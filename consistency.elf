%% Consistency relation between various contexts.


%%% Well-formedness of Field Type
%%% A field type shouldn't be borrowed.

wf-fldty : ty -> type.

wf-fldty/ : not-borrowed A -> wf-fldty (ty/ _ A _).


%%% Well-formedness of a Field Map (Helper)
%%% This says that all types in a well-formed fldmap
%%% should NOT be borrowed.

wf-fldmap : fldmap -> type.

wf-fldmap/0 : wf-fldmap fldmap/0.

wf-fldmap/U :
    wf-fldmap FM' ->
    wf-fldty T ->
    fldmap`fresh FM' F ->
    fldmap`update FM' F T FM ->
  wf-fldmap FM.


%%% Well-formed Class Map
%%% 1, All field map in the class map has to be well-formed.
%%% 2, the class map should contain an entry for the special world object.

wf-clsmap : clsmap -> type.

wf-clsmap/0 : wf-clsmap clsmap/0.

wf-clsmap/U :
    wf-clsmap CM' ->
    wf-fldmap FM ->
    fldmap`size FM (s _) ->
    clsmap`fresh CM' C ->
    clsmap`update CM' C FM CM ->
  wf-clsmap CM.


%%% Consistency between a class map and a type.
%%% Check if the class ID is in clsmap

clsmap-ty : clsmap -> ty -> type.

clsmap-ty/ : clsmap`lookup CM C _ -> clsmap-ty CM (ty/ _ _ C).


%%% Consistency between a class map and a method type.
%%% Check if all types appear in methty is also in clsmap

clsmap-methty : clsmap -> methty -> type.

clsmap-methty/base :
    clsmap-ty CM T -> clsmap-methty CM (methty/base T).

clsmap-methty/args :
    clsmap-methty CM A ->
    clsmap-ty CM T ->
  clsmap-methty CM (methty/arg T _ A).


%%% Consistency between a class map and a field map.
%%% Check if a fldmap is consistent with a clsmap.

clsmap-fldmap : clsmap -> fldmap -> type.

clsmap-fldmap/0 : clsmap-fldmap _ fldmap/0.

clsmap-fldmap/+ :
    clsmap-fldmap CM FM ->
    clsmap-ty CM T ->
  clsmap-fldmap CM (fldmap/+ _ T FM).


%%% Well-formedness of a class map
%%% Check if a clsmap is consistent with itself.

clsmap-clsmap : clsmap -> clsmap -> type.

clsmap-clsmap/0 : clsmap-clsmap _ clsmap`map/0.

clsmap-clsmap/+ :
    clsmap-clsmap CM0 CMS ->
    clsmap`shift C CM CMS ->
    clsmap-fldmap CM0 FM ->
    clsmap`lookup CM0 C FM ->
  clsmap-clsmap CM0 (clsmap`map/+ C FM CM).

%%% Consistency between a class map and a method map.
%%% Check if a clsmap is consistent with a methmap

clsmap-methmap : clsmap -> methmap -> type.

clsmap-methmap/0 : clsmap-methmap _ methmap`map/0.

clsmap-methmap/meth :
    clsmap-methmap CM MMS ->
    methmap`shift N MM MMS ->
    clsmap-methty CM MT ->
    clsmap`fresh CM N ->
  clsmap-methmap CM (methmap`map/+ N MT MM).

clsmap-methmap/const :
    clsmap-methmap CM MMS ->
    methmap`shift N MM MMS ->
    clsmap-methty CM MT ->
    clsmap`lookup CM N _ ->
  clsmap-methmap CM (methmap`map/+ N (methty/arg (ty/ nonnull/yes _ N) _ MT) MM).


%%% Consistency between clsmap and explicit context.
%%% All entries in the context should be either shared or borrowed.

clsmap-cxt : clsmap -> cxt -> type.

clsmap-cxt/0 : clsmap-cxt _ cxt/0.

clsmap-cxt/U :
    clsmap-cxt CM B' ->
    clsmap-ty CM T ->
    cxt`fresh B' N ->
    cxt`update B' N (cxt-info/ _ T) B ->
  clsmap-cxt CM B.


%%% Whether all object ids in the set are of the same class C.

same-class : cxt -> set -> nat -> type.

same-class/0 : same-class _ set/0 _.

same-class/U :
    same-class B S' C ->
    set`not-member S' N ->
    set`add S' N S ->
    cxt`lookup B N (cxt-info/ _ (ty/ _ _ C)) ->
  same-class B S C.


%%% The least nonnull-ness in a context.

least-nonnull : cxt -> set -> nn -> type.

least-nonnull/0 : least-nonnull _ set/0 _.

least-nonnull/U :
    least-nonnull B S' NN ->
    set`not-member S' N ->
    set`add S' N S ->
    cxt`lookup B N (cxt-info/ O (ty/ NN' _ _)) ->
    nonnull`leq NN NN' ->
  least-nonnull B S NN.


%%% This relation says all "pairs" (obj,fld) in the keyset of capmap are valid:
%%% i.e., you can find obj in the context B with class id C, find C
%%% in the clsmap CM with FM, and find fld in FM with type T.

clsmap-cxt-capmap : clsmap -> cxt -> capmap -> type.

clsmap-cxt-capmap/0 : clsmap-cxt-capmap _ _ capmap/0.

clsmap-cxt-capmap/z :
    clsmap-cxt-capmap CM B M' ->
    capmap`fresh M' shared ->
    capmap`update M' shared _ M ->
  clsmap-cxt-capmap CM B M.

clsmap-cxt-capmap/U :
    clsmap-cxt-capmap CM B M' ->
    nat2pair (s K) (pair/ N F) ->
    cxt`lookup B N (cxt-info/ _ (ty/ _ _ C)) ->
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F T ->
    capmap`fresh M' (s K) ->
    capmap`update M' (s K) _ M ->
  clsmap-cxt-capmap CM B M.

%%% This relation likes the one above, except all elements in the
%%% set are objs. So, we just need them to be in the context B.
%%% This is very similar to same-class, but weaker.

clsmap-cxt-objset : clsmap -> cxt -> set -> type.

clsmap-cxt-objset/0 : clsmap-cxt-objset _ _ set/0.

clsmap-cxt-objset/U :
    clsmap-cxt-objset CM B S' ->
    cxt`lookup B N (cxt-info/ O (ty/ _ _ C)) ->
    clsmap`lookup CM C FM ->
    set`not-member S' N ->
    set`add S' N S ->
  clsmap-cxt-objset CM B S.


cxt-unique-objset : cxt -> nonnull -> nat -> set -> type.

cxt-unique-objset/0 : cxt-unique-objset _ _ _ set/0.

cxt-unique-objset/U :
    cxt-unique-objset B NN C S' ->
    cxt`lookup B N (cxt-info/ _ (ty/ NN' A C)) ->
    unique-or-borrow A ->
    nonnull`leq NN NN' ->
    set`not-member S' N ->
    set`add S' N S ->
  cxt-unique-objset B NN C S.


%%% Well-formed Unique Targets
%%% The only restriction is at least one of objset or fldset
%%% needs to be non-empty.

wf-unique-targets : targets -> type.

wf-unique-targets/1 : wf-unique-targets (targets/unique (set/+ _ _) capmap/0).

wf-unique-targets/2 : wf-unique-targets (targets/unique _ (capmap/+ _ _ _)).



%%% Well-formed Reftype
%%% 1, The objset should contain all unique objects, which have the same class
%%% ID, and conform to the least nonnull-ness
%%% 2, The fldset should also be consistent with the context.
%%% TODO: perhaps we should restrict all object IDs in the fldset to be
%%%  unique as well?

clsmap-cxt-reftype : clsmap -> cxt -> reftype -> type.

clsmap-cxt-reftype/shared :
    clsmap`lookup CM C _ ->
  clsmap-cxt-reftype CM _ (reftype/ NN C targets/shared).

clsmap-cxt-reftype/unique :
    clsmap`lookup CM C _ ->
    cxt-unique-objset B NN C OS ->
    clsmap-cxt-capmap CM B M ->
    wf-unique-targets (targets/unique OS M) ->
  clsmap-cxt-reftype CM B (reftype/ NN C (targets/unique OS M)).


clsmap-env : clsmap -> env -> type.

clsmap-env/ :
    clsmap-cxt CM B ->
    clsmap-cxt-capmap CM B M ->
  clsmap-env CM (env/ B M).


targets-capmap : targets -> capmap -> type.

targets-capmap/shared : targets-capmap targets/shared _.

targets-capmap/unique :
   capmap`disjoint M1 M2 ->
  targets-capmap (targets/unique _ M1) M2.



clsmap-result : clsmap -> result K -> type.

clsmap-result/exists :
    ({o} clsmap-result CM (Rslt o)) ->
  clsmap-result CM (result/exists [o] (Rslt o)).

clsmap-result/expr :
    clsmap-cxt CM B ->
    targets-capmap G M ->
    clsmap-cxt-reftype CM B (reftype/ NN C G) ->
    clsmap-cxt-capmap CM B M ->
  clsmap-result CM (result/expr (reftype/ NN C G) (env/ B M)).


%%% Theorems

% least-nonnull

%theorem least-nonnull-respects-eq
  : forall* {B} {S} {NN} {B'} {S'} {NN'}
    forall {_: least-nonnull B S NN}
    {BE: cxt`eq B B'} {SE: set`eq S S'}
    {NNE: nonnull`eq NN NN'}
    exists {_: least-nonnull B' S' NN'}
    true.

- : least-nonnull-respects-eq FLN cxt`eq/ set`eq/ nonnull`eq/ FLN.

%worlds (objvar) (least-nonnull-respects-eq _ _ _ _ _).
%total { } (least-nonnull-respects-eq _ _ _ _ _).


%theorem least-nonnull/U-inversion
  : forall* {B} {S} {NN} {S'} {N}
    forall {B-S-NN: least-nonnull B S NN}
    {FS: set`not-member S' N} {AD: set`add S' N S}
    exists {O} {NN'} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN' A C))}
    {LE: nonnull`leq NN NN'} {B-S'-NN: least-nonnull B S' NN}
    true.

%theorem least-nonnull/U-inversion/L
  : forall* {S1} {N1} {S} {NN} {O1} {NN1} {A1} {C1} {B} {S'} {N} {P}
    forall {FS1: set`not-member S1 N1}
    {AD1: set`add S1 N1 S}
    {B-S-NN1: least-nonnull B S1 NN}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {LE1: nonnull`leq NN NN1}
    {FS: set`not-member S' N}
    {AD: set`add S' N S}
    {E?: nat`eq? N N1 P}
    exists {O} {NN'} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN' A C))}
    {LE: nonnull`leq NN NN'} {B-S'-NN: least-nonnull B S' NN}
    true.

- : least-nonnull/U-inversion/L
    F1 U1 B-S-NN1 BL1 LE1 F2 U2 nat`eq?/yes %{=>}% _ _ _ _ BL1 LE1 B-S-NN
    <- set`not-member-add-cancels F1 U1 F2 U2 nat`eq/ set`eq/ S1=S2
    <- least-nonnull-respects-eq B-S-NN1 cxt`eq/ S1=S2 nonnull`eq/ B-S-NN.

- : least-nonnull/U-inversion/L
    F1 U1 B-S-NN1 BL1 LE1 F2 U2 (nat`eq?/no N<>N1) %{=>}% _ _ _ _
    BL3 LE3 (least-nonnull/U B-S-NN F4 U4 BL1 LE1)
    <- set`add-commutes-converse U2 U1 N<>N1 SP U4 U3
    <- set`add-preserves-not-member-converse F2 U4 F3
    <- set`add-preserves-not-member-converse F1 U3 F4
    <- least-nonnull/U-inversion B-S-NN1 F3 U3 _ _ _ _ BL3 LE3 B-S-NN.

- : least-nonnull/U-inversion
    (least-nonnull/U B-S-NN1 F1 U1 BL1 LE1) F2 U2 _ _ _ _ BL LE B-S-NN
    <- nat`eq?-total E?
    <- least-nonnull/U-inversion/L F1 U1 B-S-NN1 BL1 LE1 F2 U2 E?
      _ _ _ _ BL LE B-S-NN.

%worlds (objvar) (least-nonnull/U-inversion _ _ _ _ _ _ _ _ _ _)
  (least-nonnull/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N N1) (least-nonnull/U-inversion N _ _ _ _ _ _ _ _ _)
  (least-nonnull/U-inversion/L _ _ N1 _ _ _ _ _ _ _ _ _ _ _ _).


%% clsmap, fldmap, methmap, etc.

%theorem false-implies-wf-fldmap
  : forall {F:void} {FM}
    exists {WF-FM: wf-fldmap FM}
    true.

%worlds () (false-implies-wf-fldmap _ _ _).
%total { } (false-implies-wf-fldmap _ _ _).


%theorem wf-fldmap-respects-eq
  : forall* {FM} {FM'}
    forall {WF-FM: wf-fldmap FM}
    {E: fldmap`eq FM FM'}
    exists {WF-FM': wf-fldmap FM'}
    true.

- : wf-fldmap-respects-eq WF-FM fldmap`eq/ WF-FM.

%worlds () (wf-fldmap-respects-eq _ _ _).
%total { } (wf-fldmap-respects-eq _ _ _).


%theorem false-implies-wf-clsmap
  : forall {F:void} {CM}
    exists {WF-CM: wf-clsmap CM}
    true.

%worlds () (false-implies-wf-clsmap _ _ _).
%total { } (false-implies-wf-clsmap _ _ _).


%theorem wf-clsmap-respects-eq
  : forall* {CM} {CM'}
    forall {WF-CM: wf-clsmap CM}
    {E: clsmap`eq CM CM'}
    exists {WF-CM': wf-clsmap CM'}
    true.

- : wf-clsmap-respects-eq WF-CM clsmap`eq/ WF-CM.

%worlds () (wf-clsmap-respects-eq _ _ _).
%total { } (wf-clsmap-respects-eq _ _ _).


%theorem wf-clsmap/U-inversion
  : forall* {CM} {CMP} {N} {FM}
    forall {WF: wf-clsmap CM}
    {F: clsmap`fresh CMP N}
    {U: clsmap`update CMP N FM CM}
    exists {K} {WFP: wf-clsmap CMP}
    {WFFM: wf-fldmap FM}
    {SZ: fldmap`size FM (s K)}
    true.

%theorem wf-clsmap/U-inversion/L
  : forall* {CM} {CMP} {N} {FM}
    {CM1} {N1} {FM1} {P} {K1}
    forall {WF: wf-clsmap CM1}
    {F1: clsmap`fresh CM1 N1}
    {U1: clsmap`update CM1 N1 FM1 CM}
    {WFFM: wf-fldmap FM1}
    {SZ: fldmap`size FM1 (s K1)}
    {F: clsmap`fresh CMP N}
    {U: clsmap`update CMP N FM CM}
    {E?: nat`eq? N N1 P}
    exists {K} {WFCM: wf-clsmap CMP}
    {WFFM: wf-fldmap FM}
    {SZ: fldmap`size FM (s K)}
    true.

- : wf-clsmap/U-inversion/L WF1 F1 U1 WFF1 SZ F2 U2 nat`eq?/yes _ WF WFF SZ2
    <- clsmap`fresh-update-cancels F1 U1 F2 U2 nat`eq/ clsmap`eq/ FME CME
    <- wf-clsmap-respects-eq WF1 CME WF
    <- wf-fldmap-respects-eq WFF1 FME WFF
    <- fldmap`size-respects-eq SZ FME nat`eq/ SZ2.

- : wf-clsmap/U-inversion/L WF1 F1 U1 WFF1 SZ F2 U2 (nat`eq?/no N<>N0) _
    (wf-clsmap/U WF WFF1 SZ F4 U4) WFF SZ'
    <- clsmap`update-commutes-converse U2 U1 N<>N0 _ U4 U3
    <- clsmap`update-preserves-fresh-converse F2 U4 F3
    <- clsmap`update-preserves-fresh-converse F1 U3 F4
    <- wf-clsmap/U-inversion WF1 F3 U3 _ WF WFF SZ'.

- : wf-clsmap/U-inversion (wf-clsmap/U WF1 WFF1 SZ1 F1 U1) F2 U2 _ WF WFF SZ
    <- nat`eq?-total E?
    <- wf-clsmap/U-inversion/L WF1 F1 U1 WFF1 SZ1 F2 U2 E? _ WF WFF SZ.

%worlds (objvar) (wf-clsmap/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _)
  (wf-clsmap/U-inversion _ _ _ _ _ _ _).
%total (W W0)
 (wf-clsmap/U-inversion W0 _ _ _ _ _ _)
 (wf-clsmap/U-inversion/L W _ _ _ _ _ _ _ _ _ _ _).


%theorem wf-clsmap-lookup-implies-wf-fldmap
  : forall* {CM} {C} {FM}
    forall {WF-CM: wf-clsmap CM}
    {CML: clsmap`lookup CM C FM}
    exists {WF-FM: wf-fldmap FM}
    true.

- : wf-clsmap-lookup-implies-wf-fldmap WF-CM CML WF-FM
    <- clsmap`lookup-implies-fresh-update CML _ F U
    <- wf-clsmap/U-inversion WF-CM F U _ _ WF-FM SZ.

%worlds () (wf-clsmap-lookup-implies-wf-fldmap _ _ _).
%total { } (wf-clsmap-lookup-implies-wf-fldmap _ _ _).


%theorem wf-clsmap-lookup-implies-non-empty
  : forall* {CM} {C} {FM}
    forall {WF-CM: wf-clsmap CM}
    {CML: clsmap`lookup CM C FM}
    exists {K} {SZ: fldmap`size FM (s K)}
    true.

- : wf-clsmap-lookup-implies-non-empty WF-CM CML _ SZ
    <- clsmap`lookup-implies-fresh-update CML _ F U
    <- wf-clsmap/U-inversion WF-CM F U _ _ _ SZ.

%worlds () (wf-clsmap-lookup-implies-non-empty _ _ _ _).
%total { } (wf-clsmap-lookup-implies-non-empty _ _ _ _).


%theorem clsmap-ty-respects-eq
  : forall* {CM1} {CM2} {T1} {T2}
    forall {CM1-T1: clsmap-ty CM1 T1}
    {E: clsmap`eq CM1 CM2} {E: ty`eq T1 T2}
    exists {CM2-T2: clsmap-ty CM2 T2}
    true.

- : clsmap-ty-respects-eq D clsmap`eq/ ty`eq/ D.

%worlds (objvar) (clsmap-ty-respects-eq _ _ _ _).
%total {} (clsmap-ty-respects-eq _ _ _ _).


%theorem clsmap-ty-respects-leq
  : forall* {CM0} {CM1} {T}
    forall {CM0-T: clsmap-ty CM0 T}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-T: clsmap-ty CM1 T}
    true.

- : clsmap-ty-respects-leq (clsmap-ty/ L0)
    CM0<=CM1 (clsmap-ty/ L1)
    <- clsmap`lookup-respects-leq L0 CM0<=CM1 _ L1 _.

% - : clsmap-ty-respects-leq clsmap-ty/null _ clsmap-ty/null.

%worlds (objvar) (clsmap-ty-respects-leq _ _ _).
%total {} (clsmap-ty-respects-leq _ _ _).


%theorem clsmap-fldmap-respects-leq
  : forall* {CM0} {CM1} {FM}
    forall {CM0-FM: clsmap-fldmap CM0 FM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-FM: clsmap-fldmap CM1 FM}
    true.

- : clsmap-fldmap-respects-leq clsmap-fldmap/0 _ clsmap-fldmap/0.

- : clsmap-fldmap-respects-leq (clsmap-fldmap/+ CM0-FM CM0-T)
    CM0<=CM1 (clsmap-fldmap/+ CM1-FM CM1-T)
    <- clsmap-ty-respects-leq CM0-T CM0<=CM1 CM1-T
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM.

%worlds (objvar) (clsmap-fldmap-respects-leq _ _ _).
%total (CM-FM) (clsmap-fldmap-respects-leq CM-FM _ _).


%theorem clsmap-clsmap-respects-leq
  : forall* {CM0} {CM1} {CM}
    forall {CM0-CM: clsmap-clsmap CM0 CM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-CM: clsmap-clsmap CM1 CM}
    true.

- : clsmap-clsmap-respects-leq clsmap-clsmap/0 _ clsmap-clsmap/0.

- : clsmap-clsmap-respects-leq (clsmap-clsmap/+ CM0-CMS SH CM0-FM CM0-L)
    CM0<=CM1 (clsmap-clsmap/+ CM1-CMS SH CM1-FM CM1-L)
    <- clsmap`lookup-respects-leq CM0-L CM0<=CM1 _ CM1-LP EQ
    <- fldmap`eq-symmetric EQ EQP
    <- clsmap`lookup-respects-eq CM1-LP clsmap`eq/ nat`eq/ EQP CM1-L
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM
    <- clsmap-clsmap-respects-leq CM0-CMS CM0<=CM1 CM1-CMS.

%worlds (objvar) (clsmap-clsmap-respects-leq _ _ _).
%total (CM-CM) (clsmap-clsmap-respects-leq CM-CM _ _).


%theorem shift-preserves-clsmap-fldmap
  : forall* {CM} {FM} {FMP} {N}
    forall {CM-FM: clsmap-fldmap CM FM}
    {SH: fldmap`shift N FM FMP}
    exists {CM-FM: clsmap-fldmap CM FMP}
    true.

- : shift-preserves-clsmap-fldmap clsmap-fldmap/0 _ clsmap-fldmap/0.

- : shift-preserves-clsmap-fldmap
    (clsmap-fldmap/+ CM-FM CM-T) SH (clsmap-fldmap/+ CM-FM CM-T).

%worlds (objvar) (shift-preserves-clsmap-fldmap _ _ _).
%total {} (shift-preserves-clsmap-fldmap _ _ _).


%{ This theorem says if under a "bigger" clsmap CM0, CM
 is well-defined, and class C in CM has fldmap FM, then all
 classes in FM is well-defined under CM0 }%

%theorem lookup-implies-clsmap-fldmap
  : forall* {M} {CM} {FM} {C}
    forall {M-CM: clsmap-clsmap M CM}
    {L: clsmap`lookup CM C FM}
    exists {M-FM: clsmap-fldmap M FM}
    true.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ _ _ M-FM _)
     (clsmap`lookup/= _) M-FM.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ M-CMP SH _ _)
     (clsmap`lookup/> L P0) M-FM
     <- nat`plus-swap-succ P0 P1
     <- nat`plus-commutative P1 P2
     <- clsmap`shift-preserves-lookup* L SH P2 L2
     <- lookup-implies-clsmap-fldmap M-CMP L2 M-FM.

%worlds (objvar) (lookup-implies-clsmap-fldmap _ _ _).
%total (M-CM) (lookup-implies-clsmap-fldmap M-CM _ _).


%theorem clsmap-fldmap/U-inversion
  : forall* {CM} {FM} {FM'} {T} {F}
    forall {CM-FM: clsmap-fldmap CM FM}
    {FS: fldmap`fresh FM' F}
    {UD: fldmap`update FM' F T FM}
    exists {CM-T: clsmap-ty CM T}
    {CM-FM: clsmap-fldmap CM FM'}
    true.

%worlds (objvar) (clsmap-fldmap/U-inversion _ _ _ _ _).
%trustme %total { } (clsmap-fldmap/U-inversion _ _ _ _ _).


%theorem lookup-implies-clsmap-ty
  : forall* {CM} {FM} {F} {T}
    forall {CM-FM: clsmap-fldmap CM FM}
    {FM-L: fldmap`lookup FM F T}
    exists {CM-NT: clsmap-ty CM T}
    true.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM CM-T)
    (fldmap`lookup/= _) CM-T.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM _)
    (fldmap`lookup/> LP _) CM-T
    <- lookup-implies-clsmap-ty CM-FM LP CM-T.

%worlds (objvar) (lookup-implies-clsmap-ty _ _ _).
%total (CM-FM) (lookup-implies-clsmap-ty CM-FM _ _).


%theorem lookup-implies-clsmap-methty
  : forall* {CM} {MM} {MT} {M}
    forall {CM-MM: clsmap-methmap CM MM}
    {MM-LP: methmap`lookup MM M MT}
    exists {CM-MT: clsmap-methty CM MT}
    true.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth _ _ CM-MT _) (methmap`lookup/= _) CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const _ _ (CM-MT) CML) (methmap`lookup/= _)
     (clsmap-methty/args CM-MT (clsmap-ty/ CML)).

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

%worlds (objvar) (lookup-implies-clsmap-methty _ _ _).
%total (L) (lookup-implies-clsmap-methty L _ _).


%%% Theorems about clsmap-cxt


%theorem false-implies-clsmap-cxt
  : forall* {CM} {B}
    forall {V:void}
    exists {CM-B: clsmap-cxt CM B}
    true.

%worlds (objvar) (false-implies-clsmap-cxt _ _).
%total { } (false-implies-clsmap-cxt _ _).


%theorem clsmap-cxt/U-inversion
  : forall* {CM} {B} {B'} {N} {O} {T}
    forall {CM-B: clsmap-cxt CM B}
    {N!<B: cxt`fresh B' N}
    {B'+N=B: cxt`update B' N (cxt-info/ O T) B}
    exists {CM-B': clsmap-cxt CM B'}
    {CM-T: clsmap-ty CM T}
    true.

%worlds () (clsmap-cxt/U-inversion _ _ _ _ _).
%trustme %total { } (clsmap-cxt/U-inversion _ _ _ _ _).


%theorem clsmap-cxt-respects-fresh-update-converse
  : forall* {CM} {B} {B'} {N} {CI}
    forall {CM-B: clsmap-cxt CM B}
    {N!<B': cxt`fresh B' N}
    {B'+N=B: cxt`update B' N CI B}
    exists {CM-B': clsmap-cxt CM B'}
    true.

%worlds () (clsmap-cxt-respects-fresh-update-converse _ _ _ _).
%trustme %total { } (clsmap-cxt-respects-fresh-update-converse _ _ _ _).


%theorem cxt-lookup-implies-clsmap-ty
  : forall* {CM} {B} {T} {O} {N}
    forall {WF-CM: wf-clsmap CM}
    {CM-B: clsmap-cxt CM B}
    {B-L: cxt`lookup B N (cxt-info/ O T)}
    exists {CM-T: clsmap-ty CM T}
    true.

%theorem cxt-lookup-implies-clsmap-ty/L
  : forall* {CM} {B} {B'} {T} {O} {T'} {O'} {N} {N'} {K}
    forall {WF-CM: wf-clsmap CM}
    {CM-B: clsmap-cxt CM B'}
    {CM-T: clsmap-ty CM T'}
    {U: cxt`update B' N' (cxt-info/ O' T') B}
    {BL: cxt`lookup B N (cxt-info/ O T)}
    {EQ?: nat`eq? N N' K}
    exists {CM-T: clsmap-ty CM T}
    true.

- : cxt-lookup-implies-clsmap-ty/L WF-CM CM-B' CM-T' U BL nat`eq?/yes CM-T
    <- cxt`update-implies-lookup U BL'
    <- cxt`lookup-unique BL' BL cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE _ TE
    <- clsmap-ty-respects-eq CM-T' clsmap`eq/ TE CM-T.

- : cxt-lookup-implies-clsmap-ty/L WF-CM CM-B' CM-T' U BL
    (nat`eq?/no (N<>N':nat`ne N N')) CM-T
    <- cxt`update-preserves-lookup-converse BL U N<>N' BL'
    <- cxt-lookup-implies-clsmap-ty WF-CM CM-B' BL' CM-T.

- : cxt-lookup-implies-clsmap-ty WF-CM
    (clsmap-cxt/U CM-B' CM-T' F U) BL CM-T
    <- nat`eq?-total EQ?
    <- cxt-lookup-implies-clsmap-ty/L WF-CM CM-B' CM-T' U BL EQ? CM-T.

%worlds (objvar) (cxt-lookup-implies-clsmap-ty _ _ _ _)
  (cxt-lookup-implies-clsmap-ty/L _ _ _ _ _ _ _).
%total (CM-B CM-B') (cxt-lookup-implies-clsmap-ty _ CM-B _ _)
  (cxt-lookup-implies-clsmap-ty/L _ CM-B' _ _ _ _ _).


%theorem cxt-lookup-obj-implies-clsmap-ty
  : forall* {CM} {B} {T} {N} {O}
    forall {WF-CM: wf-clsmap CM}
    {CM-B: clsmap-cxt CM B}
    {B-L: cxt`lookup-obj B O N T}
    exists {CM-T: clsmap-ty CM T}
    true.

- : cxt-lookup-obj-implies-clsmap-ty WF-CM CM-B (cxt`lookup-obj/ BL) CM-T
    <- cxt-lookup-implies-clsmap-ty WF-CM CM-B BL CM-T.

%worlds (objvar) (cxt-lookup-obj-implies-clsmap-ty _ _ _ _).
%total (CM-B) (cxt-lookup-obj-implies-clsmap-ty _ CM-B _ _).


% %theorem clsmap-cxt-objset-implies-objset2fldset
%   : forall* {CM} {B} {OS}
%     forall {CM-B-S: clsmap-cxt-objset CM B OS}
%     exists {S} {CV: objset2fldset CM B OS S}
%     true.

% - : clsmap-cxt-objset-implies-objset2fldset
%     clsmap-cxt-objset/0 _ objset2fldset/0.

% - : clsmap-cxt-objset-implies-objset2fldset
%     (clsmap-cxt-objset/U CM-B-S' BL CML F U)
%     _ (objset2fldset/U CV' BL CML DM R SU F U)
%     <- clsmap-cxt-objset-implies-objset2fldset CM-B-S' _ CV'
%     <- fldmap`domain-total DM
%     <- nat+set2set-total R
%     <- set`union-total SU.

% %worlds (objvar) (clsmap-cxt-objset-implies-objset2fldset _ _ _).
% %total (R) (clsmap-cxt-objset-implies-objset2fldset R _ _).


% %theorem objset2fldset-preserves-clsmap-cxt-capmap
%   : forall* {CM} {B} {OS} {S}
%     forall {CM-B-OS: clsmap-cxt-objset CM B OS}
%     {CV: objset2fldset CM B OS S}
%     exists {CM-B-S: clsmap-cxt-capmap CM B S}
%     true.

% - : objset2fldset-preserves-clsmap-cxt-capmap
%     clsmap-cxt-objset/0 objset2fldset/0 clsmap-cxt-capmap/0.

% % - : objset2fldset-preserves-clsmap-cxt-capmap
% %     CM-B-OS (objset2fldset/U CV' BL CML DM R U F A) KKK
% %     <- clsmap-cxt-objset/U-inversion CM-B-OS F A CM-B-OS' _ _ _ _ BL _ CML.
% %      objset2fldset/0 clsmap-cxt-capmap/0.

% %worlds (objvar) (objset2fldset-preserves-clsmap-cxt-capmap _ _ _).
% %trustme %total {} (objset2fldset-preserves-clsmap-cxt-capmap _ _ _).


% %theorem objset2fldset-respects-eq
%   : forall* {CM0} {B0} {OS0} {CM1} {B1} {OS1} {S0} {S1}
%     forall {CV0: objset2fldset CM0 B0 OS0 S0}
%     {CME: clsmap`eq CM0 CM1} {BE: cxt`eq B0 B1}
%     {OSE: set`eq OS0 OS1}  {SE: set`eq S0 S1}
%     exists {CV1: objset2fldset CM1 B1 OS1 S1}
%     true.


% - : objset2fldset-respects-eq CV clsmap`eq/ cxt`eq/
%     set`eq/ set`eq/ CV.

% %worlds (objvar) (objset2fldset-respects-eq _ _ _ _ _ _).
% %total { } (objset2fldset-respects-eq _ _ _ _ _ _).


% %theorem objset2fldset-unique
%   : forall* {CM0} {B0} {OS0} {CM1} {B1} {OS1} {S0} {S1}
%     forall {CV0: objset2fldset CM0 B0 OS0 S0}
%     {CV1: objset2fldset CM1 B1 OS1 S1}
%     {CME: clsmap`eq CM0 CM1} {BE: cxt`eq B0 B1}
%     {OSE: set`eq OS0 OS1}
%     exists {SE: set`eq S0 S1}
%     true.

% %worlds (objvar) (objset2fldset-unique _ _ _ _ _ _).
% %trustme %total { } (objset2fldset-unique _ _ _ _ _ _).


% %theorem objset2fldset-preserves-leq*
%   : forall* {CM} {B} {OS0} {OS1} {S0} {S1}
%     forall {OS0<=OS1: set`leq OS0 OS1}
%     {CV0: objset2fldset CM B OS0 S0}
%     {CV1: objset2fldset CM B OS1 S1}
%     exists {S0<=S1: set`leq S0 S1}
%     true.

% %worlds (objvar) (objset2fldset-preserves-leq* _ _ _ _).
% %trustme %total { } (objset2fldset-preserves-leq* _ _ _ _).


% %theorem objset2fldset-preserves-disjoint
%   : forall* {CM} {B} {OS0} {OS1} {S0} {S1}
%     forall {CV0: objset2fldset CM B OS0 S0}
%     {CV0: objset2fldset CM B OS1 S1}
%     {DJ: set`disjoint OS0 OS1}
%     exists {DJ: set`disjoint S0 S1}
%     true.

% %worlds (objvar) (objset2fldset-preserves-disjoint _ _ _ _).
% %trustme %total {} (objset2fldset-preserves-disjoint _ _ _ _).


% %theorem objset2fldset-commutes-disjoint-join
%   : forall* {CM} {B} {OS0} {OS1} {S0} {S1} {OS}
%     forall {OS1^OS2: set`disjoint OS0 OS1}
%     {OS1uOS2=OS: set`union OS0 OS1 OS}
%     {CV0: objset2fldset CM B OS0 S0}
%     {CV0: objset2fldset CM B OS1 S1}
%     exists {S} {DJ: set`disjoint S0 S1}
%     {U: set`union S0 S1 S}
%     {CV: objset2fldset CM B OS S}
%     true.

% %worlds (objvar) (objset2fldset-commutes-disjoint-join _ _ _ _ _ _ _ _).
% %trustme %total {} (objset2fldset-commutes-disjoint-join _ _ _ _ _ _ _ _).


% %theorem objset2fldset-commutes-disjoint-join*
%   : forall* {CM} {B} {OS0} {OS1} {S0} {S1} {OS} {S}
%     forall {OS1^OS2: set`disjoint OS0 OS1}
%     {OS1uOS2=OS: set`union OS0 OS1 OS}
%     {CV0: objset2fldset CM B OS0 S0}
%     {CV0: objset2fldset CM B OS1 S1}
%     {CV: objset2fldset CM B OS S}
%     exists {DJ: set`disjoint S0 S1}
%     {U: set`union S0 S1 S}
%     true.

% %worlds (objvar) (objset2fldset-commutes-disjoint-join* _ _ _ _ _ _ _).
% %trustme %total {} (objset2fldset-commutes-disjoint-join* _ _ _ _ _ _ _).


% %theorem clsmap-cxt-effects-respects-eq
%   : forall* {CM} {CM'} {B} {B'} {XX} {XX'}
%     forall {CM-B-XX: clsmap-cxt-effects CM B XX}
%     {CME: clsmap`eq CM CM'} {BE: cxt`eq B B'}
%     {XXE: effects`eq XX XX'}
%     exists {CM-B-XX': clsmap-cxt-effects CM' B' XX'}
%     true.

% - : clsmap-cxt-effects-respects-eq
%     CM-B-XX clsmap`eq/ cxt`eq/ effects`eq/ CM-B-XX.

% %worlds (objvar) (clsmap-cxt-effects-respects-eq _ _ _ _ _).
% %total {} (clsmap-cxt-effects-respects-eq _ _ _ _ _).


%theorem same-class-respects-eq
  : forall* {B} {BP} {S} {SP} {C} {CP}
    forall {SOC: same-class B S C}
    {E: cxt`eq B BP} {E: set`eq S SP}
    {E: nat`eq C CP}
    exists {SOC: same-class BP SP CP}
    true.

- : same-class-respects-eq SOC cxt`eq/ set`eq/ nat`eq/ SOC.

%worlds (objvar) (same-class-respects-eq _ _ _ _ _).
%total {} (same-class-respects-eq _ _ _ _ _).


%theorem clsmap-cxt-capmap-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {S1} {S2}
    forall {CM1-B1-S1: clsmap-cxt-capmap CM1 B1 S1}
    {EQ: clsmap`eq CM1 CM2} {EQ: cxt`eq B1 B2} {EQ: capmap`eq S1 S2}
    exists {CM2-B2-S2: clsmap-cxt-capmap CM2 B2 S2}
    true.

- : clsmap-cxt-capmap-respects-eq A clsmap`eq/ cxt`eq/ capmap`eq/ A.

%worlds (objvar) (clsmap-cxt-capmap-respects-eq _ _ _ _ _).
%total {} (clsmap-cxt-capmap-respects-eq _ _ _ _ _).


%theorem clsmap-cxt-objset-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {S1} {S2}
    forall {CM1-B1-S1: clsmap-cxt-objset CM1 B1 S1}
    {EQ: clsmap`eq CM1 CM2}
    {EQ: cxt`eq B1 B2} {EQ: set`eq S1 S2}
    exists {CM2-B2-S2: clsmap-cxt-objset CM2 B2 S2}
    true.

- : clsmap-cxt-objset-respects-eq A clsmap`eq/ cxt`eq/ set`eq/ A.

%worlds (objvar) (clsmap-cxt-objset-respects-eq _ _ _ _ _).
%total {} (clsmap-cxt-objset-respects-eq _ _ _ _ _).


%theorem same-class/U-inversion
  : forall* {B} {S} {SP} {C} {N}
    forall {SOC: same-class B S C}
    {NM: set`not-member SP N}
    {AD: set`add SP N S}
    exists {O} {NN} {A} {SOC: same-class B SP C}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    true.

%theorem same-class/U-inversion/L
  : forall* {B} {S} {SP1} {C} {N1} {A1} {NN1} {SP} {N} {P} {O1}
    forall {SOC: same-class B SP1 C}
    {NM1: set`not-member SP1 N1}
    {AD1: set`add SP1 N1 S}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C))}
    {NM: set`not-member SP N}
    {AD: set`add SP N S}
    {EQ?: nat`eq? N N1 P}
    exists {O} {NN} {A} {SOC: same-class B SP C}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    true.

- : same-class/U-inversion/L
    SOC0 F0 U0 BL0 F1 U1 nat`eq?/yes _ _ _ SOC1 BL0
    <- set`not-member-add-cancels F0 U0 F1 U1 nat`eq/ set`eq/ S0=S1
    <- same-class-respects-eq SOC0 cxt`eq/ S0=S1 nat`eq/ SOC1.

- : same-class/U-inversion/L
    SOC0 F0 U0 BL0 F1 U1 (nat`eq?/no N<>N1) _ _ _
    (same-class/U SOC2 F3 U3 BL0) BL2
    <- set`update-commutes-converse U1 U0 N<>N1 _ U3 U2
    <- set`add-preserves-not-member-converse F1 U3 F2
    <- set`add-preserves-not-member-converse F0 U2 F3
    <- same-class/U-inversion SOC0 F2 U2 _ _ _ SOC2 BL2.

- : same-class/U-inversion
    (same-class/U SOC0 F0 A0 BL0) F1 A1 _ _ _ SOC1 BL1
    <- nat`eq?-total E?
    <- same-class/U-inversion/L SOC0 F0 A0 BL0 F1 A1 E? _ _ _ SOC1 BL1.

%worlds (objvar) (same-class/U-inversion _ _ _ _ _ _ _ _)
	(same-class/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (same-class/U-inversion C0 _ _ _ _ _ _ _)
	(same-class/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _).



%%% Theorems about clsmap-cxt-capmap

%theorem false-implies-clsmap-cxt-capmap
  : forall* {CM} {B} {S} forall {F:void} exists {CBS: clsmap-cxt-capmap CM B S}
    true.

%worlds (objvar) (false-implies-clsmap-cxt-capmap _ _).
%total { } (false-implies-clsmap-cxt-capmap _ _).


%theorem clsmap-cxt-capmap/z-inversion
  : forall* {CM} {B} {S} {S'} {X}
    forall {CM-B-S: clsmap-cxt-capmap CM B S}
    {NM: capmap`fresh S' shared}
    {AD: capmap`update S' shared X S}
    exists {CM-B-S': clsmap-cxt-capmap CM B S'}
    true.

- : clsmap-cxt-capmap/z-inversion
    (clsmap-cxt-capmap/U CM-B-S N2P BL CML FML F1 U1) F U
    (clsmap-cxt-capmap/U CM-B-S2 N2P BL CML FML F3 U3)
    <- nat`succ-implies-gt-zero _ GT
    <- capmap`update-commutes-converse U U1 (nat`ne/< GT) M U3 U2
    <- capmap`update-preserves-fresh-converse F U3 F2
    <- capmap`update-preserves-fresh-converse F1 U2 F3
    <- clsmap-cxt-capmap/z-inversion CM-B-S F2 U2 CM-B-S2.

- : clsmap-cxt-capmap/z-inversion
    (clsmap-cxt-capmap/z CM-B-S F1 U1) F U CM-B-S'
    <- capmap`fresh-update-cancels F1 U1 F U nat`eq/ capmap`eq/ _ S1=S
    <- clsmap-cxt-capmap-respects-eq CM-B-S clsmap`eq/ cxt`eq/ S1=S CM-B-S'.

%worlds (objvar) (clsmap-cxt-capmap/z-inversion _ _ _ _).
%total (A) (clsmap-cxt-capmap/z-inversion A _ _ _).


%%% here K has to be a positive number, since nat`z is taken by shared.

%theorem clsmap-cxt-capmap/U-inversion
  : forall* {CM} {B} {S} {S'} {K} {X}
    forall {CM-B-S: clsmap-cxt-capmap CM B S}
    {NM: capmap`fresh S' (s K)}
    {AD: capmap`update S' (s K) X S}
    exists {CM-B-S': clsmap-cxt-capmap CM B S'}
    {N} {F} {N+F=>K: nat2pair (s K) (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    {T} {FML: fldmap`lookup FM F T}
    true.

- : clsmap-cxt-capmap/U-inversion
    (clsmap-cxt-capmap/z CM-B-S F1 U1) F U
    (clsmap-cxt-capmap/z CM-B-S2 F3 U3) _ _ N2P2 _ _ _ _ BL2 _ CML2 _ FML2
    <- nat`succ-implies-gt-zero _ GT
    <- capmap`update-commutes-converse U U1 (nat`ne/> GT) M U3 U2
    <- capmap`update-preserves-fresh-converse F U3 F2
    <- capmap`update-preserves-fresh-converse F1 U2 F3
    <- clsmap-cxt-capmap/U-inversion CM-B-S F2 U2 CM-B-S2
      _ _ N2P2 _ _ _ _ BL2 _ CML2 _ FML2.

%theorem clsmap-cxt-capmap/U-inversion/L
  : forall* {CM} {B} {S} {S'} {S1'} {K} {K1} {O1} {NN1}
    {A1} {C1} {FM1} {P} {N1} {F1} {T1} {X1} {X}
    forall {CM-B-S: clsmap-cxt-capmap CM B S1'}
    {NM1: capmap`fresh S1' (s K1)}
    {AD1: capmap`update S1' (s K1) X1 S}
    {K1=>N1+F1: nat2pair (s K1) (pair/ N1 F1)}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {CML1: clsmap`lookup CM C1 FM1}
    {FML1: fldmap`lookup FM1 F1 T1}
    {NM: capmap`fresh S' (s K)}
    {AD: capmap`update S' (s K) X S}
    {EQ?: nat`eq? (s K) (s K1) P}
    exists {CM-B-S': clsmap-cxt-capmap CM B S'}
    {N} {F} {K=>N+F: nat2pair (s K) (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    {T} {FML: fldmap`lookup FM F T}
    true.

- : clsmap-cxt-capmap/U-inversion/L CM-B-S F1 U1 N2P1 BL1 CML1 FML1 F U
    nat`eq?/yes CM-B-S' _ _ N2P1 _ _ _ _ BL1 _ CML1 _ FML1
    <- capmap`fresh-update-cancels F1 U1 F U nat`eq/ capmap`eq/ _ S1=S
    <- clsmap-cxt-capmap-respects-eq CM-B-S clsmap`eq/ cxt`eq/ S1=S CM-B-S'.

- : clsmap-cxt-capmap/U-inversion/L CM-B-S F1 U1 N2P BL CML FML
    F U (nat`eq?/no N<>N1) (clsmap-cxt-capmap/U CM-B-S2 N2P BL CML FML F3 U3)
    _ _ N2P2 _ _ _ _ BL2 _ CML2 _ FML2
    <- capmap`update-commutes-converse U U1 N<>N1 _ U3 U2
    <- capmap`update-preserves-fresh-converse F U3 F2
    <- capmap`update-preserves-fresh-converse F1 U2 F3
    <- clsmap-cxt-capmap/U-inversion CM-B-S F2 U2 CM-B-S2
      _ _ N2P2 _ _ _ _ BL2 _ CML2 _ FML2.

- : clsmap-cxt-capmap/U-inversion
    (clsmap-cxt-capmap/U CM-B-S0 N2P0 BL0 CML0 FML0 F0 U0) F1 U1
    CM-B-S1 _ _ N2P1 _ _ _ _ BL1 _ CML1 _ FML1
    <- nat`eq?-total E?
    <- clsmap-cxt-capmap/U-inversion/L CM-B-S0 F0 U0 N2P0 BL0 CML0 FML0
      F1 U1 E? CM-B-S1 _ _ N2P1 _ _ _ _ BL1 _ CML1 _ FML1.

%worlds (objvar) (clsmap-cxt-capmap/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-capmap/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (clsmap-cxt-capmap/U-inversion C0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-capmap/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem join-preserves-clsmap-cxt-capmap
  : forall* {CM} {B} {S1} {S2} {S}
    forall {CM-B-S1: clsmap-cxt-capmap CM B S1}
    {CM-B-S2: clsmap-cxt-capmap CM B S2}
    {J: capmap`join S1 S2 S}
    exists {CM-B-S: clsmap-cxt-capmap CM B S}
    true.

%theorem join-preserves-clsmap-cxt-capmap/L
  : forall* {CM} {B} {S1} {S2} {S}
    forall {N} {SZ: capmap`size S N}
    {CM-B-S1: clsmap-cxt-capmap CM B S1}
    {CM-B-S2: clsmap-cxt-capmap CM B S2}
    {J: capmap`join S1 S2 S}
    exists {CM-B-S: clsmap-cxt-capmap CM B S}
    true.

%theorem join-preserves-clsmap-cxt-capmap/LL
  : forall* {CM} {B} {S1} {S2} {S} {SP} {K} {B1} {B2} {X}
    forall {N} {SZ: capmap`size S N}
    {CM-B-S1: clsmap-cxt-capmap CM B S1}
    {CM-B-S2: clsmap-cxt-capmap CM B S2}
    {J: capmap`join S1 S2 S}
    {F: capmap`fresh SP K}
    {A: capmap`update SP K X S}
    {D1?: capmap`domain? S1 K B1}
    {D2?: capmap`domain? S2 K B2}
    exists {CM-B-S: clsmap-cxt-capmap CM B S}
    true.

- : join-preserves-clsmap-cxt-capmap/L
    _ capmap`size/0 clsmap-cxt-capmap/0 CBS capmap`join/L CBS.

- : join-preserves-clsmap-cxt-capmap/L
    _ capmap`size/0 CBS clsmap-cxt-capmap/0 capmap`join/R CBS.

    % <- cap`join-total DJP
    % <- capmap`join-joins-lookup* L1 L2 SU DJP LP
    % <- capmap`lookup-unique LP L capmap`eq/ nat`eq/ DE
    % <- cap`join-respects-eq DJP cap`eq/ cap`eq/ DE DJ

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/in (L1:capmap`lookup S1 shared Xx1))
    (capmap`domain?/in (L2:capmap`lookup S2 shared Xx2))
    (clsmap-cxt-capmap/z CBSP F U)
    <- capmap`lookup-implies-fresh-update L1 S1P F1 U1
    <- capmap`lookup-implies-fresh-update L2 S2P F2 U2
    <- capmap`update-implies-lookup U (L:capmap`lookup S shared Xx)
    <- capmap`fresh-update-preserves-join-converse* F1 U1 F2 U2 SU F U DJ SUP
    <- clsmap-cxt-capmap/z-inversion CBS1 F1 U1 CBS1P
    <- clsmap-cxt-capmap/z-inversion CBS2 F2 U2 CBS2P
    <- capmap`fresh-update-increases-size-converse Z F U ZP
    <- join-preserves-clsmap-cxt-capmap/L _ ZP CBS1P CBS2P SUP CBSP.

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/in _) (capmap`domain?/out F2)
    (clsmap-cxt-capmap/z CBSP F U)
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-join-right-preserves-lookup-converse L F2 SU L1
    <- capmap`lookup-implies-fresh-update L1 _ F1 U1
    <- clsmap-cxt-capmap/z-inversion CBS1 F1 U1 CBS1P
    <- capmap`fresh-update-left-preserves-join-converse* F1 U1 F2 SU F U SU1
    <- capmap`fresh-update-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capmap/L _ Z1 CBS1P CBS2 SU1 CBSP.

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/out F1) (capmap`domain?/in _)
    (clsmap-cxt-capmap/z CBSP F U)
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-join-left-preserves-lookup-converse F1 L SU L2
    <- capmap`lookup-implies-fresh-update L2 _ F2 U2
    <- clsmap-cxt-capmap/z-inversion CBS2 F2 U2 CBS2P
    <- capmap`fresh-update-right-preserves-join-converse* F1 F2 U2 SU F U SU2
    <- capmap`fresh-update-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capmap/L _ Z1 CBS1 CBS2P SU2 CBSP.

- : join-preserves-clsmap-cxt-capmap/LL _ _ _ _ SU _ U
    (capmap`domain?/out F1) (capmap`domain?/out F2) %{=>}% CBS
    <- capmap`join-preserves-fresh* F1 F2 SU F
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-clsmap-cxt-capmap V CBS.

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/in (L1:capmap`lookup S1 (s K) Xx1))
    (capmap`domain?/in (L2:capmap`lookup S2 (s K) Xx2))
    (clsmap-cxt-capmap/U CBSP P2N2 BL2 CML2 FML2 F U)
    <- capmap`lookup-implies-fresh-update L1 S1P F1 U1
    <- capmap`lookup-implies-fresh-update L2 S2P F2 U2
    <- capmap`update-implies-lookup U (L:capmap`lookup S (s K) Xx)
    <- capmap`fresh-update-preserves-join-converse* F1 U1 F2 U2 SU F U DJ SUP
    <- clsmap-cxt-capmap/U-inversion CBS1 F1 U1
      CBS1P N1 FD1 P2N1 O1 NN1 A1 C1 BL1 FM1 CML1 T1 FML1
    <- clsmap-cxt-capmap/U-inversion CBS2 F2 U2
      CBS2P N2 FD2 P2N2 O2 NN2 A2 C2 BL2 FM2 CML2 T2 FML2
    <- capmap`fresh-update-increases-size-converse Z F U ZP
    <- join-preserves-clsmap-cxt-capmap/L _ ZP CBS1P CBS2P SUP CBSP.

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/in _) (capmap`domain?/out F2)
    (clsmap-cxt-capmap/U CBSP P2N1 BL1 CML1 FML1 F U)
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-join-right-preserves-lookup-converse L F2 SU L1
    <- capmap`lookup-implies-fresh-update L1 _ F1 U1
    <- clsmap-cxt-capmap/U-inversion
      CBS1 F1 U1 CBS1P _ _ P2N1 _ _ _ _ BL1 _ CML1 _ FML1
    <- capmap`fresh-update-left-preserves-join-converse* F1 U1 F2 SU F U SU1
    <- capmap`fresh-update-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capmap/L _ Z1 CBS1P CBS2 SU1 CBSP.

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/out F1) (capmap`domain?/in _) %{=>}%
    (clsmap-cxt-capmap/U CBSP P2N2 BL2 CML2 FML2 F U)
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-join-left-preserves-lookup-converse F1 L SU L2
    <- capmap`lookup-implies-fresh-update L2 _ F2 U2
    <- clsmap-cxt-capmap/U-inversion
      CBS2 F2 U2 CBS2P _ _ P2N2 _ _ _ _ BL2 _ CML2 _ FML2
    <- capmap`fresh-update-right-preserves-join-converse* F1 F2 U2 SU F U SU2
    <- capmap`fresh-update-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capmap/L _ Z1 CBS1 CBS2P SU2 CBSP.

- : join-preserves-clsmap-cxt-capmap/LL _ _ _ _ SU _ U
    (capmap`domain?/out F1) (capmap`domain?/out F2) %{=>}% CBS
    <- capmap`join-preserves-fresh* F1 F2 SU F
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-clsmap-cxt-capmap V CBS.

- : join-preserves-clsmap-cxt-capmap/L (s N) Z CBS1 CBS2 SU CBS
    <- capmap`lookup-implies-fresh-update (capmap`lookup/= nat`eq/) _ F U
    <- capmap`domain?-total D1?
    <- capmap`domain?-total D2?
    <- join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U D1? D2? CBS.

%worlds (objvar) (join-preserves-clsmap-cxt-capmap/LL _ _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-capmap/L _ _ _ _ _ _).
%total (N1 N2) (join-preserves-clsmap-cxt-capmap/LL N1 _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-capmap/L N2 _ _ _ _ _).

- : join-preserves-clsmap-cxt-capmap CBS1 CBS2 U CBS
    <- capmap`size-total Z
    <- join-preserves-clsmap-cxt-capmap/L _ Z CBS1 CBS2 U CBS.

%worlds (objvar) (join-preserves-clsmap-cxt-capmap _ _ _ _).
%total {} (join-preserves-clsmap-cxt-capmap _ _ _ _).


%theorem clsmap-cxt-objset/U-inversion
  : forall* {CM} {B} {S} {S'} {N}
    forall {CM-B-S: clsmap-cxt-objset CM B S}
    {NM: set`not-member S' N}
    {AD: set`add S' N S}
    exists {CM-B-S': clsmap-cxt-objset CM B S'}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    true.

%theorem clsmap-cxt-objset/U-inversion/L
  : forall* {CM} {B} {S} {S'} {S1'} {N} {N1} {P} {O1} {NN1} {A1} {C1} {FM1}
    forall {CM-B-S: clsmap-cxt-objset CM B S1'}
    {NM1: set`not-member S1' N1}
    {AD1: set`add S1' N1 S}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {CML1: clsmap`lookup CM C1 FM1}
    {NM: set`not-member S' N}
    {AD: set`add S' N S}
    {EQ?: nat`eq? N N1 P}
    exists {CM-B-S': clsmap-cxt-objset CM B S'}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    true.

- : clsmap-cxt-objset/U-inversion/L CM-B-S F1 U1 BL1 CML1 F U
    nat`eq?/yes CM-B-S' _ _ _ _ BL1 _ CML1
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- clsmap-cxt-objset-respects-eq CM-B-S clsmap`eq/ cxt`eq/ S1=S CM-B-S'.

- : clsmap-cxt-objset/U-inversion/L CM-B-S F1 U1 BL CML
    F U (nat`eq?/no N<>N1) (clsmap-cxt-objset/U CM-B-S2 BL CML F3 U3)
    _ _ _ _ BL2 _ CML2
    <- set`add-commutes-converse U U1 N<>N1 _ U3 U2
    <- set`add-preserves-fresh-converse F U3 F2
    <- set`add-preserves-fresh-converse F1 U2 F3
    <- clsmap-cxt-objset/U-inversion CM-B-S F2 U2 CM-B-S2 _ _ _ _ BL2 _ CML2.

- : clsmap-cxt-objset/U-inversion
    (clsmap-cxt-objset/U CM-B-S0 BL0 CML F0 U0) F1 U1 CM-B-S1 _ _ _ _ BL1 _ CML1
    <- nat`eq?-total E?
    <- clsmap-cxt-objset/U-inversion/L CM-B-S0 F0 U0 BL0 CML
      F1 U1 E? CM-B-S1 _ _ _ _ BL1 _ CML1.

%worlds (objvar) (clsmap-cxt-objset/U-inversion _ _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-objset/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (clsmap-cxt-objset/U-inversion C0 _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-objset/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem cxt-unique-objset-respects-eq
  : forall* {B1} {B2} {S1} {S2} {NN1} {C1} {NN2} {C2}
    forall {B1-S1: cxt-unique-objset B1 NN1 C1 S1}
    {EQ: cxt`eq B1 B2} {EQ: set`eq S1 S2}
    {EQ: nonnull`eq NN1 NN2} {EQ: nat`eq C1 C2}
    exists {B2-S2: cxt-unique-objset B2 NN2 C2 S2}
    true.

- : cxt-unique-objset-respects-eq A cxt`eq/ set`eq/ nonnull`eq/ nat`eq/ A.

%worlds (objvar) (cxt-unique-objset-respects-eq _ _ _ _ _ _).
%total { } (cxt-unique-objset-respects-eq _ _ _ _ _ _).


%theorem cxt-unique-objset/U-inversion
  : forall* {B} {S} {S'} {N} {NN} {C}
    forall {B-S: cxt-unique-objset B NN C S}
    {NM: set`not-member S' N}
    {AD: set`add S' N S}
    exists {CM-B-S': cxt-unique-objset B NN C S'}
    {O} {A} {NN'} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN' A C))}
    {UA: unique-or-borrow A}
    {NN<=NN': nonnull`leq NN NN'}
    true.

%theorem cxt-unique-objset/U-inversion/L
  : forall* {B} {S} {S'} {S1'} {N} {N1} {P} {O1} {NN1} {C} {NN} {A1}
    forall {B-S: cxt-unique-objset B NN C S1'}
    {NM1: set`not-member S1' N1}
    {AD1: set`add S1' N1 S}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C))}
    {UA1: unique-or-borrow A1}
    {NN<=NN1: nonnull`leq NN NN1}
    {NM: set`not-member S' N}
    {AD: set`add S' N S}
    {EQ?: nat`eq? N N1 P}
    exists {CM-B-S': cxt-unique-objset B NN C S'}
    {O} {A} {NN'} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN' A C))}
    {UA: unique-or-borrow A}
    {NN<=NN': nonnull`leq NN NN'}
    true.

- : cxt-unique-objset/U-inversion/L B-S F1 U1 BL1 UA1 LE F U
    nat`eq?/yes B-S' _ _ _ BL1 UA1 LE
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- cxt-unique-objset-respects-eq B-S cxt`eq/ S1=S nonnull`eq/ nat`eq/ B-S'.

- : cxt-unique-objset/U-inversion/L B-S F1 U1
    (BL:cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))) UA1 (LE:nonnull`leq NN NN1)
    F U (nat`eq?/no (N<>N1:nat`ne N N1))
    (cxt-unique-objset/U B-S2 BL UA1 LE F3 U3) O A NN' BL2 UA2 LE2
    <- set`add-commutes-converse U U1 N<>N1 _ U3 U2
    <- set`add-preserves-fresh-converse F U3 F2
    <- set`add-preserves-fresh-converse F1 U2 F3
    <- cxt-unique-objset/U-inversion B-S F2 U2 B-S2 _ _ _ BL2 UA2 LE2.

- : cxt-unique-objset/U-inversion
    (cxt-unique-objset/U B-S0 BL0 UA0 LE F0 U0)
    F1 U1 B-S1 _ _ _ BL1 UA1 LE1
    <- nat`eq?-total E?
    <- cxt-unique-objset/U-inversion/L B-S0 F0 U0 BL0 UA0 LE
      F1 U1 E? B-S1 _ _ _ BL1 UA1 LE1.

%worlds (objvar) (cxt-unique-objset/U-inversion _ _ _ _ _ _ _ _ _ _)
	(cxt-unique-objset/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (cxt-unique-objset/U-inversion C0 _ _ _ _ _ _ _ _ _)
	(cxt-unique-objset/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


% backward-compatibility ...
%theorem cxt-unique-objset-implies-same-class
  : forall* {B} {NN} {C} {S}
    forall {B-S: cxt-unique-objset B NN C S}
    exists {S-C: same-class B S C}
    true.

- : cxt-unique-objset-implies-same-class cxt-unique-objset/0 same-class/0.

- : cxt-unique-objset-implies-same-class
    (cxt-unique-objset/U B-S' BL _ _ NM A)
    (same-class/U SOC' NM A BL)
    <- cxt-unique-objset-implies-same-class B-S' SOC'.

%worlds (objvar) (cxt-unique-objset-implies-same-class _ _).
%total (A) (cxt-unique-objset-implies-same-class A _).


%theorem cxt-unique-objset-implies-least-nonnull
  : forall* {B} {NN} {C} {S}
    forall {B-S: cxt-unique-objset B NN C S}
    exists {S-NN: least-nonnull B S NN}
    true.

- : cxt-unique-objset-implies-least-nonnull cxt-unique-objset/0 least-nonnull/0.

- : cxt-unique-objset-implies-least-nonnull
    (cxt-unique-objset/U B-S' BL _ LE NM A)
    (least-nonnull/U S'-NN NM A BL LE)
    <- cxt-unique-objset-implies-least-nonnull B-S' S'-NN.

%worlds (objvar) (cxt-unique-objset-implies-least-nonnull _ _).
%total (A) (cxt-unique-objset-implies-least-nonnull A _).


%theorem clsmap-cxt-capmap-respects-geq
  : forall* {S} {SP} {CM} {B}
    forall {B-SP: clsmap-cxt-capmap CM B SP}
    {S1<=S2: capmap`leq S SP}
    exists {B-S: clsmap-cxt-capmap CM B S}
    true.

- : clsmap-cxt-capmap-respects-geq
    clsmap-cxt-capmap/0 capmap`leq/0 clsmap-cxt-capmap/0.

%theorem clsmap-cxt-capmap-respects-geq/U
  : forall* {CM} {FM} {SS} {SP} {N} {B} {NN} {A} {C} {S} {K} {T} {F} {O} {X}
    forall {P} {IN?: capmap`domain? S (s K) P}
    {NM: capmap`fresh SS (s K)}
    {UD: capmap`update SS (s K) X SP}
    {NP: nat2pair (s K) (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    {B-SS: clsmap-cxt-capmap CM B SS}
    {S<=SP: capmap`leq S SP}
    exists {B-S: clsmap-cxt-capmap CM B S}
    true.

%theorem clsmap-cxt-capmap-respects-geq/z
  : forall* {S} {SS} {X} {CM} {SP} {B}
    forall {P} {IN?: capmap`domain? S shared P}
    {NM: capmap`fresh SS shared}
    {UD: capmap`update SS shared X SP}
    {B-SS: clsmap-cxt-capmap CM B SS}
    {S<=SP: capmap`leq S SP}
    exists {B-S: clsmap-cxt-capmap CM B S}
    true.

- : clsmap-cxt-capmap-respects-geq/z true (capmap`domain?/in N<-S)
    NM UD B-SS S<=SP (clsmap-cxt-capmap/z CM-B-ST N!<ST ADD)
    <- capmap`lookup-implies-fresh-update N<-S ST N!<ST ADD
    <- capmap`fresh-update-preserves-leq-converse S<=SP N!<ST ADD NM UD ST<=SS KK
    <- clsmap-cxt-capmap-respects-geq B-SS ST<=SS CM-B-ST.

- : clsmap-cxt-capmap-respects-geq/z false (capmap`domain?/out N!<S)
    NM UD B-SS S<=SP B-S
    <- capmap`fresh-update2-preserves-leq-converse S<=SP N!<S NM UD S<=SS
    <- clsmap-cxt-capmap-respects-geq B-SS S<=SS B-S.

- : clsmap-cxt-capmap-respects-geq/U true (capmap`domain?/in N<-S)
    NM UD NP BL CML FML B-SS S<=SP
    (clsmap-cxt-capmap/U CM-B-ST NP BL CML FML N!<ST ADD)
    <- capmap`lookup-implies-fresh-update N<-S ST N!<ST ADD
    <- capmap`fresh-update-preserves-leq-converse S<=SP N!<ST ADD NM UD ST<=SS KK
    <- clsmap-cxt-capmap-respects-geq B-SS ST<=SS CM-B-ST.

- : clsmap-cxt-capmap-respects-geq/U false (capmap`domain?/out N!<S)
    NM UD BL CML DM-FM=FS MPS<=FS B-SS S<=SP B-S
    <- capmap`fresh-update2-preserves-leq-converse S<=SP N!<S NM UD S<=SS
    <- clsmap-cxt-capmap-respects-geq B-SS S<=SS B-S.

- : clsmap-cxt-capmap-respects-geq
    (clsmap-cxt-capmap/z B-SS NM UD) S<=SP B-S
    <- capmap`domain?-total MB?
    <- clsmap-cxt-capmap-respects-geq/z _ MB? NM UD B-SS S<=SP B-S.

- : clsmap-cxt-capmap-respects-geq
    (clsmap-cxt-capmap/U B-SS NP BL CML FML NM UD) S<=SP B-S
    <- capmap`domain?-total MB?
    <- clsmap-cxt-capmap-respects-geq/U _ MB? NM UD NP BL CML FML B-SS S<=SP B-S.

%worlds (objvar) (clsmap-cxt-capmap-respects-geq _ _ _)
  (clsmap-cxt-capmap-respects-geq/U _ _ _ _ _ _ _ _ _ _ _)
  (clsmap-cxt-capmap-respects-geq/z _ _ _ _ _ _ _).
%total (L1 L2 L3) (clsmap-cxt-capmap-respects-geq L1 _ _)
	(clsmap-cxt-capmap-respects-geq/U _ _ _ _ _ _ _ _ L2 _ _)
  (clsmap-cxt-capmap-respects-geq/z _ _ _ _ L3 _ _).


%theorem clsmap-cxt-objset-respects-geq
  : forall* {S} {SP} {CM} {B}
    forall {B-SP: clsmap-cxt-objset CM B SP}
    {S1<=S2: set`leq S SP}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : clsmap-cxt-objset-respects-geq clsmap-cxt-objset/0 set`leq/0 clsmap-cxt-objset/0.

%theorem clsmap-cxt-objset-respects-geq/U
  : forall* {CM} {SS} {SP} {N} {B} {NN} {A} {C} {S} {O} {FM}
    forall {P} {IN?: set`member? S N P}
    {NM: set`not-member SS N}
    {UD: set`add SS N SP}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {B-SS: clsmap-cxt-objset CM B SS}
    {S<=SP: set`leq S SP}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : clsmap-cxt-objset-respects-geq/U true (set`member?/in N<-S)
    NM UD BL CML B-SS S<=SP
    (clsmap-cxt-objset/U CM-B-ST BL CML N!<ST ADD)
    <- set`member-implies-not-member-add N<-S ST N!<ST ADD
    <- set`not-member-add-preserves-leq-converse S<=SP N!<ST ADD NM UD ST<=SS
    <- clsmap-cxt-objset-respects-geq B-SS ST<=SS CM-B-ST.

- : clsmap-cxt-objset-respects-geq/U false (set`domain?/out N!<S)
    NM UD BL CML B-SS S<=SP B-S
    <- set`not-member-update2-preserves-leq-converse S<=SP N!<S NM UD S<=SS
    <- clsmap-cxt-objset-respects-geq B-SS S<=SS B-S.

- : clsmap-cxt-objset-respects-geq
    (clsmap-cxt-objset/U B-SS BL CML NM UD) S<=SP B-S
    <- set`domain?-total MB?
    <- clsmap-cxt-objset-respects-geq/U
      _ MB? NM UD BL CML B-SS S<=SP B-S.

%worlds (objvar) (clsmap-cxt-objset-respects-geq _ _ _)
	(clsmap-cxt-objset-respects-geq/U _ _ _ _ _ _ _ _ _).
%total (L1 L2) (clsmap-cxt-objset-respects-geq L1 _ _)
	(clsmap-cxt-objset-respects-geq/U _ _ _ _ _ _ L2 _ _).


% %theorem nat+set2set-implies-clsmap-cxt-capmap
%   : forall* {CM} {B} {N} {FS} {S} {NN} {A} {C} {FM} {FS0} {O}
%     forall {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
%     {CML: clsmap`lookup CM C FM} {FM-DM: fldmap`domain FM FS0}
%     {LE: capmap`leq FS FS0}
%     {N+FS=>S: nat+set2set N FS S}
%     exists {B-S: clsmap-cxt-capmap CM B S}
%     true.

% - : nat+set2set-implies-clsmap-cxt-capmap
%     _ _ _ set`leq/0 nat+set2set/0 clsmap-cxt-capmap/0.

% - : nat+set2set-implies-clsmap-cxt-capmap
%     BL CML FM-DM=FS0 FS<=FS0 (nat+set2set/U N+FS'=>S' K=>NF F!<FS' FS'+F=FS S'+K=S)
%     (clsmap-cxt-capmap/U B-S' K=>NF BL CML FML K!<S' S'+K=S)
%     <- set`add-implies-member FS'+F=FS F<-FS
%     <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
%     <- fldmap`domain-preserves-lookup-converse F<-FS0 FM-DM=FS0 _ FML
%     <- nat+set2set-preserves-fresh N+FS'=>S' F!<FS' K=>NF K!<S'
%     <- set`fresh-update-implies-leq F!<FS' FS'+F=FS FS'<=FS
%     <- set`leq-transitive FS'<=FS FS<=FS0 FS'<=FS0
%     <- nat+set2set-implies-clsmap-cxt-capmap BL CML FM-DM=FS0 FS'<=FS0 N+FS'=>S' B-S'.

% %worlds (objvar) (nat+set2set-implies-clsmap-cxt-capmap _ _ _ _ _ _).
% %total (T) (nat+set2set-implies-clsmap-cxt-capmap _ _ _ _ T _).


%%% N has to be a positive number, representing a non-world object.

%theorem nat+set2capmap-implies-clsmap-cxt-capmap*
  : forall* {N} {FS} {X} {M} {CM} {C} {FM} {B} {O} {NN} {A} {FS0}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM=FS: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    {N+FS=>M: nat+set2capmap N FS X M}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {GT: nat`gt N z}
    exists {CM-B-M: clsmap-cxt-capmap CM B M}
    true.

- : nat+set2capmap-implies-clsmap-cxt-capmap*
    _ CML FM-DM _ nat+set2capmap/0 BL _ clsmap-cxt-capmap/0.

- : nat+set2capmap-implies-clsmap-cxt-capmap* CM-CM
    CML FM-DM=FS0 (FS<=FS0:set`leq FS FS0)
    (nat+set2capmap/U N+FS'=>M' (N+F=>K:pair2nat (pair/ N F) z) F!<FS' FS'+F=FS M'+K+X=M)
    BL (GT:nat`gt N z) CM-B-M
    <- nat2pair-deterministic/0 N+F=>K P=Z
    <- pair-eq-implies-eq P=Z N=Z F=Z
    <- nat`gt-respects-eq GT N=Z nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N V
    <- false-implies-clsmap-cxt-capmap V CM-B-M.

- : nat+set2capmap-implies-clsmap-cxt-capmap* CM-CM
    CML FM-DM=FS0 (FS<=FS0:set`leq FS FS0)
    (nat+set2capmap/U N+FS'=>M' N+F=>K F!<FS' FS'+F=FS M'+K+X=M)
    BL GT (clsmap-cxt-capmap/U CM-B-M' N+F=>K BL CML FML K!<M' M'+K+X=M)
    <- set`add-implies-member FS'+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
    <- fldmap`domain-preserves-lookup-converse F<-FS0 FM-DM=FS0 _ FML
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-T
    <- nat+set2capmap-preserves-fresh N+FS'=>M' F!<FS' N+F=>K K!<M'
    <- set`add-implies-leq FS'+F=FS FS'<=FS
    <- set`leq-transitive FS'<=FS FS<=FS0 FS'<=FS0
    <- nat+set2capmap-implies-clsmap-cxt-capmap*
      CM-CM CML FM-DM=FS0 FS'<=FS0 N+FS'=>M' BL GT CM-B-M'.

%worlds (objvar) (nat+set2capmap-implies-clsmap-cxt-capmap* _ _ _ _ _ _ _ _).
%total (A) (nat+set2capmap-implies-clsmap-cxt-capmap* _ _ _ _ A _ _ _).


%theorem nat+set2capmap-implies-clsmap-cxt-capmap
  : forall* {N} {FS} {X} {M} {CM} {C} {FM} {B} {O} {NN} {A}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM=FS: fldmap`domain FM FS}
    {N+FS=>M: nat+set2capmap N FS X M}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {N>0: nat`gt N z}
    exists {CM-B-M: clsmap-cxt-capmap CM B M}
    true.

- : nat+set2capmap-implies-clsmap-cxt-capmap CM-CM
    CML FM-DM=FS N+FS=>M BL N>0 CM-B-M
    <- set`leq-reflexive _ FS<=FS
    <- nat+set2capmap-implies-clsmap-cxt-capmap* CM-CM
      CML FM-DM=FS FS<=FS N+FS=>M BL N>0 CM-B-M.

%worlds (objvar) (nat+set2capmap-implies-clsmap-cxt-capmap _ _ _ _ _ _ _).
%total { } (nat+set2capmap-implies-clsmap-cxt-capmap _ _ _ _ _ _ _).


%theorem false-implies-clsmap-cxt-objset
  : forall* {CM} {B} {S}
    forall {F:void} exists {CBS2: clsmap-cxt-objset CM B S}
    true.

%worlds (objvar) (false-implies-clsmap-cxt-objset _ _).
%total { } (false-implies-clsmap-cxt-objset _ _).


%theorem join-preserves-clsmap-cxt-objset
  : forall* {CM} {B} {S1} {S2} {S}
    forall {B-S1: clsmap-cxt-objset CM B S1}
    {B-S2: clsmap-cxt-objset CM B S2}
    {J: set`union S1 S2 S}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

%theorem join-preserves-clsmap-cxt-objset/L
  : forall* {CM} {B} {S1} {S2} {S}
    forall {N} {SZ: set`size S N}
    {B-S1: clsmap-cxt-objset CM B S1}
    {B-S2: clsmap-cxt-objset CM B S2}
    {J: set`union S1 S2 S}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : join-preserves-clsmap-cxt-objset/L
    _ set`size/0 clsmap-cxt-objset/0 CBS set`union/L CBS.

- : join-preserves-clsmap-cxt-objset/L
    _ set`size/0 CBS clsmap-cxt-objset/0 set`union/R CBS.

%theorem join-preserves-clsmap-cxt-objset/LL
  : forall* {CM} {B} {S1} {S2} {S} {SP} {K} {B1} {B2}
    forall {N} {SZ: set`size S N}
    {B-S1: clsmap-cxt-objset CM B S1}
    {B-S2: clsmap-cxt-objset CM B S2}
    {J: set`union S1 S2 S}
    {F: set`not-member SP K}
    {A: set`add SP K S}
    {D1?: set`domain? S1 K B1}
    {D2?: set`domain? S2 K B2}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U
    (set`domain?/in (L1:set`lookup S1 K unit/)) (set`domain?/in L2)
    (clsmap-cxt-objset/U CBSP BL2 CML2 F U)
    <- set`member-implies-not-member-add L1 S1P F1 U1
    <- set`member-implies-not-member-add L2 S2P F2 U2
    <- set`add-implies-member U L
    <- set`not-member-update-preserves-union-converse*
      F1 U1 F2 U2 SU F U unit`union/ SUP
    <- clsmap-cxt-objset/U-inversion CBS1 F1 U1 CBS1P _ _ _ _ BL1 _ CML1
    <- clsmap-cxt-objset/U-inversion CBS2 F2 U2 CBS2P _ _ _ _ BL2 _ CML2
    <- set`not-member-add-increases-size-converse Z F U ZP
    <- join-preserves-clsmap-cxt-objset/L _ ZP CBS1P CBS2P SUP CBSP.

- : join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U
    (set`domain?/in _) (set`domain?/out F2)
    (clsmap-cxt-objset/U CBSP BL1 CML1 F U)
    <- set`add-implies-member U L
    <- set`not-member-union-right-preserves-member-converse L F2 SU L1
    <- set`member-implies-not-member-add L1 _ F1 U1
    <- clsmap-cxt-objset/U-inversion CBS1 F1 U1 CBS1P _ _ _ _ BL1 _ CML1
    <- set`not-member-update-left-preserves-union-converse* F1 U1 F2 SU F U SU1
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-objset/L _ Z1 CBS1P CBS2 SU1 CBSP.

- : join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U
    (set`domain?/out F1) (set`domain?/in _) %{=>}%
    (clsmap-cxt-objset/U CBSP BL2 CML2 F U)
    <- set`add-implies-member U L
    <- set`not-member-union-left-preserves-member-converse F1 L SU L2
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- clsmap-cxt-objset/U-inversion CBS2 F2 U2 CBS2P _ _ _ _ BL2 _ CML2
    <- set`not-member-update-right-preserves-union-converse* F1 F2 U2 SU F U SU2
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-objset/L _ Z1 CBS1 CBS2P SU2 CBSP.

- : join-preserves-clsmap-cxt-objset/LL _ _ _ _ SU _ U
    (set`domain?/out F1) (set`domain?/out F2) %{=>}% CBS
    <- set`union-preserves-not-member* F1 F2 SU F
    <- set`add-implies-member U L
    <- set`not-member-member-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-clsmap-cxt-objset V CBS.

- : join-preserves-clsmap-cxt-objset/L (s N) Z CBS1 CBS2 SU CBS
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) _ F U
    <- set`domain?-total D1?
    <- set`domain?-total D2?
    <- join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U D1? D2? CBS.

%worlds (objvar) (join-preserves-clsmap-cxt-objset/LL _ _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-objset/L _ _ _ _ _ _).
%total (N1 N2) (join-preserves-clsmap-cxt-objset/LL N1 _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-objset/L N2 _ _ _ _ _).

- : join-preserves-clsmap-cxt-objset CBS1 CBS2 U CBS
    <- set`size-total Z
    <- join-preserves-clsmap-cxt-objset/L _ Z CBS1 CBS2 U CBS.

%worlds (objvar) (join-preserves-clsmap-cxt-objset _ _ _ _).
%total {} (join-preserves-clsmap-cxt-objset _ _ _ _).


% %theorem effects`join-right-preserves-targets-effects
%   : forall* {XX1} {XX2} {XX} {G}
%     forall {G-XX2: targets-effects G XX2}
%     {XX1+XX2=XX: effects`join XX1 XX2 XX}
%     exists {G-XX: targets-effects G XX}
%     true.

% - : effects`join-right-preserves-targets-effects
%     targets-effects/shared _ targets-effects/shared.

% - : effects`join-right-preserves-targets-effects
%     (targets-effects/unique DM-M2=R2 S2<=R2)
%     (effects`join/ _ _ _ _ _ _ _ _ J _ _ (QJ:set`union Q1 Q2 Q))
%     (targets-effects/unique DM-M=R S2<=R)
%     <- efxmap`join-implies-leq J _ M2<=M
%     <- efxmap`domain-preserves-leq M2<=M DM-M2=R2 R DM-M=R R2<=R
%     <- set`leq-transitive S2<=R2 R2<=R S2<=R.

% %worlds (objvar) (effects`join-right-preserves-targets-effects _ _ _).
% %total {} (effects`join-right-preserves-targets-effects _ _ _).


% %theorem compatible-right-join-preserves-targets-effects
%   : forall* {CM} {B} {XX1} {XX2} {XX} {G}
%     forall {G-XX1: targets-effects G XX1}
%     {XX1+XX2=XX: effects`join XX1 XX2 XX}
%     {CP: compatible CM B G XX2}
%     exists {G-XX: targets-effects G XX}
%     true.

% %theorem compatible-right-join-preserves-targets-effects/L
%   : forall* {G} {R1} {R1'} {S2} {S3} {M} {M'}
%     forall {G<=R1: set`leq G R1}
%     {D: set`disjoint G S2}
%     {RM: set`remove R1 S2 S3}
%     {DM1: efxmap`domain M R1}
%     {DM1': efxmap`domain M' R1'}
%     {RS: efxmap`restrict M S3 M'}
%     {B} {LE?: set`leq? G R1' B}
%     exists {G<=R1': set`leq G R1'}
%     true.

% - : compatible-right-join-preserves-targets-effects/L
%     G<=R1 G^S2 R1/S2=S3 DM-M=R1 DM-M'=R1' M|S3=M' _
%     (set`leq?/no (set`nle/< N<-G N!<R1')) G<=R1'
%     <- set`member-respects-leq N<-G G<=R1 N<-R1
%     <- efxmap`restrict-implies-domain-leq* M|S3=M' DM-M'=R1' R1'<=S3
%     <- efxmap`domain-preserves-lookup-converse N<-R1 DM-M=R1 D M->N=D
%     <- efxmap`domain-preserves-fresh-converse N!<R1' DM-M'=R1' N!<M'
%     <- efxmap`restrict-lookup-not-member-implies-fresh-converse
%       M|S3=M' M->N=D N!<M' N!<S3
%     <- set`union-total S2+S3=Q
%     <- set`remove-implies-leq-union R1/S2=S3 S2+S3=Q R1<=Q
%     <- set`member-respects-leq N<-R1 R1<=Q N<-Q
%     <- set`not-member-union-right-preserves-member-converse
%       N<-Q N!<S3 S2+S3=Q N<-S2
%     <- set`disjoint-member-contradiction G^S2 N<-G N<-S2 F
%     <- set`false-implies-leq F G<=R1'.

% - : compatible-right-join-preserves-targets-effects/L
%     _ _ _ _ _ _ _ (set`leq?/yes G<=R1') G<=R1'.

% %worlds (objvar)
% 	(compatible-right-join-preserves-targets-effects/L _ _ _ _ _ _ _ _ _).
% %total {}
% 	(compatible-right-join-preserves-targets-effects/L _ _ _ _ _ _ _ _ _).

% - : compatible-right-join-preserves-targets-effects
%     (targets-effects/unique (DM-M1=R1:efxmap`domain M1 R1) G<=R1)
%     (effects`join/ _ _ _ _ _ _ RM RS (J:efxmap`join M1' M2 M)
%       _ _ _)
%     (compatible/unique (DM-M2=R2:efxmap`domain M2 R2) (G^R2:set`disjoint G R2)
%       (G^S2:set`disjoint G S2) Q=>FS (G^FS:set`disjoint G FS))
%     (targets-effects/unique DM-M=R G<=R)
%     <- efxmap`domain-total (DM-M1'=R1':efxmap`domain M1' R1')
%     <- set`leq?-total LE?
%     <- compatible-right-join-preserves-targets-effects/L
%       G<=R1 G^S2 RM DM-M1=R1 DM-M1'=R1' RS _ LE? G<=R1'
%     <- efxmap`domain-total (DM-M=R:efxmap`domain M R)
%     <- efxmap`join-commute-domain J DM-M1'=R1' DM-M2=R2 DM-M=R R1'+R2=R
%     <- set`union-implies-leq R1'+R2=R R1'<=R _
%     <- set`leq-transitive G<=R1' R1'<=R G<=R.

% - : compatible-right-join-preserves-targets-effects
%     (targets-effects/shared) _ _ targets-effects/shared.

% %worlds (objvar) (compatible-right-join-preserves-targets-effects _ _ _ _).
% %total {} (compatible-right-join-preserves-targets-effects _ _ _ _).


% %theorem targets-effects-respects-geq
%   : forall* {G} {XX1} {XX2}
%     forall {G-XX1: targets-effects G XX1}
%     {XX1<=XX2: effects-leq-no-consume XX1 XX2}
%     exists {G-XX2: targets-effects G XX2}
%     true.

% - : targets-effects-respects-geq
%     targets-effects/shared _ targets-effects/shared.

% - : targets-effects-respects-geq
%     (targets-effects/unique DM-M1=R1 S<=R1)
%     (effects-leq-no-consume/ M1<=M2)
%     (targets-effects/unique DM-M2=R2 S<=R2)
%     <- efxmap`domain-preserves-leq M1<=M2 DM-M1=R1 _ DM-M2=R2 R1<=R2
%     <- set`leq-transitive S<=R1 R1<=R2 S<=R2.

% %worlds (objvar) (targets-effects-respects-geq _ _ _).
% %total {} (targets-effects-respects-geq _ _ _).


% %theorem consider-ftype-preserves-targets-effects
%   : forall* {G} {G'} {A} {XX}
%     forall {G-XX: targets-effects G XX}
%     {CF: consider-ftype G A G'}
%     exists {G'-XX: targets-effects G' XX}
%     true.

% - : consider-ftype-preserves-targets-effects
%     G-XX consider-ftype/unique G-XX.

% - : consider-ftype-preserves-targets-effects
%     _ consider-ftype/shared targets-effects/shared.

% %worlds (objvar) (consider-ftype-preserves-targets-effects _ _ _).
% %total {} (consider-ftype-preserves-targets-effects _ _ _).


% %theorem join-preserves-clsmap-cxt-effects
%   : forall* {CM} {B} {XX1} {XX2} {XX}
%     forall {C1: clsmap-cxt-effects CM B XX1}
%     {C2: clsmap-cxt-effects CM B XX2}
%     {J: effects`join XX1 XX2 XX}
%     exists {C: clsmap-cxt-effects CM B XX}
%     true.

% - : join-preserves-clsmap-cxt-effects
%     (clsmap-cxt-effects/ DM-M1=R1 R1^S1 S1=>SQ1 Q1<=SQ1 CM-B-R1 B-S1)
%     (clsmap-cxt-effects/ DM-M2=R2 R2^S2 S2=>SQ2 Q2<=SQ2 CM-B-R2 B-S2)
%     (effects`join/ DM-M1=R1' DM-M2=R2' S1^R1' S2^R2' S1^R2' S1^S2
%       R1'/S2=S3 M1|S3=M1' M1'+M2=M S1+S2=S Q1^Q2 Q1+Q2=Q)
%     (clsmap-cxt-effects/ DM-M=R R^S S=>SQ Q<=SQ CM-B-R B-S)
%     <- join-preserves-clsmap-cxt-capmap B-S1 B-S2 S1+S2=S B-S
%     <- efxmap`restrict-implies-leq M1|S3=M1' M1'<=M1
%     <- efxmap`domain-total DM-M1'=R1''
%     <- efxmap`domain-preserves-leq* M1'<=M1  DM-M1'=R1'' DM-M1=R1' R1''<=R1'
%     <- efxmap`domain-unique DM-M1=R1' DM-M1=R1 efxmap`eq/ R1'=R1
%     <- efxmap`domain-unique DM-M2=R2' DM-M2=R2 efxmap`eq/ R2'=R2
%     <- set`leq-respects-eq R1''<=R1' set`eq/ R1'=R1 R1''<=R1
%     <- clsmap-cxt-capmap-respects-geq CM-B-R1 R1''<=R1 CM-B-R1''
%     <- efxmap`domain-total DM-M=R
%     <- efxmap`join-commute-domain M1'+M2=M DM-M1'=R1'' DM-M2=R2 DM-M=R R1''+R2=R
%     <- join-preserves-clsmap-cxt-capmap CM-B-R1'' CM-B-R2 R1''+R2=R CM-B-R
%     <- set`disjoint-respects-eq S1^R1' set`eq/ R1'=R1 S1^R1
%     <- set`disjoint-respects-eq S2^R2' set`eq/ R2'=R2 S2^R2
%     <- set`disjoint-respects-eq S1^R2' set`eq/ R2'=R2 S1^R2
%     <- set`leq-reflexive _ S1<=S1
%     <- set`disjoint-respects-geq S1^R1 S1<=S1 R1''<=R1 S1^R1''
%     <- efxmap`remove-implies-domain-disjoint*
%       (efxmap`remove/ DM-M1=R1' R1'/S2=S3 M1|S3=M1') DM-M1'=R1'' R1''^S2
%     <- set`disjoint-symmetric S1^R2 R2^S1
%     <- set`disjoint-symmetric S1^R1'' R1''^S1
%     <- set`union-preserves-disjoint* R1''^S1 R2^S1 R1''+R2=R R^S1
%     <- set`union-preserves-disjoint* R1''^S2 R2^S2 R1''+R2=R R^S2
%     <- set`union-right-preserves-disjoint* R^S1 R^S2 S1+S2=S R^S
%     <- collect-objs-total S=>SQ
%     <- set`union-implies-leq S1+S2=S S1<=S S2<=S
%     <- collect-objs-respects-geq* S1<=S S1=>SQ1 S=>SQ SQ1<=SQ
%     <- collect-objs-respects-geq* S2<=S S2=>SQ2 S=>SQ SQ2<=SQ
%     <- set`leq-transitive Q1<=SQ1 SQ1<=SQ Q1<=SQ
%     <- set`leq-transitive Q2<=SQ2 SQ2<=SQ Q2<=SQ
%     <- set`union-is-lub Q1+Q2=Q Q1<=SQ Q2<=SQ Q<=SQ.

% %worlds (objvar) (join-preserves-clsmap-cxt-effects _ _ _ _).
% %trustme %total {} (join-preserves-clsmap-cxt-effects _ _ _ _).


% Some "constructive" theorems.

% %theorem set+nat2set-implies-clsmap-cxt-capmap
%   : forall* {CM} {B} {S} {F} {Q} {C} {FM} {T}
%     forall {CML: clsmap`lookup CM C FM}
%     {FML: fldmap`lookup FM F T}
%     {SOC: same-class B S C}
%     {S+F=>Q: set+nat2set S F Q}
%     exists {CM-B-Q: clsmap-cxt-capmap CM B Q}
%     true.

% - : set+nat2set-implies-clsmap-cxt-capmap _ _ _ set+nat2set/0 clsmap-cxt-capmap/0.

% - : set+nat2set-implies-clsmap-cxt-capmap CML FML SOC
%     (set+nat2set/U SP+F=>QP N+F=>K FS US UQ)
%     (clsmap-cxt-capmap/U CM-B-QP N+F=>K BL CML FML FQ UQ)
%     <- same-class/U-inversion SOC FS US _ _ _ SOCP BL
%     <- set+nat2set-implies-clsmap-cxt-capmap CML FML SOCP SP+F=>QP CM-B-QP
%     <- set+nat2set-preserves-fresh SP+F=>QP FS N+F=>K FQ.

% %worlds (objvar) (set+nat2set-implies-clsmap-cxt-capmap _ _ _ _ _).
% %total (T) (set+nat2set-implies-clsmap-cxt-capmap _ _ _ T _).


% %theorem set+set2set-implies-clsmap-cxt-capmap
%   : forall* {CM} {B} {S} {FS} {Q} {C} {FM} {FS1}
%     forall {SOC: same-class B S C}
%     {S+S=>Q: set+set2set S FS Q}
%     {CML: clsmap`lookup CM C FM}
%     {DM: fldmap`domain FM FS1}
%     {LE: set`leq FS FS1}
%     exists {CM-B-Q: clsmap-cxt-capmap CM B Q}
%     true.

% - : set+set2set-implies-clsmap-cxt-capmap _
%     set+set2set/0 _ _ _ clsmap-cxt-capmap/0.

% - : set+set2set-implies-clsmap-cxt-capmap SOC
%     (set+set2set/U S'+FS=>Q' N+FS=>R N!<S' S'+N=S Q'+R=Q)
%     CML DM-FM=FS1 FS<=FS1 CM-B-Q
%     <- same-class/U-inversion SOC N!<S' S'+N=S _ _ _ SOC' BL
%     <- set+set2set-implies-clsmap-cxt-capmap
%       SOC' S'+FS=>Q' CML DM-FM=FS1 FS<=FS1 CM-B-Q'
%     <- nat+set2set-implies-clsmap-cxt-capmap BL CML DM-FM=FS1 FS<=FS1 N+FS=>R CM-B-R
%     <- join-preserves-clsmap-cxt-capmap CM-B-Q' CM-B-R Q'+R=Q CM-B-Q.

% %worlds (objvar) (set+set2set-implies-clsmap-cxt-capmap _ _ _ _ _ _ ).
% %total (S) (set+set2set-implies-clsmap-cxt-capmap _ S _ _ _ _ ).


%theorem clsmap-result/expr-implies-clsmap-cxt
  : forall* {CM} {RT} {B} {M}
    forall {CM-R: clsmap-result CM (result/expr RT (env/ B M))}
    exists {CM-B: clsmap-cxt CM B}
    true.

- : clsmap-result/expr-implies-clsmap-cxt (clsmap-result/expr CM-B _ _ _) CM-B.

%worlds (objvar) (clsmap-result/expr-implies-clsmap-cxt _ _).
%total { } (clsmap-result/expr-implies-clsmap-cxt _ _).


%theorem capmap`unit-disjoint-implies-fresh
  : forall* {M} {X} {N}
    forall {D: capmap`disjoint M (capmap/1 N X)}
    exists {F: capmap`fresh M N}
    true.

%theorem capmap`unit-disjoint-implies-fresh/L
  : forall* {M} {N} {X}
    forall {D: capmap`disjoint M (capmap/1 N X)}
    {B} {F: capmap`domain? M N B}
    exists {F: capmap`fresh M N}
    true.

- : capmap`unit-disjoint-implies-fresh/L M^N true (capmap`domain?/in M->N) N!<M
    <- capmap`disjoint-lookup-contradiction M^N M->N (capmap`lookup/= nat`eq/) V
    <- capmap`false-implies-fresh V N!<M.

- : capmap`unit-disjoint-implies-fresh/L M^N false (capmap`domain?/out N!<M) N!<M.

- : capmap`unit-disjoint-implies-fresh D F
    <- capmap`domain?-total DM?
    <- capmap`unit-disjoint-implies-fresh/L D _ DM? F.

%worlds () (capmap`unit-disjoint-implies-fresh/L _ _ _ _).
%total (B) (capmap`unit-disjoint-implies-fresh/L _ B _ _).

%worlds () (capmap`unit-disjoint-implies-fresh _ _).
%total { } (capmap`unit-disjoint-implies-fresh _ _).

%theorem make-tgts-and-caps-consistent
  : forall* {CM} {B0} {G0} {A} {X} {M0} {M1} {F} {C} {FM} {NN} {FC} {G1} {FNN}
    forall {WF-CM: wf-clsmap CM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ FNN A FC)}
    {CM-B-R: clsmap-result CM (result/expr (reftype/ NN C G0) (env/ B0 M0))}
    {MG: make-tgts-and-caps M0 G0 F X G1 M1}
    exists {CM-B-XX: clsmap-cxt-capmap CM B0 M1}
    {GP-XX: targets-capmap G1 M1}
    true.

- : make-tgts-and-caps-consistent WF-CM CML FML
    (clsmap-result/expr (CM-B0:clsmap-cxt CM B0)
      (targets-capmap/unique (M1^M0:capmap`disjoint M1 M0))
      (clsmap-cxt-reftype/unique _ _ _ _)
      (CM-B0-M0:clsmap-cxt-capmap CM B0 M0))
    (make-tgts-and-caps/unique (S+F+X=>M2:set+nat2capmap S F X M2)
      (MX-M1=X: capmap-min M1 X) (capmap-split/ M1^M2 M1+M2=M)
      (capmap-split/ M2^M3 (M2+M3=M0:capmap`join M2 M3 M0))) CM-B0-M3
      (targets-capmap/unique M^M3)
    <- capmap`join-implies-leq M2+M3=M0 M2<=M0 M3<=M0
    <- clsmap-cxt-capmap-respects-geq CM-B0-M0 M3<=M0 CM-B0-M3
    <- capmap`leq-reflexive _ M1<=M1
    <- capmap`disjoint-respects-geq M1^M0 M1<=M1 M3<=M0 M1^M3
    <- capmap`join-preserves-disjoint* M1^M3 M2^M3 M1+M2=M M^M3.

%%% z is a special value - I need to carefully think about how to handle it.
% - : make-tgts-and-caps-consistent WF-CM CML FML
%     (clsmap-result/expr (CM-B0:clsmap-cxt CM B0)
%       (targets-capmap/shared)
%       (clsmap-cxt-reftype/shared _)
%       (CM-B0-M0:clsmap-cxt-capmap CM B0 M0))
%     (make-tgts-and-caps/shared (M0-X=M1:capmap-split M0 (capmap/1 z X) M1))
%     CM-B0-M1 (targets-capmap/unique X^M1)
%     <- capmap-split-implies-disjoint-join M0-X=M1 X^M1 _
%     <- capmap`unit-join-implies-update

%worlds (objvar) (make-tgts-and-caps-consistent _ _ _ _ _ _ _).
%trustme %total { } (make-tgts-and-caps-consistent _ _ _ _ _ _ _).

% - : make-targets-and-effects-consistent
%     WF-CM WF-B _ _ clsmap-cxt-reftype/shared
%     make-targets-and-effects/shared consider-ftype/shared
%     clsmap-cxt-reftype/shared
%     (clsmap-cxt-effects/ (efxmap`domain/+ efxmap`domain/0)
%       set`disjoint/R collect-objs/0
%       set`leq/0 (clsmap-cxt-capmap/U clsmap-cxt-capmap/0 pair2nat/00 BL
%                   CML (fldmap`lookup/= nat`eq/)
%                   set`not-member/0 set`update/0) clsmap-cxt-capmap/0)
%     (targets-effects/unique (efxmap`domain/+ efxmap`domain/0)
%       (set`leq/= set`leq/0 unit`eq/ nat`eq/))
%     <- wf-clsmap-can-lookup-shared WF-CM CML
%     <- wf-cxt-can-lookup-shared WF-B BL.

% - : make-targets-and-effects-consistent
%     WF-CM WF-B _ _ clsmap-cxt-reftype/shared
%     make-targets-and-effects/shared consider-ftype/unique
%     (clsmap-cxt-reftype/unique same-class/0 least-nonnull/0
%       clsmap-cxt-objset/0
%       (clsmap-cxt-capmap/U clsmap-cxt-capmap/0 pair2nat/00 BL
%                   CML (fldmap`lookup/= nat`eq/)
%                   set`not-member/0 set`update/0))
%     (clsmap-cxt-effects/ (efxmap`domain/+ efxmap`domain/0)
%       set`disjoint/R collect-objs/0
%       set`leq/0 (clsmap-cxt-capmap/U clsmap-cxt-capmap/0 pair2nat/00 BL
%                   CML (fldmap`lookup/= nat`eq/)
%                   set`not-member/0 set`update/0) clsmap-cxt-capmap/0)
%     (targets-effects/unique (efxmap`domain/+ efxmap`domain/0)
%       (set`leq/= set`leq/0 unit`eq/ nat`eq/))
%     <- wf-clsmap-can-lookup-shared WF-CM CML
%     <- wf-cxt-can-lookup-shared WF-B BL.

% - : make-targets-and-effects-consistent
%     WF-CM WF-B CML FML (clsmap-cxt-reftype/unique SOC NAL B-S CM-B-G1)
%     (make-targets-and-effects/unique
%       S=>G2 G1^G2 G1+G2=G G=>M) consider-ftype/shared
%     clsmap-cxt-reftype/shared
%     (clsmap-cxt-effects/ DM set`disjoint/R
%       collect-objs/0 set`leq/0 CM-B-G clsmap-cxt-capmap/0)
%     (targets-effects/unique DM LE)
%     <- set2efxmap-implies-domain G=>M DM
%     <- set+nat2set-implies-clsmap-cxt-capmap CML FML SOC S=>G2 CM-B-G2
%     <- join-preserves-clsmap-cxt-capmap CM-B-G1 CM-B-G2 G1+G2=G CM-B-G
%     <- set`leq-reflexive _ LE.

% - : make-targets-and-effects-consistent
%     WF-CM WF-B CML FML (clsmap-cxt-reftype/unique SOC NAL _ CM-B-G1)
%     (make-targets-and-effects/unique
%       S=>G2 (G1^G2:set`disjoint G1 G2) G1+G2=G G=>M)
%     consider-ftype/unique (clsmap-cxt-reftype/unique
%       same-class/0 least-nonnull/0 clsmap-cxt-objset/0 CM-B-G)
%     (clsmap-cxt-effects/ DM set`disjoint/R collect-objs/0
%       set`leq/0 CM-B-G clsmap-cxt-capmap/0)
%     (targets-effects/unique DM LE)
%     <- set+nat2set-implies-clsmap-cxt-capmap CML FML SOC S=>G2 CM-B-G2
%     <- join-preserves-clsmap-cxt-capmap CM-B-G1 CM-B-G2 G1+G2=G CM-B-G
%     <- set2efxmap-implies-domain G=>M DM
%     <- set`leq-reflexive _ LE.

% %worlds (objvar) (make-targets-and-effects-consistent _ _ _ _ _ _ _ _ _ _).
% %trustme %total {} (make-targets-and-effects-consistent _ _ _ _ _ _ _ _ _ _).


% %theorem subtyping-consistent
%   : forall* {CM} {B} {NN1} {C1} {G} {NN2} {A2} {C2} {XM} {XX}
%     forall {WF-CM: wf-clsmap CM} {WF-B: wf-cxt B}
%     {CM-B-G: clsmap-cxt-reftype CM B (reftype/ NN1 C1 G)}
%     {STYP: subtype CM (reftype/ NN1 C1 G) (ty/ NN2 A2 C2) XM XX}
%     exists {CM-B-XX: clsmap-cxt-effects CM B XX}
%     true.

% - : subtyping-consistent WF-CM WF-B clsmap-cxt-reftype/shared
%     (subtype/ (sub-annot-efx/shared2borrow _) _ _ _ _ _ _)
%     (clsmap-cxt-effects/ (efxmap`domain/+ efxmap`domain/0)
%       set`disjoint/R collect-objs/0
%       set`leq/0 (clsmap-cxt-capmap/U clsmap-cxt-capmap/0 pair2nat/00 BL
%                   CML (fldmap`lookup/= nat`eq/)
%                   set`not-member/0 set`update/0) clsmap-cxt-capmap/0)
%     <- wf-clsmap-can-lookup-shared WF-CM CML
%     <- wf-cxt-can-lookup-shared WF-B BL.

% - : subtyping-consistent _ _ clsmap-cxt-reftype/shared
%     (subtype/ sub-annot-efx/shared2shared _ _ _ _ _ _) clsmap-cxt-effects/0.

% - : subtyping-consistent (wf-clsmap/ _ WF-CM/T) WF-B
%     (clsmap-cxt-reftype/unique SOC _ B-S CM-B-G1)
%     (subtype/ (sub-annot-efx/consume G1+G2=G _ S+Cs=>G2 _) _ _ DM CML _ nat`eq/)
%     (clsmap-cxt-effects/ efxmap`domain/0 set`disjoint/L
%       G=>S' S<=S' clsmap-cxt-capmap/0 CM-B-G)
%     <- set`leq-reflexive _ LE
%     <- set+set2set-implies-clsmap-cxt-capmap SOC S+Cs=>G2 CML DM LE CM-B-G2
%     <- join-preserves-clsmap-cxt-capmap CM-B-G1 CM-B-G2 G1+G2=G CM-B-G
%     <- wf-clsmap-lookup-not-empty WF-CM/T CML _ FMZ
%     <- fldmap`domain-preserves-size FMZ DM SZ
%     <- set+set2set-implies-collect-objs _ SZ S+Cs=>G2 G2=>S
%     <- set`union-implies-leq G1+G2=G _ G2<=G
%     <- collect-objs-respects-geq G2<=G G2=>S _ G=>S' S<=S'.

% - : subtyping-consistent _ _
%     (clsmap-cxt-reftype/unique (SOC:same-class B S1 C) _ B-S1 B-S2)
%     (subtype/
%       (sub-annot-efx/unique2borrow (XM1+XM2=XM:efxmap`join XM1 XM2 XM)
%         (S2+X=>XM2:set2efxmap S2 X XM2)
%         MX-XMd=X S1+XMd=>XM1) (XS<=FS:set`leq XS FS)
%       (DM-XMd=XS:efxmap`domain XMd XS) DM-FM=FS
%       CML _ nat`eq/)
%     (clsmap-cxt-effects/ DM-XM=S set`disjoint/R
%       collect-objs/0 set`leq/0 B-S clsmap-cxt-capmap/0)
%     <- efxmap`domain-total DM-XM1=XS1
%     <- set+map2map-implies-set+set2set S1+XMd=>XM1 DM-XMd=XS DM-XM1=XS1 S1+XS=>XS1
%     <- set+set2set-implies-clsmap-cxt-capmap SOC S1+XS=>XS1 CML DM-FM=FS XS<=FS CM-B-XS1
%     <- set2efxmap-implies-domain S2+X=>XM2 DM-XM2=S2
%     <- efxmap`domain-total DM-XM=S
%     <- efxmap`join-commute-domain XM1+XM2=XM DM-XM1=XS1 DM-XM2=S2 DM-XM=S S1+S2=S
%     <- join-preserves-clsmap-cxt-capmap CM-B-XS1 B-S2 S1+S2=S B-S.

% %worlds (objvar) (subtyping-consistent _ _ _ _ _).
% %trustme %total {} (subtyping-consistent _ _ _ _ _).


%{
 This theorem says if a term in our language can be type checked, then
 the resultput (especially for unique resultput) must be in a good format.
}%

%theorem reftyping-implies-clsmap-result
  : forall* {CM} {MM} {ENV} {E: expr} {R}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-ENV: clsmap-env CM ENV}
    {TYP: reftyping CM MM ENV E R}
    exists {CM-Rslt: clsmap-result CM R}
    true.

%worlds (objvar) (reftyping-implies-clsmap-result _ _ _ _).
%trustme %total (T) (reftyping-implies-clsmap-result _ _ T _).

% - : reftyping-implies-clsmap-result _ _ _ _ (reftyping/lit ty2reftype/shared _)
%     (clsmap-result/expr (clsmap-cxt-reftype/shared)
%       clsmap-cxt-effects/0 targets-effects/shared).

% - : reftyping-implies-clsmap-result
%     (wf-clsmap/ _ WF-CM) _ _ (CM-B:clsmap-cxt CM B)
%     (reftyping/lit ty2reftype/borrow
%       (BLO:cxt`lookup-obj B O N (ty/ NN annot/borrow C)))
%     (clsmap-result/expr
%       (clsmap-cxt-reftype/unique
%         (same-class/U same-class/0 set`not-member/0
%           set`update/0 BL)
%         (least-nonnull/U least-nonnull/0 set`not-member/0
%           set`update/0 BL (nonnull`leq/= nonnull`eq/))
%         (clsmap-cxt-objset/U clsmap-cxt-objset/0 BL CML set`not-member/0 set`update/0)
%         clsmap-cxt-capmap/0) clsmap-cxt-effects/0
%       (targets-effects/unique efxmap`domain/0 set`leq/0))
%     <- cxt`lookup-obj-implies-lookup BLO BL
%     <- cxt-lookup-implies-clsmap-ty WF-CM CM-B BL (clsmap-ty/ CML).

% - : reftyping-implies-clsmap-result WF-CM WF-B CM-CM CM-B
%     (reftyping/read TYP-E CML FML MG
%       (CF:consider-ftype G1 A Gx) (XJ:effects`join XXx1 _ XXx))
%     (clsmap-result/expr CM-B-GP CM-B-XX GP-XX)
%     <- reftyping-implies-clsmap-result WF-CM WF-B CM-CM CM-B TYP-E
%       (clsmap-result/expr CM-B-G CM-B-XX1 G-XX1)
%     <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
%     <- make-targets-and-effects-consistent
%       WF-CM WF-B CML FML CM-B-G MG CF CM-B-GP CM-B-XX2 G1-XX2
%     <- effects`join-right-preserves-targets-effects G1-XX2 XJ G1-XX
%     <- join-preserves-clsmap-cxt-effects CM-B-XX1 CM-B-XX2 XJ CM-B-XX
%     <- consider-ftype-preserves-targets-effects G1-XX CF GP-XX.

% %{ We can easily obtain G-XX5, but one issue is XX6.
% After we do XX5+XX6=XX7, we need to prove G-XX7. This is
% only true if the part of read/write effects corresponding to
% G is not "covered" by consume effects in XX6. The only restriction
% we have for XX6 is "compatible", which is a stronger condition
% (not only it disallow G to have corresponding consume effects
% in XX6, but also read/write effects in XX6, since read/write
% effects are encumbered and thus cannot be reused.
% }%

% - : reftyping-implies-clsmap-result WF-CM WF-B CM-CM CM-B
%     (reftyping/write RTYP-E1 RTYP-E2 CML FML MG CF SUB
%       (XX1+XX3=XX5:effects`join XXx1 _ XXx5)
%       (XX2+XX4=XX6:effects`join XXx2 XXx4 XXx6)
%       (XX5+XX6=XX7:effects`join XXx5 XXx6 XXx7) GSP)
%     (clsmap-result/expr CM-B-G CM-B-XX7 G-XX7)
%     <- reftyping-implies-clsmap-result WF-CM WF-B CM-CM CM-B RTYP-E1
%       (clsmap-result/expr CM-B-G1 CM-B-XX1 (G-XX1:targets-effects G1x XXx1))
%     <- reftyping-implies-clsmap-result WF-CM WF-B CM-CM CM-B RTYP-E2
%       (clsmap-result/expr CM-B-G2 CM-B-XX2 (G-XX2:targets-effects G2x XXx2))
%     <- make-targets-and-effects-consistent WF-CM WF-B
%       CML FML CM-B-G1 MG (CF:consider-ftype G1 A Gx)
%       CM-B-G CM-B-XX3 (G1-XX3:targets-effects G1 _)
%     <- join-preserves-clsmap-cxt-effects
%       CM-B-XX1 CM-B-XX3 XX1+XX3=XX5 CM-B-XX5
%     <- subtyping-consistent WF-CM WF-B CM-B-G2 SUB CM-B-XX4
%     <- join-preserves-clsmap-cxt-effects
%       CM-B-XX2 CM-B-XX4 XX2+XX4=XX6 CM-B-XX6
%     <- join-preserves-clsmap-cxt-effects
%       CM-B-XX5 CM-B-XX6 XX5+XX6=XX7 CM-B-XX7
%     <- effects`join-right-preserves-targets-effects G1-XX3 XX1+XX3=XX5 G1-XX5
%     <- compatible-right-join-preserves-targets-effects
%       G1-XX5 XX5+XX6=XX7 GSP G1-XX7
%     <- consider-ftype-preserves-targets-effects G1-XX7 CF G-XX7.


%%% reftyping only augment cxt, and may change unique type to borrow type.

%theorem reftyping-preserves-cxt-lookup-ty
  : forall* {CM} {MM} {B0} {B1} {M0} {M1} {E} {RT} {K} {O} {NN} {A1} {C}
    forall {TYP: reftyping CM MM (env/ B0 M0) E (result/expr RT (env/ B1 M1))}
    {BL: cxt`lookup B0 K (cxt-info/ O (ty/ NN A1 C))}
    exists {A2} {BL: cxt`lookup B1 K (cxt-info/ O (ty/ NN A2 C))}
    true.

%worlds (objvar) (reftyping-preserves-cxt-lookup-ty _ _ _ _).
%trustme %total { } (reftyping-preserves-cxt-lookup-ty _ _ _ _).