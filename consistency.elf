%% Consistency relation between various contexts.

%%% Consistency between a class map and a type.
%%% Check if the class ID is in clsmap

clsmap-ty : clsmap -> ty -> type.

clsmap-ty/ : clsmap`lookup CM C _ -> clsmap-ty CM (ty/ _ _ C).


%%% Consistency between a class map and a method type.
%%% Check if all types appear in methty is also in clsmap

clsmap-methty : clsmap -> methty -> type.

clsmap-methty/base :
    clsmap-ty CM T -> clsmap-methty CM (methty/base T).

clsmap-methty/args :
    clsmap-methty CM MT ->
    clsmap`lookup CM C FM ->
    fldmap`domain FM FS ->
    set`leq S FS ->
  clsmap-methty CM (methty/arg (ty/ _ _ C) S MT).


%%% Consistency between a class map and a field map.
%%% Check if a fldmap is consistent with a clsmap.

clsmap-fldmap : clsmap -> fldmap -> type.

clsmap-fldmap/0 : clsmap-fldmap _ fldmap/0.

clsmap-fldmap/+ :
    clsmap-fldmap CM FM ->
    clsmap-ty CM (ty/ NN A C) ->
    not-borrow A ->
  clsmap-fldmap CM (fldmap/+ _ (ty/ NN A C) FM).


%%% Well-formedness of a class map
%%% Check if a clsmap is consistent with itself.

clsmap-clsmap : clsmap -> clsmap -> type.

clsmap-clsmap/0 : clsmap-clsmap _ clsmap`map/0.

clsmap-clsmap/+ :
    clsmap-clsmap CM0 CMS ->
    clsmap`shift C CM CMS ->
    clsmap-fldmap CM0 FM ->
    clsmap`lookup CM0 C FM ->
  clsmap-clsmap CM0 (clsmap`map/+ C FM CM).

%%% Consistency between a class map and a method map.
%%% Check if a clsmap is consistent with a methmap

clsmap-methmap : clsmap -> methmap -> type.

clsmap-methmap/0 : clsmap-methmap _ methmap`map/0.

clsmap-methmap/U/meth :
    clsmap-methmap CM MM' ->
    clsmap-methty CM MT ->
    clsmap`fresh CM N ->
    methmap`fresh MM' N ->
    methmap`update MM' N MT MM ->
  clsmap-methmap CM MM.

clsmap-methmap/U/const :
    clsmap-methmap CM MM' ->
    clsmap-methty CM MT ->
    clsmap`lookup CM N FM ->
    fldmap`domain FM FS ->
    set`leq S FS ->
    methmap`fresh MM' N ->
    methmap`update MM' N (methty/arg (ty/ nn/yes _ N) S MT) MM ->
  clsmap-methmap CM MM.


%%% Consistency between clsmap and explicit context.
%%% All entries in the context should be either shared or borrowed.

clsmap-cxt : clsmap -> cxt -> type.

clsmap-cxt/0 : clsmap-cxt _ cxt/0.

clsmap-cxt/U :
    clsmap-cxt CM B' ->
    clsmap-ty CM T ->
    cxt`fresh B' N ->
    cxt`update B' N (cxt-info/ _ T) B ->
  clsmap-cxt CM B.


%%% This relation likes the one above, except all elements in the
%%% set are objs. So, we just need them to be in the context B.

clsmap-cxt-objset : clsmap -> cxt -> set -> type.

clsmap-cxt-objset/0 : clsmap-cxt-objset _ _ set/0.

clsmap-cxt-objset/U :
    clsmap-cxt-objset CM B S' ->
    cxt`lookup B N (cxt-info/ O (ty/ _ annot/unique C)) ->
    clsmap`lookup CM C FM ->
    set`not-member S' N ->
    set`add S' N S ->
  clsmap-cxt-objset CM B S.


cxt-unique-objset : cxt -> nonnull -> nat -> set -> type.

cxt-unique-objset/0 : cxt-unique-objset _ _ _ set/0.

cxt-unique-objset/U :
    cxt-unique-objset B NN C S' ->
    cxt`lookup B (s N) (cxt-info/ _ (ty/ NN' A C)) ->
    not-shared A ->
    nonnull`leq NN NN' ->
    set`not-member S' (s N) ->
    set`add S' (s N) S ->
  cxt-unique-objset B NN C S.


%%% This relation says all "pairs" (obj,fld) in the capset are valid:
%%% i.e., you can find obj in the context B with class id C, find C
%%% in the clsmap CM with FM, and find fld in FM with type T.

%%% We also need to show that there exists at least one element in the fld tgt set,
%%% such taht we can trace to the element, starting from the current result type.
%%% The tracing is performed bottom up. For each field we meet, it could be either
%%% unique or shared. If it is unique, we keep tracking up, until we hit the first
%%% field; if it is shared, we should stop.

%%% This is needed because
%%% in proving sub, we need to show that with permissions from
%%% reftype2perm/borrow we can derive permissions from reftype2unique. In this
%%% case, given a capset, we need to show that we can get a object permission
%%% from the resulted permissions, which in turn require we can prove that
%%% the object permission is nested inside at least one of the field target permissions.

%%% It is difficult to prove for the case where a unique object may come from shared.
%%% For example:
%%%   (if true new C().s.u else a).f = 3
%%% Here s is a shared field, while u and a are both unique.
%%% To find a common type for both branches, we need to show that in the "else" branch,
%%% given 0.all->0, we can prove that Pi_u, Pi_u --|- 0.all, which requires us to
%%% keep track of the information about s, and the chain from s to u. At the moment, I don't
%%% know how we can do that.

%%% The inputs are nonnull and first nat, which represent the nonnull info and
%%% class id for the result type. The outputs are the second, representing
%%% a root field target can be reached from the result type. It could be either
%%% unique or shared. The result type is assumed to be unique.

clsmap-cxt-unique-cap : clsmap -> cxt -> nat -> nonnull -> nat -> type.

%%% the "root" object should not be null too, but the leaf object's nonnullness
%%% is not determinted - it's upper-bounded by the nonnullness of the final value.
clsmap-cxt-unique-cap/base :
    nat2pair K (pair/ N F) ->
    cxt`lookup B N (cxt-info/ _ (ty/ nn/yes A C)) ->
    not-shared A ->
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F (ty/ FNN' annot/unique FC) ->
    nonnull`leq FNN FNN' ->
  clsmap-cxt-unique-cap CM B K FNN FC.

%%% To obtain the field permission, the object must not be null.
clsmap-cxt-unique-cap/nest :
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F (ty/ FNN annot/unique FC) ->
    clsmap-cxt-unique-cap CM B K nonnull/yes C ->
  clsmap-cxt-unique-cap CM B K FNN FC.


clsmap-cxt-unique-capset : clsmap -> cxt -> nonnull -> nat -> set -> type.

clsmap-cxt-unique-capset/0 : clsmap-cxt-unique-capset _ _ _ _ set/0.

clsmap-cxt-unique-capset/z :
    clsmap-cxt-unique-capset CM B NN C M' ->
    set`not-member M' shared ->
    set`add M' shared M ->
  clsmap-cxt-unique-capset CM B NN C M.

clsmap-cxt-unique-capset/U :
    clsmap-cxt-unique-capset CM B NN C M' ->
    clsmap-cxt-unique-cap CM B (s K) NN C ->
    set`not-member M' (s K) ->
    set`add M' (s K) M ->
  clsmap-cxt-unique-capset CM B NN C M.


clsmap-cxt-capset : clsmap -> cxt -> set -> type.

clsmap-cxt-capset/0 : clsmap-cxt-capset _ _ set/0.

clsmap-cxt-capset/z :
    clsmap-cxt-capset CM B M' ->
    set`not-member M' shared ->
    set`add M' shared M ->
  clsmap-cxt-capset CM B M.

clsmap-cxt-capset/U :
    clsmap-cxt-capset CM B M' ->
    nat2pair (s K) (pair/ N F) ->
    cxt`lookup B N (cxt-info/ _ (ty/ _ A C)) ->
    not-shared A ->
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F T ->
    set`not-member M' (s K) ->
    set`add M' (s K) M ->
  clsmap-cxt-capset CM B M.


wf-unique-targets : set -> set -> bool -> type.

wf-unique-targets/borrow :
    set`size S (s _) ->
    set`size M z ->
  wf-unique-targets S M false.

wf-unique-targets/unique :
    set`size M (s _) ->
  wf-unique-targets _ M false.

wf-unique-targets/unique+fresh :
  wf-unique-targets _ _ true.


%%% Well-formed reftype
%%% 1, The objset should contain all unique objects, which have the same class
%%% ID, and conform to the least nonnull-ness
%%% 2, The fldset should also be consistent with the context.
%%% TODO: perhaps we should restrict all object IDs in the fldset to be
%%%  unique as well?

clsmap-cxt-reftype : clsmap -> cxt -> reftype -> type.

clsmap-cxt-reftype/shared :
    clsmap`lookup CM C _ ->
  clsmap-cxt-reftype CM _ (reftype/ NN C targets/shared).

clsmap-cxt-reftype/fresh :
    clsmap`lookup CM C _ ->
  clsmap-cxt-reftype CM _ (reftype/ NN C targets/fresh).

clsmap-cxt-reftype/unique :
    clsmap`lookup CM C _ ->
    cxt-unique-objset B NN C S ->
    clsmap-cxt-unique-capset CM B NN C M ->
    wf-unique-targets S M W ->
  clsmap-cxt-reftype CM B (reftype/ NN C (targets/unique S M W)).


clsmap-cxt-env : clsmap -> cxt -> env -> type.

clsmap-cxt-env/ :
    clsmap-cxt-objset CM B U ->
    clsmap-cxt-capset CM B M ->
  clsmap-cxt-env CM B (env/ U M).


clsmap-result/expr :
    clsmap-cxt-reftype CM B RT ->
    clsmap-cxt-env CM B V ->
  clsmap-result CM B (result/expr RT V).

clsmap-result/cond :
    clsmap-cxt-env CM B V ->
  clsmap-result CM B (result/cond V).

clsmap-result/args/0 :
    clsmap-cxt-env CM B V ->
  clsmap-result CM B (result/args/0 V).

clsmap-result/args/+ :
    clsmap-cxt-reftype CM B RT ->
    clsmap-cxt-env CM B V ->
    clsmap-result CM B AR ->
  clsmap-result CM B (result/args/+ RT V AR).

%%% Theorems

%% clsmap, fldmap, methmap, etc.

%theorem clsmap-ty-respects-eq
  : forall* {CM1} {CM2} {T1} {T2}
    forall {CM1-T1: clsmap-ty CM1 T1}
    {E: clsmap`eq CM1 CM2} {E: ty`eq T1 T2}
    exists {CM2-T2: clsmap-ty CM2 T2}
    true.

- : clsmap-ty-respects-eq D clsmap`eq/ ty`eq/ D.

%worlds (gtermvar) (clsmap-ty-respects-eq _ _ _ _).
%total {} (clsmap-ty-respects-eq _ _ _ _).


%theorem clsmap-ty-respects-leq
  : forall* {CM0} {CM1} {T}
    forall {CM0-T: clsmap-ty CM0 T}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-T: clsmap-ty CM1 T}
    true.

- : clsmap-ty-respects-leq (clsmap-ty/ L0)
    CM0<=CM1 (clsmap-ty/ L1)
    <- clsmap`lookup-respects-leq L0 CM0<=CM1 _ L1 _.

% - : clsmap-ty-respects-leq clsmap-ty/null _ clsmap-ty/null.

%worlds (gtermvar) (clsmap-ty-respects-leq _ _ _).
%total {} (clsmap-ty-respects-leq _ _ _).


%theorem clsmap-fldmap-respects-leq
  : forall* {CM0} {CM1} {FM}
    forall {CM0-FM: clsmap-fldmap CM0 FM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-FM: clsmap-fldmap CM1 FM}
    true.

- : clsmap-fldmap-respects-leq clsmap-fldmap/0 _ clsmap-fldmap/0.

- : clsmap-fldmap-respects-leq (clsmap-fldmap/+ CM0-FM CM0-T NB)
    CM0<=CM1 (clsmap-fldmap/+ CM1-FM CM1-T NB)
    <- clsmap-ty-respects-leq CM0-T CM0<=CM1 CM1-T
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM.

%worlds (gtermvar) (clsmap-fldmap-respects-leq _ _ _).
%total (CM-FM) (clsmap-fldmap-respects-leq CM-FM _ _).


%theorem clsmap-clsmap-respects-leq
  : forall* {CM0} {CM1} {CM}
    forall {CM0-CM: clsmap-clsmap CM0 CM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-CM: clsmap-clsmap CM1 CM}
    true.

- : clsmap-clsmap-respects-leq clsmap-clsmap/0 _ clsmap-clsmap/0.

- : clsmap-clsmap-respects-leq (clsmap-clsmap/+ CM0-CMS SH CM0-FM CM0-L)
    CM0<=CM1 (clsmap-clsmap/+ CM1-CMS SH CM1-FM CM1-L)
    <- clsmap`lookup-respects-leq CM0-L CM0<=CM1 _ CM1-LP EQ
    <- fldmap`eq-symmetric EQ EQP
    <- clsmap`lookup-respects-eq CM1-LP clsmap`eq/ nat`eq/ EQP CM1-L
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM
    <- clsmap-clsmap-respects-leq CM0-CMS CM0<=CM1 CM1-CMS.

%worlds (gtermvar) (clsmap-clsmap-respects-leq _ _ _).
%total (CM-CM) (clsmap-clsmap-respects-leq CM-CM _ _).


%theorem shift-preserves-clsmap-fldmap
  : forall* {CM} {FM} {FMP} {N}
    forall {CM-FM: clsmap-fldmap CM FM}
    {SH: fldmap`shift N FM FMP}
    exists {CM-FM: clsmap-fldmap CM FMP}
    true.

- : shift-preserves-clsmap-fldmap clsmap-fldmap/0 _ clsmap-fldmap/0.

- : shift-preserves-clsmap-fldmap
    (clsmap-fldmap/+ CM-FM CM-T NB) SH (clsmap-fldmap/+ CM-FM CM-T NB).

%worlds (gtermvar) (shift-preserves-clsmap-fldmap _ _ _).
%total {} (shift-preserves-clsmap-fldmap _ _ _).


%{ This theorem says if under a "bigger" clsmap CM0, CM
 is well-defined, and class C in CM has fldmap FM, then all
 classes in FM is well-defined under CM0 }%

%theorem lookup-implies-clsmap-fldmap
  : forall* {M} {CM} {FM} {C}
    forall {M-CM: clsmap-clsmap M CM}
    {L: clsmap`lookup CM C FM}
    exists {M-FM: clsmap-fldmap M FM}
    true.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ _ _ M-FM _)
     (clsmap`lookup/= _) M-FM.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ M-CMP SH _ _)
     (clsmap`lookup/> L P0) M-FM
     <- nat`plus-swap-succ P0 P1
     <- nat`plus-commutative P1 P2
     <- clsmap`shift-preserves-lookup* L SH P2 L2
     <- lookup-implies-clsmap-fldmap M-CMP L2 M-FM.

%worlds (gtermvar) (lookup-implies-clsmap-fldmap _ _ _).
%total (M-CM) (lookup-implies-clsmap-fldmap M-CM _ _).


%theorem clsmap-fldmap/U-inversion
  : forall* {CM} {FM} {FM'} {T} {F}
    forall {CM-FM: clsmap-fldmap CM FM}
    {FS: fldmap`fresh FM' F}
    {UD: fldmap`update FM' F T FM}
    exists {CM-T: clsmap-ty CM T}
    {CM-FM: clsmap-fldmap CM FM'}
    true.

%worlds (gtermvar) (clsmap-fldmap/U-inversion _ _ _ _ _).
%trustme %total { } (clsmap-fldmap/U-inversion _ _ _ _ _).


%theorem lookup-implies-clsmap-ty
  : forall* {CM} {FM} {F} {T}
    forall {CM-FM: clsmap-fldmap CM FM}
    {FM-L: fldmap`lookup FM F T}
    exists {CM-NT: clsmap-ty CM T}
    true.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM CM-T _)
    (fldmap`lookup/= _) CM-T.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM _ _)
    (fldmap`lookup/> LP _) CM-T
    <- lookup-implies-clsmap-ty CM-FM LP CM-T.

%worlds (gtermvar) (lookup-implies-clsmap-ty _ _ _).
%total (CM-FM) (lookup-implies-clsmap-ty CM-FM _ _).


%theorem lookup-implies-not-borrow
  : forall* {CM} {FM} {F} {NN} {A} {C}
    forall {CM-FM: clsmap-fldmap CM FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A C)}
    exists {NB: not-borrow A}
    true.

- : lookup-implies-not-borrow (clsmap-fldmap/+ CM-FM _ NB)
    (fldmap`lookup/= _) NB.

- : lookup-implies-not-borrow (clsmap-fldmap/+ CM-FM _ _)
    (fldmap`lookup/> LP _) CM-T
    <- lookup-implies-not-borrow CM-FM LP CM-T.

%worlds (gtermvar) (lookup-implies-not-borrow _ _ _).
%total (CM-FM) (lookup-implies-not-borrow CM-FM _ _).


%theorem clsmap-methty-respects-eq
  : forall* {CM0} {MT0} {CM1} {MT1}
    forall {CM0-MT0: clsmap-methty CM0 MT0}
    {CM0=CM1: clsmap`eq CM0 CM1} {MT0=MT1: methty`eq MT0 MT1}
    exists {CM1-MT1: clsmap-methty CM1 MT1}
    true.

- : clsmap-methty-respects-eq CM-MT clsmap`eq/ methty`eq/ CM-MT.

%worlds (gtermvar) (clsmap-methty-respects-eq _ _ _ _).
%total { } (clsmap-methty-respects-eq _ _ _ _).


%theorem clsmap-methmap-respects-eq
  : forall* {CM0} {MM0} {CM1} {MM1}
    forall {CM0-MM0: clsmap-methmap CM0 MM0}
    {CM0=CM1: clsmap`eq CM0 CM1} {MM0=MM1: methmap`eq MM0 MM1}
    exists {CM1-MM1: clsmap-methmap CM1 MM1}
    true.

- : clsmap-methmap-respects-eq CM-MM clsmap`eq/ methmap`eq/ CM-MM.

%worlds (gtermvar) (clsmap-methmap-respects-eq _ _ _ _).
%total { } (clsmap-methmap-respects-eq _ _ _ _).


%theorem clsmap-methmap/U/meth-inversion
  : forall* {CM} {MM} {MM'} {N} {MT}
    forall {CM-MM: clsmap-methmap CM MM}
    {N!<CM: clsmap`fresh CM N}
    {N!<MM': methmap`fresh MM' N}
     {MM'+N=MM: methmap`update MM' N MT MM}
    exists {CM-MT: clsmap-methty CM MT}
    {CM-MM': clsmap-methmap CM MM'}
    true.

%theorem clsmap-methmap/U/meth-inversion/L
  : forall* {CM} {MM} {MM'} {N} {MT} {MM0} {N0} {MT0} {P}
    forall {CM-MM0: clsmap-methmap CM MM0}
    {CM-MT0: clsmap-methty CM MT0}
    {N0!<CM: clsmap`fresh CM N0}
    {N0!<MM0: methmap`fresh MM0 N0}
    {MM0+N0=MM: methmap`update MM0 N0 MT0 MM}
    {N!<CM: clsmap`fresh CM N}
    {N!<MM': methmap`fresh MM' N}
    {MM'+N=MM: methmap`update MM' N MT MM}
    {EQ?: nat`eq? N N0 P}
    exists {CM-MT: clsmap-methty CM MT}
    {CM-MM': clsmap-methmap CM MM'}
    true.

- : clsmap-methmap/U/meth-inversion/L
    CM-MM0 CM-MT0 CM-FS0 F0 U0 CM-FS F U nat`eq?/yes CM-MT CM-MM
    <- methmap`fresh-update-cancels F0 U0 F U nat`eq/ methmap`eq/ MT-EQ MM-EQ
    <- clsmap-methmap-respects-eq CM-MM0 clsmap`eq/ MM-EQ CM-MM
    <- clsmap-methty-respects-eq CM-MT0 clsmap`eq/ MT-EQ CM-MT.

- : clsmap-methmap/U/meth-inversion/L
    CM-MM0 CM-MT0 CM-FS0 F0 U0 CM-FS F U (nat`eq?/no (N<>N0:nat`ne N N0)) CM-MT
    (clsmap-methmap/U/meth CM-MM CM-MT0 CM-FS0 F4 U4)
    <- methmap`update-commutes-converse U U0 N<>N0 _ U4 U3
    <- methmap`update-preserves-fresh-converse F U4 F3
    <- methmap`update-preserves-fresh-converse F0 U3 F4
    <- clsmap-methmap/U/meth-inversion CM-MM0 CM-FS F3 U3 CM-MT CM-MM.

- : clsmap-methmap/U/meth-inversion
    (clsmap-methmap/U/meth CM-MM0 CM-MT0 N0!<CM F0 U0) N!<CM F U CM-MT CM-MM
    <- nat`eq?-total EQ?
    <- clsmap-methmap/U/meth-inversion/L CM-MM0 CM-MT0 N0!<CM F0 U0
      N!<CM F U EQ? CM-MT CM-MM.

- : clsmap-methmap/U/meth-inversion
    (clsmap-methmap/U/const CM-MM0 CM-MT0 CML0 DM LE F0 U0)
    N!<CM F U CM-MT (clsmap-methmap/U/const CM-MM CM-MT0 CML0 DM LE F3 U3)
    <- clsmap`fresh-lookup-not-equal N!<CM CML0 NE
    <- methmap`update-commutes-converse U U0 NE _ U3 U2
    <- methmap`update-preserves-fresh-converse F U3 F2
    <- methmap`update-preserves-fresh-converse F0 U2 F3
    <- clsmap-methmap/U/meth-inversion CM-MM0 N!<CM F2 U2 CM-MT CM-MM.

%worlds (gtermvar) (clsmap-methmap/U/meth-inversion _ _ _ _ _ _)
  (clsmap-methmap/U/meth-inversion/L _ _ _ _ _ _ _ _ _ _ _).
%total (A A0) (clsmap-methmap/U/meth-inversion A _ _ _ _ _)
  (clsmap-methmap/U/meth-inversion/L A0 _ _ _ _ _ _ _ _ _ _).


%theorem clsmap-methmap/U/const-inversion
  : forall* {CM} {MM} {MM'} {N} {MT} {FM}
    forall {CM-MM: clsmap-methmap CM MM}
    {CML: clsmap`lookup CM N FM}
    {N!<MM': methmap`fresh MM' N}
    {MM'+N=MM: methmap`update MM' N MT MM}
    exists {FS} {A} {MT0} {S}
    {EQ: methty`eq (methty/arg (ty/ nn/yes A N) S MT0) MT}
    {CM-MT: clsmap-methty CM MT0}
    {DM: fldmap`domain FM FS}
    {LE: set`leq S FS}
    {CM-MM': clsmap-methmap CM MM'}
    true.

%theorem clsmap-methmap/U/const-inversion/L
  : forall* {CM} {MM} {MM'} {N} {MT} {FM}
    {MM0} {MT00} {N0} {FM0} {FS0} {S0} {A0} {P}
    forall {CM-MM0: clsmap-methmap CM MM0}
    {CM-MT0: clsmap-methty CM MT00}
    {CML0: clsmap`lookup CM N0 FM0}
    {DM0: fldmap`domain FM0 FS0}
    {LE0: set`leq S0 FS0}
    {N0!<MM0: methmap`fresh MM0 N0}
    {MM0+N0=MM: methmap`update MM0 N0 (methty/arg (ty/ nn/yes A0 N0) S0 MT00) MM}
    {CML: clsmap`lookup CM N FM}
    {N!<MM': methmap`fresh MM' N}
    {MM'+N=MM: methmap`update MM' N MT MM}
    {EQ?: nat`eq? N N0 P}
    exists {FS} {A} {MT0} {S}
    {EQ: methty`eq (methty/arg (ty/ nn/yes A N) S MT0) MT}
    {CM-MT: clsmap-methty CM MT0}
    {DM: fldmap`domain FM FS}
    {LE: set`leq S FS}
    {CM-MM': clsmap-methmap CM MM'}
    true.

- : clsmap-methmap/U/const-inversion/L
    CM-MM0 CM-MT0 CML0 DM0 LE0 F0 U0 CML F U nat`eq?/yes
    _ _ _ _ MT-EQ CM-MT0 DM1 LE0 CM-MM
    <- methmap`fresh-update-cancels F0 U0 F U nat`eq/ methmap`eq/ MT-EQ MM-EQ
    <- clsmap-methmap-respects-eq CM-MM0 clsmap`eq/ MM-EQ CM-MM
    <- clsmap`lookup-unique CML0 CML clsmap`eq/ nat`eq/ FM-EQ
    <- fldmap`domain-respects-eq DM0 FM-EQ set`eq/ DM1.

- : clsmap-methmap/U/const-inversion/L
    CM-MM0 CM-MT0 CML0 DM0 LE0 F0 U0
    CML F U (nat`eq?/no (N<>N0:nat`ne N N0))
    FS A MT0 S MT-EQ CM-MT DM LE
    (clsmap-methmap/U/const CM-MM CM-MT0 CML0 DM0 LE0 F4 U4)
    <- methmap`update-commutes-converse U U0 N<>N0 _ U4 U3
    <- methmap`update-preserves-fresh-converse F U4 F3
    <- methmap`update-preserves-fresh-converse F0 U3 F4
    <- clsmap-methmap/U/const-inversion CM-MM0 CML F3 U3 _ _ _ _ MT-EQ CM-MT DM LE CM-MM.


- : clsmap-methmap/U/const-inversion
    (clsmap-methmap/U/meth CM-MM0 CM-MT0 N0!<CM F0 U0) CML F U
    _ _ _ _ MT-EQ CM-MT DM LE (clsmap-methmap/U/meth CM-MM CM-MT0 N0!<CM F3 U3)
    <- clsmap`fresh-lookup-not-equal N0!<CM CML NE'
    <- nat`ne-symmetric NE' NE
    <- methmap`update-commutes-converse U U0 NE _ U3 U2
    <- methmap`update-preserves-fresh-converse F U3 F2
    <- methmap`update-preserves-fresh-converse F0 U2 F3
    <- clsmap-methmap/U/const-inversion CM-MM0 CML F2 U2 _ _ _ _ MT-EQ CM-MT DM LE CM-MM.

- : clsmap-methmap/U/const-inversion
    (clsmap-methmap/U/const CM-MM0 CM-MT0 CML0 DM0 LE0 F0 U0)
    CML F U _ _ _ _ MT-EQ CM-MT DE LE CM-MM
    <- nat`eq?-total EQ?
    <- clsmap-methmap/U/const-inversion/L CM-MM0 CM-MT0 CML0 DM0 LE0 F0 U0
      CML F U EQ? _ _ _ _ MT-EQ CM-MT DE LE CM-MM.

%worlds (gtermvar) (clsmap-methmap/U/const-inversion _ _ _ _ _ _ _ _ _ _ _ _ _)
  (clsmap-methmap/U/const-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A A0) (clsmap-methmap/U/const-inversion A _ _ _ _ _ _ _ _ _ _ _ _)
  (clsmap-methmap/U/const-inversion/L A0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem lookup-implies-clsmap-methty
  : forall* {CM} {MM} {MT} {M}
    forall {CM-MM: clsmap-methmap CM MM}
    {MM-LP: methmap`lookup MM M MT}
    exists {CM-MT: clsmap-methty CM MT}
    true.

%theorem lookup-implies-clsmap-methty/L
  : forall* {CM} {MM} {MT} {N}
    forall {CM-MM: clsmap-methmap CM MM}
    {MML: methmap`lookup MM N MT}
    {B} {MB?: clsmap`domain? CM N B}
    exists {CM-MT: clsmap-methty CM MT}
    true.

- : lookup-implies-clsmap-methty/L CM-MM MM-L
    false (clsmap`domain?/out N!<CM) CM-MT
    <- methmap`lookup-implies-fresh-update MM-L _ MM-F MM-U
    <- clsmap-methmap/U/meth-inversion CM-MM N!<CM MM-F MM-U CM-MT _.

- : lookup-implies-clsmap-methty/L CM-MM MM-L
    true (clsmap`domain?/in CML) CM-MT
    <- methmap`lookup-implies-fresh-update MM-L _ MM-F MM-U
    <- clsmap-methmap/U/const-inversion CM-MM CML MM-F MM-U
      _ _ _ _ MT-EQ CM-MT0 DM LE _
    <- clsmap-methty-respects-eq (clsmap-methty/args CM-MT0 CML DM LE)
      clsmap`eq/ MT-EQ CM-MT.

%worlds (gtermvar) (lookup-implies-clsmap-methty/L _ _ _ _ _).
%total { } (lookup-implies-clsmap-methty/L _ _ _ _ _).

- : lookup-implies-clsmap-methty CM-MM MM-L CM-MT
    <- clsmap`domain?-total CM-DM?
    <- lookup-implies-clsmap-methty/L CM-MM MM-L _ CM-DM? CM-MT.

%worlds (gtermvar) (lookup-implies-clsmap-methty _ _ _).
%total { } (lookup-implies-clsmap-methty _ _ _).


%%% clsmap-cxt

%theorem false-implies-clsmap-cxt
  : forall* {CM} {B}
    forall {V:void}
    exists {CM-B: clsmap-cxt CM B}
    true.

%worlds (gtermvar) (false-implies-clsmap-cxt _ _).
%total { } (false-implies-clsmap-cxt _ _).


%theorem clsmap-cxt/U-inversion
  : forall* {CM} {B} {B'} {N} {O} {T}
    forall {CM-B: clsmap-cxt CM B}
    {N!<B: cxt`fresh B' N}
    {B'+N=B: cxt`update B' N (cxt-info/ O T) B}
    exists {CM-B': clsmap-cxt CM B'}
    {CM-T: clsmap-ty CM T}
    true.

%worlds () (clsmap-cxt/U-inversion _ _ _ _ _).
%trustme %total { } (clsmap-cxt/U-inversion _ _ _ _ _).


%theorem clsmap-cxt-respects-fresh-update-converse
  : forall* {CM} {B} {B'} {N} {CI}
    forall {CM-B: clsmap-cxt CM B}
    {N!<B': cxt`fresh B' N}
    {B'+N=B: cxt`update B' N CI B}
    exists {CM-B': clsmap-cxt CM B'}
    true.

%worlds () (clsmap-cxt-respects-fresh-update-converse _ _ _ _).
%trustme %total { } (clsmap-cxt-respects-fresh-update-converse _ _ _ _).


%theorem cxt-lookup-implies-clsmap-ty
  : forall* {CM} {B} {T} {O} {N}
    forall {CM-B: clsmap-cxt CM B}
    {B-L: cxt`lookup B N (cxt-info/ O T)}
    exists {CM-T: clsmap-ty CM T}
    true.

%theorem cxt-lookup-implies-clsmap-ty/L
  : forall* {CM} {B} {B'} {T} {O} {T'} {O'} {N} {N'} {K}
    forall {CM-B: clsmap-cxt CM B'}
    {CM-T: clsmap-ty CM T'}
    {U: cxt`update B' N' (cxt-info/ O' T') B}
    {BL: cxt`lookup B N (cxt-info/ O T)}
    {EQ?: nat`eq? N N' K}
    exists {CM-T: clsmap-ty CM T}
    true.

- : cxt-lookup-implies-clsmap-ty/L CM-B' CM-T' U BL nat`eq?/yes CM-T
    <- cxt`update-implies-lookup U BL'
    <- cxt`lookup-unique BL' BL cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE _ TE
    <- clsmap-ty-respects-eq CM-T' clsmap`eq/ TE CM-T.

- : cxt-lookup-implies-clsmap-ty/L CM-B' CM-T' U BL
    (nat`eq?/no (N<>N':nat`ne N N')) CM-T
    <- cxt`update-preserves-lookup-converse BL U N<>N' BL'
    <- cxt-lookup-implies-clsmap-ty CM-B' BL' CM-T.

- : cxt-lookup-implies-clsmap-ty (clsmap-cxt/U CM-B' CM-T' F U) BL CM-T
    <- nat`eq?-total EQ?
    <- cxt-lookup-implies-clsmap-ty/L CM-B' CM-T' U BL EQ? CM-T.

%worlds (gtermvar) (cxt-lookup-implies-clsmap-ty _ _ _)
  (cxt-lookup-implies-clsmap-ty/L _ _ _ _ _ _).
%total (CM-B CM-B') (cxt-lookup-implies-clsmap-ty CM-B _ _)
  (cxt-lookup-implies-clsmap-ty/L CM-B' _ _ _ _ _).


%theorem cxt-lookup-obj-implies-clsmap-ty
  : forall* {CM} {B} {T} {N} {O}
    forall {CM-B: clsmap-cxt CM B}
    {B-L: cxt`lookup-obj B O N T}
    exists {CM-T: clsmap-ty CM T}
    true.

- : cxt-lookup-obj-implies-clsmap-ty CM-B (cxt`lookup-obj/ BL) CM-T
    <- cxt-lookup-implies-clsmap-ty CM-B BL CM-T.

%worlds (gtermvar) (cxt-lookup-obj-implies-clsmap-ty _ _ _).
%total (CM-B) (cxt-lookup-obj-implies-clsmap-ty CM-B _ _).


%%% =============================================================
%%% Theorems about clsmap-cxt-objset
%%% =============================================================

%theorem false-implies-clsmap-cxt-objset
  : forall* {CM} {B} {S}
    forall {F:void} exists {CBS2: clsmap-cxt-objset CM B S}
    true.

%worlds (gtermvar) (false-implies-clsmap-cxt-objset _ _).
%total { } (false-implies-clsmap-cxt-objset _ _).


%theorem clsmap-cxt-objset-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {S1} {S2}
    forall {CM1-B1-S1: clsmap-cxt-objset CM1 B1 S1}
    {EQ: clsmap`eq CM1 CM2}
    {EQ: cxt`eq B1 B2} {EQ: set`eq S1 S2}
    exists {CM2-B2-S2: clsmap-cxt-objset CM2 B2 S2}
    true.

- : clsmap-cxt-objset-respects-eq A clsmap`eq/ cxt`eq/ set`eq/ A.

%worlds (gtermvar) (clsmap-cxt-objset-respects-eq _ _ _ _ _).
%total {} (clsmap-cxt-objset-respects-eq _ _ _ _ _).


%theorem cxt-fresh-update-preserves-clsmap-cxt-objset
  : forall* {CM} {B} {BP} {N} {CI} {OS}
    forall {CM-OS: clsmap-cxt-objset CM B OS}
    {BF: cxt`fresh B N}
    {BU: cxt`update B N CI BP}
    exists {CM-OS: clsmap-cxt-objset CM BP OS}
    true.

- : cxt-fresh-update-preserves-clsmap-cxt-objset clsmap-cxt-objset/0 _ _ clsmap-cxt-objset/0.

- : cxt-fresh-update-preserves-clsmap-cxt-objset
    (clsmap-cxt-objset/U (CM-B-OS':clsmap-cxt-objset CM B OS') BL CML K!<OS' OS'+K=OS)
    (N!<B:cxt`fresh B N) (B+N+CI=BP:cxt`update B N _ BP)
    (clsmap-cxt-objset/U CM-BP-OS' BPL CML K!<OS' OS'+K=OS)
    <- cxt-fresh-update-preserves-clsmap-cxt-objset CM-B-OS' N!<B B+N+CI=BP CM-BP-OS'
    <- cxt`fresh-update-preserves-lookup BL N!<B B+N+CI=BP BPL.

%worlds (gtermvar) (cxt-fresh-update-preserves-clsmap-cxt-objset _ _ _ _).
%total (CM-OS) (cxt-fresh-update-preserves-clsmap-cxt-objset CM-OS _ _ _).


%theorem clsmap-cxt-objset/U-inversion
  : forall* {CM} {B} {S} {S'} {N}
    forall {CM-B-S: clsmap-cxt-objset CM B S}
    {NM: set`not-member S' N}
    {AD: set`add S' N S}
    exists {CM-B-S': clsmap-cxt-objset CM B S'}
    {O} {NN} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN annot/unique C))}
    {FM} {CML: clsmap`lookup CM C FM}
    true.

%theorem clsmap-cxt-objset/U-inversion/L
  : forall* {CM} {B} {S} {S'} {S1'} {N} {N1} {P} {O1} {NN1} {C1} {FM1}
    forall {CM-B-S: clsmap-cxt-objset CM B S1'}
    {NM1: set`not-member S1' N1}
    {AD1: set`add S1' N1 S}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 annot/unique C1))}
    {CML1: clsmap`lookup CM C1 FM1}
    {NM: set`not-member S' N}
    {AD: set`add S' N S}
    {EQ?: nat`eq? N N1 P}
    exists {CM-B-S': clsmap-cxt-objset CM B S'}
    {O} {NN} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN annot/unique C))}
    {FM} {CML: clsmap`lookup CM C FM}
    true.

- : clsmap-cxt-objset/U-inversion/L CM-B-S F1 U1 BL1 CML1 F U
    nat`eq?/yes CM-B-S' _ _ _ BL1 _ CML1
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- clsmap-cxt-objset-respects-eq CM-B-S clsmap`eq/ cxt`eq/ S1=S CM-B-S'.

- : clsmap-cxt-objset/U-inversion/L CM-B-S F1 U1 BL CML
    F U (nat`eq?/no N<>N1) (clsmap-cxt-objset/U CM-B-S2 BL CML F3 U3)
    _ _ _ BL2 _ CML2
    <- set`add-commutes-converse U U1 N<>N1 _ U3 U2
    <- set`add-preserves-not-member-converse F U3 F2
    <- set`add-preserves-not-member-converse F1 U2 F3
    <- clsmap-cxt-objset/U-inversion CM-B-S F2 U2 CM-B-S2 _ _ _ BL2 _ CML2.

- : clsmap-cxt-objset/U-inversion
    (clsmap-cxt-objset/U CM-B-S0 BL0 CML F0 U0) F1 U1 CM-B-S1 _ _ _ BL1 _ CML1
    <- nat`eq?-total E?
    <- clsmap-cxt-objset/U-inversion/L CM-B-S0 F0 U0 BL0 CML
      F1 U1 E? CM-B-S1 _ _ _ BL1 _ CML1.

%worlds (gtermvar) (clsmap-cxt-objset/U-inversion _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-objset/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (clsmap-cxt-objset/U-inversion C0 _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-objset/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem clsmap-cxt-objset-respects-geq
  : forall* {S} {SP} {CM} {B}
    forall {B-SP: clsmap-cxt-objset CM B SP}
    {S1<=S2: set`leq S SP}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : clsmap-cxt-objset-respects-geq clsmap-cxt-objset/0 set`leq/0 clsmap-cxt-objset/0.

%theorem clsmap-cxt-objset-respects-geq/U
  : forall* {CM} {SS} {SP} {N} {B} {NN} {C} {S} {O} {FM}
    forall {P} {IN?: set`member? S N P}
    {NM: set`not-member SS N}
    {UD: set`add SS N SP}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN annot/unique C))}
    {CML: clsmap`lookup CM C FM}
    {B-SS: clsmap-cxt-objset CM B SS}
    {S<=SP: set`leq S SP}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : clsmap-cxt-objset-respects-geq/U true (set`member?/in N<-S)
    NM UD BL CML B-SS S<=SP
    (clsmap-cxt-objset/U CM-B-ST BL CML N!<ST ADD)
    <- set`member-implies-not-member-add N<-S ST N!<ST ADD
    <- set`not-member-add-preserves-leq-converse S<=SP N!<ST ADD NM UD ST<=SS
    <- clsmap-cxt-objset-respects-geq B-SS ST<=SS CM-B-ST.

- : clsmap-cxt-objset-respects-geq/U false (set`member?/out N!<S)
    NM UD BL CML B-SS S<=SP B-S
    <- set`not-member-add2-preserves-leq-converse S<=SP N!<S NM UD S<=SS
    <- clsmap-cxt-objset-respects-geq B-SS S<=SS B-S.

- : clsmap-cxt-objset-respects-geq
    (clsmap-cxt-objset/U B-SS BL CML NM UD) S<=SP B-S
    <- set`member?-total MB?
    <- clsmap-cxt-objset-respects-geq/U _ MB? NM UD BL CML B-SS S<=SP B-S.

%worlds (gtermvar) (clsmap-cxt-objset-respects-geq _ _ _)
	(clsmap-cxt-objset-respects-geq/U _ _ _ _ _ _ _ _ _).
%total (L1 L2) (clsmap-cxt-objset-respects-geq L1 _ _)
	(clsmap-cxt-objset-respects-geq/U _ _ _ _ _ _ L2 _ _).


%theorem join-preserves-clsmap-cxt-objset
  : forall* {CM} {B} {S1} {S2} {S}
    forall {B-S1: clsmap-cxt-objset CM B S1}
    {B-S2: clsmap-cxt-objset CM B S2}
    {J: set`union S1 S2 S}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

%theorem join-preserves-clsmap-cxt-objset/L
  : forall* {CM} {B} {S1} {S2} {S}
    forall {N} {SZ: set`size S N}
    {B-S1: clsmap-cxt-objset CM B S1}
    {B-S2: clsmap-cxt-objset CM B S2}
    {J: set`union S1 S2 S}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : join-preserves-clsmap-cxt-objset/L
    _ set`size/0 clsmap-cxt-objset/0 CBS set`union/L CBS.

- : join-preserves-clsmap-cxt-objset/L
    _ set`size/0 CBS clsmap-cxt-objset/0 set`union/R CBS.

%theorem join-preserves-clsmap-cxt-objset/LL
  : forall* {CM} {B} {S1} {S2} {S} {SP} {K} {B1} {B2}
    forall {N} {SZ: set`size S N}
    {B-S1: clsmap-cxt-objset CM B S1}
    {B-S2: clsmap-cxt-objset CM B S2}
    {J: set`union S1 S2 S}
    {F: set`not-member SP K}
    {A: set`add SP K S}
    {D1?: set`member? S1 K B1}
    {D2?: set`member? S2 K B2}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/in (L1:set`member S1 K)) (set`member?/in L2)
    (clsmap-cxt-objset/U CBSP BL2 CML2 F U)
    <- set`member-implies-not-member-add L1 S1P F1 U1
    <- set`member-implies-not-member-add L2 S2P F2 U2
    <- set`add-implies-member U L
    <- set`not-member-update-preserves-union-converse*
      F1 U1 F2 U2 SU F U unit`union/ SUP
    <- clsmap-cxt-objset/U-inversion CBS1 F1 U1 CBS1P _ _ _ BL1 _ CML1
    <- clsmap-cxt-objset/U-inversion CBS2 F2 U2 CBS2P _ _ _ BL2 _ CML2
    <- set`not-member-add-increases-size-converse Z F U ZP
    <- join-preserves-clsmap-cxt-objset/L _ ZP CBS1P CBS2P SUP CBSP.

- : join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/in _) (set`member?/out F2)
    (clsmap-cxt-objset/U CBSP BL1 CML1 F U)
    <- set`add-implies-member U L
    <- set`not-member-union-right-preserves-member-converse L F2 SU L1
    <- set`member-implies-not-member-add L1 _ F1 U1
    <- clsmap-cxt-objset/U-inversion CBS1 F1 U1 CBS1P _ _ _ BL1 _ CML1
    <- set`not-member-update-left-preserves-union-converse* F1 U1 F2 SU F U SU1
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-objset/L _ Z1 CBS1P CBS2 SU1 CBSP.

- : join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/out F1) (set`member?/in _)
    (clsmap-cxt-objset/U CBSP BL2 CML2 F U)
    <- set`add-implies-member U L
    <- set`not-member-union-left-preserves-member-converse F1 L SU L2
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- clsmap-cxt-objset/U-inversion CBS2 F2 U2 CBS2P _ _ _ BL2 _ CML2
    <- set`not-member-update-right-preserves-union-converse* F1 F2 U2 SU F U SU2
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-objset/L _ Z1 CBS1 CBS2P SU2 CBSP.

- : join-preserves-clsmap-cxt-objset/LL _ _ _ _ SU _ U
    (set`member?/out F1) (set`member?/out F2) CBS
    <- set`union-preserves-not-member* F1 F2 SU F
    <- set`add-implies-member U L
    <- set`not-member-member-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-clsmap-cxt-objset V CBS.

- : join-preserves-clsmap-cxt-objset/L (s N) Z CBS1 CBS2 SU CBS
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) _ F U
    <- set`member?-total D1?
    <- set`member?-total D2?
    <- join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U D1? D2? CBS.

%worlds (gtermvar) (join-preserves-clsmap-cxt-objset/LL _ _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-objset/L _ _ _ _ _ _).
%total (N1 N2) (join-preserves-clsmap-cxt-objset/LL N1 _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-objset/L N2 _ _ _ _ _).

- : join-preserves-clsmap-cxt-objset CBS1 CBS2 U CBS
    <- set`size-total Z
    <- join-preserves-clsmap-cxt-objset/L _ Z CBS1 CBS2 U CBS.

%worlds (gtermvar) (join-preserves-clsmap-cxt-objset _ _ _ _).
%total {} (join-preserves-clsmap-cxt-objset _ _ _ _).


%theorem clsmap-cxt-objset-implies-domain-leq
  : forall* {CM} {B} {S} {BS}
    forall {CM-B-S: clsmap-cxt-objset CM B S}
    {B-DM: cxt`domain B BS}
    exists {S<=BS: set`leq S BS}
    true.

- : clsmap-cxt-objset-implies-domain-leq clsmap-cxt-objset/0 _ set`leq/0.

- : clsmap-cxt-objset-implies-domain-leq
    (clsmap-cxt-objset/U CM-B-S' L _ F U) B-DM S<=BS
    <- clsmap-cxt-objset-implies-domain-leq CM-B-S' B-DM S'<=BS
    <- cxt`domain-preserves-lookup L B-DM (N<-BS:set`member BS N)
    <- set`add-total (BS+N=BS':set`add BS N BS')
    <- set`add-member-has-no-effect N<-BS BS+N=BS' BS=BS'
    <- set`add-implies-leq U S'<=S
    <- set`add-preserves-leq* S'<=BS U BS+N=BS' S<=BS'
    <- set`eq-symmetric BS=BS' BS'=BS
    <- set`leq-respects-eq S<=BS' set`eq/ BS'=BS S<=BS.

%worlds (gtermvar) (clsmap-cxt-objset-implies-domain-leq _ _ _).
%total (A) (clsmap-cxt-objset-implies-domain-leq A _ _).


%theorem clsmap-cxt-objset-cxt-fresh-implies-not-member
  : forall* {CM} {B} {U} {N}
    forall {CM-B-OS: clsmap-cxt-objset CM B U}
    {N!<B: cxt`fresh B N}
    exists {N!<U: set`not-member U N}
    true.

%theorem clsmap-cxt-objset-cxt-fresh-implies-not-member/L
  : forall* {CM} {B} {U} {N} {P}
    forall {CM-B-OS: clsmap-cxt-objset CM B U}
    {N!<B: cxt`fresh B N}
    {MB?: set`member? U N P}
    exists {N!<U: set`not-member U N}
    true.

- : clsmap-cxt-objset-cxt-fresh-implies-not-member/L CM-B-U N!<B
    (set`member?/in N<-U) N!<U
    <- set`member-implies-not-member-add N<-U _ N!<U' U'+N=U
    <- clsmap-cxt-objset/U-inversion CM-B-U N!<U' U'+N=U
      CM-B-U' _ _ _ BL _ CML
    <- cxt`fresh-lookup-not-equal N!<B BL NE
    <- nat`ne-anti-reflexive NE V
    <- set`false-implies-not-member V N!<U.

- : clsmap-cxt-objset-cxt-fresh-implies-not-member/L CM-B-U N!<B
    (set`member?/out N!<U) N!<U.

- : clsmap-cxt-objset-cxt-fresh-implies-not-member CM-B-U N!<B N!<U
    <- set`member?-total MB?
    <- clsmap-cxt-objset-cxt-fresh-implies-not-member/L CM-B-U N!<B MB? N!<U.

%worlds (gtermvar) (clsmap-cxt-objset-cxt-fresh-implies-not-member/L _ _ _ _).
%total { } (clsmap-cxt-objset-cxt-fresh-implies-not-member/L _ _ _ _).

%worlds (gtermvar) (clsmap-cxt-objset-cxt-fresh-implies-not-member _ _ _).
%total { } (clsmap-cxt-objset-cxt-fresh-implies-not-member _ _ _).


%%% ============================================================
%%% Theorems about clsmap-cxt-capset
%%% ============================================================

%theorem false-implies-clsmap-cxt-capset
  : forall* {CM} {B} {S} forall {F:void} exists {CBS: clsmap-cxt-capset CM B S}
    true.

%worlds (gtermvar) (false-implies-clsmap-cxt-capset _ _).
%total { } (false-implies-clsmap-cxt-capset _ _).


%theorem clsmap-cxt-capset-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {S1} {S2}
    forall {CM1-B1-S1: clsmap-cxt-capset CM1 B1 S1}
    {EQ: clsmap`eq CM1 CM2} {EQ: cxt`eq B1 B2} {EQ: set`eq S1 S2}
    exists {CM2-B2-S2: clsmap-cxt-capset CM2 B2 S2}
    true.

- : clsmap-cxt-capset-respects-eq A clsmap`eq/ cxt`eq/ set`eq/ A.

%worlds (gtermvar) (clsmap-cxt-capset-respects-eq _ _ _ _ _).
%total {} (clsmap-cxt-capset-respects-eq _ _ _ _ _).


%%% For let x = E in F, we need to find associated targets for E
%%% (bindings, capabilities) and replace them with the new variable x

%theorem cxt-fresh-update-preserves-clsmap-cxt-capset
  : forall* {CM} {B} {BP} {N} {CI} {M}
    forall {CM-M: clsmap-cxt-capset CM B M}
    {BF: cxt`fresh B N}
    {BU: cxt`update B N CI BP}
    exists {CM-M: clsmap-cxt-capset CM BP M}
    true.

- : cxt-fresh-update-preserves-clsmap-cxt-capset clsmap-cxt-capset/0 _ _ clsmap-cxt-capset/0.

- : cxt-fresh-update-preserves-clsmap-cxt-capset
    (clsmap-cxt-capset/U (CM-B-M':clsmap-cxt-capset CM B M')
      (N0+F=>K:pair2nat (pair/ N0 F) (s K)) BL NS CML FML K!<M' M'+K=M)
    (N!<B:cxt`fresh B N) (B+N+CI=BP:cxt`update B N _ BP)
    (clsmap-cxt-capset/U CM-BP-M' N0+F=>K BPL NS CML FML K!<M' M'+K=M)
    <- cxt-fresh-update-preserves-clsmap-cxt-capset CM-B-M' N!<B B+N+CI=BP CM-BP-M'
    <- cxt`fresh-update-preserves-lookup BL N!<B B+N+CI=BP BPL.

- : cxt-fresh-update-preserves-clsmap-cxt-capset
    (clsmap-cxt-capset/z (CM-B-M':clsmap-cxt-capset CM B M') K!<M' M'+K=M)
    (N!<B:cxt`fresh B N) (B+N+CI=BP:cxt`update B N _ BP)
    (clsmap-cxt-capset/z CM-BP-M' K!<M' M'+K=M)
    <- cxt-fresh-update-preserves-clsmap-cxt-capset CM-B-M' N!<B B+N+CI=BP CM-BP-M'.

%worlds (gtermvar) (cxt-fresh-update-preserves-clsmap-cxt-capset _ _ _ _).
%total (CM-M) (cxt-fresh-update-preserves-clsmap-cxt-capset CM-M _ _ _).


%theorem clsmap-cxt-capset/z-inversion
  : forall* {CM} {B} {S} {S'}
    forall {CM-B-S: clsmap-cxt-capset CM B S}
    {NM: set`not-member S' shared}
    {AD: set`add S' shared S}
    exists {CM-B-S': clsmap-cxt-capset CM B S'}
    true.

- : clsmap-cxt-capset/z-inversion
    (clsmap-cxt-capset/U CM-B-S N2P BL NS CML FML F1 U1) F U
    (clsmap-cxt-capset/U CM-B-S2 N2P BL NS CML FML F3 U3)
    <- nat`succ-implies-gt-zero _ GT
    <- set`add-commutes-converse U U1 (nat`ne/< GT) M U3 U2
    <- set`add-preserves-not-member-converse F U3 F2
    <- set`add-preserves-not-member-converse F1 U2 F3
    <- clsmap-cxt-capset/z-inversion CM-B-S F2 U2 CM-B-S2.

- : clsmap-cxt-capset/z-inversion
    (clsmap-cxt-capset/z CM-B-S F1 U1) F U CM-B-S'
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- clsmap-cxt-capset-respects-eq CM-B-S clsmap`eq/ cxt`eq/ S1=S CM-B-S'.

%worlds (gtermvar) (clsmap-cxt-capset/z-inversion _ _ _ _).
%total (A) (clsmap-cxt-capset/z-inversion A _ _ _).


%%% here K has to be a positive number, since nat`z is taken by shared.

%theorem clsmap-cxt-capset/U-inversion
  : forall* {CM} {B} {S} {S'} {K}
    forall {CM-B-S: clsmap-cxt-capset CM B S}
    {NM: set`not-member S' (s K)}
    {AD: set`add S' (s K) S}
    exists {CM-B-S': clsmap-cxt-capset CM B S'}
    {N} {F} {N+F=>K: nat2pair (s K) (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {NS: not-shared A}
    {FM} {CML: clsmap`lookup CM C FM}
    {T} {FML: fldmap`lookup FM F T}
    true.

- : clsmap-cxt-capset/U-inversion
    (clsmap-cxt-capset/z CM-B-S F1 U1) F U
    (clsmap-cxt-capset/z CM-B-S2 F3 U3) _ _ N2P2 _ _ _ _ BL2 NS2 _ CML2 _ FML2
    <- nat`succ-implies-gt-zero _ GT
    <- set`add-commutes-converse U U1 (nat`ne/> GT) M U3 U2
    <- set`add-preserves-not-member-converse F U3 F2
    <- set`add-preserves-not-member-converse F1 U2 F3
    <- clsmap-cxt-capset/U-inversion CM-B-S F2 U2 CM-B-S2
      _ _ N2P2 _ _ _ _ BL2 NS2 _ CML2 _ FML2.

%theorem clsmap-cxt-capset/U-inversion/L
  : forall* {CM} {B} {S} {S'} {S1'} {K} {K1} {O1} {NN1}
    {A1} {C1} {FM1} {P} {N1} {F1} {T1}
    forall {CM-B-S: clsmap-cxt-capset CM B S1'}
    {NM1: set`not-member S1' (s K1)}
    {AD1: set`add S1' (s K1) S}
    {K1=>N1+F1: nat2pair (s K1) (pair/ N1 F1)}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {NS1: not-shared A1}
    {CML1: clsmap`lookup CM C1 FM1}
    {FML1: fldmap`lookup FM1 F1 T1}
    {NM: set`not-member S' (s K)}
    {AD: set`add S' (s K) S}
    {EQ?: nat`eq? (s K) (s K1) P}
    exists {CM-B-S': clsmap-cxt-capset CM B S'}
    {N} {F} {K=>N+F: nat2pair (s K) (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {NS: not-shared A}
    {FM} {CML: clsmap`lookup CM C FM}
    {T} {FML: fldmap`lookup FM F T}
    true.

- : clsmap-cxt-capset/U-inversion/L CM-B-S F1 U1 N2P1 BL1 NS1 CML1 FML1 F U
    nat`eq?/yes CM-B-S' _ _ N2P1 _ _ _ _ BL1 NS1 _ CML1 _ FML1
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- clsmap-cxt-capset-respects-eq CM-B-S clsmap`eq/ cxt`eq/ S1=S CM-B-S'.

- : clsmap-cxt-capset/U-inversion/L CM-B-S F1 U1 N2P BL NS CML FML
    F U (nat`eq?/no N<>N1) (clsmap-cxt-capset/U CM-B-S2 N2P BL NS CML FML F3 U3)
    _ _ N2P2 _ _ _ _ BL2 NS2 _ CML2 _ FML2
    <- set`add-commutes-converse U U1 N<>N1 _ U3 U2
    <- set`add-preserves-not-member-converse F U3 F2
    <- set`add-preserves-not-member-converse F1 U2 F3
    <- clsmap-cxt-capset/U-inversion CM-B-S F2 U2 CM-B-S2
      _ _ N2P2 _ _ _ _ BL2 NS2 _ CML2 _ FML2.

- : clsmap-cxt-capset/U-inversion
    (clsmap-cxt-capset/U CM-B-S0 N2P0 BL0 NS0 CML0 FML0 F0 U0) F1 U1
    CM-B-S1 _ _ N2P1 _ _ _ _ BL1 NS1 _ CML1 _ FML1
    <- nat`eq?-total E?
    <- clsmap-cxt-capset/U-inversion/L CM-B-S0 F0 U0 N2P0 BL0 NS0 CML0 FML0
      F1 U1 E? CM-B-S1 _ _ N2P1 _ _ _ _ BL1 NS1 _ CML1 _ FML1.

%worlds (gtermvar) (clsmap-cxt-capset/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-capset/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (clsmap-cxt-capset/U-inversion C0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-capset/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem clsmap-cxt-capset-respects-geq
  : forall* {S} {SP} {CM} {B}
    forall {B-SP: clsmap-cxt-capset CM B SP}
    {S1<=S2: set`leq S SP}
    exists {B-S: clsmap-cxt-capset CM B S}
    true.

- : clsmap-cxt-capset-respects-geq
    clsmap-cxt-capset/0 set`leq/0 clsmap-cxt-capset/0.

%theorem clsmap-cxt-capset-respects-geq/U
  : forall* {CM} {FM} {SS} {SP} {N} {B} {NN} {A} {C} {S} {K} {T} {F} {O}
    forall {P} {IN?: set`member? S (s K) P}
    {NM: set`not-member SS (s K)}
    {UD: set`add SS (s K) SP}
    {NP: nat2pair (s K) (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {NS: not-shared A}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    {B-SS: clsmap-cxt-capset CM B SS}
    {S<=SP: set`leq S SP}
    exists {B-S: clsmap-cxt-capset CM B S}
    true.

%theorem clsmap-cxt-capset-respects-geq/z
  : forall* {S} {SS} {CM} {SP} {B}
    forall {P} {IN?: set`member? S shared P}
    {NM: set`not-member SS shared}
    {UD: set`add SS shared SP}
    {B-SS: clsmap-cxt-capset CM B SS}
    {S<=SP: set`leq S SP}
    exists {B-S: clsmap-cxt-capset CM B S}
    true.

- : clsmap-cxt-capset-respects-geq/z true (set`member?/in N<-S)
    NM UD B-SS S<=SP (clsmap-cxt-capset/z CM-B-ST N!<ST ADD)
    <- set`member-implies-not-member-add N<-S ST N!<ST ADD
    <- set`not-member-add-preserves-leq-converse S<=SP N!<ST ADD NM UD ST<=SS
    <- clsmap-cxt-capset-respects-geq B-SS ST<=SS CM-B-ST.

- : clsmap-cxt-capset-respects-geq/z false (set`member?/out N!<S)
    NM UD B-SS S<=SP B-S
    <- set`not-member-add2-preserves-leq-converse S<=SP N!<S NM UD S<=SS
    <- clsmap-cxt-capset-respects-geq B-SS S<=SS B-S.

- : clsmap-cxt-capset-respects-geq/U true (set`member?/in N<-S)
    NM UD NP BL NS CML FML B-SS S<=SP
    (clsmap-cxt-capset/U CM-B-ST NP BL NS CML FML N!<ST ADD)
    <- set`member-implies-not-member-add N<-S ST N!<ST ADD
    <- set`not-member-add-preserves-leq-converse S<=SP N!<ST ADD NM UD ST<=SS
    <- clsmap-cxt-capset-respects-geq B-SS ST<=SS CM-B-ST.

- : clsmap-cxt-capset-respects-geq/U false (set`member?/out N!<S)
    NM UD BL NS CML DM-FM=FS MPS<=FS B-SS S<=SP B-S
    <- set`not-member-add2-preserves-leq-converse S<=SP N!<S NM UD S<=SS
    <- clsmap-cxt-capset-respects-geq B-SS S<=SS B-S.

- : clsmap-cxt-capset-respects-geq
    (clsmap-cxt-capset/z B-SS NM UD) S<=SP B-S
    <- set`member?-total MB?
    <- clsmap-cxt-capset-respects-geq/z _ MB? NM UD B-SS S<=SP B-S.

- : clsmap-cxt-capset-respects-geq
    (clsmap-cxt-capset/U B-SS NP BL NS CML FML NM UD) S<=SP B-S
    <- set`member?-total MB?
    <- clsmap-cxt-capset-respects-geq/U _ MB? NM UD NP BL NS CML FML B-SS S<=SP B-S.

%worlds (gtermvar) (clsmap-cxt-capset-respects-geq _ _ _)
  (clsmap-cxt-capset-respects-geq/U _ _ _ _ _ _ _ _ _ _ _ _)
  (clsmap-cxt-capset-respects-geq/z _ _ _ _ _ _ _).
%total (L1 L2 L3) (clsmap-cxt-capset-respects-geq L1 _ _)
	(clsmap-cxt-capset-respects-geq/U _ _ _ _ _ _ _ _ _ L2 _ _)
  (clsmap-cxt-capset-respects-geq/z _ _ _ _ L3 _ _).


%theorem join-preserves-clsmap-cxt-capset
  : forall* {CM} {B} {S1} {S2} {S}
    forall {CM-B-S1: clsmap-cxt-capset CM B S1}
    {CM-B-S2: clsmap-cxt-capset CM B S2}
    {J: set`union S1 S2 S}
    exists {CM-B-S: clsmap-cxt-capset CM B S}
    true.

%theorem join-preserves-clsmap-cxt-capset/L
  : forall* {CM} {B} {S1} {S2} {S}
    forall {N} {SZ: set`size S N}
    {CM-B-S1: clsmap-cxt-capset CM B S1}
    {CM-B-S2: clsmap-cxt-capset CM B S2}
    {J: set`union S1 S2 S}
    exists {CM-B-S: clsmap-cxt-capset CM B S}
    true.

%theorem join-preserves-clsmap-cxt-capset/LL
  : forall* {CM} {B} {S1} {S2} {S} {SP} {K} {B1} {B2}
    forall {N} {SZ: set`size S N}
    {CM-B-S1: clsmap-cxt-capset CM B S1}
    {CM-B-S2: clsmap-cxt-capset CM B S2}
    {J: set`union S1 S2 S}
    {F: set`not-member SP K}
    {A: set`add SP K S}
    {D1?: set`member? S1 K B1}
    {D2?: set`member? S2 K B2}
    exists {CM-B-S: clsmap-cxt-capset CM B S}
    true.

- : join-preserves-clsmap-cxt-capset/L
    _ set`size/0 clsmap-cxt-capset/0 CBS set`union/L CBS.

- : join-preserves-clsmap-cxt-capset/L
    _ set`size/0 CBS clsmap-cxt-capset/0 set`union/R CBS.

- : join-preserves-clsmap-cxt-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/in (L1:set`member S1 shared))
    (set`member?/in (L2:set`member S2 shared))
    (clsmap-cxt-capset/z CBSP F U)
    <- set`member-implies-not-member-add L1 S1P F1 U1
    <- set`member-implies-not-member-add L2 S2P F2 U2
    <- set`add-implies-member U (L:set`member S shared)
    <- set`not-member-update-preserves-union-converse* F1 U1 F2 U2 SU F U DJ SUP
    <- clsmap-cxt-capset/z-inversion CBS1 F1 U1 CBS1P
    <- clsmap-cxt-capset/z-inversion CBS2 F2 U2 CBS2P
    <- set`not-member-add-increases-size-converse Z F U ZP
    <- join-preserves-clsmap-cxt-capset/L _ ZP CBS1P CBS2P SUP CBSP.

- : join-preserves-clsmap-cxt-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/in _) (set`member?/out F2)
    (clsmap-cxt-capset/z CBSP F U)
    <- set`add-implies-member U L
    <- set`not-member-union-right-preserves-lookup-converse L F2 SU L1
    <- set`member-implies-not-member-add L1 _ F1 U1
    <- clsmap-cxt-capset/z-inversion CBS1 F1 U1 CBS1P
    <- set`not-member-update-left-preserves-union-converse* F1 U1 F2 SU F U SU1
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capset/L _ Z1 CBS1P CBS2 SU1 CBSP.

- : join-preserves-clsmap-cxt-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/out F1) (set`member?/in _)
    (clsmap-cxt-capset/z CBSP F U)
    <- set`add-implies-member U L
    <- set`not-member-union-left-preserves-lookup-converse F1 L SU L2
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- clsmap-cxt-capset/z-inversion CBS2 F2 U2 CBS2P
    <- set`not-member-update-right-preserves-union-converse* F1 F2 U2 SU F U SU2
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capset/L _ Z1 CBS1 CBS2P SU2 CBSP.

- : join-preserves-clsmap-cxt-capset/LL _ _ _ _ SU _ U
    (set`member?/out F1) (set`member?/out F2) CBS
    <- set`union-preserves-not-member* F1 F2 SU F
    <- set`add-implies-member U L
    <- set`not-member-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-clsmap-cxt-capset V CBS.

- : join-preserves-clsmap-cxt-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/in (L1:set`lookup S1 (s K) _))
    (set`member?/in (L2:set`lookup S2 (s K) _))
    (clsmap-cxt-capset/U CBSP P2N2 BL2 NS2 CML2 FML2 F U)
    <- set`member-implies-not-member-add L1 S1P F1 U1
    <- set`member-implies-not-member-add L2 S2P F2 U2
    <- set`add-implies-member U (L:set`member S (s K))
    <- set`not-member-update-preserves-union-converse* F1 U1 F2 U2 SU F U unit`union/ SUP
    <- clsmap-cxt-capset/U-inversion CBS1 F1 U1
      CBS1P N1 FD1 P2N1 O1 NN1 A1 C1 BL1 NS1 FM1 CML1 T1 FML1
    <- clsmap-cxt-capset/U-inversion CBS2 F2 U2
      CBS2P N2 FD2 P2N2 O2 NN2 A2 C2 BL2 NS2 FM2 CML2 T2 FML2
    <- set`not-member-add-increases-size-converse Z F U ZP
    <- join-preserves-clsmap-cxt-capset/L _ ZP CBS1P CBS2P SUP CBSP.

- : join-preserves-clsmap-cxt-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/in _) (set`member?/out F2)
    (clsmap-cxt-capset/U CBSP P2N1 BL1 NS1 CML1 FML1 F U)
    <- set`add-implies-member U L
    <- set`not-member-union-right-preserves-lookup-converse L F2 SU L1
    <- set`member-implies-not-member-add L1 _ F1 U1
    <- clsmap-cxt-capset/U-inversion
      CBS1 F1 U1 CBS1P _ _ P2N1 _ _ _ _ BL1 NS1 _ CML1 _ FML1
    <- set`not-member-update-left-preserves-union-converse* F1 U1 F2 SU F U SU1
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capset/L _ Z1 CBS1P CBS2 SU1 CBSP.

- : join-preserves-clsmap-cxt-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/out F1) (set`member?/in _)
    (clsmap-cxt-capset/U CBSP P2N2 BL2 NS2 CML2 FML2 F U)
    <- set`add-implies-member U L
    <- set`not-member-union-left-preserves-lookup-converse F1 L SU L2
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- clsmap-cxt-capset/U-inversion
      CBS2 F2 U2 CBS2P _ _ P2N2 _ _ _ _ BL2 NS2 _ CML2 _ FML2
    <- set`not-member-update-right-preserves-union-converse* F1 F2 U2 SU F U SU2
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capset/L _ Z1 CBS1 CBS2P SU2 CBSP.

- : join-preserves-clsmap-cxt-capset/LL _ _ _ _ SU _ U
    (set`member?/out F1) (set`member?/out F2) CBS
    <- set`union-preserves-not-member* F1 F2 SU F
    <- set`add-implies-member U L
    <- set`not-member-member-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-clsmap-cxt-capset V CBS.

- : join-preserves-clsmap-cxt-capset/L (s N) Z CBS1 CBS2 SU CBS
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) _ F U
    <- set`member?-total D1?
    <- set`member?-total D2?
    <- join-preserves-clsmap-cxt-capset/LL (s N) Z CBS1 CBS2 SU F U D1? D2? CBS.

%worlds (gtermvar) (join-preserves-clsmap-cxt-capset/LL _ _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-capset/L _ _ _ _ _ _).
%total (N1 N2) (join-preserves-clsmap-cxt-capset/LL N1 _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-capset/L N2 _ _ _ _ _).

- : join-preserves-clsmap-cxt-capset CBS1 CBS2 U CBS
    <- set`size-total Z
    <- join-preserves-clsmap-cxt-capset/L _ Z CBS1 CBS2 U CBS.

%worlds (gtermvar) (join-preserves-clsmap-cxt-capset _ _ _ _).
%total {} (join-preserves-clsmap-cxt-capset _ _ _ _).


%theorem nat+set2set-implies-clsmap-cxt-capset/L
  : forall* {CM} {B} {FM} {FS} {N} {M} {O} {NN} {A} {C} {FS0}
    forall {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {NS: not-shared A}
    {N+FS=>M: nat+set2set N FS M}
    exists {CM-B-M: clsmap-cxt-capset CM B M}
    true.

- : nat+set2set-implies-clsmap-cxt-capset/L _ _ _ _ _ nat+set2set/0 clsmap-cxt-capset/0.

- : nat+set2set-implies-clsmap-cxt-capset/L (CML:clsmap`lookup CM C FM)
    (FM-DM: fldmap`domain FM FS0) (FS<=FS0: set`leq FS FS0) BL NS
    (nat+set2set/U (N+FSP=QP:nat+set2set N FSP QP)
      (N+F=K:pair2nat (pair/ N F) z) F!<FSP FSP+F=FS (QP+K=Q:set`add QP z Q))
    (clsmap-cxt-capset/z CM-B-QP K!<QP QP+K=Q)
    <- set`add-implies-leq FSP+F=FS FSP<=FS
    <- set`leq-transitive FSP<=FS FS<=FS0 FSP<=FS0
    <- nat+set2set-implies-clsmap-cxt-capset/L CML FM-DM FSP<=FS0 BL NS N+FSP=QP CM-B-QP
    <- nat+set2set-preserves-not-member N+FSP=QP F!<FSP N+F=K K!<QP.

- : nat+set2set-implies-clsmap-cxt-capset/L (CML:clsmap`lookup CM C FM)
    (FM-DM: fldmap`domain FM FS0) (FS<=FS0: set`leq FS FS0) BL NS
    (nat+set2set/U (N+FSP=QP:nat+set2set N FSP QP)
      (N+F=K:pair2nat (pair/ N F) (s K)) F!<FSP FSP+F=FS (QP+K=Q:set`add QP (s K) Q))
    (clsmap-cxt-capset/U CM-B-QP N+F=K BL NS CML FML K!<QP QP+K=Q)
    <- set`add-implies-leq FSP+F=FS FSP<=FS
    <- set`leq-transitive FSP<=FS FS<=FS0 FSP<=FS0
    <- nat+set2set-implies-clsmap-cxt-capset/L CML FM-DM FSP<=FS0 BL NS N+FSP=QP CM-B-QP
    <- set`add-implies-member FSP+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
    <- fldmap`domain-preserves-lookup-converse F<-FS0 FM-DM _ FML
    <- nat+set2set-preserves-not-member N+FSP=QP F!<FSP N+F=K K!<QP.

%worlds (gtermvar) (nat+set2set-implies-clsmap-cxt-capset/L _ _ _ _ _ _ _).
%total (A) (nat+set2set-implies-clsmap-cxt-capset/L _ _ _ _ _ A _).


%theorem nat+set2set-implies-clsmap-cxt-capset
  : forall* {CM} {B} {FM} {FS} {N} {M} {O} {NN} {A} {C}
    forall {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {NS: not-shared A}
    {N+FS=>M: nat+set2set N FS M}
    exists {CM-B-M: clsmap-cxt-capset CM B M}
    true.

- : nat+set2set-implies-clsmap-cxt-capset CML DM BL NS N+FS=M CM-B-M
    <- set`leq-reflexive _ LE
    <- nat+set2set-implies-clsmap-cxt-capset/L CML DM LE BL NS N+FS=M CM-B-M.

%worlds (gtermvar) (nat+set2set-implies-clsmap-cxt-capset _ _ _ _ _ _).
%total { } (nat+set2set-implies-clsmap-cxt-capset _ _ _ _ _ _).



%%% ============================================================
%%% Theorems about clsmap-cxt-unique-objset
%%% ============================================================

%theorem cxt-unique-objset-respects-eq
  : forall* {B1} {B2} {S1} {S2} {NN1} {C1} {NN2} {C2}
    forall {B1-S1: cxt-unique-objset B1 NN1 C1 S1}
    {EQ: cxt`eq B1 B2} {EQ: set`eq S1 S2}
    {EQ: nonnull`eq NN1 NN2} {EQ: nat`eq C1 C2}
    exists {B2-S2: cxt-unique-objset B2 NN2 C2 S2}
    true.

- : cxt-unique-objset-respects-eq A cxt`eq/ set`eq/ nonnull`eq/ nat`eq/ A.

%worlds (gtermvar) (cxt-unique-objset-respects-eq _ _ _ _ _ _).
%total { } (cxt-unique-objset-respects-eq _ _ _ _ _ _).


%theorem cxt-unique-objset/U-inversion
  : forall* {B} {S} {S'} {N} {NN} {C}
    forall {B-S: cxt-unique-objset B NN C S}
    {NM: set`not-member S' (s N)}
    {AD: set`add S' (s N) S}
    exists {CM-B-S': cxt-unique-objset B NN C S'}
    {O} {A} {NN'} {BL: cxt`lookup B (s N) (cxt-info/ O (ty/ NN' A C))}
    {UA: not-shared A}
    {NN<=NN': nonnull`leq NN NN'}
    true.

%theorem cxt-unique-objset/U-inversion/L
  : forall* {B} {S} {S'} {S1'} {N} {N1} {P} {O1} {NN1} {C} {NN} {A1}
    forall {B-S: cxt-unique-objset B NN C S1'}
    {NM1: set`not-member S1' (s N1)}
    {AD1: set`add S1' (s N1) S}
    {BL1: cxt`lookup B (s N1) (cxt-info/ O1 (ty/ NN1 A1 C))}
    {UA1: not-shared A1}
    {NN<=NN1: nonnull`leq NN NN1}
    {NM: set`not-member S' (s N)}
    {AD: set`add S' (s N) S}
    {EQ?: nat`eq? (s N) (s N1) P}
    exists {CM-B-S': cxt-unique-objset B NN C S'}
    {O} {A} {NN'} {BL: cxt`lookup B (s N) (cxt-info/ O (ty/ NN' A C))}
    {UA: not-shared A}
    {NN<=NN': nonnull`leq NN NN'}
    true.

- : cxt-unique-objset/U-inversion/L B-S F1 U1 BL1 UA1 LE F U
    nat`eq?/yes B-S' _ _ _ BL1 UA1 LE
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- cxt-unique-objset-respects-eq B-S cxt`eq/ S1=S nonnull`eq/ nat`eq/ B-S'.

- : cxt-unique-objset/U-inversion/L B-S F1 U1
    (BL:cxt`lookup B (s N1) (cxt-info/ O1 (ty/ NN1 A1 C1))) UA1 (LE:nonnull`leq NN NN1)
    F U (nat`eq?/no N<>N1)
    (cxt-unique-objset/U B-S2 BL UA1 LE F3 U3) O A NN' BL2 UA2 LE2
    <- set`add-commutes-converse U U1 N<>N1 _ U3 U2
    <- set`add-preserves-not-member-converse F U3 F2
    <- set`add-preserves-not-member-converse F1 U2 F3
    <- cxt-unique-objset/U-inversion B-S F2 U2 B-S2 _ _ _ BL2 UA2 LE2.

- : cxt-unique-objset/U-inversion
    (cxt-unique-objset/U B-S0 BL0 UA0 LE F0 U0)
    F1 U1 B-S1 _ _ _ BL1 UA1 LE1
    <- nat`eq?-total E?
    <- cxt-unique-objset/U-inversion/L B-S0 F0 U0 BL0 UA0 LE
      F1 U1 E? B-S1 _ _ _ BL1 UA1 LE1.

%worlds (gtermvar) (cxt-unique-objset/U-inversion _ _ _ _ _ _ _ _ _ _)
	(cxt-unique-objset/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (cxt-unique-objset/U-inversion C0 _ _ _ _ _ _ _ _ _)
	(cxt-unique-objset/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem cxt-unique-objset-no-zero
  : forall* {B} {NN} {C} {S}
    forall {B-S: cxt-unique-objset B NN C S}
    {Z<-S: set`member S z}
    exists {V: void}
    true.

- : cxt-unique-objset-no-zero
    (cxt-unique-objset/U B-SP BL UB LE NM AD) ZMB V
    <- nat`succ-implies-gt-zero _ GT
    <- set`add-preserves-member-converse ZMB AD (nat`ne/< GT) ZMBP
    <- cxt-unique-objset-no-zero B-SP ZMBP V.

%worlds (gtermvar) (cxt-unique-objset-no-zero _ _ _).
%total (B) (cxt-unique-objset-no-zero B _ _).


%theorem cxt-fresh-update-preserves-cxt-unique-objset
  : forall* {B0} {B1} {S} {NN} {C} {CI} {N}
    forall {B0-S: cxt-unique-objset B0 NN C S}
    {F: cxt`fresh B0 N}
    {U: cxt`update B0 N CI B1}
    exists {B1-S: cxt-unique-objset B1 NN C S}
    true.

%theorem cxt-fresh-update-preserves-cxt-unique-objset/F
  : forall* {B1} {S} {NN} {C}
    forall {F: void}
    exists {B1-S: cxt-unique-objset B1 NN C S}
    true.


%theorem cxt-fresh-update-preserves-cxt-unique-objset/L
  : forall* {B0} {B1} {S} {NN} {C} {CI} {N} {S'} {O} {NN'} {A} {N0} {K}
    forall {B0-S: cxt-unique-objset B0 NN C S'}
    {B0-L: cxt`lookup B0 (s N) (cxt-info/ O (ty/ NN' A C))}
    {UA: not-shared A}
    {NN-LEQ: nonnull`leq NN NN'}
    {FS: set`not-member S' (s N)}
    {UD: set`add S' (s N) S}
    {F: cxt`fresh B0 N0}
    {U: cxt`update B0 N0 CI B1}
    {EQ?: nat`eq? (s N) N0 K}
    exists {B1-S: cxt-unique-objset B1 NN C S}
    true.

- : cxt-fresh-update-preserves-cxt-unique-objset/L B0-S' B0-L
    UA NN<=NN' N!<S' (S'+N=S:set`add S' (s N) S) N0!<B0 B0+N=B1 nat`eq?/yes B1-S
    <- cxt`fresh-lookup-not-equal N0!<B0 B0-L NE
    <- nat`ne-anti-reflexive NE V
    <- cxt-fresh-update-preserves-cxt-unique-objset/F V B1-S.

- : cxt-fresh-update-preserves-cxt-unique-objset/L B0-S' B0-L
    UA NN<=NN' N!<S' (S'+N=S:set`add S' (s N) S) N0!<B0 B0+N=B1
    (nat`eq?/no (NE: nat`ne (s N) N0))
    (cxt-unique-objset/U B1-S' B1-L UA NN<=NN' N!<S' S'+N=S)
    <- cxt`update-preserves-lookup B0-L B0+N=B1 NE B1-L
    <- cxt-fresh-update-preserves-cxt-unique-objset B0-S' N0!<B0 B0+N=B1 B1-S'.


- : cxt-fresh-update-preserves-cxt-unique-objset
    cxt-unique-objset/0 _ _ cxt-unique-objset/0.

- : cxt-fresh-update-preserves-cxt-unique-objset
    (cxt-unique-objset/U B0-S' B0-L UA NN-LEQ FS UD) FS1 UD1 B1-S
    <- nat`eq?-total EQ?
    <- cxt-fresh-update-preserves-cxt-unique-objset/L B0-S' B0-L UA NN-LEQ FS UD FS1 UD1
      EQ? B1-S.

%worlds (gtermvar) (cxt-fresh-update-preserves-cxt-unique-objset/F _ _).
%total { } (cxt-fresh-update-preserves-cxt-unique-objset/F _ _).

%worlds (gtermvar) (cxt-fresh-update-preserves-cxt-unique-objset _ _ _ _)
   (cxt-fresh-update-preserves-cxt-unique-objset/L _ _ _ _ _ _ _ _ _ _).
%total (A B) (cxt-fresh-update-preserves-cxt-unique-objset A _ _ _)
   (cxt-fresh-update-preserves-cxt-unique-objset/L B _ _ _ _ _ _ _ _ _).


%theorem set+nat2set-implies-clsmap-cxt-capset
  : forall* {CM} {B} {S} {F} {M} {NN} {C} {FM} {T}
    forall {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    {B-S: cxt-unique-objset B NN C S}
    {S+F+X=>M: set+nat2set S F M}
    exists {CM-B-M: clsmap-cxt-capset CM B M}
    true.

- : set+nat2set-implies-clsmap-cxt-capset _ _ _ set+nat2set/0 clsmap-cxt-capset/0.

- : set+nat2set-implies-clsmap-cxt-capset CML FML B-S
    (set+nat2set/U S'=>M' (K=>N+F:pair2nat _ z) N!<S' S'+N=S M'+K=M)
    (clsmap-cxt-capset/z CM-B-M' K!<M' M'+K=M)
    <- set+nat2set-preserves-not-member S'=>M' N!<S' K=>N+F K!<M'
    <- cxt-unique-objset/U-inversion B-S N!<S' S'+N=S B-S' _ _ _ BL UA NN-LEQ
    <- set+nat2set-implies-clsmap-cxt-capset CML FML B-S' S'=>M' CM-B-M'.

- : set+nat2set-implies-clsmap-cxt-capset CML FML B-S
    (set+nat2set/U S'=>M' K=>N+F (N!<S':set`not-member _ z) S'+N=S M'+K=M) CM-B-M
    <- set`add-implies-member S'+N=S N<-S
    <- cxt-unique-objset-no-zero B-S N<-S V
    <- false-implies-clsmap-cxt-capset V CM-B-M.

- : set+nat2set-implies-clsmap-cxt-capset CML FML B-S
    (set+nat2set/U S'=>M' (K=>N+F:pair2nat _ (s _)) N!<S' S'+N=S M'+K=M)
    (clsmap-cxt-capset/U CM-B-M' K=>N+F BL NS CML FML K!<M' M'+K=M)
    <- set+nat2set-preserves-not-member S'=>M' N!<S' K=>N+F K!<M'
    <- cxt-unique-objset/U-inversion B-S N!<S' S'+N=S B-S' _ _ _ BL NS NN-LEQ
    <- set+nat2set-implies-clsmap-cxt-capset CML FML B-S' S'=>M' CM-B-M'.

%worlds (gtermvar) (set+nat2set-implies-clsmap-cxt-capset _ _ _ _ _).
%total (B) (set+nat2set-implies-clsmap-cxt-capset _ _ _ B _).


%theorem set+set2set-implies-clsmap-cxt-capset
  : forall* {CM} {B} {S} {M} {FM} {FS} {NN} {C}
    forall {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS}
    {B-S: cxt-unique-objset B NN C S}
    {S+FS=>M: set+set2set S FS M}
    exists {CM-B-M: clsmap-cxt-capset CM B M}
    true.

- : set+set2set-implies-clsmap-cxt-capset _ _ _ set+set2set/0 clsmap-cxt-capset/0.

- : set+set2set-implies-clsmap-cxt-capset CML (FM-DM:fldmap`domain FM FS)
    (cxt-unique-objset/U
      (B-NN-C-SP:cxt-unique-objset B NN C SP)
      (BL: cxt`lookup B (s N) (cxt-info/ O (ty/ NNP A C)))
      (NS: not-shared A)
      (NN<=NNP: nonnull`leq NN NNP)
      (N!<SP: set`not-member SP (s N))
      (SP+N=S: set`add SP (s N) S))
    S+FS=Q2
    CM-B-Q2
    <- set+set2set/U-inversion S+FS=Q2 N!<SP SP+N=S Q0 Q1 SP+FS=Q0 N+FS=Q1 Q0+Q1=Q2
    <- set+set2set-implies-clsmap-cxt-capset CML FM-DM B-NN-C-SP SP+FS=Q0 CM-B-Q0
    <- nat+set2set-implies-clsmap-cxt-capset CML FM-DM BL NS N+FS=Q1 CM-B-Q1
    <- join-preserves-clsmap-cxt-capset CM-B-Q0 CM-B-Q1 Q0+Q1=Q2 CM-B-Q2.

%worlds (gtermvar) (set+set2set-implies-clsmap-cxt-capset _ _ _ _ _).
%total (A) (set+set2set-implies-clsmap-cxt-capset _ _ A _ _).


%%% ============================================================
%%% Theorems about clsmap-cxt-unique-capset
%%% ============================================================

%theorem cxt-fresh-update-preserves-clsmap-cxt-unique-cap
  : forall* {CM} {B0} {NN} {C} {K} {B1} {N} {CI}
    forall {CM-B0-FG: clsmap-cxt-unique-cap CM B0 NN C K}
    {F: cxt`fresh B0 N}
    {U: cxt`update B0 N CI B1}
    exists {CM-B1-FG: clsmap-cxt-unique-cap CM B1 NN C K}
    true.

- : cxt-fresh-update-preserves-clsmap-cxt-unique-cap
    (clsmap-cxt-unique-cap/base P2N B0-L NS CML FML NN-LEQ) F U
    (clsmap-cxt-unique-cap/base P2N B1-L NS CML FML NN-LEQ)
    <- cxt`fresh-update-preserves-lookup B0-L F U B1-L.

- : cxt-fresh-update-preserves-clsmap-cxt-unique-cap
    (clsmap-cxt-unique-cap/nest CML FML CM-B0-FG) F U
    (clsmap-cxt-unique-cap/nest CML FML CM-B1-FG)
    <- cxt-fresh-update-preserves-clsmap-cxt-unique-cap CM-B0-FG F U CM-B1-FG.

%worlds (gtermvar) (cxt-fresh-update-preserves-clsmap-cxt-unique-cap _ _ _ _).
%total (A) (cxt-fresh-update-preserves-clsmap-cxt-unique-cap A _ _ _).


%theorem cxt-fresh-update-preserves-clsmap-cxt-unique-capset
  : forall* {CM} {B} {BP} {N} {CI} {M} {NN} {C}
    forall {CM-M: clsmap-cxt-unique-capset CM B NN C M}
    {BF: cxt`fresh B N}
    {BU: cxt`update B N CI BP}
    exists {CM-M: clsmap-cxt-unique-capset CM BP NN C M}
    true.

- : cxt-fresh-update-preserves-clsmap-cxt-unique-capset
    clsmap-cxt-unique-capset/0 _ _ clsmap-cxt-unique-capset/0.

- : cxt-fresh-update-preserves-clsmap-cxt-unique-capset
    (clsmap-cxt-unique-capset/U CM-B-M' CM-B-UC K!<M' M'+K=M)
    (N!<B:cxt`fresh B N) (B+N+CI=BP:cxt`update B N _ BP)
    (clsmap-cxt-unique-capset/U CM-BP-M' CM-B-UCP K!<M' M'+K=M)
    <- cxt-fresh-update-preserves-clsmap-cxt-unique-cap CM-B-UC N!<B B+N+CI=BP CM-B-UCP
    <- cxt-fresh-update-preserves-clsmap-cxt-unique-capset CM-B-M' N!<B B+N+CI=BP CM-BP-M'.

- : cxt-fresh-update-preserves-clsmap-cxt-unique-capset
    (clsmap-cxt-unique-capset/z CM-B-M' K!<M' M'+K=M)
    (N!<B:cxt`fresh B N) (B+N+CI=BP:cxt`update B N _ BP)
    (clsmap-cxt-unique-capset/z CM-BP-M' K!<M' M'+K=M)
    <- cxt-fresh-update-preserves-clsmap-cxt-unique-capset CM-B-M' N!<B B+N+CI=BP CM-BP-M'.

%worlds (gtermvar) (cxt-fresh-update-preserves-clsmap-cxt-unique-capset _ _ _ _).
%total (CM-M) (cxt-fresh-update-preserves-clsmap-cxt-unique-capset CM-M _ _ _).


%%% Theorems about clsmap-cxt-unique-objset

%theorem clsmap-cxt-unique-capset-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {S1} {S2} {NN1} {C1} {NN2} {C2}
    forall {CM1-B1-S1: clsmap-cxt-unique-capset CM1 B1 NN1 C1 S1}
    {EQ: clsmap`eq CM1 CM2} {EQ: cxt`eq B1 B2}
    {EQ: nonnull`eq NN1 NN2} {EQ: nat`eq C1 C2}
    {EQ: set`eq S1 S2}
    exists {CM2-B2-S2: clsmap-cxt-unique-capset CM2 B2 NN2 C2 S2}
    true.

- : clsmap-cxt-unique-capset-respects-eq A clsmap`eq/ cxt`eq/ nonnull`eq/ nat`eq/ set`eq/ A.

%worlds (gtermvar) (clsmap-cxt-unique-capset-respects-eq _ _ _ _ _ _ _).
%total {} (clsmap-cxt-unique-capset-respects-eq _ _ _ _ _ _ _).


%theorem false-implies-clsmap-cxt-unique-capset
  : forall* {CM} {B} {S} {NN} {C}
    forall {F:void}
    exists {CBS: clsmap-cxt-unique-capset CM B NN C S}
    true.

%worlds (gtermvar) (false-implies-clsmap-cxt-unique-capset _ _).
%total { } (false-implies-clsmap-cxt-unique-capset _ _).


%theorem clsmap-cxt-unique-capset/z-inversion
  : forall* {CM} {B} {S} {S'} {NN} {C}
    forall {CM-B-S: clsmap-cxt-unique-capset CM B NN C S}
    {NM: set`not-member S' shared}
    {AD: set`add S' shared S}
    exists {CM-B-S': clsmap-cxt-unique-capset CM B NN C S'}
    true.

- : clsmap-cxt-unique-capset/z-inversion
    (clsmap-cxt-unique-capset/U CM-B-S CM-B-CP F1 U1) F U
    (clsmap-cxt-unique-capset/U CM-B-S2 CM-B-CP F3 U3)
    <- nat`succ-implies-gt-zero _ GT
    <- set`add-commutes-converse U U1 (nat`ne/< GT) M U3 U2
    <- set`add-preserves-not-member-converse F U3 F2
    <- set`add-preserves-not-member-converse F1 U2 F3
    <- clsmap-cxt-unique-capset/z-inversion CM-B-S F2 U2 CM-B-S2.

- : clsmap-cxt-unique-capset/z-inversion
    (clsmap-cxt-unique-capset/z CM-B-S F1 U1) F U CM-B-S'
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- clsmap-cxt-unique-capset-respects-eq CM-B-S clsmap`eq/ cxt`eq/ nonnull`eq/ nat`eq/
      S1=S CM-B-S'.

%worlds (gtermvar) (clsmap-cxt-unique-capset/z-inversion _ _ _ _).
%total (A) (clsmap-cxt-unique-capset/z-inversion A _ _ _).


%theorem set+nat2set-implies-clsmap-cxt-unique-capset
  : forall* {CM} {B} {S} {F} {M} {C} {FM} {FNN} {FC}
    forall {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ FNN annot/unique FC)}
    {B-S: cxt-unique-objset B nn/yes C S}
    {S+F+X=>M: set+nat2set S F M}
    exists {CM-B-M: clsmap-cxt-unique-capset CM B FNN FC M}
    true.

- : set+nat2set-implies-clsmap-cxt-unique-capset _ _ _ set+nat2set/0 clsmap-cxt-unique-capset/0.

- : set+nat2set-implies-clsmap-cxt-unique-capset CML FML B-S
    (set+nat2set/U S'=>M' (K=>N+F:pair2nat _ z) N!<S' S'+N=S M'+K=M)
    (clsmap-cxt-unique-capset/z CM-B-M' K!<M' M'+K=M)
    <- set+nat2set-preserves-not-member S'=>M' N!<S' K=>N+F K!<M'
    <- cxt-unique-objset/U-inversion B-S N!<S' S'+N=S B-S' _ _ _ BL UA NN-LEQ
    <- set+nat2set-implies-clsmap-cxt-unique-capset CML FML B-S' S'=>M' CM-B-M'.

- : set+nat2set-implies-clsmap-cxt-unique-capset CML FML B-S
    (set+nat2set/U S'=>M' K=>N+F (N!<S':set`not-member _ z) S'+N=S M'+K=M) CM-B-M
    <- set`add-implies-member S'+N=S N<-S
    <- cxt-unique-objset-no-zero B-S N<-S V
    <- false-implies-clsmap-cxt-unique-capset V CM-B-M.

- : set+nat2set-implies-clsmap-cxt-unique-capset
    (CML:clsmap`lookup CM C FM) (FML:fldmap`lookup FM F (ty/ FNN annot/unique FC))
    (B-S:cxt-unique-objset B nn/yes C S)
    (set+nat2set/U S'=>M' (K=>N+F:pair2nat _ (s _)) N!<S' S'+N=S M'+K=M)
    (clsmap-cxt-unique-capset/U CM-B-M'
      (clsmap-cxt-unique-cap/base K=>N+F BL NS CML FML (nonnull`leq/= nonnull`eq/)) K!<M' M'+K=M)
    <- set+nat2set-preserves-not-member S'=>M' N!<S' K=>N+F K!<M'
    <- cxt-unique-objset/U-inversion B-S N!<S' S'+N=S B-S' _ _ _ BL NS _
    <- set+nat2set-implies-clsmap-cxt-unique-capset CML FML B-S' S'=>M' CM-B-M'.

%worlds (gtermvar) (set+nat2set-implies-clsmap-cxt-unique-capset _ _ _ _ _).
%total (B) (set+nat2set-implies-clsmap-cxt-unique-capset _ _ _ B _).


%theorem clsmap-cxt-unique-capset/U-inversion
  : forall* {CM} {B} {S} {S'} {K} {NN} {C}
    forall {CM-B-S: clsmap-cxt-unique-capset CM B NN C S}
    {NM: set`not-member S' (s K)}
    {AD: set`add S' (s K) S}
    exists {CM-B-S': clsmap-cxt-unique-capset CM B NN C S'}
    {CM-B-CP: clsmap-cxt-unique-cap CM B (s K) NN C}
    true.

- : clsmap-cxt-unique-capset/U-inversion
    (clsmap-cxt-unique-capset/z CM-B-S F1 U1) F U
    (clsmap-cxt-unique-capset/z CM-B-S2 F3 U3) CM-B-CP
    <- nat`succ-implies-gt-zero _ GT
    <- set`add-commutes-converse U U1 (nat`ne/> GT) M U3 U2
    <- set`add-preserves-not-member-converse F U3 F2
    <- set`add-preserves-not-member-converse F1 U2 F3
    <- clsmap-cxt-unique-capset/U-inversion CM-B-S F2 U2 CM-B-S2 CM-B-CP.

%theorem clsmap-cxt-unique-capset/U-inversion/L
  : forall* {CM} {B} {S} {S'} {S1'} {K} {K1} {P} {NN} {C}
    forall {CM-B-S: clsmap-cxt-unique-capset CM B NN C S1'}
    {NM1: set`not-member S1' (s K1)}
    {AD1: set`add S1' (s K1) S}
    {CM-B-CP1: clsmap-cxt-unique-cap CM B (s K1) NN C}
    {NM: set`not-member S' (s K)}
    {AD: set`add S' (s K) S}
    {EQ?: nat`eq? (s K) (s K1) P}
    exists {CM-B-S': clsmap-cxt-unique-capset CM B NN C S'}
    {CM-B-CP: clsmap-cxt-unique-cap CM B (s K) NN C}
    true.

- : clsmap-cxt-unique-capset/U-inversion/L CM-B-S F1 U1 CM-B-CP1 F U
    nat`eq?/yes CM-B-S' CM-B-CP1
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- clsmap-cxt-unique-capset-respects-eq CM-B-S clsmap`eq/ cxt`eq/
      nonnull`eq/ nat`eq/ S1=S CM-B-S'.

- : clsmap-cxt-unique-capset/U-inversion/L CM-B-S F1 U1 CM-B-CP
    F U (nat`eq?/no N<>N1) (clsmap-cxt-unique-capset/U CM-B-S2 CM-B-CP F3 U3) CM-B-CP1
    <- set`add-commutes-converse U U1 N<>N1 _ U3 U2
    <- set`add-preserves-not-member-converse F U3 F2
    <- set`add-preserves-not-member-converse F1 U2 F3
    <- clsmap-cxt-unique-capset/U-inversion CM-B-S F2 U2 CM-B-S2 CM-B-CP1.

- : clsmap-cxt-unique-capset/U-inversion
    (clsmap-cxt-unique-capset/U CM-B-S0 CM-B-CP0 F0 U0) F1 U1 CM-B-S1 CM-B-CP1
    <- nat`eq?-total E?
    <- clsmap-cxt-unique-capset/U-inversion/L CM-B-S0 F0 U0 CM-B-CP0
      F1 U1 E? CM-B-S1 CM-B-CP1.

%worlds (gtermvar) (clsmap-cxt-unique-capset/U-inversion _ _ _ _ _)
	(clsmap-cxt-unique-capset/U-inversion/L _ _ _ _ _ _ _ _ _).
%total (C0 C1) (clsmap-cxt-unique-capset/U-inversion C0 _ _ _ _)
	(clsmap-cxt-unique-capset/U-inversion/L C1 _ _ _ _ _ _ _ _).


%theorem join-preserves-clsmap-cxt-unique-capset
  : forall* {CM} {B} {S1} {S2} {S} {NN} {C}
    forall {CM-B-S1: clsmap-cxt-unique-capset CM B NN C S1}
    {CM-B-S2: clsmap-cxt-unique-capset CM B NN C S2}
    {J: set`union S1 S2 S}
    exists {CM-B-S: clsmap-cxt-unique-capset CM B NN C S}
    true.

%theorem join-preserves-clsmap-cxt-unique-capset/L
  : forall* {CM} {B} {S1} {S2} {S} {NN} {C}
    forall {N} {SZ: set`size S N}
    {CM-B-S1: clsmap-cxt-unique-capset CM B NN C S1}
    {CM-B-S2: clsmap-cxt-unique-capset CM B NN C S2}
    {J: set`union S1 S2 S}
    exists {CM-B-S: clsmap-cxt-unique-capset CM B NN C S}
    true.

%theorem join-preserves-clsmap-cxt-unique-capset/LL
  : forall* {CM} {B} {S1} {S2} {S} {SP} {K} {B1} {B2} {NN} {C}
    forall {N} {SZ: set`size S N}
    {CM-B-S1: clsmap-cxt-unique-capset CM B NN C S1}
    {CM-B-S2: clsmap-cxt-unique-capset CM B NN C S2}
    {J: set`union S1 S2 S}
    {F: set`not-member SP K}
    {A: set`add SP K S}
    {D1?: set`member? S1 K B1}
    {D2?: set`member? S2 K B2}
    exists {CM-B-S: clsmap-cxt-unique-capset CM B NN C S}
    true.

- : join-preserves-clsmap-cxt-unique-capset/L
    _ set`size/0 clsmap-cxt-unique-capset/0 CBS set`union/L CBS.

- : join-preserves-clsmap-cxt-unique-capset/L
    _ set`size/0 CBS clsmap-cxt-unique-capset/0 set`union/R CBS.

- : join-preserves-clsmap-cxt-unique-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/in (L1:set`member S1 shared))
    (set`member?/in (L2:set`member S2 shared))
    (clsmap-cxt-unique-capset/z CBSP F U)
    <- set`member-implies-not-member-add L1 S1P F1 U1
    <- set`member-implies-not-member-add L2 S2P F2 U2
    <- set`add-implies-member U (L:set`member S shared)
    <- set`not-member-update-preserves-union-converse* F1 U1 F2 U2 SU F U DJ SUP
    <- clsmap-cxt-unique-capset/z-inversion CBS1 F1 U1 CBS1P
    <- clsmap-cxt-unique-capset/z-inversion CBS2 F2 U2 CBS2P
    <- set`not-member-add-increases-size-converse Z F U ZP
    <- join-preserves-clsmap-cxt-unique-capset/L _ ZP CBS1P CBS2P SUP CBSP.

- : join-preserves-clsmap-cxt-unique-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/in _) (set`member?/out F2)
    (clsmap-cxt-unique-capset/z CBSP F U)
    <- set`add-implies-member U L
    <- set`not-member-union-right-preserves-lookup-converse L F2 SU L1
    <- set`member-implies-not-member-add L1 _ F1 U1
    <- clsmap-cxt-unique-capset/z-inversion CBS1 F1 U1 CBS1P
    <- set`not-member-update-left-preserves-union-converse* F1 U1 F2 SU F U SU1
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-unique-capset/L _ Z1 CBS1P CBS2 SU1 CBSP.

- : join-preserves-clsmap-cxt-unique-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/out F1) (set`member?/in _)
    (clsmap-cxt-unique-capset/z CBSP F U)
    <- set`add-implies-member U L
    <- set`not-member-union-left-preserves-lookup-converse F1 L SU L2
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- clsmap-cxt-unique-capset/z-inversion CBS2 F2 U2 CBS2P
    <- set`not-member-update-right-preserves-union-converse* F1 F2 U2 SU F U SU2
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-unique-capset/L _ Z1 CBS1 CBS2P SU2 CBSP.

- : join-preserves-clsmap-cxt-unique-capset/LL _ _ _ _ SU _ U
    (set`member?/out F1) (set`member?/out F2) %{=>}% CBS
    <- set`union-preserves-not-member* F1 F2 SU F
    <- set`add-implies-member U L
    <- set`not-member-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-clsmap-cxt-unique-capset V CBS.

- : join-preserves-clsmap-cxt-unique-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/in (L1:set`lookup S1 (s K) _))
    (set`member?/in (L2:set`lookup S2 (s K) _))
    (clsmap-cxt-unique-capset/U CBSP CBCP2 F U)
    <- set`member-implies-not-member-add L1 S1P F1 U1
    <- set`member-implies-not-member-add L2 S2P F2 U2
    <- set`add-implies-member U (L:set`member S (s K))
    <- set`not-member-update-preserves-union-converse* F1 U1 F2 U2 SU F U unit`union/ SUP
    <- clsmap-cxt-unique-capset/U-inversion CBS1 F1 U1 CBS1P CBCP1
    <- clsmap-cxt-unique-capset/U-inversion CBS2 F2 U2 CBS2P CBCP2
    <- set`not-member-add-increases-size-converse Z F U ZP
    <- join-preserves-clsmap-cxt-unique-capset/L _ ZP CBS1P CBS2P SUP CBSP.

- : join-preserves-clsmap-cxt-unique-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/in _) (set`member?/out F2)
    (clsmap-cxt-unique-capset/U CBSP CBCP1 F U)
    <- set`add-implies-member U L
    <- set`not-member-union-right-preserves-lookup-converse L F2 SU L1
    <- set`member-implies-not-member-add L1 _ F1 U1
    <- clsmap-cxt-unique-capset/U-inversion CBS1 F1 U1 CBS1P CBCP1
    <- set`not-member-update-left-preserves-union-converse* F1 U1 F2 SU F U SU1
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-unique-capset/L _ Z1 CBS1P CBS2 SU1 CBSP.

- : join-preserves-clsmap-cxt-unique-capset/LL (s N) Z CBS1 CBS2 SU F U
    (set`member?/out F1) (set`member?/in _)
    (clsmap-cxt-unique-capset/U CBSP CBCP2 F U)
    <- set`add-implies-member U L
    <- set`not-member-union-left-preserves-lookup-converse F1 L SU L2
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- clsmap-cxt-unique-capset/U-inversion CBS2 F2 U2 CBS2P CBCP2
    <- set`not-member-update-right-preserves-union-converse* F1 F2 U2 SU F U SU2
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-unique-capset/L _ Z1 CBS1 CBS2P SU2 CBSP.

- : join-preserves-clsmap-cxt-unique-capset/LL _ _ _ _ SU _ U
    (set`member?/out F1) (set`member?/out F2) CBS
    <- set`union-preserves-not-member* F1 F2 SU F
    <- set`add-implies-member U L
    <- set`not-member-member-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-clsmap-cxt-unique-capset V CBS.

- : join-preserves-clsmap-cxt-unique-capset/L (s N) Z CBS1 CBS2 SU CBS
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) _ F U
    <- set`member?-total D1?
    <- set`member?-total D2?
    <- join-preserves-clsmap-cxt-unique-capset/LL (s N) Z CBS1 CBS2 SU F U D1? D2? CBS.

%worlds (gtermvar) (join-preserves-clsmap-cxt-unique-capset/LL _ _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-unique-capset/L _ _ _ _ _ _).
%total (N1 N2) (join-preserves-clsmap-cxt-unique-capset/LL N1 _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-unique-capset/L N2 _ _ _ _ _).

- : join-preserves-clsmap-cxt-unique-capset CBS1 CBS2 U CBS
    <- set`size-total Z
    <- join-preserves-clsmap-cxt-unique-capset/L _ Z CBS1 CBS2 U CBS.

%worlds (gtermvar) (join-preserves-clsmap-cxt-unique-capset _ _ _ _).
%total {} (join-preserves-clsmap-cxt-unique-capset _ _ _ _).


%theorem can-extend-clsmap-cxt-unique-capset
  : forall* {CM} {B} {C} {M0} {FM} {F} {FNN} {FC}
    forall {CM-B-M0: clsmap-cxt-unique-capset CM B nn/yes C M0}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ FNN annot/unique FC)}
    exists {CM-B-M1: clsmap-cxt-unique-capset CM B FNN FC M0}
    true.

- : can-extend-clsmap-cxt-unique-capset
    clsmap-cxt-unique-capset/0 _ _ clsmap-cxt-unique-capset/0.

- : can-extend-clsmap-cxt-unique-capset
    (clsmap-cxt-unique-capset/z CM-B-C-M0 F U) CML FML
    (clsmap-cxt-unique-capset/z CM-B-FC-M0 F U)
    <- can-extend-clsmap-cxt-unique-capset CM-B-C-M0 CML FML CM-B-FC-M0.

- : can-extend-clsmap-cxt-unique-capset
    (clsmap-cxt-unique-capset/U
      (CM-B-C-M0:clsmap-cxt-unique-capset CM B nn/yes C M)
      (CM-B-C:clsmap-cxt-unique-cap CM B (s K) nn/yes C) FS UD)
    (CML:clsmap`lookup CM C FM) (FML:fldmap`lookup FM F (ty/ FNN annot/unique FC))
    (clsmap-cxt-unique-capset/U CM-B-FC-M0
      (clsmap-cxt-unique-cap/nest CML FML CM-B-C) FS UD)
    <- can-extend-clsmap-cxt-unique-capset CM-B-C-M0 CML FML CM-B-FC-M0.

%worlds (gtermvar) (can-extend-clsmap-cxt-unique-capset _ _ _ _).
%total (A) (can-extend-clsmap-cxt-unique-capset A _ _ _).



%theorem cxt-unique-objset-implies-clsmap-cxt-objset
  : forall* {CM} {B} {NN} {C} {S} {FM}
    forall {CML: clsmap`lookup CM C FM}
    {B-NN-C-S: cxt-unique-objset B NN C S}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : cxt-unique-objset-implies-clsmap-cxt-objset _ cxt-unique-objset/0
    clsmap-cxt-objset/0.

- : cxt-unique-objset-implies-clsmap-cxt-objset
    (CML:clsmap`lookup CM C FM)
    (cxt-unique-objset/U B-NN-C-S' BL NS NN-LEQ FS UD)
    (clsmap-cxt-objset/U CM-B-S' BL CML FS UD)
    <- cxt-unique-objset-implies-clsmap-cxt-objset CML B-NN-C-S' CM-B-S'.

%worlds (gtermvar) (cxt-unique-objset-implies-clsmap-cxt-objset _ _ _).
%trustme %total (A) (cxt-unique-objset-implies-clsmap-cxt-objset _ A _).


%theorem clsmap-cxt-unique-capset-implies-clsmap-cxt-capset/L
  : forall* {CM} {B} {K} {FNN} {FC}
    forall {CM-B-C: clsmap-cxt-unique-cap CM B K FNN FC}
    exists {N} {F} {C} {O} {NN} {A} {FM} {T}
    {K2P: nat2pair K (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {NS: not-shared A}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    true.

- : clsmap-cxt-unique-capset-implies-clsmap-cxt-capset/L
    (clsmap-cxt-unique-cap/base K2P BL NS CML FML _) _ _ _ _ _ _ _ _
    K2P BL NS CML FML.

- : clsmap-cxt-unique-capset-implies-clsmap-cxt-capset/L
    (clsmap-cxt-unique-cap/nest _ _ CM-B-C) _ _ _ _ _ _ _ _ K2P BL NS CML FML
    <- clsmap-cxt-unique-capset-implies-clsmap-cxt-capset/L
      CM-B-C _ _ _ _ _ _ _ _ K2P BL NS CML FML.

%worlds (gtermvar)
  (clsmap-cxt-unique-capset-implies-clsmap-cxt-capset/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A)
  (clsmap-cxt-unique-capset-implies-clsmap-cxt-capset/L A _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem clsmap-cxt-unique-capset-implies-clsmap-cxt-capset
  : forall* {CM} {B} {NN} {C} {S}
    forall {CM-B-C-S: clsmap-cxt-unique-capset CM B NN C S}
    exists {CM-B-S: clsmap-cxt-capset CM B S}
    true.

- : clsmap-cxt-unique-capset-implies-clsmap-cxt-capset
    clsmap-cxt-unique-capset/0 clsmap-cxt-capset/0.

- : clsmap-cxt-unique-capset-implies-clsmap-cxt-capset
    (clsmap-cxt-unique-capset/z CM-B-C-S F U)
    (clsmap-cxt-capset/z CM-B-S F U)
    <- clsmap-cxt-unique-capset-implies-clsmap-cxt-capset CM-B-C-S CM-B-S.

- : clsmap-cxt-unique-capset-implies-clsmap-cxt-capset
    (clsmap-cxt-unique-capset/U CM-B-C-S CM-B-C F U)
    (clsmap-cxt-capset/U CM-B-S K2P BL NS CML FML F U)
    <- clsmap-cxt-unique-capset-implies-clsmap-cxt-capset/L
      CM-B-C _ _ _ _ _ _ _ _ K2P BL NS CML FML
    <- clsmap-cxt-unique-capset-implies-clsmap-cxt-capset CM-B-C-S CM-B-S.

%worlds (gtermvar) (clsmap-cxt-unique-capset-implies-clsmap-cxt-capset _ _).
%total (A) (clsmap-cxt-unique-capset-implies-clsmap-cxt-capset A _).


%%% =============================================================
%%% Main theorems about consistency
%%% =============================================================


%theorem combine-preserves-clsmap-cxt-env
  : forall* {CM} {B} {V0} {V1} {V}
    forall {CM-B-V0: clsmap-cxt-env CM B V0}
    {CM-B-V1: clsmap-cxt-env CM B V1}
    {V0+V1=V: env`combine V0 V1 V}
    exists {CM-B-V: clsmap-cxt-env CM B V}
    true.

- : combine-preserves-clsmap-cxt-env
    (clsmap-cxt-env/ CM-B-U0 CM-B-M0)
    (clsmap-cxt-env/ CM-B-U1 CM-B-M1)
    (env`combine/ (set`split/ _ U0+U1=U) (set`split/ _ M0+M1=M))
    (clsmap-cxt-env/ CM-B-U CM-B-M)
    <- join-preserves-clsmap-cxt-objset CM-B-U0 CM-B-U1 U0+U1=U CM-B-U
    <- join-preserves-clsmap-cxt-capset CM-B-M0 CM-B-M1 M0+M1=M CM-B-M.

%worlds (gtermvar) (combine-preserves-clsmap-cxt-env _ _ _ _).
%total { } (combine-preserves-clsmap-cxt-env _ _ _ _).


%theorem cxt-fresh-update-preserves-clsmap-cxt-reftype
  : forall* {CM} {B0} {RT} {B1} {N} {CI}
    forall {CM-B0-RT: clsmap-cxt-reftype CM B0 RT}
    {F: cxt`fresh B0 N}
    {U: cxt`update B0 N CI B1}
    exists {CM-B1-RT: clsmap-cxt-reftype CM B1 RT}
    true.

- : cxt-fresh-update-preserves-clsmap-cxt-reftype
    (clsmap-cxt-reftype/unique CML B0-OS CM-B0-M WF)
    N!<B0 B0+N=B1 (clsmap-cxt-reftype/unique CML B1-OS CM-B1-M WF)
    <- cxt-fresh-update-preserves-cxt-unique-objset B0-OS N!<B0 B0+N=B1 B1-OS
    <- cxt-fresh-update-preserves-clsmap-cxt-unique-capset CM-B0-M N!<B0 B0+N=B1 CM-B1-M.

- : cxt-fresh-update-preserves-clsmap-cxt-reftype
    (clsmap-cxt-reftype/shared CML) _ _ (clsmap-cxt-reftype/shared CML).

- : cxt-fresh-update-preserves-clsmap-cxt-reftype
    (clsmap-cxt-reftype/fresh CML) _ _ (clsmap-cxt-reftype/fresh CML).

%worlds (gtermvar) (cxt-fresh-update-preserves-clsmap-cxt-reftype _ _ _ _).
%total { } (cxt-fresh-update-preserves-clsmap-cxt-reftype _ _ _ _).


%theorem clsmap-result/expr-inversion
  : forall* {CM} {RT} {V} {B}
    forall {CM-R: clsmap-result CM B (result/expr RT V)}
    exists {CM-B-RT: clsmap-cxt-reftype CM B RT}
    {CM-B-V: clsmap-cxt-env CM B V}
    true.

- : clsmap-result/expr-inversion (clsmap-result/expr CM-B-RT CM-B-V)
    CM-B-RT CM-B-V.

%worlds (gtermvar) (clsmap-result/expr-inversion _ _ _).
%total { } (clsmap-result/expr-inversion _ _ _).


%theorem make-tgts-and-caps-implies-empty-objset
  : forall* {G1} {M1} {N} {S} {M} {W} {M2}
    forall {MG: make-tgts-and-caps M1 G1 N (targets/unique S M W) M2}
    exists {S=0: set`eq S set/0}
    true.

- : make-tgts-and-caps-implies-empty-objset
    (make-tgts-and-caps/unique _ _ _) set`eq/.

- : make-tgts-and-caps-implies-empty-objset
    (make-tgts-and-caps/shared _) set`eq/.

- : make-tgts-and-caps-implies-empty-objset
    (make-tgts-and-caps/fresh) set`eq/.

%worlds () (make-tgts-and-caps-implies-empty-objset _ _).
%total { } (make-tgts-and-caps-implies-empty-objset _ _).


%theorem make-tgts-and-caps-consistent/1
  : forall* {CM} {B} {G0} {A} {M0} {M1} {F} {C} {FM} {FC}
    {FNN} {G1} {U0}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ FNN A FC)}
    {CM-B-R: clsmap-result CM B (result/expr (reftype/ nn/yes C G0) (env/ U0 M0))}
    {MG: make-tgts-and-caps M0 G0 F G1 M1}
    exists {CM-B-V: clsmap-cxt-env CM B (env/ U0 M1)}
    true.

- : make-tgts-and-caps-consistent/1 CM-CM CML FML
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique _ B0-S CM-B0-M1' WF)
      (clsmap-cxt-env/
        (CM-B0:clsmap-cxt-objset CM _ U0)
        (CM-B0-M0:clsmap-cxt-capset CM B0 M0)))
    (make-tgts-and-caps/unique (S+F+X=>M2:set+nat2set S F M2)
      (set`split/ M1^M2 (M1+M2=M:set`union M1 M2 M))
      (set`split/ M2^M3 (M2+M3=M0:set`union M2 M3 M0)))
    (clsmap-cxt-env/ CM-B0 CM-B0-M3)
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0)
    <- set`union-implies-leq M2+M3=M0 M2<=M0 M3<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M3<=M0 CM-B0-M3
    <- set+nat2set-implies-clsmap-cxt-unique-capset CML FML B0-S S+F+X=>M2 CM-B0-M2
    <- can-extend-clsmap-cxt-unique-capset CM-B0-M1' CML FML CM-B0-M1
    <- join-preserves-clsmap-cxt-unique-capset CM-B0-M1 CM-B0-M2 M1+M2=M CM-B0-M.

- : make-tgts-and-caps-consistent/1 CM-CM CML FML
    (clsmap-result/expr
      (clsmap-cxt-reftype/shared _)
      (clsmap-cxt-env/ (CM-B0:clsmap-cxt-objset CM _ U0)
        (CM-B0-M0:clsmap-cxt-capset CM B M0)))
    (make-tgts-and-caps/shared (set`split/ X^M1 X+M1=M0))
    (clsmap-cxt-env/ CM-B0 CM-B0-M1)
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0)
    <- set`union-implies-leq X+M1=M0 _ M1<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M1<=M0 CM-B0-M1.

- : make-tgts-and-caps-consistent/1 CM-CM CML FML
    (clsmap-result/expr
      (clsmap-cxt-reftype/fresh _)
      (clsmap-cxt-env/ (CM-B0:clsmap-cxt-objset CM _ U0)
        (CM-B0-M0:clsmap-cxt-capset CM B M0)))
    (make-tgts-and-caps/fresh)
    (clsmap-cxt-env/ CM-B0 CM-B0-M0).

- : make-tgts-and-caps-consistent/1 CM-CM CML FML
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique _ B0-S CM-B0-M1' _)
      (clsmap-cxt-env/
        (CM-B0:clsmap-cxt-objset CM _ U0)
        (CM-B0-M0:clsmap-cxt-capset CM B0 M0)))
    (make-tgts-and-caps/unique (S+F+X=>M2:set+nat2set S F M2)
      (set`split/ M1^M2 (M1+M2=M:set`union M1 M2 M))
      (set`split/ M2^M3 (M2+M3=M0:set`union M2 M3 M0)))
    (clsmap-cxt-env/ CM-B0 CM-B0-M3)
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0)
    <- set`union-implies-leq M2+M3=M0 M2<=M0 M3<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M3<=M0 CM-B0-M3
    <- clsmap-cxt-unique-capset-implies-clsmap-cxt-capset CM-B0-M1' CM-B0-M1
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M2<=M0 CM-B0-M2
    <- join-preserves-clsmap-cxt-capset CM-B0-M1 CM-B0-M2 M1+M2=M CM-B0-M.

- : make-tgts-and-caps-consistent/1 CM-CM CML FML
    (clsmap-result/expr
      (clsmap-cxt-reftype/shared _)
      (clsmap-cxt-env/ (CM-B0:clsmap-cxt-objset CM _ U0)
        (CM-B0-M0:clsmap-cxt-capset CM B M0)))
    (make-tgts-and-caps/shared (set`split/ X^M1 X+M1=M0))
    (clsmap-cxt-env/ CM-B0 CM-B0-M1)
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0)
    <- set`union-implies-leq X+M1=M0 _ M1<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M1<=M0 CM-B0-M1.

%worlds (gtermvar) (make-tgts-and-caps-consistent/1 _ _ _ _ _ _).
%total { } (make-tgts-and-caps-consistent/1 _ _ _ _ _ _).


%theorem make-tgts-and-caps-consistent/2
  : forall* {CM} {B} {G0} {A} {M0} {M1} {F} {C} {FM} {FC}
    {FNN} {G1} {U0} {M3} {G2} {M4} {U2}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ FNN A FC)}
    {CM-B-R: clsmap-result CM B (result/expr (reftype/ nn/yes C G0) (env/ U0 M0))}
    {CM-B-V3: clsmap-cxt-env CM B (env/ U2 M3)}
    {MG: make-tgts-and-caps M0 G0 F G1 M1}
    {CF: consider-ftype G1 M3 A G2 M4}
    exists {CM-B-R: clsmap-result CM B (result/expr (reftype/ FNN FC G2) (env/ U2 M4))}
    true.

%theorem make-tgts-and-caps-consistent/2/L
  : forall* {S} {M1} {M2} {M} {W} {F}
    forall {WF: wf-unique-targets S M1 W}
    {S+F=M2: set+nat2set S F M2}
    {M1+M2=M: set`union M1 M2 M}
    exists {WF: wf-unique-targets set/0 M W}
    true.

- : make-tgts-and-caps-consistent/2/L
    (wf-unique-targets/borrow SZ-S _) S+F=M2 M1+M2=M
    (wf-unique-targets/unique SZ-M')
    <- set+nat2set-preserves-size S+F=M2 SZ-S SZ-M2
    <- set`union-implies-leq M1+M2=M _ M2<=M
    <- set`size-total SZ-M
    <- set`leq-implies-size-le M2<=M SZ-M2 SZ-M GE
    <- ge-succ-implies-succ GE _ EQ
    <- set`size-respects-eq SZ-M set`eq/ EQ SZ-M'.

- : make-tgts-and-caps-consistent/2/L
    (wf-unique-targets/unique SZ-M1) _ M1+M2=M
    (wf-unique-targets/unique SZ-M')
    <- set`union-implies-leq M1+M2=M M1<=M _
    <- set`size-total SZ-M
    <- set`leq-implies-size-le M1<=M SZ-M1 SZ-M GE
    <- ge-succ-implies-succ GE _ EQ
    <- set`size-respects-eq SZ-M set`eq/ EQ SZ-M'.

- : make-tgts-and-caps-consistent/2/L
    (wf-unique-targets/unique+fresh) _ _ (wf-unique-targets/unique+fresh).

%worlds (gtermvar) (make-tgts-and-caps-consistent/2/L _ _ _ _).
%total { } (make-tgts-and-caps-consistent/2/L _ _ _ _).


- : make-tgts-and-caps-consistent/2 CM-CM CML FML
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique _ B0-S CM-B0-M1' WF)
      (clsmap-cxt-env/
        (CM-B0:clsmap-cxt-objset CM _ U0)
        (CM-B0-M0:clsmap-cxt-capset CM B0 M0)))
    (clsmap-cxt-env/ CM-B-U2 CM-B-M3)
    (make-tgts-and-caps/unique (S+F+X=>M2:set+nat2set S F M2)
      (set`split/ M1^M2 (M1+M2=M:set`union M1 M2 M))
      (set`split/ M2^M3 (M2+M3=M0:set`union M2 M3 M0)))
    (consider-ftype/unique)
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique CML0 cxt-unique-objset/0 CM-B0-M WF')
      (clsmap-cxt-env/ CM-B-U2 CM-B-M3))
    <- make-tgts-and-caps-consistent/2/L WF S+F+X=>M2 M1+M2=M WF'
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0)
    <- set`union-implies-leq M2+M3=M0 M2<=M0 M3<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M3<=M0 CM-B0-M3
    <- set+nat2set-implies-clsmap-cxt-unique-capset CML FML B0-S S+F+X=>M2 CM-B0-M2
    <- can-extend-clsmap-cxt-unique-capset CM-B0-M1' CML FML CM-B0-M1
    <- join-preserves-clsmap-cxt-unique-capset CM-B0-M1 CM-B0-M2 M1+M2=M CM-B0-M.

- : make-tgts-and-caps-consistent/2 CM-CM CML FML
    (clsmap-result/expr
      (clsmap-cxt-reftype/shared _)
      (clsmap-cxt-env/ (CM-B0:clsmap-cxt-objset CM _ U0)
        (CM-B0-M0:clsmap-cxt-capset CM B M0)))
    (clsmap-cxt-env/ CM-B-U2 CM-B-M3)
    (make-tgts-and-caps/shared (set`split/ X^M1 X+M1=M0))
    (consider-ftype/shared (set`split/ _ U))
    (clsmap-result/expr
      (clsmap-cxt-reftype/shared CML0)
      (clsmap-cxt-env/ CM-B-U2 CM-B-M4))
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0)
    <- set`union-implies-leq X+M1=M0 _ M1<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M1<=M0 CM-B0-M1
    <- join-preserves-clsmap-cxt-capset
      (clsmap-cxt-capset/z clsmap-cxt-capset/0 set`not-member/0 set`update/0)
      CM-B-M3 U CM-B-M4.

- : make-tgts-and-caps-consistent/2 CM-CM CML FML
    (clsmap-result/expr
      (clsmap-cxt-reftype/fresh _)
      (clsmap-cxt-env/ (CM-B0:clsmap-cxt-objset CM _ U0)
        (CM-B0-M0:clsmap-cxt-capset CM B M0)))
    (clsmap-cxt-env/ CM-B-U2 CM-B-M3)
    (make-tgts-and-caps/fresh)
    (consider-ftype/shared (set`split/ _ U))
    (clsmap-result/expr
      (clsmap-cxt-reftype/shared CML0)
      (clsmap-cxt-env/ CM-B-U2 CM-B-M3))
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0).

- : make-tgts-and-caps-consistent/2 CM-CM CML FML
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique _ B0-S CM-B0-M1' WF)
      (clsmap-cxt-env/
        (CM-B0:clsmap-cxt-objset CM _ U0)
        (CM-B0-M0:clsmap-cxt-capset CM B0 M0)))
    (clsmap-cxt-env/ CM-B-U2 (CM-B0-M5:clsmap-cxt-capset CM B0 M5))
    (make-tgts-and-caps/unique (S+F+X=>M2:set+nat2set S F M2)
      (set`split/ M1^M2 (M1+M2=M:set`union M1 M2 M))
      (set`split/ M2^M3 (M2+M3=M0:set`union M2 M3 M0)))
    (consider-ftype/shared (set`split/ _ M+M5=M6))
    (clsmap-result/expr
      (clsmap-cxt-reftype/shared CML0)
      (clsmap-cxt-env/ CM-B-U2 (CM-B0-M6:clsmap-cxt-capset CM B0 M6)))
    <- make-tgts-and-caps-consistent/2/L WF S+F+X=>M2 M1+M2=M WF'
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0)
    <- set`union-implies-leq M2+M3=M0 M2<=M0 M3<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M3<=M0 CM-B0-M3
    <- clsmap-cxt-unique-capset-implies-clsmap-cxt-capset CM-B0-M1' CM-B0-M1
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M2<=M0 CM-B0-M2
    <- join-preserves-clsmap-cxt-capset CM-B0-M1 CM-B0-M2 M1+M2=M CM-B0-M
    <- join-preserves-clsmap-cxt-capset CM-B0-M CM-B0-M5 M+M5=M6 CM-B0-M6.

- : make-tgts-and-caps-consistent/2 CM-CM CML FML
    (clsmap-result/expr
      (clsmap-cxt-reftype/shared _)
      (clsmap-cxt-env/ (CM-B0:clsmap-cxt-objset CM _ U0)
        (CM-B0-M0:clsmap-cxt-capset CM B M0)))
    (clsmap-cxt-env/ CM-B-U2 (CM-B0-M5:clsmap-cxt-capset CM B M5))
    (make-tgts-and-caps/shared (set`split/ X^M1 X+M1=M0))
    (consider-ftype/unique)
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique CML0 cxt-unique-objset/0
        (clsmap-cxt-unique-capset/z clsmap-cxt-unique-capset/0 set`not-member/0 set`update/0)
        (wf-unique-targets/unique (set`size/+ set`size/0)))
      (clsmap-cxt-env/ CM-B-U2 CM-B0-M5))
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0)
    <- set`union-implies-leq X+M1=M0 _ M1<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M1<=M0 CM-B0-M1.

- : make-tgts-and-caps-consistent/2 CM-CM CML FML
    (clsmap-result/expr
      (clsmap-cxt-reftype/fresh _)
      (clsmap-cxt-env/ (CM-B0:clsmap-cxt-objset CM _ U0)
        (CM-B0-M0:clsmap-cxt-capset CM B M0)))
    (clsmap-cxt-env/ CM-B-U2 (CM-B0-M5:clsmap-cxt-capset CM B M5))
    (make-tgts-and-caps/fresh)
    (consider-ftype/unique)
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique CML0 cxt-unique-objset/0 clsmap-cxt-unique-capset/0
        wf-unique-targets/unique+fresh)
      (clsmap-cxt-env/ CM-B-U2 CM-B0-M5))
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0).

%worlds (gtermvar) (make-tgts-and-caps-consistent/2 _ _ _ _ _ _ _ _).
%total { } (make-tgts-and-caps-consistent/2 _ _ _ _ _ _ _ _).


%theorem subtype-consistent
  : forall* {CM} {FS} {RT} {V0} {T} {V1} {B} {V2}
    forall {CM-B-RT: clsmap-cxt-reftype CM B RT}
    {CM-V0: clsmap-cxt-env CM B V0}
    {SUB: subtype CM FS RT V0 T V2 V1}
    exists {CM-V1: clsmap-cxt-env CM B V1}
    {CM-V2: clsmap-cxt-env CM B V2}
    true.

- : subtype-consistent
    (clsmap-cxt-reftype/unique _ B-NN-C-S _ _)
    (clsmap-cxt-env/ CM-U0 CM-B-M0)
    (subtype/ _ (sub-annot/unique CML FM-DM (S+FS=M2:set+set2set S FS M2)
      (set`split/ M2^M3 (M2+M3=M0:set`union M2 M3 M0))
      (S<=U0:set`leq S U0) (U0-S=U1:set`remove U0 S U1) _))
    (clsmap-cxt-env/ CM-U1 CM-B-M3)
    (clsmap-cxt-env/ CM-S CM-B-M2)
    <- set`remove-implies-leq U0-S=U1 U1<=U0
    <- clsmap-cxt-objset-respects-geq CM-U0 U1<=U0 CM-U1
    <- clsmap-cxt-objset-respects-geq CM-U0 S<=U0 CM-S
    <- set`union-implies-leq M2+M3=M0 M2<=M0 M3<=M0
    <- clsmap-cxt-capset-respects-geq CM-B-M0 M3<=M0 CM-B-M3
    <- set+set2set-implies-clsmap-cxt-capset CML FM-DM B-NN-C-S S+FS=M2 CM-B-M2.

- : subtype-consistent
    (clsmap-cxt-reftype/fresh _)
    (clsmap-cxt-env/ CM-U0 CM-B-M0)
    (subtype/ _ (sub-annot/fresh _))
    (clsmap-cxt-env/ CM-U0 CM-B-M0)
    (clsmap-cxt-env/ clsmap-cxt-objset/0 clsmap-cxt-capset/0).

- : subtype-consistent _
    (clsmap-cxt-env/ (CM-U0:clsmap-cxt-objset CM B U0) CM-B-M0)
    (subtype/ _ (sub-annot/borrow (S+FS=M2:set+set2set S FS M2)
      (set`split/ M2^M3 (M2+M3=M0:union M2 M3 M0))))
    (clsmap-cxt-env/ CM-U0 CM-B-M3)
    (clsmap-cxt-env/ clsmap-cxt-objset/0 CM-B-M2)
    <- set`union-implies-leq M2+M3=M0 M2<=M0 M3<=M0
    <- clsmap-cxt-capset-respects-geq CM-B-M0 M2<=M0 CM-B-M2
    <- clsmap-cxt-capset-respects-geq CM-B-M0 M3<=M0 CM-B-M3.

- : subtype-consistent _ CM-V0 (subtype/ _ sub-annot/shared) CM-V0
    (clsmap-cxt-env/ clsmap-cxt-objset/0 clsmap-cxt-capset/0).

%worlds (gtermvar) (subtype-consistent _ _ _ _ _).
%total { } (subtype-consistent _ _ _ _ _).


%theorem reftyping-implies-clsmap-result
  : forall* {CM} {MM} {K} {E: term K} {R} {B} {V}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM-B: clsmap-cxt CM B}
    {CM-ENV: clsmap-cxt-env CM B V}
    {TYP: reftyping CM MM B V E R}
    exists {CM-R: clsmap-result CM B R}
    true.


%theorem reftyping-implies-clsmap-result/L1
  : forall* {CM} {B0} {N} {B1} {NN} {C} {G} {NNP} {AP} {CP}
    forall {CM-B1-RT: {x} clsmap-cxt-reftype CM (B1 x) (reftype/ NN C G)}
    {NG: not-in-targets (s N) G}
    {FS: cxt`fresh B0 (s N)}
    {UD: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NNP AP CP)) (B1 x)}
    exists {CM-B0-RT: clsmap-cxt-reftype CM B0 (reftype/ NN C G)}
    true.

%worlds (gtermvar) (reftyping-implies-clsmap-result/L1 _ _ _ _ _).
%trustme %total { } (reftyping-implies-clsmap-result/L1 _ _ _ _ _).


%theorem reftyping-implies-clsmap-result/L2
  : forall* {CM} {B0} {N} {B1} {U3} {U4} {T}
    forall {CM-B1-U3: {x} clsmap-cxt-objset CM (B1 x) U3}
    {N!<U4: set`not-member U4 (s N)}
    {U4+N=U3: set`add U4 (s N) U3}
    {FS: cxt`fresh B0 (s N)}
    {UD: {x} cxt`update B0 (s N) (cxt-info/ x T) (B1 x)}
    exists {CM-B0-: clsmap-cxt-objset CM B0 U4}
    true.

%worlds (gtermvar) (reftyping-implies-clsmap-result/L2 _ _ _ _ _ _).
%trustme %total { } (reftyping-implies-clsmap-result/L2 _ _ _ _ _ _).


%theorem reftyping-implies-clsmap-result/L3
  : forall* {CM} {B0} {N} {B1} {T} {M6} {M3} {M7} {FS}
    forall {CM-B1-U3: {x} clsmap-cxt-capset CM (B1 x) M6}
    {N+FS=M3: nat+set2set (s N) FS M3}
    {M6-M3=M7: set`split M6 M3 M7}
    {FS: cxt`fresh B0 (s N)}
    {UD: {x} cxt`update B0 (s N) (cxt-info/ x T) (B1 x)}
    exists {CM-B0-: clsmap-cxt-capset CM B0 M7}
    true.

%worlds (gtermvar) (reftyping-implies-clsmap-result/L3 _ _ _ _ _ _).
%trustme %total { } (reftyping-implies-clsmap-result/L3 _ _ _ _ _ _).


%theorem reftyping-implies-clsmap-result/L4
  : forall* {CM} {B0} {N} {B1} {NN} {C} {V}
    forall {CM-B1-V: {x} clsmap-cxt-env CM (B1 x) V}
    {FS: cxt`fresh B0 (s N)}
    {UD: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)}
    exists {CM-B0-: clsmap-cxt-env CM B0 V}
    true.

%worlds (gtermvar) (reftyping-implies-clsmap-result/L4 _ _ _ _).
%trustme %total { } (reftyping-implies-clsmap-result/L4 _ _ _ _).


%theorem ty2new-reftype-implies-clsmap-cxt-reftype
  : forall* {CM} {B} {T} {RT}
    forall {CM-T: clsmap-ty CM T}
    {T2NT: ty2new-reftype T RT}
    exists {CM-B-RT: clsmap-cxt-reftype CM B RT}
    true.

- : ty2new-reftype-implies-clsmap-cxt-reftype
    (clsmap-ty/ CML) ty2new-reftype/shared (clsmap-cxt-reftype/shared CML).

- : ty2new-reftype-implies-clsmap-cxt-reftype
    (clsmap-ty/ CML) ty2new-reftype/unique
    (clsmap-cxt-reftype/fresh CML).

%worlds (gtermvar) (ty2new-reftype-implies-clsmap-cxt-reftype _ _ _).
%total { } (ty2new-reftype-implies-clsmap-cxt-reftype _ _ _).


%theorem ty2reftype-implies-clsmap-cxt-reftype
  : forall* {CM} {T} {RT} {N} {B} {BP}
    forall {CM-T: clsmap-ty CM T}
    {T=>RT: ty2reftype (s N) T RT}
    {BU: {x} cxt`update B (s N) (cxt-info/ x T) (BP x)}
    exists {CM-B-RT: {x} clsmap-cxt-reftype CM (BP x) RT}
    true.

- : ty2reftype-implies-clsmap-cxt-reftype (clsmap-ty/ CML)
    ty2reftype/unique ([x] BU x)
    ([x] clsmap-cxt-reftype/unique CML
      (cxt-unique-objset/U cxt-unique-objset/0
        (BL x) not-shared/unique (nonnull`leq/= nonnull`eq/) set`not-member/0
        (set`update/0))
      clsmap-cxt-unique-capset/0
      (wf-unique-targets/borrow (set`size/+ set`size/0) set`size/0))
    <- ({x} cxt`update-implies-lookup (BU x) (BL x)).

- : ty2reftype-implies-clsmap-cxt-reftype (clsmap-ty/ CML)
    ty2reftype/borrow ([x] BU x)
    ([x] clsmap-cxt-reftype/unique CML
      (cxt-unique-objset/U cxt-unique-objset/0
        (BL x) not-shared/borrow (nonnull`leq/= nonnull`eq/) set`not-member/0
        (set`update/0))
      clsmap-cxt-unique-capset/0
      (wf-unique-targets/borrow (set`size/+ set`size/0) set`size/0))
    <- ({x} cxt`update-implies-lookup (BU x) (BL x)).

- : ty2reftype-implies-clsmap-cxt-reftype (clsmap-ty/ CML)
    ty2reftype/shared _ ([_] clsmap-cxt-reftype/shared CML).

%worlds (gtermvar) (ty2reftype-implies-clsmap-cxt-reftype _ _ _ _).
%total { } (ty2reftype-implies-clsmap-cxt-reftype _ _ _ _).


%theorem reftyping-implies-clsmap-result/read/helper
  : forall* {CM} {FM} {C} {F} {FNN} {A} {FC} {B} {G0} {U0} {M0} {G1} {M1} {G2} {M2}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ FNN A FC)}
    {CM-B-R: clsmap-result CM B (result/expr (reftype/ nn/yes C G0) (env/ U0 M0))}
    {MG: make-tgts-and-caps M0 G0 F G1 M1}
    {CF: consider-ftype G1 M1 A G2 M2}
    exists {CM-R: clsmap-result CM B (result/expr (reftype/ FNN FC G2) (env/ U0 M2))}
    true.

- : reftyping-implies-clsmap-result/read/helper CM-CM CML
    (FML:fldmap`lookup FM F (ty/ FNN annot/unique FC))
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique
        (CML1:clsmap`lookup CM C FM1)
        (B-S: cxt-unique-objset B nn/yes C S)
        (CM-B-C-GM1': clsmap-cxt-unique-capset CM B nn/yes C GM1)
        WF)
      (clsmap-cxt-env/ (CM-B-U0: clsmap-cxt-objset CM B U0)
        (CM-B-M0: clsmap-cxt-capset CM B M0)))
    (make-tgts-and-caps/unique (S+F=GM2:set+nat2set S F GM2)
      (set`split/ _ (GM1+GM2=GM:set`union GM1 GM2 GM)) (M0-GM2=M1:set`split M0 GM2 M1))
    consider-ftype/unique
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique CM-FL cxt-unique-objset/0 CM-B-C-GM WF')
      (clsmap-cxt-env/ CM-B-U0 CM-B-M1))
    <- make-tgts-and-caps-consistent/2/L WF S+F=GM2 GM1+GM2=GM WF'
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CM-FL)
    <- set+nat2set-implies-clsmap-cxt-unique-capset CML FML B-S S+F=GM2 CM-B-C-GM2
    <- can-extend-clsmap-cxt-unique-capset CM-B-C-GM1' CML FML CM-B-C-GM1
    <- join-preserves-clsmap-cxt-unique-capset CM-B-C-GM1 CM-B-C-GM2 GM1+GM2=GM CM-B-C-GM
    <- set`split-implies-leq M0-GM2=M1 _ M1<=M0
  <- clsmap-cxt-capset-respects-geq CM-B-M0 M1<=M0 CM-B-M1.

- : reftyping-implies-clsmap-result/read/helper CM-CM CML
    (FML:fldmap`lookup FM F (ty/ FNN annot/shared FC))
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique
        (CML1:clsmap`lookup CM C FM1)
        (B-S: cxt-unique-objset B nn/yes C S)
        (CM-B-C-GM1: clsmap-cxt-unique-capset CM B nn/yes C GM1)
        WF)
      (clsmap-cxt-env/ (CM-B-U0: clsmap-cxt-objset CM B U0)
        (CM-B-M0: clsmap-cxt-capset CM B M0)))
    (make-tgts-and-caps/unique (S+F=GM2:set+nat2set S F GM2)
      (set`split/ _ (GM1+GM2=GM:set`union GM1 GM2 GM)) (M0-GM2=M1:set`split M0 GM2 M1))
    (consider-ftype/shared
      (set`split/ _ (GM+M1=M2: union GM M1 M2)))
    (clsmap-result/expr
      (clsmap-cxt-reftype/shared CM-FL)
      (clsmap-cxt-env/ CM-B-U0 CM-B-M2))
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CM-FL)
    <- set+nat2set-implies-clsmap-cxt-capset CML FML B-S S+F=GM2 CM-B-GM2
    <- clsmap-cxt-unique-capset-implies-clsmap-cxt-capset CM-B-C-GM1 CM-B-GM1
    <- join-preserves-clsmap-cxt-capset CM-B-GM1 CM-B-GM2 GM1+GM2=GM CM-B-GM
    <- set`split-implies-leq M0-GM2=M1 _ M1<=M0
    <- clsmap-cxt-capset-respects-geq CM-B-M0 M1<=M0 CM-B-M1
    <- join-preserves-clsmap-cxt-capset CM-B-GM CM-B-M1 GM+M1=M2 CM-B-M2.

- : reftyping-implies-clsmap-result/read/helper CM-CM CML
    (FML:fldmap`lookup FM F (ty/ FNN annot/unique FC))
    (clsmap-result/expr (clsmap-cxt-reftype/shared _)
      (clsmap-cxt-env/ (CM-B-U0: clsmap-cxt-objset CM B U0)
        (CM-B-M0: clsmap-cxt-capset CM B M0)))
    (make-tgts-and-caps/shared (SP: set`split M0 _ M1))
    consider-ftype/unique
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique CM-FL cxt-unique-objset/0
        (clsmap-cxt-unique-capset/z clsmap-cxt-unique-capset/0 set`not-member/0 set`update/0)
        (wf-unique-targets/unique (set`size/+ set`size/0)))
      (clsmap-cxt-env/ CM-B-U0 CM-B-M1))
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CM-FL)
    <- set`split-implies-leq SP _ M1<=M0
    <- clsmap-cxt-capset-respects-geq CM-B-M0 M1<=M0 CM-B-M1.

- : reftyping-implies-clsmap-result/read/helper CM-CM CML
    (FML:fldmap`lookup FM F (ty/ FNN annot/shared FC))
    (clsmap-result/expr (clsmap-cxt-reftype/shared _)
      (clsmap-cxt-env/ (CM-B-U0: clsmap-cxt-objset CM B U0)
        (CM-B-M0: clsmap-cxt-capset CM B M0)))
    (make-tgts-and-caps/shared (M0=M2+M1: set`split M0 _ M1))
    (consider-ftype/shared (M0P=M2+M1: set`split M0P _ M1))
    (clsmap-result/expr (clsmap-cxt-reftype/shared CM-FL)
      (clsmap-cxt-env/ CM-B-U0 CM-B-M0P))
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CM-FL)
    <- set`combine-unique M0=M2+M1 M0P=M2+M1 set`eq/ set`eq/ M0=M0P
    <- clsmap-cxt-capset-respects-eq CM-B-M0 clsmap`eq/ cxt`eq/ M0=M0P CM-B-M0P.

- : reftyping-implies-clsmap-result/read/helper CM-CM CML
    (FML:fldmap`lookup FM F (ty/ FNN annot/shared FC))
    (clsmap-result/expr (clsmap-cxt-reftype/fresh _)
      (clsmap-cxt-env/ (CM-B-U0: clsmap-cxt-objset CM B U0)
        (CM-B-M0: clsmap-cxt-capset CM B M0)))
    make-tgts-and-caps/fresh
    (consider-ftype/shared _)
    (clsmap-result/expr (clsmap-cxt-reftype/shared CM-FL)
      (clsmap-cxt-env/ CM-B-U0 CM-B-M0))
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CM-FL).

- : reftyping-implies-clsmap-result/read/helper CM-CM CML
    (FML:fldmap`lookup FM F (ty/ FNN annot/unique FC))
    (clsmap-result/expr (clsmap-cxt-reftype/fresh _)
      (clsmap-cxt-env/ (CM-B-U0: clsmap-cxt-objset CM B U0)
        (CM-B-M0: clsmap-cxt-capset CM B M0)))
    make-tgts-and-caps/fresh
    consider-ftype/unique
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique CM-FL cxt-unique-objset/0 clsmap-cxt-unique-capset/0
        (wf-unique-targets/unique+fresh))
      (clsmap-cxt-env/ CM-B-U0 CM-B-M0))
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CM-FL).

%worlds (gtermvar) (reftyping-implies-clsmap-result/read/helper _ _ _ _ _ _ _).
%total { } (reftyping-implies-clsmap-result/read/helper _ _ _ _ _ _ _).


%theorem reftyping-implies-clsmap-result/read
  : forall* {CM} {Rslt} {Rslt2} {F} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-Rslt: clsmap-result CM B Rslt}
    {RTYP-HELPER/R: readRefTyping CM Rslt F Rslt2}
    exists {CM-Rslt2: clsmap-result CM B Rslt2}
    true.

- : reftyping-implies-clsmap-result/read CM-CM CM-R0
    (readRefTyping/base CML FML MG CF _) CM-R1
    <- reftyping-implies-clsmap-result/read/helper CM-CM CML FML CM-R0 MG CF CM-R1.

%worlds (gtermvar) (reftyping-implies-clsmap-result/read _ _ _ _).
%total (CM-R) (reftyping-implies-clsmap-result/read _ CM-R _ _).


%theorem restore-cap-call-preserves-clsmap-cxt-env
  : forall* {CM} {B} {V0} {RT} {AV} {T} {V1}
    forall {CM-B-V0: clsmap-cxt-env CM B V0}
    {RCC: restore-cap-call V0 RT AV T V1}
    exists {CM-B-V1: clsmap-cxt-env CM B V1}
    true.

%worlds (gtermvar) (restore-cap-call-preserves-clsmap-cxt-env _ _ _).
%trustme %total { } (restore-cap-call-preserves-clsmap-cxt-env _ _ _).


%theorem restore-cap-targets-preserves-clsmap-cxt-env
  : forall* {CM} {B} {V0} {G} {V1} {NN} {C}
    forall {CM-B-V0: clsmap-cxt-env CM B V0}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ NN C G)}
    {RCT: restore-cap-targets V0 G V1}
    exists {CM-B-V1: clsmap-cxt-env CM B V1}
    true.

- : restore-cap-targets-preserves-clsmap-cxt-env CM-V _ restore-cap-targets/shared CM-V.

- : restore-cap-targets-preserves-clsmap-cxt-env (clsmap-cxt-env/ CM-B-U CM-B-M0)
    (clsmap-cxt-reftype/unique _ _ CM-B-NN-C-M1 _)
    (restore-cap-targets/unique (set`split/ _ M0+M1=M)) (clsmap-cxt-env/ CM-B-U CM-B-M)
    <- clsmap-cxt-unique-capset-implies-clsmap-cxt-capset CM-B-NN-C-M1 CM-B-M1
    <- join-preserves-clsmap-cxt-capset CM-B-M0 CM-B-M1 M0+M1=M CM-B-M.

%worlds (gtermvar) (restore-cap-targets-preserves-clsmap-cxt-env _ _ _ _).
%total { } (restore-cap-targets-preserves-clsmap-cxt-env _ _ _ _).


%theorem reftyping-implies-clsmap-result/let
  : forall* {CM} {MM} {R} {K} {F: object -> term K} {R2: result K} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM-B: clsmap-cxt CM B}
    {CM-Rslt: clsmap-result CM B R}
    {RTYP-LET: letRefTyping CM MM B R F R2}
    exists {CM-Rslt2: clsmap-result CM B R2}
    true.

%theorem reftyping-implies-clsmap-result/write
  : forall* {CM} {MM} {F} {E} {Rslt2} {G} {T} {Rslt1} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM-B: clsmap-cxt CM B}
    {CM-Rslt1: clsmap-result CM B Rslt1}
    {RTYP-W: writeRefTyping CM MM B Rslt1 F E G T Rslt2}
    exists {CM-Rslt2: clsmap-result CM B Rslt2}
    true.

%theorem reftyping-implies-clsmap-result/args
  : forall* {CM} {MM} {B} {V} {A} {MT} {AR}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM-B: clsmap-cxt CM B}
    {CM-V: clsmap-cxt-env CM B V}
    {CM-MT: clsmap-methty CM MT}
    {RTYP-ARGS: argsRefTyping CM MM B V A MT AR}
    exists {CM-Rslt: clsmap-result CM B AR}
    true.

%theorem reftyping-implies-clsmap-result/call
  : forall* {CM} {MM} {B} {V} {MT} {AR} {R}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM-B: clsmap-cxt CM B}
    {CM-V: clsmap-cxt-env CM B V}
    {CM-B-AR: clsmap-result CM B AR}
    {CM-MT: clsmap-methty CM MT}
    {RTYP-CALL: callRefTyping* CM MM V AR MT R}
    exists {CM-Rslt: clsmap-result CM B R}
    true.

- : reftyping-implies-clsmap-result/call CM-CM CM-MM CM-B CM-B-V0
    (clsmap-result/args/0 CM-B-V1) (clsmap-methty/base CM-T)
    (callRefTyping/arg/0 V0+V1=V T2NT)
    (clsmap-result/expr CM-B-RT CM-B-V)
    <- ty2new-reftype-implies-clsmap-cxt-reftype CM-T T2NT CM-B-RT
    <- combine-preserves-clsmap-cxt-env CM-B-V0 CM-B-V1 V0+V1=V CM-B-V.

- : reftyping-implies-clsmap-result/call CM-CM CM-MM CM-B CM-B-V0
    (clsmap-result/args/+ CM-B-RT CM-B-V1 CM-B-AR)
    (clsmap-methty/args CM-MT _ _ _)
    (callRefTyping/arg/+ RCC RTYP-CALL) CM-B-R
    <- restore-cap-call-preserves-clsmap-cxt-env CM-B-V0 RCC CM-B-V2
    <- reftyping-implies-clsmap-result/call CM-CM CM-MM CM-B CM-B-V2 CM-B-AR
      CM-MT RTYP-CALL CM-B-R.

- : reftyping-implies-clsmap-result/args CM-CM CM-MM _
    (clsmap-cxt-env/ (CM-B-U0:clsmap-cxt-objset CM B U0) (CM-B-M0:clsmap-cxt-capset CM B M0))
    (clsmap-methty/base CM-T)
    argsRefTyping/0
    (clsmap-result/args/0 (clsmap-cxt-env/ CM-B-U0 CM-B-M0)).

- : reftyping-implies-clsmap-result/args CM-CM CM-MM CM-B
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (clsmap-methty/args CM-MT _ _ _)
    (argsRefTyping/+ RTYP-E SUB RTYP-A)
    (clsmap-result/args/+ CM-B-RT CM-B-AV CM-B-AR)
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP-E
      (clsmap-result/expr (CM-B-RT:clsmap-cxt-reftype CM B RT)
        (CM-B-V1:clsmap-cxt-env CM B V1))
    <- subtype-consistent CM-B-RT CM-B-V1 SUB (CM-B-V2:clsmap-cxt-env CM B V2)
      (CM-B-AV:clsmap-cxt-env CM B AV)
    <- reftyping-implies-clsmap-result/args CM-CM CM-MM CM-B CM-B-V2 CM-MT RTYP-A CM-B-AR.

- : reftyping-implies-clsmap-result/write CM-CM CM-MM CM-B CM-R1
    (writeRefTyping/base CML FML
      (MG:make-tgts-and-caps M0 G0 F G1 M1)
      (RTYP-E2:reftyping CM MM B (env/ U0 M1) E (result/expr RT (env/ U1 M2)))
      (SUB:subtype CM _ RT _ (ty/ NN A FC) _ (env/ U2 M3))
      (CF:consider-ftype G1 M3 A G2 M4)) CM-R2
    <- make-tgts-and-caps-consistent/1 CM-CM CML FML CM-R1 MG CM-B-V0
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP-E2
      (clsmap-result/expr CM-B-RT CM-B-V2)
    <- subtype-consistent CM-B-RT CM-B-V2 SUB CM-B-V3 CM-B-V4
    <- make-tgts-and-caps-consistent/2 CM-CM CML FML CM-R1 CM-B-V3 MG CF CM-R2.

- : reftyping-implies-clsmap-result/let CM-CM CM-MM CM-B0
    (clsmap-result/expr
      (clsmap-cxt-reftype/shared _)
      (clsmap-cxt-env/
        (CM-B0-U0:clsmap-cxt-objset CM B0 U0)
        (CM-B0-M0:clsmap-cxt-capset CM B0 M0)))
    (letRefTyping/base/shared
      (CML:clsmap`lookup CM C FM)
      (N!<B0: cxt`fresh B0 (s N))
      ([x] B0+N=B1 x)
      ([x] RTYP-F x)
      (N!<G1: not-in-targets (s N) G1))
    (clsmap-result/expr CM-B0-RT CM-B0-V1)
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-objset
         CM-B0-U0 N!<B0 (B0+N=B1 x) (CM-B1-U0 x))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capset
         CM-B0-M0 N!<B0 (B0+N=B1 x) (CM-B1-M0 x))
    <- ({x} reftyping-implies-clsmap-result CM-CM CM-MM
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (clsmap-cxt-env/ (CM-B1-U0 x) (CM-B1-M0 x)) (RTYP-F x)
         (clsmap-result/expr (CM-B1-RT x) (CM-B1-V1 x)))
    <- reftyping-implies-clsmap-result/L1 CM-B1-RT N!<G1 N!<B0 B0+N=B1 CM-B0-RT
    <- reftyping-implies-clsmap-result/L4 CM-B1-V1 N!<B0 B0+N=B1 CM-B0-V1.

- : reftyping-implies-clsmap-result/let CM-CM CM-MM CM-B0
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique _ _ CM-B0-NN-C-M1 _)
      (clsmap-cxt-env/
        (CM-B0-U0:clsmap-cxt-objset CM B0 U0)
        (CM-B0-M0:clsmap-cxt-capset CM B0 M0)))
    (letRefTyping/base/unique
      (CML:clsmap`lookup CM C FM)
      (FM-DM: fldmap`domain FM FS)
      (S+FS=M2: set+set2set S FS M2)
      (N!<B0: cxt`fresh B0 (s N))
      ([x] B0+N=B1 x)
      (U0-S=U1: set`split U0 S U1)
      (N!<U1: set`not-member U1 (s N))
      (U1+N=U2: set`add U1 (s N) U2)
      (M0-M2=M4: set`split M0 M2 M4)
      (N+FS=M3: nat+set2set (s N) FS M3)
      (set`split/ _ (M3+M4=M5: set`union M3 M4 M5))
      ([x] RTYP-F x)
      (N!<G1: not-in-targets (s N) G1)
      (M6-M3=M7: set`split M6 M3 M7)
      (set`split/ _ (M2+M7=M8:set`union M2 M7 M8))
      (set`split/ _ (M1+M8=M9:set`union M1 M8 M9))
      (N!<U4: set`not-member U4 (s N))
      (U4+N=U3: set`add U4 (s N) U3)
      (U4+S=U5: set`union U4 S U5))
    (clsmap-result/expr CM-B0-RT (clsmap-cxt-env/ CM-B0-U5 CM-B0-M9))
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1->N x))
    <- ({x} nat+set2set-implies-clsmap-cxt-capset CML FM-DM
         (B1->N x) not-shared/unique N+FS=M3 (CM-B1-M3 x))
    <- set`split-implies-leq M0-M2=M4 M2<=M0 M4<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M2<=M0 CM-B0-M2
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M4<=M0 CM-B0-M4
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capset CM-B0-M4
         N!<B0 (B0+N=B1 x) (CM-B1-M4 x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-M3 x) (CM-B1-M4 x)
         M3+M4=M5 (CM-B1-M5 x))
    <- set`split-implies-leq U0-S=U1 S<=U0 U1<=U0
    <- clsmap-cxt-objset-respects-geq CM-B0-U0 S<=U0 CM-B0-S
    <- clsmap-cxt-objset-respects-geq CM-B0-U0 U1<=U0 CM-B0-U1
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-objset CM-B0-U1
         N!<B0 (B0+N=B1 x) (CM-B1-U1 x))
    <- ({x} reftyping-implies-clsmap-result CM-CM CM-MM
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (clsmap-cxt-env/
           (clsmap-cxt-objset/U (CM-B1-U1 x) (B1->N x) CML N!<U1 U1+N=U2)
           (CM-B1-M5 x)) (RTYP-F x)
         (clsmap-result/expr
           (CM-B1-RT x)
           (clsmap-cxt-env/ (CM-B1-U3 x) (CM-B1-M6 x))))
    <- clsmap-cxt-unique-capset-implies-clsmap-cxt-capset CM-B0-NN-C-M1 CM-B0-M1
    <- reftyping-implies-clsmap-result/L1 CM-B1-RT N!<G1 N!<B0 B0+N=B1 CM-B0-RT
    <- reftyping-implies-clsmap-result/L2 CM-B1-U3 N!<U4
      U4+N=U3 N!<B0 B0+N=B1 CM-B0-U4
    <- reftyping-implies-clsmap-result/L3 CM-B1-M6 N+FS=M3 M6-M3=M7 N!<B0 B0+N=B1 CM-B0-M7
    <- join-preserves-clsmap-cxt-objset CM-B0-U4 CM-B0-S U4+S=U5 CM-B0-U5
    <- join-preserves-clsmap-cxt-capset CM-B0-M2 CM-B0-M7 M2+M7=M8 CM-B0-M8
    <- join-preserves-clsmap-cxt-capset CM-B0-M1 CM-B0-M8 M1+M8=M9 CM-B0-M9.


%%% cases for the main theorem

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V
    (reftyping/read RTYP-E RTYP-HELPER-F) CM-R2
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-E CM-R
    <- reftyping-implies-clsmap-result/read CM-CM CM-R RTYP-HELPER-F CM-R2.

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V
    (reftyping/let RTYP-E LTYP) CM-R2
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-E CM-R
    <- reftyping-implies-clsmap-result/let CM-CM CM-MM CM-B CM-R LTYP CM-R2.

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V
    (reftyping/lit BL0 ty2reftype/shared)
    (clsmap-result/expr (clsmap-cxt-reftype/shared CML) CM-B-V)
    <- cxt`lookup-obj-implies-lookup BL0 BL
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/ CML).

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V
    (reftyping/lit BL0 ty2reftype/unique)
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique CML
        (cxt-unique-objset/U cxt-unique-objset/0 BL not-shared/unique
          (nonnull`leq/= nonnull`eq/) set`not-member/0 set`update/0)
        clsmap-cxt-unique-capset/0
        (wf-unique-targets/borrow (set`size/+ set`size/0) set`size/0))
      CM-B-V)
    <- cxt`lookup-obj-implies-lookup BL0 BL
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/ CML).

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V
    (reftyping/lit BL0 ty2reftype/borrow)
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique CML
        (cxt-unique-objset/U cxt-unique-objset/0 BL not-shared/borrow
          (nonnull`leq/= nonnull`eq/) set`not-member/0 set`update/0)
        clsmap-cxt-unique-capset/0
        (wf-unique-targets/borrow (set`size/+ set`size/0) set`size/0))
      CM-B-V)
    <- cxt`lookup-obj-implies-lookup BL0 BL
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/ CML).

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V
    (reftyping/write RTYP-E1 RTYP-H) CM-R2
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-E1 CM-R
    <- reftyping-implies-clsmap-result/write CM-CM CM-MM CM-B CM-R RTYP-H CM-R2.

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V
    (reftyping/call FS MM-L RTYP-A RTYP-C) CM-R
    <- lookup-implies-clsmap-methty CM-MM MM-L CM-MT
    <- reftyping-implies-clsmap-result/args CM-CM CM-MM CM-B CM-V CM-MT RTYP-A CM-AR
    <- reftyping-implies-clsmap-result/call CM-CM CM-MM CM-B
      (clsmap-cxt-env/ clsmap-cxt-objset/0 clsmap-cxt-capset/0) CM-AR CM-MT RTYP-C CM-R.

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V
    (reftyping/const CML FM-DM MML RTYP-A RTYP-C) CM-R
    <- lookup-implies-clsmap-methty CM-MM MML (clsmap-methty/args CM-MT _ _ _)
    <- reftyping-implies-clsmap-result/args CM-CM CM-MM CM-B CM-V CM-MT RTYP-A CM-AR
    <- reftyping-implies-clsmap-result/call CM-CM CM-MM CM-B
      (clsmap-cxt-env/ clsmap-cxt-objset/0 clsmap-cxt-capset/0) CM-AR CM-MT RTYP-C CM-R.

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0
    (reftyping/eq RTYP-E1 RTYP-E2 RCT1 RCT2) (clsmap-result/cond CM-V4)
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP-E1
      (clsmap-result/expr CM-B-RT1 CM-V1)
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V1 RTYP-E2
      (clsmap-result/expr CM-B-RT2 CM-V2)
    <- restore-cap-targets-preserves-clsmap-cxt-env CM-V2 CM-B-RT1 RCT1 CM-V3
    <- restore-cap-targets-preserves-clsmap-cxt-env CM-V3 CM-B-RT2 RCT2 CM-V4.

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V
    (reftyping/and RTYP-C1 RTYP-C2) (clsmap-result/cond CM-V2)
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-C1
      (clsmap-result/cond CM-V1)
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V1 RTYP-C2
      (clsmap-result/cond CM-V2).

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V
    (reftyping/not RTYP-C) CM-R
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-C CM-R.

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0
    (reftyping/sub _ _ CM-R1) CM-R1.

- : reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0
    (reftyping/if RTYP-C RTYP-E1 _) CM-R
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP-C (clsmap-result/cond CM-V1)
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V1 RTYP-E1 CM-R.

%worlds (gtermvar) (reftyping-implies-clsmap-result _ _ _ _ _ _)
  (reftyping-implies-clsmap-result/let _ _ _ _ _ _)
  (reftyping-implies-clsmap-result/write _ _ _ _ _ _)
  (reftyping-implies-clsmap-result/args _ _ _ _ _ _ _)
  (reftyping-implies-clsmap-result/call _ _ _ _ _ _ _ _).

%total (A0 A1 A2 A3 A4) (reftyping-implies-clsmap-result _ _ _ _ A0 _)
  (reftyping-implies-clsmap-result/let _ _ _ _ A1 _)
  (reftyping-implies-clsmap-result/write _ _ _ _ A2 _)
  (reftyping-implies-clsmap-result/args _ _ _ _ _ A3 _)
  (reftyping-implies-clsmap-result/call _ _ _ _ _ _ A4 _).