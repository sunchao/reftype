%%% consistency relation between clsmap, methmap and fldmap

%%% check if a type is in clsmap

clsmap-ty : clsmap -> ty -> type.

clsmap-ty/notnull
  : clsmap-ty CM (ty/ _ _ C)
    <- clsmap`lookup CM C _.

clsmap-ty/null : clsmap-ty CM ty/null.



% check if all types appear in methty is also in clsmap

clsmap-methty : clsmap -> methty -> type.

% nothing to check for shared effect
clsmap-methty/base
  : clsmap-methty CM (methty/base T _)
    <- clsmap-ty CM T.

% should we worried that effect sets are not
% subsets of class's field set?
clsmap-methty/args
  : clsmap-methty CM (methty/arg T _ _ A)
    <- clsmap-ty CM T
    <- clsmap-methty CM A.


% check if a fldmap is consistent with a clsmap

clsmap-fldmap : clsmap -> fldmap -> type.

clsmap-fldmap/0 : clsmap-fldmap _ fldmap/0.

clsmap-fldmap/+
  : clsmap-fldmap CM (fldmap/+ _ T FM)
    <- clsmap-ty CM T
    <- clsmap-fldmap CM FM.


% check if a clsmap is consistent with itself

clsmap-clsmap : clsmap -> clsmap -> type.

clsmap-clsmap/0 : clsmap-clsmap _ clsmap`map/0.

clsmap-clsmap/+
  : clsmap-clsmap CM0 (clsmap`map/+ C FM CM)
    <- clsmap`lookup CM0 C FM
    <- clsmap-fldmap CM0 FM
    <- clsmap`shift C CM CMS
    <- clsmap-clsmap CM0 CMS.


% check if a clsmap is consistent with a methmap

clsmap-methmap : clsmap -> methmap -> type.

clsmap-methmap/0 : clsmap-methmap _ methmap`map/0.

clsmap-methmap/meth
  : clsmap-methmap CM (methmap`map/+ N MT MM)
    <- clsmap`fresh CM N
    <- clsmap-methty CM MT
    <- methmap`shift N MM MMS
    <- clsmap-methmap CM MMS.

clsmap-methmap/const
  : clsmap-methmap CM
    (methmap`map/+ N (methty/arg (ty/ nonnull/yes _ N) _ _ MT) MM)
    <- clsmap`lookup CM N _
    <- clsmap-methty CM MT
    <- methmap`shift N MM MMS
    <- clsmap-methmap CM MMS.


% consistency between clsmap and context

clsmap-cxt : clsmap -> cxt -> type.

clsmap-cxt/nil : clsmap-cxt _ cxt/nil.

clsmap-cxt/cons
  : clsmap-cxt CM (cxt/cons O T B)
    <- clsmap-ty CM T
    <- clsmap-cxt CM B.


% for each entry (L -> M) in efxmap, L must be in cxt, and M must
% be consistent with SOME fldmap in clsmap.

clsmap-cxt-tgtmap : clsmap -> cxt -> tgtmap -> type.

clsmap-cxt-tgtmap/0 : clsmap-cxt-tgtmap _ _ tgtmap/0.

clsmap-cxt-tgtmap/U
  : clsmap-cxt-tgtmap CM B GMP
    -> tgtmap`fresh GMP N
    -> tgtmap`update GMP N S GM
    -> cxt`lookup B (object/ N) (ty/ _ _ C)
    -> clsmap`lookup CM C FM
    -> fldmap`domain FM FS
    -> set`leq S FS
    -> clsmap-cxt-tgtmap CM B GM.


clsmap-cxt-efxmap : clsmap -> cxt -> efxmap -> type.

clsmap-cxt-efxmap/0 : clsmap-cxt-efxmap _ _ efxmap/0.

clsmap-cxt-efxmap/U
  : clsmap-cxt-efxmap CM B XMP
    -> efxmap`fresh XMP N
    -> efxmap`update XMP N M XM
    -> cxt`lookup B (object/ N) (ty/ _ _ C)
    -> clsmap`lookup CM C FM
    -> fldmap`domain FM FS
    -> inner-efxmap`domain M MS
    -> set`leq MS FS
    -> clsmap-cxt-efxmap CM B XM.

% a wrapper on clsmap-cxt-efxmap

clsmap-cxt-effects : clsmap -> cxt -> effects -> type.

clsmap-cxt-effects/ : clsmap-cxt-effects CM B (effects/ M X)
                      <- clsmap-cxt-efxmap CM B M.


same-class : cxt -> set -> nat -> type.

same-class/0 : same-class _ set/0 _.

same-class/U
  : same-class B SP C
    -> set`not-member SP N
    -> set`add SP N S
    -> cxt`lookup B (object/ N) (ty/ _ _ C)
    -> same-class B S C.

clsmap-cxt-targets : clsmap -> cxt -> nat -> targets -> type.

clsmap-cxt-targets/shared : clsmap-cxt-targets _ _ _ targets/shared.

clsmap-cxt-targets/unique
  : clsmap-cxt-targets CM B C (targets/unique S GM _)
    <- same-class B S C
    <- clsmap-cxt-tgtmap CM B GM.


targets-effects : targets -> effects -> type.

targets-effects/unique
  : targets-effects (targets/unique S G _) (effects/ M _)
    <- tgtmap`leq-efxmap G M.

targets-effects/shared : targets-effects (targets/shared) _.


% ===================================
% =========== Theorems ==============
% ===================================


%theorem same-class-respects-eq
  : forall* {B} {BP} {S} {SP} {C} {CP}
    forall {SOC: same-class B S C}
    {E: cxt`eq B BP} {E: set`eq S SP}
    {E: nat`eq C CP}
    exists {SOC: same-class BP SP CP}
    true.

- : same-class-respects-eq SOC cxt`eq/ set`eq/ nat`eq/ SOC.

%worlds () (same-class-respects-eq _ _ _ _ _).
%total {} (same-class-respects-eq _ _ _ _ _).


%theorem same-class/U-inversion
  : forall* {B} {S} {SP} {C} {N}
    forall {SOC: same-class B S C}
    {NM: set`not-member SP N}
    {AD: set`add SP N S}
    exists {NN} {A} {SOC: same-class B SP C}
    {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    true.

%theorem same-class/U-inversion/L
  : forall* {B} {S} {SP1} {C} {N1} {A1} {NN1} {SP} {N} {P}
    forall {SOC: same-class B SP1 C}
    {NM1: set`not-member SP1 N1}
    {AD1: set`add SP1 N1 S}
    {BL1: cxt`lookup B (object/ N1) (ty/ NN1 A1 C)}
    {NM: set`not-member SP N}
    {AD: set`add SP N S}
    {EQ?: nat`eq? N N1 P}
    exists {NN} {A} {SOC: same-class B SP C}
    {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    true.

- : same-class/U-inversion/L
    SOC0 F0 U0 BL0 F1 U1 nat`eq?/yes _ _ SOC1 BL0
    <- set`not-member-add-cancels F0 U0 F1 U1 nat`eq/ set`eq/ S0=S1
    <- same-class-respects-eq SOC0 cxt`eq/ S0=S1 nat`eq/ SOC1.

- : same-class/U-inversion/L
    SOC0 F0 U0 BL0 F1 U1 (nat`eq?/no N<>N1) _ _ 
    (same-class/U SOC2 F3 U3 BL0) BL2
    <- set`update-commutes-converse U1 U0 N<>N1 _ U3 U2
    <- set`add-preserves-not-member-converse F1 U3 F2
    <- set`add-preserves-not-member-converse F0 U2 F3
    <- same-class/U-inversion SOC0 F2 U2 _ _ SOC2 BL2.

- : same-class/U-inversion
    (same-class/U SOC0 F0 A0 BL0) F1 A1 _ _ SOC1 BL1
    <- nat`eq?-total E?
    <- same-class/U-inversion/L SOC0 F0 A0 BL0 F1 A1 E? _ _ SOC1 BL1.

%worlds () (same-class/U-inversion _ _ _ _ _ _ _)
(same-class/U-inversion/L _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (same-class/U-inversion C0 _ _ _ _ _ _)
(same-class/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _).