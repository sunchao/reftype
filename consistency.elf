%% Consistency relation between various contexts.


%%% Well-formedness of Field Type
%%% A field type shouldn't be borrowed.

wf-fldty : ty -> type.

wf-fldty/ : not-borrowed A -> wf-fldty (ty/ _ A _).


%%% Well-formedness of a Field Map (Helper)
%%% This says that all types in a well-formed fldmap
%%% should NOT be borrowed.

wf-fldmap : fldmap -> type.

wf-fldmap/0 : wf-fldmap fldmap/0.

wf-fldmap/U :
    wf-fldmap FM' ->
    wf-fldty T ->
    fldmap`fresh FM' F ->
    fldmap`update FM' F T FM ->
  wf-fldmap FM.


%%% Well-formed Class Map
%%% 1, All field map in the class map has to be well-formed.
%%% 2, the class map should contain an entry for the special world object.

wf-clsmap : clsmap -> type.

wf-clsmap/0 : wf-clsmap clsmap/0.

wf-clsmap/U :
    wf-clsmap CM' ->
    wf-fldmap FM ->
    fldmap`size FM (s _) ->
    clsmap`fresh CM' C ->
    clsmap`update CM' C FM CM ->
  wf-clsmap CM.


%%% Consistency between a class map and a type.
%%% Check if the class ID is in clsmap

clsmap-ty : clsmap -> ty -> type.

clsmap-ty/ : clsmap`lookup CM C _ -> clsmap-ty CM (ty/ _ _ C).


%%% Consistency between a class map and a method type.
%%% Check if all types appear in methty is also in clsmap

clsmap-methty : clsmap -> methty -> type.

clsmap-methty/base :
    clsmap-ty CM T -> clsmap-methty CM (methty/base T).

clsmap-methty/args :
    clsmap-methty CM A ->
    clsmap-ty CM T ->
  clsmap-methty CM (methty/arg T _ A).


%%% Consistency between a class map and a field map.
%%% Check if a fldmap is consistent with a clsmap.

clsmap-fldmap : clsmap -> fldmap -> type.

clsmap-fldmap/0 : clsmap-fldmap _ fldmap/0.

clsmap-fldmap/+ :
    clsmap-fldmap CM FM ->
    clsmap-ty CM T ->
  clsmap-fldmap CM (fldmap/+ _ T FM).


%%% Well-formedness of a class map
%%% Check if a clsmap is consistent with itself.

clsmap-clsmap : clsmap -> clsmap -> type.

clsmap-clsmap/0 : clsmap-clsmap _ clsmap`map/0.

clsmap-clsmap/+ :
    clsmap-clsmap CM0 CMS ->
    clsmap`shift C CM CMS ->
    clsmap-fldmap CM0 FM ->
    clsmap`lookup CM0 C FM ->
  clsmap-clsmap CM0 (clsmap`map/+ C FM CM).

%%% Consistency between a class map and a method map.
%%% Check if a clsmap is consistent with a methmap

clsmap-methmap : clsmap -> methmap -> type.

clsmap-methmap/0 : clsmap-methmap _ methmap`map/0.

clsmap-methmap/meth :
    clsmap-methmap CM MMS ->
    methmap`shift N MM MMS ->
    clsmap-methty CM MT ->
    clsmap`fresh CM N ->
  clsmap-methmap CM (methmap`map/+ N MT MM).

clsmap-methmap/const :
    clsmap-methmap CM MMS ->
    methmap`shift N MM MMS ->
    clsmap-methty CM MT ->
    clsmap`lookup CM N _ ->
  clsmap-methmap CM (methmap`map/+ N (methty/arg (ty/ nonnull/yes _ N) _ MT) MM).


%%% Consistency between clsmap and explicit context.
%%% All entries in the context should be either shared or borrowed.

clsmap-cxt : clsmap -> cxt -> type.

clsmap-cxt/0 : clsmap-cxt _ cxt/0.

clsmap-cxt/U :
    clsmap-cxt CM B' ->
    clsmap-ty CM T ->
    cxt`fresh B' N ->
    cxt`update B' N (cxt-info/ _ T) B ->
  clsmap-cxt CM B.


%%% Whether all object ids in the set are of the same class C.

same-class : cxt -> set -> nat -> type.

same-class/0 : same-class _ set/0 _.

same-class/U :
    same-class B S' C ->
    set`not-member S' (s N) ->
    set`add S' (s N) S ->
    cxt`lookup B (s N) (cxt-info/ _ (ty/ _ _ C)) ->
  same-class B S C.


%%% The least nonnull-ness in a context.

least-nonnull : cxt -> set -> nn -> type.

least-nonnull/0 : least-nonnull _ set/0 _.

least-nonnull/U :
    least-nonnull B S' NN ->
    set`not-member S' N ->
    set`add S' N S ->
    cxt`lookup B N (cxt-info/ O (ty/ NN' _ _)) ->
    nonnull`leq NN NN' ->
  least-nonnull B S NN.


%%% This relation says all "pairs" (obj,fld) in the keyset of capmap are valid:
%%% i.e., you can find obj in the context B with class id C, find C
%%% in the clsmap CM with FM, and find fld in FM with type T.

clsmap-cxt-capmap : clsmap -> cxt -> capmap -> type.

clsmap-cxt-capmap/0 : clsmap-cxt-capmap _ _ capmap/0.

clsmap-cxt-capmap/z :
    clsmap-cxt-capmap CM B M' ->
    capmap`fresh M' shared ->
    capmap`update M' shared _ M ->
  clsmap-cxt-capmap CM B M.

clsmap-cxt-capmap/U :
    clsmap-cxt-capmap CM B M' ->
    nat2pair (s K) (pair/ N F) ->
    cxt`lookup B N (cxt-info/ _ (ty/ _ _ C)) ->
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F T ->
    capmap`fresh M' (s K) ->
    capmap`update M' (s K) _ M ->
  clsmap-cxt-capmap CM B M.

%%% This relation likes the one above, except all elements in the
%%% set are objs. So, we just need them to be in the context B.
%%% This is very similar to same-class, but weaker.

clsmap-cxt-objset : clsmap -> cxt -> set -> type.

clsmap-cxt-objset/0 : clsmap-cxt-objset _ _ set/0.

clsmap-cxt-objset/U :
    clsmap-cxt-objset CM B S' ->
    cxt`lookup B N (cxt-info/ O (ty/ _ _ C)) ->
    clsmap`lookup CM C FM ->
    set`not-member S' N ->
    set`add S' N S ->
  clsmap-cxt-objset CM B S.


cxt-unique-objset : cxt -> nonnull -> nat -> set -> type.

cxt-unique-objset/0 : cxt-unique-objset _ _ _ set/0.

cxt-unique-objset/U :
    cxt-unique-objset B NN C S' ->
    cxt`lookup B (s N) (cxt-info/ _ (ty/ NN' A C)) ->
    unique-or-borrow A ->
    nonnull`leq NN NN' ->
    set`not-member S' (s N) ->
    set`add S' (s N) S ->
  cxt-unique-objset B NN C S.


%%% Well-formed Unique Targets
%%% The only restriction is at least one of objset or fldset
%%% needs to be non-empty.

wf-unique-targets : targets -> type.

wf-unique-targets/1 : wf-unique-targets (targets/unique (set/+ _ _) capmap/0).

wf-unique-targets/2 : wf-unique-targets (targets/unique _ (capmap/+ _ _ _)).


%%% Well-formed Reftype
%%% 1, The objset should contain all unique objects, which have the same class
%%% ID, and conform to the least nonnull-ness
%%% 2, The fldset should also be consistent with the context.
%%% TODO: perhaps we should restrict all object IDs in the fldset to be
%%%  unique as well?

clsmap-cxt-reftype : clsmap -> cxt -> reftype -> type.

clsmap-cxt-reftype/shared :
    clsmap`lookup CM C _ ->
  clsmap-cxt-reftype CM _ (reftype/ NN C targets/shared).

clsmap-cxt-reftype/unique :
    clsmap`lookup CM C _ ->
    cxt-unique-objset B NN C OS ->
    clsmap-cxt-capmap CM B M ->
    wf-unique-targets (targets/unique OS M) ->
  clsmap-cxt-reftype CM B (reftype/ NN C (targets/unique OS M)).


clsmap-env : clsmap -> env -> type.

clsmap-env/ :
    clsmap-cxt CM B ->
    clsmap-cxt-capmap CM B M ->
  clsmap-env CM (env/ B M).


clsmap-result : clsmap -> result K -> type.

clsmap-result/exists :
    ({o} clsmap-result CM (Rslt o)) ->
  clsmap-result CM (result/exists [o] (Rslt o)).

clsmap-result/expr :
    clsmap-cxt CM B ->
    clsmap-cxt-reftype CM B RT ->
    clsmap-cxt-capmap CM B M ->
  clsmap-result CM (result/expr RT (env/ B M)).


%%% Theorems

% least-nonnull

%theorem least-nonnull-respects-eq
  : forall* {B} {S} {NN} {B'} {S'} {NN'}
    forall {_: least-nonnull B S NN}
    {BE: cxt`eq B B'} {SE: set`eq S S'}
    {NNE: nonnull`eq NN NN'}
    exists {_: least-nonnull B' S' NN'}
    true.

- : least-nonnull-respects-eq FLN cxt`eq/ set`eq/ nonnull`eq/ FLN.

%worlds (objvar) (least-nonnull-respects-eq _ _ _ _ _).
%total { } (least-nonnull-respects-eq _ _ _ _ _).


%theorem least-nonnull/U-inversion
  : forall* {B} {S} {NN} {S'} {N}
    forall {B-S-NN: least-nonnull B S NN}
    {FS: set`not-member S' N} {AD: set`add S' N S}
    exists {O} {NN'} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN' A C))}
    {LE: nonnull`leq NN NN'} {B-S'-NN: least-nonnull B S' NN}
    true.

%theorem least-nonnull/U-inversion/L
  : forall* {S1} {N1} {S} {NN} {O1} {NN1} {A1} {C1} {B} {S'} {N} {P}
    forall {FS1: set`not-member S1 N1}
    {AD1: set`add S1 N1 S}
    {B-S-NN1: least-nonnull B S1 NN}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {LE1: nonnull`leq NN NN1}
    {FS: set`not-member S' N}
    {AD: set`add S' N S}
    {E?: nat`eq? N N1 P}
    exists {O} {NN'} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN' A C))}
    {LE: nonnull`leq NN NN'} {B-S'-NN: least-nonnull B S' NN}
    true.

- : least-nonnull/U-inversion/L
    F1 U1 B-S-NN1 BL1 LE1 F2 U2 nat`eq?/yes %{=>}% _ _ _ _ BL1 LE1 B-S-NN
    <- set`not-member-add-cancels F1 U1 F2 U2 nat`eq/ set`eq/ S1=S2
    <- least-nonnull-respects-eq B-S-NN1 cxt`eq/ S1=S2 nonnull`eq/ B-S-NN.

- : least-nonnull/U-inversion/L
    F1 U1 B-S-NN1 BL1 LE1 F2 U2 (nat`eq?/no N<>N1) %{=>}% _ _ _ _
    BL3 LE3 (least-nonnull/U B-S-NN F4 U4 BL1 LE1)
    <- set`add-commutes-converse U2 U1 N<>N1 SP U4 U3
    <- set`add-preserves-not-member-converse F2 U4 F3
    <- set`add-preserves-not-member-converse F1 U3 F4
    <- least-nonnull/U-inversion B-S-NN1 F3 U3 _ _ _ _ BL3 LE3 B-S-NN.

- : least-nonnull/U-inversion
    (least-nonnull/U B-S-NN1 F1 U1 BL1 LE1) F2 U2 _ _ _ _ BL LE B-S-NN
    <- nat`eq?-total E?
    <- least-nonnull/U-inversion/L F1 U1 B-S-NN1 BL1 LE1 F2 U2 E?
      _ _ _ _ BL LE B-S-NN.

%worlds (objvar) (least-nonnull/U-inversion _ _ _ _ _ _ _ _ _ _)
  (least-nonnull/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N N1) (least-nonnull/U-inversion N _ _ _ _ _ _ _ _ _)
  (least-nonnull/U-inversion/L _ _ N1 _ _ _ _ _ _ _ _ _ _ _ _).


%% clsmap, fldmap, methmap, etc.

%theorem false-implies-wf-fldmap
  : forall {F:void} {FM}
    exists {WF-FM: wf-fldmap FM}
    true.

%worlds () (false-implies-wf-fldmap _ _ _).
%total { } (false-implies-wf-fldmap _ _ _).


%theorem wf-fldmap-respects-eq
  : forall* {FM} {FM'}
    forall {WF-FM: wf-fldmap FM}
    {E: fldmap`eq FM FM'}
    exists {WF-FM': wf-fldmap FM'}
    true.

- : wf-fldmap-respects-eq WF-FM fldmap`eq/ WF-FM.

%worlds () (wf-fldmap-respects-eq _ _ _).
%total { } (wf-fldmap-respects-eq _ _ _).


%theorem false-implies-wf-clsmap
  : forall {F:void} {CM}
    exists {WF-CM: wf-clsmap CM}
    true.

%worlds () (false-implies-wf-clsmap _ _ _).
%total { } (false-implies-wf-clsmap _ _ _).


%theorem wf-clsmap-respects-eq
  : forall* {CM} {CM'}
    forall {WF-CM: wf-clsmap CM}
    {E: clsmap`eq CM CM'}
    exists {WF-CM': wf-clsmap CM'}
    true.

- : wf-clsmap-respects-eq WF-CM clsmap`eq/ WF-CM.

%worlds () (wf-clsmap-respects-eq _ _ _).
%total { } (wf-clsmap-respects-eq _ _ _).


%theorem wf-clsmap/U-inversion
  : forall* {CM} {CMP} {N} {FM}
    forall {WF: wf-clsmap CM}
    {F: clsmap`fresh CMP N}
    {U: clsmap`update CMP N FM CM}
    exists {K} {WFP: wf-clsmap CMP}
    {WFFM: wf-fldmap FM}
    {SZ: fldmap`size FM (s K)}
    true.

%theorem wf-clsmap/U-inversion/L
  : forall* {CM} {CMP} {N} {FM}
    {CM1} {N1} {FM1} {P} {K1}
    forall {WF: wf-clsmap CM1}
    {F1: clsmap`fresh CM1 N1}
    {U1: clsmap`update CM1 N1 FM1 CM}
    {WFFM: wf-fldmap FM1}
    {SZ: fldmap`size FM1 (s K1)}
    {F: clsmap`fresh CMP N}
    {U: clsmap`update CMP N FM CM}
    {E?: nat`eq? N N1 P}
    exists {K} {WFCM: wf-clsmap CMP}
    {WFFM: wf-fldmap FM}
    {SZ: fldmap`size FM (s K)}
    true.

- : wf-clsmap/U-inversion/L WF1 F1 U1 WFF1 SZ F2 U2 nat`eq?/yes _ WF WFF SZ2
    <- clsmap`fresh-update-cancels F1 U1 F2 U2 nat`eq/ clsmap`eq/ FME CME
    <- wf-clsmap-respects-eq WF1 CME WF
    <- wf-fldmap-respects-eq WFF1 FME WFF
    <- fldmap`size-respects-eq SZ FME nat`eq/ SZ2.

- : wf-clsmap/U-inversion/L WF1 F1 U1 WFF1 SZ F2 U2 (nat`eq?/no N<>N0) _
    (wf-clsmap/U WF WFF1 SZ F4 U4) WFF SZ'
    <- clsmap`update-commutes-converse U2 U1 N<>N0 _ U4 U3
    <- clsmap`update-preserves-fresh-converse F2 U4 F3
    <- clsmap`update-preserves-fresh-converse F1 U3 F4
    <- wf-clsmap/U-inversion WF1 F3 U3 _ WF WFF SZ'.

- : wf-clsmap/U-inversion (wf-clsmap/U WF1 WFF1 SZ1 F1 U1) F2 U2 _ WF WFF SZ
    <- nat`eq?-total E?
    <- wf-clsmap/U-inversion/L WF1 F1 U1 WFF1 SZ1 F2 U2 E? _ WF WFF SZ.

%worlds (objvar) (wf-clsmap/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _)
  (wf-clsmap/U-inversion _ _ _ _ _ _ _).
%total (W W0)
 (wf-clsmap/U-inversion W0 _ _ _ _ _ _)
 (wf-clsmap/U-inversion/L W _ _ _ _ _ _ _ _ _ _ _).


%theorem wf-clsmap-lookup-implies-wf-fldmap
  : forall* {CM} {C} {FM}
    forall {WF-CM: wf-clsmap CM}
    {CML: clsmap`lookup CM C FM}
    exists {WF-FM: wf-fldmap FM}
    true.

- : wf-clsmap-lookup-implies-wf-fldmap WF-CM CML WF-FM
    <- clsmap`lookup-implies-fresh-update CML _ F U
    <- wf-clsmap/U-inversion WF-CM F U _ _ WF-FM SZ.

%worlds () (wf-clsmap-lookup-implies-wf-fldmap _ _ _).
%total { } (wf-clsmap-lookup-implies-wf-fldmap _ _ _).


%theorem wf-clsmap-lookup-implies-non-empty
  : forall* {CM} {C} {FM}
    forall {WF-CM: wf-clsmap CM}
    {CML: clsmap`lookup CM C FM}
    exists {K} {SZ: fldmap`size FM (s K)}
    true.

- : wf-clsmap-lookup-implies-non-empty WF-CM CML _ SZ
    <- clsmap`lookup-implies-fresh-update CML _ F U
    <- wf-clsmap/U-inversion WF-CM F U _ _ _ SZ.

%worlds () (wf-clsmap-lookup-implies-non-empty _ _ _ _).
%total { } (wf-clsmap-lookup-implies-non-empty _ _ _ _).


%theorem clsmap-ty-respects-eq
  : forall* {CM1} {CM2} {T1} {T2}
    forall {CM1-T1: clsmap-ty CM1 T1}
    {E: clsmap`eq CM1 CM2} {E: ty`eq T1 T2}
    exists {CM2-T2: clsmap-ty CM2 T2}
    true.

- : clsmap-ty-respects-eq D clsmap`eq/ ty`eq/ D.

%worlds (objvar) (clsmap-ty-respects-eq _ _ _ _).
%total {} (clsmap-ty-respects-eq _ _ _ _).


%theorem clsmap-ty-respects-leq
  : forall* {CM0} {CM1} {T}
    forall {CM0-T: clsmap-ty CM0 T}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-T: clsmap-ty CM1 T}
    true.

- : clsmap-ty-respects-leq (clsmap-ty/ L0)
    CM0<=CM1 (clsmap-ty/ L1)
    <- clsmap`lookup-respects-leq L0 CM0<=CM1 _ L1 _.

% - : clsmap-ty-respects-leq clsmap-ty/null _ clsmap-ty/null.

%worlds (objvar) (clsmap-ty-respects-leq _ _ _).
%total {} (clsmap-ty-respects-leq _ _ _).


%theorem clsmap-fldmap-respects-leq
  : forall* {CM0} {CM1} {FM}
    forall {CM0-FM: clsmap-fldmap CM0 FM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-FM: clsmap-fldmap CM1 FM}
    true.

- : clsmap-fldmap-respects-leq clsmap-fldmap/0 _ clsmap-fldmap/0.

- : clsmap-fldmap-respects-leq (clsmap-fldmap/+ CM0-FM CM0-T)
    CM0<=CM1 (clsmap-fldmap/+ CM1-FM CM1-T)
    <- clsmap-ty-respects-leq CM0-T CM0<=CM1 CM1-T
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM.

%worlds (objvar) (clsmap-fldmap-respects-leq _ _ _).
%total (CM-FM) (clsmap-fldmap-respects-leq CM-FM _ _).


%theorem clsmap-clsmap-respects-leq
  : forall* {CM0} {CM1} {CM}
    forall {CM0-CM: clsmap-clsmap CM0 CM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-CM: clsmap-clsmap CM1 CM}
    true.

- : clsmap-clsmap-respects-leq clsmap-clsmap/0 _ clsmap-clsmap/0.

- : clsmap-clsmap-respects-leq (clsmap-clsmap/+ CM0-CMS SH CM0-FM CM0-L)
    CM0<=CM1 (clsmap-clsmap/+ CM1-CMS SH CM1-FM CM1-L)
    <- clsmap`lookup-respects-leq CM0-L CM0<=CM1 _ CM1-LP EQ
    <- fldmap`eq-symmetric EQ EQP
    <- clsmap`lookup-respects-eq CM1-LP clsmap`eq/ nat`eq/ EQP CM1-L
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM
    <- clsmap-clsmap-respects-leq CM0-CMS CM0<=CM1 CM1-CMS.

%worlds (objvar) (clsmap-clsmap-respects-leq _ _ _).
%total (CM-CM) (clsmap-clsmap-respects-leq CM-CM _ _).


%theorem shift-preserves-clsmap-fldmap
  : forall* {CM} {FM} {FMP} {N}
    forall {CM-FM: clsmap-fldmap CM FM}
    {SH: fldmap`shift N FM FMP}
    exists {CM-FM: clsmap-fldmap CM FMP}
    true.

- : shift-preserves-clsmap-fldmap clsmap-fldmap/0 _ clsmap-fldmap/0.

- : shift-preserves-clsmap-fldmap
    (clsmap-fldmap/+ CM-FM CM-T) SH (clsmap-fldmap/+ CM-FM CM-T).

%worlds (objvar) (shift-preserves-clsmap-fldmap _ _ _).
%total {} (shift-preserves-clsmap-fldmap _ _ _).


%{ This theorem says if under a "bigger" clsmap CM0, CM
 is well-defined, and class C in CM has fldmap FM, then all
 classes in FM is well-defined under CM0 }%

%theorem lookup-implies-clsmap-fldmap
  : forall* {M} {CM} {FM} {C}
    forall {M-CM: clsmap-clsmap M CM}
    {L: clsmap`lookup CM C FM}
    exists {M-FM: clsmap-fldmap M FM}
    true.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ _ _ M-FM _)
     (clsmap`lookup/= _) M-FM.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ M-CMP SH _ _)
     (clsmap`lookup/> L P0) M-FM
     <- nat`plus-swap-succ P0 P1
     <- nat`plus-commutative P1 P2
     <- clsmap`shift-preserves-lookup* L SH P2 L2
     <- lookup-implies-clsmap-fldmap M-CMP L2 M-FM.

%worlds (objvar) (lookup-implies-clsmap-fldmap _ _ _).
%total (M-CM) (lookup-implies-clsmap-fldmap M-CM _ _).


%theorem clsmap-fldmap/U-inversion
  : forall* {CM} {FM} {FM'} {T} {F}
    forall {CM-FM: clsmap-fldmap CM FM}
    {FS: fldmap`fresh FM' F}
    {UD: fldmap`update FM' F T FM}
    exists {CM-T: clsmap-ty CM T}
    {CM-FM: clsmap-fldmap CM FM'}
    true.

%worlds (objvar) (clsmap-fldmap/U-inversion _ _ _ _ _).
%trustme %total { } (clsmap-fldmap/U-inversion _ _ _ _ _).


%theorem lookup-implies-clsmap-ty
  : forall* {CM} {FM} {F} {T}
    forall {CM-FM: clsmap-fldmap CM FM}
    {FM-L: fldmap`lookup FM F T}
    exists {CM-NT: clsmap-ty CM T}
    true.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM CM-T)
    (fldmap`lookup/= _) CM-T.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM _)
    (fldmap`lookup/> LP _) CM-T
    <- lookup-implies-clsmap-ty CM-FM LP CM-T.

%worlds (objvar) (lookup-implies-clsmap-ty _ _ _).
%total (CM-FM) (lookup-implies-clsmap-ty CM-FM _ _).


%theorem lookup-implies-clsmap-methty
  : forall* {CM} {MM} {MT} {M}
    forall {CM-MM: clsmap-methmap CM MM}
    {MM-LP: methmap`lookup MM M MT}
    exists {CM-MT: clsmap-methty CM MT}
    true.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth _ _ CM-MT _) (methmap`lookup/= _) CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const _ _ (CM-MT) CML) (methmap`lookup/= _)
     (clsmap-methty/args CM-MT (clsmap-ty/ CML)).

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

%worlds (objvar) (lookup-implies-clsmap-methty _ _ _).
%total (L) (lookup-implies-clsmap-methty L _ _).


%%% clsmap-cxt

%theorem false-implies-clsmap-cxt
  : forall* {CM} {B}
    forall {V:void}
    exists {CM-B: clsmap-cxt CM B}
    true.

%worlds (objvar) (false-implies-clsmap-cxt _ _).
%total { } (false-implies-clsmap-cxt _ _).


%theorem clsmap-cxt/U-inversion
  : forall* {CM} {B} {B'} {N} {O} {T}
    forall {CM-B: clsmap-cxt CM B}
    {N!<B: cxt`fresh B' N}
    {B'+N=B: cxt`update B' N (cxt-info/ O T) B}
    exists {CM-B': clsmap-cxt CM B'}
    {CM-T: clsmap-ty CM T}
    true.

%worlds () (clsmap-cxt/U-inversion _ _ _ _ _).
%trustme %total { } (clsmap-cxt/U-inversion _ _ _ _ _).


%theorem clsmap-cxt-respects-fresh-update-converse
  : forall* {CM} {B} {B'} {N} {CI}
    forall {CM-B: clsmap-cxt CM B}
    {N!<B': cxt`fresh B' N}
    {B'+N=B: cxt`update B' N CI B}
    exists {CM-B': clsmap-cxt CM B'}
    true.

%worlds () (clsmap-cxt-respects-fresh-update-converse _ _ _ _).
%trustme %total { } (clsmap-cxt-respects-fresh-update-converse _ _ _ _).


%theorem cxt-lookup-implies-clsmap-ty
  : forall* {CM} {B} {T} {O} {N}
    forall {CM-B: clsmap-cxt CM B}
    {B-L: cxt`lookup B N (cxt-info/ O T)}
    exists {CM-T: clsmap-ty CM T}
    true.

%theorem cxt-lookup-implies-clsmap-ty/L
  : forall* {CM} {B} {B'} {T} {O} {T'} {O'} {N} {N'} {K}
    forall {CM-B: clsmap-cxt CM B'}
    {CM-T: clsmap-ty CM T'}
    {U: cxt`update B' N' (cxt-info/ O' T') B}
    {BL: cxt`lookup B N (cxt-info/ O T)}
    {EQ?: nat`eq? N N' K}
    exists {CM-T: clsmap-ty CM T}
    true.

- : cxt-lookup-implies-clsmap-ty/L CM-B' CM-T' U BL nat`eq?/yes CM-T
    <- cxt`update-implies-lookup U BL'
    <- cxt`lookup-unique BL' BL cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE _ TE
    <- clsmap-ty-respects-eq CM-T' clsmap`eq/ TE CM-T.

- : cxt-lookup-implies-clsmap-ty/L CM-B' CM-T' U BL
    (nat`eq?/no (N<>N':nat`ne N N')) CM-T
    <- cxt`update-preserves-lookup-converse BL U N<>N' BL'
    <- cxt-lookup-implies-clsmap-ty CM-B' BL' CM-T.

- : cxt-lookup-implies-clsmap-ty (clsmap-cxt/U CM-B' CM-T' F U) BL CM-T
    <- nat`eq?-total EQ?
    <- cxt-lookup-implies-clsmap-ty/L CM-B' CM-T' U BL EQ? CM-T.

%worlds (objvar) (cxt-lookup-implies-clsmap-ty _ _ _)
  (cxt-lookup-implies-clsmap-ty/L _ _ _ _ _ _).
%total (CM-B CM-B') (cxt-lookup-implies-clsmap-ty CM-B _ _)
  (cxt-lookup-implies-clsmap-ty/L CM-B' _ _ _ _ _).


%theorem cxt-lookup-obj-implies-clsmap-ty
  : forall* {CM} {B} {T} {N} {O}
    forall {CM-B: clsmap-cxt CM B}
    {B-L: cxt`lookup-obj B O N T}
    exists {CM-T: clsmap-ty CM T}
    true.

- : cxt-lookup-obj-implies-clsmap-ty CM-B (cxt`lookup-obj/ BL) CM-T
    <- cxt-lookup-implies-clsmap-ty CM-B BL CM-T.

%worlds (objvar) (cxt-lookup-obj-implies-clsmap-ty _ _ _).
%total (CM-B) (cxt-lookup-obj-implies-clsmap-ty CM-B _ _).


%%% cxt-remove-unique-preserves-XX

%theorem cxt-remove-unique-preserves-clsmap-cxt-capmap
  : forall* {B0} {B1} {S} {CM} {M}
    forall {CM-B0-M: clsmap-cxt-capmap CM B0 M}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    exists {CM-B1-M: clsmap-cxt-capmap CM B1 M}
    true.

- : cxt-remove-unique-preserves-clsmap-cxt-capmap
    clsmap-cxt-capmap/0 B0-S=B1 clsmap-cxt-capmap/0.

- : cxt-remove-unique-preserves-clsmap-cxt-capmap
    (clsmap-cxt-capmap/U CM-B0-M' N+F=>K B0-L CML FML K!<M' M'+K=M) B0-S=B1
    (clsmap-cxt-capmap/U CM-B1-M' N+F=>K B1-L CML FML K!<M' M'+K=M)
    <- cxt-remove-unique-preserves-clsmap-cxt-capmap CM-B0-M' B0-S=B1 CM-B1-M'
    <- cxt-remove-unique-preserves-lookup-info B0-L B0-S=B1 _ B1-L.

- : cxt-remove-unique-preserves-clsmap-cxt-capmap
    (clsmap-cxt-capmap/z CM-B0-M' K!<M' M'+K=M) B0-S=B1
    (clsmap-cxt-capmap/z CM-B1-M' K!<M' M'+K=M)
    <- cxt-remove-unique-preserves-clsmap-cxt-capmap CM-B0-M' B0-S=B1 CM-B1-M'.

%worlds (objvar) (cxt-remove-unique-preserves-clsmap-cxt-capmap _ _ _).
%total (A) (cxt-remove-unique-preserves-clsmap-cxt-capmap A _ _).


%theorem cxt-remove-unique-preserves-clsmap-cxt
  : forall* {CM} {B0} {S} {B1}
    forall {CM-B0: clsmap-cxt CM B0}
    {B0-B1=B2: cxt-remove-unique B0 S B1}
    exists {CM-B2: clsmap-cxt CM B1}
    true.

%theorem cxt-remove-unique-preserves-clsmap-cxt/L1
  : forall* {B} {N} {CI}
    forall {SZ: cxt`size B nat`z}
    {L: cxt`lookup B N CI}
    exists {V: void}
    true.

%worlds (objvar) (cxt-remove-unique-preserves-clsmap-cxt/L1 _ _ _).
%total { } (cxt-remove-unique-preserves-clsmap-cxt/L1 _ _ _).


%theorem cxt-remove-unique-preserves-clsmap-cxt/L2
  : forall* {B} {CM}
    forall {SZ: cxt`size B nat`z}
    exists {CM-B: clsmap-cxt CM B}
    true.

- : cxt-remove-unique-preserves-clsmap-cxt/L2 cxt`size/0 clsmap-cxt/0.

%worlds (objvar) (cxt-remove-unique-preserves-clsmap-cxt/L2 _ _).
%total { } (cxt-remove-unique-preserves-clsmap-cxt/L2 _ _).


- : cxt-remove-unique-preserves-clsmap-cxt clsmap-cxt/0 cxt-remove-unique/0 clsmap-cxt/0.

- : cxt-remove-unique-preserves-clsmap-cxt
    (clsmap-cxt/U CM-B0' (clsmap-ty/ CML) N!<B0'
      (B0'+N=B0:cxt`update B0' N _ B0)) B0-S=B1
    (clsmap-cxt/U CM-B1' (clsmap-ty/ CML) N!<B1' B1'+N=B1)
    <- cxt`update-implies-lookup B0'+N=B0 B0->N
    <- cxt-remove-unique-preserves-lookup-info B0->N B0-S=B1 _ B1->N
    <- cxt-remove-unique-preserves-fresh-update B0-S=B1 N!<B0' B0'+N=B0
      CI B1' N!<B1' B1'+N=B1 B0'-S=B1'
    <- cxt-remove-unique-preserves-clsmap-cxt CM-B0' B0'-S=B1' CM-B1'.

- : cxt-remove-unique-preserves-clsmap-cxt
    clsmap-cxt/0 (cxt-remove-unique/U/in B0-S=B1 B1-L _ _ _) CM-B2
    <- cxt-remove-unique-preserves-size cxt`size/0 B0-S=B1 SZ-B1
    <- cxt-remove-unique-preserves-clsmap-cxt/L1 SZ-B1 B1-L V
    <- false-implies-clsmap-cxt V CM-B2.

- : cxt-remove-unique-preserves-clsmap-cxt
    clsmap-cxt/0 (cxt-remove-unique/U/out B0-S=B1 _ _ _) CM-B1
    <- cxt-remove-unique-preserves-size cxt`size/0 B0-S=B1 SZ-B1
    <- cxt-remove-unique-preserves-clsmap-cxt/L2 SZ-B1 CM-B1.

%worlds (objvar) (cxt-remove-unique-preserves-clsmap-cxt _ _ _).
%total (CM-B) (cxt-remove-unique-preserves-clsmap-cxt CM-B _ _).


%theorem cxt-remove-unique-preserves-cxt-unique-objset
  : forall* {NN} {C} {B0} {B1} {S} {R}
    forall {B0-S: cxt-unique-objset B0 NN C S}
    {B0-S=B1: cxt-remove-unique B0 R B1}
    exists {B1-S: cxt-unique-objset B1 NN C S}
    true.

- : cxt-remove-unique-preserves-cxt-unique-objset
    cxt-unique-objset/0 _ cxt-unique-objset/0.

- : cxt-remove-unique-preserves-cxt-unique-objset
    (cxt-unique-objset/U B0-S' B0-L UA0 LE N!<S' S'+N=S) B0-R=B1
    (cxt-unique-objset/U B1-S' B1-L UA1 LE N!<S' S'+N=S)
    <- cxt-remove-unique-preserves-cxt-unique-objset B0-S' B0-R=B1 B1-S'
    <- cxt-remove-unique-preserves-unique-or-borrow B0-L UA0 B0-R=B1 _ B1-L UA1.

%worlds (objvar) (cxt-remove-unique-preserves-cxt-unique-objset _ _ _).
%total (A) (cxt-remove-unique-preserves-cxt-unique-objset A _ _).


%%% same-class

%theorem same-class-respects-eq
  : forall* {B} {BP} {S} {SP} {C} {CP}
    forall {SOC: same-class B S C}
    {E: cxt`eq B BP} {E: set`eq S SP}
    {E: nat`eq C CP}
    exists {SOC: same-class BP SP CP}
    true.

- : same-class-respects-eq SOC cxt`eq/ set`eq/ nat`eq/ SOC.

%worlds (objvar) (same-class-respects-eq _ _ _ _ _).
%total {} (same-class-respects-eq _ _ _ _ _).


%theorem clsmap-cxt-capmap-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {S1} {S2}
    forall {CM1-B1-S1: clsmap-cxt-capmap CM1 B1 S1}
    {EQ: clsmap`eq CM1 CM2} {EQ: cxt`eq B1 B2} {EQ: capmap`eq S1 S2}
    exists {CM2-B2-S2: clsmap-cxt-capmap CM2 B2 S2}
    true.

- : clsmap-cxt-capmap-respects-eq A clsmap`eq/ cxt`eq/ capmap`eq/ A.

%worlds (objvar) (clsmap-cxt-capmap-respects-eq _ _ _ _ _).
%total {} (clsmap-cxt-capmap-respects-eq _ _ _ _ _).


%%% For let x = E in F, we need to find associated targets for E
%%% (bindings, capabilities) and replace them with the new variable x

%theorem cxt-fresh-update-preserves-clsmap-cxt-capmap
  : forall* {CM} {B} {BP} {N} {CI} {M}
    forall {CM-M: clsmap-cxt-capmap CM B M}
    {BF: cxt`fresh B N}
    {BU: cxt`update B N CI BP}
    exists {CM-M: clsmap-cxt-capmap CM BP M}
    true.

- : cxt-fresh-update-preserves-clsmap-cxt-capmap clsmap-cxt-capmap/0 _ _ clsmap-cxt-capmap/0.

- : cxt-fresh-update-preserves-clsmap-cxt-capmap
    (clsmap-cxt-capmap/U (CM-B-M':clsmap-cxt-capmap CM B M')
      (N0+F=>K:pair2nat (pair/ N0 F) (s K)) BL CML FML K!<M' M'+K=M)
    (N!<B:cxt`fresh B N) (B+N+CI=BP:cxt`update B N _ BP)
    (clsmap-cxt-capmap/U CM-BP-M' N0+F=>K BPL CML FML K!<M' M'+K=M)
    <- cxt-fresh-update-preserves-clsmap-cxt-capmap CM-B-M' N!<B B+N+CI=BP CM-BP-M'
    <- cxt`fresh-update-preserves-lookup BL N!<B B+N+CI=BP BPL.

- : cxt-fresh-update-preserves-clsmap-cxt-capmap
    (clsmap-cxt-capmap/z (CM-B-M':clsmap-cxt-capmap CM B M')
      K!<M' M'+K=M)
    (N!<B:cxt`fresh B N) (B+N+CI=BP:cxt`update B N _ BP)
    (clsmap-cxt-capmap/z CM-BP-M' K!<M' M'+K=M)
    <- cxt-fresh-update-preserves-clsmap-cxt-capmap CM-B-M' N!<B B+N+CI=BP CM-BP-M'.

%worlds (objvar) (cxt-fresh-update-preserves-clsmap-cxt-capmap _ _ _ _).
%total (CM-M) (cxt-fresh-update-preserves-clsmap-cxt-capmap CM-M _ _ _).


%theorem clsmap-cxt-objset-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {S1} {S2}
    forall {CM1-B1-S1: clsmap-cxt-objset CM1 B1 S1}
    {EQ: clsmap`eq CM1 CM2}
    {EQ: cxt`eq B1 B2} {EQ: set`eq S1 S2}
    exists {CM2-B2-S2: clsmap-cxt-objset CM2 B2 S2}
    true.

- : clsmap-cxt-objset-respects-eq A clsmap`eq/ cxt`eq/ set`eq/ A.

%worlds (objvar) (clsmap-cxt-objset-respects-eq _ _ _ _ _).
%total {} (clsmap-cxt-objset-respects-eq _ _ _ _ _).


%theorem same-class/U-inversion
  : forall* {B} {S} {SP} {C} {N}
    forall {SOC: same-class B S C}
    {NM: set`not-member SP (s N)}
    {AD: set`add SP (s N) S}
    exists {O} {NN} {A} {SOC: same-class B SP C}
    {BL: cxt`lookup B (s N) (cxt-info/ O (ty/ NN A C))}
    true.

%theorem same-class/U-inversion/L
  : forall* {B} {S} {SP1} {C} {N1} {A1} {NN1} {SP} {N} {P} {O1}
    forall {SOC: same-class B SP1 C}
    {NM1: set`not-member SP1 (s N1)}
    {AD1: set`add SP1 (s N1) S}
    {BL1: cxt`lookup B (s N1) (cxt-info/ O1 (ty/ NN1 A1 C))}
    {NM: set`not-member SP (s N)}
    {AD: set`add SP (s N) S}
    {EQ?: nat`eq? (s N) (s N1) P}
    exists {O} {NN} {A} {SOC: same-class B SP C}
    {BL: cxt`lookup B (s N) (cxt-info/ O (ty/ NN A C))}
    true.

- : same-class/U-inversion/L
    SOC0 F0 U0 BL0 F1 U1 nat`eq?/yes _ _ _ SOC1 BL0
    <- set`not-member-add-cancels F0 U0 F1 U1 nat`eq/ set`eq/ S0=S1
    <- same-class-respects-eq SOC0 cxt`eq/ S0=S1 nat`eq/ SOC1.

- : same-class/U-inversion/L
    SOC0 F0 U0 BL0 F1 U1 (nat`eq?/no N<>N1) _ _ _
    (same-class/U SOC2 F3 U3 BL0) BL2
    <- set`update-commutes-converse U1 U0 N<>N1 _ U3 U2
    <- set`add-preserves-not-member-converse F1 U3 F2
    <- set`add-preserves-not-member-converse F0 U2 F3
    <- same-class/U-inversion SOC0 F2 U2 _ _ _ SOC2 BL2.

- : same-class/U-inversion
    (same-class/U SOC0 F0 A0 BL0) F1 A1 _ _ _ SOC1 BL1
    <- nat`eq?-total E?
    <- same-class/U-inversion/L SOC0 F0 A0 BL0 F1 A1 E? _ _ _ SOC1 BL1.

%worlds (objvar) (same-class/U-inversion _ _ _ _ _ _ _ _)
	(same-class/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (same-class/U-inversion C0 _ _ _ _ _ _ _)
	(same-class/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _).


%%% Theorems about clsmap-cxt-capmap

%theorem false-implies-clsmap-cxt-capmap
  : forall* {CM} {B} {S} forall {F:void} exists {CBS: clsmap-cxt-capmap CM B S}
    true.

%worlds (objvar) (false-implies-clsmap-cxt-capmap _ _).
%total { } (false-implies-clsmap-cxt-capmap _ _).


%theorem clsmap-cxt-capmap/z-inversion
  : forall* {CM} {B} {S} {S'} {X}
    forall {CM-B-S: clsmap-cxt-capmap CM B S}
    {NM: capmap`fresh S' shared}
    {AD: capmap`update S' shared X S}
    exists {CM-B-S': clsmap-cxt-capmap CM B S'}
    true.

- : clsmap-cxt-capmap/z-inversion
    (clsmap-cxt-capmap/U CM-B-S N2P BL CML FML F1 U1) F U
    (clsmap-cxt-capmap/U CM-B-S2 N2P BL CML FML F3 U3)
    <- nat`succ-implies-gt-zero _ GT
    <- capmap`update-commutes-converse U U1 (nat`ne/< GT) M U3 U2
    <- capmap`update-preserves-fresh-converse F U3 F2
    <- capmap`update-preserves-fresh-converse F1 U2 F3
    <- clsmap-cxt-capmap/z-inversion CM-B-S F2 U2 CM-B-S2.

- : clsmap-cxt-capmap/z-inversion
    (clsmap-cxt-capmap/z CM-B-S F1 U1) F U CM-B-S'
    <- capmap`fresh-update-cancels F1 U1 F U nat`eq/ capmap`eq/ _ S1=S
    <- clsmap-cxt-capmap-respects-eq CM-B-S clsmap`eq/ cxt`eq/ S1=S CM-B-S'.

%worlds (objvar) (clsmap-cxt-capmap/z-inversion _ _ _ _).
%total (A) (clsmap-cxt-capmap/z-inversion A _ _ _).


%%% here K has to be a positive number, since nat`z is taken by shared.

%theorem clsmap-cxt-capmap/U-inversion
  : forall* {CM} {B} {S} {S'} {K} {X}
    forall {CM-B-S: clsmap-cxt-capmap CM B S}
    {NM: capmap`fresh S' (s K)}
    {AD: capmap`update S' (s K) X S}
    exists {CM-B-S': clsmap-cxt-capmap CM B S'}
    {N} {F} {N+F=>K: nat2pair (s K) (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    {T} {FML: fldmap`lookup FM F T}
    true.

- : clsmap-cxt-capmap/U-inversion
    (clsmap-cxt-capmap/z CM-B-S F1 U1) F U
    (clsmap-cxt-capmap/z CM-B-S2 F3 U3) _ _ N2P2 _ _ _ _ BL2 _ CML2 _ FML2
    <- nat`succ-implies-gt-zero _ GT
    <- capmap`update-commutes-converse U U1 (nat`ne/> GT) M U3 U2
    <- capmap`update-preserves-fresh-converse F U3 F2
    <- capmap`update-preserves-fresh-converse F1 U2 F3
    <- clsmap-cxt-capmap/U-inversion CM-B-S F2 U2 CM-B-S2
      _ _ N2P2 _ _ _ _ BL2 _ CML2 _ FML2.

%theorem clsmap-cxt-capmap/U-inversion/L
  : forall* {CM} {B} {S} {S'} {S1'} {K} {K1} {O1} {NN1}
    {A1} {C1} {FM1} {P} {N1} {F1} {T1} {X1} {X}
    forall {CM-B-S: clsmap-cxt-capmap CM B S1'}
    {NM1: capmap`fresh S1' (s K1)}
    {AD1: capmap`update S1' (s K1) X1 S}
    {K1=>N1+F1: nat2pair (s K1) (pair/ N1 F1)}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {CML1: clsmap`lookup CM C1 FM1}
    {FML1: fldmap`lookup FM1 F1 T1}
    {NM: capmap`fresh S' (s K)}
    {AD: capmap`update S' (s K) X S}
    {EQ?: nat`eq? (s K) (s K1) P}
    exists {CM-B-S': clsmap-cxt-capmap CM B S'}
    {N} {F} {K=>N+F: nat2pair (s K) (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    {T} {FML: fldmap`lookup FM F T}
    true.

- : clsmap-cxt-capmap/U-inversion/L CM-B-S F1 U1 N2P1 BL1 CML1 FML1 F U
    nat`eq?/yes CM-B-S' _ _ N2P1 _ _ _ _ BL1 _ CML1 _ FML1
    <- capmap`fresh-update-cancels F1 U1 F U nat`eq/ capmap`eq/ _ S1=S
    <- clsmap-cxt-capmap-respects-eq CM-B-S clsmap`eq/ cxt`eq/ S1=S CM-B-S'.

- : clsmap-cxt-capmap/U-inversion/L CM-B-S F1 U1 N2P BL CML FML
    F U (nat`eq?/no N<>N1) (clsmap-cxt-capmap/U CM-B-S2 N2P BL CML FML F3 U3)
    _ _ N2P2 _ _ _ _ BL2 _ CML2 _ FML2
    <- capmap`update-commutes-converse U U1 N<>N1 _ U3 U2
    <- capmap`update-preserves-fresh-converse F U3 F2
    <- capmap`update-preserves-fresh-converse F1 U2 F3
    <- clsmap-cxt-capmap/U-inversion CM-B-S F2 U2 CM-B-S2
      _ _ N2P2 _ _ _ _ BL2 _ CML2 _ FML2.

- : clsmap-cxt-capmap/U-inversion
    (clsmap-cxt-capmap/U CM-B-S0 N2P0 BL0 CML0 FML0 F0 U0) F1 U1
    CM-B-S1 _ _ N2P1 _ _ _ _ BL1 _ CML1 _ FML1
    <- nat`eq?-total E?
    <- clsmap-cxt-capmap/U-inversion/L CM-B-S0 F0 U0 N2P0 BL0 CML0 FML0
      F1 U1 E? CM-B-S1 _ _ N2P1 _ _ _ _ BL1 _ CML1 _ FML1.

%worlds (objvar) (clsmap-cxt-capmap/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-capmap/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (clsmap-cxt-capmap/U-inversion C0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-capmap/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem join-preserves-clsmap-cxt-capmap
  : forall* {CM} {B} {S1} {S2} {S}
    forall {CM-B-S1: clsmap-cxt-capmap CM B S1}
    {CM-B-S2: clsmap-cxt-capmap CM B S2}
    {J: capmap`join S1 S2 S}
    exists {CM-B-S: clsmap-cxt-capmap CM B S}
    true.

%theorem join-preserves-clsmap-cxt-capmap/L
  : forall* {CM} {B} {S1} {S2} {S}
    forall {N} {SZ: capmap`size S N}
    {CM-B-S1: clsmap-cxt-capmap CM B S1}
    {CM-B-S2: clsmap-cxt-capmap CM B S2}
    {J: capmap`join S1 S2 S}
    exists {CM-B-S: clsmap-cxt-capmap CM B S}
    true.

%theorem join-preserves-clsmap-cxt-capmap/LL
  : forall* {CM} {B} {S1} {S2} {S} {SP} {K} {B1} {B2} {X}
    forall {N} {SZ: capmap`size S N}
    {CM-B-S1: clsmap-cxt-capmap CM B S1}
    {CM-B-S2: clsmap-cxt-capmap CM B S2}
    {J: capmap`join S1 S2 S}
    {F: capmap`fresh SP K}
    {A: capmap`update SP K X S}
    {D1?: capmap`domain? S1 K B1}
    {D2?: capmap`domain? S2 K B2}
    exists {CM-B-S: clsmap-cxt-capmap CM B S}
    true.

- : join-preserves-clsmap-cxt-capmap/L
    _ capmap`size/0 clsmap-cxt-capmap/0 CBS capmap`join/L CBS.

- : join-preserves-clsmap-cxt-capmap/L
    _ capmap`size/0 CBS clsmap-cxt-capmap/0 capmap`join/R CBS.

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/in (L1:capmap`lookup S1 shared Xx1))
    (capmap`domain?/in (L2:capmap`lookup S2 shared Xx2))
    (clsmap-cxt-capmap/z CBSP F U)
    <- capmap`lookup-implies-fresh-update L1 S1P F1 U1
    <- capmap`lookup-implies-fresh-update L2 S2P F2 U2
    <- capmap`update-implies-lookup U (L:capmap`lookup S shared Xx)
    <- capmap`fresh-update-preserves-join-converse* F1 U1 F2 U2 SU F U DJ SUP
    <- clsmap-cxt-capmap/z-inversion CBS1 F1 U1 CBS1P
    <- clsmap-cxt-capmap/z-inversion CBS2 F2 U2 CBS2P
    <- capmap`fresh-update-increases-size-converse Z F U ZP
    <- join-preserves-clsmap-cxt-capmap/L _ ZP CBS1P CBS2P SUP CBSP.

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/in _) (capmap`domain?/out F2)
    (clsmap-cxt-capmap/z CBSP F U)
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-join-right-preserves-lookup-converse L F2 SU L1
    <- capmap`lookup-implies-fresh-update L1 _ F1 U1
    <- clsmap-cxt-capmap/z-inversion CBS1 F1 U1 CBS1P
    <- capmap`fresh-update-left-preserves-join-converse* F1 U1 F2 SU F U SU1
    <- capmap`fresh-update-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capmap/L _ Z1 CBS1P CBS2 SU1 CBSP.

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/out F1) (capmap`domain?/in _)
    (clsmap-cxt-capmap/z CBSP F U)
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-join-left-preserves-lookup-converse F1 L SU L2
    <- capmap`lookup-implies-fresh-update L2 _ F2 U2
    <- clsmap-cxt-capmap/z-inversion CBS2 F2 U2 CBS2P
    <- capmap`fresh-update-right-preserves-join-converse* F1 F2 U2 SU F U SU2
    <- capmap`fresh-update-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capmap/L _ Z1 CBS1 CBS2P SU2 CBSP.

- : join-preserves-clsmap-cxt-capmap/LL _ _ _ _ SU _ U
    (capmap`domain?/out F1) (capmap`domain?/out F2) %{=>}% CBS
    <- capmap`join-preserves-fresh* F1 F2 SU F
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-clsmap-cxt-capmap V CBS.

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/in (L1:capmap`lookup S1 (s K) Xx1))
    (capmap`domain?/in (L2:capmap`lookup S2 (s K) Xx2))
    (clsmap-cxt-capmap/U CBSP P2N2 BL2 CML2 FML2 F U)
    <- capmap`lookup-implies-fresh-update L1 S1P F1 U1
    <- capmap`lookup-implies-fresh-update L2 S2P F2 U2
    <- capmap`update-implies-lookup U (L:capmap`lookup S (s K) Xx)
    <- capmap`fresh-update-preserves-join-converse* F1 U1 F2 U2 SU F U DJ SUP
    <- clsmap-cxt-capmap/U-inversion CBS1 F1 U1
      CBS1P N1 FD1 P2N1 O1 NN1 A1 C1 BL1 FM1 CML1 T1 FML1
    <- clsmap-cxt-capmap/U-inversion CBS2 F2 U2
      CBS2P N2 FD2 P2N2 O2 NN2 A2 C2 BL2 FM2 CML2 T2 FML2
    <- capmap`fresh-update-increases-size-converse Z F U ZP
    <- join-preserves-clsmap-cxt-capmap/L _ ZP CBS1P CBS2P SUP CBSP.

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/in _) (capmap`domain?/out F2)
    (clsmap-cxt-capmap/U CBSP P2N1 BL1 CML1 FML1 F U)
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-join-right-preserves-lookup-converse L F2 SU L1
    <- capmap`lookup-implies-fresh-update L1 _ F1 U1
    <- clsmap-cxt-capmap/U-inversion
      CBS1 F1 U1 CBS1P _ _ P2N1 _ _ _ _ BL1 _ CML1 _ FML1
    <- capmap`fresh-update-left-preserves-join-converse* F1 U1 F2 SU F U SU1
    <- capmap`fresh-update-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capmap/L _ Z1 CBS1P CBS2 SU1 CBSP.

- : join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U
    (capmap`domain?/out F1) (capmap`domain?/in _) %{=>}%
    (clsmap-cxt-capmap/U CBSP P2N2 BL2 CML2 FML2 F U)
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-join-left-preserves-lookup-converse F1 L SU L2
    <- capmap`lookup-implies-fresh-update L2 _ F2 U2
    <- clsmap-cxt-capmap/U-inversion
      CBS2 F2 U2 CBS2P _ _ P2N2 _ _ _ _ BL2 _ CML2 _ FML2
    <- capmap`fresh-update-right-preserves-join-converse* F1 F2 U2 SU F U SU2
    <- capmap`fresh-update-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-capmap/L _ Z1 CBS1 CBS2P SU2 CBSP.

- : join-preserves-clsmap-cxt-capmap/LL _ _ _ _ SU _ U
    (capmap`domain?/out F1) (capmap`domain?/out F2) %{=>}% CBS
    <- capmap`join-preserves-fresh* F1 F2 SU F
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-clsmap-cxt-capmap V CBS.

- : join-preserves-clsmap-cxt-capmap/L (s N) Z CBS1 CBS2 SU CBS
    <- capmap`lookup-implies-fresh-update (capmap`lookup/= nat`eq/) _ F U
    <- capmap`domain?-total D1?
    <- capmap`domain?-total D2?
    <- join-preserves-clsmap-cxt-capmap/LL (s N) Z CBS1 CBS2 SU F U D1? D2? CBS.

%worlds (objvar) (join-preserves-clsmap-cxt-capmap/LL _ _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-capmap/L _ _ _ _ _ _).
%total (N1 N2) (join-preserves-clsmap-cxt-capmap/LL N1 _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-capmap/L N2 _ _ _ _ _).

- : join-preserves-clsmap-cxt-capmap CBS1 CBS2 U CBS
    <- capmap`size-total Z
    <- join-preserves-clsmap-cxt-capmap/L _ Z CBS1 CBS2 U CBS.

%worlds (objvar) (join-preserves-clsmap-cxt-capmap _ _ _ _).
%total {} (join-preserves-clsmap-cxt-capmap _ _ _ _).


%theorem clsmap-cxt-objset/U-inversion
  : forall* {CM} {B} {S} {S'} {N}
    forall {CM-B-S: clsmap-cxt-objset CM B S}
    {NM: set`not-member S' N}
    {AD: set`add S' N S}
    exists {CM-B-S': clsmap-cxt-objset CM B S'}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    true.

%theorem clsmap-cxt-objset/U-inversion/L
  : forall* {CM} {B} {S} {S'} {S1'} {N} {N1} {P} {O1} {NN1} {A1} {C1} {FM1}
    forall {CM-B-S: clsmap-cxt-objset CM B S1'}
    {NM1: set`not-member S1' N1}
    {AD1: set`add S1' N1 S}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {CML1: clsmap`lookup CM C1 FM1}
    {NM: set`not-member S' N}
    {AD: set`add S' N S}
    {EQ?: nat`eq? N N1 P}
    exists {CM-B-S': clsmap-cxt-objset CM B S'}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    true.

- : clsmap-cxt-objset/U-inversion/L CM-B-S F1 U1 BL1 CML1 F U
    nat`eq?/yes CM-B-S' _ _ _ _ BL1 _ CML1
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- clsmap-cxt-objset-respects-eq CM-B-S clsmap`eq/ cxt`eq/ S1=S CM-B-S'.

- : clsmap-cxt-objset/U-inversion/L CM-B-S F1 U1 BL CML
    F U (nat`eq?/no N<>N1) (clsmap-cxt-objset/U CM-B-S2 BL CML F3 U3)
    _ _ _ _ BL2 _ CML2
    <- set`add-commutes-converse U U1 N<>N1 _ U3 U2
    <- set`add-preserves-fresh-converse F U3 F2
    <- set`add-preserves-fresh-converse F1 U2 F3
    <- clsmap-cxt-objset/U-inversion CM-B-S F2 U2 CM-B-S2 _ _ _ _ BL2 _ CML2.

- : clsmap-cxt-objset/U-inversion
    (clsmap-cxt-objset/U CM-B-S0 BL0 CML F0 U0) F1 U1 CM-B-S1 _ _ _ _ BL1 _ CML1
    <- nat`eq?-total E?
    <- clsmap-cxt-objset/U-inversion/L CM-B-S0 F0 U0 BL0 CML
      F1 U1 E? CM-B-S1 _ _ _ _ BL1 _ CML1.

%worlds (objvar) (clsmap-cxt-objset/U-inversion _ _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-objset/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (clsmap-cxt-objset/U-inversion C0 _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-objset/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem cxt-unique-objset-respects-eq
  : forall* {B1} {B2} {S1} {S2} {NN1} {C1} {NN2} {C2}
    forall {B1-S1: cxt-unique-objset B1 NN1 C1 S1}
    {EQ: cxt`eq B1 B2} {EQ: set`eq S1 S2}
    {EQ: nonnull`eq NN1 NN2} {EQ: nat`eq C1 C2}
    exists {B2-S2: cxt-unique-objset B2 NN2 C2 S2}
    true.

- : cxt-unique-objset-respects-eq A cxt`eq/ set`eq/ nonnull`eq/ nat`eq/ A.

%worlds (objvar) (cxt-unique-objset-respects-eq _ _ _ _ _ _).
%total { } (cxt-unique-objset-respects-eq _ _ _ _ _ _).


%theorem cxt-unique-objset/U-inversion
  : forall* {B} {S} {S'} {N} {NN} {C}
    forall {B-S: cxt-unique-objset B NN C S}
    {NM: set`not-member S' (s N)}
    {AD: set`add S' (s N) S}
    exists {CM-B-S': cxt-unique-objset B NN C S'}
    {O} {A} {NN'} {BL: cxt`lookup B (s N) (cxt-info/ O (ty/ NN' A C))}
    {UA: unique-or-borrow A}
    {NN<=NN': nonnull`leq NN NN'}
    true.

%theorem cxt-unique-objset/U-inversion/L
  : forall* {B} {S} {S'} {S1'} {N} {N1} {P} {O1} {NN1} {C} {NN} {A1}
    forall {B-S: cxt-unique-objset B NN C S1'}
    {NM1: set`not-member S1' (s N1)}
    {AD1: set`add S1' (s N1) S}
    {BL1: cxt`lookup B (s N1) (cxt-info/ O1 (ty/ NN1 A1 C))}
    {UA1: unique-or-borrow A1}
    {NN<=NN1: nonnull`leq NN NN1}
    {NM: set`not-member S' (s N)}
    {AD: set`add S' (s N) S}
    {EQ?: nat`eq? (s N) (s N1) P}
    exists {CM-B-S': cxt-unique-objset B NN C S'}
    {O} {A} {NN'} {BL: cxt`lookup B (s N) (cxt-info/ O (ty/ NN' A C))}
    {UA: unique-or-borrow A}
    {NN<=NN': nonnull`leq NN NN'}
    true.

- : cxt-unique-objset/U-inversion/L B-S F1 U1 BL1 UA1 LE F U
    nat`eq?/yes B-S' _ _ _ BL1 UA1 LE
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- cxt-unique-objset-respects-eq B-S cxt`eq/ S1=S nonnull`eq/ nat`eq/ B-S'.

- : cxt-unique-objset/U-inversion/L B-S F1 U1
    (BL:cxt`lookup B (s N1) (cxt-info/ O1 (ty/ NN1 A1 C1))) UA1 (LE:nonnull`leq NN NN1)
    F U (nat`eq?/no N<>N1)
    (cxt-unique-objset/U B-S2 BL UA1 LE F3 U3) O A NN' BL2 UA2 LE2
    <- set`add-commutes-converse U U1 N<>N1 _ U3 U2
    <- set`add-preserves-fresh-converse F U3 F2
    <- set`add-preserves-fresh-converse F1 U2 F3
    <- cxt-unique-objset/U-inversion B-S F2 U2 B-S2 _ _ _ BL2 UA2 LE2.

- : cxt-unique-objset/U-inversion
    (cxt-unique-objset/U B-S0 BL0 UA0 LE F0 U0)
    F1 U1 B-S1 _ _ _ BL1 UA1 LE1
    <- nat`eq?-total E?
    <- cxt-unique-objset/U-inversion/L B-S0 F0 U0 BL0 UA0 LE
      F1 U1 E? B-S1 _ _ _ BL1 UA1 LE1.

%worlds (objvar) (cxt-unique-objset/U-inversion _ _ _ _ _ _ _ _ _ _)
	(cxt-unique-objset/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (cxt-unique-objset/U-inversion C0 _ _ _ _ _ _ _ _ _)
	(cxt-unique-objset/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


% backward-compatibility ...
%theorem cxt-unique-objset-implies-same-class
  : forall* {B} {NN} {C} {S}
    forall {B-S: cxt-unique-objset B NN C S}
    exists {S-C: same-class B S C}
    true.

- : cxt-unique-objset-implies-same-class cxt-unique-objset/0 same-class/0.

- : cxt-unique-objset-implies-same-class
    (cxt-unique-objset/U B-S' BL _ _ NM A)
    (same-class/U SOC' NM A BL)
    <- cxt-unique-objset-implies-same-class B-S' SOC'.

%worlds (objvar) (cxt-unique-objset-implies-same-class _ _).
%total (A) (cxt-unique-objset-implies-same-class A _).


%theorem cxt-unique-objset-implies-least-nonnull
  : forall* {B} {NN} {C} {S}
    forall {B-S: cxt-unique-objset B NN C S}
    exists {S-NN: least-nonnull B S NN}
    true.

- : cxt-unique-objset-implies-least-nonnull cxt-unique-objset/0 least-nonnull/0.

- : cxt-unique-objset-implies-least-nonnull
    (cxt-unique-objset/U B-S' BL _ LE NM A)
    (least-nonnull/U S'-NN NM A BL LE)
    <- cxt-unique-objset-implies-least-nonnull B-S' S'-NN.

%worlds (objvar) (cxt-unique-objset-implies-least-nonnull _ _).
%total (A) (cxt-unique-objset-implies-least-nonnull A _).


%theorem clsmap-cxt-capmap-respects-geq
  : forall* {S} {SP} {CM} {B}
    forall {B-SP: clsmap-cxt-capmap CM B SP}
    {S1<=S2: capmap`leq S SP}
    exists {B-S: clsmap-cxt-capmap CM B S}
    true.

- : clsmap-cxt-capmap-respects-geq
    clsmap-cxt-capmap/0 capmap`leq/0 clsmap-cxt-capmap/0.

%theorem clsmap-cxt-capmap-respects-geq/U
  : forall* {CM} {FM} {SS} {SP} {N} {B} {NN} {A} {C} {S} {K} {T} {F} {O} {X}
    forall {P} {IN?: capmap`domain? S (s K) P}
    {NM: capmap`fresh SS (s K)}
    {UD: capmap`update SS (s K) X SP}
    {NP: nat2pair (s K) (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    {B-SS: clsmap-cxt-capmap CM B SS}
    {S<=SP: capmap`leq S SP}
    exists {B-S: clsmap-cxt-capmap CM B S}
    true.

%theorem clsmap-cxt-capmap-respects-geq/z
  : forall* {S} {SS} {X} {CM} {SP} {B}
    forall {P} {IN?: capmap`domain? S shared P}
    {NM: capmap`fresh SS shared}
    {UD: capmap`update SS shared X SP}
    {B-SS: clsmap-cxt-capmap CM B SS}
    {S<=SP: capmap`leq S SP}
    exists {B-S: clsmap-cxt-capmap CM B S}
    true.

- : clsmap-cxt-capmap-respects-geq/z true (capmap`domain?/in N<-S)
    NM UD B-SS S<=SP (clsmap-cxt-capmap/z CM-B-ST N!<ST ADD)
    <- capmap`lookup-implies-fresh-update N<-S ST N!<ST ADD
    <- capmap`fresh-update-preserves-leq-converse S<=SP N!<ST ADD NM UD ST<=SS KK
    <- clsmap-cxt-capmap-respects-geq B-SS ST<=SS CM-B-ST.

- : clsmap-cxt-capmap-respects-geq/z false (capmap`domain?/out N!<S)
    NM UD B-SS S<=SP B-S
    <- capmap`fresh-update2-preserves-leq-converse S<=SP N!<S NM UD S<=SS
    <- clsmap-cxt-capmap-respects-geq B-SS S<=SS B-S.

- : clsmap-cxt-capmap-respects-geq/U true (capmap`domain?/in N<-S)
    NM UD NP BL CML FML B-SS S<=SP
    (clsmap-cxt-capmap/U CM-B-ST NP BL CML FML N!<ST ADD)
    <- capmap`lookup-implies-fresh-update N<-S ST N!<ST ADD
    <- capmap`fresh-update-preserves-leq-converse S<=SP N!<ST ADD NM UD ST<=SS KK
    <- clsmap-cxt-capmap-respects-geq B-SS ST<=SS CM-B-ST.

- : clsmap-cxt-capmap-respects-geq/U false (capmap`domain?/out N!<S)
    NM UD BL CML DM-FM=FS MPS<=FS B-SS S<=SP B-S
    <- capmap`fresh-update2-preserves-leq-converse S<=SP N!<S NM UD S<=SS
    <- clsmap-cxt-capmap-respects-geq B-SS S<=SS B-S.

- : clsmap-cxt-capmap-respects-geq
    (clsmap-cxt-capmap/z B-SS NM UD) S<=SP B-S
    <- capmap`domain?-total MB?
    <- clsmap-cxt-capmap-respects-geq/z _ MB? NM UD B-SS S<=SP B-S.

- : clsmap-cxt-capmap-respects-geq
    (clsmap-cxt-capmap/U B-SS NP BL CML FML NM UD) S<=SP B-S
    <- capmap`domain?-total MB?
    <- clsmap-cxt-capmap-respects-geq/U _ MB? NM UD NP BL CML FML B-SS S<=SP B-S.

%worlds (objvar) (clsmap-cxt-capmap-respects-geq _ _ _)
  (clsmap-cxt-capmap-respects-geq/U _ _ _ _ _ _ _ _ _ _ _)
  (clsmap-cxt-capmap-respects-geq/z _ _ _ _ _ _ _).
%total (L1 L2 L3) (clsmap-cxt-capmap-respects-geq L1 _ _)
	(clsmap-cxt-capmap-respects-geq/U _ _ _ _ _ _ _ _ L2 _ _)
  (clsmap-cxt-capmap-respects-geq/z _ _ _ _ L3 _ _).


%theorem clsmap-cxt-objset-respects-geq
  : forall* {S} {SP} {CM} {B}
    forall {B-SP: clsmap-cxt-objset CM B SP}
    {S1<=S2: set`leq S SP}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : clsmap-cxt-objset-respects-geq clsmap-cxt-objset/0 set`leq/0 clsmap-cxt-objset/0.

%theorem clsmap-cxt-objset-respects-geq/U
  : forall* {CM} {SS} {SP} {N} {B} {NN} {A} {C} {S} {O} {FM}
    forall {P} {IN?: set`member? S N P}
    {NM: set`not-member SS N}
    {UD: set`add SS N SP}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {B-SS: clsmap-cxt-objset CM B SS}
    {S<=SP: set`leq S SP}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : clsmap-cxt-objset-respects-geq/U true (set`member?/in N<-S)
    NM UD BL CML B-SS S<=SP
    (clsmap-cxt-objset/U CM-B-ST BL CML N!<ST ADD)
    <- set`member-implies-not-member-add N<-S ST N!<ST ADD
    <- set`not-member-add-preserves-leq-converse S<=SP N!<ST ADD NM UD ST<=SS
    <- clsmap-cxt-objset-respects-geq B-SS ST<=SS CM-B-ST.

- : clsmap-cxt-objset-respects-geq/U false (set`domain?/out N!<S)
    NM UD BL CML B-SS S<=SP B-S
    <- set`not-member-update2-preserves-leq-converse S<=SP N!<S NM UD S<=SS
    <- clsmap-cxt-objset-respects-geq B-SS S<=SS B-S.

- : clsmap-cxt-objset-respects-geq
    (clsmap-cxt-objset/U B-SS BL CML NM UD) S<=SP B-S
    <- set`domain?-total MB?
    <- clsmap-cxt-objset-respects-geq/U
      _ MB? NM UD BL CML B-SS S<=SP B-S.

%worlds (objvar) (clsmap-cxt-objset-respects-geq _ _ _)
	(clsmap-cxt-objset-respects-geq/U _ _ _ _ _ _ _ _ _).
%total (L1 L2) (clsmap-cxt-objset-respects-geq L1 _ _)
	(clsmap-cxt-objset-respects-geq/U _ _ _ _ _ _ L2 _ _).


%%% N has to be a positive number, representing a non-world object.

%theorem nat+set2capmap-implies-clsmap-cxt-capmap*
  : forall* {N} {FS} {X} {M} {CM} {C} {FM} {B} {O} {NN} {A} {FS0}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM=FS: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    {N+FS=>M: nat+set2capmap N FS X M}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {GT: nat`gt N z}
    exists {CM-B-M: clsmap-cxt-capmap CM B M}
    true.

- : nat+set2capmap-implies-clsmap-cxt-capmap*
    _ CML FM-DM _ nat+set2capmap/0 BL _ clsmap-cxt-capmap/0.

- : nat+set2capmap-implies-clsmap-cxt-capmap* CM-CM
    CML FM-DM=FS0 (FS<=FS0:set`leq FS FS0)
    (nat+set2capmap/U N+FS'=>M' (N+F=>K:pair2nat (pair/ N F) z) F!<FS' FS'+F=FS M'+K+X=M)
    BL (GT:nat`gt N z) CM-B-M
    <- nat2pair-deterministic/0 N+F=>K P=Z
    <- pair-eq-implies-eq P=Z N=Z F=Z
    <- nat`gt-respects-eq GT N=Z nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N V
    <- false-implies-clsmap-cxt-capmap V CM-B-M.

- : nat+set2capmap-implies-clsmap-cxt-capmap* CM-CM
    CML FM-DM=FS0 (FS<=FS0:set`leq FS FS0)
    (nat+set2capmap/U N+FS'=>M' N+F=>K F!<FS' FS'+F=FS M'+K+X=M)
    BL GT (clsmap-cxt-capmap/U CM-B-M' N+F=>K BL CML FML K!<M' M'+K+X=M)
    <- set`add-implies-member FS'+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
    <- fldmap`domain-preserves-lookup-converse F<-FS0 FM-DM=FS0 _ FML
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-T
    <- nat+set2capmap-preserves-fresh N+FS'=>M' F!<FS' N+F=>K K!<M'
    <- set`add-implies-leq FS'+F=FS FS'<=FS
    <- set`leq-transitive FS'<=FS FS<=FS0 FS'<=FS0
    <- nat+set2capmap-implies-clsmap-cxt-capmap*
      CM-CM CML FM-DM=FS0 FS'<=FS0 N+FS'=>M' BL GT CM-B-M'.

%worlds (objvar) (nat+set2capmap-implies-clsmap-cxt-capmap* _ _ _ _ _ _ _ _).
%total (A) (nat+set2capmap-implies-clsmap-cxt-capmap* _ _ _ _ A _ _ _).


%theorem nat+set2capmap-implies-clsmap-cxt-capmap
  : forall* {N} {FS} {X} {M} {CM} {C} {FM} {B} {O} {NN} {A}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM=FS: fldmap`domain FM FS}
    {N+FS=>M: nat+set2capmap N FS X M}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {N>0: nat`gt N z}
    exists {CM-B-M: clsmap-cxt-capmap CM B M}
    true.

- : nat+set2capmap-implies-clsmap-cxt-capmap CM-CM
    CML FM-DM=FS N+FS=>M BL N>0 CM-B-M
    <- set`leq-reflexive _ FS<=FS
    <- nat+set2capmap-implies-clsmap-cxt-capmap* CM-CM
      CML FM-DM=FS FS<=FS N+FS=>M BL N>0 CM-B-M.

%worlds (objvar) (nat+set2capmap-implies-clsmap-cxt-capmap _ _ _ _ _ _ _).
%total { } (nat+set2capmap-implies-clsmap-cxt-capmap _ _ _ _ _ _ _).


%theorem false-implies-clsmap-cxt-objset
  : forall* {CM} {B} {S}
    forall {F:void} exists {CBS2: clsmap-cxt-objset CM B S}
    true.

%worlds (objvar) (false-implies-clsmap-cxt-objset _ _).
%total { } (false-implies-clsmap-cxt-objset _ _).


%theorem join-preserves-clsmap-cxt-objset
  : forall* {CM} {B} {S1} {S2} {S}
    forall {B-S1: clsmap-cxt-objset CM B S1}
    {B-S2: clsmap-cxt-objset CM B S2}
    {J: set`union S1 S2 S}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

%theorem join-preserves-clsmap-cxt-objset/L
  : forall* {CM} {B} {S1} {S2} {S}
    forall {N} {SZ: set`size S N}
    {B-S1: clsmap-cxt-objset CM B S1}
    {B-S2: clsmap-cxt-objset CM B S2}
    {J: set`union S1 S2 S}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : join-preserves-clsmap-cxt-objset/L
    _ set`size/0 clsmap-cxt-objset/0 CBS set`union/L CBS.

- : join-preserves-clsmap-cxt-objset/L
    _ set`size/0 CBS clsmap-cxt-objset/0 set`union/R CBS.

%theorem join-preserves-clsmap-cxt-objset/LL
  : forall* {CM} {B} {S1} {S2} {S} {SP} {K} {B1} {B2}
    forall {N} {SZ: set`size S N}
    {B-S1: clsmap-cxt-objset CM B S1}
    {B-S2: clsmap-cxt-objset CM B S2}
    {J: set`union S1 S2 S}
    {F: set`not-member SP K}
    {A: set`add SP K S}
    {D1?: set`domain? S1 K B1}
    {D2?: set`domain? S2 K B2}
    exists {B-S: clsmap-cxt-objset CM B S}
    true.

- : join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U
    (set`domain?/in (L1:set`lookup S1 K unit/)) (set`domain?/in L2)
    (clsmap-cxt-objset/U CBSP BL2 CML2 F U)
    <- set`member-implies-not-member-add L1 S1P F1 U1
    <- set`member-implies-not-member-add L2 S2P F2 U2
    <- set`add-implies-member U L
    <- set`not-member-update-preserves-union-converse*
      F1 U1 F2 U2 SU F U unit`union/ SUP
    <- clsmap-cxt-objset/U-inversion CBS1 F1 U1 CBS1P _ _ _ _ BL1 _ CML1
    <- clsmap-cxt-objset/U-inversion CBS2 F2 U2 CBS2P _ _ _ _ BL2 _ CML2
    <- set`not-member-add-increases-size-converse Z F U ZP
    <- join-preserves-clsmap-cxt-objset/L _ ZP CBS1P CBS2P SUP CBSP.

- : join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U
    (set`domain?/in _) (set`domain?/out F2)
    (clsmap-cxt-objset/U CBSP BL1 CML1 F U)
    <- set`add-implies-member U L
    <- set`not-member-union-right-preserves-member-converse L F2 SU L1
    <- set`member-implies-not-member-add L1 _ F1 U1
    <- clsmap-cxt-objset/U-inversion CBS1 F1 U1 CBS1P _ _ _ _ BL1 _ CML1
    <- set`not-member-update-left-preserves-union-converse* F1 U1 F2 SU F U SU1
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-objset/L _ Z1 CBS1P CBS2 SU1 CBSP.

- : join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U
    (set`domain?/out F1) (set`domain?/in _) %{=>}%
    (clsmap-cxt-objset/U CBSP BL2 CML2 F U)
    <- set`add-implies-member U L
    <- set`not-member-union-left-preserves-member-converse F1 L SU L2
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- clsmap-cxt-objset/U-inversion CBS2 F2 U2 CBS2P _ _ _ _ BL2 _ CML2
    <- set`not-member-update-right-preserves-union-converse* F1 F2 U2 SU F U SU2
    <- set`not-member-add-increases-size-converse Z F U Z1
    <- join-preserves-clsmap-cxt-objset/L _ Z1 CBS1 CBS2P SU2 CBSP.

- : join-preserves-clsmap-cxt-objset/LL _ _ _ _ SU _ U
    (set`domain?/out F1) (set`domain?/out F2) %{=>}% CBS
    <- set`union-preserves-not-member* F1 F2 SU F
    <- set`add-implies-member U L
    <- set`not-member-member-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-clsmap-cxt-objset V CBS.

- : join-preserves-clsmap-cxt-objset/L (s N) Z CBS1 CBS2 SU CBS
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) _ F U
    <- set`domain?-total D1?
    <- set`domain?-total D2?
    <- join-preserves-clsmap-cxt-objset/LL (s N) Z CBS1 CBS2 SU F U D1? D2? CBS.

%worlds (objvar) (join-preserves-clsmap-cxt-objset/LL _ _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-objset/L _ _ _ _ _ _).
%total (N1 N2) (join-preserves-clsmap-cxt-objset/LL N1 _ _ _ _ _ _ _ _ _)
  (join-preserves-clsmap-cxt-objset/L N2 _ _ _ _ _).

- : join-preserves-clsmap-cxt-objset CBS1 CBS2 U CBS
    <- set`size-total Z
    <- join-preserves-clsmap-cxt-objset/L _ Z CBS1 CBS2 U CBS.

%worlds (objvar) (join-preserves-clsmap-cxt-objset _ _ _ _).
%total {} (join-preserves-clsmap-cxt-objset _ _ _ _).


%theorem set+nat2capmap-implies-clsmap-cxt-capmap
  : forall* {CM} {B} {S} {F} {X} {M} {NN} {C} {FM} {T}
    forall {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    {B-S: cxt-unique-objset B NN C S}
    {S+F+X=>M: set+nat2capmap S F X M}
    exists {CM-B-M: clsmap-cxt-capmap CM B M}
    true.

%theorem cxt-unique-objset-no-zero
  : forall* {B} {NN} {C} {S}
    forall {B-S: cxt-unique-objset B NN C S}
    {Z<-S: set`member S z}
    exists {V: void}
    true.

- : cxt-unique-objset-no-zero
    (cxt-unique-objset/U B-SP BL UB LE NM AD) ZMB V
    <- nat`succ-implies-gt-zero _ GT
    <- set`add-preserves-member-converse ZMB AD (nat`ne/< GT) ZMBP
    <- cxt-unique-objset-no-zero B-SP ZMBP V.

%worlds (objvar) (cxt-unique-objset-no-zero _ _ _).
%total (B) (cxt-unique-objset-no-zero B _ _).

- : set+nat2capmap-implies-clsmap-cxt-capmap _ _ _ set+nat2capmap/0 clsmap-cxt-capmap/0.

- : set+nat2capmap-implies-clsmap-cxt-capmap CML FML B-S
    (set+nat2capmap/U S'=>M' (K=>N+F:pair2nat _ z) N!<S' S'+N=S M'+K=M)
    (clsmap-cxt-capmap/z CM-B-M' K!<M' M'+K=M)
    <- set+nat2capmap-preserves-fresh S'=>M' N!<S' K=>N+F K!<M'
    <- cxt-unique-objset/U-inversion B-S N!<S' S'+N=S B-S' _ _ _ BL UA NN-LEQ
    <- set+nat2capmap-implies-clsmap-cxt-capmap CML FML B-S' S'=>M' CM-B-M'.

- : set+nat2capmap-implies-clsmap-cxt-capmap CML FML B-S
    (set+nat2capmap/U S'=>M' K=>N+F (N!<S':set`not-member _ z) S'+N=S M'+K=M)
    CM-B-M
    <- set`add-implies-member S'+N=S N<-S
    <- cxt-unique-objset-no-zero B-S N<-S V
    <- false-implies-clsmap-cxt-capmap V CM-B-M.

- : set+nat2capmap-implies-clsmap-cxt-capmap CML FML B-S
    (set+nat2capmap/U S'=>M' (K=>N+F:pair2nat _ (s _)) N!<S' S'+N=S M'+K=M)
    (clsmap-cxt-capmap/U CM-B-M' K=>N+F BL CML FML K!<M' M'+K=M)
    <- set+nat2capmap-preserves-fresh S'=>M' N!<S' K=>N+F K!<M'
    <- cxt-unique-objset/U-inversion B-S N!<S' S'+N=S B-S' _ _ _ BL UA NN-LEQ
    <- set+nat2capmap-implies-clsmap-cxt-capmap CML FML B-S' S'=>M' CM-B-M'.

%worlds (objvar) (set+nat2capmap-implies-clsmap-cxt-capmap _ _ _ _ _).
%total (B) (set+nat2capmap-implies-clsmap-cxt-capmap _ _ _ B _).


%theorem clsmap-result/expr-implies-clsmap-cxt
  : forall* {CM} {RT} {B} {M}
    forall {CM-R: clsmap-result CM (result/expr RT (env/ B M))}
    exists {CM-B: clsmap-cxt CM B}
    true.

- : clsmap-result/expr-implies-clsmap-cxt (clsmap-result/expr CM-B _ _) CM-B.

%worlds (objvar) (clsmap-result/expr-implies-clsmap-cxt _ _).
%total { } (clsmap-result/expr-implies-clsmap-cxt _ _).


%theorem false-implies-wf-unique-targets
  : forall* {S} {M}
    forall {V:void}
    exists {WF-G: wf-unique-targets (targets/unique S M)}
    true.

%worlds () (false-implies-wf-unique-targets _ _).
%total { } (false-implies-wf-unique-targets _ _).


%theorem make-tgts-and-caps-consistent
  : forall* {CM} {B0} {G0} {A} {X} {M0} {M1} {F} {C} {FM} {NN} {FC} {FNN} {G1}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ FNN A FC)}
    {CM-B-R: clsmap-result CM (result/expr (reftype/ NN C G0) (env/ B0 M0))}
    {MG: make-tgts-and-caps M0 G0 F X G1 M1}
    exists {CM-B-R2: clsmap-result CM (result/expr (reftype/ FNN FC G1) (env/ B0 M1))}
    true.

%theorem make-tgts-and-caps-consistent/L
  : forall* {S} {M1} {M2} {M} {F} {X}
    forall {WF-G: wf-unique-targets (targets/unique S M1)}
    {S+F=>M2: set+nat2capmap S F X M2}
    {M1+M2=M: capmap`join M1 M2 M}
    exists {WF-G1: wf-unique-targets (targets/unique set/0 M)}
    true.

- : make-tgts-and-caps-consistent/L
    wf-unique-targets/1
    (S+F+X=>M2:set+nat2capmap _ _ _ (capmap/+ _ _ _)) capmap`join/L wf-unique-targets/2.

- : make-tgts-and-caps-consistent/L
    wf-unique-targets/1
    (S+F+X=>M2:set+nat2capmap _ _ _ capmap/0) _ WF
    <- set`size-total SZ
    <- set+nat2capmap-preserves-size S+F+X=>M2 (set`size/+ SZ) M-SZ
    <- capmap`size-unique capmap`size/0 M-SZ capmap`eq/ EQ
    <- nat`eq-contradiction EQ V
    <- false-implies-wf-unique-targets V WF.

- : make-tgts-and-caps-consistent/L
    wf-unique-targets/2 S+F+X=>M1 (M1+M2=M:capmap`join _ _ (capmap/+ _ _ _))
    wf-unique-targets/2.

%worlds () (make-tgts-and-caps-consistent/L _ _ _ _).
%total { } (make-tgts-and-caps-consistent/L _ _ _ _).

%%% z is a special value - I need to carefully think about how to handle it.
- : make-tgts-and-caps-consistent CM-CM CML FML
    (clsmap-result/expr (CM-B0:clsmap-cxt CM B0)
      (clsmap-cxt-reftype/shared _)
      (CM-B0-M0:clsmap-cxt-capmap CM B0 M0))
    (make-tgts-and-caps/shared (M0-X=M1:capmap-split M0 (capmap/1 z X) M1))
    (clsmap-result/expr CM-B0
      (clsmap-cxt-reftype/unique CML0 cxt-unique-objset/0
        (clsmap-cxt-capmap/z clsmap-cxt-capmap/0 capmap`fresh/0 capmap`update/0)
        wf-unique-targets/2) CM-B0-M1)
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0)
    <- capmap-split-implies-disjoint-join M0-X=M1 X^M1 X+M1=M0
    <- capmap`join-implies-leq X+M1=M0 _ M1<=M0
    <- clsmap-cxt-capmap-respects-geq CM-B0-M0 M1<=M0 CM-B0-M1.

- : make-tgts-and-caps-consistent CM-CM CML FML
    (clsmap-result/expr (CM-B0:clsmap-cxt CM B0)
      (clsmap-cxt-reftype/unique _ B0-S CM-B0-M1 WF-G1)
      (CM-B0-M0:clsmap-cxt-capmap CM B0 M0))
    (make-tgts-and-caps/unique (S+F+X=>M2:set+nat2capmap S F X M2)
      (MX-M1=X: capmap-min M1 X) (capmap-split/ M1^M2 (M1+M2=M:capmap`join M1 M2 M))
      (capmap-split/ M2^M3 (M2+M3=M0:capmap`join M2 M3 M0)))
    (clsmap-result/expr CM-B0
      (clsmap-cxt-reftype/unique CML0
        cxt-unique-objset/0 CM-B0-M WF-G) CM-B0-M3)
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/ CML0)
    <- capmap`join-implies-leq M2+M3=M0 M2<=M0 M3<=M0
    <- clsmap-cxt-capmap-respects-geq CM-B0-M0 M3<=M0 CM-B0-M3
    <- set+nat2capmap-implies-clsmap-cxt-capmap CML FML B0-S S+F+X=>M2 CM-B0-M2
    <- join-preserves-clsmap-cxt-capmap CM-B0-M1 CM-B0-M2 M1+M2=M CM-B0-M
    <- make-tgts-and-caps-consistent/L WF-G1 S+F+X=>M2 M1+M2=M WF-G.

%worlds (objvar) (make-tgts-and-caps-consistent _ _ _ _ _ _).
%total { } (make-tgts-and-caps-consistent _ _ _ _ _ _).


%theorem consider-ftype-consistent
  : forall* {CM} {G1} {M1} {A} {G2} {M2} {NN} {C} {B0}
    forall {CM-Rslt: clsmap-result CM (result/expr (reftype/ NN C G1) (env/ B0 M1))}
    {CF: consider-ftype G1 M1 A G2 M2}
    exists {CM-Rslt: clsmap-result CM (result/expr (reftype/ NN C G2) (env/ B0 M2))}
    true.

- : consider-ftype-consistent CM-Rslt consider-ftype/unique CM-Rslt.

- : consider-ftype-consistent
    (clsmap-result/expr CM-B0
      (clsmap-cxt-reftype/unique CML _ CM-B0-M _) CM-B0-M1)
    (consider-ftype/shared (SP:capmap-split M0 M M1))
    (clsmap-result/expr CM-B0
      (clsmap-cxt-reftype/shared CML) CM-B0-M0)
    <- capmap-split-implies-disjoint-join SP M^M1 M+M1=M0
    <- join-preserves-clsmap-cxt-capmap CM-B0-M CM-B0-M1 M+M1=M0 CM-B0-M0.

%worlds (objvar) (consider-ftype-consistent _ _ _).
%total { } (consider-ftype-consistent _ _ _).


%theorem make-tgts-and-caps-implies-empty-objset
  : forall* {G1} {M1} {N} {X} {S} {M} {M2}
    forall {MG: make-tgts-and-caps M1 G1 N X (targets/unique S M) M2}
    exists {S=0: set`eq S set/0}
    true.

- : make-tgts-and-caps-implies-empty-objset
    (make-tgts-and-caps/unique _ _ _ _) set`eq/.

- : make-tgts-and-caps-implies-empty-objset
    (make-tgts-and-caps/shared _) set`eq/.

%worlds () (make-tgts-and-caps-implies-empty-objset _ _).
%total { } (make-tgts-and-caps-implies-empty-objset _ _).


%theorem subtype-consistent
  : forall* {CM} {RT} {VI} {T} {VO}
    forall {CM-VI: clsmap-env CM VI}
    {SUB: subtype CM RT VI T VO}
    exists {CM-VO: clsmap-env CM VO}
    true.

%theorem sub-annot-cap-consistent
  : forall* {CM} {FS} {A} {G} {B0} {B1} {M0} {M1}
    forall {CM-VI: clsmap-env CM (env/ B0 M0)}
    {SUB: sub-annot-cap G (env/ B0 M0) FS A (env/ B1 M1)}
    exists {CM-VO: clsmap-env CM (env/ B1 M1)}
    true.

- : sub-annot-cap-consistent (clsmap-env/ CM-B0 CM-B0-M0)
    (sub-annot-cap/consume _ M0-M2=M3 _ B0-OS=B1)
    (clsmap-env/ CM-B1 CM-B1-M3)
    <- cxt-remove-unique-preserves-clsmap-cxt CM-B0 B0-OS=B1 CM-B1
    <- capmap-split-implies-leq M0-M2=M3 M2<=M0 M3<=M0
    <- clsmap-cxt-capmap-respects-geq CM-B0-M0 M3<=M0 CM-B0-M3
    <- cxt-remove-unique-preserves-clsmap-cxt-capmap CM-B0-M3 B0-OS=B1 CM-B1-M3.

- : sub-annot-cap-consistent CM-V sub-annot-cap/shared2shared CM-V.

%worlds (objvar) (sub-annot-cap-consistent _ _ _).
%total { } (sub-annot-cap-consistent _ _ _).

- : subtype-consistent CM-V0 (subtype/ nat`eq/ _ CML DM SUB-A) CM-V1
    <- sub-annot-cap-consistent CM-V0 SUB-A CM-V1.

- : subtype-consistent CM-V subtype/null CM-V.

- : subtype-consistent CM-V subtype/maynull CM-V.

%worlds (objvar) (subtype-consistent _ _ _).
%total { } (subtype-consistent _ _ _).


%theorem subtype-preserves-clsmap-cxt-reftype
  : forall* {CM} {RT} {RT0} {B1} {M1} {T} {B2} {M2}
    forall {CM-B1-RT: clsmap-cxt-reftype CM B1 RT0}
    {SUB: subtype CM RT (env/ B1 M1) T (env/ B2 M2)}
    exists {CM-B2-RT: clsmap-cxt-reftype CM B2 RT0}
    true.

%theorem sub-annot-cap-preserves-clsmap-cxt-reftype
  : forall* {CM} {RT} {B1} {M1} {B2} {M2} {GS} {FS} {A}
    forall {CM-B1-RT: clsmap-cxt-reftype CM B1 RT}
    {SUB: sub-annot-cap GS (env/ B1 M1) FS A (env/ B2 M2)}
    exists {CM-B2-RT: clsmap-cxt-reftype CM B2 RT}
    true.

- : sub-annot-cap-preserves-clsmap-cxt-reftype
    (clsmap-cxt-reftype/unique CML B1-OS CM-B1-M WF)
    (sub-annot-cap/consume _ _ _ R)
    (clsmap-cxt-reftype/unique CML B2-OS CM-B2-M WF)
    <- cxt-remove-unique-preserves-cxt-unique-objset B1-OS R B2-OS
    <- cxt-remove-unique-preserves-clsmap-cxt-capmap CM-B1-M R CM-B2-M.

- : sub-annot-cap-preserves-clsmap-cxt-reftype (clsmap-cxt-reftype/shared CML) _
    (clsmap-cxt-reftype/shared CML).

- : sub-annot-cap-preserves-clsmap-cxt-reftype CM-B-RT sub-annot-cap/shared2shared CM-B-RT.

%worlds (objvar) (sub-annot-cap-preserves-clsmap-cxt-reftype _ _ _).
%total { } (sub-annot-cap-preserves-clsmap-cxt-reftype _ _ _).

- : subtype-preserves-clsmap-cxt-reftype CM-B1-RT
    (subtype/ nat`eq/ _ _ _ SUB-A) CM-B2-RT
    <- sub-annot-cap-preserves-clsmap-cxt-reftype CM-B1-RT SUB-A CM-B2-RT.

- : subtype-preserves-clsmap-cxt-reftype CM-B-RT subtype/null CM-B-RT.

- : subtype-preserves-clsmap-cxt-reftype CM-B-RT subtype/maynull CM-B-RT.

%worlds (objvar) (subtype-preserves-clsmap-cxt-reftype _ _ _).
%total { } (subtype-preserves-clsmap-cxt-reftype _ _ _).


%theorem reftyping-preserves-clsmap-cxt-reftype
  : forall* {CM} {MM} {E} {B0} {B1} {RT} {RT1} {M0} {M1}
    forall {CM-B0-RT: clsmap-cxt-reftype CM B0 RT}
    {RTYP: reftyping CM MM (env/ B0 M0) E (result/expr RT1 (env/ B1 M1))}
    exists {CM-B1-RT: clsmap-cxt-reftype CM B1 RT}
    true.

- : reftyping-preserves-clsmap-cxt-reftype CM-B0-RT (reftyping/lit _ _) CM-B0-RT.

- : reftyping-preserves-clsmap-cxt-reftype CM-B0-RT
    (reftyping/read RTYP-E (reftyping-helper/read/base _ _ _ _ _)) CM-B1-RT
    <- reftyping-preserves-clsmap-cxt-reftype CM-B0-RT RTYP-E CM-B1-RT.

- : reftyping-preserves-clsmap-cxt-reftype CM-B0-RT
    (reftyping/write RTYP-E1
      (reftyping-helper/write/base _ _ _ RTYP-E2 SUB _)) CM-B3-RT
    <- reftyping-preserves-clsmap-cxt-reftype CM-B0-RT RTYP-E1 CM-B1-RT
    <- reftyping-preserves-clsmap-cxt-reftype CM-B1-RT RTYP-E2 CM-B2-RT
    <- subtype-preserves-clsmap-cxt-reftype CM-B2-RT SUB CM-B3-RT.

%worlds (objvar) (reftyping-preserves-clsmap-cxt-reftype _ _ _).
%total (T) (reftyping-preserves-clsmap-cxt-reftype _ T _).

%{
 This theorem says if a term in our language can be type checked, then
 the resultput (especially for unique resultput) must be in a good format.
}%

%theorem reftyping-implies-clsmap-result
  : forall* {CM} {MM} {ENV} {E: expr} {R}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-ENV: clsmap-env CM ENV}
    {TYP: reftyping CM MM ENV E R}
    exists {CM-Rslt: clsmap-result CM R}
    true.

%theorem reftyping-implies-clsmap-result/read
  : forall* {CM} {Rslt} {Rslt2} {F}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-Rslt: clsmap-result CM Rslt}
    {RTYP-HELPER/R: reftyping-helper/read CM Rslt F Rslt2}
    exists {CM-Rslt2: clsmap-result CM Rslt2}
    true.

- : reftyping-implies-clsmap-result/read CM-CM CM-Rslt
    (reftyping-helper/read/base CML FML MG CF _) CM-Rslt3
    <- make-tgts-and-caps-consistent CM-CM CML FML CM-Rslt MG CM-Rslt2
    <- consider-ftype-consistent CM-Rslt2 CF CM-Rslt3.

- : reftyping-implies-clsmap-result/read CM-CM
    (clsmap-result/exists ([v] CM-Rslt v))
    (reftyping-helper/read/exists ([v] RTYP-H v))
    (clsmap-result/exists ([v] CM-Rslt2 v))
    <- ({v} reftyping-implies-clsmap-result/read CM-CM (CM-Rslt v) (RTYP-H v) (CM-Rslt2 v)).

%worlds (objvar) (reftyping-implies-clsmap-result/read _ _ _ _).
%total (CM-R) (reftyping-implies-clsmap-result/read _ CM-R _ _).


%theorem reftyping-implies-clsmap-result/let
  : forall* {CM} {MM} {Rslt} {F} {Rslt2}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-Rslt: clsmap-result CM Rslt}
    {RTYP-LET: letRefTyping CM MM Rslt F Rslt2}
    exists {CM-Rslt2: clsmap-result CM Rslt2}
    true.

%theorem reftyping-implies-clsmap-result/write
  : forall* {CM} {MM} {F} {E} {Rslt2} {G} {T} {Rslt1}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-Rslt1: clsmap-result CM Rslt1}
    {RTYP-W: reftyping-helper/write CM MM Rslt1 F E G T Rslt2}
    exists {CM-Rslt2: clsmap-result CM Rslt2}
    true.

- : reftyping-implies-clsmap-result/write CM-CM (clsmap-result/exists [x] (CM-Rslt1 x))
    (reftyping-helper/write/exists [x] (RTYP-H x)) (clsmap-result/exists [x] (CM-Rslt2 x))
    <- ({x} reftyping-implies-clsmap-result/write CM-CM (CM-Rslt1 x) (RTYP-H x) (CM-Rslt2 x)).

- : reftyping-implies-clsmap-result/write CM-CM CM-R1
    (reftyping-helper/write/base CML FML
      (MG:make-tgts-and-caps M0 G0 F _ G1 M1)
      (RTYP-E2:reftyping CM MM (env/ B0 M1) E (result/expr RT (env/ B1 M2)))
      (SUB:subtype CM RT _ (ty/ NN A FC) (env/ B2 M3))
      (CF:consider-ftype G1 M3 A G2 M4)) CM-R2
    <- clsmap-result/expr-implies-clsmap-cxt CM-R1 CM-B0
    <- make-tgts-and-caps-consistent CM-CM CML FML CM-R1 MG
      (clsmap-result/expr _ CM-B0-RT (CM-B0-M1:clsmap-cxt-capmap CM B0 M1))
    <- reftyping-implies-clsmap-result CM-CM (clsmap-env/ CM-B0 CM-B0-M1) RTYP-E2
      (clsmap-result/expr CM-B1 _ CM-B1-M2)
    <- subtype-consistent (clsmap-env/ CM-B1 CM-B1-M2)
      SUB (clsmap-env/ CM-B2 (CM-B2-M3:clsmap-cxt-capmap CM B2 M3))
    <- reftyping-preserves-clsmap-cxt-reftype CM-B0-RT RTYP-E2 CM-B1-RT
    <- subtype-preserves-clsmap-cxt-reftype CM-B1-RT SUB CM-B2-RT
    <- consider-ftype-consistent (clsmap-result/expr CM-B2 CM-B2-RT CM-B2-M3) CF CM-R2.

- : reftyping-implies-clsmap-result/let CM-CM
    (clsmap-result/expr (CM-B0:clsmap-cxt CM B0) _ CM-B0-M0)
    (letRefTyping/base/unique CML FM-DM S+FS=>M2
      (B0-S=B1:cxt-remove-unique B0 S B1) N!<B1
      (B1+N=B2:{x} cxt`update _ (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B2 x))
      (M0-M2=M4:capmap-split M0 M2 M4)
      N+FS=>M3 (M5-M3=M4:capmap-split M5 M3 M4) MIN-M1=W ([x] RTYP-F x))
    (clsmap-result/exists [x] (CM-Rslt2 x))
    <- cxt-remove-unique-preserves-clsmap-cxt CM-B0 B0-S=B1 CM-B1
    <- capmap-split-implies-disjoint-join M0-M2=M4 M2^M4 M2+M4=M0
    <- capmap-split-implies-disjoint-join M5-M3=M4 M3^M4 M3+M4=M5
    <- ({x} cxt`update-implies-lookup (B1+N=B2 x) (B2->N x))
    <- nat`succ-implies-gt-zero _ GT
    <- ({x} nat+set2capmap-implies-clsmap-cxt-capmap CM-CM CML FM-DM N+FS=>M3
         (B2->N x) GT (CM-B2-M3 x))
    <- capmap`join-implies-leq M2+M4=M0 M2<=M0 M4<=M0
    <- clsmap-cxt-capmap-respects-geq CM-B0-M0 M4<=M0 CM-B0-M4
    <- cxt-remove-unique-preserves-clsmap-cxt-capmap CM-B0-M4 B0-S=B1 CM-B1-M4
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capmap CM-B1-M4
         N!<B1 (B1+N=B2 x) (CM-B2-M4 x))
    <- ({x} join-preserves-clsmap-cxt-capmap (CM-B2-M3 x) (CM-B2-M4 x)
         M3+M4=M5 (CM-B2-M5 x))
    <- ({x:object} reftyping-implies-clsmap-result CM-CM
         (clsmap-env/ (clsmap-cxt/U CM-B1 (clsmap-ty/ CML) N!<B1 (B1+N=B2 x))
           (CM-B2-M5 x)) (RTYP-F x) (CM-Rslt2 x)).

- : reftyping-implies-clsmap-result/let CM-CM
    (clsmap-result/expr (CM-B0:clsmap-cxt CM B0) _ CM-B0-M0)
    (letRefTyping/base/shared CML N!<B0
      (B0+N=B1:{x} cxt`update _ (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x))
      ([x] RTYP-F x))
    (clsmap-result/exists [x] (CM-Rslt2 x))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capmap CM-B0-M0
         N!<B0 (B0+N=B1 x) (CM-B1-M0 x))
    <- ({x:object} reftyping-implies-clsmap-result CM-CM
         (clsmap-env/ (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
           (CM-B1-M0 x)) (RTYP-F x) (CM-Rslt2 x)).

- : reftyping-implies-clsmap-result/let CM-CM
    (clsmap-result/exists [x] (CM-Rslt x))
    (letRefTyping/exists [x] (LTYP x))
    (clsmap-result/exists [x] (CM-Rslt2 x))
    <- ({x} reftyping-implies-clsmap-result/let CM-CM (CM-Rslt x) (LTYP x) (CM-Rslt2 x)).


%%% cases for the main theorem

- : reftyping-implies-clsmap-result CM-CM CM-V
    (reftyping/read RTYP-E RTYP-HELPER-F) CM-Rslt2
    <- reftyping-implies-clsmap-result CM-CM CM-V RTYP-E CM-Rslt
    <- reftyping-implies-clsmap-result/read CM-CM CM-Rslt RTYP-HELPER-F CM-Rslt2.

- : reftyping-implies-clsmap-result CM-CM CM-V
    (reftyping/let RTYP-E LTYP) CM-Rslt2
    <- reftyping-implies-clsmap-result CM-CM CM-V RTYP-E CM-Rslt
    <- reftyping-implies-clsmap-result/let CM-CM CM-Rslt LTYP CM-Rslt2.

- : reftyping-implies-clsmap-result CM-CM (clsmap-env/ CM-B CM-B-M)
    (reftyping/lit BL0 ty2reftype/shared)
    (clsmap-result/expr CM-B
      (clsmap-cxt-reftype/shared CML) CM-B-M)
    <- cxt`lookup-obj-implies-lookup BL0 BL
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/ CML).

- : reftyping-implies-clsmap-result CM-CM (clsmap-env/ CM-B CM-B-M)
    (reftyping/lit BL0 ty2reftype/unique)
    (clsmap-result/expr CM-B
      (clsmap-cxt-reftype/unique CML
        (cxt-unique-objset/U cxt-unique-objset/0 BL unique-or-borrow/unique
          (nonnull`leq/= nonnull`eq/) set`not-member/0 set`update/0)
        clsmap-cxt-capmap/0 wf-unique-targets/1) CM-B-M)
    <- cxt`lookup-obj-implies-lookup BL0 BL
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/ CML).

- : reftyping-implies-clsmap-result CM-CM (clsmap-env/ CM-B CM-B-M)
    (reftyping/lit BL0 ty2reftype/borrow)
    (clsmap-result/expr CM-B
      (clsmap-cxt-reftype/unique CML
        (cxt-unique-objset/U cxt-unique-objset/0 BL unique-or-borrow/borrow
          (nonnull`leq/= nonnull`eq/) set`not-member/0 set`update/0)
        clsmap-cxt-capmap/0 wf-unique-targets/1) CM-B-M)
    <- cxt`lookup-obj-implies-lookup BL0 BL
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/ CML).

- : reftyping-implies-clsmap-result CM-CM CM-V
    (reftyping/write RTYP-E1 RTYP-H) CM-Rslt2
    <- reftyping-implies-clsmap-result CM-CM CM-V RTYP-E1 CM-Rslt
    <- reftyping-implies-clsmap-result/write CM-CM CM-Rslt RTYP-H CM-Rslt2.

%worlds (objvar) (reftyping-implies-clsmap-result _ _ _ _)
  (reftyping-implies-clsmap-result/let _ _ _ _)
  (reftyping-implies-clsmap-result/write _ _ _ _).
%total (T T1 T2) (reftyping-implies-clsmap-result _ _ T _)
  (reftyping-implies-clsmap-result/let _ _ T1 _)
  (reftyping-implies-clsmap-result/write _ _ T2 _).