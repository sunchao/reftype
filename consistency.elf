%%% Consistency relation between various contexts.
%%% $Id$


% Check if a type is in clsmap

clsmap-ty : clsmap -> ty -> type.

clsmap-ty/notnull : clsmap-ty CM (ty/ _ _ C)
                    <- clsmap`lookup CM C _.

clsmap-ty/null : clsmap-ty CM ty/null.


% Check if all types appear in methty is also in clsmap

clsmap-methty : clsmap -> methty -> type.

clsmap-methty/base : clsmap-methty CM (methty/base T _)
                     <- clsmap-ty CM T.

clsmap-methty/args : clsmap-methty CM (methty/arg T _ _ A)
                     <- clsmap-ty CM T
                     <- clsmap-methty CM A.


% Check if a fldmap is consistent with a clsmap.

clsmap-fldmap : clsmap -> fldmap -> type.

clsmap-fldmap/0 : clsmap-fldmap _ fldmap/0.

clsmap-fldmap/+ : clsmap-fldmap CM (fldmap/+ _ T FM)
                  <- clsmap-ty CM T
                  <- clsmap-fldmap CM FM.


% Check if a clsmap is consistent with itself.

clsmap-clsmap : clsmap -> clsmap -> type.

clsmap-clsmap/0 : clsmap-clsmap _ clsmap`map/0.

clsmap-clsmap/+ : clsmap-clsmap CM0 (clsmap`map/+ C FM CM)
                  <- clsmap`lookup CM0 C FM
                  <- clsmap-fldmap CM0 FM
                  <- clsmap`shift C CM CMS
                  <- clsmap-clsmap CM0 CMS.


% Check if a clsmap is consistent with a methmap

clsmap-methmap : clsmap -> methmap -> type.

clsmap-methmap/0 : clsmap-methmap _ methmap`map/0.

clsmap-methmap/meth
  : clsmap-methmap CM (methmap`map/+ N MT MM)
    <- clsmap`fresh CM N
    <- clsmap-methty CM MT
    <- methmap`shift N MM MMS
    <- clsmap-methmap CM MMS.

clsmap-methmap/const
  : clsmap-methmap CM
    (methmap`map/+ N (methty/arg (ty/ nonnull/yes _ N) _ _ MT) MM)
    <- clsmap`lookup CM N _
    <- clsmap-methty CM MT
    <- methmap`shift N MM MMS
    <- clsmap-methmap CM MMS.


% Consistency between clsmap and explicit context.
% All entries in the context should be either shared or borrowed.

clsmap-cxt : clsmap -> cxt -> type.

clsmap-cxt/nil : clsmap-cxt _ cxt/nil.

clsmap-cxt/cons/b
  : clsmap-cxt CM (cxt/cons O (ty/ NN annot/borrow C) B)
    <- clsmap-ty CM (ty/ NN annot/borrow C)
    <- clsmap-cxt CM B.

clsmap-cxt/cons/s
  : clsmap-cxt CM (cxt/cons O (ty/ NN annot/shared C) B)
    <- clsmap-ty CM (ty/ NN annot/shared C)
    <- clsmap-cxt CM B.



% Result from reftyping has to be internally consistent and
% in a good format. This is defined below.


%{
 this relation says all "pairs" (obj,fld) in the set are valid:
 i.e., you can find obj in the context B with class id C, find C
 in the clsmap CM with FM, and find fld in FM with type T.
}%

clsmap-cxt-set : clsmap -> cxt -> set -> type.

clsmap-cxt-set/0 : clsmap-cxt-set _ _ set/0.

clsmap-cxt-set/U : clsmap-cxt-set CM B S'
                   -> nat2pair K (pair/ N F)
                   -> cxt`lookup B (object/ N) (ty/ _ _ C)
                   -> clsmap`lookup CM C FM
                   -> fldmap`lookup FM F T
                   -> set`not-member S' K
                   -> set`add S' K S
                   -> clsmap-cxt-set CM B S.


%{
 This relation likes the one above, except all elements in the
 set are objs. So, we just need them to be in the context B, and
 that we can find the class id in the clsmap CM.
}%

clsmap-cxt-set2 : clsmap -> nat -> cxt -> set -> type.

clsmap-cxt-set2/0 : clsmap-cxt-set2 _ _ _ set/0.

clsmap-cxt-set2/U : clsmap-cxt-set2 CM C B S'
                    -> cxt`lookup B (object/ N) (ty/ _ _ C)
                    -> clsmap`lookup CM C FM
                    -> set`not-member S' N
                    -> set`add S' N S
                    -> clsmap-cxt-set2 CM C B S.


clsmap-cxt-efxmap : clsmap -> cxt -> efxmap -> type.

clsmap-cxt-efxmap/ : efxmap`domain M S
                     -> clsmap-cxt-set CM B S
                     -> clsmap-cxt-efxmap CM B M.

%abbrev clsmap-cxt-efxmap/0 =
	(clsmap-cxt-efxmap/ efxmap`domain/0 clsmap-cxt-set/0).


clsmap-cxt-targets : clsmap -> cxt -> nat -> targets -> type.

clsmap-cxt-targets/shared : clsmap-cxt-targets _ _ _ targets/shared.

clsmap-cxt-targets/unique : clsmap-cxt-set2 CM C B S
                            -> set`disjoint S S2
                            -> clsmap-cxt-set CM B S2
                            -> clsmap-cxt-targets CM B C (targets/unique S S2 _).


clsmap-cxt-effects : clsmap -> cxt -> effects -> type.

clsmap-cxt-effects/ : efxmap`domain M R
                      -> set`disjoint R S
                      -> clsmap-cxt-set CM B R
                      -> clsmap-cxt-set CM B S
                      -> clsmap-cxt-effects CM B (effects/ M S _).

%abbrev clsmap-cxt-effects/0 =
	(clsmap-cxt-effects/ efxmap`domain/0 set`disjoint/R clsmap-cxt-set/0
    clsmap-cxt-set/0).


% Targets and effects has to be consistent with each other.

shared-efx-not-none : shared-efx -> type.

shared-efx-not-none/ : shared-efx-not-none (shared-efx/ _).


shared-efx-relation : bool -> shared-efx -> type.

shared-efx-relation/t : shared-efx-relation true SX <- shared-efx-not-none SX.

shared-efx-relation/f : shared-efx-relation false _.


targets-effects : targets -> effects -> type.

targets-effects/unique
  : efxmap`domain M R
    -> set`leq S2 R
    -> shared-efx-relation B X
    -> targets-effects (targets/unique S1 S2 B) (effects/ M S X).

targets-effects/shared : targets-effects (targets/shared) _.



good-result : clsmap -> cxt -> result K -> type.

good-result/expr : clsmap-cxt-targets CM B C G
                   -> clsmap-cxt-effects CM B XX
                   -> targets-effects G XX
                   -> good-result CM B (result/expr (reftype/ _ C G) XX).

good-result/cond : good-result CM B (result/cond XX)
                   <- clsmap-cxt-effects CM B XX.

good-result/args/0 : good-result CM B (result/args/0 XX)
                     <- clsmap-cxt-effects CM B XX.

good-result/args/+ : good-result CM B (result/args/+ RT AR)
                     <- good-result CM B AR.



%%% Theorems


%theorem clsmap-ty-respects-eq
  : forall* {CM1} {CM2} {T1} {T2}
    forall {CM1-T1: clsmap-ty CM1 T1}
    {E: clsmap`eq CM1 CM2} {E: ty`eq T1 T2}
    exists {CM2-T2: clsmap-ty CM2 T2}
    true.

- : clsmap-ty-respects-eq D clsmap`eq/ ty`eq/ D.

%worlds () (clsmap-ty-respects-eq _ _ _ _).
%total {} (clsmap-ty-respects-eq _ _ _ _).


%theorem clsmap-ty-respects-leq
  : forall* {CM0} {CM1} {T}
    forall {CM0-T: clsmap-ty CM0 T}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-T: clsmap-ty CM1 T}
    true.

- : clsmap-ty-respects-leq (clsmap-ty/notnull L0)
    CM0<=CM1 (clsmap-ty/notnull L1)
    <- clsmap`lookup-respects-leq L0 CM0<=CM1 _ L1 _.

- : clsmap-ty-respects-leq clsmap-ty/null _ clsmap-ty/null.

%worlds () (clsmap-ty-respects-leq _ _ _).
%total {} (clsmap-ty-respects-leq _ _ _).


%theorem clsmap-fldmap-respects-leq
  : forall* {CM0} {CM1} {FM}
    forall {CM0-FM: clsmap-fldmap CM0 FM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-FM: clsmap-fldmap CM1 FM}
    true.

- : clsmap-fldmap-respects-leq clsmap-fldmap/0 _ clsmap-fldmap/0.

- : clsmap-fldmap-respects-leq (clsmap-fldmap/+ CM0-FM CM0-T)
    CM0<=CM1 (clsmap-fldmap/+ CM1-FM CM1-T)
    <- clsmap-ty-respects-leq CM0-T CM0<=CM1 CM1-T
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM.

%worlds () (clsmap-fldmap-respects-leq _ _ _).
%total (CM-FM) (clsmap-fldmap-respects-leq CM-FM _ _).


%theorem clsmap-clsmap-respects-leq
  : forall* {CM0} {CM1} {CM}
    forall {CM0-CM: clsmap-clsmap CM0 CM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-CM: clsmap-clsmap CM1 CM}
    true.

- : clsmap-clsmap-respects-leq clsmap-clsmap/0 _ clsmap-clsmap/0.

- : clsmap-clsmap-respects-leq (clsmap-clsmap/+ CM0-CMS SH CM0-FM CM0-L)
    CM0<=CM1 (clsmap-clsmap/+ CM1-CMS SH CM1-FM CM1-L)
    <- clsmap`lookup-respects-leq CM0-L CM0<=CM1 _ CM1-LP EQ
    <- fldmap`eq-symmetric EQ EQP
    <- clsmap`lookup-respects-eq CM1-LP clsmap`eq/ nat`eq/ EQP CM1-L
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM
    <- clsmap-clsmap-respects-leq CM0-CMS CM0<=CM1 CM1-CMS.

%worlds () (clsmap-clsmap-respects-leq _ _ _).
%total (CM-CM) (clsmap-clsmap-respects-leq CM-CM _ _).


%theorem shift-preserves-clsmap-fldmap
  : forall* {CM} {FM} {FMP} {N}
    forall {CM-FM: clsmap-fldmap CM FM}
    {SH: fldmap`shift N FM FMP}
    exists {CM-FM: clsmap-fldmap CM FMP}
    true.

- : shift-preserves-clsmap-fldmap clsmap-fldmap/0 _ clsmap-fldmap/0.

- : shift-preserves-clsmap-fldmap
    (clsmap-fldmap/+ CM-FM CM-T) SH (clsmap-fldmap/+ CM-FM CM-T).

%worlds () (shift-preserves-clsmap-fldmap _ _ _).
%total {} (shift-preserves-clsmap-fldmap _ _ _).


%{ This theorem says if under a "bigger" clsmap CM0, CM
 is well-defined, and class C in CM has fldmap FM, then all
 classes in FM is well-defined under CM0 }%

%theorem lookup-implies-clsmap-fldmap
  : forall* {M} {CM} {FM} {C}
    forall {M-CM: clsmap-clsmap M CM}
    {L: clsmap`lookup CM C FM}
    exists {M-FM: clsmap-fldmap M FM}
    true.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ _ _ M-FM _)
     (clsmap`lookup/= _) M-FM.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ M-CMP SH _ _)
     (clsmap`lookup/> L P0) M-FM
     <- nat`plus-swap-succ P0 P1
     <- nat`plus-commutative P1 P2
     <- clsmap`shift-preserves-lookup* L SH P2 L2
     <- lookup-implies-clsmap-fldmap M-CMP L2 M-FM.

%worlds () (lookup-implies-clsmap-fldmap _ _ _).
%total (M-CM) (lookup-implies-clsmap-fldmap M-CM _ _).


%theorem lookup-implies-clsmap-ty
  : forall* {CM} {FM} {F} {T}
    forall {CM-FM: clsmap-fldmap CM FM}
    {FM-L: fldmap`lookup FM F T}
    exists {CM-NT: clsmap-ty CM T}
    true.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM CM-T)
    (fldmap`lookup/= _) CM-T.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM _)
    (fldmap`lookup/> LP _) CM-T
    <- lookup-implies-clsmap-ty CM-FM LP CM-T.

%worlds () (lookup-implies-clsmap-ty _ _ _).
%total (CM-FM) (lookup-implies-clsmap-ty CM-FM _ _).


%theorem lookup-implies-clsmap-methty
  : forall* {CM} {MM} {MT} {M}
    forall {CM-MM: clsmap-methmap CM MM}
    {MM-LP: methmap`lookup MM M MT}
    exists {CM-MT: clsmap-methty CM MT}
    true.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth _ _ CM-MT _) (methmap`lookup/= _) CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const _ _ (CM-MT) CML) (methmap`lookup/= _)
     (clsmap-methty/args CM-MT (clsmap-ty/notnull CML)).

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

%worlds (objvar) (lookup-implies-clsmap-methty _ _ _).
%total (L) (lookup-implies-clsmap-methty L _ _).


%theorem cxt-lookup-implies-clsmap-ty
  : forall* {CM} {B} {T} {O}
    forall {CM-B: clsmap-cxt CM B}
    {B-L: cxt`lookup B O T}
    exists {CM-T: clsmap-ty CM T}
    true.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons/s _ CM-T) cxt`lookup/hit CM-T.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons/b _ CM-T) cxt`lookup/hit CM-T.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons/s CM-B _) (cxt`lookup/miss B-L _) CM-T
    <- cxt-lookup-implies-clsmap-ty CM-B B-L CM-T.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons/b CM-B _) (cxt`lookup/miss B-L _) CM-T
    <- cxt-lookup-implies-clsmap-ty CM-B B-L CM-T.

%worlds () (cxt-lookup-implies-clsmap-ty _ _ _).
%total (CM-B) (cxt-lookup-implies-clsmap-ty CM-B _ _).


% theorems about result consistency

%theorem clsmap-cxt-set-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {S1} {S2}
    forall {CM1-B1-S1: clsmap-cxt-set CM1 B1 S1}
    {EQ: clsmap`eq CM1 CM2} {EQ: cxt`eq B1 B2} {EQ: set`eq S1 S2}
    exists {CM2-B2-S2: clsmap-cxt-set CM2 B2 S2}
    true.

- : clsmap-cxt-set-respects-eq A clsmap`eq/ cxt`eq/ set`eq/ A.

%worlds () (clsmap-cxt-set-respects-eq _ _ _ _ _).
%total {} (clsmap-cxt-set-respects-eq _ _ _ _ _).


%theorem clsmap-cxt-set2-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {S1} {S2} {C1} {C2}
    forall {CM1-B1-S1: clsmap-cxt-set2 CM1 C1 B1 S1}
    {EQ: clsmap`eq CM1 CM2} {EQ: nat`eq C1 C2}
    {EQ: cxt`eq B1 B2} {EQ: set`eq S1 S2}
    exists {CM2-B2-S2: clsmap-cxt-set2 CM2 C2 B2 S2}
    true.

- : clsmap-cxt-set2-respects-eq A clsmap`eq/ nat`eq/ cxt`eq/ set`eq/ A.

%worlds () (clsmap-cxt-set2-respects-eq _ _ _ _ _ _).
%total {} (clsmap-cxt-set2-respects-eq _ _ _ _ _ _).


%theorem clsmap-cxt-efxmap-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {M1} {M2}
    forall {CM1-B1-M1: clsmap-cxt-efxmap CM1 B1 M1}
    {EQ: clsmap`eq CM1 CM2} {EQ: cxt`eq B1 B2} {EQ: efxmap`eq M1 M2}
    exists {CM2-B2-M2: clsmap-cxt-efxmap CM2 B2 M2}
    true.

- : clsmap-cxt-efxmap-respects-eq A clsmap`eq/ cxt`eq/ efxmap`eq/ A.

%worlds () (clsmap-cxt-efxmap-respects-eq _ _ _ _ _).
%total {} (clsmap-cxt-efxmap-respects-eq _ _ _ _ _).


%theorem clsmap-cxt-set/U-inversion
  : forall* {CM} {B} {S} {S'} {K}
    forall {CM-B-S: clsmap-cxt-set CM B S}
    {NM: set`not-member S' K}
    {AD: set`add S' K S}
    exists {CM-B-S': clsmap-cxt-set CM B S'}
    {N} {F} {N+F=>K: nat2pair K (pair/ N F)}
    {NN} {A} {C} {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {FM} {CML: clsmap`lookup CM C FM}
    {T} {FML: fldmap`lookup FM F T}
    true.

%theorem clsmap-cxt-set/U-inversion/L
  : forall* {CM} {B} {S} {S'} {S1'} {K} {K1} {NN1}
    {A1} {C1} {FM1} {P} {N1} {F1} {T1}
    forall {CM-B-S: clsmap-cxt-set CM B S1'}
    {NM1: set`not-member S1' K1}
    {AD1: set`add S1' K1 S}
    {K1=>N1+F1: nat2pair K1 (pair/ N1 F1)}
    {BL1: cxt`lookup B (object/ N1) (ty/ NN1 A1 C1)}
    {CML1: clsmap`lookup CM C1 FM1}
    {FML1: fldmap`lookup FM1 F1 T1}
    {NM: set`not-member S' K}
    {AD: set`add S' K S}
    {EQ?: nat`eq? K K1 P}
    exists {CM-B-S': clsmap-cxt-set CM B S'}
    {N} {F} {K=>N+F: nat2pair K (pair/ N F)}
    {NN} {A} {C} {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {FM} {CML: clsmap`lookup CM C FM}
    {T} {FML: fldmap`lookup FM F T}
    true.

- : clsmap-cxt-set/U-inversion/L CM-B-S F1 U1 N2P1 BL1 CML1 FML1 F U
    nat`eq?/yes CM-B-S' _ _ N2P1 _ _ _ BL1 _ CML1 _ FML1
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- clsmap-cxt-set-respects-eq CM-B-S clsmap`eq/ cxt`eq/ S1=S CM-B-S'.

- : clsmap-cxt-set/U-inversion/L CM-B-S F1 U1 N2P BL CML FML
    F U (nat`eq?/no N<>N1) (clsmap-cxt-set/U CM-B-S2 N2P BL CML FML F3 U3)
    _ _ N2P2 _ _ _ BL2 _ CML2 _ FML2
    <- set`add-commutes-converse U U1 N<>N1 _ U3 U2
    <- set`add-preserves-fresh-converse F U3 F2
    <- set`add-preserves-fresh-converse F1 U2 F3
    <- clsmap-cxt-set/U-inversion CM-B-S F2 U2 CM-B-S2 _ _ N2P2 _ _ _ BL2 _ CML2
      _ FML2.

- : clsmap-cxt-set/U-inversion
    (clsmap-cxt-set/U CM-B-S0 N2P0 BL0 CML0 FML0 F0 U0) F1 U1
    CM-B-S1 _ _ N2P1 _ _ _ BL1 _ CML1 _ FML1
    <- nat`eq?-total E?
    <- clsmap-cxt-set/U-inversion/L CM-B-S0 F0 U0 N2P0 BL0 CML0 FML0
      F1 U1 E? CM-B-S1 _ _ N2P1 _ _ _ BL1 _ CML1 _ FML1.

%worlds () (clsmap-cxt-set/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-set/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (clsmap-cxt-set/U-inversion C0 _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-set/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem clsmap-cxt-set2/U-inversion
  : forall* {CM} {C} {B} {S} {S'} {N}
    forall {CM-B-S: clsmap-cxt-set2 CM C B S}
    {NM: set`not-member S' N}
    {AD: set`add S' N S}
    exists {CM-B-S': clsmap-cxt-set2 CM C B S'}
    {NN} {A} {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {FM} {CML: clsmap`lookup CM C FM}
    true.

%theorem clsmap-cxt-set2/U-inversion/L
  : forall* {CM} {C} {B} {S} {S'} {S1'} {N} {NN1}
    {A1} {FM1} {P} {N1}
    forall {CM-B-S: clsmap-cxt-set2 CM C B S1'}
    {NM1: set`not-member S1' N1}
    {AD1: set`add S1' N1 S}
    {BL1: cxt`lookup B (object/ N1) (ty/ NN1 A1 C)}
    {CML1: clsmap`lookup CM C FM1}
    {NM: set`not-member S' N}
    {AD: set`add S' N S}
    {EQ?: nat`eq? N N1 P}
    exists {CM-B-S': clsmap-cxt-set2 CM C B S'}
    {NN} {A} {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {FM} {CML: clsmap`lookup CM C FM}
    true.

- : clsmap-cxt-set2/U-inversion/L CM-B-S F1 U1 BL1 CML1 F U
    nat`eq?/yes CM-B-S' _ _ BL1 _ CML1
    <- set`not-member-add-cancels F1 U1 F U nat`eq/ set`eq/ S1=S
    <- clsmap-cxt-set2-respects-eq CM-B-S clsmap`eq/ nat`eq/ cxt`eq/ S1=S CM-B-S'.

- : clsmap-cxt-set2/U-inversion/L CM-B-S F1 U1 BL CML
    F U (nat`eq?/no N<>N1) (clsmap-cxt-set2/U CM-B-S2 BL CML F3 U3)
    _ _ BL2 _ CML2
    <- set`add-commutes-converse U U1 N<>N1 _ U3 U2
    <- set`add-preserves-fresh-converse F U3 F2
    <- set`add-preserves-fresh-converse F1 U2 F3
    <- clsmap-cxt-set2/U-inversion CM-B-S F2 U2 CM-B-S2 _ _ BL2 _ CML2.

- : clsmap-cxt-set2/U-inversion
    (clsmap-cxt-set2/U CM-B-S0 BL0 CML0 F0 U0) F1 U1 CM-B-S1 _ _ BL1 _ CML1
    <- nat`eq?-total E?
    <- clsmap-cxt-set2/U-inversion/L CM-B-S0 F0 U0 BL0 CML0
      F1 U1 E? CM-B-S1 _ _ BL1 _ CML1.

%worlds () (clsmap-cxt-set2/U-inversion _ _ _ _ _ _ _ _ _)
	(clsmap-cxt-set2/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (clsmap-cxt-set2/U-inversion C0 _ _ _ _ _ _ _ _)
	(clsmap-cxt-set2/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem clsmap-cxt-set-respects-geq
  : forall* {S} {SP} {CM} {B}
    forall {B-SP: clsmap-cxt-set CM B SP}
    {S1<=S2: set`leq S SP}
    exists {B-S: clsmap-cxt-set CM B S}
    true.

- : clsmap-cxt-set-respects-geq clsmap-cxt-set/0 set`leq/0 clsmap-cxt-set/0.

%theorem clsmap-cxt-set-respects-geq/U
  : forall* {CM} {FM} {SS} {SP} {N} {B} {NN} {A} {C} {S} {K} {T} {F}
    forall {P} {IN?: set`member? S K P}
    {NM: set`not-member SS K}
    {UD: set`add SS K SP}
    {NP: nat2pair K (pair/ N F)}
    {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    {CM-B-SS: clsmap-cxt-set CM B SS}
    {S<=SP: set`leq S SP}
    exists {CM-B-S: clsmap-cxt-set CM B S}
    true.

- : clsmap-cxt-set-respects-geq/U true (set`member?/in N<-S)
    NM UD NP BL CML FML CM-B-SS S<=SP
    (clsmap-cxt-set/U CM-B-ST NP BL CML FML N!<ST ADD)
    <- set`member-implies-not-member-add N<-S ST N!<ST ADD
    <- set`not-member-add-preserves-leq-converse S<=SP N!<ST ADD NM UD ST<=SS
    <- clsmap-cxt-set-respects-geq CM-B-SS ST<=SS CM-B-ST.

- : clsmap-cxt-set-respects-geq/U false (set`domain?/out N!<S)
    NM UD BL CML DM-FM=FS MPS<=FS CM-B-SS S<=SP CM-B-S
    <- set`not-member-update2-preserves-leq-converse S<=SP N!<S NM UD S<=SS
    <- clsmap-cxt-set-respects-geq CM-B-SS S<=SS CM-B-S.

- : clsmap-cxt-set-respects-geq
    (clsmap-cxt-set/U CM-B-SS NP BL CML FML NM UD) S<=SP CM-B-S
    <- set`domain?-total MB?
    <- clsmap-cxt-set-respects-geq/U
      _ MB? NM UD NP BL CML FML CM-B-SS S<=SP CM-B-S.

%worlds (objvar | fracvar) (clsmap-cxt-set-respects-geq _ _ _)
(clsmap-cxt-set-respects-geq/U _ _ _ _ _ _ _ _ _ _ _).
%total (L1 L2) (clsmap-cxt-set-respects-geq L1 _ _)
(clsmap-cxt-set-respects-geq/U _ _ _ _ _ _ _ _ L2 _ _).


% a direct result from above

%theorem clsmap-cxt-efxmap-respects-geq
  : forall* {M} {M'} {CM} {B}
    forall {B-M': clsmap-cxt-efxmap CM B M'}
    {LE: efxmap`leq M M'}
    exists {B-M: clsmap-cxt-efxmap CM B M}
    true.

- : clsmap-cxt-efxmap-respects-geq (clsmap-cxt-efxmap/ DM' CM-B-S')
    M<=M' (clsmap-cxt-efxmap/ DM CM-B-S)
    <- efxmap`domain-total DM
    <- efxmap`domain-preserves-leq* M<=M' DM DM' S<=S'
    <- clsmap-cxt-set-respects-geq CM-B-S' S<=S' CM-B-S.

%worlds (objvar | fracvar) (clsmap-cxt-efxmap-respects-geq _ _ _).
%total {} (clsmap-cxt-efxmap-respects-geq L1 _ _).


%theorem join-preserves-clsmap-cxt-set
  : forall* {CM} {B} {S1} {S2} {S}
    forall {CM-B-S1: clsmap-cxt-set CM B S1}
    {CM-B-S2: clsmap-cxt-set CM B S2}
    {J: set`join S1 S2 S}
    exists {CM-B-S: clsmap-cxt-set CM B S}
    true.

% this seems a little bit tricky, but it's basically
% of the same pattern in map-all.elf.

%worlds () (join-preserves-clsmap-cxt-set _ _ _ _).
%trustme %total {} (join-preserves-clsmap-cxt-set _ _ _ _).


%theorem shared-efx-relation-respects-geq
  : forall* {B} {SX1} {SX2}
    forall {B-SX1: shared-efx-relation B SX1}
    {SX1<=SX2: shared-efx`leq SX1 SX2}
    exists {B-SX2: shared-efx-relation B SX2}
    true.

- : shared-efx-relation-respects-geq shared-efx-relation/f _ shared-efx-relation/f.

- : shared-efx-relation-respects-geq
    (shared-efx-relation/t shared-efx-not-none/) (shared-efx`leq/= _)
    (shared-efx-relation/t shared-efx-not-none/).

%worlds () (shared-efx-relation-respects-geq _ _ _).
%total {} (shared-efx-relation-respects-geq _ _ _).


%theorem effects`join-right-preserves-targets-effects
  : forall* {XX1} {XX2} {XX} {G}
    forall {G-XX2: targets-effects G XX2}
    {XX1+XX2=XX: effects`join XX1 XX2 XX}
    exists {G-XX: targets-effects G XX}
    true.

- : effects`join-right-preserves-targets-effects
    targets-effects/shared _ targets-effects/shared.

- : effects`join-right-preserves-targets-effects
    (targets-effects/unique DM-M2=R2 S2<=R2 B-X2)
    (effects`join/ _ _ _ _ _ _ _ _ J _ XJ)
    (targets-effects/unique DM-M=R S2<=R B-X)
    <- efxmap`join-implies-leq J _ M2<=M
    <- efxmap`domain-preserves-leq M2<=M DM-M2=R2 R DM-M=R R2<=R
    <- set`leq-transitive S2<=R2 R2<=R S2<=R
    <- shared-efx`join-implies-leq XJ _ X2<=X
    <- shared-efx-relation-respects-geq B-X2 X2<=X B-X.

%worlds () (effects`join-right-preserves-targets-effects _ _ _).
%total {} (effects`join-right-preserves-targets-effects _ _ _).


%theorem compatible-right-join-preserves-targets-effects
  : forall* {XX1} {XX2} {XX} {G}
    forall {G-XX1: targets-effects G XX1}
    {XX1+XX2=XX: effects`join XX1 XX2 XX}
    {CP: compatible G XX2}
    exists {G-XX: targets-effects G XX}
    true.

%theorem compatible-right-join-preserves-targets-effects/L
  : forall* {G} {R1} {R1'} {S2} {S3} {M} {M'}
    forall {G<=R1: set`leq G R1}
    {D: set`disjoint G S2}
    {RM: set`remove R1 S2 S3}
    {DM1: efxmap`domain M R1}
    {DM1': efxmap`domain M' R1'}
    {RS: efxmap`restrict M S3 M'}
    {B} {LE?: set`leq? G R1' B}
    exists {G<=R1': set`leq G R1'}
    true.

- : compatible-right-join-preserves-targets-effects/L
    G<=R1 G^S2 R1/S2=S3 DM-M=R1 DM-M'=R1' M|S3=M' _
    (set`leq?/no (set`nle/< N<-G N!<R1')) G<=R1'
    <- set`member-respects-leq N<-G G<=R1 N<-R1
    <- efxmap`restrict-implies-domain-leq* M|S3=M' DM-M'=R1' R1'<=S3
    <- efxmap`domain-preserves-lookup-converse N<-R1 DM-M=R1 D M->N=D
    <- efxmap`domain-preserves-fresh-converse N!<R1' DM-M'=R1' N!<M'
    <- efxmap`restrict-lookup-not-member-implies-fresh-converse
      M|S3=M' M->N=D N!<M' N!<S3
    <- set`union-total S2+S3=Q
    <- set`remove-implies-leq-union R1/S2=S3 S2+S3=Q R1<=Q
    <- set`member-respects-leq N<-R1 R1<=Q N<-Q
    <- set`not-member-union-right-preserves-member-converse
      N<-Q N!<S3 S2+S3=Q N<-S2
    <- set`disjoint-member-contradiction G^S2 N<-G N<-S2 F
    <- set`false-implies-leq F G<=R1'.

- : compatible-right-join-preserves-targets-effects/L
    _ _ _ _ _ _ _ (set`leq?/yes G<=R1') G<=R1'.

%worlds ()
	(compatible-right-join-preserves-targets-effects/L _ _ _ _ _ _ _ _ _).
%total {}
	(compatible-right-join-preserves-targets-effects/L _ _ _ _ _ _ _ _ _).

- : compatible-right-join-preserves-targets-effects
    (targets-effects/unique (DM-M1=R1:efxmap`domain M1 R1) G<=R1 B-X1)
    (effects`join/ _ _ _ _ _ _ RM RS (J:efxmap`join M1' M2 M)
      _ (XJ:shared-efx`join Xx1 Xx2 Xx))
    (compatible/unique (DM-M2=R2:efxmap`domain M2 R2) (G^R2:set`disjoint G R2)
      (G^S2:set`disjoint G S2) B-X2)
    (targets-effects/unique DM-M=R G<=R (B-X:shared-efx-relation B Xx))
    <- efxmap`domain-total (DM-M1'=R1':efxmap`domain M1' R1')
    <- set`leq?-total LE?
    <- compatible-right-join-preserves-targets-effects/L
      G<=R1 G^S2 RM DM-M1=R1 DM-M1'=R1' RS _ LE? G<=R1'
    <- efxmap`domain-total (DM-M=R:efxmap`domain M R)
    <- efxmap`join-commute-domain J DM-M1'=R1' DM-M2=R2 DM-M=R R1'+R2=R
    <- set`union-implies-leq R1'+R2=R R1'<=R _
    <- set`leq-transitive G<=R1' R1'<=R G<=R
    <- shared-efx`join-implies-leq XJ LE1 LE2
    <- shared-efx-relation-respects-geq B-X1 LE1 B-X.

- : compatible-right-join-preserves-targets-effects
    (targets-effects/shared) _ _ targets-effects/shared.

%worlds () (compatible-right-join-preserves-targets-effects _ _ _ _).
%total {} (compatible-right-join-preserves-targets-effects _ _ _ _).


%theorem targets-effects-respects-efxmap-geq
  : forall* {G} {M1} {M2} {S} {SX}
    forall {G-XX1: targets-effects G (effects/ M1 S SX)}
    {L: efxmap`leq M1 M2}
    exists {G-XX2: targets-effects G (effects/ M2 S SX)}
    true.

- : targets-effects-respects-efxmap-geq
    targets-effects/shared _ targets-effects/shared.

- : targets-effects-respects-efxmap-geq
    (targets-effects/unique DM-M1=R1 S<=R1 B-SX) M1<=M2
    (targets-effects/unique DM-M2=R2 S<=R2 B-SX)
    <- efxmap`domain-preserves-leq M1<=M2 DM-M1=R1 _ DM-M2=R2 R1<=R2
    <- set`leq-transitive S<=R1 R1<=R2 S<=R2.

%worlds () (targets-effects-respects-efxmap-geq _ _ _).
%total {} (targets-effects-respects-efxmap-geq _ _ _).


%theorem join-preserves-clsmap-cxt-effects
  : forall* {CM} {B} {XX1} {XX2} {XX}
    forall {C1: clsmap-cxt-effects CM B XX1}
    {C2: clsmap-cxt-effects CM B XX2}
    {J: effects`join XX1 XX2 XX}
    exists {C: clsmap-cxt-effects CM B XX}
    true.

- : join-preserves-clsmap-cxt-effects
    (clsmap-cxt-effects/ DM-M1=R1 R1^S1 CM-B-R1 CM-B-S1)
    (clsmap-cxt-effects/ DM-M2=R2 R2^S2 CM-B-R2 CM-B-S2)
    (effects`join/ DM-M1=R1' DM-M2=R2' S1^R1' S2^R2' S1^R2' S1^S2
      R1'/S2=S3 M1|S3=M1' M1'+M2=M S1+S2=S X1+X2=X)
    (clsmap-cxt-effects/ DM-M=R R^S CM-B-R CM-B-S)
    <- join-preserves-clsmap-cxt-set CM-B-S1 CM-B-S2 S1+S2=S CM-B-S
    <- efxmap`restrict-implies-leq M1|S3=M1' M1'<=M1
    <- efxmap`domain-total DM-M1'=R1''
    <- efxmap`domain-preserves-leq* M1'<=M1  DM-M1'=R1'' DM-M1=R1' R1''<=R1'
    <- efxmap`domain-unique DM-M1=R1' DM-M1=R1 efxmap`eq/ R1'=R1
    <- efxmap`domain-unique DM-M2=R2' DM-M2=R2 efxmap`eq/ R2'=R2
    <- set`leq-respects-eq R1''<=R1' set`eq/ R1'=R1 R1''<=R1
    <- clsmap-cxt-set-respects-geq CM-B-R1 R1''<=R1 CM-B-R1''
    <- efxmap`domain-total DM-M=R
    <- efxmap`join-commute-domain M1'+M2=M DM-M1'=R1'' DM-M2=R2 DM-M=R R1''+R2=R
    <- join-preserves-clsmap-cxt-set CM-B-R1'' CM-B-R2 R1''+R2=R CM-B-R
    <- set`disjoint-respects-eq S1^R1' set`eq/ R1'=R1 S1^R1
    <- set`disjoint-respects-eq S2^R2' set`eq/ R2'=R2 S2^R2
    <- set`disjoint-respects-eq S1^R2' set`eq/ R2'=R2 S1^R2
    <- set`leq-reflexive _ S1<=S1
    <- set`disjoint-respects-geq S1^R1 S1<=S1 R1''<=R1 S1^R1''
    <- efxmap`remove-implies-domain-disjoint*
      (efxmap`remove/ DM-M1=R1' R1'/S2=S3 M1|S3=M1') DM-M1'=R1'' R1''^S2
    <- set`disjoint-symmetric S1^R2 R2^S1
    <- set`disjoint-symmetric S1^R1'' R1''^S1
    <- set`union-preserves-disjoint* R1''^S1 R2^S1 R1''+R2=R R^S1
    <- set`union-preserves-disjoint* R1''^S2 R2^S2 R1''+R2=R R^S2
    <- set`union-right-preserves-disjoint* R^S1 R^S2 S1+S2=S R^S.

%worlds () (join-preserves-clsmap-cxt-effects _ _ _ _).
%total {} (join-preserves-clsmap-cxt-effects _ _ _ _).


%theorem join-preserves-clsmap-cxt-set2
  : forall* {B} {C} {CM} {S1} {S2} {S}
    forall {B-S1: clsmap-cxt-set2 CM C B S1}
    {B-S2: clsmap-cxt-set2 CM C B S2}
    {U: set`union S1 S2 S}
    exists {B-S: clsmap-cxt-set2 CM C B S}
    true.

%worlds () (join-preserves-clsmap-cxt-set2 _ _ _ _).
%trustme %total {} (join-preserves-clsmap-cxt-set2 _ _ _ _).


% Some "constructive" theorems.

%theorem set+nat2set-implies-clsmap-cxt-set
  : forall* {CM} {B} {S} {F} {Q} {C} {FM} {T}
    forall {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    {SOC: clsmap-cxt-set2 CM C B S}
    {S+F=>Q: set+nat2set S F Q}
    exists {CM-B-Q: clsmap-cxt-set CM B Q}
    true.

- : set+nat2set-implies-clsmap-cxt-set _ _ _ set+nat2set/0 clsmap-cxt-set/0.

- : set+nat2set-implies-clsmap-cxt-set CML FML CM-B-S
    (set+nat2set/U SP+F=>QP N+F=>K FS US UQ)
    (clsmap-cxt-set/U CM-B-QP N+F=>K BL CML FML FQ UQ)
    <- clsmap-cxt-set2/U-inversion CM-B-S FS US CM-B-SP _ _ BL _ _
    <- set+nat2set-implies-clsmap-cxt-set CML FML CM-B-SP SP+F=>QP CM-B-QP
    <- set+nat2set-preserves-fresh SP+F=>QP FS N+F=>K FQ.

%worlds () (set+nat2set-implies-clsmap-cxt-set _ _ _ _ _).
%total (T) (set+nat2set-implies-clsmap-cxt-set _ _ _ T _).


%theorem set+set2set-implies-clsmap-cxt-set
  : forall* {CM} {B} {S} {FS} {Q} {C} {FM} {FS1}
    forall {CM-B-S: clsmap-cxt-set2 CM C B S}
    {S+S=>Q: set+set2set S FS Q}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS1}
    {LE: set`leq FS FS1}
    exists {CM-B-Q: clsmap-cxt-set CM B Q}
    true.

- : set+set2set-implies-clsmap-cxt-set CM-B-S
    set+set2set/0 _ _ _ clsmap-cxt-set/0.

- : set+set2set-implies-clsmap-cxt-set CM-B-S
    (set+set2set/U S+FSP=>QP S+F=>R F!<FSP FSP+F=FS QP+R=Q)
    CML DM-FM=FS1 FS<=FS1 CM-B-Q
    <- set`add-implies-leq FSP+F=FS FSP<=FS
    <- set`leq-transitive FSP<=FS FS<=FS1 FSP<=FS1
    <- set`add-implies-member FSP+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS1 F<-FS1
    <- fldmap`domain-preserves-lookup-converse F<-FS1 DM-FM=FS1 _ FML
    <- set+nat2set-implies-clsmap-cxt-set CML FML CM-B-S S+F=>R CM-B-R
    <- set+set2set-implies-clsmap-cxt-set CM-B-S S+FSP=>QP CML DM-FM=FS1
      FSP<=FS1 CM-B-QP
    <- join-preserves-clsmap-cxt-set CM-B-QP CM-B-R QP+R=Q CM-B-Q.

%worlds () (set+set2set-implies-clsmap-cxt-set _ _ _ _ _ _ ).
%total (S) (set+set2set-implies-clsmap-cxt-set _ S _ _ _ _ ).


%theorem set2efxmap-preserves-consistency
  : forall* {CM} {B} {S} {X} {M}
    forall {S2M: set2efxmap S X M}
    {CM-B-S: clsmap-cxt-set CM B S}
    exists {CM-B-M: clsmap-cxt-efxmap CM B M}
    true.

- : set2efxmap-preserves-consistency
    S2M CM-B-S (clsmap-cxt-efxmap/ DM CM-B-S)
    <- set2efxmap-implies-domain S2M DM.

%worlds () (set2efxmap-preserves-consistency _ _ _).
%total (A) (set2efxmap-preserves-consistency _ A _).


%theorem create-shared-efx-not-none
  : forall* {SX} {X}
    forall {CX: create-shared-efx X SX}
    exists {SN: shared-efx-not-none SX}
    true.

- : create-shared-efx-not-none create-shared-efx/read shared-efx-not-none/.

- : create-shared-efx-not-none create-shared-efx/write shared-efx-not-none/.

%worlds () (create-shared-efx-not-none _ _).
%total {} (create-shared-efx-not-none _ _).


%theorem efx-on-shared-implies-shared-efx-relation
  : forall* {B} {SX} {SX'}
    forall {NN: shared-efx-not-none SX} {EOS: efx-on-shared B SX SX'}
    exists {B-SX: shared-efx-relation B SX'}
    true.

- : efx-on-shared-implies-shared-efx-relation NN efx-on-shared/true
    (shared-efx-relation/t NN).

- : efx-on-shared-implies-shared-efx-relation _ efx-on-shared/false
    shared-efx-relation/f.

%worlds () (efx-on-shared-implies-shared-efx-relation _ _ _).
%total {} (efx-on-shared-implies-shared-efx-relation _ _ _).


%theorem make-targets-and-effects-consistent
  : forall* {CM} {B} {G} {A} {X} {GP} {XX} {F} {C} {FM} {NN} {FC}
    forall {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {CM-B-G: clsmap-cxt-targets CM B C G}
    {MG: make-targets-and-effects G A F X GP XX}
    exists {CM-B-GP: clsmap-cxt-targets CM B FC GP}
    {CM-B-XX: clsmap-cxt-effects CM B XX}
    {GP-XX: targets-effects GP XX}
    true.

- : make-targets-and-effects-consistent
    _ _ clsmap-cxt-targets/shared
    (make-targets-and-effects/shared consider-ftype/shared _)
    clsmap-cxt-targets/shared clsmap-cxt-effects/0 targets-effects/shared.

- : make-targets-and-effects-consistent
    _ _ clsmap-cxt-targets/shared
    (make-targets-and-effects/shared consider-ftype/unique CX)
    (clsmap-cxt-targets/unique clsmap-cxt-set2/0
      set`disjoint/L clsmap-cxt-set/0) clsmap-cxt-effects/0
    (targets-effects/unique efxmap`domain/0 set`leq/0
      (shared-efx-relation/t SN))
    <- create-shared-efx-not-none CX SN.

- : make-targets-and-effects-consistent
    CML FML (clsmap-cxt-targets/unique CM-B-S _ CM-B-G1)
    (make-targets-and-effects/unique
      S=>G2 G1^G2 G1+G2=G G=>M _ _ consider-ftype/shared)
    clsmap-cxt-targets/shared
    (clsmap-cxt-effects/ DM set`disjoint/R CM-B-G clsmap-cxt-set/0)
    (targets-effects/shared)
    <- set2efxmap-implies-domain G=>M DM
    <- set+nat2set-implies-clsmap-cxt-set CML FML CM-B-S S=>G2 CM-B-G2
    <- join-preserves-clsmap-cxt-set CM-B-G1 CM-B-G2 G1+G2=G CM-B-G.

- : make-targets-and-effects-consistent
    CML FML (clsmap-cxt-targets/unique CM-B-S _ CM-B-G1)
    (make-targets-and-effects/unique
      S=>G2 (G1^G2:set`disjoint G1 G2) G1+G2=G G=>M CSE EOS consider-ftype/unique)
    (clsmap-cxt-targets/unique clsmap-cxt-set2/0 set`disjoint/L CM-B-G)
    (clsmap-cxt-effects/ DM set`disjoint/R CM-B-G clsmap-cxt-set/0)
    (targets-effects/unique DM LE B-SX)
    <- set+nat2set-implies-clsmap-cxt-set CML FML CM-B-S S=>G2 CM-B-G2
    <- join-preserves-clsmap-cxt-set CM-B-G1 CM-B-G2 G1+G2=G CM-B-G
    <- set2efxmap-implies-domain G=>M DM
    <- set`leq-reflexive _ LE
    <- create-shared-efx-not-none CSE SN
    <- efx-on-shared-implies-shared-efx-relation SN EOS B-SX.

%worlds () (make-targets-and-effects-consistent _ _ _ _ _ _ _).
%total {} (make-targets-and-effects-consistent _ _ _ _ _ _ _).


%theorem subtyping-consistent
  : forall* {CM} {B} {NN1} {C1} {G} {NN2} {A2} {C2} {S1} {S2} {XX}
    forall {CM-B-G: clsmap-cxt-targets CM B C1 G}
    {STYP: subtype CM (reftype/ NN1 C1 G) (ty/ NN2 A2 C2) S1 S2 XX}
    exists {CM-B-XX: clsmap-cxt-effects CM B XX}
    true.

- : subtyping-consistent (clsmap-cxt-targets/unique CM-B-S S^G1 CM-B-G1)
    (subtype/ (sub-annot/unique2shared G1+G2=G S+Cs=>G2) _ _ DM CML nat`eq/)
    (clsmap-cxt-effects/ efxmap`domain/0 set`disjoint/L clsmap-cxt-set/0 CM-B-G)
    <- set`leq-reflexive _ LE
    <- set+set2set-implies-clsmap-cxt-set CM-B-S S+Cs=>G2 CML DM LE CM-B-G2
    <- join-preserves-clsmap-cxt-set CM-B-G1 CM-B-G2 G1+G2=G CM-B-G.

- : subtyping-consistent (clsmap-cxt-targets/unique CM-B-S S^Gs CM-B-G)
    (subtype/
      (sub-annot/unique2borrow
        B+SX1=SX S1+S2=SX1 M1+M2=M G2x=>M2 G1x=>M1
        G+G2=G2x G+G1=G1x S+WS=>G2 S+RS=>G1) (WS<=FS:set`leq WS FS)
      (RS<=FS:set`leq RS FS) DM CML nat`eq/)
    (clsmap-cxt-effects/ DM-M=Gx set`disjoint/R CM-B-Gx clsmap-cxt-set/0)
    <- set+set2set-implies-clsmap-cxt-set CM-B-S S+RS=>G1 CML DM RS<=FS CM-B-G1
    <- set+set2set-implies-clsmap-cxt-set CM-B-S S+WS=>G2 CML DM WS<=FS CM-B-G2
    <- join-preserves-clsmap-cxt-set CM-B-G CM-B-G1 G+G1=G1x CM-B-G1x
    <- join-preserves-clsmap-cxt-set CM-B-G CM-B-G2 G+G2=G2x CM-B-G2x
    <- set2efxmap-implies-domain G1x=>M1 DM-M1=G1x
    <- set2efxmap-implies-domain G2x=>M2 DM-M2=G2x
    <- efxmap`domain-total DM-M=Gx
    <- efxmap`join-commute-domain
      M1+M2=M DM-M1=G1x DM-M2=G2x DM-M=Gx G1x+G2x=Gx
    <- join-preserves-clsmap-cxt-set CM-B-G1x CM-B-G2x G1x+G2x=Gx CM-B-Gx.

- : subtyping-consistent (clsmap-cxt-targets/unique CM-B-S S^Gs CM-B-G1)
    (subtype/ (sub-annot/unique2unique G1+G2=G S+Cs=>G2)
      WS<=FS RS<=FS DM CML nat`eq/)
    (clsmap-cxt-effects/ efxmap`domain/0 set`disjoint/L
      clsmap-cxt-set/0 CM-B-G)
    <- set`leq-reflexive _ LE
    <- set+set2set-implies-clsmap-cxt-set CM-B-S S+Cs=>G2 CML DM LE CM-B-G2
    <- join-preserves-clsmap-cxt-set CM-B-G1 CM-B-G2 G1+G2=G CM-B-G.

- : subtyping-consistent clsmap-cxt-targets/shared
    (subtype/ (sub-annot/shared2borrow _) _ _ _ _ _) clsmap-cxt-effects/0.

- : subtyping-consistent clsmap-cxt-targets/shared
    (subtype/ sub-annot/shared2shared _ _ _ _ _) clsmap-cxt-effects/0.

%worlds () (subtyping-consistent _ _ _).
%total {} (subtyping-consistent _ _ _).


%{
 This theorem says if a term in our language can be type checked, then
 the resultput (especially for unique resultput) must be in a good format.
}%

%theorem reftyping-implies-good-result
  : forall* {CM} {MM} {B} {E: expr} {Rslt}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-B: clsmap-cxt CM B}
    {TYP: reftyping CM MM B E Rslt}
    exists {G-Rslt: good-result CM B Rslt}
    true.

- : reftyping-implies-good-result _ _ (reftyping/lit ty2reftype/shared _ _)
    (good-result/expr (clsmap-cxt-targets/shared)
      clsmap-cxt-effects/0 targets-effects/shared).

- : reftyping-implies-good-result _ CM-B
    (reftyping/lit ty2reftype/borrow _ BL)
    (good-result/expr
      (clsmap-cxt-targets/unique
        (clsmap-cxt-set2/U clsmap-cxt-set2/0 BL CML set`not-member/0 set`update/0)
        set`disjoint/R  clsmap-cxt-set/0) clsmap-cxt-effects/0
      (targets-effects/unique efxmap`domain/0 set`leq/0 shared-efx-relation/f))
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/notnull CML).

- : reftyping-implies-good-result CM-CM CM-B
    (reftyping/read TYP-E CML FML MG (XJ:effects`join XXx1 XXx2 XXx))
    (good-result/expr CM-B-GP CM-B-XX GP-XX)
    <- reftyping-implies-good-result CM-CM CM-B TYP-E
      (good-result/expr CM-B-G CM-B-XX1 G-XX1)
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/notnull CML2)
    <- make-targets-and-effects-consistent
      CML FML CM-B-G MG CM-B-GP CM-B-XX2 GP-XX2
    <- effects`join-right-preserves-targets-effects GP-XX2 XJ GP-XX
    <- join-preserves-clsmap-cxt-effects CM-B-XX1 CM-B-XX2 XJ CM-B-XX.

%{ We can easily obtain G-XX5, but one issue is XX6.
After we do XX5+XX6=XX7, we need to prove G-XX7. This is
only true if the part of read/write effects corresponding to
G is not "covered" by consume effects in XX6. The only restriction
we have for XX6 is "compatible", which is a stronger condition
(not only it disallow G to have corresponding consume effects
in XX6, but also read/write effects in XX6, since read/write
effects are encumbered and thus cannot be reused.
}%

- : reftyping-implies-good-result CM-CM CM-B
    (reftyping/write RTYP-E1 RTYP-E2 CML FML MG SUB
      (XX1+XX3=XX5:effects`join XXx1 XXx3 XXx5)
      (XX2+XX4=XX6:effects`join XXx2 XXx4 XXx6)
      (XX5+XX6=XX7:effects`join XXx5 XXx6 XXx7) GSP)
    (good-result/expr CM-B-G CM-B-XX7 G-XX7)
    <- reftyping-implies-good-result CM-CM CM-B RTYP-E1
      (good-result/expr CM-B-G1 CM-B-XX1 (G-XX1:targets-effects G1x XXx1))
    <- reftyping-implies-good-result CM-CM CM-B RTYP-E2
      (good-result/expr CM-B-G2 CM-B-XX2 (G-XX2:targets-effects G2x XXx2))
    <- make-targets-and-effects-consistent
      CML FML CM-B-G1 MG CM-B-G CM-B-XX3 (G-XX3:targets-effects Gx _)
    <- join-preserves-clsmap-cxt-effects
      CM-B-XX1 CM-B-XX3 XX1+XX3=XX5 CM-B-XX5
    <- subtyping-consistent CM-B-G2 SUB CM-B-XX4
    <- join-preserves-clsmap-cxt-effects
      CM-B-XX2 CM-B-XX4 XX2+XX4=XX6 CM-B-XX6
    <- join-preserves-clsmap-cxt-effects
      CM-B-XX5 CM-B-XX6 XX5+XX6=XX7 CM-B-XX7
    <- effects`join-right-preserves-targets-effects G-XX3 XX1+XX3=XX5 G-XX5
    <- compatible-right-join-preserves-targets-effects
      G-XX5 XX5+XX6=XX7 GSP G-XX7.

%worlds () (reftyping-implies-good-result _ _ _ _).
%total (T) (reftyping-implies-good-result _ _ T _).