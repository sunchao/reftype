%%% Transforming a efxmap to a tgtmap
%%% $Id: efxmap2tgtmap.elf,v 1.3 2013/06/03 20:25:14 csun Exp csun $


% ===================================
% ========== Definition =============
% ===================================


efxmap2tgtmap : efxmap -> tgtmap -> type.

efxmap2tgtmap/0 : efxmap2tgtmap efxmap/0 tgtmap/0.

efxmap2tgtmap/+
  : inner-efxmap`domain M S
    -> efxmap2tgtmap XM GM
    -> efxmap2tgtmap (efxmap/+ N M XM) (tgtmap/+ N S GM).


% =========================================
% =============== Theorems ================
% =========================================


%theorem false-implies-efxmap2tgtmap
  : forall* {XM} {GM}
    forall {V:void}
    exists {T: efxmap2tgtmap XM GM}
    true.

%worlds () (false-implies-efxmap2tgtmap _ _).
%total {} (false-implies-efxmap2tgtmap _ _).


%theorem efxmap2tgtmap-respects-eq
  : forall* {XM} {GM} {XMP} {GMP}
    forall {T: efxmap2tgtmap XM GM}
    {E: efxmap`eq XM XMP}
    {E: tgtmap`eq GM GMP}
    exists {TP: efxmap2tgtmap XMP GMP}
    true.

- : efxmap2tgtmap-respects-eq efxmap2tgtmap/0 _ _ efxmap2tgtmap/0.

- : efxmap2tgtmap-respects-eq (efxmap2tgtmap/+ D T)
    efxmap`eq/ tgtmap`eq/ (efxmap2tgtmap/+ D T) .

%worlds () (efxmap2tgtmap-respects-eq _ _ _ _).
%total {} (efxmap2tgtmap-respects-eq _ _ _ _).


%theorem efxmap2tgtmap-total*
  : forall {XM}
    exists {GM} {T: efxmap2tgtmap XM GM}
    true.

%abbrev efxmap2tgtmap-total = efxmap2tgtmap-total* _ _.

- : efxmap2tgtmap-total* efxmap/0 tgtmap/0 efxmap2tgtmap/0.

- : efxmap2tgtmap-total* (efxmap/+ N M XM) (tgtmap/+ N S GM)
    (efxmap2tgtmap/+ DM-M=S XM=>GM)
    <- inner-efxmap`domain-total* M S DM-M=S
    <- efxmap2tgtmap-total* XM GM XM=>GM.

%worlds () (efxmap2tgtmap-total* _ _ _).
%total (M) (efxmap2tgtmap-total* M _ _).


%theorem efxmap2tgtmap-unique
  : forall* {XM} {GM} {XMP} {GMP}
    forall {T: efxmap2tgtmap XM GM}
    {TP: efxmap2tgtmap XMP GMP} {E: efxmap`eq XM XMP}
    exists {E: tgtmap`eq GM GMP}
    true.

- : efxmap2tgtmap-unique efxmap2tgtmap/0 efxmap2tgtmap/0 efxmap`eq/ tgtmap`eq/.

- : efxmap2tgtmap-unique
    (efxmap2tgtmap/+ M-DM1 XM2GM1)
    (efxmap2tgtmap/+ M-DM2 XM2GM2) XM-EQ GM-EQ
    <- efxmap`map/+-preserves-eq-converse XM-EQ N-EQ M-EQ XM1-EQ
    <- efxmap2tgtmap-unique XM2GM1 XM2GM2 XM1-EQ GM1-EQ
    <- inner-efxmap`domain-unique M-DM1 M-DM2 M-EQ S-EQ
    <- tgtmap`map/+-preserves-eq N-EQ S-EQ GM1-EQ GM-EQ.

%worlds () (efxmap2tgtmap-unique _ _ _ _).
%total (D) (efxmap2tgtmap-unique D _ _ _).


%theorem efxmap2tgtmap-inversion
  : forall* {N1} {N2} {M} {XM} {GM} {S}
    forall {T: efxmap2tgtmap (efxmap/+ N1 M XM) (tgtmap/+ N2 S GM)}
    {E: nat`eq N1 N2}
    exists {DM: inner-efxmap`domain M S} {T: efxmap2tgtmap XM GM}
    true.

- : efxmap2tgtmap-inversion (efxmap2tgtmap/+ DM XM=>GM) _ DM XM=>GM.

%worlds () (efxmap2tgtmap-inversion _ _ _ _).
%total {} (efxmap2tgtmap-inversion _ _ _ _).


%theorem nat`ne-efxmap2tgtmap-implies-false
  : forall* {N1} {N2} {M} {S} {XM} {GM}
    forall {NE: nat`ne N1 N2}
    {T: efxmap2tgtmap (efxmap/+ N1 M XM) (tgtmap/+ N2 S GM)}
    exists {V: void} true.

- : nat`ne-efxmap2tgtmap-implies-false (nat`ne/< GT) (efxmap2tgtmap/+ _ _) V
    <- nat`gt-anti-reflexive GT V.

- : nat`ne-efxmap2tgtmap-implies-false (nat`ne/> GT) (efxmap2tgtmap/+ _ _) V
    <- nat`gt-anti-reflexive GT V.

%worlds () (nat`ne-efxmap2tgtmap-implies-false _ _ _).
%total {} (nat`ne-efxmap2tgtmap-implies-false _ _ _).


%theorem shift-preserves-efxmap2tgtmap
  : forall* {XM} {GM} {XM1} {N}
    forall {T: efxmap2tgtmap XM GM}
    {SH: efxmap`shift N XM XM1}
    exists {GM1} {SH: tgtmap`shift N GM GM1}
    {T: efxmap2tgtmap XM1 GM1}
    true.

- : shift-preserves-efxmap2tgtmap
    efxmap2tgtmap/0 efxmap`shift/0 tgtmap/0 tgtmap`shift/0 efxmap2tgtmap/0.

- : shift-preserves-efxmap2tgtmap
    (efxmap2tgtmap/+ T D) (efxmap`shift/+ P)
    _ (tgtmap`shift/+ P) (efxmap2tgtmap/+ T D).

%worlds () (shift-preserves-efxmap2tgtmap _ _ _ _ _).
%total {} (shift-preserves-efxmap2tgtmap _ _ _ _ _).


%theorem shift-preserves-efxmap2tgtmap*
  : forall* {XM} {GM} {XMs} {GMs} {N}
    forall {T: efxmap2tgtmap XM GM}
    {SH: efxmap`shift N XM XMs}
    {SH: tgtmap`shift N GM GMs}
    exists {Ts: efxmap2tgtmap XMs GMs}
    true.

- : shift-preserves-efxmap2tgtmap* efxmap2tgtmap/0 _ _ efxmap2tgtmap/0.

- : shift-preserves-efxmap2tgtmap*
    (efxmap2tgtmap/+ T D) _ _ (efxmap2tgtmap/+ T D).

%worlds () (shift-preserves-efxmap2tgtmap* _ _ _ _).
%total {} (shift-preserves-efxmap2tgtmap* _ _ _ _).


%theorem shift-preserves-efxmap2tgtmap-converse
  : forall* {XM} {XMP} {GMP} {N}
    forall {TP: efxmap2tgtmap XMP GMP}
    {SH: efxmap`shift N XM XMP}
    exists {GM} {SH: tgtmap`shift N GM GMP}
    {T: efxmap2tgtmap XM GM}
    true.

- : shift-preserves-efxmap2tgtmap-converse
    efxmap2tgtmap/0 efxmap`shift/0 tgtmap/0 tgtmap`shift/0 efxmap2tgtmap/0.

- : shift-preserves-efxmap2tgtmap-converse
    (efxmap2tgtmap/+ T D) (efxmap`shift/+ P) _ (tgtmap`shift/+ P)
    (efxmap2tgtmap/+ T D).

%worlds () (shift-preserves-efxmap2tgtmap-converse _ _ _ _ _).
%total {} (shift-preserves-efxmap2tgtmap-converse _ _ _ _ _).


%theorem shift-preserves-efxmap2tgtmap-converse*
  : forall* {XM} {GM} {XMP} {GMP} {N}
    forall {TP: efxmap2tgtmap XMP GMP}
    {SH: efxmap`shift N XM XMP}
    {SH: tgtmap`shift N GM GMP}
    exists {T: efxmap2tgtmap XM GM}
    true.

- : shift-preserves-efxmap2tgtmap-converse* efxmap2tgtmap/0 _ _ efxmap2tgtmap/0.

- : shift-preserves-efxmap2tgtmap-converse*
    (efxmap2tgtmap/+ T D) (efxmap`shift/+ P1) (tgtmap`shift/+ P2) T2
    <- nat`plus-left-cancels P1 P2 nat`eq/ nat`eq/ E
    <- tgtmap`map/+-preserves-eq E set`eq/ tgtmap`eq/ ME
    <- efxmap2tgtmap-respects-eq (efxmap2tgtmap/+ T D) efxmap`eq/ ME T2.

%worlds () (shift-preserves-efxmap2tgtmap-converse* _ _ _ _).
%total {} (shift-preserves-efxmap2tgtmap-converse* _ _ _ _).


%theorem efxmap2tgtmap-preserves-size
  : forall* {XM} {GM} {N}
    forall {T: efxmap2tgtmap XM GM} {SZ: efxmap`size XM N}
    exists {SZ: tgtmap`size GM N} true.

- : efxmap2tgtmap-preserves-size efxmap2tgtmap/0 efxmap`size/0 tgtmap`size/0.

- : efxmap2tgtmap-preserves-size
    (efxmap2tgtmap/+ _ T) (efxmap`size/+ SZ1) (tgtmap`size/+ SZ2)
    <- efxmap2tgtmap-preserves-size T SZ1 SZ2.

%worlds () (efxmap2tgtmap-preserves-size _ _ _).
%total (T) (efxmap2tgtmap-preserves-size T _ _).


%theorem efxmap2tgtmap-preserves-size-converse
  : forall* {XM} {GM} {N}
    forall {T: efxmap2tgtmap XM GM} {SZ: tgtmap`size GM N}
    exists {SZ: efxmap`size XM N} true.

- : efxmap2tgtmap-preserves-size-converse
    efxmap2tgtmap/0 tgtmap`size/0 efxmap`size/0.

- : efxmap2tgtmap-preserves-size-converse
    (efxmap2tgtmap/+ _ T) (tgtmap`size/+ SZ1) (efxmap`size/+ SZ2)
    <- efxmap2tgtmap-preserves-size-converse T SZ1 SZ2.

%worlds () (efxmap2tgtmap-preserves-size-converse _ _ _).
%total (T) (efxmap2tgtmap-preserves-size-converse T _ _).


%theorem efxmap2tgtmap-preserves-lookup
  : forall* {XM} {GM} {N} {M}
    forall {T: efxmap2tgtmap XM GM}
    {L: efxmap`lookup XM N M}
    exists {S} {L: tgtmap`lookup GM N S}
    {DM: inner-efxmap`domain M S}
    true.

- : efxmap2tgtmap-preserves-lookup
    (efxmap2tgtmap/+ DM T) (efxmap`lookup/= nat`eq/)
    S (tgtmap`lookup/= nat`eq/) DM.

- : efxmap2tgtmap-preserves-lookup
    (efxmap2tgtmap/+ _ T) (efxmap`lookup/> L P)
    S (tgtmap`lookup/> L2 P) DM
    <- efxmap2tgtmap-preserves-lookup T L _ L2 DM.

%worlds () (efxmap2tgtmap-preserves-lookup _ _ _ _ _).
%total (T) (efxmap2tgtmap-preserves-lookup T _ _ _ _).


%theorem efxmap2tgtmap-preserves-lookup-converse
  : forall* {XM} {GM} {N} {S}
    forall {T: efxmap2tgtmap XM GM}
    {L: tgtmap`lookup GM N S}
    exists {M:inner-efxmap} {L: efxmap`lookup XM N M}
    {DM: inner-efxmap`domain M S}
    true.

- : efxmap2tgtmap-preserves-lookup-converse
    (efxmap2tgtmap/+ DM T) (tgtmap`lookup/= nat`eq/)
    S (efxmap`lookup/= nat`eq/) DM.

- : efxmap2tgtmap-preserves-lookup-converse
    (efxmap2tgtmap/+ _ T) (tgtmap`lookup/> L P)
    S (efxmap`lookup/> L2 P) DM
    <- efxmap2tgtmap-preserves-lookup-converse T L _ L2 DM.

%worlds () (efxmap2tgtmap-preserves-lookup-converse _ _ _ _ _).
%total (T) (efxmap2tgtmap-preserves-lookup-converse T _ _ _ _).


%theorem efxmap2tgtmap-preserves-fresh
  : forall* {XM} {GM} {N}
    forall {T: efxmap2tgtmap XM GM} {F: efxmap`fresh XM N}
    exists {F: tgtmap`fresh GM N} true.

- : efxmap2tgtmap-preserves-fresh
    efxmap2tgtmap/0 efxmap`fresh/0 tgtmap`fresh/0.

- : efxmap2tgtmap-preserves-fresh
    (efxmap2tgtmap/+ _ _) (efxmap`fresh/< GT) (tgtmap`fresh/< GT).

- : efxmap2tgtmap-preserves-fresh
    (efxmap2tgtmap/+ _ T) (efxmap`fresh/> F1 P) (tgtmap`fresh/> F2 P)
    <- efxmap2tgtmap-preserves-fresh T F1 F2.

%worlds () (efxmap2tgtmap-preserves-fresh _ _ _).
%total (T) (efxmap2tgtmap-preserves-fresh T _ _).


%theorem efxmap2tgtmap-preserves-fresh-converse
  : forall* {XM} {GM} {N}
    forall {T: efxmap2tgtmap XM GM} {F: tgtmap`fresh GM N}
    exists {F: efxmap`fresh XM N} true.

- : efxmap2tgtmap-preserves-fresh-converse
    efxmap2tgtmap/0 tgtmap`fresh/0 efxmap`fresh/0.

- : efxmap2tgtmap-preserves-fresh-converse
    (efxmap2tgtmap/+ _ _) (tgtmap`fresh/< GT) (efxmap`fresh/< GT).

- : efxmap2tgtmap-preserves-fresh-converse
    (efxmap2tgtmap/+ _ T)  (tgtmap`fresh/> F1 P) (efxmap`fresh/> F2 P)
    <- efxmap2tgtmap-preserves-fresh-converse T F1 F2.

%worlds () (efxmap2tgtmap-preserves-fresh-converse _ _ _).
%total (T) (efxmap2tgtmap-preserves-fresh-converse T _ _).


%theorem update-preserves-efxmap2tgtmap
  : forall* {XM} {GM} {N} {M} {XMP} {S}
    forall {T: efxmap2tgtmap XM GM}
    {U: efxmap`update XM N M XMP}
    {DM: inner-efxmap`domain M S}
    exists {GMP} {U: tgtmap`update GM N S GMP}
    {TP: efxmap2tgtmap XMP GMP}
    true.

- : update-preserves-efxmap2tgtmap
    _ efxmap`update/0 D _ tgtmap`update/0 (efxmap2tgtmap/+ D efxmap2tgtmap/0).

- : update-preserves-efxmap2tgtmap
    (efxmap2tgtmap/+ _ T) (efxmap`update/= nat`eq/) DM
    _ (tgtmap`update/= nat`eq/) (efxmap2tgtmap/+ DM T).

- : update-preserves-efxmap2tgtmap
    (efxmap2tgtmap/+ DMP T) (efxmap`update/< P) DM
    _ (tgtmap`update/< P) (efxmap2tgtmap/+ DM (efxmap2tgtmap/+ DMP T)).

- : update-preserves-efxmap2tgtmap
    (efxmap2tgtmap/+ DMP T) (efxmap`update/> U1 P) DM
    _ (tgtmap`update/> U2 P) (efxmap2tgtmap/+ DMP T2)
    <- update-preserves-efxmap2tgtmap T U1 DM _ U2 T2.

%worlds () (update-preserves-efxmap2tgtmap _ _ _ _ _ _).
%total (T) (update-preserves-efxmap2tgtmap T _ _ _ _ _).


%theorem update-preserves-efxmap2tgtmap*
  : forall* {XM} {GM} {N} {M} {S} {XMP} {GMP}
    forall {T: efxmap2tgtmap XM GM}
    {U: efxmap`update XM N M XMP}
    {U: tgtmap`update GM N S GMP}
    {DM: inner-efxmap`domain M S}
    exists {TP: efxmap2tgtmap XMP GMP}
    true.
%mode update-preserves-efxmap2tgtmap* +T1 +U1 +U2 +D -T2.
%worlds () (update-preserves-efxmap2tgtmap* _ _ _ _ _).
%trustme %total { } (update-preserves-efxmap2tgtmap* _ _ _ _ _).


%theorem efxmap2tgtmap-preserves-domain
  : forall* {GM} {XM} {S}
    forall {XM=>GM: efxmap2tgtmap XM GM}
    {DM-XM: efxmap`domain XM S}
    exists {DM-GM: tgtmap`domain GM S}
    true.

- : efxmap2tgtmap-preserves-domain
    (efxmap2tgtmap/+ _ XM=>GM) (efxmap`domain/+ DM-XM) (tgtmap`domain/+ DM-GM)
    <- efxmap2tgtmap-preserves-domain XM=>GM DM-XM DM-GM.

- : efxmap2tgtmap-preserves-domain efxmap2tgtmap/0 _ tgtmap`domain/0.

%worlds () (efxmap2tgtmap-preserves-domain _ _ _).
%total (T) (efxmap2tgtmap-preserves-domain T _ _).


%theorem efxmap2tgtmap-preserves-domain-converse
  : forall* {GM} {XM} {S}
    forall {XM=>GM: efxmap2tgtmap XM GM}
    {DM-GM: tgtmap`domain GM S}
    exists {DM-XM: efxmap`domain XM S}
    true.

- : efxmap2tgtmap-preserves-domain-converse
    (efxmap2tgtmap/+ _ XM=>GM) (tgtmap`domain/+ DM-GM) (efxmap`domain/+ DM-XM)
    <- efxmap2tgtmap-preserves-domain-converse XM=>GM DM-GM DM-XM.

- : efxmap2tgtmap-preserves-domain-converse efxmap2tgtmap/0 _ efxmap`domain/0.

%worlds () (efxmap2tgtmap-preserves-domain-converse _ _ _).
%total (T) (efxmap2tgtmap-preserves-domain-converse T _ _).


%theorem efxmap2tgtmap-preserves-leq
  : forall* {XM} {XMP} {GM} {GMP}
    forall {LE: efxmap`leq XM XMP}
    {T: efxmap2tgtmap XM GM}
    {TP: efxmap2tgtmap XMP GMP}
    exists {LE: tgtmap`leq GM GMP}
    true.

%theorem efxmap2tgtmap-preserves-leq/L
  : forall* {XM} {XMP} {GM} {GMP}
    forall {N} {SZ: efxmap`size XMP N}
    {LE: efxmap`leq XM XMP}
    {T: efxmap2tgtmap XM GM}
    {TP: efxmap2tgtmap XMP GMP}
    exists {LE: tgtmap`leq GM GMP}
    true.

- : efxmap2tgtmap-preserves-leq/L _ _ efxmap`leq/0 _ _ tgtmap`leq/0.

- : efxmap2tgtmap-preserves-leq/L _ (efxmap`size/+ SZ2)
    (efxmap`leq/= XM1<=XM2 M1<=M2 EQ)
    (efxmap2tgtmap/+ DM-M1=S1 XM1=>GM1)
    (efxmap2tgtmap/+ DM-M2=S2 XM2=>GM2)
    (tgtmap`leq/= GM1<=GM2 S1<=S2 EQ)
    <- inner-efxmap`domain-preserves-leq* M1<=M2 DM-M1=S1 DM-M2=S2 S1<=S2
    <- efxmap2tgtmap-preserves-leq/L
      _ SZ2 XM1<=XM2 XM1=>GM1 XM2=>GM2 GM1<=GM2.

- : efxmap2tgtmap-preserves-leq/L _ (efxmap`size/+ SZ2)
    (efxmap`leq/> N3D1XM1<=XM2 P) N1D1XM1=>GM1
    (efxmap2tgtmap/+ _ XM2=>GM2) GM1<=GM2
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- efxmap`shift-total SH-XM2=XM2P
    <- efxmap`shift-preserves-leq*
      N3D1XM1<=XM2 (efxmap`shift/+ P2) SH-XM2=XM2P N1D1XM1<=XM2P
    <- tgtmap`shift-total SH-GM2=GM2P
    <- shift-preserves-efxmap2tgtmap*
      XM2=>GM2 SH-XM2=XM2P SH-GM2=GM2P XM2P=>GM2P
    <- efxmap`shift-preserves-size SZ2 SH-XM2=XM2P SZ2P
    <- efxmap2tgtmap-preserves-leq/L _ SZ2P
      N1D1XM1<=XM2P N1D1XM1=>GM1 XM2P=>GM2P GM1<=GM2P
    <- tgtmap`shift-implies-update SH-GM2=GM2P UD
    <- tgtmap`shift-implies-fresh SH-GM2=GM2P FS
    <- tgtmap`fresh-update-implies-leq FS UD GM2P<=GM2
    <- tgtmap`leq-transitive GM1<=GM2P GM2P<=GM2 GM1<=GM2.

- : efxmap2tgtmap-preserves-leq XM<=XMP XM=>GM XMP=>GMP GM<=GMP
    <- efxmap`size-total SZ
    <- efxmap2tgtmap-preserves-leq/L N SZ XM<=XMP XM=>GM XMP=>GMP GM<=GMP.

%worlds () (efxmap2tgtmap-preserves-leq/L _ _ _ _ _ _).
%total (N) (efxmap2tgtmap-preserves-leq/L N _ _ _ _ _).

%worlds () (efxmap2tgtmap-preserves-leq _ _ _ _).
%total {} (efxmap2tgtmap-preserves-leq _ _ _ _).


%theorem fresh-update-preserves-efxmap2tgtmap-converse*
  : forall* {XM} {GM} {XMP} {GMP} {N} {M} {S}
    forall {T: efxmap2tgtmap XM GM}
    {F: efxmap`fresh XMP N}
    {U: efxmap`update XMP N M XM}
    {F: tgtmap`fresh GMP N}
    {U: tgtmap`update GMP N S GM}
    exists {TP: efxmap2tgtmap XMP GMP}
    true.

- : fresh-update-preserves-efxmap2tgtmap-converse*
    _ _ _ FS (tgtmap`update/= nat`eq/) XM=>GM
    <- tgtmap`fresh-contradiction FS V
    <- false-implies-efxmap2tgtmap V XM=>GM.

%theorem fresh-update-preserves-efxmap2tgtmap-converse*/0
  : forall* {M} forall {SZ: tgtmap`size M z}
    exists {E: tgtmap`eq M tgtmap/0} true.

- : fresh-update-preserves-efxmap2tgtmap-converse*/0 tgtmap`size/0 tgtmap`eq/.

%worlds () (fresh-update-preserves-efxmap2tgtmap-converse*/0 _ _).
%total {} (fresh-update-preserves-efxmap2tgtmap-converse*/0 _ _).

- : fresh-update-preserves-efxmap2tgtmap-converse* T1
    efxmap`fresh/0 efxmap`update/0 FS2 U2 XM=>GM
    <- efxmap2tgtmap-preserves-size T1 (efxmap`size/+ efxmap`size/0) SZ2
    <- tgtmap`fresh-update-increases-size-converse SZ2 FS2 U2 SZ1
    <- fresh-update-preserves-efxmap2tgtmap-converse*/0 SZ1 EQ
    <- tgtmap`eq-symmetric EQ EQs
    <- efxmap2tgtmap-respects-eq efxmap2tgtmap/0 efxmap`eq/ EQs XM=>GM.

- : fresh-update-preserves-efxmap2tgtmap-converse* XM=>GM
    (efxmap`fresh/< GT1) U1 (tgtmap`fresh/< GT2) U2 XM=>GMsc
    <- nat`gt-implies-plus GT1 _ P1
    <- nat`gt-implies-plus GT2 _ P2
    <- efxmap`update/<-inversion U1 P1 EQ1
    <- tgtmap`update/<-inversion U2 P2 EQ2
    <- efxmap`eq-symmetric EQ1 EQ1s
    <- tgtmap`eq-symmetric EQ2 EQ2s
    <- efxmap2tgtmap-respects-eq XM=>GM EQ1s EQ2s XM=>GMx
    <- efxmap2tgtmap-inversion XM=>GMx nat`eq/ DMs XM=>GMs
    <- nat`plus-swap-succ P1 P1s
    <- nat`plus-swap-succ P2 P2s
    <- nat`plus-commutative P1s P1sc
    <- nat`plus-commutative P2s P2sc
    <- shift-preserves-efxmap2tgtmap*
      XM=>GMs (efxmap`shift/+ P1sc) (tgtmap`shift/+ P2sc) XM=>GMsc.

- : fresh-update-preserves-efxmap2tgtmap-converse*
    T1 (efxmap`fresh/< GT1) U1 tgtmap`fresh/0 tgtmap`update/0 XM=>GM
    <- nat`gt-implies-plus GT1 _ P1
    <- efxmap`update/<-inversion U1 P1 EQ1
    <- efxmap`eq-symmetric EQ1 EQ1s
    <- efxmap2tgtmap-respects-eq T1 EQ1s tgtmap`eq/ T2
    <- efxmap2tgtmap-inversion T2 nat`eq/ _ T3
    <- nat`plus-swap-succ P1 P1s
    <- nat`plus-commutative P1s P1sc
    <- shift-preserves-efxmap2tgtmap*
      T3 (efxmap`shift/+ P1sc) tgtmap`shift/0 XM=>GM.

- : fresh-update-preserves-efxmap2tgtmap-converse*
    T1 (efxmap`fresh/< GT1) U1 (tgtmap`fresh/> _ P2) U2 XM=>GM
    <- nat`gt-implies-plus GT1 _ P1
    <- efxmap`update/<-inversion U1 P1 EQ1
    <- tgtmap`update/>-inversion U2 P2 _ U2R EQ2
    <- efxmap`eq-symmetric EQ1 EQ1s
    <- tgtmap`eq-symmetric EQ2 EQ2s
    <- efxmap2tgtmap-respects-eq T1 EQ1s EQ2s T2
    <- nat`plus-implies-gt P2 nat`eq/ N1>N3
    <- nat`ne-efxmap2tgtmap-implies-false (nat`ne/> N1>N3) T2 V
    <- false-implies-efxmap2tgtmap V XM=>GM.

%theorem fresh-update-preserves-efxmap2tgtmap-converse*/>
  : forall* {N1} {N2} {M} {S} {XM} {GM} {C1} {C2}
    {XMs} {GMs} {N} {M1} {S1} {CC}
    forall {T: efxmap2tgtmap (efxmap/+ N1 M XM) (tgtmap/+ N2 S GM)}
    {P: nat`plus (s C1) N1 N} {F: efxmap`fresh XMs C1}
    {U: efxmap`update XMs C1 M1 XM}
    {P: nat`plus (s C2) N2 N}
    {F: tgtmap`fresh GMs C2}
    {U: tgtmap`update GMs C2 S1 GM}
    {CMP: nat`compare C1 C2 CC}
    exists {T: efxmap2tgtmap (efxmap/+ N1 M XMs) (tgtmap/+ N2 S GMs)}
    true.

- : fresh-update-preserves-efxmap2tgtmap-converse*/>
    T1 P1 F1 U1 P2 F2 U2 nat`compare/= XM=>GM
    <- nat`plus-left-cancels P1 P2 nat`eq/ nat`eq/ N1=N2
    <- efxmap2tgtmap-inversion T1 N1=N2 DM T1P
    <- fresh-update-preserves-efxmap2tgtmap-converse* T1P F1 U1 F2 U2 T2
    <- tgtmap`map/+-preserves-eq N1=N2 set`eq/ tgtmap`eq/ EQ
    <- efxmap2tgtmap-respects-eq (efxmap2tgtmap/+ DM T2) efxmap`eq/ EQ XM=>GM.

- : fresh-update-preserves-efxmap2tgtmap-converse*/>
    T1 C1+1+N1=N _ _ C2+1+N2=N _ _ (nat`compare/< C2>C1) XM=>GM
    <- gt-implies-plus C2>C1 D D+1+C1=C2
    <- plus-swap-succ C2+1+N2=N C2+N2+1=N
    <- plus-swap-succ D+1+C1=C2 D+C1+1=C2
    <- plus-commutative D+C1+1=C2 C1+1+D=C2
    <- plus-associative C1+1+D=C2 C2+N2+1=N X D+N2+1=X C1+1+X=N
    <- plus-left-cancels C1+1+X=N C1+1+N1=N nat`eq/ nat`eq/ X=N1
    <- plus-swap-succ-converse D+N2+1=X D+1+N2=X
    <- plus-respects-eq D+1+N2=X nat`eq/ nat`eq/ X=N1 D+1+N2=N1
    <- nat`plus-implies-gt D+1+N2=N1 nat`eq/ N1>N2
    <- nat`ne-efxmap2tgtmap-implies-false (nat`ne/> N1>N2) T1 V
    <- false-implies-efxmap2tgtmap V XM=>GM.

- : fresh-update-preserves-efxmap2tgtmap-converse*/>
    T1 P1 F1 U1 P2 F2 U2 (nat`compare/> C1>C2) XM=>GM
    <- nat`succ-preserves-gt C1>C2 SC1>SC2
    <- nat`plus-left-reverses-gt P1 P2 SC1>SC2 nat`eq/ N2>N1
    <- nat`ne-efxmap2tgtmap-implies-false (nat`ne/< N2>N1) T1 V
    <- false-implies-efxmap2tgtmap V XM=>GM.

- : fresh-update-preserves-efxmap2tgtmap-converse* XM=>GM
    (efxmap`fresh/> FS1 P1) U1 (tgtmap`fresh/> FS2 P2) U2 XM=>GMsc
    <- efxmap`update/>-inversion U1 P1 _ U1s EQ1
    <- tgtmap`update/>-inversion U2 P2 _ U2s EQ2
    <- efxmap`eq-symmetric EQ1 EQ1s
    <- tgtmap`eq-symmetric EQ2 EQ2s
    <- efxmap2tgtmap-respects-eq XM=>GM EQ1s EQ2s XM=>GMs
    <- nat`compare-total C
    <- fresh-update-preserves-efxmap2tgtmap-converse*/>
      XM=>GMs P1 FS1 U1s P2 FS2 U2s C XM=>GMsc.

- : fresh-update-preserves-efxmap2tgtmap-converse*
    T1 (efxmap`fresh/> _ P1) U1 tgtmap`fresh/0 tgtmap`update/0 XM=>GM
    <- efxmap`update/>-inversion U1 P1 _ U1R EQ1
    <- efxmap`eq-symmetric EQ1 EQ1s
    <- efxmap2tgtmap-respects-eq T1 EQ1s tgtmap`eq/ T2
    <- nat`plus-implies-gt P1 nat`eq/ N1>N2
    <- nat`ne-efxmap2tgtmap-implies-false (nat`ne/< N1>N2) T2 V
    <- false-implies-efxmap2tgtmap V XM=>GM.

- : fresh-update-preserves-efxmap2tgtmap-converse*
    T1 (efxmap`fresh/> _ P1) U1 (tgtmap`fresh/< GT2) U2 XM=>GM
    <- efxmap`update/>-inversion U1 P1 _ U1R EQ1
    <- nat`gt-implies-plus GT2 _ P2
    <- tgtmap`update/<-inversion U2 P2 EQ2
    <- efxmap`eq-symmetric EQ1 EQ1s
    <- tgtmap`eq-symmetric EQ2 EQ2s
    <- efxmap2tgtmap-respects-eq T1 EQ1s EQ2s T2
    <- nat`plus-implies-gt P1 nat`eq/ N2>N1
    <- nat`ne-efxmap2tgtmap-implies-false (nat`ne/< N2>N1) T2 V
    <- false-implies-efxmap2tgtmap V XM=>GM.

%worlds () (fresh-update-preserves-efxmap2tgtmap-converse* _ _ _ _ _ _)
(fresh-update-preserves-efxmap2tgtmap-converse*/> _ _ _ _ _ _ _ _ _).

%total (F2a F2b)
(fresh-update-preserves-efxmap2tgtmap-converse* _ F1a _ F2a _ _)
(fresh-update-preserves-efxmap2tgtmap-converse*/> _ _ F1b _ _ F2b _ _ _).


%theorem fresh-update-preserves-efxmap2tgtmap-converse
  : forall* {XM} {GM} {XMP} {N} {M}
    forall {T: efxmap2tgtmap XM GM}
    {F: efxmap`fresh XMP N}
    {U: efxmap`update XMP N M XM}
    exists {GMP} {S} {DM: inner-efxmap`domain M S}
    {F: tgtmap`fresh GMP N}
    {U: tgtmap`update GMP N S GM}
    {TP: efxmap2tgtmap XMP GMP}
    true.

- : fresh-update-preserves-efxmap2tgtmap-converse
    XM=>GM N!<XMP XMP+N+M=XM GMPs S DM-M=S N!<GMPs GMPs+N+S=GM XMP=>GMPs
    <- efxmap2tgtmap-total XMP=>GMPs
    <- inner-efxmap`domain-total DM-M=S
    <- efxmap2tgtmap-preserves-fresh XMP=>GMPs N!<XMP N!<GMPs
    <- update-preserves-efxmap2tgtmap XMP=>GMPs XMP+N+M=XM DM-M=S
      GMs GMPs+N+S=GMs XM=>GMs
    <- efxmap2tgtmap-unique XM=>GMs XM=>GM efxmap`eq/ GMs=GM
    <- tgtmap`update-respects-eq GMPs+N+S=GMs
      tgtmap`eq/ nat`eq/ set`eq/ GMs=GM GMPs+N+S=GM.

%worlds () (fresh-update-preserves-efxmap2tgtmap-converse _ _ _ _ _ _ _ _ _).
%total {} (fresh-update-preserves-efxmap2tgtmap-converse _ _ _ _ _ _ _ _ _).


%theorem tgtmap2efxmap-implies-efxmap2tgtmap
  : forall* {XM} {GM} {X}
    forall {T: tgtmap2efxmap GM X XM}
    exists {T: efxmap2tgtmap XM GM}
    true.

- : tgtmap2efxmap-implies-efxmap2tgtmap
    tgtmap2efxmap/0 efxmap2tgtmap/0.

- : tgtmap2efxmap-implies-efxmap2tgtmap
    (tgtmap2efxmap/+ S=>M GM=>XM) (efxmap2tgtmap/+ DM-M=S XM=>GM)
    <- tgtmap2efxmap-implies-efxmap2tgtmap GM=>XM XM=>GM
    <- set2inner-efxmap-implies-domain S=>M DM-M=S.

%worlds () (tgtmap2efxmap-implies-efxmap2tgtmap _ _).
%total (A) (tgtmap2efxmap-implies-efxmap2tgtmap A _).


%theorem join-preserves-efxmap2tgtmap
  : forall* {XM1} {GM1} {XM2} {GM2} {XM}
    forall {T1: efxmap2tgtmap XM1 GM1}
    {T2: efxmap2tgtmap XM2 GM2}
    {J: efxmap`join XM1 XM2 XM}
    exists {GM} {J: tgtmap`join GM1 GM2 GM}
    {T: efxmap2tgtmap XM GM}
    true.

- : join-preserves-efxmap2tgtmap
    efxmap2tgtmap/0 XM=>GM efxmap`join/L _ tgtmap`join/L XM=>GM.

- : join-preserves-efxmap2tgtmap
    XM=>GM efxmap2tgtmap/0 efxmap`join/R _ tgtmap`join/R XM=>GM.

- : join-preserves-efxmap2tgtmap
    (efxmap2tgtmap/+ DM-M1=S1 XM1=>GM1)
    (efxmap2tgtmap/+ DM-M2=S2 XM2=>GM2)
    (efxmap`join/= XM1UXM2=XM M1UM2=M nat`eq/)
    %{=>}% _ (tgtmap`join/= GM1UGM2=GM S1US2=S nat`eq/)
    (efxmap2tgtmap/+ DM-M=S XM=>GM)
    <- join-preserves-efxmap2tgtmap
      XM1=>GM1 XM2=>GM2 XM1UXM2=XM _ GM1UGM2=GM XM=>GM
    <- inner-efxmap`domain-total DM-M=S
    <- inner-efxmap`join-commute-domain
      M1UM2=M DM-M1=S1 DM-M2=S2 DM-M=S S1US2=S.

- : join-preserves-efxmap2tgtmap
    (efxmap2tgtmap/+ DM-M1=S1 XM1=>GM1) (efxmap2tgtmap/+ DM-M2=S2 XM2=>GM2)
    (efxmap`join/< J1 P) %{=>}% _ (tgtmap`join/< J2 P)
    (efxmap2tgtmap/+ DM-M1=S1 XM3=>GM3)
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- join-preserves-efxmap2tgtmap
      XM1=>GM1 (efxmap2tgtmap/+ DM-M2=S2 XM2=>GM2) J1 _ J2 XM3=>GM3.

- : join-preserves-efxmap2tgtmap
    (efxmap2tgtmap/+ DM-M1=S1 XM1=>GM1) (efxmap2tgtmap/+ DM-M2=S2 XM2=>GM2)
    (efxmap`join/> J1 P) %{=>}% _ (tgtmap`join/> J2 P)
    (efxmap2tgtmap/+ DM-M2=S2 XM3=>GM3)
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- join-preserves-efxmap2tgtmap
      (efxmap2tgtmap/+ DM-M1=S1 XM1=>GM1) XM2=>GM2 J1 _ J2 XM3=>GM3.

%worlds () (join-preserves-efxmap2tgtmap _ _ _ _ _ _).
%total (J) (join-preserves-efxmap2tgtmap _ _ J _ _ _).


%theorem join-preserves-efxmap2tgtmap*
  : forall* {XM1} {XM2} {GM1} {GM2} {XM} {GM}
    forall {T1: efxmap2tgtmap XM1 GM1} {T2: efxmap2tgtmap XM2 GM2}
    {J: efxmap`join XM1 XM2 XM} {J: tgtmap`join GM1 GM2 GM}
    exists {T: efxmap2tgtmap XM GM}
    true.

- : join-preserves-efxmap2tgtmap*
    XM1=>GM1 XM2=>GM2 XM1UXM2=XM GM1UGM2=GM XM=>GM
    <- join-preserves-efxmap2tgtmap
      XM1=>GM1 XM2=>GM2 XM1UXM2=XM _ GM1UGM2=GMP XM=>GMP
    <- tgtmap`join-deterministic
      GM1UGM2=GMP GM1UGM2=GM tgtmap`eq/ tgtmap`eq/ GMP=GM
    <- efxmap2tgtmap-respects-eq XM=>GMP efxmap`eq/ GMP=GM XM=>GM.

%worlds () (join-preserves-efxmap2tgtmap* _ _ _ _ _).
%total {} (join-preserves-efxmap2tgtmap* _ _ _ _ _).


%theorem set2inner-efxmap-preserves-disjoint
  : forall* {M1} {M2} {S} {X} {M1P}
    forall {DJ: inner-efxmap`disjoint M1 M2}
    {DM: inner-efxmap`domain M1 S}
    {T: set2inner-efxmap S X M1P}
    exists {DJ: inner-efxmap`disjoint M1P M2}
    true.

- : set2inner-efxmap-preserves-disjoint
    M1^M2 DM-M1=S S+X=>M1P M1P^M2
    <- inner-efxmap`domain-total DM-M2=S2
    <- inner-efxmap`domain-preserves-disjoint M1^M2 DM-M1=S DM-M2=S2 S^S2
    <- set2inner-efxmap-implies-domain S+X=>M1P DM-M1P=S
    <- inner-efxmap`domain-preserves-disjoint-converse
      S^S2 DM-M1P=S DM-M2=S2 M1P^M2.

%worlds () (set2inner-efxmap-preserves-disjoint _ _ _ _).
%total {} (set2inner-efxmap-preserves-disjoint _ _ _ _).


%theorem efxmap2tgtmap-preserves-deep-disjoint/L
  : forall* {XM1} {XM2} {GM1} {X} {XM1P}
    forall {N1} {SZ: efxmap`size XM1 N1}
    {N2} {SZ: efxmap`size XM2 N2}
    {DJ: efxmap`deep-disjoint XM1 XM2}
    {T: efxmap2tgtmap XM1 GM1}
    {T: tgtmap2efxmap GM1 X XM1P}
    exists {DJ: efxmap`deep-disjoint XM1P XM2}
    true.

- : efxmap2tgtmap-preserves-deep-disjoint/L _ _ _ _
    efxmap`deep-disjoint/L _ _ efxmap`deep-disjoint/L.

- : efxmap2tgtmap-preserves-deep-disjoint/L _ _ _ _
    efxmap`deep-disjoint/R _ _ efxmap`deep-disjoint/R.

- : efxmap2tgtmap-preserves-deep-disjoint/L
    _ (efxmap`size/+ SZ1) _ (efxmap`size/+ SZ2)
    (efxmap`deep-disjoint/= XM1^XM2 M1^M2 nat`eq/)
    (efxmap2tgtmap/+ DM-M1=S XM1=>GM1) (tgtmap2efxmap/+ S+X=>M1P GM1+X=>XM1P)
    (efxmap`deep-disjoint/= XM1P^XM2 M1P^M2 nat`eq/)
    <- efxmap2tgtmap-preserves-deep-disjoint/L _ SZ1 _ SZ2
      XM1^XM2 XM1=>GM1 GM1+X=>XM1P XM1P^XM2
    <- set2inner-efxmap-preserves-disjoint M1^M2 DM-M1=S S+X=>M1P M1P^M2.

- : efxmap2tgtmap-preserves-deep-disjoint/L
    _ (efxmap`size/+ SZ1) _ (efxmap`size/+ SZ2)
    (efxmap`deep-disjoint/< XM1^N2XM2 SN1+N2=N3)
    (efxmap2tgtmap/+ DM-M1=S XM1=>GM1) (tgtmap2efxmap/+ S+X=>M1P GM1+X=>XM1P)
    (efxmap`deep-disjoint/< XM1P^N2XM2 SN1+N2=N3)
    <- efxmap2tgtmap-preserves-deep-disjoint/L _ SZ1 _ (efxmap`size/+ SZ2)
      XM1^N2XM2 XM1=>GM1 GM1+X=>XM1P XM1P^N2XM2.

- : efxmap2tgtmap-preserves-deep-disjoint/L
    _ (efxmap`size/+ SZ1) _ (efxmap`size/+ SZ2)
    (efxmap`deep-disjoint/> N1XM1^XM2 SN1+N2=N3)
    (efxmap2tgtmap/+ DM-M1=S XM1=>GM1) (tgtmap2efxmap/+ S+X=>M1P GM1+X=>XM1P)
    (efxmap`deep-disjoint/> YY SN1+N2=N3)
    <- nat`plus-swap-succ SN1+N2=N3 N1+SN2=N3
    <- nat`plus-commutative N1+SN2=N3 SN2+N1=N3
    <- efxmap`shift-total SH
    <- efxmap`shift-preserves-size SZ2 SH SZ2P
    <- efxmap`shift-preserves-deep-disjoint
      N1XM1^XM2 (efxmap`shift/+ SN2+N1=N3) SH N3XM1^XM2
    <- efxmap2tgtmap-preserves-deep-disjoint/L
      _ (efxmap`size/+ SZ1) _ SZ2P
      N3XM1^XM2 (efxmap2tgtmap/+ DM-M1=S XM1=>GM1)
      (tgtmap2efxmap/+ S+X=>M1P GM1+X=>XM1P) XM1P^XM2
    <- efxmap`shift-preserves-deep-disjoint-converse
      XM1P^XM2 (efxmap`shift/+ SN2+N1=N3) SH YY.

%worlds () (efxmap2tgtmap-preserves-deep-disjoint/L _ _ _ _ _ _ _ _).
%total {N1 N2} (efxmap2tgtmap-preserves-deep-disjoint/L N1 _ N2 _ _ _ _ _).


%{
We have two efxmaps that contains same entries except efx attached
to each entry may be different. Now we need to show if one of them
is disjoint with another efxmap, then so is the other one.
}%
%theorem efxmap2tgtmap-preserves-deep-disjoint
  : forall* {XM1} {XM2} {GM1} {X} {XM1P}
    forall {DJ: efxmap`deep-disjoint XM1 XM2}
    {T1: efxmap2tgtmap XM1 GM1}
    {T: tgtmap2efxmap GM1 X XM1P}
    exists {DJ: efxmap`deep-disjoint XM1P XM2}
    true.

- : efxmap2tgtmap-preserves-deep-disjoint DJ1 T1 T2 DJ2
    <- efxmap`size-total SZ1
    <- efxmap`size-total SZ2
    <- efxmap2tgtmap-preserves-deep-disjoint/L _ SZ1 _ SZ2 DJ1 T1 T2 DJ2.

%worlds () (efxmap2tgtmap-preserves-deep-disjoint _ _ _ _).
%total {} (efxmap2tgtmap-preserves-deep-disjoint _ _ _ _).