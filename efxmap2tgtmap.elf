%%e Transformation from efxmap to tgtmap

% ===================================
% ========== Definition =============
% ===================================

efxmap2tgtmap : efxmap -> tgtmap -> type.

efxmap2tgtmap/0 : efxmap2tgtmap efxmap/0 tgtmap/0.

efxmap2tgtmap/U
  : efxmap2tgtmap MP GP
    -> inner-efxmap`domain D S
    -> efxmap`fresh MP N
    -> efxmap`update MP N D M
    -> tgtmap`update GP N S G
    -> efxmap2tgtmap M G.


% ====================================
% ============= Theorems =============
% ====================================

%theorem false-implies-efxmap2tgtmap :
	forall*	{M} {MP}
	forall	{F: void}
	exists	{A: efxmap2tgtmap M MP}
	true.

%worlds () (false-implies-efxmap2tgtmap _ _).
%total { } (false-implies-efxmap2tgtmap _ _).


%theorem efxmap2tgtmap-respects-eq :
	forall*	{M1} {M2} {M1P} {M2P}
	forall	{A1: efxmap2tgtmap M1 M1P}
		{ME: efxmap`eq M1 M2}
		{EP: tgtmap`eq M1P M2P}
	exists	{A2: efxmap2tgtmap M2 M2P}
	true.

- : efxmap2tgtmap-respects-eq A _ _ A.

%worlds () (efxmap2tgtmap-respects-eq _ _ _ _).
%total { } (efxmap2tgtmap-respects-eq _ _ _ _).


%theorem efxmap2tgtmap/U-inversion :
	forall*	{M1} {M2} {N} {D} {M2P}
	forall	{A2: efxmap2tgtmap M2 M2P}
		{F: efxmap`fresh M1 N}
		{U: efxmap`update M1 N D M2}
	exists	{M1P} {DP}
		{A1: efxmap2tgtmap M1 M1P}
		{R: inner-efxmap`domain D DP}
		{U: tgtmap`update M1P N DP M2P}
	true.

%theorem efxmap2tgtmap/U-inversion/L :
	forall*	{N0} {D0} {M0} {N} {D} {B} {M1} {M2} {M0P} {D0P} {M2P}
	forall	{A0: efxmap2tgtmap M0 M0P}
		{R1: inner-efxmap`domain D0 D0P}
		{F0: efxmap`fresh M0 N0}
		{U0: efxmap`update M0 N0 D0 M2}
		{UP: tgtmap`update M0P N0 D0P M2P}
		{F1: efxmap`fresh M1 N}
		{U1: efxmap`update M1 N D M2}
		{EQ?: nat`eq? N N0 B}
	exists	{M1P} {DP}
		{A1: efxmap2tgtmap M1 M1P}
		{R: inner-efxmap`domain D DP}
		{U: tgtmap`update M1P N DP M2P}
	true.

- : efxmap2tgtmap/U-inversion/L
    A0 R0 F0 U0 U0P F1 U1 nat`eq?/yes _ _ A1 R1 U0P
    <- efxmap`fresh-update-cancels
      F0 U0 F1 U1 (nat`eq/:nat`eq N N) efxmap`eq/ D0=D1 M0=M1
    <- efxmap2tgtmap-respects-eq A0 M0=M1 tgtmap`eq/ A1
    <- inner-efxmap`domain-respects-eq R0 D0=D1 set`eq/ R1.

- : efxmap2tgtmap/U-inversion/L A0 R0 F0 U0 U0P F1 U1 (nat`eq?/no N<>N1) _ _
	(efxmap2tgtmap/U A2 R0 F3 U3 U3P) R1 U1P
    <- efxmap`update-commutes-converse U1 U0 N<>N1 _ U3 U2
    <- efxmap`update-preserves-fresh-converse F1 U3 F2
    <- efxmap`update-preserves-fresh-converse F0 U2 F3
    <- efxmap2tgtmap/U-inversion A0 F2 U2 _ _ A2 R1 U2P
    <- tgtmap`update-commutes U2P U0P N<>N1 _ U3P U1P.

- : efxmap2tgtmap/U-inversion (efxmap2tgtmap/U A0 R0 F0 U0 U0P) F U _ _ A1 R U1P
    <- nat`eq?-total EQ?
    <- efxmap2tgtmap/U-inversion/L A0 R0 F0 U0 U0P F U EQ? _ _ A1 R U1P.

%worlds () (efxmap2tgtmap/U-inversion _ _ _ _ _ _ _ _)
           (efxmap2tgtmap/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A B)
	   (efxmap2tgtmap/U-inversion A _ _ _ _ _ _ _)
           (efxmap2tgtmap/U-inversion/L B _ _ _ _ _ _ _ _ _ _ _ _).


%theorem efxmap2tgtmap-lookup-implies-lookup :
	forall*	{M} {N} {D} {MP}
	forall	{A: efxmap2tgtmap M MP}
		{L: efxmap`lookup M N D}
	exists	{DP}
		{R: inner-efxmap`domain D DP}
		{L: tgtmap`lookup MP N DP}
	true.

- : efxmap2tgtmap-lookup-implies-lookup A L DP T LP
    <- efxmap`lookup-implies-fresh-update L _ F U
    <- efxmap2tgtmap/U-inversion A F U _ _ AP T UP
    <- tgtmap`update-implies-lookup UP LP.

%worlds () (efxmap2tgtmap-lookup-implies-lookup _ _ _ _ _).
%total { } (efxmap2tgtmap-lookup-implies-lookup _ _ _ _ _).


%theorem efxmap2tgtmap-lookup-implies-lookup*
  : forall* {M} {N} {D} {MP} {DP}
    forall {A: efxmap2tgtmap M MP}
		{L: efxmap`lookup M N D}
		{R: inner-efxmap`domain D DP}
		exists {L: tgtmap`lookup MP N DP}
    true.

- : efxmap2tgtmap-lookup-implies-lookup* A L T LP
    <- efxmap2tgtmap-lookup-implies-lookup A L DP TP LR
    <- inner-efxmap`domain-unique TP T inner-efxmap`eq/ E
    <- tgtmap`lookup-respects-eq LR tgtmap`eq/ nat`eq/ E LP.

%worlds () (efxmap2tgtmap-lookup-implies-lookup* _ _ _ _).
%total {} (efxmap2tgtmap-lookup-implies-lookup* _ _ _ _).


%theorem efxmap2tgtmap-lookup-implies-domain
  : forall* {M} {N} {D} {G} {S}
    forall {T: efxmap2tgtmap M G}
    {L: efxmap`lookup M N D}
    {L: tgtmap`lookup G N S}
    exists {DM: inner-efxmap`domain D S}
    true.

- : efxmap2tgtmap-lookup-implies-domain
    M=>G M->N=D G->N=S DM-D=S
    <- inner-efxmap`domain-total DM-D=SP
    <- efxmap2tgtmap-lookup-implies-lookup* M=>G M->N=D DM-D=SP G->N=SP
    <- tgtmap`lookup-unique G->N=SP G->N=S tgtmap`eq/ nat`eq/ SP=S
    <- inner-efxmap`domain-respects-eq DM-D=SP inner-efxmap`eq/ SP=S DM-D=S.

%worlds () (efxmap2tgtmap-lookup-implies-domain _ _ _ _).
%total {} (efxmap2tgtmap-lookup-implies-domain _ _ _ _).


%theorem efxmap2tgtmap-preserves-fresh:
	forall*	{M} {N} {MP}
	forall	{F: efxmap`fresh M N}
		{A: efxmap2tgtmap M MP}
	exists	{F: tgtmap`fresh MP N}
	true.

- : efxmap2tgtmap-preserves-fresh _ efxmap2tgtmap/0 tgtmap`fresh/0.

- : efxmap2tgtmap-preserves-fresh F1 (efxmap2tgtmap/U A _ _ U UP) F4
    <- efxmap`update-implies-lookup U L
    <- efxmap`fresh-lookup-not-equal F1 L NE
    <- efxmap`update-preserves-fresh-converse F1 U F2
    <- efxmap2tgtmap-preserves-fresh F2 A F3
    <- tgtmap`update-preserves-fresh F3 UP NE F4.

%worlds () (efxmap2tgtmap-preserves-fresh _ _ _).
%total (A) (efxmap2tgtmap-preserves-fresh _ A _).


%theorem efxmap2tgtmap-preserves-fresh-converse:
	forall*	{M} {N} {MP}
	forall	{F: tgtmap`fresh MP N}
		{A: efxmap2tgtmap M MP}
	exists	{F: efxmap`fresh M N}
	true.

- : efxmap2tgtmap-preserves-fresh-converse _ efxmap2tgtmap/0 efxmap`fresh/0.

- : efxmap2tgtmap-preserves-fresh-converse F1 (efxmap2tgtmap/U A _ _ U UP) F4
    <- tgtmap`update-implies-lookup UP L
    <- tgtmap`fresh-lookup-not-equal F1 L NE
    <- tgtmap`update-preserves-fresh-converse F1 UP F2
    <- efxmap2tgtmap-preserves-fresh-converse F2 A F3
    <- efxmap`update-preserves-fresh F3 U NE F4.

%worlds () (efxmap2tgtmap-preserves-fresh-converse _ _ _).
%total (A) (efxmap2tgtmap-preserves-fresh-converse _ A _).


%theorem efxmap2tgtmap-lookup-implies-lookup-converse :
	forall*	{M} {N} {DP} {MP}
	forall	{A: efxmap2tgtmap M MP}
		{L: tgtmap`lookup MP N DP}
	exists	{D}
		{R: inner-efxmap`domain D DP}
		{L: efxmap`lookup M N D}
	true.

%theorem efxmap2tgtmap-lookup-implies-lookup-converse/L :
	forall*	{M} {N} {DP} {MP} {B}
	forall	{A: efxmap2tgtmap M MP}
		{L: tgtmap`lookup MP N DP}
		{D?: efxmap`domain? M N B}
	exists	{D}
		{R: inner-efxmap`domain D DP}
		{L: efxmap`lookup M N D}
	true.

- : efxmap2tgtmap-lookup-implies-lookup-converse/L
	A LP (efxmap`domain?/in L) _ T L
    <- efxmap`lookup-implies-fresh-update L _ F U
    <- tgtmap`lookup-implies-fresh-update LP _ FP UP
    <- efxmap2tgtmap/U-inversion A F U _ _ _ T1 UP1
    <- tgtmap`update-implies-lookup UP1 LP1
    <- tgtmap`lookup-unique LP1 LP tgtmap`eq/ (nat`eq/:nat`eq N N) DP1=DP
    <- inner-efxmap`domain-respects-eq T1 inner-efxmap`eq/ DP1=DP T.

%theorem efxmap2tgtmap-lookup-implies-lookup-converse/F :
	forall*	{M} {N} {DP}
	forall	{F: void}
	exists	{D} {R: inner-efxmap`domain D DP}
		{L: efxmap`lookup M N D}
	true.

%worlds () (efxmap2tgtmap-lookup-implies-lookup-converse/F _ _ _ _).
%total { } (efxmap2tgtmap-lookup-implies-lookup-converse/F _ _ _ _).

- : efxmap2tgtmap-lookup-implies-lookup-converse/L
	A (LP:tgtmap`lookup MP N DP) (efxmap`domain?/out F) D2 T L
    <- efxmap2tgtmap-preserves-fresh F A FP
    <- tgtmap`fresh-lookup-not-equal FP LP N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- efxmap2tgtmap-lookup-implies-lookup-converse/F V D2 T L.

%worlds () (efxmap2tgtmap-lookup-implies-lookup-converse/L _ _ _ _ _ _).
%total { } (efxmap2tgtmap-lookup-implies-lookup-converse/L _ _ _ _ _ _).

- : efxmap2tgtmap-lookup-implies-lookup-converse A LP DP T L
    <- efxmap`domain?-total D?
    <- efxmap2tgtmap-lookup-implies-lookup-converse/L A LP D? DP T L.

%worlds () (efxmap2tgtmap-lookup-implies-lookup-converse _ _ _ _ _).
%total { } (efxmap2tgtmap-lookup-implies-lookup-converse _ _ _ _ _).


%theorem efxmap2tgtmap-preserves-domain? :
	forall*	{M} {N} {B} {MP}
	forall	{D1: efxmap`domain? M N B}
		{A: efxmap2tgtmap M MP}
	exists	{D2: tgtmap`domain? MP N B}
	true.

- : efxmap2tgtmap-preserves-domain? (efxmap`domain?/in L) A (tgtmap`domain?/in LP)
    <- efxmap`lookup-implies-fresh-update L _ F U
    <- efxmap2tgtmap/U-inversion A F U _ _ _ _ UP
    <- tgtmap`update-implies-lookup UP LP.

- : efxmap2tgtmap-preserves-domain? (efxmap`domain?/out F) A (tgtmap`domain?/out FP)
    <- efxmap2tgtmap-preserves-fresh F A FP.

%worlds () (efxmap2tgtmap-preserves-domain? _ _ _).
%total { } (efxmap2tgtmap-preserves-domain? _ _ _).


%theorem efxmap2tgtmap-preserves-domain?-converse :
	forall*	{M} {N} {B} {MP}
	forall	{D1: tgtmap`domain? MP N B}
		{A: efxmap2tgtmap M MP}
	exists	{D2: efxmap`domain? M N B}
	true.

- : efxmap2tgtmap-preserves-domain?-converse (tgtmap`domain?/in LP) A (efxmap`domain?/in L)
    <- efxmap2tgtmap-lookup-implies-lookup-converse A LP _ _ L.

- : efxmap2tgtmap-preserves-domain?-converse (tgtmap`domain?/out FP) A (efxmap`domain?/out F)
    <- efxmap2tgtmap-preserves-fresh-converse FP A F.

%worlds () (efxmap2tgtmap-preserves-domain?-converse _ _ _).
%total { } (efxmap2tgtmap-preserves-domain?-converse _ _ _).


%theorem efxmap2tgtmap/UP-inversion :
	forall*	{M1P} {M2} {N} {DP} {M2P}
	forall	{A2: efxmap2tgtmap M2 M2P}
		{F: tgtmap`fresh M1P N}
		{U: tgtmap`update M1P N DP M2P}
	exists	{M1} {D}
		{A1: efxmap2tgtmap M1 M1P}
		{R: inner-efxmap`domain D DP}
		{U: efxmap`update M1 N D M2}
	true.

- : efxmap2tgtmap/UP-inversion A FP UP _ _ A1 T U
    <- tgtmap`update-implies-lookup UP LP
    <- efxmap2tgtmap-lookup-implies-lookup-converse A LP _ _ L
    <- efxmap`lookup-implies-fresh-update L _ F U
    <- efxmap2tgtmap/U-inversion A F U _ _ A2 T2 UP2
    <- efxmap2tgtmap-preserves-fresh F A2 FP2
    <- tgtmap`fresh-update-cancels
      FP2 UP2 FP UP (nat`eq/:nat`eq N N) tgtmap`eq/ DP2=DP M2P=MP
    <- inner-efxmap`domain-respects-eq T2 inner-efxmap`eq/ DP2=DP T
    <- efxmap2tgtmap-respects-eq A2 efxmap`eq/ M2P=MP A1.

%worlds () (efxmap2tgtmap/UP-inversion _ _ _ _ _ _ _ _).
%total { } (efxmap2tgtmap/UP-inversion _ _ _ _ _ _ _ _).


%theorem update-preserves-efxmap2tgtmap :
	forall*	{M1} {N} {D} {M2} {M1P} {M2P} {DP}
	forall	{A1: efxmap2tgtmap M1 M1P}
		{R: inner-efxmap`domain D DP}
		{U: efxmap`update M1 N D M2}
		{UP:tgtmap`update M1P N DP M2P}
	exists	{A2: efxmap2tgtmap M2 M2P}
	true.

%theorem update-preserves-efxmap2tgtmap/L :
	forall*	{M1} {N} {D} {M2} {M1P} {M2P} {DP} {B}
	forall	{A1: efxmap2tgtmap M1 M1P}
		{R: inner-efxmap`domain D DP}
		{D?: efxmap`domain? M1 N B}
		{U: efxmap`update M1 N D M2}
		{UP:tgtmap`update M1P N DP M2P}
	exists	{A2: efxmap2tgtmap M2 M2P}
	true.

- : update-preserves-efxmap2tgtmap/L
    A T (efxmap`domain?/out F) U UP (efxmap2tgtmap/U A T F U UP).

- : update-preserves-efxmap2tgtmap/L
    A T (efxmap`domain?/in L) U UP (efxmap2tgtmap/U A1 T F U3 UP3)
    <- efxmap`lookup-implies-fresh-update L _ F U1
    <- efxmap2tgtmap/U-inversion A F U1 _ _ A1 TX U2
    <- efxmap`update-overwrites U1 U nat`eq/ U3
    <- tgtmap`update-overwrites U2 UP nat`eq/ UP3.

%worlds () (update-preserves-efxmap2tgtmap/L _ _ _ _ _ _).
%total { } (update-preserves-efxmap2tgtmap/L _ _ _ _ _ _).

- : update-preserves-efxmap2tgtmap A T U UP AP
    <- efxmap`domain?-total D?
    <- update-preserves-efxmap2tgtmap/L A T D? U UP AP.

%worlds () (update-preserves-efxmap2tgtmap _ _ _ _ _).
%total { } (update-preserves-efxmap2tgtmap _ _ _ _ _).


%theorem efxmap2tgtmap-preserves-size :
	forall*	{M1} {N} {M2}
	forall	{Z1: efxmap`size M1 N}
		{A: efxmap2tgtmap M1 M2}
	exists	{Z2: tgtmap`size M2 N}
	true.

- : efxmap2tgtmap-preserves-size efxmap`size/0 efxmap2tgtmap/0 tgtmap`size/0.

- : efxmap2tgtmap-preserves-size Z (efxmap2tgtmap/U A T F U UP) ZP
    <- efxmap`fresh-update-increases-size-converse Z F U Z1
    <- efxmap2tgtmap-preserves-size Z1 A ZP1
    <- efxmap2tgtmap-preserves-fresh F A FP
    <- tgtmap`fresh-update-increases-size ZP1 FP UP ZP.

%worlds () (efxmap2tgtmap-preserves-size _ _ _).
%total (A) (efxmap2tgtmap-preserves-size _ A _).


%theorem efxmap2tgtmap-preserves-size-converse :
	forall*	{M1} {N} {M2}
	forall	{Z1: tgtmap`size M2 N}
		{A: efxmap2tgtmap M1 M2}
	exists	{Z2: efxmap`size M1 N}
	true.

- : efxmap2tgtmap-preserves-size-converse tgtmap`size/0 efxmap2tgtmap/0 efxmap`size/0.

- : efxmap2tgtmap-preserves-size-converse ZP (efxmap2tgtmap/U A T F U UP) Z
    <- efxmap2tgtmap-preserves-fresh F A FP
    <- tgtmap`fresh-update-increases-size-converse ZP FP UP ZP1
    <- efxmap2tgtmap-preserves-size-converse ZP1 A Z1
    <- efxmap`fresh-update-increases-size Z1 F U Z.

%worlds () (efxmap2tgtmap-preserves-size-converse _ _ _).
%total (A) (efxmap2tgtmap-preserves-size-converse _ A _).


%theorem efxmap2tgtmap-preserves-domain:
	forall*	{M} {S} {MP}
	forall	{D: efxmap`domain M S}
		{A: efxmap2tgtmap M MP}
	exists	{DP: tgtmap`domain MP S}
	true.

- : efxmap2tgtmap-preserves-domain efxmap`domain/0 efxmap2tgtmap/0 tgtmap`domain/0.

- : efxmap2tgtmap-preserves-domain D (efxmap2tgtmap/U A T F U UP) DP
    <- efxmap`domain-total D1
    <- efxmap2tgtmap-preserves-domain D1 A DP1
    <- efxmap`update-commute-domain U D1 D SA
    <- tgtmap`domain-commute-update DP1 UP SA DP.

%worlds () (efxmap2tgtmap-preserves-domain _ _ _).
%total (A) (efxmap2tgtmap-preserves-domain _ A _).


%theorem efxmap2tgtmap-preserves-domain-converse:
	forall*	{M} {S} {MP}
	forall	{D: tgtmap`domain MP S}
		{A: efxmap2tgtmap M MP}
	exists	{DP: efxmap`domain M S}
	true.

- : efxmap2tgtmap-preserves-domain-converse tgtmap`domain/0 efxmap2tgtmap/0 efxmap`domain/0.

- : efxmap2tgtmap-preserves-domain-converse DP (efxmap2tgtmap/U A T F U UP) D
    <- tgtmap`domain-total D1P
    <- efxmap2tgtmap-preserves-domain-converse D1P A D1
    <- tgtmap`update-commute-domain UP D1P DP SA
    <- efxmap`domain-commute-update D1 U SA D.

%worlds () (efxmap2tgtmap-preserves-domain-converse _ _ _).
%total (A) (efxmap2tgtmap-preserves-domain-converse _ A _).


%theorem efxmap2tgtmap-total* :
	forall	{M}
	exists	{MP}
		{A: efxmap2tgtmap M MP}
	true.

%abbrev efxmap2tgtmap-total = efxmap2tgtmap-total* _ _.

%theorem efxmap2tgtmap-total/L :
	forall*	{M}
	forall	{N} {Z: efxmap`size M N}
	exists	{MP}
		{A: efxmap2tgtmap M MP}
	true.

- : efxmap2tgtmap-total/L _ _ _ efxmap2tgtmap/0.

- : efxmap2tgtmap-total/L _ Z _ (efxmap2tgtmap/U A1 T F U UP)
    <- efxmap`lookup-implies-fresh-update (efxmap`lookup/= (nat`eq/:nat`eq N N)) _ F U
    <- efxmap`fresh-update-increases-size-converse Z F U Z1
    <- efxmap2tgtmap-total/L _ Z1 _ A1
    <- inner-efxmap`domain-total* _ _ T
    <- tgtmap`update-total UP.

%worlds () (efxmap2tgtmap-total/L _ _ _ _).
%total (N) (efxmap2tgtmap-total/L N _ _ _).

- : efxmap2tgtmap-total A
    <- efxmap`size-total Z
    <- efxmap2tgtmap-total/L _ Z _ A.

%worlds () (efxmap2tgtmap-total* _ _ _).
%total { } (efxmap2tgtmap-total* _ _ _).


%theorem efxmap2tgtmap-unique :
	forall*	{M1} {M2} {M1P} {M2P}
	forall	{A1: efxmap2tgtmap M1 M1P}
		{A2: efxmap2tgtmap M2 M2P}
		{ME: efxmap`eq M1 M2}
	exists	{EP: tgtmap`eq M1P M2P}
	true.

%theorem efxmap2tgtmap-unique/L :
	forall*	{M} {M1P} {M2P}
	forall	{N} {Z: efxmap`size M N}
		{A1: efxmap2tgtmap M M1P}
		{A2: efxmap2tgtmap M M2P}
	exists	{EP: tgtmap`eq M1P M2P}
	true.

- : efxmap2tgtmap-unique/L _ _ efxmap2tgtmap/0 efxmap2tgtmap/0 tgtmap`eq/.

- : efxmap2tgtmap-unique/L _ Z A1 A2 MEQ
    <- efxmap`lookup-implies-fresh-update (efxmap`lookup/= nat`eq/) _ F U
    <- efxmap`fresh-update-increases-size-converse Z F U ZR
    <- efxmap2tgtmap/U-inversion A1 F U _ _ A1R T1 U1
    <- efxmap2tgtmap/U-inversion A2 F U _ _ A2R T2 U2
    <- efxmap2tgtmap-unique/L _ ZR A1R A2R MEQR
    <- inner-efxmap`domain-unique T1 T2 inner-efxmap`eq/ DEQ
    <- tgtmap`update-unique U1 U2 MEQR nat`eq/ DEQ MEQ.

%worlds () (efxmap2tgtmap-unique/L _ _ _ _ _).
%total (N) (efxmap2tgtmap-unique/L N _ _ _ _).

- : efxmap2tgtmap-unique A1 A2 _ MEQ
    <- efxmap`size-total Z
    <- efxmap2tgtmap-unique/L _ Z A1 A2 MEQ.

%worlds () (efxmap2tgtmap-unique _ _ _ _).
%total { } (efxmap2tgtmap-unique _ _ _ _).



%theorem efxmap2tgtmap-right-preserves-leq* :
	forall*	{M1} {M1P} {M2} {M2P}
	forall	{L: efxmap`leq M1 M2}
		{A1: efxmap2tgtmap M1 M1P}
		{A2: efxmap2tgtmap M2 M2P}
	exists	{LP: tgtmap`leq M1P M2P}
	true.

- : efxmap2tgtmap-right-preserves-leq* _ efxmap2tgtmap/0 _ tgtmap`leq/0.

- : efxmap2tgtmap-right-preserves-leq* M1<=M2
	(efxmap2tgtmap/U A1R T1 F1 U1 U1P) A2 M1P<=M2P
    <- efxmap`update-implies-lookup U1 L1
    <- efxmap`lookup-respects-leq L1 M1<=M2 _ L2 _
    <- efxmap`lookup-implies-fresh-update L2 _ F2 U2
    <- efxmap2tgtmap/U-inversion A2 F2 U2 _ _ A2R T2 U2P
    <- efxmap`fresh-update-preserves-leq-converse M1<=M2 F1 U1 F2 U2 M1R<=M2R D1<=D2
    <- efxmap2tgtmap-right-preserves-leq* M1R<=M2R A1R A2R M1PR<=M2PR
    <- inner-efxmap`domain-preserves-leq* D1<=D2 T1 T2 D1P<=D2P
    <- tgtmap`update-preserves-leq* M1PR<=M2PR D1P<=D2P U1P U2P M1P<=M2P.

%worlds () (efxmap2tgtmap-right-preserves-leq* _ _ _ _).
%total (A) (efxmap2tgtmap-right-preserves-leq* _ A _ _).


%theorem efxmap2tgtmap-preserves-leq* :
	forall*	{M1} {M1P} {M2} {M2P}
	forall	{LM: efxmap`leq M1 M2}
		{A1: efxmap2tgtmap M1 M1P}
		{A2: efxmap2tgtmap M2 M2P}
	exists	{LP: tgtmap`leq M1P M2P}
	true.

- : efxmap2tgtmap-preserves-leq* M1<=M2 A1 A2 M1P<=M2P
    <- efxmap2tgtmap-right-preserves-leq* M1<=M2 A1 A2 M1P<=M2P.

%worlds () (efxmap2tgtmap-preserves-leq* _ _ _ _).
%total { } (efxmap2tgtmap-preserves-leq* _ _ _ _).


%theorem fresh-update-preserves-efxmap2tgtmap-converse
  : forall* {M} {MP} {N} {D} {G}
    forall {T: efxmap2tgtmap M G}
    {FS: efxmap`fresh MP N} {U: efxmap`update MP N D M}
    exists {GP} {S} {TP: inner-efxmap`domain D S}
    {FS: tgtmap`fresh GP N} {U: tgtmap`update GP N S G}
    {T: efxmap2tgtmap MP GP}
    true.

%theorem fresh-update-preserves-efxmap2tgtmap-converse/L
  : forall* {M} {MS} {G} {MP} {GS} {N1} {N2} {B} {S1} {D1} {D2}
    forall {T: efxmap2tgtmap MS GS} {TP: inner-efxmap`domain D1 S1}
    {FS: efxmap`fresh MS N1} {U: efxmap`update MS N1 D1 M}
    {U: tgtmap`update GS N1 S1 G}
    {FS: efxmap`fresh MP N2} {U: efxmap`update MP N2 D2 M}
    {EQ?: nat`eq? N1 N2 B}
    exists {GP} {S2} {TP: inner-efxmap`domain D2 S2}
    {U: tgtmap`update GP N2 S2 G} {FS: tgtmap`fresh GP N2} {T: efxmap2tgtmap MP GP}
    true.

- : fresh-update-preserves-efxmap2tgtmap-converse/L
    SS=>MS S1=>D1 N1!<SS SS+N1=S MS+N1=M N2!<SP SP+N2=S (nat`eq?/no N1<>N2)
    MP D2 S2=>D2 MP+N2=M N2!<MP (efxmap2tgtmap/U SK=>MK S1=>D1 N1!<SK SK+N1=SP MK+N1=MP)
    <- efxmap`update-commutes-converse SS+N1=S SP+N2=S N1<>N2 SK SK+N2=SS SK+N1=SP
    <- efxmap`update-preserves-fresh-converse N2!<SP SK+N1=SP N2!<SK
    <- fresh-update-preserves-efxmap2tgtmap-converse
      SS=>MS N2!<SK SK+N2=SS MK D2 S2=>D2 N2!<MK MK+N2=MS SK=>MK
    <- nat`ne-symmetric N1<>N2 N2<>N1
    <- tgtmap`update-commutes MK+N2=MS MS+N1=M N2<>N1 MP MK+N1=MP MP+N2=M
    <- tgtmap`update-preserves-fresh N2!<MK MK+N1=MP N2<>N1 N2!<MP
    <- efxmap`update-preserves-fresh-converse N1!<SS SK+N2=SS N1!<SK.

- : fresh-update-preserves-efxmap2tgtmap-converse/L
    SS=>MS S1=>D1 N!<SS SS+N=S MS+N=M N!<SP SP+N=S (nat`eq?/yes)
    MS _ S2=>D1 MS+N=M N!<MS SP=>MS
    <- efxmap`fresh-update-cancels N!<SS SS+N=S N!<SP SP+N=S nat`eq/ efxmap`eq/ S1=S2 SS=SP
    <- efxmap2tgtmap-respects-eq SS=>MS SS=SP tgtmap`eq/ SP=>MS
    <- efxmap2tgtmap-preserves-fresh N!<SS SS=>MS N!<MS
    <- inner-efxmap`domain-respects-eq S1=>D1 S1=S2 set`eq/ S2=>D1.

- : fresh-update-preserves-efxmap2tgtmap-converse
    (efxmap2tgtmap/U T TK F1 U1 UP1) F2 U2 MP D TU U F TP
    <- nat`eq?-total EQ?
    <- fresh-update-preserves-efxmap2tgtmap-converse/L
      T TK F1 U1 UP1 F2 U2 EQ? MP D TU F U TP.

%worlds () (fresh-update-preserves-efxmap2tgtmap-converse _ _ _ _ _ _ _ _ _)
(fresh-update-preserves-efxmap2tgtmap-converse/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (T1 T2) (fresh-update-preserves-efxmap2tgtmap-converse T1 _ _ _ _ _ _ _ _)
(fresh-update-preserves-efxmap2tgtmap-converse/L T2 _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem fresh-update-preserves-efxmap2tgtmap-converse*
  : forall* {M} {MP} {N} {D} {G} {GP} {S}
    forall {T: efxmap2tgtmap M G}
    {FS: efxmap`fresh MP N} {U: efxmap`update MP N D M}
    {FS: tgtmap`fresh GP N} {U: tgtmap`update GP N S G}
    exists {T: efxmap2tgtmap MP GP}
    true.

- : fresh-update-preserves-efxmap2tgtmap-converse*
    M=>G MF MU GF GU MP=>GP
    <- fresh-update-preserves-efxmap2tgtmap-converse
      M=>G MF MU _ _ _ GF' GU' MP=>GP'
    <- tgtmap`fresh-update-cancels GF' GU' GF GU nat`eq/ tgtmap`eq/ DE ME
    <- efxmap2tgtmap-respects-eq MP=>GP' efxmap`eq/ ME MP=>GP.

%worlds () (fresh-update-preserves-efxmap2tgtmap-converse* _ _ _ _ _ _).
%total {} (fresh-update-preserves-efxmap2tgtmap-converse* _ _ _ _ _ _).


%theorem join-preserves-efxmap2tgtmap
  : forall* {XM1} {GM1} {XM2} {GM2} {XM}
    forall {T1: efxmap2tgtmap XM1 GM1}
    {T2: efxmap2tgtmap XM2 GM2}
    {J: efxmap`join XM1 XM2 XM}
    exists {GM} {J: tgtmap`join GM1 GM2 GM}
    {T: efxmap2tgtmap XM GM}
    true.

%worlds () (join-preserves-efxmap2tgtmap _ _ _ _ _ _).
%trustme %total {} (join-preserves-efxmap2tgtmap _ _ _ _ _ _).


%theorem join-preserves-efxmap2tgtmap*
  : forall* {XM1} {XM2} {GM1} {GM2} {XM} {GM}
    forall {T1: efxmap2tgtmap XM1 GM1} {T2: efxmap2tgtmap XM2 GM2}
    {J: efxmap`join XM1 XM2 XM} {J: tgtmap`join GM1 GM2 GM}
    exists {T: efxmap2tgtmap XM GM}
    true.

%worlds () (join-preserves-efxmap2tgtmap* _ _ _ _ _).
%trustme %total {} (join-preserves-efxmap2tgtmap* _ _ _ _ _).



%% Variable names are messed up since I copied this from tgtmap2efxmap.elf

%theorem efxmap2tgtmap-preserves-deep-disjoint-join
  : forall* {G} {G1} {G2} {M}
    forall {T: efxmap2tgtmap G M}
    {DJ: efxmap`deep-disjoint G1 G2} {J: efxmap`join G1 G2 G}
    exists {M1} {M2} {T1: efxmap2tgtmap G1 M1}
    {T2: efxmap2tgtmap G2 M2}
    {DJ: tgtmap`deep-disjoint M1 M2} {J: tgtmap`join M1 M2 M}
    true.

- : efxmap2tgtmap-preserves-deep-disjoint-join
    efxmap2tgtmap/0 DJ J _ _ efxmap2tgtmap/0 efxmap2tgtmap/0
    tgtmap`deep-disjoint/L tgtmap`join/L.

%theorem efxmap2tgtmap-preserves-deep-disjoint-join/F
  : forall* {G1} {G2} {M}
    forall {V:void}
    exists {M1} {M2} {T1: efxmap2tgtmap G1 M1}
    {T2: efxmap2tgtmap G2 M2}
    {DJ: tgtmap`deep-disjoint M1 M2} {J: tgtmap`join M1 M2 M}
    true.

%worlds () (efxmap2tgtmap-preserves-deep-disjoint-join/F _ _ _ _ _ _ _).
%total {} (efxmap2tgtmap-preserves-deep-disjoint-join/F _ _ _ _ _ _ _).


%theorem efxmap2tgtmap-preserves-deep-disjoint-join/L
  : forall* {G} {G1} {G2} {M} {MP} {GP} {N} {B1} {B2} {S} {D}
    forall {T: efxmap2tgtmap GP MP}
    {S=>D: inner-efxmap`domain S D}
    {FS: efxmap`fresh GP N} {A: efxmap`update GP N S G}
    {U: tgtmap`update MP N D M}
    {DJ: efxmap`deep-disjoint G1 G2} {J: efxmap`join G1 G2 G}
    {IN1?: efxmap`domain? G1 N B1} {IN2?: efxmap`domain? G2 N B2}
    exists {M1} {M2} {T1: efxmap2tgtmap G1 M1}
    {T2: efxmap2tgtmap G2 M2}
    {DJ: tgtmap`deep-disjoint M1 M2} {J: tgtmap`join M1 M2 M}
    true.

- : efxmap2tgtmap-preserves-deep-disjoint-join/L
    GP=>MP S=>D N!<GP GP+N=G MP+N=M G1^G2 G1+G2=G
    (efxmap`domain?/out N!<G1) (efxmap`domain?/out N!<G2)
    M1 M2 G1=>M1 G2=>M2 M1^M2 M1+M2=M
    <- efxmap`join-preserves-fresh* N!<G1 N!<G2 G1+G2=G N!<G
    <- efxmap`update-implies-lookup GP+N=G G->N=S
    <- efxmap`fresh-lookup-not-equal N!<G G->N=S N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- efxmap2tgtmap-preserves-deep-disjoint-join/F V M1 M2 G1=>M1 G2=>M2 M1^M2 M1+M2=M.

- : efxmap2tgtmap-preserves-deep-disjoint-join/L
    GP+X=>MP (S+X=>D:inner-efxmap`domain S D)
    N!<GP (GP+N+S=G:efxmap`update GP N S G)
    (MP+N+D=M:tgtmap`update MP N D M)
    G1^G2 (G1+G2=G:efxmap`join G1 G2 G)
    (efxmap`domain?/in (G1->N=SP:efxmap`lookup G1 N SP))
    (efxmap`domain?/out (N!<G2:efxmap`fresh G2 N))
    %{=>}% M1 M2 (efxmap2tgtmap/U G1P+X=>M1P SP+X=>D N!<G1P G1P+N+SP=G1 M1P+N+D=M1)
    G2+X=>M2 M1^M2 M1+M2=M
    <- efxmap`lookup-implies-fresh-update G1->N=SP G1P N!<G1P G1P+N+SP=G1
    <- efxmap`fresh-update-implies-leq N!<G1P G1P+N+SP=G1 G1P<=G1
    <- efxmap`deep-disjoint-respects-geq* G1^G2 G1P<=G1 G1P^G2
    <- efxmap`fresh-update-implies-unit-join N!<G1P G1P+N+SP=G1 G1P+SP=G1
    <- efxmap`fresh-implies-unit-deep-disjoint N!<G1P G1P^SP
    <- efxmap`deep-disjoint-join-commutative G1P^SP G1P+SP=G1 SP+G1P=G1
    <- efxmap`join-associative SP+G1P=G1 G1+G2=G GPk G1P+G2=GPk SP+GPk=G
    <- efxmap`join-preserves-fresh* N!<G1P N!<G2 G1P+G2=GPk N!<GPk
    <- efxmap`fresh-implies-unit-deep-disjoint N!<GPk GPk^SP
    <- efxmap`deep-disjoint-symmetric GPk^SP SP^GPk
    <- efxmap`deep-disjoint-join-commutative SP^GPk SP+GPk=G GPk+SP=G
    <- efxmap`fresh-unit-join-implies-update N!<GPk GPk+SP=G GPk+N+SP=G
    <- efxmap`fresh-update-cancels
      N!<GP GP+N+S=G N!<GPk GPk+N+SP=G nat`eq/ efxmap`eq/ S=SP GP=GPk
    <- efxmap`eq-symmetric GP=GPk GPk=GP
    <- efxmap`join-respects-eq G1P+G2=GPk efxmap`eq/ efxmap`eq/ GPk=GP G1P+G2=GP
    <- efxmap2tgtmap-preserves-deep-disjoint-join
      GP+X=>MP G1P^G2 G1P+G2=GP M1P M2 G1P+X=>M1P G2+X=>M2 M1P^M2 M1P+M2=MP
    <- efxmap2tgtmap-preserves-fresh N!<GP GP+X=>MP N!<MP
    <- tgtmap`fresh-update-implies-unit-join N!<MP MP+N+D=M MP+D=M
    <- tgtmap`fresh-implies-unit-deep-disjoint N!<MP MP^D
    <- tgtmap`deep-disjoint-join-commutative MP^D MP+D=M D+MP=M
    <- tgtmap`join-associative-converse M1P+M2=MP D+MP=M M1 D+M1P=M1 M1+M2=M
    <- efxmap2tgtmap-preserves-fresh N!<G1P G1P+X=>M1P N!<M1P
    <- tgtmap`fresh-implies-unit-deep-disjoint N!<M1P M1P^D
    <- tgtmap`deep-disjoint-symmetric M1P^D D^M1P
    <- tgtmap`deep-disjoint-join-commutative D^M1P D+M1P=M1 M1P+D=M1
    <- tgtmap`fresh-unit-join-implies-update N!<M1P M1P+D=M1 M1P+N+D=M1
    <- inner-efxmap`domain-respects-eq S+X=>D S=SP set`eq/ SP+X=>D
    <- tgtmap`deep-disjoint-symmetric M1P^M2 M2^M1P
    <- efxmap2tgtmap-preserves-fresh N!<G2 G2+X=>M2 N!<M2
    <- tgtmap`fresh-update-preserves-deep-disjoint M2^M1P N!<M2 M1P+N+D=M1 M2^M1
    <- tgtmap`deep-disjoint-symmetric M2^M1 M1^M2.

- : efxmap2tgtmap-preserves-deep-disjoint-join/L
    GP+X=>MP (S+X=>D:inner-efxmap`domain S D)
    N!<GP (GP+N+S=G:efxmap`update GP N S G)
    (MP+N+D=M:tgtmap`update MP N D M)
    G1^G2 (G1+G2=G:efxmap`join G1 G2 G)
    (efxmap`domain?/out (N!<G1:efxmap`fresh G1 N))
    (efxmap`domain?/in (G2->N=SP:efxmap`lookup G2 N SP))
    %{=>}% M1 M2 G1+X=>M1
    (efxmap2tgtmap/U G2P+X=>M2P SP+X=>D N!<G2P G2P+N+SP=G2 M2P+N+D=M2)
    M1^M2 M1+M2=M
    <- efxmap`lookup-implies-fresh-update G2->N=SP G2P N!<G2P G2P+N+SP=G2
    <- efxmap`fresh-update-implies-leq N!<G2P G2P+N+SP=G2 G2P<=G2
    <- efxmap`deep-disjoint-symmetric G1^G2 G2^G1
    <- efxmap`deep-disjoint-respects-geq* G2^G1 G2P<=G2 G2P^G1
    <- efxmap`fresh-update-implies-unit-join N!<G2P G2P+N+SP=G2 G2P+SP=G2
    <- efxmap`join-associative-converse G2P+SP=G2 G1+G2=G GPk G1+G2P=GPk GPk+SP=G
    <- efxmap`join-preserves-fresh* N!<G1 N!<G2P G1+G2P=GPk N!<GPk
    <- efxmap`fresh-unit-join-implies-update N!<GPk GPk+SP=G GPk+N+SP=G
    <- efxmap`fresh-update-cancels
      N!<GP GP+N+S=G N!<GPk GPk+N+SP=G nat`eq/ efxmap`eq/ S=SP GP=GPk
    <- efxmap`eq-symmetric GP=GPk GPk=GP
    <- efxmap`join-respects-eq G1+G2P=GPk efxmap`eq/ efxmap`eq/ GPk=GP G1+G2P=GP
    <- efxmap`deep-disjoint-symmetric G2P^G1 G1^G2P
    <- efxmap2tgtmap-preserves-deep-disjoint-join
      GP+X=>MP G1^G2P G1+G2P=GP M1 M2P G1+X=>M1 G2P+X=>M2P M1^M2P M1+M2P=MP
    <- efxmap2tgtmap-preserves-fresh N!<GP GP+X=>MP N!<MP
    <- tgtmap`fresh-update-implies-unit-join N!<MP MP+N+D=M MP+D=M
    <- tgtmap`join-associative M1+M2P=MP MP+D=M M2 M2P+D=M2 M1+M2=M
    <- efxmap2tgtmap-preserves-fresh N!<G2P G2P+X=>M2P N!<M2P
    <- tgtmap`fresh-unit-join-implies-update N!<M2P M2P+D=M2 M2P+N+D=M2
    <- inner-efxmap`domain-respects-eq S+X=>D S=SP set`eq/ SP+X=>D
    <- efxmap2tgtmap-preserves-fresh N!<G1 G1+X=>M1 N!<M1
    <- tgtmap`fresh-update-preserves-deep-disjoint M1^M2P N!<M1 M2P+N+D=M2 M1^M2.

- : efxmap2tgtmap-preserves-deep-disjoint-join/L
    GP+X=>MP (S+X=>D:inner-efxmap`domain S D)
    N!<GP (GP+N+S=G:efxmap`update GP N S G)
    (MP+N+D=M:tgtmap`update MP N D M)
    G1^G2 (G1+G2=G:efxmap`join G1 G2 G)
    (efxmap`domain?/in (G1->N=S1:efxmap`lookup G1 N S1))
    (efxmap`domain?/in (G2->N=S2:efxmap`lookup G2 N S2))
    %{=>}% M1 M2
    (efxmap2tgtmap/U G1P+X=>M1P S1+X=>D1 N!<G1P G1P+N+S1=G1 M1P+N+D1=M1)
    (efxmap2tgtmap/U G2P+X=>M2P S2+X=>D2 N!<G2P G2P+N+S2=G2 M2P+N+D2=M2)
    M1^M2 M1+M2=M
    <- efxmap`lookup-implies-fresh-update G1->N=S1 G1P N!<G1P G1P+N+S1=G1
    <- efxmap`fresh-update-implies-leq N!<G1P G1P+N+S1=G1 G1P<=G1
    <- efxmap`lookup-implies-fresh-update G2->N=S2 G2P N!<G2P G2P+N+S2=G2
    <- efxmap`fresh-update-implies-leq N!<G2P G2P+N+S2=G2 G2P<=G2
    <- efxmap`fresh-update-implies-unit-join N!<G1P G1P+N+S1=G1 G1P+S1=G1
    <- efxmap`fresh-update-implies-unit-join N!<G2P G2P+N+S2=G2 G2P+S2=G2
    <- efxmap`join-associative G1P+S1=G1 G1+G2=G S1G2 S1+G2=S1G2 X1+S1G2=G
    <- efxmap`fresh-implies-unit-deep-disjoint N!<G2P G2P^S2
    <- efxmap`deep-disjoint-join-commutative G2P^S2 G2P+S2=G2 S2+G2P=G2
    <- efxmap`join-associative-converse
      S2+G2P=G2 S1+G2=S1G2 S12 S1+S2=S12 S12+G2P=S1G2
    <- efxmap`fresh-implies-unit-deep-disjoint N!<G2P G2P^S1
    <- efxmap`deep-disjoint-symmetric G2P^S1 S1^G2P
    <- efxmap`deep-disjoint-symmetric G2P^S2 S2^G2P
    <- efxmap`join-preserves-deep-disjoint* S1^G2P S2^G2P S1+S2=S12 S12^G2P
    <- efxmap`deep-disjoint-join-commutative S12^G2P S12+G2P=S1G2 G2P+S12=S1G2
    <- efxmap`join-associative-converse G2P+S12=S1G2 X1+S1G2=G GPk G1P+G2P=GPk GPk+S12=G
    <- efxmap`join/=-inversion S1+S2=S12 nat`eq/ Sk _ S1+S2=Sk J S12=Sk'
    <- efxmap`join-unique J efxmap`join/L efxmap`eq/ efxmap`eq/ X=0
    <- efxmap`map/+-preserves-eq nat`eq/ inner-efxmap`eq/ X=0 Sk'=Sk
    <- efxmap`eq-transitive S12=Sk' Sk'=Sk S12=Sk
    <- efxmap`join-respects-eq GPk+S12=G efxmap`eq/ S12=Sk efxmap`eq/ GPk+Sk=G
    <- efxmap`join-preserves-fresh* N!<G1P N!<G2P G1P+G2P=GPk N!<GPk
    <- efxmap`fresh-unit-join-implies-update N!<GPk GPk+Sk=G GPk+N+Sk=G
    <- efxmap`fresh-update-cancels
      N!<GPk GPk+N+Sk=G N!<GP GP+N+S=G nat`eq/ efxmap`eq/ Sk=S GPk=GP
    <- efxmap`join-respects-eq G1P+G2P=GPk efxmap`eq/ efxmap`eq/ GPk=GP G1P+G2P=GP
    <- efxmap`deep-disjoint-respects-geq G1^G2 G1P<=G1 G2P<=G2 G1P^G2P
    <- efxmap2tgtmap-preserves-deep-disjoint-join
      GP+X=>MP G1P^G2P G1P+G2P=GP M1P M2P G1P+X=>M1P G2P+X=>M2P M1P^M2P M1P+M2P=MP
    <- efxmap`deep-disjoint-lookup-implies-disjoint G1^G2 G1->N=S1 G2->N=S2 S1^S2
    <- inner-efxmap`join-respects-eq
      S1+S2=Sk inner-efxmap`eq/ inner-efxmap`eq/ Sk=S S1+S2=S
    <- inner-efxmap`domain-total S1+X=>D1
    <- inner-efxmap`domain-total S2+X=>D2
    <- inner-efxmap`domain-preserves-disjoint S1^S2 S1+X=>D1 S2+X=>D2 D1^D2
    <- inner-efxmap`join-commute-domain S1+S2=S S1+X=>D1 S2+X=>D2 S+X=>D D1+D2=D
    <- efxmap2tgtmap-preserves-fresh N!<GP GP+X=>MP N!<MP
    <- efxmap2tgtmap-preserves-fresh N!<G1P G1P+X=>M1P N!<M1P
    <- efxmap2tgtmap-preserves-fresh N!<G2P G2P+X=>M2P N!<M2P
    <- tgtmap`fresh-update-implies-unit-join N!<MP MP+N+D=M MP+D=M
    <- tgtmap`join-associative-converse
      (tgtmap`join/= tgtmap`join/L D1+D2=D nat`eq/) MP+D=M MPD1 MP+D1=MPD1 MPD1+D2=M
    <- tgtmap`join-associative
      M1P+M2P=MP MP+D1=MPD1 M2PD1 M2P+D1=M2PD1 M1P+M2PD1=MPD1
    <- tgtmap`fresh-implies-unit-deep-disjoint N!<M2P M2P^D1
    <- tgtmap`deep-disjoint-join-commutative M2P^D1 M2P+D1=M2PD1 D1+M2P=M2PD1
    <- tgtmap`join-associative-converse D1+M2P=M2PD1 M1P+M2PD1=MPD1 M1
      M1P+D1=M1 M1+M2P=MPD1
    <- tgtmap`join-associative M1+M2P=MPD1 MPD1+D2=M M2 M2P+D2=M2 M1+M2=M
    <- tgtmap`fresh-unit-join-implies-update N!<M1P M1P+D1=M1 M1P+N+D1=M1
    <- tgtmap`fresh-unit-join-implies-update N!<M2P M2P+D2=M2 M2P+N+D2=M2
    <- tgtmap`update-disjoint-preserves-deep-disjoint M1P^M2P M1P+N+D1=M1 M2P+N+D2=M2
    D1^D2 M1^M2.

- : efxmap2tgtmap-preserves-deep-disjoint-join
    (efxmap2tgtmap/U GP=>MP S=>D N!<GP GP+N=G MP+N=M)
    G1^G2 G1+G2=G %{=>}% M1 M2 G1=>M1 G2=>M2 M1^M2 M1+M2=M
    <- efxmap`domain?-total MB1?
    <- efxmap`domain?-total MB2?
    <- efxmap2tgtmap-preserves-deep-disjoint-join/L
      GP=>MP S=>D N!<GP GP+N=G MP+N=M G1^G2 G1+G2=G MB1? MB2?
      _ _ G1=>M1 G2=>M2 M1^M2 M1+M2=M.

%worlds () (efxmap2tgtmap-preserves-deep-disjoint-join _ _ _ _ _ _ _ _ _)
(efxmap2tgtmap-preserves-deep-disjoint-join/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N1 N2) (efxmap2tgtmap-preserves-deep-disjoint-join N1 _ _ _ _ _ _ _ _)
(efxmap2tgtmap-preserves-deep-disjoint-join/L N2 _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem tgtmap2efxmap-implies-efxmap2tgtmap
  : forall* {G} {M} {X}
    forall {G2M: tgtmap2efxmap G X M}
    exists {M2G: efxmap2tgtmap M G}
    true.

- : tgtmap2efxmap-implies-efxmap2tgtmap tgtmap2efxmap/0 efxmap2tgtmap/0.

- : tgtmap2efxmap-implies-efxmap2tgtmap
    (tgtmap2efxmap/U GP+X=>MP S+X=>D N!<GP GP+N+S=G MP+N+D=M)
    (efxmap2tgtmap/U MP=>GP DM-D=S N!<MP MP+N+D=M GP+N+S=G)
    <- tgtmap2efxmap-implies-efxmap2tgtmap GP+X=>MP MP=>GP
    <- set2inner-efxmap-implies-domain S+X=>D DM-D=S
    <- tgtmap2efxmap-preserves-fresh N!<GP GP+X=>MP N!<MP.

%worlds () (tgtmap2efxmap-implies-efxmap2tgtmap _ _).
%total (T) (tgtmap2efxmap-implies-efxmap2tgtmap T _).
