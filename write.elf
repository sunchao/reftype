%%% The following two definitions should only be used in this file.

%%% all permissions for objects in the set.

set-all-permissions : predmap -> cxt -> nat -> set -> permission -> type.

set-all-permissions/0 : set-all-permissions _ _ _ set/0 empty.

set-all-permissions/U :
    set-all-permissions PM B C S' Pi ->
    set`not-member S' (s N) ->
    set`add S' (s N) S ->
    cxt`lookup B (s N) (cxt-info/ O (ty/ _ _ C)) ->
    ty2perm PM (ty/ nn/may annot/unique C) PF ->
  set-all-permissions PM B C S ((PF O) , Pi).


set-all-permissions* : predmap -> cxt -> nat -> set -> permission -> type.

set-all-permissions*/0 : set-all-permissions* _ _ _ set/0 empty.

set-all-permissions*/U :
    set-all-permissions* PM B C S' Pi ->
    set`not-member S' (s N) ->
    set`add S' (s N) S ->
    cxt`lookup B (s N) (cxt-info/ O (ty/ NN _ C)) ->
    ty2perm PM (ty/ NN annot/unique C) PF ->
  set-all-permissions* PM B C S ((PF O) , Pi).



%%% A few theorems about make-encumbered

%theorem make-encumbered-intro
  : forall* {CM} {PM} {B} {U0} {U1} {S} {PiU0}
    forall {S<=U0: set`leq S U0}
    {U0-S=U1: set`remove U0 S U1}
    {U0=>PiU0: make-encumbered CM PM B U0 PiU0}
    exists {PiS} {PiU1}
    {S=>PiS: make-encumbered CM PM B S PiS}
    {U1=>PiU1: make-encumbered CM PM B U1 PiU1}
    {EQV: equiv PiU0 (PiS , PiU1)}
    true.

%worlds (gtermvar) (make-encumbered-intro _ _ _ _ _ _ _ _).
%trustme %total { } (make-encumbered-intro _ _ _ _ _ _ _ _).


%theorem make-encumbered-intro-reverse
  : forall* {CM} {PM} {B} {U0} {U1} {U} {PiU0} {PiU1}
    forall {U0+U1=U: set`union U0 U1 U}
    {U0=>PiU0: make-encumbered CM PM B U0 PiU0}
    {U1=>PiU1: make-encumbered CM PM B U1 PiU1}
    exists {PiU}
    {U=>PiU: make-encumbered CM PM B U PiU}
    {EQV: equiv (PiU0 , PiU1) PiU}
    true.

%worlds (gtermvar) (make-encumbered-intro-reverse _ _ _ _ _ _).
%trustme %total { } (make-encumbered-intro-reverse _ _ _ _ _ _).



reftype2ty : reftype -> ty -> type.

reftype2ty/shared : reftype2ty (reftype/ NN C targets/shared) (ty/ NN annot/shared C).

reftype2ty/fresh : reftype2ty (reftype/ NN C targets/fresh) (ty/ NN annot/unique C).

%% TODO: maybe annot/borrow more making sense?
reftype2ty/unique : reftype2ty (reftype/ NN C (targets/unique _ _ _)) (ty/ NN annot/unique C).


%%% A format before we checking write.

before-write-format : clsmap -> predmap -> cxt -> expr-result -> expr-output -> type.

before-write-format/expr :
    make-encumbered CM PM B U PiU ->
    cxt2perm PM B PiB ->
    capset2perm CM PM B M PiM ->
    reftype2ty RT T ->
    ty2perm PM T ([x] PF x) ->
  before-write-format CM PM B (result/expr RT (env/ U M))
      (output/exists [x]
        (output/exists [p:permission]
          (output/expr x (combine PiU (combine PiB (combine (PF x) PiM)))))).

%%% A few theorems about set-all-permissions

%theorem set-all-permissions-respects-eq
  : forall* {PM} {PM'} {S} {S'} {Pi} {Pi'} {B} {C}
    forall {SAP: set-all-permissions PM B C S Pi}
    {PME: predmap`eq PM PM'} {SE: set`eq S S'} {PE: permission`eq Pi Pi'}
    exists {SAP: set-all-permissions PM' B C S' Pi'}
    true.

- : set-all-permissions-respects-eq SAP predmap`eq/ set`eq/ permission`eq/ SAP.

%worlds (gtermvar) (set-all-permissions-respects-eq _ _ _ _ _).
%total { } (set-all-permissions-respects-eq _ _ _ _ _).


%theorem restore-object-permission/L1
  : forall* {N} {FS} {S} {R} {S2}
    forall {N!<S: set`not-member S N}
    {N+FS=>S: nat+set2set N FS R}
    {S+FS=>S2': set+set2set S FS S2}
    exists {D: set`disjoint S2 R}
    true.

%theorem restore-object-permission/L1L
  : forall* {N} {FS} {S} {R} {S2}
    forall {N!<S: set`not-member S N}
    {N+FS=>S: nat+set2set N FS R}
    {S+FS=>S2': set+set2set S FS S2}
    {B} {D?: set`disjoint? S2 R B}
    exists {D: set`disjoint S2 R}
    true.

- : restore-object-permission/L1L _ _ _ _ (set`disjoint?/yes D) D.

- : restore-object-permission/L1L (N!<S:set`not-member S N)
    (N+FS=>R:nat+set2set N FS R) S+FS=>S2 false
    (set`disjoint?/no (K<-S2:set`member S2 K) (K<-R:set`member R K)) S2^R
    <- set`member-respects-eq K<-R set`eq/ nat`eq/ K->R=C
    <- set`member-implies-not-member-add K->R=C R' K!<R' R'+K=R
    <- set+set2set-member-implies-nat2pair S+FS=>S2 K<-S2 N0 F N0<-S F<-FS K=>N0+F
    <- nat+set2set/UP-inversion N+FS=>R K!<R' R'+K=R _ N+FS=R' F0 K=>N+F0 FS+F0=FS
    <- nat2pair-unique K=>N0+F K=>N+F0 nat`eq/ PE
    <- pair-eq-implies-eq PE N0=N F=F0
    <- set`not-member-member-not-equal N!<S N0<-S N<>N0
    <- nat`ne-symmetric N<>N0 N0<>N
    <- nat`eq-ne-implies-false N0=N N0<>N V
    <- set`false-implies-disjoint V S2^R.

%worlds (gtermvar) (restore-object-permission/L1L _ _ _ _ _ _).
%total { } (restore-object-permission/L1L _ _ _ _ _ _).

- : restore-object-permission/L1 N!<S N+FS=>S S+FS=>S2' S2^R
    <- set`disjoint?-total S2^R?
    <- restore-object-permission/L1L N!<S N+FS=>S S+FS=>S2' _ S2^R? S2^R.

%worlds (gtermvar) (restore-object-permission/L1 _ _ _ _).
%total { } (restore-object-permission/L1 _ _ _ _).


%theorem fldmap`fresh-update-empty-implies-eq
  : forall* {S} {N} {T}
    forall {F: fldmap`fresh S N}
    {U: fldmap`update S N T (fldmap/+ N T fldmap/0)}
    exists {EQ: fldmap`eq S fldmap/0}
    true.

- : fldmap`fresh-update-empty-implies-eq fldmap`fresh/0 fldmap`update/0 fldmap`eq/.

- : fldmap`fresh-update-empty-implies-eq NM (fldmap`update/= NE) SE
    <- fldmap`fresh-lookup-not-equal NM (fldmap`lookup/= NE) NNE
    <- nat`ne-anti-reflexive NNE F
    <- fldmap`false-implies-eq F SE.

%worlds (gtermvar) (fldmap`fresh-update-empty-implies-eq _ _ _).
%total { } (fldmap`fresh-update-empty-implies-eq _ _ _).


%%% We changed fldset2perm, and thus need to change the proof itself too.

%theorem restore-object-permission/L2L1
  : forall* {O1} {O2} {N1} {N2} {PF}
    forall {OE: object`eq O2 O1}
    {NE: nat`eq N2 N1}
    exists {EQV: implies
                 (unitperm
                   (conditional (objequal O2 null) empty
                     (unitperm
                       (precise-exists O2 N1 ([x:gterm objectk] PF x)))))
                 (unitperm
                   (conditional (objequal O1 null) empty
                     (combine
                       (unitperm
                         (precise-exists O1 N2 ([x:gterm objectk] PF x)))
                       empty)))}
    true.

- : restore-object-permission/L2L1 object`eq/ nat`eq/
    (implies/cond-inner
      (bimplies/reflexive)
      (bimplies/reflexive)
      (implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/identity))).

%worlds (gtermvar) (restore-object-permission/L2L1 _ _ _).
%total { } (restore-object-permission/L2L1 _ _ _).


%theorem restore-object-permission/L2L2
  : forall* {O} {O'} {F0} {N3}
    forall {PF: object -> permission} {PF2: object -> permission}
    {OE: object`eq O' O} {FE: nat`eq F0 N3}
    exists {KKK:implies
                 (combine
                   (unitperm
                     (conditional (objequal O' null) empty
                       (unitperm
                         (precise-exists O' F0 ([x:gterm objectk] PF x)))))
                   (unitperm (conditional (objequal O null) empty (PF2 O))))
                 (unitperm
                   (conditional (objequal O null) empty
                     (combine
                       (unitperm
                         (precise-exists O N3 ([x:gterm objectk] PF x)))
                       (PF2 O))))}
    true.

- : restore-object-permission/L2L2 _ _ object`eq/ nat`eq/
    (implies/trans
      (implies/cond-factor)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/identity)
        (implies/reflexive))).

%worlds (gtermvar) (restore-object-permission/L2L2 _ _ _ _ _).
%total { } (restore-object-permission/L2L2 _ _ _ _ _).


%theorem restore-object-permission/L2L3
  : forall* {PM} {FM} {FS} {Pi} {O}
    forall {V:void}
    exists {PiF}
    {SFP: {x} fldset2perm PM x FM FS (PiF x)}
    {Pi=>PiF: implies Pi (unitperm (conditional (objequal O null) empty (PiF O)))}
    true.

%worlds (gtermvar) (restore-object-permission/L2L3 _ _ _ _).
%total { } (restore-object-permission/L2L3 _ _ _ _).


%theorem restore-object-permission/L2
  : forall* {CM} {PM} {FM} {B} {M} {N} {Pi} {A} {C} {O} {FS} {FS0} {NN}
    forall {BL: cxt`lookup B (s N) (cxt-info/ O (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    {N+FS=>S: nat+set2set (s N) FS M}
    {M=>Pi: capset2perm CM PM B M Pi}
    exists {PiF}
    {SFP: {x} fldset2perm PM x FM FS (PiF x)}
    {Pi=>PiF: implies Pi (unitperm (conditional (objequal O null) empty (PiF O)))}
    true.

- : restore-object-permission/L2 _ _ _ _
    (nat+set2set/U _ (P2K:pair2nat (pair/ (s _) _) z) _ _ _) _ _ SFP IMP
    <- pair2nat-total-s _ _ _ P2KP
    <- nat`succ-preserves-eq nat`eq/ SE
    <- pair-preserves-eq SE nat`eq/ PE
    <- pair2nat-unique P2K P2KP PE EQ
    <- nat`eq-contradiction EQ V
    <- restore-object-permission/L2L3 V _ SFP IMP.

- : restore-object-permission/L2 _ _ _ set`leq/0
    nat+set2set/0 capset2perm/0 _ ([_] fldset2perm/0) implies/cond-equal-objequal.

- : restore-object-permission/L2 (BL:cxt`lookup _ _ (cxt-info/ O _)) CML
    FM-DM=FS0 FS<=FS0
    (nat+set2set/U N+FS'=>M' K=>N+F F!<FS' FS'+F=FS M'+K+W=M) M=>Pi _ MFP1
    (implies/trans4
      (implies/equiv (equiv/symmetric PF+Pi'<=>Pi))
      (implies/combine implies/reflexive IMP)
      (IMP2)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (implies/equiv (EQV2 O))))
    <- nat+set2set-preserves-not-member N+FS'=>M' F!<FS' K=>N+F K!<M'
    <- set`not-member-update-implies-leq F!<FS' FS'+F=FS FS'<=FS
    <- set`leq-transitive FS'<=FS FS<=FS0 FS'<=FS0
    <- capset2perm/U-inversion M=>Pi K!<M' M'+K+W=M N0 F0 K=>N0+F0
      O' _ _ _ BL0 _ (create-fldperm/ CML0 FML0 T2PF0) _ M'=>Pi' PF+Pi'<=>Pi
    <- nat2pair-unique K=>N0+F0 K=>N+F nat`eq/ PE
    <- pair-eq-implies-eq PE N0=N F0=F
    <- cxt`lookup-unique BL0 BL cxt`eq/ N0=N CIO=CI
    <- cxt-info-eq-inversion CIO=CI O0=O T0=T
    <- ty-eq-inversion T0=T NN0=NN _ C0=C
    <- clsmap`lookup-unique CML0 CML clsmap`eq/ C0=C (FM0=FM:fldmap`eq FM0 FM)
    <- set`add-implies-member FS'+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
    <- fldmap`domain-preserves-lookup-converse F<-FS0 FM-DM=FS0 T FML
    <- fldmap`lookup-unique FML0 FML FM0=FM F0=F FT0=FT
    <- ty2perm-respects-eq T2PF0 predmap`eq/ FT0=FT ([_] permission`eq/) T2PF
    <- restore-object-permission/L2 BL CML FM-DM=FS0 FS'<=FS0 N+FS'=>M'
      M'=>Pi' PF2 ([x] FS'=>Pi' x) IMP
    <- ({x} fresh-update-preserves-fldset2perm F!<FS' FS'+F=FS (FS'=>Pi' x) FML
         (T2PF:ty2perm _ _ PF) _ (MFP1 x) (EQV2 x))
    <- restore-object-permission/L2L2 PF PF2 O0=O F0=F IMP2.

%worlds (gtermvar) (restore-object-permission/L2 _ _ _ _ _ _ _ _ _).
%total (A) (restore-object-permission/L2 _ _ _ _ A _ _ _ _).


%theorem restore-object-permission/L3
  : forall* {PM} {C} {CP} {Pi} {PF3}
    forall {O} {PML: predmap`lookup PM C CP}
    {EQ: {x} equiv (PF3 x) (Pi x)}
    exists {IMP: implies (combine (encumbered-fldperm O Pi CP)
                           (unitperm (conditional (objequal O null) empty (PF3 O))))
                 (unitperm (conditional (objequal O null) empty
                             (combine (allperm O) (one-predcall CP O))))}
    true.

- : restore-object-permission/L3 O PML EQV
    (implies/trans
      (implies/cond-factor)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/identity)
        (implies/trans3
          (implies/equiv equiv/commute)
          (implies/combine (implies/equiv (EQV O)) implies/reflexive)
          (implies/linear-modus-ponens)))).

%worlds (gtermvar) (restore-object-permission/L3 _ _ _ _).
%total { } (restore-object-permission/L3 _ _ _ _).


%theorem restore-object-permission/F
  : forall* {PM} {B} {S} {C} {Pi} {Pi2}
    forall {V:void}
    exists {Pi3} {IMP: implies (Pi2 , Pi) Pi3}
    {SAP: set-all-permissions PM B C S Pi3}
    true.

%worlds (gtermvar) (restore-object-permission/F _ _ _ _).
%total { } (restore-object-permission/F _ _ _ _).


%theorem restore-object-permission/L
  : forall* {O1} {O0} {X1}
    forall {OE: object`eq O1 O0}
    exists {EQV3:equiv
                  (unitperm
                    (conditional (objequal O1 null) empty
                      (combine (allperm O1) (one-predcall X1 O1))))
                  (unitperm
                    (conditional (objequal O0 null) empty
                      (combine (allperm O0) (one-predcall X1 O0))))}
    true.

- : restore-object-permission/L object`eq/ equiv/reflexive.

%worlds (gtermvar) (restore-object-permission/L _ _).
%total { } (restore-object-permission/L _ _).


%theorem restore-object-permission
  : forall* {CM} {PM} {B} {S} {FS} {Pi} {M} {Pi2} {C} {FM} {NN}
    forall {SOC: cxt-unique-objset B NN C S}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {MF: make-encumbered CM PM B S Pi}
    {S+FS=>S2: set+set2set S FS M}
    {M2P: capset2perm CM PM B M Pi2}
    exists {Pi3} {IMP: implies (Pi2 , Pi) Pi3}
    {SAP: set-all-permissions PM B C S Pi3}
    true.

- : restore-object-permission _ _ _ _ make-encumbered/0 S+FS+X=>M2 M2=>Pi2 _
    (implies/trans (implies/combine (implies/equiv EQV) implies/reflexive)
      (implies/equiv equiv/identity))
    (set-all-permissions/0)
    <- set+set2set-unique S+FS+X=>M2 set+set2set/0 set`eq/ set`eq/ M2=0
    <- capset2perm-equiv M2=>Pi2 capset2perm/0 clsmap`eq/ predmap`eq/ cxt`eq/ M2=0 EQV.

- : restore-object-permission
    (SOC:cxt-unique-objset B NN C S) (CM2PM:clsmap2predmap CM PM)
    (CML0:clsmap`lookup CM C FM0)
    (FM-DM0:fldmap`domain FM0 FS0)
    (make-encumbered/U (S'=>Pi':make-encumbered CM PM B SP PiP)
      (BL1:cxt`lookup B _ (cxt-info/ O1 (ty/ NN1 A1 C1)))
      (CML1:clsmap`lookup CM C1 FM1) PML
      (DM-FM:fldmap`domain FM1 FS1)
      MF1 (N!<S':set`not-member SP shared) (S'+N=S:set`add SP shared S))
    (S+FS=>M2:set+set2set S FS0 M2)
    (M2=>Pi2:capset2perm CM PM B M2 Pi2) _ IMP SAP
    <- set`add-implies-member S'+N=S MB
    <- cxt-unique-objset-no-zero SOC MB V
    <- restore-object-permission/F V _ IMP SAP.

- : restore-object-permission
    (SOC:cxt-unique-objset B NN C S) (CM2PM:clsmap2predmap CM PM)
    (CML0:clsmap`lookup CM C FM0)
    (FM-DM0:fldmap`domain FM0 FS0)
    (make-encumbered/U (S'=>Pi':make-encumbered CM PM B SP PiP)
      (BL1:cxt`lookup B _ (cxt-info/ O1 (ty/ NN1 A1 C1)))
      (CML1:clsmap`lookup CM C1 FM1) PML
      (DM-FM:fldmap`domain FM1 FS1)
      MF1 (N!<S':set`not-member SP (s N1)) (S'+N=S:set`add SP (s N1) S))
    (S+FS=>M2:set+set2set S FS0 M2)
    (M2=>Pi2:capset2perm CM PM B M2 Pi2) _
    (implies/trans5
      (implies/combine (implies/equiv Pi2<=>Pi2'+PiR) implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive
        (implies/trans3
          (implies/combine (Pi=>PiF2) implies/reflexive)
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/equiv equiv/commute)
              (IMP2))
            (implies/reflexive))))
      (implies/equiv equiv/roll2)
      (implies/combine (implies/equiv EQV3) IMP))
    (set-all-permissions/U S'-Pi3 N!<S' S'+N=S BL1'
      (ty2perm/ PML2 nn2perm/may annot2perm/unique))
    <- cxt-unique-objset/U-inversion SOC N!<S' S'+N=S SOC' O0 A0 NN0 BL0 _ _
    <- set+set2set/U-inversion
      S+FS=>M2 N!<S' S'+N=S S2P R S'+FS=>M2' N+FS=>MR M2'+MR=M2
    <- restore-object-permission/L1 N!<S' N+FS=>MR S'+FS=>M2' M2'^MR
    <- capset`disjoint-join-implies-equiv M2'^MR M2'+MR=M2 M2=>Pi2
      Pi2' PiR M2'=>Pi2' MR=>PiR Pi2<=>Pi2'+PiR
    <- cxt`lookup-unique BL0 BL1 cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE (OE:object`eq O0 O1) TE
    <- cxt-info`eq-symmetric CIE CIE'
    <- object`eq-symmetric OE OEP
    <- ty-eq-inversion TE NNE AE (CE:nat`eq C C1)
    <- clsmap`lookup-unique CML0 CML1 clsmap`eq/ CE FME
    <- fldmap`domain-respects-eq FM-DM0 FME set`eq/ FM-DM
    <- restore-object-permission SOC' CM2PM CML0 FM-DM0 S'=>Pi'
      S'+FS=>M2' M2'=>Pi2' _ IMP S'-Pi3
    <- set`leq-reflexive _ FS<=FS
    <- restore-object-permission/L2 BL1 CML1 FM-DM FS<=FS N+FS=>MR MR=>PiR
      _ ([x] MF1F' x) Pi=>PiF2
    <- fldmap`domain-unique FM-DM0 DM-FM FME FSE
    <- ({x} fldset2perm-unique (MF1F' x)
         (MF1 x) predmap`eq/ object`eq/ fldmap`eq/ FSE (PEQ x))
    <- ({x} permission`eq-implies-equiv (PEQ x) (PEQV x))
    <- restore-object-permission/L3 O1 PML PEQV IMP2
    <- cxt`lookup-respects-eq BL1 cxt`eq/ nat`eq/ CIE' BL1'
    <- nat`eq-symmetric CE CE2
    <- predmap`lookup-respects-eq PML predmap`eq/ CE2 predicate`eq/ PML2
    <- restore-object-permission/L OEP EQV3.

%worlds (gtermvar) (restore-object-permission _ _ _ _ _ _ _ _ _ _).
%total (C) (restore-object-permission _ _ _ _ C _ _ _ _ _).


%theorem set-all-permissions-implies/L1
  : forall* {O1} {O2} {O} {Pi}
    forall {EQ: object`eq O2 O1}
    exists {EQV: equiv (unitperm (conditional (objequal O O2) empty Pi))
                 (unitperm (conditional (objequal O O1) empty Pi))}
    true.

- : set-all-permissions-implies/L1 object`eq/ equiv/reflexive.

%worlds (gtermvar) (set-all-permissions-implies/L1 _ _).
%total { } (set-all-permissions-implies/L1 _ _).


%theorem set-all-permissions-implies/L2
  : forall* {O} {O2} {PF: object -> permission} {PF2}
    forall {OE: object`eq O O2}
    {IMP: {x} implies (PF x) (PF2 x)}
    exists {IMP: implies (PF O) (PF2 O2)}
    true.

- : set-all-permissions-implies/L2 (object`eq/:object`eq O O) ([x] IMP x) (IMP O).

%worlds (gtermvar) (set-all-permissions-implies/L2 _ _ _).
%total { } (set-all-permissions-implies/L2 _ _ _).


%theorem set-all-permissions*-equiv
  : forall* {PM} {S} {S'} {Pi} {Pi'} {B} {C}
    forall {SAP: set-all-permissions* PM B C S Pi}
    {SAP: set-all-permissions* PM B C S' Pi'}
    {SE: set`eq S S'}
    exists {EQV: equiv Pi Pi'}
    true.

%worlds (gtermvar) (set-all-permissions*-equiv _ _ _ _).
%trustme %total { } (set-all-permissions*-equiv _ _ _ _).


%theorem set-all-permissions-implies/L3/L
  : forall* {PM} {C} {PF}
    forall {T2PF: ty2perm PM (ty/ nn/may annot/unique C) PF}
    exists {PF2} {T2PF2: ty2perm PM (ty/ nn/yes annot/unique C) PF2}
    {IMP: {x} implies (combine (unitperm (nonlinear (neg (objequal x null)))) (PF x)) (PF2 x)}
    true.

- : set-all-permissions-implies/L3/L
    (ty2perm/ PML nn2perm/may A2P) _ (ty2perm/ PML nn2perm/yes A2P)
    ([_] implies/reflexive).

%worlds (gtermvar) (set-all-permissions-implies/L3/L _ _ _ _).
%total { } (set-all-permissions-implies/L3/L _ _ _ _).


%theorem set-all-permissions-implies/L3
  : forall* {PM} {B} {C} {S} {Pi1} {Pi2}
    forall {B=>Pi: cxt2perm PM B Pi1}
    {SAP: set-all-permissions PM B C S Pi2}
    exists {Pi3} {SAP*: set-all-permissions* PM B C S Pi3}
    {IMP: implies (Pi1 , Pi2) (Pi1 , Pi3)}
    true.

- : set-all-permissions-implies/L3 B=>Pi
    set-all-permissions/0 _ set-all-permissions*/0 implies/reflexive.

- : set-all-permissions-implies/L3 B=>Pi1
    (set-all-permissions/U SAP F U
      (BL:cxt`lookup B0 _ (cxt-info/ _ (ty/ nn/may _ _))) T2PF)
    _ (set-all-permissions*/U SAP' F U BL T2PF)
    (implies/trans3
      (implies/equiv equiv/roll2)
      (implies/combine implies/reflexive IMP)
      (implies/equiv equiv/roll2))
    <- set-all-permissions-implies/L3 B=>Pi1 SAP _ SAP' IMP.

- : set-all-permissions-implies/L3 B=>Pi1
    (set-all-permissions/U SAP F U
      (BL0:cxt`lookup B0 _ (cxt-info/ _ (ty/ nn/yes _ _))) T2PF)
    _ (set-all-permissions*/U SAP' F U BL0 T2PF2)
    (implies/trans6
      (implies/combine IMP3 implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive (implies/equiv equiv/roll2))
      (implies/equiv equiv/associate)
      (implies/combine (IMP2 _) IMP)
      (implies/equiv equiv/roll2))
    <- set-all-permissions-implies/L3 B=>Pi1 SAP _ SAP' IMP
    <- set-all-permissions-implies/L3/L T2PF _ T2PF2 IMP2
    <- cxt2perm-duplicate-notnull-info B=>Pi1 BL0 IMP3.

%worlds (gtermvar) (set-all-permissions-implies/L3 _ _ _ _ _).
%total (SAP) (set-all-permissions-implies/L3 _ SAP _ _ _).


%theorem set-all-permissions-implies
  : forall* {S} {Pi} {GF} {O} {B} {PM} {C} {NN}
    forall {N} {SZ: set`size S (s N)}
    {SAP: set-all-permissions* PM B C S Pi}
    {S=>G: set2cond B O S GF}
    {LNN: cxt-unique-objset B NN C S}
    exists {PF} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    {Pi2} {IMP: implies (GF , Pi) ((PF O) , Pi2)}
    true.

- : set-all-permissions-implies z SZ
    (set-all-permissions*/U (S=>Pi:set-all-permissions* PM B C S' Pi)
      (F:set`not-member _ _) U
      (BL:cxt`lookup B _ (cxt-info/ O (ty/ NN1 A C))) T2PF) S=>GF
    (MN-NN:cxt-unique-objset B NN C S) _ (T2PF2:ty2perm _ _ PF) _
    (implies/trans7
      (implies/combine BIMP
        (implies/trans
          (implies/combine implies/reflexive (implies/equiv EQV))
          (implies/equiv equiv/identity)))
      (implies/combine (implies/equiv EQV2) implies/reflexive)
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (implies/nonlinear bimplies/objequal-symmetric)
                (IMP O))
              (implies/objequal ([y] PF y)))
            (implies/reflexive)))
        (implies/trans4
          (implies/equiv equiv/commute)
          (implies/combine
            (implies/combine implies/reflexive
              (implies/trans BIMP2 implies/contradiction))
            (implies/nonlinear2empty))
          (implies/equiv
            (equiv/transitive
              (equiv/symmetric equiv/associate)
              (equiv/roll2)))
          (implies/trans
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/trans
                (implies/combine
                  (implies/nonlinear bimplies/objequal-symmetric)
                  (IMP O))
                (implies/objequal ([y] PF y)))
              (implies/reflexive)))))
      (implies/cond-pull))
    <- set`not-member-update-increases-size-converse SZ F U SZ'
    <- set`size-zero-implies-empty SZ' S=0
    <- set-all-permissions*-equiv S=>Pi set-all-permissions*/0 S=0 EQV
    <- set2cond/U-inversion S=>GF F U _ S'=>GF' O2 T2 BL2 BIMP _
    <- set2cond-implies S'=>GF' set2cond/0 object`eq/ S=0 BIMP2 _
    <- set`eq-symmetric S=0 E=S
    <- cxt-unique-objset/U-inversion MN-NN F U _ O3 A3 NN3 BL3 _ LE
    <- cxt`lookup-unique BL3 BL cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE O3=O TE
    <- ty-eq-inversion TE NNE _ CE
    <- cxt`lookup-unique BL2 BL cxt`eq/ nat`eq/ CIE2
    <- cxt-info-eq-inversion CIE2 O2=O _
    <- nonnull`leq-respects-eq LE nonnull`eq/ NNE LE'
    <- nn-leq-implies-permission-leq T2PF LE' _ T2PF2 IMP
    <- set-all-permissions-implies/L1 O2=O EQV2.

- : set-all-permissions-implies (s N) SZ
    (set-all-permissions*/U S'=>Pi' N!<S'
      S'+N=S (BL: cxt`lookup _ _ (cxt-info/ O _)) T2PF2)
    S=>GF MN-NN _ T2PF3 _
    (implies/trans6
      (implies/combine (GF=>E+GF') implies/reflexive)
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans4
          (implies/combine
            (implies/nonlinear
              (bimplies/objequal-symmetric))
            (implies/equiv equiv/identity))
          (implies/combine implies/reflexive % (IMP2 O)
            (implies/combine IMP3 implies/reflexive))
          (implies/equiv equiv/associate)
          (implies/combine (implies/objequal ([x] PF x)) implies/reflexive))
        (implies/trans3
          (implies/equiv equiv/commute)
          (implies/combine
            (implies/trans4
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive
                (implies/trans
                  (implies/equiv equiv/commute)
                  (IMP)))
              (implies/equiv equiv/roll2)
              (implies/combine (implies/equiv (EQV _)) implies/reflexive))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))))
      (implies/cond-pull))
    <- set2cond/U-inversion S=>GF N!<S' S'+N=S GF' S'=>GF' O2 T2 BL2 GF=>E+GF' _
    <- cxt-unique-objset/U-inversion MN-NN N!<S' S'+N=S MN-NN' _ _ _ BL' _ LE
    <- set`not-member-add-increases-size-converse SZ N!<S' S'+N=S SZ'
    <- set-all-permissions-implies N SZ' S'=>Pi' S'=>GF' MN-NN' _ T2PF _ IMP
    <- cxt`lookup-unique BL' BL cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE _ TE
    <- ty-eq-inversion TE NNE _ CE
    <- cxt`lookup-unique BL BL2 cxt`eq/ nat`eq/ CIE2
    <- cxt-info-eq-inversion CIE2 O=O2 _
    <- nonnull`leq-respects-eq LE nonnull`eq/ NNE LE'
    <- nn-leq-implies-permission-leq T2PF2 LE' _ (T2PF3:ty2perm _ _ PF) IMP2
    <- ty2perm-deterministic T2PF T2PF3 predmap`eq/ ty`eq/ PEF
    <- ({x} permission`eq-implies-equiv (PEF x) (EQV x))
    <- set-all-permissions-implies/L2 O=O2 IMP2 IMP3.

%worlds (gtermvar) (set-all-permissions-implies _ _ _ _ _ _ _ _ _).
%total (N) (set-all-permissions-implies N _ _ _ _ _ _ _ _).


%theorem set-all-permissions-implies*
  : forall* {PM} {S} {Pi} {GF} {O} {B} {NN} {C} {PF} {N}
    forall {SZ: set`size S (s N)}
    {SAP: set-all-permissions* PM B C S Pi}
    {S=>G: set2cond B O S GF}
    {LNN: cxt-unique-objset B NN C S}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    exists {Pi2} {_: implies (GF , Pi) (PF O , Pi2)}
    true.

- : set-all-permissions-implies* SZ SAP (S2GF:set2cond _ O _ _) FLN T2PF _
    (implies/trans IMP'
      (implies/combine (implies/equiv (EQV O)) implies/reflexive))
    <- set-all-permissions-implies _ SZ SAP S2GF FLN _ T2PF' _ IMP'
    <- ty2perm-deterministic T2PF' T2PF predmap`eq/ ty`eq/ PEF
    <- ({x} permission`eq-implies-equiv (PEF x) (EQV x)).

%worlds (gtermvar) (set-all-permissions-implies* _ _ _ _ _ _ _).
%total { } (set-all-permissions-implies* _ _ _ _ _ _ _).


%%% The version where `O` is a variable
%theorem set-all-permissions-implies-var
  : forall* {S} {Pi} {GF} {B} {PM} {C} {NN}
    forall {N} {SZ: set`size S (s N)}
    {SAP: set-all-permissions* PM B C S Pi}
    {S=>G: {x} set2cond B x S (GF x)}
    {LNN: cxt-unique-objset B NN C S}
    exists {PF} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    {Pi2} {IMP: {x} implies (GF x , Pi) ((PF x) , (Pi2 x))}
    true.

- : set-all-permissions-implies-var N SZ SAP S2G LNN _ T2PF _
    ([x] implies/trans (IMP x)
      (implies/combine (implies/equiv (EQV x x)) (implies/reflexive)))
    <- ({x} set-all-permissions-implies N SZ SAP (S2G x) LNN (PF x) (T2PFF x) (Pi2 x) (IMP x))
    <- ty2perm-no-var T2PFF _ EQ T2PF
    <- ({x}{x1} permission`eq-implies-equiv (EQ x x1) (EQV x x1)).

%worlds (gtermvar) (set-all-permissions-implies-var _ _ _ _ _ _ _ _ _).
%total { } (set-all-permissions-implies-var _ _ _ _ _ _ _ _ _).


%%% Lemmas for the main theorem make-before-write-format

%theorem make-before-write-format/L1*
  : forall* {PM} {B} {S} {C} {Pi} {NN} {GF} {PF}
    forall {N} {SZ: set`size S N}
    {SAP: set-all-permissions* PM B C S Pi}
    {FLN: cxt-unique-objset B NN C S}
    {G=>GF: {x} set2cond B x S (GF x)}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    exists {Pi2}
    {IMP: {x}{o} implies
          (combine (Pi , (PF o))
            (unitperm (conditional (objequal x o) empty (GF x))))
          (combine (PF x) (Pi2 x o))}
    true.

- : make-before-write-format/L1* z _ set-all-permissions*/0
    cxt-unique-objset/0 ([_] set2cond/0) (T2PF:ty2perm _ _ PF) _
    ([x][o] implies/trans4
      (implies/combine
        (implies/equiv (equiv/transitive equiv/commute equiv/identity))
        (implies/trans (cond-to-objequal x o)
          (implies/nonlinear bimplies/objequal-symmetric)))
      (implies/equiv equiv/commute)
      (implies/objequal ([x] PF x))
      (implies/equiv (equiv/symmetric equiv/identity))).

- : make-before-write-format/L1* (s _) SZ SAP MN G=>GF T2PF _
    ([x][o] implies/trans4
      (implies/combine (implies/equiv equiv/commute)
        (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive
        (implies/trans
          (implies/cond-push)
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/equiv equiv/identity)
            (implies/trans
              (implies/equiv equiv/commute)
              (IMP2 x)))))
      (implies/trans4
        (implies/cond-push)
        (implies/cond-gen-inner)
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/trans3
            (implies/combine
              (implies/nonlinear bimplies/objequal-symmetric)
              (implies/reflexive))
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/objequal ([x] PF x))
              (implies/reflexive)))
          (implies/equiv equiv/roll3))
        (implies/cond-pull)))
    <- ({r} set-all-permissions-implies* SZ SAP (G=>GF r) MN T2PF _ (IMP2 r)).

%worlds (gtermvar) (make-before-write-format/L1* _ _ _ _ _ _ _ _).
%total (N) (make-before-write-format/L1* N _ _ _ _ _ _ _).


%theorem make-before-write-format/L1
  : forall* {PM} {B} {S} {C} {Pi} {NN} {GF} {PF}
    forall {SAP: set-all-permissions* PM B C S Pi}
    {FLN: cxt-unique-objset B NN C S}
    {G=>GF: {x} set2cond B x S (GF x)}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    exists {Pi2}
    {IMP: {x}{o} implies
          (combine (Pi , (PF o))
            (unitperm (conditional (objequal x o) empty (GF x))))
          (combine (PF x) (Pi2 x o))}
    true.

- : make-before-write-format/L1 SAP FLN G2GF T2PF _ IMP
    <- set`size-total SZ
    <- make-before-write-format/L1* _ SZ SAP FLN G2GF T2PF _ IMP.

%worlds (gtermvar) (make-before-write-format/L1 _ _ _ _ _ _).
%total { } (make-before-write-format/L1 _ _ _ _ _ _).


%theorem make-before-write-format/L2
  : forall* {Q} {PF: object -> permission}
    forall {EQ: equ Q one}
    exists {EQV: {x} equiv (scale (fraction/ Q) (PF x)) (PF x)}
    true.

- : make-before-write-format/L2 equ/ ([_] equiv/one).

%worlds (gtermvar) (make-before-write-format/L2 _ _).
%total { } (make-before-write-format/L2 _ _).


%theorem make-before-write-format/L3
  : forall* {CP} {CPF}
    forall {PF:clspred -> object -> permission}
    {EQ: {x} predicate`eq (CPF x) (CP)}
    exists {EQV: {x} equiv (PF (CPF x) x) (PF CP x)}
    true.

- : make-before-write-format/L3 _ ([_] predicate`eq/) ([_] equiv/reflexive).

%worlds (gtermvar) (make-before-write-format/L3 _ _ _).
%total { } (make-before-write-format/L3 _ _ _).


%theorem make-before-write-format
  : forall* {CM} {PM} {V1} {V2} {Out0} {B} {V3} {FS} {C} {NN} {A} {RT}
    forall {CM2PM: clsmap2predmap CM PM}
    {CM-B-R: clsmap-result CM B (result/expr RT V1)}
    {SUB: subtype CM FS RT V1 (ty/ NN A C) V3 V2}
    {NB: not-borrow A} % field type should NOT be borrowed
    {R=>Out: result2output CM PM B (result/expr RT V1) Out0}
    exists {Out1}
    {TRANS: transform Out0 Out1}
    {BR-FMT: before-write-format CM PM B (result/expr RT V2) Out1}
    true.

%%% fresh to unique field
- : make-before-write-format CM2PM
    (clsmap-result/expr (clsmap-cxt-reftype/fresh CML)
      (clsmap-cxt-env/ _ CM-B0-M0))
    (subtype/ NN-LEQ (sub-annot/fresh _))
    _
    (result2output/expr (B=>PiB:cxt2perm PM B PiB)
      (env2input/ U0=>PiU0 (M0=>PiM0:capset2perm CM PM B M0 PiM0))
      (reftype2perm/fresh T2PF))
    _
    (transform/inside [o]
      (transform/trans
        (transform/rem-unused)
        (transform/inside [p:permission]
          (transform/implies
            (implies/equiv
              (equiv/transitive
                (equiv/identity)
                (equiv/roll3)))))))
    (before-write-format/expr U0=>PiU0 B=>PiB
      (M0=>PiM0:capset2perm CM PM B M0 PiM0) reftype2ty/fresh
      T2PF).

%%% borrowed to unique field
- : make-before-write-format CM2PM
    (clsmap-result/expr (clsmap-cxt-reftype/unique _ CM-B0-S _ _)
      (clsmap-cxt-env/ _ CM-B0-M0))
    (subtype/ NN-LEQ
      (sub-annot/unique CML DM-FM=FS (S+FS=>M2:set+set2set S FS M2)
        (M0-M2=M3:set`split M0 M2 M3) S<=U0 (U0-S=U1:set`remove U0 S U1) _)) _
    (result2output/expr (B=>PiB:cxt2perm PM B PiB)
      (env2input/ U0=>PiU0 (M0=>PiM0:capset2perm CM PM B M0 PiM0))
      (reftype2perm/borrow SZ-S set`size/0
        (ty2perm/ PML _ annot2perm/borrow)
        (S=>GF: {x} set2cond B x S (GF x)))) _
    (transform/inside [x]
      (transform/trans
        (transform/rem-unused)
        (transform/inside [p:permission]
          (transform/trans
            (transform/implies
              (implies/trans11
                (implies/equiv
                  (equiv/transitive4
                    (equiv/identity)
                    (equiv/roll3)
                    (equiv/associate)
                    (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))
                (implies/combine (implies/equiv (equiv/combine (EQV) equiv/reflexive))
                  (implies/combine implies/reflexive
                    (implies/combine implies/reflexive (implies/equiv PiM0<=>PiM2+PiM3))))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/equiv
                  (equiv/transitive3
                    (equiv/roll5)
                    (equiv/combine equiv/reflexive equiv/roll2)
                    (equiv/associate)))
                (implies/equiv
                  (equiv/transitive4
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive3
                        (equiv/symmetric equiv/associate)
                        (equiv/combine equiv/reflexive equiv/roll2)
                        (equiv/associate))
                      (equiv/reflexive))
                    (equiv/symmetric equiv/associate)
                    (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))
                (implies/combine (PiM2+Pi<=>PiS) implies/reflexive)
                (implies/equiv
                  (equiv/transitive3
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine equiv/commute equiv/reflexive)))
                (implies/trans5
                  (implies/equiv (equiv/symmetric equiv/associate))
                  (implies/combine implies/reflexive (implies/equiv equiv/associate))
                  (implies/combine implies/reflexive
                    (implies/combine
                      (implies/trans3
                        (implies/equiv equiv/commute)
                        (IMP1)
                        (implies/equiv equiv/commute))
                      (implies/reflexive)))
                  (implies/combine implies/reflexive
                    (implies/equiv (equiv/symmetric equiv/associate)))
                  (implies/equiv (equiv/associate)))
                (implies/equiv
                  (equiv/transitive4
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive3
                        (equiv/commute)
                        (equiv/reorder)
                        (equiv/commute))
                      (equiv/reflexive))
                    (equiv/symmetric equiv/associate)))
                (implies/combine
                  (implies/trans
                    (IMP2 x)
                    (implies/combine
                      (implies/equiv (EQV2 x))
                      (implies/reflexive)))
                  (implies/reflexive))
                (implies/equiv
                  (equiv/transitive8
                    (equiv/symmetric equiv/associate)
                    (equiv/roll4)
                    (equiv/combine equiv/reflexive equiv/roll2)
                    (equiv/associate)
                    (equiv/combine equiv/reflexive equiv/roll2)
                    (equiv/combine equiv/commute equiv/reflexive)
                    (equiv/symmetric equiv/associate)
                    (equiv/transitive3
                      (equiv/combine equiv/reflexive equiv/roll2)
                      (equiv/associate)
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/combine equiv/reflexive equiv/reorder)
                          (equiv/reorder))))))))
            (transform/drop)))))
    (before-write-format/expr U1=>PiU1 B=>PiB
      (M3=>PiM3:capset2perm CM PM B M3 PiM3) reftype2ty/unique
      (ty2perm/ PML2 NN2P A2P))
    <- make-encumbered-intro S<=U0 U0-S=U1 U0=>PiU0 _ PiU1 S=>PiS U1=>PiU1 EQV
    <- set`split-implies-permission-combine
      M0-M2=M3 M0=>PiM0 PiM2 PiM3 M2=>PiM2 M3=>PiM3 PiM0<=>PiM2+PiM3
    <- restore-object-permission CM-B0-S CM2PM CML DM-FM=FS S=>PiS S+FS=>M2 M2=>PiM2
      _ PiM2+Pi<=>PiS S-PiS
    <- set-all-permissions-implies/L3 B=>PiB S-PiS PiS* S-PiS* IMP1
    <- ({x} set-all-permissions-implies _ SZ-S S-PiS* (S=>GF x) CM-B0-S _
         (ty2perm/ (PMLP x) (NN2P:nn2perm _ _ PF) A2P) _ (IMP2 x))
    <- predmap`no-variable-lookup PMLP CP2 PML2 PEQ
    <- make-before-write-format/L3 PF PEQ EQV2.


%%% unique to unique field
- : make-before-write-format CM2PM
    (clsmap-result/expr (clsmap-cxt-reftype/unique _ CM-B-S _ _)
      (clsmap-cxt-env/ _ CM-B-M0))
    (subtype/ NN-LEQ
      (sub-annot/unique CML DM-FM=FS (S+FS=>M2:set+set2set S FS M2)
        (M0-M2=M3:set`split M0 M2 M3) S<=U0 (U0-S=U1:set`remove U0 S U1) _)) _
    (result2output/expr (B=>PiB:cxt2perm PM B PiB)
      (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
        (M0=>PiM0:capset2perm CM PM B M0 PiM0))
      (reftype2perm/unique SZ-M1
        (T2PF:ty2perm PM _ ([x] PF x)) ([x] B+S=>GF x)
        (M1=>PiM1:capset2perm CM PM B M1 PiM1))) _
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/inside [p:permission]
            (transform/trans
              (transform/implies
                (implies/trans11 % PiB0 , G , Q (ECUMB PiM1 , PiM0)
                  (implies/equiv
                    (equiv/transitive4
                      (equiv/identity)
                      (equiv/roll3)
                      (equiv/associate)
                      (equiv/combine
                        (equiv/commute)
                        (equiv/transitive
                          (equiv/symmetric equiv/associate)
                          (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))))
                  (implies/combine
                    (implies/equiv (equiv/combine equiv/reflexive (EQV)))
                    (implies/combine implies/reflexive % GF
                      (implies/combine (implies/equiv equiv/reflexive) % PF
                        (implies/combine
                          (implies/reflexive)
                          (implies/equiv PiM0<=>PiM2+PiM3)))))
                  (implies/equiv
                    (equiv/transitive4
                      (equiv/symmetric equiv/associate)
                      (equiv/roll6)
                      (equiv/combine equiv/reflexive equiv/roll2)
                      (equiv/associate)))
                  (implies/equiv
                    (equiv/transitive
                      (equiv/combine equiv/associate equiv/reflexive)
                      (equiv/symmetric equiv/associate)))
                  (implies/combine PiM2+Pi<=>PiS implies/reflexive)
                  (implies/equiv
                    (equiv/transitive4
                      (equiv/combine equiv/reflexive equiv/roll3)
                      (equiv/associate)
                      (equiv/combine equiv/reflexive equiv/roll2)
                      (equiv/associate)))
                  (implies/trans8
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive (implies/equiv equiv/roll2))
                    (implies/equiv equiv/associate)
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine (equiv/symmetric equiv/associate) equiv/reflexive)
                        (equiv/associate)))
                    (implies/combine
                      (implies/trans5
                        (implies/equiv equiv/commute)
                        (implies/equiv equiv/associate)
                        (implies/combine (IMP2) implies/reflexive)
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/equiv equiv/commute))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive (implies/equiv equiv/roll2))
                    (implies/equiv equiv/associate))
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine
                        (equiv/transitive
                          (equiv/swap)
                          (equiv/associate))
                        (equiv/reflexive))
                      (equiv/symmetric equiv/associate)
                      (equiv/combine equiv/reflexive equiv/associate)))
                  (implies/combine (IMP o r) implies/reflexive)
                  (implies/equiv
                    (equiv/transitive5
                      (equiv/combine equiv/commute equiv/reflexive)
                      (equiv/symmetric equiv/associate)
                      (equiv/combine equiv/reflexive equiv/roll3)
                      (equiv/associate)
                      (equiv/combine equiv/reflexive equiv/roll2)))
                  (implies/equiv
                    (equiv/combine equiv/reflexive
                      (equiv/symmetric equiv/associate)))))
              (transform/drop))))
        (transform/rem-unused)))
    (before-write-format/expr U1=>PiU1 B=>PiB
      (M3=>PiM3:capset2perm CM PM B M3 PiM3) reftype2ty/unique T2PF)
    <- make-encumbered-intro S<=U0 U0-S=U1 U0=>PiU0 _ PiU1 S=>PiS U1=>PiU1 EQV
    <- set`split-implies-permission-combine
      M0-M2=M3 M0=>PiM0 PiM2 PiM3 M2=>PiM2 M3=>PiM3 PiM0<=>PiM2+PiM3
    <- restore-object-permission CM-B-S CM2PM CML DM-FM=FS S=>PiS S+FS=>M2 M2=>PiM2
      PiS PiM2+Pi<=>PiS B-S-PiS
    <- set-all-permissions-implies/L3 B=>PiB B-S-PiS PiS* B-S-PiS* IMP2
    <- make-before-write-format/L1 B-S-PiS* CM-B-S B+S=>GF T2PF _ IMP.

%%% unique+fresh to unique field
- : make-before-write-format CM2PM
    (clsmap-result/expr (clsmap-cxt-reftype/unique _ CM-B-S _ wf-unique-targets/unique+fresh)
      (clsmap-cxt-env/ _ CM-B-M0))
    (subtype/ NN-LEQ
      (sub-annot/unique CML DM-FM=FS (S+FS=>M2:set+set2set S FS M2)
        (M0-M2=M3:set`split M0 M2 M3) S<=U0 (U0-S=U1:set`remove U0 S U1) _)) _
    (result2output/expr (B=>PiB:cxt2perm PM B PiB)
      (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
        (M0=>PiM0:capset2perm CM PM B M0 PiM0))
      (reftype2perm/unique+fresh
        (T2PF:ty2perm PM _ ([x] PF x)) ([x] B+S=>GF x)
        (M1=>PiM1:capset2perm CM PM B M1 PiM1))) _
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/inside [p:permission]
            (transform/trans
              (transform/implies
                (implies/trans11 % PiB0 , G , Q (ECUMB PiM1 , PiM0)
                  (implies/equiv
                    (equiv/transitive4
                      (equiv/identity)
                      (equiv/roll3)
                      (equiv/associate)
                      (equiv/combine
                        (equiv/commute)
                        (equiv/transitive
                          (equiv/symmetric equiv/associate)
                          (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))))
                  (implies/combine
                    (implies/equiv (equiv/combine equiv/reflexive (EQV)))
                    (implies/combine implies/reflexive % GF
                      (implies/combine (implies/equiv equiv/reflexive) % PF
                        (implies/combine
                          (implies/reflexive)
                          (implies/equiv PiM0<=>PiM2+PiM3)))))
                  (implies/equiv
                    (equiv/transitive4
                      (equiv/symmetric equiv/associate)
                      (equiv/roll6)
                      (equiv/combine equiv/reflexive equiv/roll2)
                      (equiv/associate)))
                  (implies/equiv
                    (equiv/transitive
                      (equiv/combine equiv/associate equiv/reflexive)
                      (equiv/symmetric equiv/associate)))
                  (implies/combine PiM2+Pi<=>PiS implies/reflexive)
                  (implies/equiv
                    (equiv/transitive4
                      (equiv/combine equiv/reflexive equiv/roll3)
                      (equiv/associate)
                      (equiv/combine equiv/reflexive equiv/roll2)
                      (equiv/associate)))
                  (implies/trans8
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive (implies/equiv equiv/roll2))
                    (implies/equiv equiv/associate)
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine (equiv/symmetric equiv/associate) equiv/reflexive)
                        (equiv/associate)))
                    (implies/combine
                      (implies/trans5
                        (implies/equiv equiv/commute)
                        (implies/equiv equiv/associate)
                        (implies/combine (IMP2) implies/reflexive)
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/equiv equiv/commute))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive (implies/equiv equiv/roll2))
                    (implies/equiv equiv/associate))
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine
                        (equiv/transitive
                          (equiv/swap)
                          (equiv/associate))
                        (equiv/reflexive))
                      (equiv/symmetric equiv/associate)
                      (equiv/combine equiv/reflexive equiv/associate)))
                  (implies/combine (IMP o r) implies/reflexive)
                  (implies/equiv
                    (equiv/transitive5
                      (equiv/combine equiv/commute equiv/reflexive)
                      (equiv/symmetric equiv/associate)
                      (equiv/combine equiv/reflexive equiv/roll3)
                      (equiv/associate)
                      (equiv/combine equiv/reflexive equiv/roll2)))
                  (implies/equiv
                    (equiv/combine equiv/reflexive
                      (equiv/symmetric equiv/associate)))))
              (transform/drop))))
        (transform/rem-unused)))
    (before-write-format/expr U1=>PiU1 B=>PiB
      (M3=>PiM3:capset2perm CM PM B M3 PiM3) reftype2ty/unique T2PF)
    <- make-encumbered-intro S<=U0 U0-S=U1 U0=>PiU0 _ PiU1 S=>PiS U1=>PiU1 EQV
    <- set`split-implies-permission-combine
      M0-M2=M3 M0=>PiM0 PiM2 PiM3 M2=>PiM2 M3=>PiM3 PiM0<=>PiM2+PiM3
    <- restore-object-permission CM-B-S CM2PM CML DM-FM=FS S=>PiS S+FS=>M2 M2=>PiM2
      PiS PiM2+Pi<=>PiS B-S-PiS
    <- set-all-permissions-implies/L3 B=>PiB B-S-PiS PiS* B-S-PiS* IMP2
    <- make-before-write-format/L1 B-S-PiS* CM-B-S B+S=>GF T2PF _ IMP.

- : make-before-write-format _ CM-B-Rslt
    (subtype/ _ (sub-annot/shared)) _
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM) (reftype2perm/shared T2PF)) _
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/inside [p:permission]
            (transform/implies
              (implies/equiv
                (equiv/transitive
                  (equiv/identity)
                  (equiv/roll3))))))
        (transform/rem-unused)))
    (before-write-format/expr U=>PiU B=>PiB M=>PiM reftype2ty/shared T2PF).

%worlds (gtermvar) (make-before-write-format _ _ _ _ _ _ _ _).
%total (T) (make-before-write-format _ _ _ _ T _ _ _).


%theorem subtype-implies-ty2perm-leq
  : forall* {CM} {PM} {RT} {V} {T1} {PF1} {NN2} {A2} {C2} {B} {M} {V3} {FS}
    forall {SUB: subtype CM FS RT V (ty/ NN2 A2 C2) V3 (env/ B M)}
    {RT=>T: reftype2ty RT T1}
    {T1=>PF1: ty2perm PM T1 PF1}
    exists {PF2} {T2=>PF2: ty2perm PM (ty/ NN2 A2 C2) PF2}
    {IMP: {x} implies (PF1 x) (PF2 x)}
    true.

%worlds (gtermvar) (subtype-implies-ty2perm-leq _ _ _ _ _ _).
%trustme %total { } (subtype-implies-ty2perm-leq _ _ _ _ _ _).


%theorem subtype-implies-ty2perm-leq*
  : forall* {CM} {PM} {RT} {V} {T1} {PF1} {PF2} {NN2} {A2} {C2} {B} {M} {V3} {FS}
    forall {SUB: subtype CM FS RT V (ty/ NN2 A2 C2) V3 (env/ B M)}
    {RT=>T: reftype2ty RT T1}
    {T1=>PF1: ty2perm PM T1 PF1}
    {T2=>PF2: ty2perm PM (ty/ NN2 A2 C2) PF2}
    exists {IMP: {x} implies (PF1 x) (PF2 x)}
    true.

%worlds (gtermvar) (subtype-implies-ty2perm-leq* _ _ _ _ _).
%trustme %total { } (subtype-implies-ty2perm-leq* _ _ _ _ _).


%%% This should be the final theorem
%%% B0 is the output context for checking E1,

%theorem do-write
  : forall* {CM} {PM} {W} {B} {U1} {U2} {M} {M1} {M2} {M3} {M4} {NN} {A} {FC} {FS}
    {G2} {PiB} {PiM} {PiM1} {PiM1'} {E2} {F} {PF} {Out} {PiU0} {V3} {RT} {P}
    forall {B2+M1=>Pi2: capset2perm CM PM B M1 PiM1'}
    {BF-READ-FMT: read-format CM PM B F PF (targets/unique set/0 M P) M1 PiM PiM1}
    {SUB: subtype CM FS RT (env/ U1 M2) (ty/ NN A FC) V3 (env/ U2 M3)}
    {T2PF: ty2perm PM (ty/ NN A FC) ([x] PF x)}
    {TYP-E2: typing W (PiB , (PiU0 , PiM1')) E2 Out}
    {BW-FMT: before-write-format CM PM B (result/expr RT (env/ U2 M3)) Out}
    {CF: consider-ftype (targets/unique set/0 M P) M3 A G2 M4}
    exists {Out1}
    {TYP: {x}{p:permission} typing W (combine PiB (combine PiU0 (combine (fperm x F PF)
      (combine (PiM x p) PiM1))))
      (write (lit x) F E2) Out1}
    {R=>Out1: result2output CM PM B (result/expr (reftype/ NN FC G2) (env/ U2 M4)) Out1}
    true.

- : do-write (M1=>PiM1':capset2perm CM PM B M1 PiM1')
    (read-format/unique+fresh
      (M1=>PiM1:capset2perm CM PM B M1 PiM1)
      (M=>PiM:capset2perm CM PM B M PiM))
    SUB (T2PF) (TYP-E2:typing W (PiB , (PiU , PiM1')) E2 _)
    (before-write-format/expr (U2=>PiU2:make-encumbered CM PM B U2 PiU2)
      (B=>PiB:cxt2perm PM B PiB')
      (M3=>PiM3:capset2perm CM PM B M3 PiM3) RT2T T2PF2)
    (consider-ftype/shared (set`split/ M^M3 M+M3=M4)) _
    ([x][p] tTrans
      (transform/implies
        (implies/trans
          (implies/combine implies/reflexive
            (implies/combine implies/reflexive
              (implies/combine (implies/equiv (equiv/symmetric equiv/one))
                (implies/combine
                  (implies/equiv-encumbered (equiv/symmetric equiv/one) equiv/reflexive)
                  (implies/reflexive)))))
          (implies/equiv
            (equiv/transitive7
              (equiv/associate)
              (equiv/combine equiv/reflexive % piB0
                (equiv/combine equiv/reflexive equiv/commute)) % PF
              (equiv/roll3)
              (equiv/associate)
              (equiv/combine
                (equiv/transitive
                  (equiv/commute)
                  (equiv/combine equiv/reflexive PiM1<=>PiM1'))
                (equiv/reflexive))
              (equiv/commute)
              (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))))
      (letTyping/base null
        (tWrite2 (TYP-E2' x p)
          (letTyping/exists [o]
            (letTyping/exists [v:permission]
              (letTyping/base o
                (tTrans
                  (transform/trans3
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine equiv/reflexive equiv/associate)
                          (equiv/symmetric equiv/associate))))
                    (transform/skolem)
                    (transform/inside [o']
                      (transform/implies
                        (implies/equiv
                          (equiv/transitive
                            (equiv/combine equiv/one equiv/reflexive)
                            (equiv/symmetric equiv/associate))))))
                  (letTyping/exists [o']
                    (letTyping/base null
                      (tWrite: typing _ _ (write (lit x) F (lit o)) _)))
                  (transform/inside [o']
                    (transform/trans
                      (transform/implies
                        (implies/trans4
                          (implies/equiv equiv/roll2)
                          (implies/combine implies/reflexive
                            (implies/trans7
                              (implies/combine implies/reflexive
                                (implies/equiv equiv/roll3))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans3
                                  (implies/combine implies/reflexive
                                    (implies/trans (IMP o) (DUP o)))
                                  (implies/equiv equiv/associate)
                                  (implies/equiv equiv/commute))
                                (implies/reflexive))
                              (implies/equiv (equiv/symmetric equiv/associate))
                              (implies/combine implies/reflexive
                                (implies/trans3
                                  (implies/combine
                                    (implies/pack o)
                                    (implies/combine
                                      (implies/equiv-encumbered
                                        (equiv/one) (equiv/reflexive))
                                      (implies/reflexive)))
                                  (implies/equiv equiv/associate)
                                  (implies/combine
                                    (implies/linear-modus-ponens)
                                    (implies/reflexive))))
                              (implies/equiv equiv/roll3)
                              (implies/combine implies/reflexive
                                (implies/combine implies/reflexive
                                  (implies/equiv
                                    (equiv/transitive
                                      (equiv/swap)
                                      (equiv/combine PiM+PiM3<=>PiM4 equiv/reflexive)))))))
                          (implies/equiv
                            (equiv/combine equiv/reflexive
                              (equiv/transitive4
                                (equiv/symmetric equiv/associate)
                                (equiv/reorder)
                                (equiv/combine equiv/reflexive equiv/reorder)
                                (equiv/symmetric equiv/identity))))
                          (implies/equiv
                            (equiv/transitive
                              (equiv/combine equiv/reflexive
                                (equiv/transitive
                                  (equiv/combine
                                    (equiv/transitive
                                      (equiv/combine equiv/reflexive
                                        (equiv/combine equiv/reflexive
                                          (equiv/transitive
                                            (equiv/associate)
                                            (equiv/commute))))
                                      (equiv/roll3))
                                    (equiv/reflexive))
                                  (equiv/symmetric-associate)))
                              (equiv/associate)))))
                      (transform/drop)))))))))
      (transform/inside [o] transform/reorder))
    (result2output/expr B=>PiB (env2input/ U2=>PiU2 M4=>PiM4) (reftype2perm/shared T2PF))
    <- capset2perm-equiv M1=>PiM1 M1=>PiM1' clsmap`eq/
      predmap`eq/ cxt`eq/ set`eq/ PiM1<=>PiM1'
    <- ({o:object}{p:permission} typing-frame* TYP-E2
         (envadd/exists [x] (envadd/exists [p] envadd/expr)) (TYP-E2' o p))
    <- subtype-implies-ty2perm-leq* SUB RT2T T2PF2 T2PF IMP
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- set`split-implies-permission-combine-converse
      (set`split/ M^M3 M+M3=M4) M=>PiM M3=>PiM3 PiM4 M4=>PiM4 PiM+PiM3<=>PiM4.

- : do-write (M1=>PiM1':capset2perm CM PM B M1 PiM1')
    (read-format/unique+fresh
      (M1=>PiM1:capset2perm CM PM B M1 PiM1)
      (M=>PiM:capset2perm CM PM B M PiM))
    SUB (T2PF:ty2perm PM _ ([x] PF x)) (TYP-E2:typing W (PiB , (PiU0 , PiM1')) E2 _)
    (before-write-format/expr (U2=>PiU2: make-encumbered CM PM B U2 PiU2)
      (B=>PiB)
      (M3=>PiM3:capset2perm CM PM B M3 PiM3)
      RT2T T2PF2)
    consider-ftype/unique _
    ([x][p:permission] tTrans
      (transform/implies
        (implies/trans
          (implies/combine implies/reflexive
            (implies/combine implies/reflexive
              (implies/combine (implies/equiv (equiv/symmetric equiv/one))
                (implies/combine
                  (implies/equiv-encumbered (equiv/symmetric equiv/one) equiv/reflexive)
                  (implies/reflexive)))))
          (implies/equiv
            (equiv/transitive7
              (equiv/associate)
              (equiv/combine equiv/reflexive % piB0
                (equiv/combine equiv/reflexive equiv/commute)) % PF
              (equiv/roll3)
              (equiv/associate)
              (equiv/combine
                (equiv/transitive
                  (equiv/commute)
                  (equiv/combine equiv/reflexive PiM1<=>PiM1'))
                (equiv/reflexive))
              (equiv/commute)
              (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))))
      (letTyping/base null
        (tWrite2 (TYP-E2' x p)
          (letTyping/exists [o]
            (letTyping/exists [v]
              (letTyping/base o
                (tTrans
                  (transform/trans3
                    (transform/implies
                      (implies/equiv
                        (equiv/symmetric equiv/associate)))
                    (transform/skolem)
                    (transform/inside [o']
                      (transform/implies
                        (implies/equiv
                          (equiv/transitive
                            (equiv/combine equiv/one equiv/reflexive)
                            (equiv/symmetric equiv/associate))))))
                  (letTyping/exists [o']
                    (letTyping/base null
                      (tWrite: typing _ _ (write (lit x) F (lit o)) _)))
                  (transform/trans
                    (transform/inside [o']
                      (transform/trans
                        (transform/implies
                          (implies/trans8
                            (implies/equiv
                              (equiv/combine equiv/reflexive
                                (equiv/combine equiv/reflexive
                                  (equiv/combine equiv/reflexive
                                    (equiv/transitive
                                      (equiv/reorder)
                                      (equiv/combine equiv/reflexive
                                        (equiv/reorder)))))))
                            (implies/combine
                              (implies/trans3
                                (implies/equiv (equiv/symmetric equiv/identity))
                                (implies/combine
                                  (implies/reflexive)
                                  (implies/trans
                                    (implies/gen-pack-encumber o)
                                    (implies/combine-assoc-encumbered)))
                                (implies/linear-modus-ponens))
                              (implies/equiv equiv/roll2))
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans
                                (implies/combine implies/reflexive
                                  (implies/equiv-encumbered equiv/one equiv/reflexive))
                                (implies/chain-implication))
                              (implies/reflexive))
                            (implies/equiv equiv/roll2)
                            (implies/combine implies/reflexive
                              (implies/trans6
                                (implies/combine implies/reflexive
                                  (implies/equiv equiv/roll2))
                                (implies/equiv equiv/roll2)
                                (implies/combine (IMP o) implies/reflexive)
                                (implies/equiv equiv/roll3)
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv (equiv/symmetric equiv/identity))
                                    (implies/combine implies/reflexive
                                      (gen-objequal-self-cond o)))
                                  (implies/combine
                                    (implies/equiv (equiv/symmetric equiv/one))
                                    (implies/combine
                                      (implies/equiv-encumbered
                                        (equiv/symmetric equiv/one)
                                        (equiv/reflexive))
                                      (implies/reflexive))))
                                (implies/equiv (equiv/symmetric equiv/associate))))
                            (implies/equiv
                              (equiv/combine equiv/reflexive
                                (equiv/transitive
                                  (equiv/combine equiv/reflexive
                                    (equiv/transitive
                                      (equiv/combine equiv/reflexive equiv/associate)
                                      (equiv/associate)))
                                  (equiv/symmetric equiv/identity))))
                            (implies/combine implies/reflexive
                              (implies/combine
                                (implies/combine implies/reflexive
                                  (implies/combine
                                    (implies/combine implies/reflexive
                                      (implies/combine (implies/equiv equiv/one)
                                        (implies/equiv-encumbered
                                          (equiv/one) (equiv/reflexive))))
                                    (implies/reflexive)))
                                (implies/reflexive)))))
                        (transform/drop)))
                    (transform/rem-unused))))))))
      (transform/trans3
        (transform/inside [o]
          (transform/trans3
            (transform/rem-unused)
            (transform/gen-exists p)
            (transform/inside [k:permission] transform/gen-exists o)))
        (transform/inside [_] transform/reorder)
        (transform/reorder)))
    (result2output/expr B=>PiB (env2input/ U2=>PiU2 M3=>PiM3)
      (reftype2perm/unique+fresh T2PF ([_] set2cond/0) M=>PiM))
    <- capset2perm-equiv M1=>PiM1 M1=>PiM1' clsmap`eq/
      predmap`eq/ cxt`eq/ set`eq/ PiM1<=>PiM1'
    <- ({o:object}{p:permission} typing-frame*
         TYP-E2 (envadd/exists [x] (envadd/exists [p] envadd/expr)) (TYP-E2' o p))
    <- subtype-implies-ty2perm-leq* SUB RT2T T2PF2 T2PF IMP.

- : do-write (M1=>PiM1':capset2perm CM PM B M1 PiM1')
    (read-format/unique (SZ-M:set`size M (s _))
      (M1=>PiM1:capset2perm CM PM B M1 PiM1)
      (M=>PiM:capset2perm CM PM B M PiM))
    SUB (T2PF) (TYP-E2:typing W (PiB , (PiU , PiM1')) E2 _)
    (before-write-format/expr (U2=>PiU2:make-encumbered CM PM B U2 PiU2)
      (B=>PiB:cxt2perm PM B PiB')
      (M3=>PiM3:capset2perm CM PM B M3 PiM3) RT2T T2PF2)
    (consider-ftype/shared (set`split/ M^M3 M+M3=M4)) _
    ([x][p] tTrans
      (transform/implies
        (implies/trans
          (implies/combine implies/reflexive
            (implies/combine implies/reflexive
              (implies/combine (implies/equiv (equiv/symmetric equiv/one))
                (implies/combine
                  (implies/equiv-encumbered (equiv/symmetric equiv/one) equiv/reflexive)
                  (implies/reflexive)))))
          (implies/equiv
            (equiv/transitive7
              (equiv/associate)
              (equiv/combine equiv/reflexive % piB0
                (equiv/combine equiv/reflexive equiv/commute)) % PF
              (equiv/roll3)
              (equiv/associate)
              (equiv/combine
                (equiv/transitive
                  (equiv/commute)
                  (equiv/combine equiv/reflexive PiM1<=>PiM1'))
                (equiv/reflexive))
              (equiv/commute)
              (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))))
      (letTyping/base null
        (tWrite2 (TYP-E2' x p)
          (letTyping/exists [o]
            (letTyping/exists [v]
              (letTyping/base o
                (tTrans
                  (transform/trans3
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine equiv/reflexive equiv/associate)
                          (equiv/symmetric equiv/associate))))
                    (transform/skolem)
                    (transform/inside [o']
                      (transform/implies
                        (implies/equiv
                          (equiv/transitive
                            (equiv/combine equiv/one equiv/reflexive)
                            (equiv/symmetric equiv/associate))))))
                  (letTyping/exists [o']
                    (letTyping/base null
                      (tWrite: typing _ _ (write (lit x) F (lit o)) _)))
                  (transform/inside [o']
                    (transform/trans
                      (transform/implies
                        (implies/trans3
                          (implies/equiv equiv/roll2)
                          (implies/combine implies/reflexive
                            (implies/trans7
                              (implies/combine implies/reflexive
                                (implies/equiv equiv/roll3))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans3
                                  (implies/combine implies/reflexive
                                    (implies/trans (IMP o) (DUP o)))
                                  (implies/equiv equiv/associate)
                                  (implies/equiv equiv/commute))
                                (implies/reflexive))
                              (implies/equiv (equiv/symmetric equiv/associate))
                              (implies/combine implies/reflexive
                                (implies/trans3
                                  (implies/combine
                                    (implies/pack o)
                                    (implies/combine
                                      (implies/equiv-encumbered
                                        (equiv/one) (equiv/reflexive))
                                      (implies/reflexive)))
                                  (implies/equiv equiv/associate)
                                  (implies/combine
                                    (implies/linear-modus-ponens)
                                    (implies/reflexive))))
                              (implies/equiv equiv/roll3)
                              (implies/combine implies/reflexive
                                (implies/combine implies/reflexive
                                  (implies/equiv PiM+PiM3<=>PiM4)))))
                          (implies/equiv
                            (equiv/combine equiv/reflexive
                              (equiv/transitive4
                                (equiv/symmetric equiv/associate)
                                (equiv/reorder)
                                (equiv/combine equiv/reflexive equiv/reorder)
                                (equiv/symmetric equiv/identity))))))
                      (transform/drop)))))))))
      (transform/inside [_] transform/reorder))
    (result2output/expr B=>PiB (env2input/ U2=>PiU2 M4=>PiM4) (reftype2perm/shared T2PF))
    <- capset2perm-equiv M1=>PiM1 M1=>PiM1' clsmap`eq/
      predmap`eq/ cxt`eq/ set`eq/ PiM1<=>PiM1'
    <- ({o:object}{p:permission} typing-frame*
         TYP-E2 (envadd/exists [x] (envadd/exists [p] envadd/expr)) (TYP-E2' o p))
    <- subtype-implies-ty2perm-leq* SUB RT2T T2PF2 T2PF IMP
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- set`split-implies-permission-combine-converse
      (set`split/ M^M3 M+M3=M4) M=>PiM M3=>PiM3 PiM4 M4=>PiM4 PiM+PiM3<=>PiM4.

- : do-write (M1=>PiM1':capset2perm CM PM B M1 PiM1')
    (read-format/unique (SZ-M:set`size M (s _))
      (M1=>PiM1:capset2perm CM PM B M1 PiM1)
      (M=>PiM:capset2perm CM PM B M PiM))
    SUB (T2PF:ty2perm PM _ ([x] PF x)) (TYP-E2:typing W (PiB , (PiU0 , PiM1')) E2 _)
    (before-write-format/expr (U2=>PiU2: make-encumbered CM PM B U2 PiU2)
      (B=>PiB)
      (M3=>PiM3:capset2perm CM PM B M3 PiM3)
      RT2T T2PF2)
    consider-ftype/unique _
    ([x][p] tTrans
      (transform/implies
        (implies/trans
          (implies/combine implies/reflexive
            (implies/combine implies/reflexive
              (implies/combine (implies/equiv (equiv/symmetric equiv/one))
                (implies/combine
                  (implies/equiv-encumbered (equiv/symmetric equiv/one) equiv/reflexive)
                  (implies/reflexive)))))
          (implies/equiv
            (equiv/transitive7
              (equiv/associate)
              (equiv/combine equiv/reflexive % piB0
                (equiv/combine equiv/reflexive equiv/commute)) % PF
              (equiv/roll3)
              (equiv/associate)
              (equiv/combine
                (equiv/transitive
                  (equiv/commute)
                  (equiv/combine equiv/reflexive PiM1<=>PiM1'))
                (equiv/reflexive))
              (equiv/commute)
              (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))))
      (letTyping/base null
        (tWrite2 (TYP-E2' x p)
          (letTyping/exists [o]
            (letTyping/exists [v]
              (letTyping/base o
                (tTrans
                  (transform/trans3
                    (transform/implies
                      (implies/equiv
                        (equiv/symmetric equiv/associate)))
                    (transform/skolem)
                    (transform/inside [o']
                      (transform/implies
                        (implies/equiv
                          (equiv/transitive
                            (equiv/combine equiv/one equiv/reflexive)
                            (equiv/symmetric equiv/associate))))))
                  (letTyping/exists [o']
                    (letTyping/base null
                      (tWrite: typing _ _ (write (lit x) F (lit o)) _)))
                  (transform/trans
                    (transform/inside [o']
                      (transform/trans
                        (transform/implies
                          (implies/trans8
                            (implies/equiv
                              (equiv/combine equiv/reflexive
                                (equiv/combine equiv/reflexive
                                  (equiv/combine equiv/reflexive
                                    (equiv/transitive
                                      (equiv/reorder)
                                      (equiv/combine equiv/reflexive
                                        (equiv/reorder)))))))
                            (implies/combine
                              (implies/trans3
                                (implies/equiv (equiv/symmetric equiv/identity))
                                (implies/combine
                                  (implies/reflexive)
                                  (implies/trans
                                    (implies/gen-pack-encumber o)
                                    (implies/combine-assoc-encumbered)))
                                (implies/linear-modus-ponens))
                              (implies/equiv equiv/roll2))
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans
                                (implies/combine implies/reflexive
                                  (implies/equiv-encumbered equiv/one equiv/reflexive))
                                (implies/chain-implication))
                              (implies/reflexive))
                            (implies/equiv equiv/roll2)
                            (implies/combine implies/reflexive
                              (implies/trans6
                                (implies/combine implies/reflexive
                                  (implies/equiv equiv/roll2))
                                (implies/equiv equiv/roll2)
                                (implies/combine (IMP o) implies/reflexive)
                                (implies/equiv equiv/roll3)
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv (equiv/symmetric equiv/identity))
                                    (implies/combine implies/reflexive
                                      (gen-objequal-self-cond o)))
                                  (implies/combine
                                    (implies/equiv (equiv/symmetric equiv/one))
                                    (implies/combine
                                      (implies/equiv-encumbered
                                        (equiv/symmetric equiv/one)
                                        (equiv/reflexive))
                                      (implies/reflexive))))
                                (implies/equiv (equiv/symmetric equiv/associate))))
                            (implies/equiv
                              (equiv/combine equiv/reflexive
                                (equiv/transitive
                                  (equiv/combine equiv/reflexive
                                    (equiv/transitive
                                      (equiv/combine equiv/reflexive equiv/associate)
                                      (equiv/associate)))
                                  (equiv/symmetric equiv/identity))))
                            (implies/combine implies/reflexive
                              (implies/combine
                                (implies/combine implies/reflexive
                                  (implies/combine
                                    (implies/combine implies/reflexive
                                      (implies/combine (implies/equiv equiv/one)
                                        (implies/equiv-encumbered
                                          (equiv/one) (equiv/reflexive))))
                                    (implies/reflexive)))
                                (implies/reflexive)))))
                        (transform/drop)))
                    (transform/rem-unused))))))))
      (transform/inside [o]
        (transform/trans
          (transform/inside [v]
            (transform/gen-exists o)))
        (transform/reorder)))
    (result2output/expr B=>PiB (env2input/ U2=>PiU2 M3=>PiM3)
      (reftype2perm/unique SZ-M T2PF ([_] set2cond/0) M=>PiM))
    <- capset2perm-equiv M1=>PiM1 M1=>PiM1' clsmap`eq/
      predmap`eq/ cxt`eq/ set`eq/ PiM1<=>PiM1'
    <- ({o:object}{p:permission} typing-frame*
         TYP-E2 (envadd/exists [x] (envadd/exists [p] envadd/expr)) (TYP-E2' o p))
    <- subtype-implies-ty2perm-leq* SUB RT2T T2PF2 T2PF IMP.

%worlds (gtermvar) (do-write _ _ _ _ _ _ _ _ _ _).
%total { } (do-write _ _ _ _ _ _ _ _ _ _).