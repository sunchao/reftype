% Definitions

transfer-consume : effects -> effects -> effects -> set -> type.

transfer-consume/
  : set`leq S1 S
    -> set`leq Q1 Q
    -> set`remove S S1 S2
    -> set`remove Q Q1 Q2
    -> set2efxmap S2 efx/write M3
    -> efxmap`join M M3 M2
    -> transfer-consume (effects/ M S Q)
      (effects/ M1 S1 Q1) (effects/ M2 S1 Q1) Q2.


effects-getq : effects -> set -> type.

effects-getq/ : effects-getq (effects/ _ _ Q) Q.


write-intermediate-format : clsmap -> predmap -> cxt -> nat
	-> targets -> effects -> effects -> (object -> permission)
	-> permission -> type.

write-intermediate-format/0
  : predmap`lookup PM C CP
    -> efxmap`domain M' R'
    -> efxmap`partition M R' M11 M'
    -> efxmap2perm CM PM B M11 Pi1
    -> write-intermediate-format CM PM B C (targets/unique set/0 set/0)
      (effects/ M _ _) (effects/ M' _ _)
      ([x] nonnull-unique-perm x CP) Pi1.

write-intermediate-format/+f
  : set`size S (s _)
    -> efxmap`partition M S M1 M2
    -> efxmap2perm CM PM B M2 Pi2
    -> efxmap-min-efx M2 X
    -> efx2frac X (fraction/ Z)
    -> rat`eq Z one
    -> efxmap`domain M' R'
    -> efxmap`partition M1 R' M11 M'
    -> efxmap2perm CM PM B M11 Pi1
    -> write-intermediate-format CM PM B C (targets/unique set/0 S)
      (effects/ M _ _) (effects/ M' _ _) ([_] Pi2) Pi1.


before-write-format : clsmap -> predmap -> cxt ->
	reftype -> effects -> expr-output -> type.

before-write-format/
  : before-write-format CM PM B RT (effects/ M S Q)
    (output/exists [r]
      (output/expr r
        (combine Pi1 (combine (PF r) Pi2))))
    <- cxt2perm CM PM B Pi1
    <- efxmap2perm CM PM B M Pi2
    <- reftype2ty RT T
    <- ty2perm PM T PF.


set-all-permissions : predmap -> cxt -> nat -> set -> permission -> type.

set-all-permissions/0 : set-all-permissions _ _ _ set/0 empty.

set-all-permissions/U
  : set-all-permissions PM B C S' Pi
    -> set`not-member S' N
    -> set`add S' N S
    -> cxt`lookup B N (cxt-info/ O (ty/ NN _ C))
    -> ty2perm PM (ty/ NN annot/unique C) PF
    -> set-all-permissions PM B C S ((PF O) , Pi).



%% Theorems

% 1. theorems about transfer-consume

%theorem transfer-consume-respects-eq
  : forall* {XX1} {XX2} {XX3} {Q} {XX1'} {XX2'} {XX3'} {Q'}
    forall {TC: transfer-consume XX1 XX2 XX3 Q}
    {E1: effects`eq XX1 XX1'}
    {E2: effects`eq XX2 XX2'}
    {E3: effects`eq XX3 XX3'}
    {E4: set`eq Q Q'}
    exists {TC: transfer-consume XX1' XX2' XX3' Q'}
    true.

- : transfer-consume-respects-eq TC effects`eq/ effects`eq/ effects`eq/ set`eq/ TC.

%worlds () (transfer-consume-respects-eq _ _ _ _ _ _ ).
%total {} (transfer-consume-respects-eq _ _ _ _ _ _ ).


% not total

%theorem leq-implies-transfer-consume
  : forall* {XX1} {XX2}
    forall {XX<=XX': effects`leq XX1 XX2}
    exists {XX} {Q} {TC: transfer-consume XX2 XX1 XX Q}
    true.

- : leq-implies-transfer-consume
    (effects`leq/ _ _ _ _ _ S1<=S Q1<=Q) _ _
    (transfer-consume/ S1<=S Q1<=Q S/S1=S2 Q/Q1=Q2 S2=>M1 M+M1=M2)
    <- set`remove-total S/S1=S2
    <- set`remove-total Q/Q1=Q2
    <- set2efxmap-total S2=>M1
    <- efxmap`join-total M+M1=M2.

%worlds () (leq-implies-transfer-consume _ _ _ _).
%total {} (leq-implies-transfer-consume _ _ _ _).


%theorem leq-transfer-consume-implies-leq-no-consume
  : forall* {CM} {B} {XX1} {XX2} {XX} {Q}
    forall {CM-B-XX1: clsmap-cxt-effects CM B XX1}
    {XX1<=XX2: effects`leq XX1 XX2}
    {TC: transfer-consume XX2 XX1 XX Q}
    exists {LE: effects-leq-no-consume XX1 XX}
    true.

%theorem leq-transfer-consume-implies-leq-no-consume/L
  : forall* {M1} {R1} {S1} {Q1} {M} {S} {Q} {M2} {Q2}
    forall {DM-M1=R1: efxmap`domain M1 R1}
    {R1^S1: set`disjoint R1 S1}
    {XX1<=XX2: effects`leq (effects/ M1 S1 Q1) (effects/ M S Q)}
    {TC: transfer-consume (effects/ M S Q) (effects/ M1 S1 Q1)
         (effects/ M2 S1 Q1) Q2}
    {B} {M1<=M2?: efxmap`leq? M1 M2 B}
    exists {M1<=M2: efxmap`leq M1 M2}
    true.

- : leq-transfer-consume-implies-leq-no-consume/L
    _ _ _ _ true (efxmap`leq?/yes M1<=M2) M1<=M2.

%theorem leq-transfer-consume-implies-leq-no-consume/LL
  : forall* {M} {M3} {M2} {S2} {N} {B1} {B2}
    forall {J: efxmap`join M M3 M2}
    {S2=>M3: set2efxmap S2 efx/write M3}
    {M2->N=R: efxmap`lookup M2 N efx/read}
    {N<-M?: efxmap`domain? M N B1} {N<-M3?: efxmap`domain? M3 N B2}
    exists {M->N=R: efxmap`lookup M N efx/read}
    {N!<M3: efxmap`fresh M3 N}
    true.

- : leq-transfer-consume-implies-leq-no-consume/LL M+M3=M2 S2=>M3 M2->N=R
    _ (efxmap`domain?/in M3->N=D) M->N=R N!<M3
    <- set2efxmap-lookup-implies-efx-id-lookup-converse S2=>M3 M3->N=D
      D ID N<-S2
    <- efx-id-eq ID XE
    <- efx`eq-symmetric XE XEx
    <- efxmap`lookup-respects-eq M3->N=D efxmap`eq/ nat`eq/ XEx M3->N=W
    <- efxmap`join-implies-leq M+M3=M2 _ M3<=M2
    <- efxmap`lookup-respects-leq* M3->N=W M3<=M2 M2->N=R W<=R
    <- efx`leq-nle-contradiction W<=R (efx`grt/wr) F
    <- efxmap`false-implies-lookup F M->N=R
    <- efxmap`false-implies-fresh F N!<M3.

- : leq-transfer-consume-implies-leq-no-consume/LL M+M3=M2 S2=>M3 M2->N=R
    (efxmap`domain?/in _) (efxmap`domain?/out N!<M3) M->N=R N!<M3
    <- efxmap`fresh-join-right-preserves-lookup-converse M2->N=R N!<M3 M+M3=M2 M->N=R.

- : leq-transfer-consume-implies-leq-no-consume/LL M+M3=M2 S2=>M3 M2->N=R
    (efxmap`domain?/out N!<M) (efxmap`domain?/out N!<M3) M->N=R N!<M3
    <- efxmap`join-preserves-fresh* N!<M N!<M3 M+M3=M2 N!<M2
    <- efxmap`fresh-lookup-not-equal N!<M2 M2->N=R N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- efxmap`false-implies-lookup F M->N=R.

- : leq-transfer-consume-implies-leq-no-consume/L DM-M1=R1' R1'^S1
    (effects`leq/ (DM-M1=R1:efxmap`domain M1 R1)
      DM-M=R R1/S=S3 M1|S3=M1' M1'<=M S1<=S Q1<=Q)
    (transfer-consume/ S1<=S' Q1<=Q' S/S1=S2 Q/Q1=Q2 S2=>M3
      (M+M3=M2:efxmap`join M M3 M2)) % N must be in M
    false (efxmap`leq?/no (efxmap`nle/= M1->N=W M2->N=R efx`grt/wr)) M1<=M2
    <- efxmap`domain?-total N<-M?
    <- efxmap`domain?-total N<-M3?
    <- leq-transfer-consume-implies-leq-no-consume/LL M+M3=M2 S2=>M3 M2->N=R
      N<-M? N<-M3? M->N=R N!<M3
    <- set2efxmap-implies-domain S2=>M3 DM-M3=S2
    <- efxmap`domain-preserves-fresh N!<M3 DM-M3=S2 N!<S2
    <- efxmap`domain-preserves-lookup M1->N=W DM-M1=R1 (N<-R1:set`member R1 N)
    <- efxmap`domain-unique DM-M1=R1' DM-M1=R1 efxmap`eq/ R1'=R1
    <- set`disjoint-respects-eq R1'^S1 R1'=R1 set`eq/ R1^S1
    <- set`disjoint-member-implies-not-member N<-R1 R1^S1 N!<S1
    <- set`union-total S1+S2=U
    <- set`remove-implies-leq-union S/S1=S2 S1+S2=U S<=U
    <- set`union-preserves-not-member* N!<S1 N!<S2 S1+S2=U N!<U
    <- set`not-member-respects-geq N!<U S<=U N!<S
    <- set`remove-preserves-member N<-R1 R1/S=S3 N!<S N<-S3
    <- efxmap`restrict-preserves-lookup M1->N=W M1|S3=M1' N<-S3 M1'->N=W
    <- efxmap`lookup-respects-leq* M1'->N=W M1'<=M M->N=R W<=R
    <- efx`leq-nle-contradiction W<=R (efx`grt/wr) F
    <- efxmap`false-implies-leq F M1<=M2.

- : leq-transfer-consume-implies-leq-no-consume/L DM-M1=R1' R1'^S1
    (effects`leq/ (DM-M1=R1:efxmap`domain M1 R1)
      DM-M=R R1/S=S3 M1|S3=M1' M1'<=M S1<=S Q1<=Q)
    (transfer-consume/ S1<=S' Q1<=Q' S/S1=S2 Q/Q1=Q2 S2=>M3
      (M+M3=M2:efxmap`join M M3 M2))
    false (efxmap`leq?/no (efxmap`nle/< M1->N N!<M2)) M1<=M2
    <- efxmap`join-preserves-fresh-converse* N!<M2 M+M3=M2 N!<M N!<M3
    <- set2efxmap-implies-domain S2=>M3 DM-M3=S2
    <- efxmap`domain-preserves-fresh N!<M3 DM-M3=S2 N!<S2
    <- efxmap`domain-preserves-lookup M1->N DM-M1=R1 (N<-R1:set`member R1 N)
    <- efxmap`domain-unique DM-M1=R1' DM-M1=R1 efxmap`eq/ R1'=R1
    <- set`disjoint-respects-eq R1'^S1 R1'=R1 set`eq/ R1^S1
    <- set`disjoint-member-implies-not-member N<-R1 R1^S1 N!<S1
    <- set`union-total S1+S2=U
    <- set`remove-implies-leq-union S/S1=S2 S1+S2=U S<=U
    <- set`union-preserves-not-member* N!<S1 N!<S2 S1+S2=U N!<U
    <- set`not-member-respects-geq N!<U S<=U N!<S
    <- set`remove-preserves-member N<-R1 R1/S=S3 N!<S N<-S3
    <- efxmap`restrict-preserves-lookup M1->N M1|S3=M1' N<-S3 M1'->N
    <- efxmap`lookup-respects-leq M1'->N M1'<=M _ M->N _
    <- efxmap`fresh-lookup-not-equal N!<M M->N N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- efxmap`false-implies-leq F M1<=M2.

%worlds () (leq-transfer-consume-implies-leq-no-consume/LL _ _ _ _ _ _ _).
%total {} (leq-transfer-consume-implies-leq-no-consume/LL _ _ _ _ _ _ _).

%worlds () (leq-transfer-consume-implies-leq-no-consume/L _ _ _ _ _ _ _).
%total {} (leq-transfer-consume-implies-leq-no-consume/L _ _ _ _ _ _ _).

- : leq-transfer-consume-implies-leq-no-consume (clsmap-cxt-effects/ DM DJ _ _ _ _)
    LE TC (effects-leq-no-consume/ MLE)
    <- efxmap`leq?-total LE?
    <- effects`leq-inversion LE _ _ _ _ _ _ _ _ _
    <- leq-transfer-consume-implies-leq-no-consume/L DM DJ LE TC _ LE? MLE.

%worlds () (leq-transfer-consume-implies-leq-no-consume _ _ _ _).
%total {} (leq-transfer-consume-implies-leq-no-consume _ _ _ _).


%theorem transfer-consume-preserves-clsmap-cxt-effects
  : forall* {CM} {B} {XX} {XX'} {Q} {XX1}
    forall {CM-B-XX1: clsmap-cxt-effects CM B XX1}
    {CM-B-XX: clsmap-cxt-effects CM B XX}
    {TC: transfer-consume XX XX1 XX' Q}
    exists {CM-B-XX': clsmap-cxt-effects CM B XX'}
    true.

- : transfer-consume-preserves-clsmap-cxt-effects
    (clsmap-cxt-effects/ _ _ S1=>SQ1 Q1<=SQ1 _ _)
    (clsmap-cxt-effects/ DM-M=R R^S S=>SQ Q<=SQ CM-B-R CM-B-S)
    (transfer-consume/ S1<=S Q1<=Q S/S1=S2 Q/Q1=Q2 S2=>M1 M+M1=M2)
    (clsmap-cxt-effects/ DM-M2=R2 R2^S1 S1=>SQ1 Q1<=SQ1 CM-B-R2 CM-B-S1)
    <- set2efxmap-implies-domain S2=>M1 DM-M1=S2
    <- efxmap`domain-total DM-M2=R2
    <- efxmap`join-commute-domain M+M1=M2 DM-M=R DM-M1=S2 DM-M2=R2 R+S2=R2
    <- set`remove-implies-leq S/S1=S2 S2<=S
    <- clsmap-cxt-set-respects-geq CM-B-S S2<=S CM-B-S2
    <- join-preserves-clsmap-cxt-set CM-B-R CM-B-S2 R+S2=R2 CM-B-R2
    <- set`remove-implies-disjoint S/S1=S2 S1^S2
    <- set`disjoint-symmetric S1^S2 S2^S1
    <- set`leq-reflexive _ R<=R
    <- set`disjoint-respects-geq R^S R<=R S1<=S R^S1
    <- set`union-preserves-disjoint* R^S1 S2^S1 R+S2=R2 R2^S1
    <- clsmap-cxt-set-respects-geq CM-B-S S1<=S CM-B-S1.

%worlds () (transfer-consume-preserves-clsmap-cxt-effects _ _ _ _).
%total {} (transfer-consume-preserves-clsmap-cxt-effects _ _ _ _).


%theorem effects-leq-implies-transfer-consume
  : forall* {CM} {B} {XX1} {XX2}
    forall {CM-B-XX1: clsmap-cxt-effects CM B XX1}
    {CM-B-XX2: clsmap-cxt-effects CM B XX2}
    {XX1<=XX2: effects`leq XX1 XX2}
    exists {XX} {Q}
    {TC: transfer-consume XX2 XX1 XX Q}
    {CM-B-XX: clsmap-cxt-effects CM B XX}
    {XX1<=XX: effects-leq-no-consume XX1 XX}
    true.

- : effects-leq-implies-transfer-consume
    CM-B-XX1 CM-B-XX2 XX1<=XX2 _ _  XX2=>XX CM-B-XX XX1<=XX
    <- effects`leq-inversion XX1<=XX2 _ _ _ _ _ _ _ _ _
    <- leq-implies-transfer-consume XX1<=XX2 XX _ XX2=>XX
    <- leq-transfer-consume-implies-leq-no-consume
      CM-B-XX1 XX1<=XX2 XX2=>XX XX1<=XX
    <- transfer-consume-preserves-clsmap-cxt-effects
      CM-B-XX1 CM-B-XX2 XX2=>XX CM-B-XX.

%worlds () (effects-leq-implies-transfer-consume _ _ _ _ _ _ _ _).
%total {} (effects-leq-implies-transfer-consume _ _ _ _ _ _ _ _).


%theorem effects-leq-no-consume-implies-leq
  : forall* {XX} {XX'}
    forall {L: effects-leq-no-consume XX XX'}
    exists {L: effects`leq XX XX'}
    true.

- : effects-leq-no-consume-implies-leq
    (effects-leq-no-consume/ M<=M')
    (effects`leq/ DM1 DM2 RM RS M1<=M' SLE QLE)
    <- efxmap`domain-total DM1
    <- efxmap`domain-total DM2
    <- set`remove-total RM
    <- efxmap`restrict-total RS
    <- efxmap`restrict-implies-leq RS M1<=M
    <- efxmap`leq-transitive M1<=M M<=M' M1<=M'
    <- set`leq-reflexive _ SLE
    <- set`leq-reflexive _ QLE.

%worlds () (effects-leq-no-consume-implies-leq _ _).
%total {} (effects-leq-no-consume-implies-leq _ _).


%{
 This says we can transfer consume efx to write efx, and
still generate the same permission.
}%

%theorem consume-as-write
  : forall* {CM} {PM} {B} {XX} {XX1} {XX2} {Q} {Pi1}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-XX: clsmap-cxt-effects CM B XX}
    {TC: transfer-consume XX XX2 XX1 Q}
    {X=>Pi: effects2input CM PM B XX Pi1}
    exists {Pi2} {Pi3}
    {X=>Pi: effects2input CM PM B XX1 Pi3}
    {Q3=>Pi2: make-fperm CM PM B Q Pi2}
    {EQV: equiv Pi1 (Pi2 , Pi3)}
    true.

- : consume-as-write CM-CM CM2PM
    (clsmap-cxt-effects/ DM-M=R R^S S=>SQ Q<=SQ CM-B-R CM-B-S)
    (transfer-consume/ S1<=S Q1<=Q S/S1=S3 Q/Q1=Q3 S3=>M3 M+M3=M4)
    (effects2input/ B=>Pi1 Q=>Pi2 S=>Ms Ms=>Pi3 M=>Pi4)
    Piy _ (effects2input/ B=>Pi1 Q1=>Pi21 S1=>Ms1 Ms1=>Pi31 M4=>Pi41)
    Q3=>Piy
    (equiv/transitive7
      (equiv/combine
        (equiv/symmetric equiv/identity)
        (equiv/reflexive))
      (equiv/combine
        (equiv/combine
          (equiv/transitive4
            (equiv/associate)
            (equiv/combine
              (equiv/transitive3
                (equiv/combine
                  (equiv/reflexive)
                  (equiv/symmetric Pi21+Piy<=>Pi2))
                (equiv/associate)
                (equiv/commute))
              (equiv/symmetric Pi31+Pix<=>Pi3))
            (equiv/symmetric equiv/associate)
            (equiv/combine
              (equiv/reflexive)
              (equiv/transitive
                (equiv/symmetric equiv/associate)
                (equiv/combine
                  (equiv/reflexive)
                  (equiv/associate)))))
          (equiv/reflexive))
        (equiv/reflexive))
      (equiv/transitive
        (equiv/combine
          (equiv/transitive
            (equiv/identity)
            (equiv/combine
              (equiv/reflexive)
              (equiv/combine
                (equiv/reflexive)
                (equiv/transitive
                  (equiv/symmetric equiv/associate)
                  (equiv/combine
                    (equiv/reflexive)
                    (equiv/commute))))))
          (equiv/reflexive))
        (equiv/commute))
      (equiv/transitive3
        (equiv/combine
          (equiv/reflexive)
          (equiv/roll4))
        (equiv/associate)
        (equiv/combine
          (Pi4+Pix<=>Pi41)
          (equiv/reflexive)))
      (equiv/commute)
      (equiv/combine equiv/reflexive equiv/reflexive)
      (equiv/symmetric equiv/associate))
    <- set`remove-implies-leq S/S1=S3 S3<=S
    <- set`disjoint-symmetric R^S S^R
    <- set`disjoint-respects-geq* S^R S3<=S S3^R
    <- set2efxmap-implies-domain S3=>M3 DM-M3=S3
    <- efxmap`domain-preserves-disjoint-converse S3^R DM-M3=S3 DM-M=R M3^M
    <- efxmap`disjoint-symmetric M3^M M^M3
    <- clsmap-cxt-set-respects-geq CM-B-S S3<=S CM-B-S3
    <- clsmap-cxt-set-respects-geq CM-B-S S1<=S CM-B-S1
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM-M3=S3 CM-B-S3 _ M3=>Pix
    <- efxmap`disjoint-join-implies-equiv-converse M^M3 M+M3=M4
      M=>Pi4 M3=>Pix Pi41 M4=>Pi41 (Pi4+Pix<=>Pi41:equiv (Pi4 , Pix) Pi41)
    <- set`remove-implies-leq Q/Q1=Q3 Q3<=Q
    <- set`remove-implies-disjoint Q/Q1=Q3 Q1^Q3
    <- set`remove-subset-implies-union Q/Q1=Q3 Q1<=Q Q1+Q3=Q
    <- collect-objs-implies-clsmap-cxt-set2 CM-B-S S=>SQ CM-B-SQ
    <- clsmap-cxt-set2-respects-geq CM-B-SQ Q<=SQ CM-B-Q
    <- clsmap-cxt-set2-respects-geq CM-B-Q Q3<=Q CM-B-Q3
    <- clsmap-cxt-set2-respects-geq CM-B-Q Q1<=Q CM-B-Q1
    <- make-fperm-total CM-CM CM2PM CM-B-Q3 _ Q3=>Piy
    <- make-fperm-total CM-CM CM2PM CM-B-Q1 _ Q1=>Pi21
    <- make-fperm-disjoint-join-implies-equiv* Q1^Q3 Q1+Q3=Q
      Q1=>Pi21 Q3=>Piy Q=>Pi2 (Pi21+Piy<=>Pi2:equiv (Pi21 , Piy) Pi2)
    <- set`remove-subset-implies-union S/S1=S3 S1<=S S1+S3=S
    <- set`remove-implies-disjoint S/S1=S3 S1^S3
    <- set2efxmap-total S1=>Ms1
    <- set2efxmap-implies-domain S1=>Ms1 DM-Ms1=S1
    <- set2efxmap-preserves-disjoint-join*
      S=>Ms S1^S3 S1+S3=S S1=>Ms1 S3=>M3 Ms1^M3 Ms1+M3=Ms
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM-Ms1=S1 CM-B-S1 _ Ms1=>Pi31
    <- efxmap`disjoint-join-implies-equiv* Ms1^M3 Ms1+M3=Ms Ms1=>Pi31 M3=>Pix
      Ms=>Pi3 (Pi31+Pix<=>Pi3:equiv (Pi31 , Pix) Pi3).

%worlds () (consume-as-write _ _ _ _  _ _ _ _ _ _).
%total {} (consume-as-write _ _ _ _ _ _ _ _ _ _).


%theorem consume-as-write*
  : forall* {CM} {PM} {B} {XX} {XX1} {XX2} {Q} {Pi1} {Pi2} {Pi3}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-XX: clsmap-cxt-effects CM B XX}
    {TC: transfer-consume XX XX2 XX1 Q}
    {X=>Pi: effects2input CM PM B XX Pi1}
    {X=>Pi: effects2input CM PM B XX1 Pi3}
    {Q3=>Pi2: make-fperm CM PM B Q Pi2}
    exists {EQV: equiv Pi1 (Pi2 , Pi3)}
    true.

- : consume-as-write* CM-CM CM2PM CM-B-XX TC XX=>Pi1 XX1=>Pi3 MF
    (equiv/transitive EQV' (equiv/combine Pi2'<=>Pi2 Pi3'<=>Pi3))
    <- consume-as-write CM-CM CM2PM CM-B-XX TC XX=>Pi1 _ _ XX1=>Pi3' MF' EQV'
    <- make-fperm-unique MF' MF clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/ Pi2'=Pi2
    <- permission`eq-implies-equiv Pi2'=Pi2 Pi2'<=>Pi2
    <- effects2input-equiv XX1=>Pi3' XX1=>Pi3 clsmap`eq/ predmap`eq/
      cxt`eq/ effects`eq/ Pi3'<=>Pi3.

%worlds () (consume-as-write* _ _ _ _ _ _ _ _).
%total { } (consume-as-write* _ _ _ _ _ _ _ _).


%theorem join-left-preserves-effects-leq-without-consume
  : forall* {G} {G1} {F} {X} {XX1} {XX2} {XX}
    forall {MG: make-targets-and-effects G F X G1 XX1}
    {CP: compatible G1 XX2}
    {J: effects`join XX1 XX2 XX}
    exists {LE: effects-leq-without-consume XX1 XX}
    true.

- : join-left-preserves-effects-leq-without-consume
    make-targets-and-effects/shared
    (compatible/unique (DM-XM2=R2:efxmap`domain XM2 R2)
      (S2^R2:set`disjoint (set/1 z) R2) (S2^CS2:set`disjoint (set/1 z) CS2))
    (effects`join/ DM-XM1=R1 (DM-XM2=R2':efxmap`domain XM2 R2')
      CS1^R1 CS2^R2' CS1^R2' CS1^CS2 R1/CS2=CS3 XM1|CS3=XM1'
      (XM1'+XM2=XM:efxmap`join XM1' XM2 XM) _ _ _)
    (effects-leq-without-consume/ XM1<=XM)
    <- efxmap`domain-unique DM-XM2=R2 DM-XM2=R2' efxmap`eq/ R2=R2'
    <- efxmap`domain-unique (efxmap`domain/+ efxmap`domain/0)
      DM-XM1=R1 efxmap`eq/ S2=R1
    <- set`disjoint-respects-eq S2^CS2 S2=R1 set`eq/ R1^CS2
    <- set`disjoint-implies-remove-nothing R1^CS2 R1/CS2=R1
    <- set`remove-unique R1/CS2=R1 R1/CS2=CS3 set`eq/ set`eq/ R1=CS3
    <- set`leq-reflexive _ R1<=R1
    <- set`leq-respects-eq R1<=R1 set`eq/ R1=CS3 R1<=CS3
    <- efxmap`domain-leq-implies-no-restriction DM-XM1=R1 R1<=CS3 XM1|CS3=XM1
    <- efxmap`restrict-unique XM1|CS3=XM1' XM1|CS3=XM1 efxmap`eq/ set`eq/ XM1'=XM1
    <- efxmap`join-respects-eq XM1'+XM2=XM XM1'=XM1 efxmap`eq/ efxmap`eq/ XM1+XM2=XM
    <- efxmap`join-implies-leq XM1+XM2=XM XM1<=XM _.

- : join-left-preserves-effects-leq-without-consume
    (make-targets-and-effects/unique _ _ _ G=>M1)
    (compatible/unique DM-M2=R2 _ G^S2)
    (effects`join/ DM-M1=R1 DM-M2=R2' _ _ _ _
      R1/S2=S3 M1|S3=M1' M1'+M2=M _ _ _)
    (effects-leq-without-consume/ M1<=M)
    <- set2efxmap-implies-domain G=>M1 DM-M1=G
    <- efxmap`domain-unique DM-M1=G DM-M1=R1 efxmap`eq/ G=R1
    <- set`disjoint-respects-eq G^S2 G=R1 set`eq/ R1^S2
    <- set`disjoint-implies-remove-nothing R1^S2 R1/S2=R1
    <- set`remove-unique R1/S2=R1 R1/S2=S3 set`eq/ set`eq/ R1=S3
    <- set`leq-reflexive _ R1<=R1
    <- set`leq-respects-eq R1<=R1 set`eq/ R1=S3 R1<=S3
    <- efxmap`domain-leq-implies-no-restriction DM-M1=R1 R1<=S3 M1|S3=M1
    <- efxmap`restrict-unique M1|S3=M1' M1|S3=M1 efxmap`eq/ set`eq/ M1'=M1
    <- efxmap`join-respects-eq M1'+M2=M M1'=M1 efxmap`eq/ efxmap`eq/ M1+M2=M
    <- efxmap`join-implies-leq M1+M2=M M1<=M _.

%worlds () (join-left-preserves-effects-leq-without-consume _ _ _ _).
%total {} (join-left-preserves-effects-leq-without-consume _ _ _ _).


%theorem reftyping-ok/expr-helper/write/L1
  : forall* {G1} {G} {F} {X} {Q} {XX1} {XX3} {XX5} {XX6} {XX7} {XX} {XX'}
    forall {MG: make-targets-and-effects G F X G1 XX3}
    {CP: compatible G1 XX6}
    {XX1+XX3=XX5: effects`join XX1 XX3 XX5}
    {XX5+XX6=XX7: effects`join XX5 XX6 XX7}
    {XX7<=XX: effects-leq-no-consume XX7 XX}
    {TC: transfer-consume XX XX1 XX' Q}
    exists {XX3<=XX': effects-leq-without-consume XX3 XX'}
    true.

%theorem reftyping-ok/expr-helper/write/L1L1
  : forall* {XX} {XX1} {XX2} {XX3}
    forall {L: effects-leq-without-consume XX XX2}
    {XX1+XX2: effects`join XX1 XX2 XX3}
    exists {L: effects-leq-without-consume XX XX3}
    true.

- : reftyping-ok/expr-helper/write/L1L1 (effects-leq-without-consume/ M<=M2)
    (effects`join/ _ _ _ _ _ _ _ _ J _ _ _)
    (effects-leq-without-consume/ M<=M3)
    <- efxmap`join-implies-leq J _ M2<=M3
    <- efxmap`leq-transitive M<=M2 M2<=M3 M<=M3.

%theorem reftyping-ok/expr-helper/write/L1L2
  : forall* {XX} {XX1} {XX2} {XX3} {XX'} {Q}
    forall {L: effects-leq-without-consume XX XX2}
    {XX1+XX2: effects-leq-no-consume XX2 XX3}
    {TC: transfer-consume XX3 XX1 XX' Q}
    exists {L: effects-leq-without-consume XX XX'}
    true.

- : reftyping-ok/expr-helper/write/L1L2
    (effects-leq-without-consume/ M<=M2)
    (effects-leq-no-consume/ M2<=M3)
    (transfer-consume/ _ _ _ _ _ J)
    (effects-leq-without-consume/ M<=M')
    <- efxmap`join-implies-leq J M3<=M' _
    <- efxmap`leq-transitive M<=M2 M2<=M3 M<=M3
    <- efxmap`leq-transitive M<=M3 M3<=M' M<=M'.

- : reftyping-ok/expr-helper/write/L1 MG CP J13=5 J56=7 LE TC LE'
    <- effects`join-associative J13=5 J56=7 _ J36=8 J18=7
    <- join-left-preserves-effects-leq-without-consume MG CP J36=8 L38
    <- reftyping-ok/expr-helper/write/L1L1 L38 J18=7 L37
    <- reftyping-ok/expr-helper/write/L1L2 L37 LE TC LE'.

%worlds () (reftyping-ok/expr-helper/write/L1L1 _ _ _).
%total {} (reftyping-ok/expr-helper/write/L1L1 _ _ _).

%worlds () (reftyping-ok/expr-helper/write/L1L2 _ _ _ _).
%total {} (reftyping-ok/expr-helper/write/L1L2 _ _ _ _).

%worlds () (reftyping-ok/expr-helper/write/L1 _ _ _ _ _ _ _).
%total {} (reftyping-ok/expr-helper/write/L1 _ _ _ _ _ _ _).


%theorem reftyping-ok/expr-helper/write/L2
  : forall* {M1} {S1} {Q1} {M2} {S2} {Q2} {XX} {XX'} {Q3}
    forall {TC: transfer-consume XX (effects/ M1 S1 Q1) XX' Q3}
    {SE: set`eq S1 S2} {QE: set`eq Q1 Q2}
    exists {TC: transfer-consume XX (effects/ M2 S2 Q2) XX' Q3}
    true.

- : reftyping-ok/expr-helper/write/L2
    (transfer-consume/ S1<=S Q1<=Q S/S1=S2 Q/Q1=Q2 S2=>M3 M+M3=M2) SE QE
    (transfer-consume/ S1<=S' Q1<=Q' S/S1=S2 Q/Q1=Q2 S2=>M3 M+M3=M2)
    <- set`leq-respects-eq S1<=S SE set`eq/ S1<=S'
    <- set`leq-respects-eq Q1<=Q QE set`eq/ Q1<=Q'
    <- set`remove-respects-eq S/S1=S2 set`eq/ SE set`eq/ S/S1=S2'
    <- set`remove-respects-eq Q/Q1=Q2 set`eq/ QE set`eq/ Q/Q1=Q2'.

%worlds () (reftyping-ok/expr-helper/write/L2 _ _ _ _).
%total {} (reftyping-ok/expr-helper/write/L2 _ _ _ _).


%theorem effects-getq-respects-eq
  : forall* {XX} {Q} {Q'}
    forall {XG: effects-getq XX Q} {E: set`eq Q Q'}
    exists {XG: effects-getq XX Q'}
    true.

- : effects-getq-respects-eq XG _ XG.

%worlds () (effects-getq-respects-eq _ _ _).
%total {} (effects-getq-respects-eq _ _ _).


%theorem reftyping-ok/expr-helper/write/L3
  : forall* {CM} {PM} {XX1} {XX2} {XX3} {XX} {XX'} {Q} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-XX: clsmap-cxt-effects CM B XX}
    {XX1+XX2=XX:effects`join XX1 XX2 XX3}
    {XX3<=XX: effects-leq-no-consume XX3 XX}
    {TC: transfer-consume XX XX1 XX' Q}
    exists {Pi} {XG: effects-getq XX2 Q}
    {Q=>Pi: make-fperm CM PM B Q Pi}
    true.

- : reftyping-ok/expr-helper/write/L3 CM-CM CM2PM
    (clsmap-cxt-effects/ _ _ S=>SQ Q<=SQ _ CM-B-S)
    (effects`join/ _ _ _ _ _ S1^S2 _ _ _ _ Q1^Q2 (Q1+Q2=Q:set`union Q1 Q2 Q))
    (effects-leq-no-consume/ _)
    (transfer-consume/ _ Q1<=Q _ (Q/Q1=Q3:set`remove Q Q1 Q3) _ _) _ XG Q3=>Pi
    <- set`union-commutative Q1+Q2=Q Q2+Q1=Q
    <- set`disjoint-symmetric Q1^Q2 Q2^Q1
    <- set`disjoint-union-implies-remove Q2+Q1=Q Q2^Q1 Q/Q1=Q2
    <- set`remove-unique Q/Q1=Q2 Q/Q1=Q3 set`eq/ set`eq/ Q2=Q3
    <- effects-getq-respects-eq effects-getq/ Q2=Q3 XG
    <- collect-objs-implies-clsmap-cxt-set2 CM-B-S S=>SQ CM-B-SQ
    <- clsmap-cxt-set2-respects-geq CM-B-SQ Q<=SQ CM-B-Q
    <- set`remove-implies-leq Q/Q1=Q3 Q3<=Q
    <- clsmap-cxt-set2-respects-geq CM-B-Q Q3<=Q CM-B-Q3
    <- make-fperm-total CM-CM CM2PM CM-B-Q3 _ Q3=>Pi.

%worlds () (reftyping-ok/expr-helper/write/L3 _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/expr-helper/write/L3 _ _ _ _ _ _ _ _ _).


%theorem read-ready-format-implies-consume/L
  : forall* {CM} {PM} {B} {X} {M} {Pi}
    forall {S2M: set2efxmap set/0 X M}
    {M=>Pi: efxmap2perm CM PM B M Pi}
    exists {E: equiv Pi empty}
    true.

- : read-ready-format-implies-consume/L S2M M2P PE
    <- set2efxmap-unique S2M set2efxmap/0 set`eq/ efx`eq/ ME
    <- efxmap2perm-equiv M2P efxmap2perm/0 clsmap`eq/ predmap`eq/ cxt`eq/ ME PE.

%worlds () (read-ready-format-implies-consume/L _ _ _).
%total {} (read-ready-format-implies-consume/L _ _ _).


% can be easily proved

%theorem efxmap`leq-partition-preserves-leq
  : forall* {M} {M1} {M2} {M2'} {R2}
    forall {DM-M2=R2: efxmap`domain M2 R2}
    {M|R2=M1+M2': efxmap`partition M R2 M1 M2'}
    exists {DM-M2'=R2: efxmap`domain M2' R2}
    {M2<=M2': efxmap`leq M2 M2'}
    true.

%worlds () (efxmap`leq-partition-preserves-leq _ _ _ _).
%trustme %total {} (efxmap`leq-partition-preserves-leq _ _ _ _).


%theorem make-write-intermediate-format/L1
  : forall* {M1} {M2} {M} {MP} {MQ} {G} {S2}
    forall {P: efxmap`partition M G MP MQ}
    {J: efxmap`join M1 M2 M}
    {DM: efxmap`domain M2 S2}
    {D: set`disjoint G S2}
    exists {MK} {P: efxmap`partition M1 G MK MQ}
    {J: efxmap`join MK M2 MP}
    true.

%worlds () (make-write-intermediate-format/L1 _ _ _ _ _ _ _).
%trustme %total {} (make-write-intermediate-format/L1 _ _ _ _ _ _ _).


%theorem make-write-intermediate-format/L2
  : forall* {M2} {M} {MP} {MQ} {G} {S2}
    forall {P: efxmap`partition M G MP MQ}
    {DM: efxmap`domain M2 S2}
    {D: set`disjoint G S2}
    {LE: efxmap`leq M2 M}
    exists {LE: efxmap`leq M2 MP}
    true.

%worlds () (make-write-intermediate-format/L2 _ _ _ _ _).
%trustme %total {} (make-write-intermediate-format/L2 _ _ _ _ _).


%theorem partition-domain-leq
  : forall* {M} {S} {D}
    forall {DM: efxmap`domain M D}
    {L: set`leq D S}
    exists {P: efxmap`partition M S efxmap/0 M}
    true.

- : partition-domain-leq DM-M=D D<=S
    (efxmap`partition/ DM-M=D D/S=0 M|0=0 M|S=M)
    <- set`leq-implies-remove-all D<=S D/S=0
    <- efxmap`empty-restriction M|0=0
    <- efxmap`domain-leq-implies-no-restriction DM-M=D D<=S M|S=M.

%worlds () (partition-domain-leq _ _ _).
%total { } (partition-domain-leq _ _ _).


%theorem write-efx-means-whole-fldperm
  : forall* {CM} {PM} {B} {C} {G} {G'} {F} {XX} {XX'} {Pi1} {Pi2} {Q}
    forall {MG: make-targets-and-effects G F efx/write G' XX}
    {LE: effects-leq-without-consume XX XX'}
    {REE: read-format CM PM B C G' XX' ([r] Pi1 r) Pi2 (fraction/ Q)}
    exists {EQ: rat`eq Q one}
    true.

- : write-efx-means-whole-fldperm
    (make-targets-and-effects/unique G1+F=G1' G2^G1' G2+G1'=G G=>M)
    (effects-leq-without-consume/ M<=M') (read-format/unique/0 _ _) rat`eq/.

%theorem write-efx-means-whole-fldperm/L
  : forall* {S} {M} {M2} {X1} {X}
    forall {N} {SZ: set`size S N}
    {S=>M: set2efxmap S efx/write M}
    {MX-M=X1: efxmap-min-efx M2 X1}
    {M<=M2: efxmap`leq M M2}
    {DM-M=S: efxmap`domain M S} {DM-M2=S: efxmap`domain M2 S}
    {MX: efx`min X1 efx/write X}
    exists {EQ: efx`eq X efx/write}
    true.

- : write-efx-means-whole-fldperm/L z set`size/0 S=>M M=>X1 _ _ _ MN X=W
    <- set2efxmap-unique S=>M set2efxmap/0 set`eq/ efx`eq/ M=0
    <- efxmap-min-efx-unique M=>X1 efxmap-min-efx/0 efx`eq/ M=0 X1=W
    <- efx`min-unique MN efx`min/= X1=W efx`eq/ X=W.

- : write-efx-means-whole-fldperm/L (s _) SZ S=>M MX-M2 M<=M2 DM-M DM-M2 MN EQ
    <- set2efxmap-implies-efxmap-min-efx _ SZ S=>M MX-M
    <- efxmap-min-efx-respects-leq-domain MX-M M<=M2 DM-M DM-M2 _ MX-M2'
      (efx`geq/= efx`eq/)
    <- efxmap-min-efx-unique MX-M2 MX-M2' efx`eq/ efxmap`eq/ X=W
    <- efx`min-unique MN efx`min/= X=W efx`eq/ EQ.

%worlds () (write-efx-means-whole-fldperm/L _ _ _ _ _ _ _ _ _).
%total { } (write-efx-means-whole-fldperm/L _ _ _ _ _ _ _ _ _).

- : write-efx-means-whole-fldperm
    (make-targets-and-effects/unique
      G1+F=G1' G2^G1' G2+G1'=G G=>M)
    (effects-leq-without-consume/ M<=M')
    (read-format/unique/+f SZ-G M'|G=M1+M2 _ _ MX-M2=X X2Q) Q=1
    <- set2efxmap-implies-domain G=>M DM-M=G
    <- set`leq-reflexive _ G<=G
    <- partition-domain-leq DM-M=G G<=G M|G=0+M
    <- partition-right-preserves-leq M<=M' M|G=0+M M'|G=M1+M2 M<=M2
    <- efxmap`domain-preserves-leq M<=M' DM-M=G G' DM-M'=G' G<=G'
    <- partition-implies-domain M'|G=M1+M2 DM-M'=G' G<=G' DM-M2=G
    <- set2efxmap-implies-efxmap-min-efx _ SZ-G G=>M MX-M
    <- efxmap-min-efx-respects-leq-domain
      MX-M M<=M2 DM-M=G DM-M2=G _ MX-M2=X' (efx`geq/= efx`eq/)
    <- efxmap-min-efx-unique MX-M2=X MX-M2=X' efx`eq/ efxmap`eq/ X=X'
    <- efx2frac-unique X2Q efx2frac/write X=X' Q=1.

%worlds () (write-efx-means-whole-fldperm _ _ _ _).
%trustme %total { } (write-efx-means-whole-fldperm _ _ _ _).


%theorem make-write-intermediate-format
  : forall* {CM} {PM} {B} {C} {Pi1} {Pi} {XX1} {XX2} {XX3} {XX} {XX'}
    {Pib} {Piq} {Q} {Z} {G}
    forall {CM-B-XX: clsmap-cxt-effects CM B XX}
    {CM-B-XX2: clsmap-cxt-effects CM B XX2}
    {XX1+XX2=XX3: effects`join XX1 XX2 XX3}
    {XX3<=XX: effects-leq-no-consume XX3 XX}
    {TC: transfer-consume XX XX1 XX' Q}
    {G-Q: effects-getq XX2 Q}
    {BWF: read-format CM PM B C G XX' ([r] Pi1 r) Pi (fraction/ Z)}
    {Z=1: rat`eq Z one}
    {XX-GSP: compatible G XX2}
    {B=>Pib: cxt2perm CM PM B Pib}
    {Q2=>Piq: make-fperm CM PM B Q Piq}
    exists {XX2'} {Pi2} {Pi3}
    {XX2<=XX2': effects-leq-no-consume XX2 XX2'}
    {CM-B-XX2': clsmap-cxt-effects CM B XX2'}
    {XX2'=>Pi2': effects2input CM PM B XX2' Pi2}
    {WIF: write-intermediate-format CM PM B C G XX XX2' Pi1 Pi3}
    {EQV: equiv (Pib , (Piq , Pi)) (Pi2 , Pi3)}
    true.

- : make-write-intermediate-format
    (clsmap-cxt-effects/ DM-M=R (R^S3:set`disjoint R S3) _ _ _ _)
    (clsmap-cxt-effects/ DM-M2=R2'' R2''^S2 S2=>SQ2 Q<=SQ CM-B-R2'' CM-B-S2)
    (effects`join/ _ (DM-M2=R2:efxmap`domain M2 R2) _ _ _ S1^S2 _ _ M1'+M2=M3
      (S1+S2=S3:set`union S1 S2 S3) _ (Q1+Q2=Q3:set`union Q1 Q2 Q3))
    (effects-leq-no-consume/ (M3<=M:efxmap`leq M3 M))
    (transfer-consume/ _ _ (S3/S1=S2':set`remove S3 S1 S2')
      Q3/Q1=Q2' S2'=>Mx M+Mx=M') effects-getq/
    (read-format/unique/0 PML M'=>Pi') Z=1
    (compatible/unique _ _ _) B=>Pib Q=>Piq %{=>}% _ _ _
    (effects-leq-no-consume/ M2<=M2')
    (clsmap-cxt-effects/ DM-M2'=R2 R2^S2 S2=>SQ2 Q<=SQ CM-B-R2 CM-B-S2)
    (effects2input/ B=>Pib Q=>Piq S2=>Mx Mx=>Pi23 M2'=>Pi24)
    (write-intermediate-format/0 PML DM-M2'=R2 M|R2=Mv+M2' Mv=>Pi3)
    (equiv/transitive4
      (equiv/combine
        (equiv/reflexive)
        (equiv/combine
          (equiv/reflexive)
          (equiv/transitive4
            (Pi'<=>Pi+Pi23)
            (equiv/combine
              (Pi<=>Pi3+Pi24)
              (equiv/reflexive))
            (equiv/symmetric equiv/associate)
            (equiv/combine
              (equiv/reflexive)
              (equiv/commute)))))
      (equiv/roll3)
      (equiv/commute)
      (equiv/combine
        (equiv/transitive
          (equiv/combine
            (equiv/reflexive)
            (equiv/associate))
          (equiv/associate))
        (equiv/reflexive)))
    <- efxmap`join-implies-leq M1'+M2=M3 M1'<=M3 M2<=M3
    <- efxmap`join-implies-leq M+Mx=M' M<=M' Mx<=M'
    <- efxmap`leq-transitive M2<=M3 M3<=M M2<=M
    <- efxmap`leq-transitive M2<=M M<=M' (M2<=M':efxmap`leq M2 M')
    <- set`union-commutative S1+S2=S3 S2+S1=S3
    <- set`disjoint-symmetric S1^S2 S2^S1
    <- set`disjoint-union-implies-remove S2+S1=S3 S2^S1 S3/S1=S2
    <- set`remove-implies-leq S3/S1=S2 S2<=S3
    <- set`remove-unique S3/S1=S2' S3/S1=S2 set`eq/ set`eq/ (S2'=S2:set`eq S2' S2)
    <- set2efxmap-respects-eq S2'=>Mx S2'=S2 efx`eq/ efxmap`eq/ S2=>Mx
    <- set`leq-reflexive _ R<=R
    <- set`disjoint-respects-geq R^S3 R<=R S2<=S3 R^S2
    <- set2efxmap-implies-domain S2=>Mx (DM-Mx=S2:efxmap`domain Mx S2)
    <- efxmap`domain-preserves-disjoint-converse R^S2 DM-M=R DM-Mx=S2 M^Mx
    <- efxmap`disjoint-join-implies-equiv
      M^Mx M+Mx=M' M'=>Pi' Pi Pi23 M=>Pi Mx=>Pi23 Pi'<=>Pi+Pi23
    <- efxmap`partition-total (M|R2=Mv+M2':efxmap`partition M R2 Mv M2')
    <- efxmap`partition-implies-disjoint-join M|R2=Mv+M2' Mv^M2' Mv+M2'=M
    <- efxmap`leq-partition-preserves-leq DM-M2=R2 M|R2=Mv+M2' DM-M2'=R2 M2<=M2'
    <- efxmap`disjoint-join-implies-equiv
      Mv^M2' Mv+M2'=M M=>Pi Pi3 Pi24 Mv=>Pi3 M2'=>Pi24 Pi<=>Pi3+Pi24
    <- efxmap`domain-unique DM-M2=R2'' DM-M2=R2 efxmap`eq/ R2''=R2
    <- set`disjoint-respects-eq R2''^S2 R2''=R2 set`eq/ R2^S2
    <- clsmap-cxt-set-respects-eq CM-B-R2'' clsmap`eq/ cxt`eq/ R2''=R2 CM-B-R2.

- : make-write-intermediate-format
    (clsmap-cxt-effects/ DM-M=R (R^S3:set`disjoint R S3) _ _ _ _)
    (clsmap-cxt-effects/ DM-M2=R2'' R2''^S2 S2=>SQ2 Q<=SQ CM-B-R2'' CM-B-S2)
    (effects`join/ _ (DM-M2=R2:efxmap`domain M2 R2) _ _ _ S1^S2 _ _ M1'+M2=M3
      (S1+S2=S3:set`union S1 S2 S3) _ (Q1+Q2=Q3:set`union Q1 Q2 Q3))
    (effects-leq-no-consume/ (M3<=M:efxmap`leq M3 M))
    (transfer-consume/ _ _ (S3/S1=S2':set`remove S3 S1 S2')
      Q3/Q1=Q2' S2'=>Mx M+Mx=M') effects-getq/
    (read-format/unique/+f SZ-G (M'|G=Mp+Mq:partition M' G Mp Mq) Mp=>Pi2
      Mq=>Pi3 (MX-Mq=X:efxmap-min-efx Mq X) X2Q) Z=1
    (compatible/unique DM-M2=R2' (G^R2':set`disjoint G R2') G^S2)
    B=>Pib Q=>Piq %{=>}% _ _ _ (effects-leq-no-consume/ M2<=M2')
    (clsmap-cxt-effects/ DM-M2'=R2 R2^S2 S2=>SQ2 Q<=SQ CM-B-R2 CM-B-S2)
    (effects2input/ B=>Pib Q=>Piq S2=>Mx Mx=>Pi2x M2'=>Pi2')
    (write-intermediate-format/+f SZ-G M|G=Mk+Mq
      Mq=>Pi3 MX-Mq=X X2Q Z=1 DM-M2'=R2 Mk|R2=Mv+M2' Mv=>Pi2v)
    (equiv/transitive4
      (equiv/combine
        (equiv/reflexive)
        (equiv/combine
          (equiv/reflexive)
          (equiv/transitive4
            (Pi2<=>Pi2k+Pi2x)
            (equiv/combine
              (Pi2k<=>Pi2v+Pi2')
              (equiv/reflexive))
            (equiv/symmetric equiv/associate)
            (equiv/combine
              (equiv/reflexive)
              (equiv/commute)))))
      (equiv/roll3)
      (equiv/commute)
      (equiv/combine
        (equiv/transitive
          (equiv/combine
            (equiv/reflexive)
            (equiv/associate))
          (equiv/associate))
        (equiv/reflexive)))
    <- efxmap`join-implies-leq M1'+M2=M3 M1'<=M3 M2<=M3
    <- efxmap`join-implies-leq M+Mx=M' M<=M' Mx<=M'
    <- efxmap`leq-transitive M2<=M3 M3<=M M2<=M
    <- set`union-commutative S1+S2=S3 S2+S1=S3
    <- set`disjoint-symmetric S1^S2 S2^S1
    <- set`disjoint-union-implies-remove S2+S1=S3 S2^S1 S3/S1=S2
    <- set`remove-implies-leq S3/S1=S2 S2<=S3
    <- set`remove-unique S3/S1=S2' S3/S1=S2 set`eq/ set`eq/ (S2'=S2:set`eq S2' S2)
    <- set2efxmap-respects-eq S2'=>Mx S2'=S2 efx`eq/ efxmap`eq/ S2=>Mx
    <- set2efxmap-implies-domain S2=>Mx DM-Mx=S2
    <- set`leq-reflexive _ R<=R
    <- set`disjoint-respects-geq R^S3 R<=R S2<=S3 R^S2
    <- efxmap`domain-preserves-disjoint-converse R^S2 DM-M=R DM-Mx=S2 M^Mx
    <- make-write-intermediate-format/L1 M'|G=Mp+Mq M+Mx=M' DM-Mx=S2
      G^S2 Mk M|G=Mk+Mq Mk+Mx=Mp
    <- efxmap`partition-implies-leq M|G=Mk+Mq Mk<=M Mq<=M
    <- efxmap`disjoint-respects-geq* M^Mx Mk<=M Mk^Mx
    <- efxmap`disjoint-join-implies-equiv
      Mk^Mx Mk+Mx=Mp Mp=>Pi2 Pi2k Pi2x Mk=>Pi2k Mx=>Pi2x Pi2<=>Pi2k+Pi2x
    <- make-write-intermediate-format/L2 M|G=Mk+Mq DM-M2=R2' G^R2' M2<=M M2<=Mk
    <- efxmap`partition-total (Mk|R2=Mv+M2':efxmap`partition Mk R2 Mv M2')
    <- efxmap`leq-partition-preserves-leq DM-M2=R2 Mk|R2=Mv+M2' DM-M2'=R2 M2<=M2'
    <- efxmap`partition-implies-disjoint-join Mk|R2=Mv+M2' Mv^M2' Mv+M2'=Mk
    <- efxmap`disjoint-join-implies-equiv
      Mv^M2' Mv+M2'=Mk Mk=>Pi2k Pi2v Pi2' Mv=>Pi2v M2'=>Pi2' Pi2k<=>Pi2v+Pi2'
    <- efxmap`domain-unique DM-M2=R2'' DM-M2=R2 efxmap`eq/ R2''=R2
    <- set`disjoint-respects-eq R2''^S2 R2''=R2 set`eq/ R2^S2
    <- clsmap-cxt-set-respects-eq CM-B-R2'' clsmap`eq/ cxt`eq/ R2''=R2 CM-B-R2.

%worlds () (make-write-intermediate-format _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (make-write-intermediate-format _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


% Theorems

%% 1. set-all-permissions

%theorem set-all-permissions-respects-eq
  : forall* {PM} {PM'} {S} {S'} {Pi} {Pi'} {B} {C}
    forall {SAP: set-all-permissions PM B C S Pi}
    {PME: predmap`eq PM PM'} {SE: set`eq S S'} {PE: permission`eq Pi Pi'}
    exists {SAP: set-all-permissions PM' B C S' Pi'}
    true.

- : set-all-permissions-respects-eq SAP predmap`eq/ set`eq/ permission`eq/ SAP.

%worlds (objvar) (set-all-permissions-respects-eq _ _ _ _ _).
%total { } (set-all-permissions-respects-eq _ _ _ _ _).


%theorem set-all-permissions-equiv
  : forall* {PM} {S} {S'} {Pi} {Pi'} {B} {C}
    forall {SAP: set-all-permissions PM B C S Pi}
    {SAP: set-all-permissions PM B C S' Pi'}
    {SE: set`eq S S'}
    exists {EQV: equiv Pi Pi'}
    true.

%worlds (objvar) (set-all-permissions-equiv _ _ _ _).
%trustme %total { } (set-all-permissions-equiv _ _ _ _).


%theorem restore-object-permission
  : forall* {CM} {PM} {B} {S} {S2} {FS} {Pi} {M} {Pi2} {C} {FM}
    forall {SOC: same-class B S C}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {MF: make-fperm CM PM B S Pi}
    {S+FS=>S2: set+set2set S FS S2}
    {S2=>M: set2efxmap S2 efx/write M}
    {M2P: efxmap2perm CM PM B M Pi2}
    exists {Pi3} {IMP: implies (Pi2 , Pi) Pi3}
    {SAP: set-all-permissions PM B C S Pi3}
    true.

- : restore-object-permission _ _ _ _ make-fperm/0 S+FS=>S2 S2=>M2 M2=>Pi2 _
    (implies/trans (implies/combine (implies/equiv EQV) implies/reflexive)
      (implies/equiv equiv/identity))
    set-all-permissions/0
    <- set+set2set-unique S+FS=>S2 set+set2set/0 set`eq/ set`eq/ S2=0
    <- set2efxmap-unique S2=>M2 set2efxmap/0 S2=0 efx`eq/ M2=0
    <- efxmap2perm-equiv M2=>Pi2 efxmap2perm/0 clsmap`eq/
      predmap`eq/ cxt`eq/ M2=0 EQV.


%theorem restore-object-permission/L2
  : forall* {N} {FS} {S} {R} {S2}
    forall {N!<S: set`not-member S N}
    {N+FS=>S: nat+set2set N FS R}
    {S+FS=>S2': set+set2set S FS S2}
    exists {D: set`disjoint S2 R}
    true.

%theorem restore-object-permission/L2L
  : forall* {N} {FS} {S} {R} {S2}
    forall {N!<S: set`not-member S N}
    {N+FS=>S: nat+set2set N FS R}
    {S+FS=>S2': set+set2set S FS S2}
    {B} {D?: set`disjoint? S2 R B}
    exists {D: set`disjoint S2 R}
    true.

- : restore-object-permission/L2L _ _ _ _ (set`disjoint?/yes D) D.

- : restore-object-permission/L2L (N!<S:set`not-member S N)
    N+FS=>R S+FS=>S2 false (set`disjoint?/no K<-S2 K<-R) S2^R
    <- set`member-implies-not-member-add K<-R R' K!<R' R'+K=R
    <- set+set2set-lookup-implies-nat2pair S+FS=>S2 K<-S2 N0 F N0<-S F<-FS K=>N0+F
    <- nat+set2set/UP-inversion N+FS=>R K!<R' R'+K=R _ N+FS=R' F0 K=>N+F0 FS+F0=FS
    <- nat2pair-unique K=>N0+F K=>N+F0 nat`eq/ PE
    <- pair-eq-implies-eq PE N0=N F=F0
    <- set`not-member-member-not-equal N!<S N0<-S N<>N0
    <- nat`ne-symmetric N<>N0 N0<>N
    <- nat`eq-ne-implies-false N0=N N0<>N V
    <- set`false-implies-disjoint V S2^R.

%worlds (objvar) (restore-object-permission/L2L _ _ _ _ _ _).
%total { } (restore-object-permission/L2L _ _ _ _ _ _).

- : restore-object-permission/L2 N!<S N+FS=>S S+FS=>S2' S2^R
    <- set`disjoint?-total S2^R?
    <- restore-object-permission/L2L N!<S N+FS=>S S+FS=>S2' _ S2^R? S2^R.

%worlds (objvar) (restore-object-permission/L2 _ _ _ _).
%total { } (restore-object-permission/L2 _ _ _ _).


%theorem restore-object-permission/L3
  : forall* {CM} {PM} {FM} {B} {M} {N} {S} {Pi} {A} {C} {FS} {FS0} {O}
    forall {NN} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    {N+FS=>S: nat+set2set N FS S}
    {S=>M: set2efxmap S efx/write M}
    {M=>Pi: efxmap2perm CM PM B M Pi}
    exists {PiF} {PiF2}
    {SFP: {x} make-fperm1 PM x FM FS (PiF x)}
    {CNN: consider-nn PiF NN PiF2}
    {Pi=>PiF: implies Pi (PiF2 O)}
    true.

- : restore-object-permission/L3 nn/yes _ _ _ set`leq/0
    N+FS=>S S=>M M=>Pi
    _ _ ([_] make-fperm1/0) consider-nn/yes
    (implies/equiv EQV)
    <- nat+set2set-unique N+FS=>S nat+set2set/0 nat`eq/ set`eq/ S=0
    <- set2efxmap-unique S=>M set2efxmap/0 S=0 efx`eq/ M=0
    <- efxmap2perm-equiv M=>Pi efxmap2perm/0 clsmap`eq/ predmap`eq/
      cxt`eq/ M=0 EQV.

- : restore-object-permission/L3 nn/may _ _
    _ set`leq/0 N+FS=>S S=>M M=>Pi
    _ _ ([_] make-fperm1/0) consider-nn/may
    (implies/trans (implies/equiv EQV) implies/cond-equal-objequal)
    <- nat+set2set-unique N+FS=>S nat+set2set/0 nat`eq/ set`eq/ S=0
    <- set2efxmap-unique S=>M set2efxmap/0 S=0 efx`eq/ M=0
    <- efxmap2perm-equiv M=>Pi efxmap2perm/0 clsmap`eq/ predmap`eq/
      cxt`eq/ M=0 EQV.

%theorem restore-object-permission/L3L
  : forall* {PM} {FM} {FS} {PiF} {PiF2}
    forall {SFP: {x} make-fperm1 PM x FM FS (PiF x)}
    {CNN: consider-nn PiF nn/may PiF2}
    exists {EQ: {x} permission`eq (PiF2 x)
                (unitperm (conditional (objequal x null) empty (PiF x)))}
    true.

- : restore-object-permission/L3L _ consider-nn/may ([_] permission`eq/).

%worlds (objvar) (restore-object-permission/L3L _ _ _).
%total { } (restore-object-permission/L3L _ _ _).


%theorem restore-object-permission/L3L2
  : forall* {O1} {O2} {Pi1} {Pi2}
    forall {E: object`eq O1 O2}
    exists {EQV: equiv
                 (unitperm (conditional (objequal O1 null) Pi1 Pi2))
                 (unitperm (conditional (objequal O2 null) Pi1 Pi2))}
    true.

- : restore-object-permission/L3L2 object`eq/ equiv/reflexive.

%worlds (objvar) (restore-object-permission/L3L2 _ _).
%total { } (restore-object-permission/L3L2 _ _).


- : restore-object-permission/L3 nn/yes
    (BL:cxt`lookup _ _ (cxt-info/ O _)) CML
    FM-DM=FS0 FS<=FS0 (nat+set2set/U N+FS'=>S' K=>N+F F!<FS' FS'+F=FS S'+K=S)
    S=>M M=>Pi _ _
    ([x] make-fperm1/U (FS'=>Pi' x) F!<FS' FS'+F=FS FML (T2PF:ty2perm _ _ PF))
    (consider-nn/yes)
    (implies/trans
      (implies/equiv
        (equiv/transitive
          (equiv/symmetric PF+Pi'<=>Pi)
          (equiv/combine (PFEQV O') equiv/reflexive)))
      (implies/combine
        (implies/equiv PF0<=>PF)
        (IMP)))
    <- nat+set2set-preserves-fresh N+FS'=>S' F!<FS' K=>N+F K!<S'
    <- set`fresh-update-implies-leq F!<FS' FS'+F=FS FS'<=FS
    <- set`leq-transitive FS'<=FS FS<=FS0 FS'<=FS0
    <- set2efxmap/U-inversion S=>M K!<S' S'+K=S M' _ S'=>M' ID M'+K+X=M
    <- efx-id-eq ID XEx
    <- efx`eq-symmetric XEx XE
    <- efxmap`update-respects-eq
      M'+K+X=M efxmap`eq/ nat`eq/ XE efxmap`eq/ M'+K+W=M
    <- set2efxmap-preserves-fresh K!<S' S'=>M' K!<M'
    <- efxmap2perm/U-inversion M=>Pi K!<M' M'+K+W=M N0 F0 K=>N0+F0
      O' _ _ _ BL0 FM0 CML0 _ FML0 _ T2PF0
      _ CNN _ apply-efx/write _ M'=>Pi' PF+Pi'<=>Pi
    <- nat2pair-unique K=>N0+F0 K=>N+F nat`eq/ PE
    <- pair-eq-implies-eq PE N0=N F0=F
    <- cxt`lookup-unique BL0 BL cxt`eq/ N0=N CIO=CI
    <- cxt-info-eq-inversion CIO=CI O0=O T0=T
    <- ty-eq-inversion T0=T NN0=NN _ C0=C
    <- consider-nn-unique CNN consider-nn/yes ([_] permission`eq/) NN0=NN PFE
    <- ({x} permission`eq-implies-equiv (PFE x) (PFEQV x))
    <- clsmap`lookup-unique CML0 CML clsmap`eq/ C0=C (FM0=FM:fldmap`eq FM0 FM)
    <- set`add-implies-member FS'+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
    <- fldmap`domain-preserves-lookup-converse F<-FS0 FM-DM=FS0 T FML
    <- fldmap`lookup-unique FML0 FML FM0=FM F0=F FT0=FT
    <- ty2perm-respects-eq T2PF0 predmap`eq/ FT0=FT ([_] permission`eq/) T2PF
    <- restore-object-permission/L3 _ BL CML FM-DM=FS0 FS'<=FS0 N+FS'=>S'
      S'=>M' M'=>Pi' _ _ ([x] FS'=>Pi' x) consider-nn/yes IMP
    <- permission`precise-exists-respects-eq O0=O F0=F
      ([_] permission`eq/) PF0=PF
    <- permission`eq-implies-equiv PF0=PF PF0<=>PF.

- : restore-object-permission/L3 nn/may
    (BL:cxt`lookup _ _ (cxt-info/ O _)) CML
    FM-DM=FS0 FS<=FS0 (nat+set2set/U N+FS'=>S' K=>N+F F!<FS' FS'+F=FS S'+K=S)
    S=>M M=>Pi _ _
    ([x] make-fperm1/U (FS'=>Pi' x) F!<FS' FS'+F=FS FML T2PF)
    (consider-nn/may)
    (implies/trans6
      (implies/equiv (equiv/symmetric PF+Pi'<=>Pi))
      (implies/combine (implies/equiv (PFEQV O')) implies/reflexive)
      (implies/combine implies/reflexive IMP)
      (implies/combine (implies/equiv EQV) implies/reflexive)
      (implies/cond-factor)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/identity)
        (implies/combine
          (implies/equiv (PF0<=>PF))
          (implies/reflexive))))
    <- nat+set2set-preserves-fresh N+FS'=>S' F!<FS' K=>N+F K!<S'
    <- set`fresh-update-implies-leq F!<FS' FS'+F=FS FS'<=FS
    <- set`leq-transitive FS'<=FS FS<=FS0 FS'<=FS0
    <- set2efxmap/U-inversion S=>M K!<S' S'+K=S M' _ S'=>M' ID M'+K+X=M
    <- efx-id-eq ID XEx
    <- efx`eq-symmetric XEx XE
    <- efxmap`update-respects-eq M'+K+X=M efxmap`eq/ nat`eq/ XE efxmap`eq/ M'+K+W=M
    <- set2efxmap-preserves-fresh K!<S' S'=>M' K!<M'
    <- efxmap2perm/U-inversion M=>Pi K!<M' M'+K+W=M N0 F0 K=>N0+F0
      O' _ _ _ BL0 FM0 CML0 _ FML0 _ T2PF0
      _ CNN _ apply-efx/write _ M'=>Pi' PF+Pi'<=>Pi
    <- nat2pair-unique K=>N0+F0 K=>N+F nat`eq/ PE
    <- pair-eq-implies-eq PE N0=N F0=F
    <- cxt`lookup-unique BL0 BL cxt`eq/ N0=N CIO=CI
    <- cxt-info-eq-inversion CIO=CI O0=O T0=T
    <- ty-eq-inversion T0=T NN0=NN _ C0=C
    <- consider-nn-unique CNN consider-nn/may ([_] permission`eq/) NN0=NN PFE
    <- ({x} permission`eq-implies-equiv (PFE x) (PFEQV x))
    <- clsmap`lookup-unique CML0 CML clsmap`eq/ C0=C (FM0=FM:fldmap`eq FM0 FM)
    <- set`add-implies-member FS'+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
    <- fldmap`domain-preserves-lookup-converse F<-FS0 FM-DM=FS0 T FML
    <- fldmap`lookup-unique FML0 FML FM0=FM F0=F FT0=FT
    <- ty2perm-respects-eq T2PF0 predmap`eq/ FT0=FT ([_] permission`eq/) T2PF
    <- restore-object-permission/L3 _ BL CML FM-DM=FS0 FS'<=FS0 N+FS'=>S'
      S'=>M' M'=>Pi' _ _ ([x] FS'=>Pi' x) consider-nn/may IMP
    <- permission`precise-exists-respects-eq O0=O F0=F
      ([_] permission`eq/) PF0=PF
    <- permission`eq-implies-equiv PF0=PF PF0<=>PF
    <- restore-object-permission/L3L2 O0=O EQV.

%worlds (objvar) (restore-object-permission/L3 _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A) (restore-object-permission/L3 _ _ _ _ _ A _ _ _ _ _ _ _).


%theorem restore-object-permission/L4
  : forall* {PM} {C} {CP} {Pi} {PF} {NN} {PF2} {PF3}
    forall {PML: predmap`lookup PM C CP}
    {CNN: consider-nn
          ([x] (combine (one-predcall CP x)
                 (combine (obj-ne-null x)
                   (unitperm (encumbered (Pi x) (allperm x)))))) NN PF}
    {CNN: consider-nn ([x] PF3 x) NN ([x] PF2 x)}
    {EQ: {x} permission`eq (PF3 x) (Pi x)}
    exists {PF4} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF4}
    {IMP: {x} implies ((PF2 x) , (PF x)) (PF4 x)}
    true.

- : restore-object-permission/L4 PML
    consider-nn/yes consider-nn/yes ([_] permission`eq/) _
    (ty2perm/ PML nn2perm/yes annot2perm/unique)
    ([_] implies/trans
      (implies/equiv
        (equiv/transitive
          (equiv/roll3)
          (equiv/combine
            (equiv/reflexive)
            (equiv/reorder))))
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/combine
            (implies/reflexive) (implies/linear-modus-ponens))
          (implies/equiv equiv/commute)))).

- : restore-object-permission/L4 PML
    consider-nn/may consider-nn/may ([_] permission`eq/) _
    (ty2perm/ PML nn2perm/may annot2perm/unique)
    ([x] implies/trans
      (implies/cond-factor)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/identity)
        (implies/trans3
          (implies/equiv
            (equiv/transitive
              (equiv/roll3)
              (equiv/combine
                (equiv/reflexive)
                (equiv/reorder))))
          (implies/combine
            (implies/nonlinear2empty)
            (implies/trans
              (implies/combine
                (implies/reflexive) (implies/linear-modus-ponens))
              (implies/equiv equiv/commute)))
          (implies/equiv
            (equiv/transitive equiv/commute equiv/identity))))).

%worlds (objvar) (restore-object-permission/L4 _ _ _ _ _ _ _).
%total { } (restore-object-permission/L4 _ _ _ _ _ _ _).

- : restore-object-permission SOC CM2PM CML0 FM-DM0
    (make-fperm/U S'=>Pi' BL1 PML CML1 DM-FM MF1 CNN N!<S' S'+N=S)
    S+FS=>S2 S2=>M2 M2=>Pi2 _
    (implies/trans5
      (implies/combine (implies/equiv Pi2<=>Pi2'+PiR) implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive
        (implies/trans3
          (implies/combine Pi=>PiF2 implies/reflexive)
          (implies/equiv equiv/associate)
          (implies/combine (IMP2 O) implies/reflexive)))
      (implies/equiv equiv/reorder)
      (implies/combine implies/reflexive IMP))
    (set-all-permissions/U S'-Pi3 N!<S' S'+N=S
      (BL1:cxt`lookup _ _ (cxt-info/ O _)) T2PF)
    <- same-class/U-inversion SOC N!<S' S'+N=S _ _ _ SOC' BL0
    <- set+set2set/U-inversion
      S+FS=>S2 N!<S' S'+N=S S2' S'+FS=>S2' R N+FS=>R S2'+R=S2
    <- restore-object-permission/L2 N!<S' N+FS=>R S'+FS=>S2' S2'^R
    <- set2efxmap-preserves-disjoint-join S2=>M2 S2'^R S2'+R=S2
      M2' MR S2'=>M2' R=>MR M2'^MR M2'+MR=M2
    <- efxmap`disjoint-join-implies-equiv M2'^MR M2'+MR=M2 M2=>Pi2
      Pi2' PiR M2'=>Pi2' MR=>PiR Pi2<=>Pi2'+PiR
    <- cxt`lookup-unique BL0 BL1 cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE TE
    <- ty-eq-inversion TE _ _ CE
    <- clsmap`lookup-unique CML0 CML1 clsmap`eq/ CE FME
    <- fldmap`domain-respects-eq FM-DM0 FME set`eq/ FM-DM
    <- restore-object-permission SOC' CM2PM CML0 FM-DM0 S'=>Pi'
      S'+FS=>S2' S2'=>M2' M2'=>Pi2' _ IMP S'-Pi3
    <- set`leq-reflexive _ FS<=FS
    <- restore-object-permission/L3
      _ BL1 CML1 FM-DM FS<=FS N+FS=>R R=>MR MR=>PiR
      _ _ ([x] MF1F' x) CNN1 Pi=>PiF2
    <- ({x} make-fperm1-unique (MF1F' x)
         (MF1 x) predmap`eq/ object`eq/ fldmap`eq/ set`eq/ (PEQ x))
    <- restore-object-permission/L4 PML CNN CNN1 PEQ _ T2PF IMP2.

%worlds (objvar) (restore-object-permission _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (C) (restore-object-permission _ _ _ _ C _ _ _ _ _ _).


%theorem nn-leq-implies-permission-leq
  : forall* {PM} {C} {PF2} {NN2} {NN1} {A}
    forall {T2PF: ty2perm PM (ty/ NN2 A C) PF2}
    {NN2<=NN1: nonnull`leq NN1 NN2}
    exists {PF1} {T2PF: ty2perm PM (ty/ NN1 A C) PF1}
    {IMP: {x} implies (PF2 x) (PF1 x)}
    true.

- : nn-leq-implies-permission-leq T2PF
    (nonnull`leq/= nonnull`eq/) _ T2PF ([_] implies/reflexive).

- : nn-leq-implies-permission-leq
    (ty2perm/ PML nn2perm/yes A2AF)
    (nonnull`leq/<) _ (ty2perm/ PML nn2perm/may A2AF)
    ([_] implies/cond-intro-neg).

%worlds (objvar) (nn-leq-implies-permission-leq _ _ _ _ _).
%total { } (nn-leq-implies-permission-leq _ _ _ _ _).


%theorem nn-leq-implies-permission-leq*
  : forall* {PM} {C} {PF1} {PF2} {NN2} {NN1} {A}
    forall {T2PF: ty2perm PM (ty/ NN2 A C) PF2}
    {NN2<=NN1: nonnull`leq NN1 NN2}
    {T2PF: ty2perm PM (ty/ NN1 A C) PF1}
    exists {IMP: {x} implies (PF2 x) (PF1 x)}
    true.

- : nn-leq-implies-permission-leq* T2PF2 LE T2PF
    ([x] implies/trans (IMP' x) (implies/equiv (PEQV x)))
    <- nn-leq-implies-permission-leq T2PF2 LE _ T2PF' IMP'
    <- ty2perm-deterministic T2PF' T2PF predmap`eq/ ty`eq/ PEF
    <- ({x} permission`eq-implies-equiv (PEF x) (PEQV x)).

%worlds (objvar) (nn-leq-implies-permission-leq* _ _ _ _).
%total { } (nn-leq-implies-permission-leq* _ _ _ _).


%theorem set-all-permissions-implies
  : forall* {S} {Pi} {GF} {O} {B} {PM} {C} {NN}
    forall {N} {_: set`size S (s N)}
    {_: set-all-permissions PM B C S Pi} {S=>G: set2facts B O S GF}
    {_: nn-all-less-than B S NN}
    exists {PF} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    {Pi2} {_: implies (unitperm (nonlinear GF) , Pi) (PF O , Pi2)}
    true.

% - : set-all-permissions-implies
%     (s N) SZ
%     (set-all-permissions/U S'=>Pi' N!<S'
%       S'+N=S (BL: cxt`lookup _ _ (cxt-info/ O _)) T2PF2)
%     S=>GF MN-NN _ T2PF3 _
%     (implies/trans6
%       (implies/combine
%         (implies/trans (implies/nonlinear GF=>E+GF')
%           (implies/disj2cond))
%         (implies/reflexive))
%       (implies/equiv equiv/commute)
%       (implies/cond-push)
%       (implies/cond-gen-inner)
%       (implies/cond-inner
%         (bimplies/reflexive)
%         (bimplies/reflexive)
%         (implies/trans4
%           (implies/combine
%             (implies/nonlinear
%               (bimplies/objequal-symmetric))
%             (implies/equiv equiv/identity))
%           (implies/combine implies/reflexive
%             (implies/combine (IMP2 O) implies/reflexive))
%           (implies/equiv equiv/associate)
%           (implies/combine (implies/objequal ([x] PF x)) implies/reflexive))
%         (implies/trans4
%           (implies/equiv equiv/commute)
%           (implies/combine
%             (implies/trans4
%               (implies/equiv equiv/commute)
%               (implies/equiv equiv/reorder)
%               (implies/combine implies/reflexive
%                 (IMP))
%               (implies/equiv equiv/reorder))
%             (implies/reflexive))
%           (implies/equiv (equiv/symmetric equiv/associate))
%           (implies/combine (implies/equiv (EQV O)) implies/reflexive)))
%       (implies/cond-pull)).
%     <- set2facts/U-inversion S=>GF N!<S' S'+N=S GF' S'=>GF' _ _ BL2 GF=>E+GF' _
%     <- nn-all-less-than/U-inversion MN-NN N!<S' S'+N=S _ _ _ BL' LE MN-NN'
%     <- set`not-member-add-increases-size-converse SZ N!<S' S'+N=S SZ'
%     <- set-all-permissions-implies N SZ' S'=>Pi' S'=>GF' MN-NN' _ T2PF _ IMP.
%     <- cxt`lookup-unique BL' BL cxt`eq/ nat`eq/ CIE
%     <- cxt-info-eq-inversion CIE _ TE
%     <- ty-eq-inversion TE NNE _ CE
%     <- nonnull`leq-respects-eq LE nonnull`eq/ NNE LE'
%     <- nn-leq-implies-permission-leq T2PF2 LE' _ (T2PF3:ty2perm _ _ PF) IMP2
%     <- ty2perm-deterministic T2PF T2PF3 predmap`eq/ ty`eq/ PEF
%     <- ({x} permission`eq-implies-equiv (PEF x) (EQV x)).

% - : set-all-permissions-implies z SZ
%     (set-all-permissions/U (S=>Pi:set-all-permissions PM B C S' Pi)
%       (F:set`not-member _ W) U BL T2PF) S=>GF
%     (MN-NN:nn-all-less-than B S NN) _ (T2PF2:ty2perm _ _ PF)
%     _ (implies/trans4
%         (implies/combine
%           (implies/nonlinear BIMP)
%           (implies/trans
%             (implies/combine implies/reflexive (implies/equiv EQV))
%             (implies/equiv equiv/identity)))
%         (implies/combine
%           (implies/nonlinear
%             (bimplies/trans
%               (bimplies/neg
%                 (bimplies/trans
%                   (bimplies/conj/XX
%                     (bimplies/reflexive)
%                     (bimplies/trans
%                       (bimplies/neg (BIMP2) bool`ne/TF)
%                       (bimplies/rem-negneg)))
%                   (bimplies/conj-true))
%                 (bool`ne/FT))
%               (bimplies/trans
%                 (bimplies/rem-negneg)
%                 (bimplies/objequal-symmetric))))
%           (IMP (object/ W)))
%         (implies/objequal ([x] PF x))
%         (implies/equiv (equiv/symmetric equiv/identity)))
%     <- set`not-member-update-increases-size-converse
%       SZ F U SZ'
%     <- set`size-zero-implies-empty SZ' S=0
%     <- set-all-permissions-equiv S=>Pi set-all-permissions/0 S=0 EQV
%     <- set2facts/U-inversion S=>GF F U _ S'=>GF' BIMP _
%     <- set2facts-bimplies S'=>GF' set2facts/0 object`eq/ S=0 BIMP2 _
%     <- set`eq-symmetric S=0 E=S
%     <- nn-all-less-than/U-inversion MN-NN F U _ _ _ BL' LE _
%     <- cxt`lookup-unique BL' BL cxt`eq/ object`eq/ TE
%     <- ty-eq-inversion TE NNE _ CE
%     <- nonnull`leq-respects-eq LE nonnull`eq/ NNE LE'
%     <- nn-leq-implies-permission-leq T2PF LE' _ T2PF2 IMP.

%worlds (objvar) (set-all-permissions-implies _ _ _ _ _ _ _ _ _).
%trustme %total (N) (set-all-permissions-implies N _ _ _ _ _ _ _ _).


%theorem set-all-permissions-implies*
  : forall* {PM} {S} {Pi} {GF} {O} {B} {NN} {C} {PF}
    forall {N} {_: set`size S (s N)}
    {_: set-all-permissions PM B C S Pi} {S=>G: set2facts B O S GF}
    {_: nn-all-less-than B S NN} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    exists {Pi2} {_: implies (unitperm (nonlinear GF) , Pi) (PF O , Pi2)}
    true.

- : set-all-permissions-implies* _ SZ SAP (S2GF:set2facts _ O _ _) FLN T2PF _
    (implies/trans IMP'
      (implies/combine (implies/equiv (EQV O)) implies/reflexive))
    <- set-all-permissions-implies _ SZ SAP S2GF FLN _ T2PF' _ IMP'
    <- ty2perm-deterministic T2PF' T2PF predmap`eq/ ty`eq/ PEF
    <- ({x} permission`eq-implies-equiv (PEF x) (EQV x)).

%worlds (objvar) (set-all-permissions-implies* _ _ _ _ _ _ _ _).
%total { } (set-all-permissions-implies* _ _ _ _ _ _ _ _).


%theorem make-before-write-format/L1
  : forall* {XX} {XX'} {XXc} {Q}
    forall {XX<=XX': effects-leq-no-consume XX XX'}
    {TC: transfer-consume XX' XX XXc Q}
    exists {XX'=XXc: effects`eq XX' XXc} {QE: set`eq Q set/0}
    true.

- : make-before-write-format/L1
    (effects-leq-no-consume/ M<=M')
    (transfer-consume/ _ _ S/S=S1 Q/Q=Q1 S1=>M3 M'+M3=M2) XXE Q1=0
    <- set`leq-reflexive _ S<=S
    <- set`leq-reflexive _ Q<=Q
    <- set`leq-implies-remove-all S<=S S/S=0
    <- set`leq-implies-remove-all Q<=Q Q/Q=0
    <- set`remove-unique S/S=S1 S/S=0 set`eq/ set`eq/ S1=0
    <- set`remove-unique Q/Q=Q1 Q/Q=0 set`eq/ set`eq/ Q1=0
    <- set2efxmap-unique S1=>M3 set2efxmap/0 S1=0 efx`eq/ M3=0
    <- efxmap`join-unique M'+M3=M2 efxmap`join/R efxmap`eq/ M3=0 M2=M'
    <- efxmap`eq-symmetric M2=M' M'=M2
    <- effects/-preserves-eq M'=M2 set`eq/ set`eq/ XXE.

%worlds (objvar) (make-before-write-format/L1 _ _ _ _).
%total {} (make-before-write-format/L1 _ _ _ _).


%theorem make-before-write-format/L2
  : forall* {Cs} {S1} {S}
    forall {T: set+set2set set/0 Cs S1}
    {U: set`union set/0 S1 S}
    exists {E: set`eq S set/0}
    true.

- : make-before-write-format/L2 E+Cs=S1 E+S1=S S=0
    <- set+set2set-on-empty-set E+Cs=0
    <- set+set2set-unique E+Cs=S1 E+Cs=0 set`eq/ set`eq/ S1=0
    <- set`union-unique E+S1=S set`union/L set`eq/ S1=0 S=0.

%worlds (objvar) (make-before-write-format/L2 _ _ _).
%total {} (make-before-write-format/L2 _ _ _).


%theorem make-before-write-format/L3
  : forall* {M1} {S1} {Q1} {M2} {S2} {Q2} {Q3}
    {M} {S} {Q} {M'} {Mc} {CM} {B} {Sc} {Qc}
    forall {CM-B-XX': clsmap-cxt-effects CM B (effects/ M' S Q)}
    {XX1+XX2=XX: effects`join (effects/ M1 S1 Q1) (effects/ M2 S2 Q2)
               (effects/ M S Q)}
    {XX<=XX': effects-leq-no-consume (effects/ M S Q) (effects/ M' S Q)}
    {XX'+XX1=>XXc+Q: transfer-consume
                     (effects/ M' S Q) (effects/ M1 S1 Q1)
                     (effects/ Mc Sc Qc) Q3}
    exists {Mk} {S2=>Mk: set2efxmap S2 efx/write Mk}
    {M'^Mk: efxmap`disjoint M' Mk}
    {M'+Mk=Mc: efxmap`join M' Mk Mc}
    {QE: set`eq Q3 Q2} {E: set`eq Sc S1} {E: set`eq Qc Q1}
    true.

- : make-before-write-format/L3
    (clsmap-cxt-effects/ DM-M'=R' R'^S _ _ _ _)
    (effects`join/ _ _ _ _ _ S1^S2 RM RS M1'+M2=M S1+S2=S Q1^Q2 Q1+Q2=Q)
    (effects-leq-no-consume/ M<=M')
    (transfer-consume/ S1<=S Q1<=Q
      S/S1=S2' Q/Q1=Q3 S2'=>M3 M'+M3=Mc) M3 S2=>M3 M'^M3 M'+M3=Mc Q3=Q2
    set`eq/ set`eq/
    <- set`union-commutative S1+S2=S S2+S1=S
    <- set`disjoint-symmetric S1^S2 S2^S1
    <- set`union-commutative Q1+Q2=Q Q2+Q1=Q
    <- set`disjoint-symmetric Q1^Q2 Q2^Q1
    <- set`disjoint-union-implies-remove S2+S1=S S2^S1 S/S1=S2
    <- set`disjoint-union-implies-remove Q2+Q1=Q Q2^Q1 Q/Q1=Q2
    <- set`remove-unique S/S1=S2' S/S1=S2 set`eq/ set`eq/ S2'=S2
    <- set`remove-unique Q/Q1=Q3 Q/Q1=Q2 set`eq/ set`eq/ Q3=Q2
    <- set2efxmap-respects-eq S2'=>M3 S2'=S2 efx`eq/ efxmap`eq/ S2=>M3
    <- set`leq-reflexive _ R'<=R'
    <- set`remove-implies-leq S/S1=S2 S2<=S
    <- set`disjoint-respects-geq R'^S R'<=R' S2<=S R'^S2
    <- set2efxmap-implies-domain S2=>M3 DM-M3=S2
    <- efxmap`domain-preserves-disjoint-converse R'^S2 DM-M'=R' DM-M3=S2 M'^M3.

%worlds (objvar) (make-before-write-format/L3 _ _ _ _ _ _ _ _ _ _ _).
%total { } (make-before-write-format/L3 _ _ _ _ _ _ _ _ _ _ _).


%theorem make-before-write-format/L4
  : forall* {NN} {C} {PM} {PF} {PF3}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {_: consider-nn ([x] (obj-ne-null x) , (allperm x)) NN PF3}
    exists {PF2} {IMP: {x} implies (PF3 x , (PF x)) (PF2 x)}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) PF2}
    true.

- : make-before-write-format/L4
    (ty2perm/ PML nn2perm/yes annot2perm/borrow) consider-nn/yes _
   ([r] implies/trans4
     (implies/equiv
       (equiv/transitive
         (equiv/symmetric equiv/associate)
         (equiv/combine equiv/reflexive
           (equiv/transitive4
             (equiv/roll3)
             (equiv/combine
               (equiv/reflexive)
               (equiv/reorder))
             (equiv/commute)
             (equiv/identity)))))
     (implies/combine
       (implies/trans
         (implies/nonlinear bimplies/tt)
         (implies/true2empty))
       (implies/reflexive))
     (implies/equiv equiv/commute)
     (implies/equiv equiv/identity))
    (ty2perm/ PML nn2perm/yes annot2perm/unique).

- : make-before-write-format/L4
    (ty2perm/ PML nn2perm/may annot2perm/borrow) consider-nn/may _
    ([x] implies/trans
      (implies/cond-factor)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/identity)
        (implies/trans4
          (implies/combine implies/reflexive
            (implies/equiv
              (equiv/transitive equiv/commute equiv/identity)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/nonlinear2empty implies/reflexive)
          (implies/equiv
            (equiv/transitive equiv/commute equiv/identity)))))
    (ty2perm/ PML nn2perm/may annot2perm/unique).

%worlds (objvar) (make-before-write-format/L4 _ _ _ _ _).
%total { } (make-before-write-format/L4 _ _ _ _ _).


%theorem make-before-write-format/L5
  : forall* {NN} {C} {PM} {PF}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    exists {IMP: {x} implies (PF x) empty}
    true.

- : make-before-write-format/L5
    (ty2perm/ _ nn2perm/yes annot2perm/borrow)
    ([_] implies/trans
      (implies/combine
        implies/nonlinear2empty
        (implies/trans
          (implies/combine implies/reflexive
            implies/nonlinear2empty)
          (implies/equiv equiv/identity)))
      (implies/equiv equiv/identity)).

- : make-before-write-format/L5
    (ty2perm/ _ nn2perm/may annot2perm/borrow)
    ([x] implies/trans
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/trans
            (implies/combine implies/reflexive
              (implies/nonlinear2empty))
            (implies/equiv equiv/identity)))
        (implies/cond-equal)).

%worlds (objvar) (make-before-write-format/L5 _ _).
%total { } (make-before-write-format/L5 _ _).


% don't need to handle effects2output/unique/0t since cannot consume shared
% TODO: make sense to loose this restriction?

%theorem make-before-write-format/L6
  : forall* {Q} {PF:object -> permission}
    forall {QE: rat`eq Q one}
    exists {EQV: {x} equiv (scale (fraction/ Q) (PF x)) (PF x)}
    true.

- : make-before-write-format/L6 rat`eq/ ([_] equiv/one).

%worlds (objvar) (make-before-write-format/L6 _ _).
%total { } (make-before-write-format/L6 _ _).


%theorem make-before-write-format/L7
  : forall* {PM} {B} {S} {C} {Pi} {NN} {GF} {PF}
    forall {N} {SZ: set`size S N}
    {SAP: set-all-permissions PM B C S Pi}
    {FLN: nn-all-less-than B S NN}
    {G=>GF: {x} set2facts B x S (GF x)}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    exists {Pi2}
    {IMP: {x}{o} implies (combine (Pi , (PF o))
                           (unitperm (nonlinear (disj (objequal x o) (GF x)))))
          (combine (PF x) (Pi2 x o))}
    true.

- : make-before-write-format/L7 z _ set-all-permissions/0
    nn-all-less-than/0 ([_] set2facts/0) (T2PF:ty2perm _ _ PF) _
    ([x][o] implies/trans4
      (implies/combine
        (implies/equiv (equiv/transitive equiv/commute equiv/identity))
        (implies/trans (implies/nonlinear (disj-to-objequal x o))
          (implies/nonlinear bimplies/objequal-symmetric)))
      (implies/equiv equiv/commute)
      (implies/objequal ([x] PF x))
      (implies/equiv (equiv/symmetric equiv/identity))).

- : make-before-write-format/L7 (s _) SZ SAP MN G=>GF T2PF _
    ([x][o] implies/trans4
      (implies/combine (implies/equiv equiv/commute)
        (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive
        (implies/trans3
          (implies/combine implies/reflexive implies/disj2cond)
          (implies/cond-push)
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/equiv equiv/identity)
            (implies/trans
              (implies/equiv equiv/commute)
              (IMP2 x)))))
      (implies/trans4
        (implies/cond-push)
        (implies/cond-gen-inner)
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/trans3
            (implies/combine
              (implies/nonlinear bimplies/objequal-symmetric)
              (implies/reflexive))
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/objequal ([x] PF x))
              (implies/reflexive)))
          (implies/equiv equiv/roll3))
        (implies/cond-pull)))
    <- ({r} set-all-permissions-implies* _ SZ SAP (G=>GF r) MN T2PF _ (IMP2 r)).

%worlds () (make-before-write-format/L7 _ _ _ _ _ _ _ _).
%total (N) (make-before-write-format/L7 N _ _ _ _ _ _ _).


%theorem make-before-write-format/shared
  : forall* {CM} {PM} {B} {NN1} {C1} {NN} {FC} {XX1} {XX2} {XX} {XX'}
    {XXc} {Q} {Out} {PiQ} {A}
    forall {CM-B-RT: clsmap-cxt-reftype CM B (reftype/ NN1 C1 targets/shared)}
    {SUB: subtype CM (reftype/ NN1 C1 targets/shared) (ty/ NN A FC) efxmap/0 XX2}
    {NOT-B: not-borrowed A} %% field type should either be unique or shared.
    {J: effects`join XX1 XX2 XX}
    {CM-B-XX': clsmap-cxt-effects CM B XX'}
    {XX<=XX': effects-leq-no-consume XX XX'}
    {TC: transfer-consume XX' XX1 XXc Q}
    {XXc=>Out: effects2output CM PM B (reftype/ NN1 C1 targets/shared) XXc Out}
    {Q=>PiQ: make-fperm CM PM B Q PiQ}
    exists {Out'} {Out''} {EA: envadd PiQ Out Out'}
    {TRANS: transform Out' Out''}
    {BWF: before-write-format CM PM B (reftype/ NN1 C1 targets/shared) XX' Out''}
    true.

- : make-before-write-format/shared _
    (subtype/ (sub-annot-efx/shared2shared) _ _ _ _ _ nat`eq/) _
    J _ XX<=XX' XX'+XX1=>XXc+Q
    (effects2output/simple T2PF reftype2ty/shared
      simple-targets/shared Mc=>Pi2 B=>Pi1)
    Q=>PiQ %{=>}% _ _ (envadd/exists [r] (envadd/expr))
    (transform/inside [r]
      (transform/implies
        (implies/equiv
          (equiv/transitive3
            (equiv/commute)
            (equiv/combine equiv/reflexive PiQ<=>E)
            (equiv/identity)))))
    (before-write-format/ T2PF reftype2ty/shared M'=>Pi2 B=>Pi1)
    <- effects`join-right-empty-no-change J XX1=XX
    <- transfer-consume-respects-eq XX'+XX1=>XXc+Q
      effects`eq/ XX1=XX effects`eq/ set`eq/ XX'+XX=>XXc+Q
    <- make-before-write-format/L1 XX<=XX' XX'+XX=>XXc+Q XX'=XXc Q=0
    <- make-fperm-unique Q=>PiQ make-fperm/0
      clsmap`eq/ predmap`eq/ cxt`eq/ Q=0 PiQ=E
    <- effects`eq-symmetric XX'=XXc XXc=XX'
    <- effects`eq-inversion XXc=XX' Mc=M' Sc=S' Qc=Q'
    <- efxmap2perm-respects-eq Mc=>Pi2 clsmap`eq/ predmap`eq/ cxt`eq/
      Mc=M' permission`eq/ M'=>Pi2
    <- permission`eq-implies-equiv PiQ=E PiQ<=>E.

%worlds (objvar) (make-before-write-format/shared _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (make-before-write-format/shared _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem make-before-write-format/unique
  : forall* {CM} {PM} {B} {NN1} {C1} {NN} {FC} {XX1} {XX2} {XX} {XX'}
    {XXc} {Q} {Out} {PiQ} {S1} {S2} {A}
    forall {CM2PM: clsmap2predmap CM PM}
    {CM-B-RT: clsmap-cxt-reftype CM B (reftype/ NN1 C1 (targets/unique S1 S2))}
    {SUB: subtype CM (reftype/ NN1 C1 (targets/unique S1 S2))
          (ty/ NN A FC) efxmap/0 XX2}
    {N1} {SZ1: set`size S1 N1} {N2} {SZ2: set`size S2 N2}
    {NOT-B: not-borrowed A} %% field should either be unique or shared.
    {J: effects`join XX1 XX2 XX}
    {CM-B-XX': clsmap-cxt-effects CM B XX'}
    {XX<=XX': effects-leq-no-consume XX XX'}
    {TC: transfer-consume XX' XX1 XXc Q}
    {XXc=>Out: effects2output CM PM B
               (reftype/ NN1 C1 (targets/unique S1 S2)) XXc Out}
    {Q=>PiQ: make-fperm CM PM B Q PiQ}
    exists {Out'} {Out''} {EA: envadd PiQ Out Out'}
    {TRANS: transform Out' Out''}
    {BWF: before-write-format CM PM B (reftype/ NN1 C1
                                (targets/unique S1 S2)) XX' Out''}
    true.

- : make-before-write-format/unique CM2PM
    (clsmap-cxt-reftype/unique SOC FLN _ _)
    (subtype/ (sub-annot-efx/consume
                (G2+G1'=G:set`union G2 G1' G)
                (G2^G1':set`disjoint G2 G1')
                (G1+FS=>G1':set+set2set G1 FS G1') _)
      _ _ DM-FM=FS CML _ nat`eq/) _ SZ-G1 (s _) SZ-G2
    _ XX1+XX2=XX CM-B-XX' XX<=XX' XX'+XX1=>XXc+Q
    (effects2output/unique/+f (T2PF:ty2perm _ _ PF) X2Q MX-Mc2=X
      Mc2=>Pi22 Mc1=>Pi21
      (Mc|G2=Mc1+Mc2:efxmap`partition Mc G2 Mc1 Mc2)
      ([x] G1=>GF x) B=>Pi1 SZ-G2')
    (Q=>PiQ:make-fperm CM PM B Q PiQ) %{=>}% _ _
    (envadd/exists [o] (envadd/exists [r] envadd/expr))
    (transform/inside [x]
      (transform/trans
        (transform/inside [o]
          (transform/trans
            (transform/implies
              (implies/trans11
                (implies/combine implies/reflexive % PiQ
                  (implies/combine implies/reflexive % PiB
                    (implies/combine implies/reflexive % x!=0 \/ G(x)
                      (implies/combine implies/reflexive % PF
                        (implies/combine implies/reflexive % PF --+- Pi22
                          (implies/equiv
                            (equiv/transitive
                              (Pi21<=>Pi211+Pi212)
                              (equiv/commute))))))))
                (implies/equiv equiv/roll6)
                (implies/equiv equiv/associate)
                (implies/combine IMP implies/reflexive)
                (implies/combine implies/reflexive
                  (implies/equiv equiv/reorder))
                (implies/equiv equiv/associate)
                (implies/combine implies/reflexive (implies/equiv equiv/reorder))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans
                    (implies/combine implies/reflexive
                      (implies/equiv (EQV o)))
                    (implies/equiv equiv/swap))
                  implies/reflexive)
                (implies/combine
                  (implies/trans (IMP2 x o) (implies/equiv equiv/commute))
                  implies/reflexive)
                (implies/trans4
                  (implies/equiv (equiv/symmetric equiv/associate))
                  (implies/combine implies/reflexive (implies/equiv equiv/roll3))
                  (implies/equiv equiv/associate)
                  (implies/combine
                    (implies/reflexive)
                    (implies/equiv equiv/reorder)))))
            (transform/drop)))
        (transform/rem-unused)))
    (before-write-format/ T2PF reftype2ty/unique M'=>Pi211 B=>Pi1)
    <- make-before-write-format/L3 CM-B-XX' XX1+XX2=XX XX<=XX' XX'+XX1=>XXc+Q
      Mk G=>Mk M'^Mk M'+Mk=Mc (Q=G1:set`eq Q G1) _ _
    <- make-fperm-respects-eq Q=>PiQ clsmap`eq/ predmap`eq/ cxt`eq/
      Q=G1 permission`eq/ (G1=>PiQ:make-fperm CM PM B G1 PiQ)
    <- set2efxmap-preserves-disjoint-join G=>Mk G2^G1' G2+G1'=G Mk2 Mk1'
      G2=>Mk2 G1'=>Mk1' Mk2^Mk1' Mk2+Mk1'=Mk
    <- efxmap`disjoint-symmetric Mk2^Mk1' Mk1'^Mk2
    <- efxmap`join-commutative Mk2+Mk1'=Mk Mk1'+Mk2=Mk
    <- efxmap`join-associative-converse Mk1'+Mk2=Mk M'+Mk=Mc Mu
      M'+Mk1'=Mu Mu+Mk2=Mc
    <- efxmap`disjoint-symmetric M'^Mk Mk^M'
    <- efxmap`join-preserves-disjoint-converse Mk^M' Mk1'+Mk2=Mk Mk1'^M' Mk2^M'
    <- efxmap`disjoint-symmetric Mk1'^M' M'^Mk1'
    <- efxmap`disjoint-symmetric Mk2^M' M'^Mk2
    <- set2efxmap-implies-domain G2=>Mk2 (DM-Mk2=G2:efxmap`domain Mk2 G2)
    <- efxmap`join-preserves-disjoint* M'^Mk2 Mk1'^Mk2 M'+Mk1'=Mu Mu^Mk2
    <- efxmap`disjoint-join-right-domain-implies-partition
      DM-Mk2=G2 Mu^Mk2 Mu+Mk2=Mc Mc|G2=Mu+Mk2
    <- efxmap`partition-unique Mc|G2=Mc1+Mc2 Mc|G2=Mu+Mk2
      efxmap`eq/ set`eq/ Mc1=Mu Mc2=Mk2
    <- efxmap`eq-symmetric Mc1=Mu Mu=Mc1
    <- efxmap`eq-symmetric Mc2=Mk2 Mk2=Mc2
    <- efxmap`join-respects-eq M'+Mk1'=Mu efxmap`eq/ efxmap`eq/ Mu=Mc1
      M'+Mk1'=Mc1
    <- efxmap`disjoint-join-implies-equiv M'^Mk1' M'+Mk1'=Mc1 Mc1=>Pi21
      Pi211 Pi212 M'=>Pi211 Mk1'=>Pi212 Pi21<=>Pi211+Pi212
    <- restore-object-permission SOC CM2PM CML DM-FM=FS G1=>PiQ
      G1+FS=>G1' G1'=>Mk1' Mk1'=>Pi212 Pi3 IMP (SAP:set-all-permissions PM B C G1 Pi3)
    <- set2efxmap-respects-eq G2=>Mk2 set`eq/ efx`eq/ Mk2=Mc2 G2=>Mc2
    <- set2efxmap-implies-efxmap-min-efx _ SZ-G2 G2=>Mc2 MX-Mc2=W
    <- efxmap-min-efx-unique MX-Mc2=X MX-Mc2=W efx`eq/ efxmap`eq/ X=W
    <- efx2frac-unique X2Q efx2frac/write X=W Q=1
    <- make-before-write-format/L6 Q=1 ([x] EQV x)
    <- make-before-write-format/L7 _ SZ-G1 SAP FLN G1=>GF T2PF _ ([x][o] IMP2 x o).

- : make-before-write-format/unique _ CM2PM
    (subtype/ (sub-annot-efx/consume U _ T _) _ _ _ _ _ nat`eq/)
    z _ z _ _ XX1+XX2=XX _ XX<=XX' XX'+XX1=>XXc+Q
    (effects2output/simple T2PF reftype2ty/unique simple-targets/unique
      Mc=>Pi2 B=>Pi1)
    Q=>PiQ %{=>}% _ _ (envadd/exists [r] (envadd/expr))
    (transform/inside [r]
      (transform/implies
        (implies/equiv
          (equiv/transitive3
            (equiv/commute)
            (equiv/combine equiv/reflexive PiQ<=>E)
            (equiv/identity)))))
    (before-write-format/ T2PF reftype2ty/unique M'=>Pi2 B=>Pi1)
    <- set+set2set-on-empty-set T'
    <- set+set2set-unique T T' set`eq/ set`eq/ S1=0
    <- set`union-unique U set`union/L set`eq/ S1=0 S=0
    <- effects/-preserves-eq efxmap`eq/ S=0 set`eq/ XX2=0
    <- effects`join-respects-eq XX1+XX2=XX effects`eq/ XX2=0 effects`eq/ J
    <- effects`join-right-empty-no-change J XX1=XX
    <- transfer-consume-respects-eq XX'+XX1=>XXc+Q
      effects`eq/ XX1=XX effects`eq/ set`eq/ XX'+XX=>XXc+Q
    <- make-before-write-format/L1 XX<=XX' XX'+XX=>XXc+Q XX'=XXc Q=0
    <- make-fperm-unique Q=>PiQ make-fperm/0 clsmap`eq/ predmap`eq/
      cxt`eq/ Q=0 PiQ=E
    <- effects`eq-symmetric XX'=XXc XXc=XX'
    <- effects`eq-inversion XXc=XX' Mc=M' Sc=S' Qc=Q'
    <- efxmap2perm-respects-eq Mc=>Pi2 clsmap`eq/ predmap`eq/ cxt`eq/
      Mc=M' permission`eq/ M'=>Pi2
    <- permission`eq-implies-equiv PiQ=E PiQ<=>E.

- : make-before-write-format/unique CM2PM
    (clsmap-cxt-reftype/unique SOC MN-NN CM-B-S _)
    (subtype/ (sub-annot-efx/consume (U:set`union set/0 S2 S4) _
                (S+FS=>S2:set+set2set S FS S2) _) _ _
      (DM-FM:fldmap`domain FM FS)
      (CML:clsmap`lookup CM C FM) _ nat`eq/) (s _) Z z _
    _ XX1+XX2=XX CM-B-XX' XX<=XX' XX'+XX1=>XXc+Q
    (effects2output/unique/0f
      T2PF (Mc=>Pi2:efxmap2perm CM PM B Mc Pi2)
      ([r] S=>GF r) B=>Pi1 set`size/0 (Z':set`size S (s SN')))
    (Q=>PiQ:make-fperm CM PM B Q PiQ) %{=>}% _ _ (envadd/exists [r] (envadd/expr))
    (transform/inside [x]
      (transform/trans
        (transform/implies
          (implies/trans11
            (implies/trans
              (implies/combine
                (implies/reflexive)
                (implies/combine
                  (implies/reflexive)
                  (implies/combine
                    (implies/reflexive)
                    (implies/combine
                      (implies/reflexive)
                      (implies/equiv (equiv/symmetric equiv/identity))))))
              (implies/combine implies/reflexive
                (implies/equiv equiv/roll4)))
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/trans3
                (implies/combine implies/reflexive
                  (implies/equiv
                    (equiv/transitive
                      (Pi2<=>Pi'+Pik)
                      (equiv/commute))))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans (implies/equiv equiv/commute) IMP)
                  (implies/reflexive)))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv equiv/roll4))
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/trans3
                (implies/equiv equiv/commute)
                (IMP2 x)
                (implies/combine
                  (implies/equiv (EQV x x))
                  (implies/reflexive)))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive (implies/equiv equiv/roll4))
            (implies/equiv equiv/associate)
            (implies/trans4
              (implies/combine
                (implies/trans
                  (implies/combine implies/reflexive (IMP4 x))
                  (implies/equiv equiv/identity))
                implies/reflexive)
              (implies/equiv equiv/reorder)
              (implies/combine implies/reflexive (implies/equiv equiv/roll3))
              (implies/combine
                (implies/reflexive)
                (implies/combine
                  (implies/reflexive)
                  (implies/combine
                    (implies/reflexive)
                    (implies/equiv equiv/identity)))))))
        (transform/drop)))
    (before-write-format/ T2PF2 reftype2ty/unique M'=>Pi' B=>Pi1)
    <- make-before-write-format/L3 CM-B-XX' XX1+XX2=XX XX<=XX' XX'+XX1=>XXc+Q
      Mk S4=>Mk M'^Mk M'+Mk=Mc (Q=S:set`eq Q S)
      (Sc=S1:set`eq Sc S1) (Qc=Q1:set`eq Qc Q1)
    <- make-fperm-respects-eq Q=>PiQ clsmap`eq/ predmap`eq/ cxt`eq/
      Q=S permission`eq/ (S=>PiQ:make-fperm CM PM B S PiQ)
    <- efxmap`disjoint-join-implies-equiv M'^Mk M'+Mk=Mc Mc=>Pi2
      Pi' Pik M'=>Pi' Mk=>Pik (Pi2<=>Pi'+Pik:equiv Pi2 (Pi' , Pik))
    <- set`union-unique U set`union/L set`eq/ set`eq/ S4=S2
    <- set2efxmap-respects-eq S4=>Mk S4=S2 efx`eq/ efxmap`eq/ S2=>Mk
    <- restore-object-permission (SOC:same-class B S C) CM2PM CML DM-FM S=>PiQ
      S+FS=>S2 S2=>Mk Mk=>Pik Pi3 IMP (SAP:set-all-permissions PM B C S Pi3)
    <- ({r} set-all-permissions-implies SN (Z:set`size S (s SN))
         (SAP:set-all-permissions PM B C S _) (S=>GF r) MN-NN _
         (T2PFF r) _ (IMP2 r))
    <- ty2perm-no-var T2PFF _ ([r][o] EQF r o) T2PF2
    <- ({r}{o} permission`eq-implies-equiv (EQF r o) (EQV r o))
    <- make-before-write-format/L5 T2PF IMP4.

%worlds () (make-before-write-format/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (make-before-write-format/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem make-before-write-format
  : forall* {CM} {PM} {B} {NN1} {C1} {NN} {FC} {XX1} {XX2} {XX} {XX'}
    {XXc} {Q} {Out} {PiQ} {A} {GS}
    forall {CM2PM: clsmap2predmap CM PM}
    {CM-B-RT: clsmap-cxt-reftype CM B (reftype/ NN1 C1 GS)}
    {SUB: subtype CM (reftype/ NN1 C1 GS) (ty/ NN A FC) efxmap/0 XX2}
    {NOT-B: not-borrowed A} % field should either be unique or shared.
    {J: effects`join XX1 XX2 XX}
    {CM-B-XX': clsmap-cxt-effects CM B XX'}
    {XX<=XX': effects-leq-no-consume XX XX'}
    {TC: transfer-consume XX' XX1 XXc Q}
    {XXc=>Out: effects2output CM PM B (reftype/ NN1 C1 GS) XXc Out}
    {Q=>PiQ: make-fperm CM PM B Q PiQ}
    exists {Out'} {Out''} {EA: envadd PiQ Out Out'}
    {TRANS: transform Out' Out''}
    {BWF: before-write-format CM PM B (reftype/ NN1 C1 GS) XX' Out''}
    true.

- : make-before-write-format CM2PM CM-B-RT SUB NB XX1+XX2=XX CM-B-XX' XX<=XX'
    XX'+XX1=>XXc+Q XXc=>Out Q=>PiQ _ _ EA TRANS BWF
    <- make-before-write-format/shared CM-B-RT SUB NB XX1+XX2=XX CM-B-XX' XX<=XX'
      XX'+XX1=>XXc+Q XXc=>Out Q=>PiQ _ _ EA TRANS BWF.

- : make-before-write-format CM2PM CM-B-RT SUB NB XX1+XX2=XX CM-B-XX' XX<=XX'
    XX'+XX1=>XXc+Q XXc=>Out Q=>PiQ _ _ EA TRANS BWF
    <- set`size-total SZ1
    <- set`size-total SZ2
    <- make-before-write-format/unique CM2PM CM-B-RT SUB _ SZ1 _ SZ2 NB
      XX1+XX2=XX CM-B-XX' XX<=XX' XX'+XX1=>XXc+Q XXc=>Out Q=>PiQ _ _ EA TRANS BWF.

%worlds () (make-before-write-format _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (make-before-write-format _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem subtype-implies-ty2perm-leq
  : forall* {CM} {PM} {RT} {T1} {PF1} {NN2} {A2} {C2} {XM} {XX}
    forall {SUB: subtype CM RT (ty/ NN2 A2 C2) XM XX}
    {NB: not-borrowed A2}
    {RT=>T: reftype2ty RT T1}
    {T1=>PF1: ty2perm PM T1 PF1}
    exists {PF2} {T2=>PF2: ty2perm PM (ty/ NN2 A2 C2) PF2}
    {IMP: {x} implies (PF1 x) (PF2 x)}
    true.

%worlds () (subtype-implies-ty2perm-leq _ _ _ _ _ _ _).
%trustme %total { } (subtype-implies-ty2perm-leq _ _ _ _ _ _ _).


%theorem subtype-implies-ty2perm-leq*
  : forall* {CM} {PM} {RT} {T1} {PF1} {PF2} {NN2} {A2} {C2} {XM} {XX}
    forall {SUB: subtype CM RT (ty/ NN2 A2 C2) XM XX}
    {NB: not-borrowed A2}
    {RT=>T: reftype2ty RT T1}
    {T1=>PF1: ty2perm PM T1 PF1}
    {T2=>PF2: ty2perm PM (ty/ NN2 A2 C2) PF2}
    exists {IMP: {x} implies (PF1 x) (PF2 x)}
    true.

%worlds () (subtype-implies-ty2perm-leq* _ _ _ _ _ _).
%trustme %total { } (subtype-implies-ty2perm-leq* _ _ _ _ _ _).


%theorem do-write
  : forall* {CM} {PM} {B} {Pi1} {XX} {XX6'} {Pi3} {C} {S} {A}
    {W} {Pi2} {E2} {Out} {GP} {F} {TF} {NN} {FC} {XX4} {C1} {NN1} {GS}
    forall {_: write-intermediate-format CM PM B C
               (targets/unique set/0 S) XX XX6' Pi1 Pi3}
    {SUB: subtype CM (reftype/ NN1 C1 GS) (ty/ NN A FC) efxmap/0 XX4}
    {T2TF: ty2perm PM (ty/ NN A FC) TF} {NB: not-borrowed A}
    {TYP: typing W Pi2 E2 Out}
    {_: before-write-format CM PM B (reftype/ NN1 C1 GS) XX6' Out}
    {CF: consider-ftype (targets/unique set/0 S) A GP}
    exists {Out'}
    {TYP: {r} typing W
          (combine (unitperm (precise-exists r F TF))
            (combine
              (unitperm
                (encumbered (unitperm (precise-exists r F TF)) (Pi1 r)))
              (combine Pi2 Pi3)))
          (write (lit r) F E2) Out'}
    {XX=>Out: effects2output CM PM B (reftype/ NN FC GP) XX Out'}
    true.

- : do-write
    (write-intermediate-format/+f SZ M|G=M1+M2 M2=>Pi2
      MX-M2=X efx2frac/write rat`eq/
      (DM-M6'=R6':efxmap`domain M6' R6')
      (M1|R6'=M61+M6':partition M1 R6' M61 M6')
      (M61=>Pi3:efxmap2perm CM PM B M61 Pi3))
    SUB T2PF _ TYP-E2
    (before-write-format/ T2PF2
      (RT=>T2:reftype2ty (reftype/ NN1 C1 GS) T) M6'=>Pi6 B=>PiB)
    consider-ftype/unique
    %{=>}% _
    ([r] tTrans
      (transform/implies
        (implies/equiv (equiv/transitive (equiv/roll3) (equiv/commute))))
      (letTyping/base null
        (tWrite2 (TYP-E2' r)
          (letTyping/exists [o]
            (letTyping/base o
              (tTrans
                (transform/trans3
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/symmetric equiv/associate)
                        (equiv/combine (equiv/symmetric equiv/one)
                          (equiv/symmetric equiv/associate)))))
                  (transform/skolem)
                  (transform/inside [o']
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine equiv/one equiv/reflexive)
                          (equiv/symmetric equiv/associate))))))
                (letTyping/exists [o']
                  (letTyping/base null
                    (tWrite: typing _ _ (write (lit r) F (lit o)) _)))
                (transform/trans
                  (transform/inside [o']
                    (transform/trans
                      (transform/implies
                        (implies/trans5
                          (implies/combine
                            (implies/trans3
                              (implies/equiv (equiv/symmetric equiv/identity))
                              (implies/combine
                                (implies/reflexive)
                                (implies/trans
                                  (implies/gen-pack-encumber o)
                                  (implies/combine-assoc-encumbered)))
                              (implies/linear-modus-ponens))
                            (implies/equiv equiv/roll2))
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/chain-implication)
                            (implies/combine
                              (implies/reflexive) % X2
                              (implies/trans3
                                (implies/combine
                                  (implies/reflexive) % Pi3
                                  (implies/trans
                                    (implies/combine
                                      (implies/reflexive) % X6
                                      (implies/equiv equiv/commute))
                                    (implies/equiv equiv/roll2)))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/equiv Pi3+Pi6<=>Pi1)
                                  (implies/reflexive)))))
                          (implies/equiv
                            (equiv/transitive
                              (equiv/roll2)
                              (equiv/combine
                                (equiv/reflexive) % (X2 x2)
                                (equiv/transitive
                                  (equiv/roll3)
                                  (equiv/combine
                                    (equiv/reflexive) % X6
                                    (equiv/transitive
                                      (equiv/combine
                                        (equiv/reflexive)
                                        (equiv/commute))
                                      (equiv/roll2)))))))
                          (implies/combine
                            (implies/reflexive)
                            (implies/combine
                              (implies/reflexive)
                              (implies/trans
                                (implies/combine
                                  (implies/trans3
                                    (implies/equiv (equiv/symmetric equiv/identity))
                                    (implies/equiv equiv/commute)
                                    (implies/combine
                                      (gen-objequal-self o)
                                      (implies/trans
                                        (IMP o)
                                        (implies/equiv (equiv/symmetric equiv/one)))))
                                  (implies/combine
                                    (implies/equiv-encumbered
                                      (equiv/symmetric equiv/one)
                                      (equiv/reflexive))
                                    (implies/reflexive)))
                                (implies/equiv
                                  (equiv/symmetric equiv/associate)))))))
                      (transform/drop)))
                  (transform/rem-unused)))))))
      (transform/inside [o]
        (transform/gen-exists o)))
    (effects2output/unique/+f T2PF efx2frac/write MX-M2=X
      M2=>Pi2 M1=>Pi1 (M|G=M1+M2:partition M G M1 M2)
      ([_] set2facts/0) B=>PiB SZ)
    <- ({o:object} typing-frame* TYP-E2 (envadd/exists [r] envadd/expr) (TYP-E2' o))
    <- efxmap`partition-implies-permission-combine-converse M1|R6'=M61+M6'
      M61=>Pi3 (M6'=>Pi6:efxmap2perm CM PM B M6' Pi6)
      Pi1 M1=>Pi1 (Pi3+Pi6<=>Pi1:equiv (Pi3 , Pi6) Pi1)
    <- efxmap`partition-implies-permission-combine-converse M|G=M1+M2
      (M1=>Pi1:efxmap2perm CM PM B M1 Pi1) (M2=>Pi2:efxmap2perm CM PM B M2 Pi2)
      Pi (M=>Pi:efxmap2perm CM PM B M Pi)
      (Pi1+Pi2<=>Pi:equiv (Pi1 , Pi2) Pi)
    <- subtype-implies-ty2perm-leq* SUB not-borrowed/unique RT=>T2 T2PF2 T2PF IMP.

- : do-write
    (write-intermediate-format/+f SZ M|G=M1+M2 M2=>Pi2
      MX-M2 efx2frac/write rat`eq/ DM-M6'=R6' M1|R6'=M61+M6' M61=>Pi3)
    SUB T2PF _ TYP-E2
    (before-write-format/ T2PF2 RT=>T2 M6'=>Pi6 B=>PiB)
    consider-ftype/shared
    %{=>}% _
    ([r] tTrans
      (transform/implies
        (implies/equiv (equiv/transitive (equiv/roll3) (equiv/commute))))
      (letTyping/base null
        (tWrite2 (TYP-E2' r)
          (letTyping/exists [o]
            (letTyping/base o
              (tTrans
                (transform/trans3
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/symmetric equiv/associate)
                        (equiv/combine (equiv/symmetric equiv/one)
                          (equiv/symmetric equiv/associate)))))
                  (transform/skolem)
                  (transform/inside [o']
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine equiv/one equiv/reflexive)
                          (equiv/symmetric equiv/associate))))))
                (letTyping/exists [o']
                  (letTyping/base null
                    (tWrite: typing _ _ (write (lit r) F (lit o)) _)))
                (transform/trans
                  (transform/inside [o']
                    (transform/trans
                      (transform/implies
                        (implies/trans7
                          (implies/combine implies/reflexive
                            (implies/equiv equiv/roll5))
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/trans3
                              (implies/combine
                                (implies/reflexive)
                                (implies/trans (IMP o) (DUP o)))
                              (implies/equiv equiv/associate)
                              (implies/trans
                                (implies/combine (implies/pack o) implies/reflexive)
                                (implies/equiv equiv/commute)))
                            (implies/reflexive))
                          (implies/equiv (equiv/symmetric equiv/associate))
                          (implies/combine implies/reflexive
                            (implies/trans3
                              (implies/combine implies/reflexive
                                (implies/equiv equiv/roll2))
                              (implies/equiv equiv/associate)
                              (implies/combine implies/linear-modus-ponens
                                (implies/combine implies/reflexive
                                  (implies/trans3
                                    (implies/combine
                                      implies/reflexive
                                      (implies/equiv equiv/commute))
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/equiv Pi3+Pi6<=>Pi1)
                                      (implies/reflexive)))))))
                          (implies/combine implies/reflexive
                            (implies/trans3
                              (implies/combine implies/reflexive
                                (implies/equiv equiv/roll2))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans
                                  (implies/equiv equiv/commute)
                                  (implies/equiv Pi1+Pi2<=>Pi))
                                (implies/reflexive))))
                          (implies/trans
                            (implies/equiv equiv/roll3)
                            (implies/combine
                              (implies/reflexive)
                              (implies/trans
                                (implies/combine
                                  (implies/reflexive)
                                  (implies/equiv equiv/commute))
                                (implies/equiv equiv/roll2))))))
                      (transform/drop)))
                  (transform/rem-unused)))))))
      (transform/reflexive))
    (effects2output/simple T2PF reftype2ty/shared simple-targets/shared
      M=>Pi B=>PiB)
    <- ({o:object} typing-frame* TYP-E2 (envadd/exists [r] envadd/expr) (TYP-E2' o))
    <- efxmap`partition-implies-permission-combine-converse M1|R6'=M61+M6'
      M61=>Pi3 M6'=>Pi6 Pi1 M1=>Pi1 Pi3+Pi6<=>Pi1
    <- efxmap`partition-implies-permission-combine-converse M|G=M1+M2
      M1=>Pi1 M2=>Pi2 Pi M=>Pi Pi1+Pi2<=>Pi
    <- subtype-implies-ty2perm-leq* SUB not-borrowed/shared RT=>T2 T2PF2 T2PF IMP
    <- sharedperm-can-be-duplicated* T2PF DUP.

- : do-write
    (write-intermediate-format/0
      (PML:predmap`lookup PM C CP)
      (DM-M6'=R6:efxmap`domain M6' R6)
      (M|R6=M61+M6':efxmap`partition M R6 M61 M6')
      (M61=>Pi3:efxmap2perm CM PM B M61 Pi3))
    SUB T2PF not-borrowed/shared TYP-E2
    (before-write-format/ (T2PF2:ty2perm PM _ PF2) RT=>T2
      (M6'=>Pi6:efxmap2perm CM PM B M6' Pi6)
      (B=>Pi1:cxt2perm CM PM B PiB))
    consider-ftype/shared %{=>}% _
    ([r] tTrans
      (transform/implies
        (implies/equiv (equiv/transitive (equiv/roll3) (equiv/commute))))
      (letTyping/base null
        (tWrite2 (TYP-E2' r)
          (letTyping/exists [o]
            (letTyping/base o
              (tTrans
                (transform/trans3
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/symmetric equiv/associate)
                        (equiv/combine (equiv/symmetric equiv/one)
                          (equiv/symmetric equiv/associate)))))
                  (transform/skolem)
                  (transform/inside [o']
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine equiv/one equiv/reflexive)
                          (equiv/symmetric equiv/associate))))))
                (letTyping/exists [o']
                  (letTyping/base null
                    (tWrite: typing _ _ (write (lit r) F (lit o)) _)))
                (transform/trans
                  (transform/inside [o']
                    (transform/trans
                      (transform/implies
                        (implies/trans
                          (implies/equiv
                            (equiv/transitive
                              (equiv/associate)
                              (equiv/associate)))
                          (implies/combine
                            (implies/reflexive)
                            (implies/trans
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/roll2)
                                  (equiv/combine equiv/reflexive equiv/roll2)))
                              (implies/combine
                                (implies/reflexive)
                                (implies/combine
                                  (IMP o)
                                  (implies/equiv Pi3+Pi6<=>Pi2)))))))
                      (transform/drop)))
                  (transform/rem-unused)))))))
      (transform/reflexive))
    (effects2output/simple T2PF reftype2ty/shared simple-targets/shared
      M=>Pi2 B=>Pi1)
    <- ({o:object} typing-frame* TYP-E2 (envadd/exists [r] envadd/expr) (TYP-E2' o))
    <- efxmap`partition-implies-permission-combine-converse M|R6=M61+M6'
      M61=>Pi3 M6'=>Pi6 Pi2 (M=>Pi2:efxmap2perm CM PM B M Pi2) Pi3+Pi6<=>Pi2
    <- subtype-implies-ty2perm-leq* SUB not-borrowed/shared RT=>T2 T2PF2 T2PF IMP.

- : do-write
    (write-intermediate-format/0
      (PML:predmap`lookup PM C CP)
      (DM-M6'=R6:efxmap`domain M6' R6)
      (M|R6=M61+M6':efxmap`partition M R6 M61 M6')
      (M61=>Pi3:efxmap2perm CM PM B M61 Pi3))
    SUB T2PF not-borrowed/unique TYP-E2
    (before-write-format/ (T2PF2:ty2perm PM _ PF2) RT=>T2
      (M6'=>Pi6:efxmap2perm CM PM B M6' Pi6)
      (B=>Pi1:cxt2perm CM PM B PiB))
    consider-ftype/unique %{=>}% _
    ([r] tTrans
      (transform/implies
        (implies/equiv (equiv/transitive (equiv/roll3) (equiv/commute))))
      (letTyping/base null
        (tWrite2 (TYP-E2' r)
          (letTyping/exists [o]
            (letTyping/base o
              (tTrans
                (transform/trans3
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/symmetric equiv/associate)
                        (equiv/combine (equiv/symmetric equiv/one)
                          (equiv/symmetric equiv/associate)))))
                  (transform/skolem)
                  (transform/inside [o']
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine equiv/one equiv/reflexive)
                          (equiv/symmetric equiv/associate))))))
                (letTyping/exists [o']
                  (letTyping/base null
                    (tWrite: typing _ _ (write (lit r) F (lit o)) _)))
                (transform/trans
                  (transform/inside [o']
                    (transform/trans
                      (transform/implies
                        (implies/trans
                          (implies/equiv
                            (equiv/transitive
                              (equiv/associate)
                              (equiv/associate)))
                          (implies/combine
                            (implies/reflexive)
                            (implies/trans
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/roll2)
                                  (equiv/combine equiv/reflexive equiv/roll2)))
                              (implies/combine
                                (implies/reflexive)
                                (implies/combine
                                  (IMP o)
                                  (implies/equiv Pi3+Pi6<=>Pi2)))))))
                      (transform/drop)))
                  (transform/rem-unused)))))))
      (transform/reflexive))
    (effects2output/simple T2PF reftype2ty/unique simple-targets/unique
      M=>Pi2 B=>Pi1)
    <- ({o:object} typing-frame* TYP-E2 (envadd/exists [r] envadd/expr) (TYP-E2' o))
    <- efxmap`partition-implies-permission-combine-converse M|R6=M61+M6'
      M61=>Pi3 M6'=>Pi6 Pi2 (M=>Pi2:efxmap2perm CM PM B M Pi2) Pi3+Pi6<=>Pi2
    <- subtype-implies-ty2perm-leq* SUB not-borrowed/unique RT=>T2 T2PF2 T2PF IMP.

%worlds () (do-write _ _ _ _ _ _ _ _ _ _).
%total { } (do-write _ _ _ _ _ _ _ _ _ _).