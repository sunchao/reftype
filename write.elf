%%% The following two definitions should only be used in this file.

%abbrev encumbered-fldperm : object -> (object -> permission) -> clspred -> permission
  = [O][PF][CP]
    (unitperm
      (conditional
        (objequal O null)
        (empty)
        (unitperm
          (encumbered
            (PF O)
            (combine
              (allperm O)
              (one-predcall CP O)))))).

make-encumbered : clsmap -> predmap -> cxt -> set -> permission -> type.

make-encumbered/0 : make-encumbered _ _ _ set/0 empty.

make-encumbered/U :
    make-encumbered CM PM B S' Pi2 ->
    cxt`lookup B N (cxt-info/ O (ty/ _ _ C)) ->
    clsmap`lookup CM C FM ->
    predmap`lookup PM C CP ->
    fldmap`domain FM FS ->
    ({x} fldmap2perm PM x FM FS (PF x)) ->
    set`not-member S' N ->
    set`add S' N S ->
  make-encumbered CM PM B S ((encumbered-fldperm O PF CP) , Pi2).


%%% all permissions for objects in the set.

set-all-permissions : predmap -> cxt -> nat -> set -> permission -> type.

set-all-permissions/0 : set-all-permissions _ _ _ set/0 empty.

set-all-permissions/U :
    set-all-permissions PM B C S' Pi ->
    set`not-member S' N ->
    set`add S' N S ->
    cxt`lookup B N (cxt-info/ O (ty/ NN _ C)) ->
    ty2perm PM (ty/ NN annot/unique C) PF ->
  set-all-permissions PM B C S ((PF O) , Pi).


%%% A few theorems about make-encumbered

%theorem false-implies-make-encumbered
  : forall* {CM} {PM} {B} {S} {Pi}
    forall {V:void} exists {MF: make-encumbered CM PM B S Pi}
    true.

%worlds (objvar) (false-implies-make-encumbered _ _).
%total { } (false-implies-make-encumbered _ _).


%theorem make-encumbered-respects-eq
  : forall* {PM1} {PM2} {CM1} {CM2} {B1} {B2} {S1} {S2} {Pi1} {Pi2}
    forall {MFP1: make-encumbered CM1 PM1 B1 S1 Pi1}
    {CME: clsmap`eq CM1 CM2}
    {PME: predmap`eq PM1 PM2}
    {BE: cxt`eq B1 B2} {SE: set`eq S1 S2}
    {PE: permission`eq Pi1 Pi2}
    exists {MFP2: make-encumbered CM2 PM2 B2 S2 Pi2}
    true.

- : make-encumbered-respects-eq MFP clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/
    permission`eq/ MFP.

%worlds (objvar) (make-encumbered-respects-eq _ _ _ _ _ _ _).
%total {} (make-encumbered-respects-eq _ _ _ _ _ _ _).


%theorem make-encumbered/U-inversion
  : forall* {CM} {PM} {B} {S} {Pi} {SP} {N}
    forall {MF: make-encumbered CM PM B S Pi}
    {NM: set`not-member SP N}
    {UD: set`add SP N S}
    exists {Pi1} {MFP: make-encumbered CM PM B SP Pi1}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    {CP} {PML: predmap`lookup PM C CP}
    {FS} {DM: fldmap`domain FM FS}
    {PiP} {MF1: {x} fldmap2perm PM x FM FS (PiP x)}
    {EQV: equiv Pi ((encumbered-fldperm O PiP CP) , Pi1)}
    true.

%theorem make-encumbered/U-inversion/L
  : forall* {CM} {PM} {B} {S} {SP} {N} {S1} {Pi1} {N1} {O1} {NN1}
    {A1} {C1} {FM1} {FS1} {PiP1} {P} {CP1}
    forall {MF1: make-encumbered CM PM B S1 Pi1}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {CML1: clsmap`lookup CM C1 FM1}
    {PML1: predmap`lookup PM C1 CP1}
    {DM1: fldmap`domain FM1 FS1}
    {MF11: {x} fldmap2perm PM x FM1 FS1 (PiP1 x)}
    {NM1: set`not-member S1 N1}
    {U1: set`add S1 N1 S}
    {NM: set`not-member SP N}
    {U: set`add SP N S}
    {E?: nat`eq? N N1 P}
    exists {Pi} {MFP: make-encumbered CM PM B SP Pi}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    {CP} {PML: predmap`lookup PM C CP}
    {FS} {DM: fldmap`domain FM FS}
    {PiP} {MF1: {x} fldmap2perm PM x FM FS (PiP x)}
    {EQV: equiv ((encumbered-fldperm O1 PiP1 CP1) , Pi1)
          ((encumbered-fldperm O PiP CP) , Pi)}
    true.

- : make-encumbered/U-inversion/L MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1 F2 U2
    nat`eq?/yes %{=>}% _ MF _ _ _ _ BL1 _ CML1 _ PML1 _ DM1 _ MFO1 equiv/reflexive
    <- set`not-member-add-cancels F1 U1 F2 U2 nat`eq/ set`eq/ SE
    <- make-encumbered-respects-eq MF1 clsmap`eq/ predmap`eq/ cxt`eq/ SE
      permission`eq/ MF.

- : make-encumbered/U-inversion/L MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1 F2 U2
    (nat`eq?/no N<>N1) %{=>}%
    _ (make-encumbered/U MF2 BL1 CML1 PML1 DM1 MFO1 F4 U4)
    _ _ _ _ BL2 _ CML2 _ PML2 _ DM2 _ MFO2
    (equiv/transitive
      (equiv/combine equiv/reflexive EQV)
      (equiv/roll2))
    <- set`add-commutes-converse U2 U1 N<>N1 _ U4 U3
    <- set`add-preserves-not-member-converse F2 U4 F3
    <- set`add-preserves-not-member-converse F1 U3 F4
    <- make-encumbered/U-inversion MF1 F3 U3 _ MF2 _ _ _ _ BL2 _ CML2 _ PML2 _ DM2
      _ MFO2 EQV.

- : make-encumbered/U-inversion (make-encumbered/U MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1)
    F2 U2 _ MF _ _ _ _ BL _ CML _ PML _ DM _ MFO EQV
    <- nat`eq?-total E?
    <- make-encumbered/U-inversion/L MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1
      F2 U2 E? _ MF _ _ _ _ BL _ CML _ PML _ DM _ MFO EQV.

%worlds (objvar) (make-encumbered/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  (make-encumbered/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N N0) (make-encumbered/U-inversion N _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  (make-encumbered/U-inversion/L N0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem make-encumbered-implies
  : forall* {CM} {PM} {B} {Q} {Pi} {CM'} {PM'} {B'} {Q'} {Pi'}
    forall {MF: make-encumbered CM PM B Q Pi}
    {MF': make-encumbered CM' PM' B' Q' Pi'}
    {CME: clsmap`eq CM CM'} {PME: predmap`eq PM PM'}
    {BE: cxt`eq B B'} {QE: set`eq Q Q'}
    exists {PE: implies Pi Pi'} {PE': implies Pi' Pi}
    true.

%% Could we get a equivalence here?
%theorem make-encumbered-implies/L
  : forall* {PF1:object -> permission} {PF2:object -> permission} {CP1} {CP2}
    forall {O1} {O2} {EQ: object`eq O1 O2}
    {EQ: predicate`eq CP1 CP2}
    {EQV: {x} equiv (PF1 x) (PF2 x)}
    exists {IMP1: implies (encumbered-fldperm O1 PF1 CP1) (encumbered-fldperm O2 PF2 CP2)}
    {IMP2: implies (encumbered-fldperm O2 PF2 CP2) (encumbered-fldperm O1 PF1 CP1)}
    true.

- : make-encumbered-implies/L O1 _ object`eq/ predicate`eq/ EQV
    (implies/cond-inner
      (bimplies/reflexive)
      (bimplies/reflexive)
      (implies/reflexive)
      (implies/equiv-encumbered (EQV O1) equiv/reflexive))
    (implies/cond-inner
      (bimplies/reflexive)
      (bimplies/reflexive)
      (implies/reflexive)
      (implies/equiv-encumbered (equiv/symmetric (EQV O1)) equiv/reflexive)).

%worlds (objvar) (make-encumbered-implies/L _ _ _ _ _ _ _).
%total { } (make-encumbered-implies/L _ _ _ _ _ _ _).

- : make-encumbered-implies make-encumbered/0 make-encumbered/0 _ _ _ _
    implies/reflexive implies/reflexive.

- : make-encumbered-implies MF
    (make-encumbered/U MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1) CME PME BE SE
    (implies/trans
      (implies/equiv EQV)
      (implies/combine I1 I3))
    (implies/trans
      (implies/combine I2 I4)
      (implies/equiv (equiv/symmetric EQV)))
    <- make-encumbered/U-inversion MF F1 U1 _ MF0 _ _ _ _ BL0
      _ CML0 _ PML0 _ DM0 _ MFO0 EQV
    <- cxt`lookup-unique BL0 BL1 BE nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE TE
    <- ty-eq-inversion TE NNE AE CE
    <- clsmap`lookup-unique CML0 CML1 CME CE FME
    <- predmap`lookup-unique PML0 PML1 PME CE CPE
    <- fldmap`domain-unique DM0 DM1 FME FSE
    <- ({x} fldmap2perm-equiv (MFO0 x) (MFO1 x) PME object`eq/ FME FSE (PEQV x))
    <- make-encumbered-implies/L _ _ OE CPE PEQV I1 I2
    <- make-encumbered-implies MF0 MF1 CME PME BE set`eq/ I3 I4.

%worlds (objvar) (make-encumbered-implies _ _ _ _ _ _ _ _).
%total (K) (make-encumbered-implies _ K _ _ _ _ _ _).


%%% A few theorems about set-all-permissions

%theorem set-all-permissions-respects-eq
  : forall* {PM} {PM'} {S} {S'} {Pi} {Pi'} {B} {C}
    forall {SAP: set-all-permissions PM B C S Pi}
    {PME: predmap`eq PM PM'} {SE: set`eq S S'} {PE: permission`eq Pi Pi'}
    exists {SAP: set-all-permissions PM' B C S' Pi'}
    true.

- : set-all-permissions-respects-eq SAP predmap`eq/ set`eq/ permission`eq/ SAP.

%worlds (objvar) (set-all-permissions-respects-eq _ _ _ _ _).
%total { } (set-all-permissions-respects-eq _ _ _ _ _).


%theorem set-all-permissions-equiv
  : forall* {PM} {S} {S'} {Pi} {Pi'} {B} {C}
    forall {SAP: set-all-permissions PM B C S Pi}
    {SAP: set-all-permissions PM B C S' Pi'}
    {SE: set`eq S S'}
    exists {EQV: equiv Pi Pi'}
    true.

%worlds (objvar) (set-all-permissions-equiv _ _ _ _).
%trustme %total { } (set-all-permissions-equiv _ _ _ _).


%theorem restore-object-permission/L1
  : forall* {N} {FS} {S} {R} {S2} {X}
    forall {N!<S: set`not-member S N}
    {N+FS=>S: nat+set2capmap N FS X R}
    {S+FS=>S2': set+set2capmap S FS X S2}
    exists {D: capmap`disjoint S2 R}
    true.

%theorem restore-object-permission/L1L
  : forall* {N} {FS} {S} {R} {S2} {X}
    forall {N!<S: set`not-member S N}
    {N+FS=>S: nat+set2capmap N FS X R}
    {S+FS=>S2': set+set2capmap S FS X S2}
    {B} {D?: capmap`disjoint? S2 R B}
    exists {D: capmap`disjoint S2 R}
    true.

- : restore-object-permission/L1L _ _ _ _ (capmap`disjoint?/yes D) D.

- : restore-object-permission/L1L (N!<S:set`not-member S N)
    (N+FS=>R:nat+set2capmap N FS C R) S+FS=>S2 false
    (capmap`disjoint?/no (K<-S2:capmap`lookup S2 K C1)
      (K<-R:capmap`lookup R K C2)) S2^R
    <- nat+set2capmap-implies-cap-equal N+FS=>R K<-R (C2=C:cap`eq C2 C)
    <- capmap`lookup-respects-eq K<-R capmap`eq/ nat`eq/ C2=C K->R=C
    <- capmap`lookup-implies-fresh-update K->R=C R' K!<R' R'+K=R
    <- set+set2capmap-lookup-implies-nat2pair S+FS=>S2 K<-S2 N0 F N0<-S F<-FS K=>N0+F
    <- nat+set2capmap/UP-inversion N+FS=>R K!<R' R'+K=R _ N+FS=R' F0 K=>N+F0 FS+F0=FS
    <- nat2pair-unique K=>N0+F K=>N+F0 nat`eq/ PE
    <- pair-eq-implies-eq PE N0=N F=F0
    <- set`not-member-member-not-equal N!<S N0<-S N<>N0
    <- nat`ne-symmetric N<>N0 N0<>N
    <- nat`eq-ne-implies-false N0=N N0<>N V
    <- capmap`false-implies-disjoint V S2^R.

%worlds (objvar) (restore-object-permission/L1L _ _ _ _ _ _).
%total { } (restore-object-permission/L1L _ _ _ _ _ _).

- : restore-object-permission/L1 N!<S N+FS=>S S+FS=>S2' S2^R
    <- capmap`disjoint?-total S2^R?
    <- restore-object-permission/L1L N!<S N+FS=>S S+FS=>S2' _ S2^R? S2^R.

%worlds (objvar) (restore-object-permission/L1 _ _ _ _).
%total { } (restore-object-permission/L1 _ _ _ _).


%theorem fldmap`fresh-update-empty-implies-eq
  : forall* {S} {N} {T}
    forall {F: fldmap`fresh S N}
    {U: fldmap`update S N T (fldmap/+ N T fldmap/0)}
    exists {EQ: fldmap`eq S fldmap/0}
    true.

- : fldmap`fresh-update-empty-implies-eq fldmap`fresh/0 fldmap`update/0 fldmap`eq/.

- : fldmap`fresh-update-empty-implies-eq NM (fldmap`update/= NE) SE
    <- fldmap`fresh-lookup-not-equal NM (fldmap`lookup/= NE) NNE
    <- nat`ne-anti-reflexive NNE F
    <- fldmap`false-implies-eq F SE.

%worlds (objvar) (fldmap`fresh-update-empty-implies-eq _ _ _).
%total { } (fldmap`fresh-update-empty-implies-eq _ _ _).


%%% We changed fldmap2perm, and thus need to change the proof itself too.

%theorem restore-object-permission/L2L1
  : forall* {O1} {O2} {N1} {N2} {PF}
    forall {OE: object`eq O2 O1}
    {NE: nat`eq N2 N1}
    exists {EQV: implies
                 (unitperm
                   (conditional (objequal O2 null) empty
                     (scale (fraction/ (whole z))
                       (unitperm
                         (precise-exists O2 N1 ([x:gterm objectk] PF x))))))
                 (unitperm
                   (conditional (objequal O1 null) empty
                     (combine
                       (unitperm
                         (precise-exists O1 N2 ([x:gterm objectk] PF x)))
                       empty)))}
    true.

- : restore-object-permission/L2L1 object`eq/ nat`eq/
    (implies/cond-inner
      (bimplies/reflexive)
      (bimplies/reflexive)
      (implies/reflexive)
      (implies/trans
        (implies/equiv equiv/one)
        (implies/equiv (equiv/symmetric equiv/identity)))).

%worlds (objvar) (restore-object-permission/L2L1 _ _ _).
%total { } (restore-object-permission/L2L1 _ _ _).


%theorem restore-object-permission/L2L2
  : forall* {O} {O'} {F0} {N3}
    forall {PF: object -> permission} {PF2: object -> permission} {OE: object`eq O' O}
    {FE: nat`eq F0 N3}
    exists {KKK:implies
                 (combine
                   (unitperm
                     (conditional (objequal O' null) empty
                       (scale (fraction/ (whole z))
                         (unitperm
                           (precise-exists O' F0 ([x:gterm objectk] PF x))))))
                   (unitperm (conditional (objequal O null) empty (PF2 O))))
                 (unitperm
                   (conditional (objequal O null) empty
                     (combine
                       (unitperm
                         (precise-exists O N3 ([x:gterm objectk] PF x)))
                       (PF2 O))))}
    true.

- : restore-object-permission/L2L2 _ _ object`eq/ nat`eq/
    (implies/trans
      (implies/cond-factor)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/identity)
        (implies/combine (implies/equiv equiv/one) implies/reflexive))).

%worlds (objvar) (restore-object-permission/L2L2 _ _ _ _ _).
%total { } (restore-object-permission/L2L2 _ _ _ _ _).


%theorem restore-object-permission/L2
  : forall* {CM} {PM} {FM} {B} {M} {N} {Pi} {A} {C} {O} {FS} {FS0} {NN}
    forall {K} {BL: cxt`lookup B (s N) (cxt-info/ O (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    {SZ: set`size FS (s K)}
    {N+FS=>S: nat+set2capmap (s N) FS cap/write M}
    {M=>Pi: capmap2perm CM PM B M Pi}
    exists {PiF}
    {SFP: {x} fldmap2perm PM x FM FS (PiF x)}
    {Pi=>PiF: implies Pi (unitperm (conditional (objequal O null) empty (PiF O)))}
    true.

%theorem restore-object-permission/L2L3
  : forall* {PM} {FM} {FS} {Pi} {O}
    forall {V:void}
    exists {PiF}
    {SFP: {x} fldmap2perm PM x FM FS (PiF x)}
    {Pi=>PiF: implies Pi (unitperm (conditional (objequal O null) empty (PiF O)))}
    true.

%worlds (objvar) (restore-object-permission/L2L3 _ _ _ _).
%total { } (restore-object-permission/L2L3 _ _ _ _).


%theorem restore-object-permission/L2L4
  : forall* {SP} {K} {S}
    forall {NM: set`not-member SP K} {AD: set`add SP K S}
    {SZ: set`size S (s z)}
    exists {E: set`eq SP set/0}
    true.

- : restore-object-permission/L2L4 set`not-member/0 set`update/0 (set`size/+ set`size/0) set`eq/.

- : restore-object-permission/L2L4 NM (set`update/= nat`eq/) _ E
    <- set`not-member-contradiction NM F
    <- set`false-implies-eq F E.

%worlds () (restore-object-permission/L2L4 _ _ _ _).
%total {} (restore-object-permission/L2L4 _ _ _ _).


- : restore-object-permission/L2 _ _ _ _ _ _
    (nat+set2capmap/U _ (P2K:pair2nat (pair/ (s _) _) z) _ _ _) _ _ SFP IMP
    <- pair2nat-total-s _ _ _ P2KP
    <- nat`succ-preserves-eq nat`eq/ SE
    <- pair-preserves-eq SE nat`eq/ PE
    <- pair2nat-unique P2K P2KP PE EQ
    <- nat`eq-contradiction EQ V
    <- restore-object-permission/L2L3 V _ SFP IMP.

- : restore-object-permission/L2 z BL CML DM FS<=FS0 SZ
    (nat+set2capmap/U N+FSP=>SP P2K F U
      (MU)) M=>Pi _ ([x] fldmap2perm/U (MFP x) F U FML3 T2PF2)
    (implies/trans3
      (implies/equiv (equiv/symmetric EQV))
      (implies/combine IMP (implies/equiv PiP=0))
      (implies/equiv equiv/identity))
    <- restore-object-permission/L2L4 F U SZ (FSP=0:set`eq FSP set/0)
    <- nat+set2capmap-unique N+FSP=>SP nat+set2capmap/0
      nat`eq/ FSP=0 cap`eq/ (MP=0:capmap`eq SP capmap/0)
    <- nat+set2capmap-preserves-fresh N+FSP=>SP F P2K MF
    <- capmap2perm/U-inversion M=>Pi MF MU _ _ P2K2 _ _ _ _ BL2
      _ (create-fldperm/ CML2 FML2 T2PF2) _ cap2frac/write _ MP=>PiP EQV
    <- capmap2perm-equiv MP=>PiP capmap2perm/0 clsmap`eq/ predmap`eq/
      cxt`eq/ MP=0 (PiP=0:equiv PiP empty)
    <- nat2pair-unique P2K P2K2 nat`eq/ PE
    <- pair-eq-implies-eq PE NE FE
    <- cxt`lookup-unique BL BL2 cxt`eq/ NE CIE
    <- cxt-info-eq-inversion CIE (OE:object`eq O1 O2) TE
    <- ty-eq-inversion TE _ _ (CE:nat`eq C1 C2)
    <- clsmap`lookup-unique CML CML2 clsmap`eq/ CE (FME:fldmap`eq FM1 FM2)
    <- fldmap`eq-symmetric FME FMEP
    <- nat`eq-symmetric FE FEP
    <- set`eq-symmetric FSP=0 E=FSP
    <- object`eq-symmetric OE OEP
    <- fldmap`lookup-respects-eq FML2 FMEP FEP ty`eq/ FML3
    <- ({x} fldmap2perm-respects-eq
         fldmap2perm/0 predmap`eq/ object`eq/ fldmap`eq/ E=FSP permission`eq/ (MFP x))
    <- restore-object-permission/L2L1 OEP FE IMP.

- : restore-object-permission/L2 (s N) (BL:cxt`lookup _ _ (cxt-info/ O _)) CML
    FM-DM=FS0 FS<=FS0 SZ (nat+set2capmap/U N+FS'=>M' K=>N+F F!<FS' FS'+F=FS M'+K+W=M)
    M=>Pi _ ([x] fldmap2perm/U ((FS'=>Pi': {x} fldmap2perm _ x FM _ (PF2 x)) x)
              F!<FS' FS'+F=FS FML (T2PF:ty2perm _ _ PF))
    (implies/trans3
      (implies/equiv (equiv/symmetric PF+Pi'<=>Pi))
      (implies/combine implies/reflexive IMP)
      (IMP2))
    <- nat+set2capmap-preserves-fresh N+FS'=>M' F!<FS' K=>N+F K!<M'
    <- set`fresh-update-implies-leq F!<FS' FS'+F=FS FS'<=FS
    <- set`leq-transitive FS'<=FS FS<=FS0 FS'<=FS0
    <- capmap2perm/U-inversion M=>Pi K!<M' M'+K+W=M N0 F0 K=>N0+F0
      O' _ _ _ BL0 _ (create-fldperm/ CML0 FML0 T2PF0)
      _ cap2frac/write _ M'=>Pi' PF+Pi'<=>Pi
    <- nat2pair-unique K=>N0+F0 K=>N+F nat`eq/ PE
    <- pair-eq-implies-eq PE N0=N F0=F
    <- cxt`lookup-unique BL0 BL cxt`eq/ N0=N CIO=CI
    <- cxt-info-eq-inversion CIO=CI O0=O T0=T
    <- ty-eq-inversion T0=T NN0=NN _ C0=C
    <- clsmap`lookup-unique CML0 CML clsmap`eq/ C0=C (FM0=FM:fldmap`eq FM0 FM)
    <- set`add-implies-member FS'+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
    <- fldmap`domain-preserves-lookup-converse F<-FS0 FM-DM=FS0 T FML
    <- fldmap`lookup-unique FML0 FML FM0=FM F0=F FT0=FT
    <- ty2perm-respects-eq T2PF0 predmap`eq/ FT0=FT ([_] permission`eq/) T2PF
    <- set`not-member-add-increases-size-converse SZ F!<FS' FS'+F=FS SZ'
    <- restore-object-permission/L2 N BL CML FM-DM=FS0 FS'<=FS0 SZ' N+FS'=>M'
      M'=>Pi' _ ([x] FS'=>Pi' x) IMP
    <- restore-object-permission/L2L2 PF PF2 O0=O F0=F IMP2.

%worlds (objvar) (restore-object-permission/L2 _ _ _ _ _ _ _ _ _ _ _).
%total (A) (restore-object-permission/L2 A _ _ _ _ _ _ _ _ _ _).


% %theorem restore-object-permission/L3
%   : forall* {PM} {C} {CP} {Pi} {PF} {NN} {PF2} {PF3}
%     forall {PML: predmap`lookup PM C CP}
%     {AN: apply-nn NN ([x] unitperm (encumbered (Pi x)
%       (combine (obj-ne-null x) (combine (allperm x) (one-predcall CP x))))) PF}
%     {CNN: apply-nn NN ([x] PF3 x) ([x] PF2 x)}
%     {EQ: {x} equiv (PF3 x) (Pi x)}
%     exists {PF4} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF4}
%     {IMP: {x} implies ((PF2 x) , (PF x)) (PF4 x)}
%     true.

%theorem restore-object-permission/L3
  : forall* {PM} {C} {CP} {Pi} {NN} {PF3}
    forall {PML: predmap`lookup PM C CP}
    {EQ: {x} equiv (PF3 x) (Pi x)}
    exists {PF4} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF4}
    {IMP: {x} implies (combine (encumbered-fldperm x Pi CP)
                        (unitperm (conditional (objequal x null) empty (PF3 x))))
          (PF4 x)}
    true.

% - : restore-object-permission/L3 PML
%     apply-nn/yes apply-nn/yes EQV _
%     (ty2perm/ PML nn2perm/yes annot2perm/unique)
%     ([x] implies/trans3
%       (implies/combine
%         (implies/trans
%           (implies/combine implies/nonlinear2empty implies/reflexive)
%           (implies/equiv (equiv/transitive equiv/commute equiv/identity)))
%         (implies/trans
%           (implies/combine implies/nonlinear2empty implies/reflexive)
%           (implies/equiv (equiv/transitive equiv/commute equiv/identity))))
%       (implies/combine (implies/equiv (EQV x)) implies/reflexive)
%       (implies/linear-modus-ponens)).

% - : restore-object-permission/L3 PML
%     apply-nn/may apply-nn/may EQV _
%     (ty2perm/ PML nn2perm/may annot2perm/unique)
%     ([x] implies/trans
%       (implies/cond-factor)
%       (implies/cond-inner
%         (bimplies/reflexive)
%         (bimplies/reflexive)
%         (implies/equiv equiv/identity)
%         (implies/trans4
%           (implies/combine (implies/equiv (EQV x)) implies/reflexive)
%           (implies/linear-modus-ponens)
%           (implies/combine implies/nonlinear2empty implies/reflexive)
%           (implies/equiv (equiv/transitive equiv/commute equiv/identity))))).

%worlds (objvar) (restore-object-permission/L3 _ _ _ _ _).
%trustme %total { } (restore-object-permission/L3 _ _ _ _ _).


%theorem restore-object-permission
  : forall* {CM} {PM} {B} {S} {FS} {Pi} {M} {Pi2} {C} {FM} {N}
    forall {SOC: same-class B S C}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {SZ: set`size FS (s N)}
    {MF: make-encumbered CM PM B S Pi}
    {S+FS=>S2: set+set2capmap S FS cap/write M}
    {M2P: capmap2perm CM PM B M Pi2}
    exists {Pi3} {IMP: implies (Pi2 , Pi) Pi3}
    {SAP: set-all-permissions PM B C S Pi3}
    true.

%theorem restore-object-permission/F
  : forall* {PM} {B} {S} {C} {Pi} {Pi2}
    forall {V:void}
    exists {Pi3} {IMP: implies (Pi2 , Pi) Pi3}
    {SAP: set-all-permissions PM B C S Pi3}
    true.

%worlds (objvar) (restore-object-permission/F _ _ _ _).
%total { } (restore-object-permission/F _ _ _ _).


- : restore-object-permission _ _ _ _ _ make-encumbered/0 S+FS+X=>M2 M2=>Pi2 _
    (implies/trans (implies/combine (implies/equiv EQV) implies/reflexive)
      (implies/equiv equiv/identity))
    set-all-permissions/0
    <- set+set2capmap-unique S+FS+X=>M2 set+set2capmap/0 set`eq/ set`eq/ cap`eq/ M2=0
    <- capmap2perm-equiv M2=>Pi2 capmap2perm/0 clsmap`eq/ predmap`eq/ cxt`eq/ M2=0 EQV.

- : restore-object-permission
    (SOC:same-class B S C) (CM2PM:clsmap2predmap CM PM)
    (CML0:clsmap`lookup CM C FM0)
    (FM-DM0:fldmap`domain FM0 FS0) SZK
    (make-encumbered/U (S'=>Pi':make-encumbered CM PM B SP PiP)
      (BL1:cxt`lookup B _ (cxt-info/ O1 (ty/ NN1 A1 C1)))
      (CML1:clsmap`lookup CM C1 FM1) PML
      (DM-FM:fldmap`domain FM1 FS1)
      MF1 (N!<S':set`not-member SP z) (S'+N=S:set`add SP z S))
    (S+FS=>M2:set+set2capmap S FS0 cap/write M2)
    (M2=>Pi2:capmap2perm CM PM B M2 Pi2) _ IMP SAP
    <- set`add-implies-member S'+N=S MB
    <- same-class-no-zero SOC MB V
    <- restore-object-permission/F V _ IMP SAP.

- : restore-object-permission
    (SOC:same-class B S C) (CM2PM:clsmap2predmap CM PM)
    (CML0:clsmap`lookup CM C FM0)
    (FM-DM0:fldmap`domain FM0 FS0) SZK
    (make-encumbered/U (S'=>Pi':make-encumbered CM PM B SP PiP)
      (BL1:cxt`lookup B _ (cxt-info/ O1 (ty/ NN1 A1 C1)))
      (CML1:clsmap`lookup CM C1 FM1) PML
      (DM-FM:fldmap`domain FM1 FS1)
      MF1 (N!<S':set`not-member SP (s N1)) (S'+N=S:set`add SP (s N1) S))
    (S+FS=>M2:set+set2capmap S FS0 cap/write M2)
    (M2=>Pi2:capmap2perm CM PM B M2 Pi2) _
    (implies/trans5
      (implies/combine (implies/equiv Pi2<=>Pi2'+PiR) implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive
        (implies/trans3
          (implies/combine (Pi=>PiF2) implies/reflexive)
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/equiv equiv/commute)
              (IMP2 O1))
            (implies/reflexive))))
      (implies/equiv equiv/roll2)
      (implies/combine (implies/equiv (EQV3)) (IMP)))
    (set-all-permissions/U S'-Pi3 N!<S' S'+N=S (BL1') T2PF2)
    <- same-class/U-inversion SOC N!<S' S'+N=S O0 NN0 A0 (SOC':same-class B SP C)
      (BL0:cxt`lookup B _ (cxt-info/ O0 (ty/ NN0 A0 C)))
    <- set+set2capmap/U-inversion
      S+FS=>M2 N!<S' S'+N=S S2P R S'+FS=>M2' N+FS=>MR M2'+MR=M2
    <- restore-object-permission/L1 N!<S' N+FS=>MR S'+FS=>M2' M2'^MR
    <- capmap`disjoint-join-implies-equiv M2'^MR M2'+MR=M2 M2=>Pi2
      Pi2' PiR M2'=>Pi2' MR=>PiR Pi2<=>Pi2'+PiR
    <- cxt`lookup-unique BL0 BL1 cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE (OE:object`eq O0 O1) TE
    <- cxt-info`eq-symmetric CIE CIE'
    <- object`eq-symmetric OE OEP
    <- ty-eq-inversion TE NNE AE (CE:nat`eq C C1)
    <- clsmap`lookup-unique CML0 CML1 clsmap`eq/ CE FME
    <- fldmap`domain-respects-eq FM-DM0 FME set`eq/ FM-DM
    <- restore-object-permission SOC' CM2PM CML0 FM-DM0 SZK S'=>Pi'
      S'+FS=>M2' M2'=>Pi2' _ IMP S'-Pi3
    <- set`leq-reflexive _ FS<=FS
    <- restore-object-permission/L2 _ BL1 CML1 FM-DM FS<=FS SZK N+FS=>MR MR=>PiR
      _ ([x] MF1F' x) Pi=>PiF2
    <- fldmap`domain-unique FM-DM0 DM-FM FME FSE
    <- ({x} fldmap2perm-equiv (MF1F' x)
         (MF1 x) predmap`eq/ object`eq/ fldmap`eq/ FSE (PEQV x))
    <- restore-object-permission/L3 PML PEQV _ T2PF IMP2
    <- cxt`lookup-respects-eq BL1 cxt`eq/ nat`eq/ CIE' BL1'
    <- ty-preserves-eq NNE annot`eq/ CE TE2
    <- ty`eq-symmetric TE2 TE2P
    <- ty2perm-respects-eq T2PF predmap`eq/ TE2P ([_] permission`eq/) (T2PF2:ty2perm _ _ PF)
    <- equiv-respects-object-eq PF OEP EQV3.

%worlds (objvar) (restore-object-permission _ _ _ _ _ _ _ _ _ _ _).
%total (C) (restore-object-permission _ _ _ _ _ C _ _ _ _ _).


%theorem nn-leq-implies-permission-leq
  : forall* {PM} {C} {PF2} {NN2} {NN1} {A}
    forall {T2PF: ty2perm PM (ty/ NN2 A C) PF2}
    {NN2<=NN1: nonnull`leq NN1 NN2}
    exists {PF1} {T2PF: ty2perm PM (ty/ NN1 A C) PF1}
    {IMP: {x} implies (PF2 x) (PF1 x)}
    true.

- : nn-leq-implies-permission-leq T2PF
    (nonnull`leq/= nonnull`eq/) _ T2PF ([_] implies/reflexive).

- : nn-leq-implies-permission-leq
    (ty2perm/ PML nn2perm/yes A2AF)
    (nonnull`leq/<) _ (ty2perm/ PML nn2perm/may A2AF)
    ([_] implies/cond-intro-neg).

%worlds (objvar) (nn-leq-implies-permission-leq _ _ _ _ _).
%total { } (nn-leq-implies-permission-leq _ _ _ _ _).


%theorem nn-leq-implies-permission-leq*
  : forall* {PM} {C} {PF1} {PF2} {NN2} {NN1} {A}
    forall {T2PF: ty2perm PM (ty/ NN2 A C) PF2}
    {NN2<=NN1: nonnull`leq NN1 NN2}
    {T2PF: ty2perm PM (ty/ NN1 A C) PF1}
    exists {IMP: {x} implies (PF2 x) (PF1 x)}
    true.

- : nn-leq-implies-permission-leq* T2PF2 LE T2PF
    ([x] implies/trans (IMP' x) (implies/equiv (PEQV x)))
    <- nn-leq-implies-permission-leq T2PF2 LE _ T2PF' IMP'
    <- ty2perm-deterministic T2PF' T2PF predmap`eq/ ty`eq/ PEF
    <- ({x} permission`eq-implies-equiv (PEF x) (PEQV x)).

%worlds (objvar) (nn-leq-implies-permission-leq* _ _ _ _).
%total { } (nn-leq-implies-permission-leq* _ _ _ _).


%theorem set-all-permissions-implies
  : forall* {S} {Pi} {GF} {O} {B} {PM} {C} {NN}
    forall {N} {SZ: set`size S (s N)}
    {SAP: set-all-permissions PM B C S Pi}
    {S=>G: set2cond B O S GF}
    {LNN: least-nonnull B S NN}
    exists {PF} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    {Pi2} {IMP: implies (GF , Pi) ((PF O) , Pi2)}
    true.

% - : set-all-permissions-implies
%     (s N) SZ
%     (set-all-permissions/U S'=>Pi' N!<S'
%       S'+N=S (BL: cxt`lookup _ _ (cxt-info/ O _)) T2PF2)
%     S=>GF MN-NN _ T2PF3 _
%     (implies/trans6
%       (implies/combine
%         (implies/trans (implies/nonlinear GF=>E+GF')
%           (implies/disj2cond))
%         (implies/reflexive))
%       (implies/equiv equiv/commute)
%       (implies/cond-push)
%       (implies/cond-gen-inner)
%       (implies/cond-inner
%         (bimplies/reflexive)
%         (bimplies/reflexive)
%         (implies/trans4
%           (implies/combine
%             (implies/nonlinear
%               (bimplies/objequal-symmetric))
%             (implies/equiv equiv/identity))
%           (implies/combine implies/reflexive
%             (implies/combine (IMP2 O) implies/reflexive))
%           (implies/equiv equiv/associate)
%           (implies/combine (implies/objequal ([x] PF x)) implies/reflexive))
%         (implies/trans4
%           (implies/equiv equiv/commute)
%           (implies/combine
%             (implies/trans4
%               (implies/equiv equiv/commute)
%               (implies/equiv equiv/reorder)
%               (implies/combine implies/reflexive
%                 (IMP))
%               (implies/equiv equiv/reorder))
%             (implies/reflexive))
%           (implies/equiv (equiv/symmetric equiv/associate))
%           (implies/combine (implies/equiv (EQV O)) implies/reflexive)))
%       (implies/cond-pull)).
%     <- set2facts/U-inversion S=>GF N!<S' S'+N=S GF' S'=>GF' _ _ BL2 GF=>E+GF' _
%     <- nn-all-less-than/U-inversion MN-NN N!<S' S'+N=S _ _ _ BL' LE MN-NN'
%     <- set`not-member-add-increases-size-converse SZ N!<S' S'+N=S SZ'
%     <- set-all-permissions-implies N SZ' S'=>Pi' S'=>GF' MN-NN' _ T2PF _ IMP.
%     <- cxt`lookup-unique BL' BL cxt`eq/ nat`eq/ CIE
%     <- cxt-info-eq-inversion CIE _ TE
%     <- ty-eq-inversion TE NNE _ CE
%     <- nonnull`leq-respects-eq LE nonnull`eq/ NNE LE'
%     <- nn-leq-implies-permission-leq T2PF2 LE' _ (T2PF3:ty2perm _ _ PF) IMP2
%     <- ty2perm-deterministic T2PF T2PF3 predmap`eq/ ty`eq/ PEF
%     <- ({x} permission`eq-implies-equiv (PEF x) (EQV x)).

% - : set-all-permissions-implies z SZ
%     (set-all-permissions/U (S=>Pi:set-all-permissions PM B C S' Pi)
%       (F:set`not-member _ W) U BL T2PF) S=>GF
%     (MN-NN:nn-all-less-than B S NN) _ (T2PF2:ty2perm _ _ PF)
%     _ (implies/trans4
%         (implies/combine
%           (implies/nonlinear BIMP)
%           (implies/trans
%             (implies/combine implies/reflexive (implies/equiv EQV))
%             (implies/equiv equiv/identity)))
%         (implies/combine
%           (implies/nonlinear
%             (bimplies/trans
%               (bimplies/neg
%                 (bimplies/trans
%                   (bimplies/conj/XX
%                     (bimplies/reflexive)
%                     (bimplies/trans
%                       (bimplies/neg (BIMP2) bool`ne/TF)
%                       (bimplies/rem-negneg)))
%                   (bimplies/conj-true))
%                 (bool`ne/FT))
%               (bimplies/trans
%                 (bimplies/rem-negneg)
%                 (bimplies/objequal-symmetric))))
%           (IMP (object/ W)))
%         (implies/objequal ([x] PF x))
%         (implies/equiv (equiv/symmetric equiv/identity)))
%     <- set`not-member-update-increases-size-converse
%       SZ F U SZ'
%     <- set`size-zero-implies-empty SZ' S=0
%     <- set-all-permissions-equiv S=>Pi set-all-permissions/0 S=0 EQV
%     <- set2facts/U-inversion S=>GF F U _ S'=>GF' BIMP _
%     <- set2facts-bimplies S'=>GF' set2facts/0 object`eq/ S=0 BIMP2 _
%     <- set`eq-symmetric S=0 E=S
%     <- nn-all-less-than/U-inversion MN-NN F U _ _ _ BL' LE _
%     <- cxt`lookup-unique BL' BL cxt`eq/ object`eq/ TE
%     <- ty-eq-inversion TE NNE _ CE
%     <- nonnull`leq-respects-eq LE nonnull`eq/ NNE LE'
%     <- nn-leq-implies-permission-leq T2PF LE' _ T2PF2 IMP.

%worlds (objvar) (set-all-permissions-implies _ _ _ _ _ _ _ _ _).
%trustme %total (N) (set-all-permissions-implies N _ _ _ _ _ _ _ _).


%theorem set-all-permissions-implies*
  : forall* {PM} {S} {Pi} {GF} {O} {B} {NN} {C} {PF} {N}
    forall {_: set`size S (s N)}
    {_: set-all-permissions PM B C S Pi} {S=>G: set2cond B O S GF}
    {_: least-nonnull B S NN} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    exists {Pi2} {_: implies (GF , Pi) (PF O , Pi2)}
    true.

- : set-all-permissions-implies* SZ SAP (S2GF:set2cond _ O _ _) FLN T2PF _
    (implies/trans IMP'
      (implies/combine (implies/equiv (EQV O)) implies/reflexive))
    <- set-all-permissions-implies _ SZ SAP S2GF FLN _ T2PF' _ IMP'
    <- ty2perm-deterministic T2PF' T2PF predmap`eq/ ty`eq/ PEF
    <- ({x} permission`eq-implies-equiv (PEF x) (EQV x)).

%worlds (objvar) (set-all-permissions-implies* _ _ _ _ _ _ _).
%total { } (set-all-permissions-implies* _ _ _ _ _ _ _).


%%% A format before we checking write.

before-write-format : clsmap -> predmap -> expr-result -> expr-output -> type.

before-write-format/expr :
    cxt2perm CM PM B PiB ->
    capmap2perm CM PM B M PiM ->
    reftype2ty RT T ->
    ty2perm PM T ([x] PF x) ->
  before-write-format CM PM (result/expr RT (env/ B M))
      (output/exists [x] (output/expr x (combine PiB (combine (PF x) PiM)))).


% cxt-remove-unique

%theorem cxt-remove-unique-implies-make-encumbered/L1
  : forall* {B0} {B0P} {B1} {N} {O} {T0} {T1}
    forall {N!<B0P: cxt`fresh B0P N}
    {B0P+N+T0=B0: cxt`update B0P N (cxt-info/ O T0) B0}
    {B0+N+T1=B1: cxt`update B0 N (cxt-info/ O T1) B1}
    exists {B0P+N+T1=B1:cxt`update B0P N (cxt-info/ O T1) B1}
    true.

%worlds (objvar) (cxt-remove-unique-implies-make-encumbered/L1 _ _ _ _).
%trustme %total { } (cxt-remove-unique-implies-make-encumbered/L1 _ _ _ _).


%theorem cxt-remove-unique-implies-make-encumbered/L2
  : forall* {CM} {PM} {B0} {B1} {S} {Pi} {N} {O} {NN} {A0} {A1} {C}
    forall {ME: make-encumbered CM PM B0 S Pi}
    {B0-L: cxt`lookup B0 N (cxt-info/ O (ty/ NN A0 C))}
    {B0-U: cxt`update B0 N (cxt-info/ O (ty/ NN A1 C)) B1}
    exists {ME: make-encumbered CM PM B1 S Pi}
    true.

%worlds (objvar) (cxt-remove-unique-implies-make-encumbered/L2 _ _ _ _).
%trustme %total { } (cxt-remove-unique-implies-make-encumbered/L2 _ _ _ _).


%theorem cxt-remove-unique-implies-make-encumbered/L4
  : forall* {CM} {PM} {NN} {C} {PiU}
    forall {U=>PiU: ty2perm2 CM PM (ty/ NN annot/unique C) PiU}
    exists {PiB} {FM} {PF} {CP}
    {B=>PiB: ty2perm2 CM PM (ty/ NN annot/borrow C) PiB}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FS=>PF: {x} fldmap2perm2 PM x FM (PF x)}
    {IMP: {x} implies (PiU x)
          (combine (PiB x)
            (unitperm (conditional (objequal x null) empty
              (unitperm (encumbered (PF x)
                          (combine (allperm x) (one-predcall CP x)))))))}
    true.

- : cxt-remove-unique-implies-make-encumbered/L4
    (ty2perm2/unique CML PML ([x] FM=>PF x) T2PF) %{=>}% _ _ _ _
    (ty2perm2/borrow T2PF) CML PML FM=>PF ([_] implies/reflexive).

%worlds (objvar) (cxt-remove-unique-implies-make-encumbered/L4 _ _ _ _ _ _ _ _ _ _).
%total { } (cxt-remove-unique-implies-make-encumbered/L4 _ _ _ _ _ _ _ _ _ _).


%theorem cxt-remove-unique-implies-make-encumbered
  : forall* {CM} {PM} {B0} {B1} {S} {PiB0}
    forall {B0-S=B1: cxt-remove-unique B0 S B1}
    {B0=>PiB0: cxt2perm CM PM B0 PiB0}
    exists {PiB1} {Pi}
    {B1=>PiB1: cxt2perm CM PM B1 PiB1}
    {ME: make-encumbered CM PM B0 S Pi}
    {IMP: equiv PiB0 (PiB1 , Pi)}
    true.

%worlds (objvar) (cxt-remove-unique-implies-make-encumbered _ _ _ _ _ _ _).
%trustme %total (A) (cxt-remove-unique-implies-make-encumbered A _ _ _ _ _ _).


% - : cxt-remove-unique-implies-make-encumbered
%     (cxt-remove-unique/0) B=>PiB0 _ _ B=>PiB0 make-encumbered/0
%     (equiv/symmetric equiv/identity).

% - : cxt-remove-unique-implies-make-encumbered
%     (cxt-remove-unique/U B0-SP-B1 N!<B2
%       (B2+N=B1:cxt`update B2 N (cxt-info/ O (ty/ NN annot/unique C)) B1)
%       (N!<SP:set`not-member SP N) SP+N=S)
%     (B0=>PiB0:cxt2perm CM PM B0 PiB0) %{=>}% _ _ B2=>PiB2 ME-B2-S=Pi EQV
%     <- cxt-remove-unique-implies-make-encumbered
%       B0-SP-B1 B0=>PiB0 PiB1 PiSP B1=>PiB1 ME-B1-SP=PiSP EQV1.

%     (cxt2perm/U B2P=>PiB2P N!<B2P B2P+N+R=B2 (ty2perm2/borrow T2PF))
%     (make-encumbered/U ME-B2-SP=PiSP B2->N CML PML DM FM=>PF AP N!<SP SP+N=S)
%     (equiv/transitive4
%       (EQV1)
%       (equiv/combine (EQV2) equiv/reflexive)
%       (equiv/combine equiv/swap equiv/reflexive)
%       (equiv/symmetric equiv/associate))
%     <- cxt-remove-unique-implies-make-encumbered
%       B0-SP-B1 B0=>PiB0 PiB1 PiSP B1=>PiB1 ME-B1-SP=PiSP EQV1.
%     <- cxt-remove-unique-implies-make-encumbered/L2 ME-B1-SP=PiSP B1->N=U
%       B1+N+R=B2 ME-B2-SP=PiSP
%     <- cxt`lookup-implies-fresh-update B1->N=U B1P N!<B1P B1P+N+U=B1
%     <- cxt2perm/U-inversion B1=>PiB1 N!<B1P B1P+N+U=B1 PiB1P B1P=>PiB1P
%       _ (ty2perm2/unique CML PML ([x] fldmap2perm2/ DM (FM=>PF x)) AP T2PF) EQV2
%     <- cxt-remove-unique-implies-make-encumbered/L1 N!<B1P B1P+N+U=B1 B1+N+R=B2 B1P+N+R=B2
%     <- cxt`update-implies-lookup B1P+N+R=B2 B2->N.

% %worlds (objvar) (cxt-remove-unique-implies-make-encumbered _ _ _ _ _ _ _).
% %total (A) (cxt-remove-unique-implies-make-encumbered A _ _ _ _ _ _).


%%% cxt-remove-unique has no effect on many transformations,
%%% because they don't use the annotation info.

%theorem cxt-remove-unique-no-effect-on-capmap2perm
  : forall* {CM} {PM} {B0} {B1} {Pi} {M} {M1} {M2} {S} {FS} {X} {Pi2}
    forall {M=>Pi: capmap2perm CM PM B0 M Pi}
    {B0+M2=>Pi2: capmap2perm CM PM B0 M2 Pi2}
    {S+FS=>M1: set+set2capmap S FS X M1}
    {M-M1=M2: capmap-split M M1 M2}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    exists {B1+M2=>Pi2: capmap2perm CM PM B1 M2 Pi2}
    true.

%worlds (objvar) (cxt-remove-unique-no-effect-on-capmap2perm _ _ _ _ _ _).
%trustme %total { } (cxt-remove-unique-no-effect-on-capmap2perm _ _ _ _ _ _).


%%% Lemmas for the main theorem make-before-write-format

%theorem make-before-write-format/L1*
  : forall* {PM} {B} {S} {C} {Pi} {NN} {GF} {PF}
    forall {N} {SZ: set`size S N}
    {SAP: set-all-permissions PM B C S Pi}
    {FLN: least-nonnull B S NN}
    {G=>GF: {x} set2cond B x S (GF x)}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    exists {Pi2}
    {IMP: {x}{o} implies
          (combine (Pi , (PF o))
            (unitperm (conditional (objequal x o) empty (GF x))))
          (combine (PF x) (Pi2 x o))}
    true.

- : make-before-write-format/L1* z _ set-all-permissions/0
    least-nonnull/0 ([_] set2cond/0) (T2PF:ty2perm _ _ PF) _
    ([x][o] implies/trans4
      (implies/combine
        (implies/equiv (equiv/transitive equiv/commute equiv/identity))
        (implies/trans (cond-to-objequal x o)
          (implies/nonlinear bimplies/objequal-symmetric)))
      (implies/equiv equiv/commute)
      (implies/objequal ([x] PF x))
      (implies/equiv (equiv/symmetric equiv/identity))).

- : make-before-write-format/L1* (s _) SZ SAP MN G=>GF T2PF _
    ([x][o] implies/trans4
      (implies/combine (implies/equiv equiv/commute)
        (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive
        (implies/trans
          (implies/cond-push)
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/equiv equiv/identity)
            (implies/trans
              (implies/equiv equiv/commute)
              (IMP2 x)))))
      (implies/trans4
        (implies/cond-push)
        (implies/cond-gen-inner)
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/trans3
            (implies/combine
              (implies/nonlinear bimplies/objequal-symmetric)
              (implies/reflexive))
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/objequal ([x] PF x))
              (implies/reflexive)))
          (implies/equiv equiv/roll3))
        (implies/cond-pull)))
    <- ({r} set-all-permissions-implies* SZ SAP (G=>GF r) MN T2PF _ (IMP2 r)).

%worlds (objvar) (make-before-write-format/L1* _ _ _ _ _ _ _ _).
%total (N) (make-before-write-format/L1* N _ _ _ _ _ _ _).


%theorem make-before-write-format/L1
  : forall* {PM} {B} {S} {C} {Pi} {NN} {GF} {PF}
    forall {SAP: set-all-permissions PM B C S Pi}
    {FLN: least-nonnull B S NN}
    {G=>GF: {x} set2cond B x S (GF x)}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    exists {Pi2}
    {IMP: {x}{o} implies
          (combine (Pi , (PF o))
            (unitperm (conditional (objequal x o) empty (GF x))))
          (combine (PF x) (Pi2 x o))}
    true.

- : make-before-write-format/L1 SAP FLN G2GF T2PF _ IMP
    <- set`size-total SZ
    <- make-before-write-format/L1* _ SZ SAP FLN G2GF T2PF _ IMP.

%worlds (objvar) (make-before-write-format/L1 _ _ _ _ _ _).
%total { } (make-before-write-format/L1 _ _ _ _ _ _).


%theorem make-before-write-format/L2
  : forall* {Q} {PF: object -> permission}
    forall {EQ: equ Q one}
    exists {EQV: {x} equiv (scale (fraction/ Q) (PF x)) (PF x)}
    true.

- : make-before-write-format/L2 equ/ ([_] equiv/one).

%worlds (objvar) (make-before-write-format/L2 _ _).
%total { } (make-before-write-format/L2 _ _).


%theorem make-before-write-format/L3
  : forall* {CP} {CPF}
    forall {PF:clspred -> object -> permission}
    {EQ: {x} predicate`eq (CPF x) (CP)}
    exists {EQV: {x} equiv (PF (CPF x) x) (PF CP x)}
    true.

- : make-before-write-format/L3 _ ([_] predicate`eq/) ([_] equiv/reflexive).

%worlds (objvar) (make-before-write-format/L3 _ _ _).
%total { } (make-before-write-format/L3 _ _ _).


%%% V1 = (env/ B0 M0), V2 = (env/ B1 M3)
%theorem make-before-write-format
  : forall* {CM} {PM} {RT} {T} {V1} {V2} {Out0}
    forall {WF-CM: wf-clsmap CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-RSLT: clsmap-result CM (result/expr RT V1)}
    {SUB: subtype CM RT V1 T V2}
    {R=>Out: result2output CM PM (result/expr RT V1) Out0}
    exists {Out1}
    {TRANS: transform Out0 Out1}
    {BR-FMT: before-write-format CM PM (result/expr RT V2) Out1}
    true.

- : make-before-write-format WF-CM CM2PM
    (clsmap-result/expr _
      (clsmap-cxt-reftype/unique _ CM-B0-S _ _) CM-B0-M0)
    (subtype/ nat`eq/ NN-LEQ CML (DM-FM=FS:fldmap`domain FM FS)
      (sub-annot-cap/consume (S+FS=>M2:set+set2capmap S FS _ M2)
                (M0-M2=M3:capmap-split M0 M2 M3) (MI-M1=W:capmap-min M1 cap/write)
                (B0-S=B1:cxt-remove-unique B0 S B1)))
    (result2output/unique/2 SZ-M1 T2PF ([x] B0+S=>GF x)
      (B0=>PiB0:cxt2perm CM PM B0 PiB0) (B0+M0=>PiM0:capmap2perm CM PM B0 M0 PiM0)
      (B0+M1=>PiM1:capmap2perm CM PM B0 M1 PiM1)
      (MI-M1=X:capmap-min M1 Xx)
      (X=>Q:cap2frac Xx (fraction/ Q)))
    %{=>}% _
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/trans
            (transform/implies
              (implies/trans6 % PiB0 , G , Q (ECUMB PiM1 , PiM0)
                (implies/combine
                  (implies/equiv EQV)
                  (implies/combine implies/reflexive % GF
                    (implies/combine (implies/equiv (EQV2 r)) % PF
                      (implies/combine
                        (implies/reflexive)
                        (implies/equiv PiM0<=>PiM2+PiM3)))))
                (implies/equiv
                  (equiv/transitive4
                    (equiv/symmetric equiv/associate)
                    (equiv/roll6)
                    (equiv/combine equiv/reflexive equiv/roll2)
                    (equiv/associate)))
                (implies/combine PiM2+Pi<=>PiS implies/reflexive)
                (implies/equiv
                  (equiv/transitive4
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine equiv/reflexive equiv/roll2)
                    (equiv/associate)))
                (implies/combine (IMP o r) implies/reflexive)
                (implies/equiv
                  (equiv/transitive5
                    (equiv/combine equiv/commute equiv/reflexive)
                    (equiv/symmetric equiv/associate)
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine equiv/reflexive equiv/roll2))))))
          (transform/drop))
        (transform/rem-unused)))
    (before-write-format/expr (B1=>PiB1:cxt2perm CM PM B1 PiB1)
      (B1+M3=>PiM3:capmap2perm CM PM B1 M3 PiM3) reftype2ty/unique T2PF)
    <- cxt-remove-unique-implies-make-encumbered B0-S=B1 B0=>PiB0 PiB1 Pi B1=>PiB1 B0-ME EQV
    <- capmap-split-implies-permission-combine
      M0-M2=M3 B0+M0=>PiM0 PiM2 PiM3 B0+M2=>PiM2 B0+M3=>PiM3 PiM0<=>PiM2+PiM3
    <- cxt-remove-unique-no-effect-on-capmap2perm B0+M0=>PiM0 B0+M3=>PiM3
      S+FS=>M2 M0-M2=M3 B0-S=B1 B1+M3=>PiM3
    <- wf-clsmap-lookup-implies-non-empty WF-CM CML _ SZ-FM
    <- fldmap`domain-preserves-size SZ-FM DM-FM=FS SZ-FS
    <- cxt-unique-objset-implies-same-class CM-B0-S SOC
    <- cxt-unique-objset-implies-least-nonnull CM-B0-S FLN
    <- restore-object-permission SOC CM2PM CML DM-FM=FS SZ-FS B0-ME S+FS=>M2 B0+M2=>PiM2
      PiS PiM2+Pi<=>PiS B0-S-PiS
    <- make-before-write-format/L1 B0-S-PiS FLN B0+S=>GF T2PF _ IMP
    <- capmap-min-unique MI-M1=X MI-M1=W cap`eq/ capmap`eq/ (X=W:cap`eq Xx cap/write)
    <- cap2frac-unique X=>Q cap2frac/write X=W Q=ONE
    <- make-before-write-format/L2 Q=ONE EQV2.

- : make-before-write-format _ _ CM-B-Rslt
    (subtype/ nat`eq/ _ _ _  (sub-annot-cap/shared2shared))
    (result2output/shared T2PF B=>PiB M=>PiM)
    %{=>}% _
    (transform/reflexive) (before-write-format/expr B=>PiB M=>PiM reftype2ty/shared T2PF).

- : make-before-write-format WF-CM CM2PM
    (clsmap-result/expr _
      (clsmap-cxt-reftype/unique _ CM-B0-S _ _) CM-B0-M0)
    (subtype/ nat`eq/ NN-LEQ CML (DM-FM=FS:fldmap`domain FM FS)
      (sub-annot-cap/consume (S+FS=>M2:set+set2capmap S FS _ M2)
        (M0-M2=M3:capmap-split M0 M2 M3) MI-M1=W
        (B0-S=B1:cxt-remove-unique B0 S B1)))
    (result2output/unique/1 SZ-S SZ-M1 (ty2perm/ (PML:predmap`lookup PM _ CP) _ _)
      ([x] B0+S=>GF x)
      (B0=>PiB0:cxt2perm CM PM B0 PiB0) (B0+M0=>PiM0:capmap2perm CM PM B0 M0 PiM0))
    %{=>}% _
    (transform/inside [x]
      (transform/trans
        (transform/implies
          (implies/trans7
            (implies/combine (implies/equiv EQV)
              (implies/combine implies/reflexive
                (implies/combine implies/reflexive (implies/equiv PiM0<=>PiM2+PiM3))))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/equiv
              (equiv/transitive3
                (equiv/roll5)
                (equiv/combine equiv/reflexive equiv/roll2)
                (equiv/associate)))
            (implies/combine (PiM2+Pi<=>PiS) implies/reflexive)
            (implies/equiv
              (equiv/transitive3
                (equiv/combine equiv/reflexive equiv/roll3)
                (equiv/associate)
                (equiv/combine equiv/commute equiv/reflexive)))
            (implies/combine
              (implies/trans
                (IMP2 x)
                (implies/combine
                  (implies/equiv (EQV2 x))
                  (implies/reflexive)))
              (implies/reflexive))
            (implies/equiv
              (equiv/transitive5
                (equiv/symmetric equiv/associate)
                (equiv/roll4)
                (equiv/combine equiv/reflexive equiv/roll2)
                (equiv/associate)
                (equiv/combine equiv/reflexive equiv/roll2)))))
        (transform/drop)))
    (before-write-format/expr (B1=>PiB1:cxt2perm CM PM B1 PiB1)
      (B1+M3=>PiM3:capmap2perm CM PM B1 M3 PiM3) reftype2ty/unique
      (ty2perm/ PML2 NN2P A2P))
    <- cxt-remove-unique-implies-make-encumbered B0-S=B1 B0=>PiB0 PiB1 Pi B1=>PiB1 B0-ME EQV
    <- capmap-split-implies-permission-combine
      M0-M2=M3 B0+M0=>PiM0 PiM2 PiM3 B0+M2=>PiM2 B0+M3=>PiM3 PiM0<=>PiM2+PiM3
    <- cxt-remove-unique-no-effect-on-capmap2perm B0+M0=>PiM0 B0+M3=>PiM3
      S+FS=>M2 M0-M2=M3 B0-S=B1 B1+M3=>PiM3
    <- wf-clsmap-lookup-implies-non-empty WF-CM CML _ SZ-FM
    <- fldmap`domain-preserves-size SZ-FM DM-FM=FS SZ-FS
    <- cxt-unique-objset-implies-same-class CM-B0-S SOC
    <- cxt-unique-objset-implies-least-nonnull CM-B0-S FLN
    <- restore-object-permission SOC CM2PM CML DM-FM=FS SZ-FS B0-ME S+FS=>M2 B0+M2=>PiM2
      PiS PiM2+Pi<=>PiS S-PiS
    <- ({x} set-all-permissions-implies _ SZ-S S-PiS (B0+S=>GF x) FLN _
         (ty2perm/ (PMLP x) (NN2P:nn2perm _ _ PF) A2P) _ (IMP2 x))
    <- predmap`no-variable-lookup PMLP CP2 PML2 PEQ
    <- make-before-write-format/L3 PF PEQ EQV2.

%worlds (objvar) (make-before-write-format _ _ _ _ _ _ _ _).
%total (T) (make-before-write-format _ _ _ _ T _ _ _).


%theorem subtype-implies-ty2perm-leq
  : forall* {CM} {PM} {RT} {V} {T1} {PF1} {NN2} {A2} {C2} {B} {M}
    forall {SUB: subtype CM RT V (ty/ NN2 A2 C2) (env/ B M)}
    {RT=>T: reftype2ty RT T1}
    {T1=>PF1: ty2perm PM T1 PF1}
    exists {PF2} {T2=>PF2: ty2perm PM (ty/ NN2 A2 C2) PF2}
    {IMP: {x} implies (PF1 x) (PF2 x)}
    true.

%worlds (objvar) (subtype-implies-ty2perm-leq _ _ _ _ _ _).
%trustme %total { } (subtype-implies-ty2perm-leq _ _ _ _ _ _).


%theorem subtype-implies-ty2perm-leq*
  : forall* {CM} {PM} {RT} {V} {T1} {PF1} {PF2} {NN2} {A2} {C2} {B} {M}
    forall {SUB: subtype CM RT V (ty/ NN2 A2 C2) (env/ B M)}
    {RT=>T: reftype2ty RT T1}
    {T1=>PF1: ty2perm PM T1 PF1}
    {T2=>PF2: ty2perm PM (ty/ NN2 A2 C2) PF2}
    exists {IMP: {x} implies (PF1 x) (PF2 x)}
    true.

%worlds (objvar) (subtype-implies-ty2perm-leq* _ _ _ _ _).
%trustme %total { } (subtype-implies-ty2perm-leq* _ _ _ _ _).


%%% This should be the final theorem
%%% B0 is the output context for checking E1,

%theorem do-write
  : forall* {CM} {PM} {W} {RT} {B1} {B2} {M} {M1} {M2} {M3} {M4} {NN} {A} {FC}
    {G2} {PiB0} {PiM} {PiM1} {PiM1'} {E2} {F} {PF} {Out}
    forall {B2+M1=>Pi2: capmap2perm CM PM B2 M1 PiM1'}
    {BF-READ-FMT: read-format CM PM B2 (targets/unique set/0 M) M1 PiM PiM1 (fraction/ one)}
    {SUB: subtype CM RT (env/ B1 M2) (ty/ NN A FC) (env/ B2 M3)}
    {T2PF: ty2perm PM (ty/ NN A FC) ([x] PF x)}
    {TYP-E2: typing W (PiB0 , PiM1') E2 Out}
    {BW-FMT: before-write-format CM PM (result/expr RT (env/ B2 M3)) Out}
    {CF: consider-ftype (targets/unique set/0 M) M3 A G2 M4}
    exists {Out1}
    {TYP: {x} typing W (combine PiB0 (combine (ffperm (fraction/ one) x F PF)
      (combine (unitperm (encumbered (ffperm (fraction/ one) x F PF) PiM)) PiM1)))
      (write (lit x) F E2) Out1}
    {R=>Out1: result2output CM PM (result/expr (reftype/ NN FC G2) (env/ B2 M4)) Out1}
    true.

- : do-write (B2+M1=>PiM1':capmap2perm CM PM B2 M1 PiM1')
    (read-format/ (SZ-M:capmap`size M (s _))
      (B2+M1=>PiM1:capmap2perm CM PM B2 M1 PiM1)
      (B2+M=>PiM:capmap2perm CM PM B2 M PiM)
      (MC-M=X:capmap-min M Xx)
      (X=>Q))
    SUB (T2PF:ty2perm PM _ ([x] PF x)) (TYP-E2:typing W (PiB0 , PiM1') E2 _)
    (before-write-format/expr
      (B2=>PiB2:cxt2perm CM PM B2 PiB2)
      (B2+M3=>PiM3:capmap2perm CM PM B2 M3 PiM3) RT2T T2PF2)
    (consider-ftype/shared (capmap-split/ M^M3 M+M3=M4)) %{=>}% _
    ([x] tTrans
      (transform/implies
        (implies/equiv
          (equiv/transitive5
            (equiv/combine equiv/reflexive % piB0
              (equiv/combine equiv/reflexive equiv/commute)) % PF
            (equiv/roll3)
            (equiv/associate)
            (equiv/combine
              (equiv/transitive
                (equiv/commute)
                (equiv/combine equiv/reflexive PiM1<=>PiM1'))
              (equiv/reflexive))
            (equiv/commute))))
      (letTyping/base null
        (tWrite2 (TYP-E2' x)
          (letTyping/exists [o]
            (letTyping/base o
              (tTrans
                (transform/trans3
                  (transform/implies
                    (implies/equiv
                      (equiv/symmetric equiv/associate)))
                  (transform/skolem)
                  (transform/inside [o']
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine equiv/one equiv/reflexive)
                          (equiv/symmetric equiv/associate))))))
                (letTyping/exists [o']
                  (letTyping/base null
                    (tWrite: typing _ _ (write (lit x) F (lit o)) _)))
                (transform/trans
                  (transform/inside [o']
                    (transform/trans
                      (transform/implies
                        (implies/trans
                          (implies/equiv equiv/roll2)
                          (implies/combine implies/reflexive
                            (implies/trans7
                              (implies/combine implies/reflexive
                                (implies/equiv equiv/roll3))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans3
                                  (implies/combine implies/reflexive
                                    (implies/trans (IMP o) (DUP o)))
                                  (implies/equiv equiv/associate)
                                  (implies/equiv equiv/commute))
                                (implies/reflexive))
                              (implies/equiv (equiv/symmetric equiv/associate))
                              (implies/combine implies/reflexive
                                (implies/trans3
                                  (implies/combine
                                    (implies/pack o)
                                    (implies/combine
                                      (implies/equiv-encumbered
                                        (equiv/one) (equiv/reflexive))
                                      (implies/reflexive)))
                                  (implies/equiv equiv/associate)
                                  (implies/combine
                                    (implies/linear-modus-ponens)
                                    (implies/reflexive))))
                              (implies/equiv equiv/roll3)
                              (implies/combine implies/reflexive
                                (implies/combine implies/reflexive
                                  (implies/equiv PiM+PiM3<=>PiM4)))))))
                      (transform/drop)))
                  (transform/rem-unused)))))))
      (transform/reflexive))
    (result2output/shared T2PF B2=>PiB2 B2+M4=>PiM4)
    <- capmap2perm-equiv B2+M1=>PiM1 B2+M1=>PiM1' clsmap`eq/
      predmap`eq/ cxt`eq/ capmap`eq/ PiM1<=>PiM1'
    <- ({o:object} typing-frame* TYP-E2 (envadd/exists [x] envadd/expr) (TYP-E2' o))
    <- subtype-implies-ty2perm-leq* SUB RT2T T2PF2 T2PF IMP
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- capmap-split-implies-permission-combine-converse
      (capmap-split/ M^M3 M+M3=M4) B2+M=>PiM B2+M3=>PiM3 PiM4 B2+M4=>PiM4
      PiM+PiM3<=>PiM4.

- : do-write (B2+M1=>PiM1':capmap2perm CM PM B2 M1 PiM1')
    (read-format/ (SZ-M:capmap`size M (s _))
      (B2+M1=>PiM1:capmap2perm CM PM B2 M1 PiM1)
      (B2+M=>PiM:capmap2perm CM PM B2 M PiM)
      (MC-M=X:capmap-min M Xx)
      (X=>Q))
    SUB (T2PF:ty2perm PM _ ([x] PF x)) (TYP-E2:typing W (PiB0 , PiM1') E2 _)
    (before-write-format/expr
      (B2=>PiB2:cxt2perm CM PM B2 PiB2)
      (B2+M3=>PiM3:capmap2perm CM PM B2 M3 PiM3)
      RT2T
      T2PF2)
    consider-ftype/unique %{=>}% _
    ([x] tTrans
      (transform/implies
        (implies/equiv
          (equiv/transitive5
            (equiv/combine equiv/reflexive % piB0
              (equiv/combine equiv/reflexive equiv/commute)) % PF
            (equiv/roll3)
            (equiv/associate)
            (equiv/combine
              (equiv/transitive
                (equiv/commute)
                (equiv/combine equiv/reflexive PiM1<=>PiM1'))
              (equiv/reflexive))
            (equiv/commute))))
      (letTyping/base null
        (tWrite2 (TYP-E2' x)
          (letTyping/exists [o]
            (letTyping/base o
              (tTrans
                (transform/trans3
                  (transform/implies
                    (implies/equiv
                      (equiv/symmetric equiv/associate)))
                  (transform/skolem)
                  (transform/inside [o']
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine equiv/one equiv/reflexive)
                          (equiv/symmetric equiv/associate))))))
                (letTyping/exists [o']
                  (letTyping/base null
                    (tWrite: typing _ _ (write (lit x) F (lit o)) _)))
                (transform/trans
                  (transform/inside [o']
                    (transform/trans
                      (transform/implies
                        (implies/trans5
                          (implies/combine
                            (implies/trans3
                              (implies/equiv (equiv/symmetric equiv/identity))
                              (implies/combine
                                (implies/reflexive)
                                (implies/trans
                                  (implies/gen-pack-encumber o)
                                  (implies/combine-assoc-encumbered)))
                              (implies/linear-modus-ponens))
                            (implies/equiv equiv/roll2))
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/trans
                              (implies/combine implies/reflexive
                                (implies/equiv-encumbered equiv/one equiv/reflexive))
                              (implies/chain-implication))
                            (implies/reflexive))
                          (implies/equiv equiv/roll2)
                          (implies/combine implies/reflexive
                            (implies/trans6
                              (implies/combine implies/reflexive
                                (implies/equiv equiv/roll2))
                              (implies/equiv equiv/roll2)
                              (implies/combine (IMP o) implies/reflexive)
                              (implies/equiv equiv/roll3)
                              (implies/combine
                                (implies/trans
                                  (implies/equiv (equiv/symmetric equiv/identity))
                                  (implies/combine implies/reflexive
                                    (gen-objequal-self-cond o)))
                                (implies/combine
                                  (implies/equiv (equiv/symmetric equiv/one))
                                  (implies/combine
                                    (implies/equiv-encumbered
                                      (equiv/symmetric equiv/one)
                                      (equiv/reflexive))
                                    (implies/reflexive))))
                              (implies/equiv (equiv/symmetric equiv/associate))))))
                      (transform/drop)))
                  (transform/rem-unused)))))))
      (transform/inside [o] transform/gen-exists o))
    (result2output/unique/2 SZ-M T2PF ([_] set2cond/0)
      B2=>PiB2 B2+M3=>PiM3 B2+M=>PiM MC-M=X X=>Q)
    <- capmap2perm-equiv B2+M1=>PiM1 B2+M1=>PiM1' clsmap`eq/
      predmap`eq/ cxt`eq/ capmap`eq/ PiM1<=>PiM1'
    <- ({o:object} typing-frame* TYP-E2 (envadd/exists [x] envadd/expr) (TYP-E2' o))
    <- subtype-implies-ty2perm-leq* SUB RT2T T2PF2 T2PF IMP.

%worlds (objvar) (do-write _ _ _ _ _ _ _ _ _ _).
%total { } (do-write _ _ _ _ _ _ _ _ _ _).