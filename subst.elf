%%% Explicit Substitution

%abbrev shared-tgt = nat`z.


%%% Definitions

%%% First, some utility definitions

%%% Whether the given (obj,fld) pair has the object index.

match-index? : nat -> nat -> bool -> type.

match-index?/yes : nat2pair K (pair/ N _) -> match-index? K N true.

match-index?/no
  : nat2pair K (pair/ N' _)
    -> nat`ne N N'
    -> match-index? K N false.


%% From the field target set, select those whose object
%% index is the given nat.

select-to-substitute : set -> nat -> set -> type.

select-to-substitute/0 : select-to-substitute set/0 _ set/0.

select-to-substitute/in
  : select-to-substitute S' N R'
    -> match-index? N K true
    -> set`fresh S' K
    -> set`add S' K S
    -> set`add R' K R
    -> select-to-substitute S N R.

select-to-substitute/out
  : select-to-substitute S' N R
    -> match-index? N K false
    -> set`fresh S' K
    -> set`add S' K S
    -> select-to-substitute S N R.



%%% A property that ALL targets in the efxmap are coming from the
%%%  same object

efxmap-same-object : efxmap -> nat -> type.

efxmap-same-object/0 : efxmap-same-object efxmap/0 _.

efxmap-same-object/U
  : efxmap-same-object MP N
    -> match-index? K N true
    -> efxmap`fresh MP K
    -> efxmap`update MP K _ M
    -> efxmap-same-object M N.


%%% Given a set of (obj,fld) pairs, map it to a set of flds.

set-map-fields : set -> set -> type.

set-map-fields/0 : set-map-fields set/0 set/0.

set-map-fields/U : set-map-fields Sin' Sout'
                   -> nat2pair K (pair/ _ F)
                   -> set`fresh Sin K
                   -> set`add Sin' K Sin
                   -> set`add Sout' F Sout
                   -> set-map-fields Sin Sout.

%% Same OP for efxmap

efxmap-map-fields : efxmap -> efxmap -> type.

efxmap-map-fields/0 : efxmap-map-fields efxmap/0 efxmap/0.

efxmap-map-fields/U : efxmap-map-fields Min' Mout'
                    -> nat2pair K (pair/ _ F)
                    -> efxmap`fresh Min' K
                    -> efxmap`update Min' K X Min
                    -> efxmap`update Mout' F X Mout
                    -> efxmap-map-fields Min Mout.


set-map-objects : set -> set -> type.

set-map-objects/0 : set-map-objects set/0 set/0.

set-map-objects/U : set-map-objects Sin' Sout'
                    -> nat2pair K (pair/ N _)
                    -> set`fresh Sin K
                    -> set`add Sin' K Sin
                    -> set`add Sout' N Sout
                    -> set-map-objects Sin Sout.


efxmap-map-objects : efxmap -> set -> type.

efxmap-map-objects/0 : efxmap-map-objects efxmap/0 set/0.

efxmap-map-objects/U : efxmap-map-objects Min' Sout'
                    -> nat2pair K (pair/ N _)
                    -> efxmap`fresh Min' K
                    -> efxmap`update Min' K _ Min
                    -> set`add Sout' N Sout
                    -> efxmap-map-objects Min Sout.


%%% Substitution for Object Target Set

% Given an object target set `gs`, replace the occurrence of
% an object index `n` (if it exist) with given targets `gs1`.
% Return substituted targets `gs'` where all occurences of the
% index `n` has been replaced by `gs1`.
%  `targets`: the targets used for substitution
%  `nat`: the index of object to substitute
%  `set`: the set of object targets to substitute
%  `targets`: the result targets

% Don't need recursion

subst-object-set : targets -> nat -> set -> set -> set -> type.

subst-object-set/in
  : set`not-member OS' N
    -> set`add OS' N OS
    -> set`union S OS' OSout
    -> subst-object-set (targets/unique S FS) N OS OSout FS.

subst-object-set/out : set`not-member S N -> subst-object-set _ N S S set/0.


%%% Substitution for Field Target Set

% Given an field target set `gs`, replace all occurences of
% an object index `n` with given unique targets `gs1`.
% Return substituted set `s'` where all occurences of the
% index `n` has been replaced by targets in `gs1`.
%  `targets`: the targets used for substitution
%  `nat`: the index of object to substitute
%  `set`: the set of field targets to substitute
%  `set`: the result set

subst-field-set : targets -> nat -> set -> set -> type.

subst-field-set/out
  : subst-field-set _ N S S
    <- select-to-substitute S N set/0. % no occurrence

subst-field-set/in
  : select-to-substitute FG N FGin
    -> set`size FGin (s _)
    -> set`remove FG FGin FGout
    -> set-map-fields FGin FSin
    -> set+set2set S FSin FS2
    -> set`union FS2 S2 FS3
    -> set`union FS3 FGout R
    -> subst-field-set (targets/unique S S2) N FG R.


% Substitution for Targets

%  `targets`: the targets used for substitution.
%  `nat`: the index of object we are looking to substitute
%  `targets`: the targets to substitute
%  `targets`: the result targets

subst-targets : targets -> nat -> targets -> targets -> type.

subst-targets/shared : subst-targets _ N targets/shared targets/shared.

% if targets to substitute is unique, then if x occurs in object
% targets, then we need to remove it and add a shared target in field
% target set. If x occur in field target set, then we need to remove it
% and add a shared target into the same set.

subst-targets/shared/unique
  : subst-object-set (targets/unique set/0 (set/1 shared-tgt)) N R OS FS1
    -> subst-field-set (targets/unique set/0 (set/1 shared-tgt)) N R2 FS2
    -> set`union FS1 FS2 FS
    -> subst-targets targets/shared N
      (targets/unique R R2) (targets/unique OS FS).

% If both targets are unique, we need to do the explicit substitution:
% we first replace all occurences of parameter `nat` in the object set
% of the `targets` to be substituted, and then replace all occurences
% of parameter `nat` in the field set of that targets. Finally, we
% set the bool flag for shared.

subst-targets/unique/unique
  : subst-object-set (targets/unique S S2) N R OS FS1 ->
    subst-field-set (targets/unique S S2) N R2 FS2 ->
    set`union FS1 FS2 FS ->
    subst-targets (targets/unique S S2) N
    (targets/unique R R2) (targets/unique OS FS).


% Substitution for Effects

efxmap-partition-on-index : efxmap -> nat -> efxmap -> efxmap -> type.

efxmap-partition-on-index/
  : efxmap`domain M S ->
    select-to-substitute S N Sin ->
    efxmap`partition M Sin Mout Min ->
      efxmap-partition-on-index M N Mout Min.


subst-efxmap : targets -> nat -> efxmap -> efxmap -> type.

subst-efxmap/
  : efxmap-partition-on-index M N Mout Min
    -> efxmap-map-fields Min MFin
    -> set+map2map S MFin M1
    -> efxmap-max-efx Min X
    -> set2efxmap S2 X M2
    -> efxmap`join M1 M2 M3
    -> efxmap`join M3 Mout M4
    -> subst-efxmap (targets/unique S S2) N M M4.

% subst-efxmap/out
%   : efxmap-map-objects M OS
%     -> set`not-member OS N
%     -> subst-efxmap (targets/unique S S2) N M M.

subst-effects : clsmap -> cxt -> targets -> nat -> effects -> effects -> type.

% the case when N is in efxmap

% subst-effects/unique
%   : compatible CM B (targets/unique S S2) (effects/ M R Q)
%     -> subst-efxmap (targets/unique S S2) N M M'
%     -> subst-object-set (targets/unique S S2) N Q Q1 R1
%     -> subst-field-set (targets/unique S S2) N R R2
%     -> set`union R1 R2 R3
%     -> subst-effects CM B
%       (targets/unique S S2) N (effects/ M R Q) (effects/ M' R3 Q1).

subst-effects/unique/1
  : compatible CM B (targets/unique S S2) (effects/ M R Q)
    -> set-map-objects R OS
    -> efxmap-map-objects M MS
    -> set`member MS N
    -> set`not-member OS N
    -> set`not-member Q N
    -> subst-efxmap (targets/unique S S2) N M M'
    -> subst-effects CM B (targets/unique S S2) N (effects/ M R Q) (effects/ M' R Q).


subst-effects/shared1
  : subst-efxmap (targets/unique set/0 (set/1 shared-tgt)) N M M'
    -> subst-object-set (targets/unique set/0 (set/1 shared-tgt)) N Q Q1 R1
    -> subst-field-set (targets/unique set/0 (set/1 shared-tgt)) N R R2
    -> set`union R1 R2 R3
    -> subst-effects CM B targets/shared N (effects/ M R Q)
      (effects/ M' R3 Q1).


%%% Theorems

%% theorems about match-index?

%theorem match-index?-respects-eq
  : forall* {K} {K0} {N} {N0} {B} {B0}
    forall {M: match-index? K N B}
    {KE: nat`eq K K0} {NE: nat`eq N N0} {BE: bool`eq B B0}
    exists {M0: match-index? K0 N0 B0}
    true.

- : match-index?-respects-eq M nat`eq/ nat`eq/ bool`eq/ M.

%worlds (objvar) (match-index?-respects-eq _ _ _ _ _).
%total { } (match-index?-respects-eq _ _ _ _ _).


%% theorems about efxmap-same-object

%theorem false-implies-efxmap-same-object :
	forall*	{M} {X}
	forall	{F: void}
	exists	{A: efxmap-same-object M X}
	true.

%worlds (objvar) (false-implies-efxmap-same-object _ _).
%total { } (false-implies-efxmap-same-object _ _).


%theorem efxmap-same-object-respects-eq :
	forall*	{M1} {X1} {M2} {X2}
	forall	{A1: efxmap-same-object M1 X1}
		{ME: efxmap`eq M1 M2}
		{XE: nat`eq X1 X2}
	exists	{A2: efxmap-same-object M2 X2}
	true.

- : efxmap-same-object-respects-eq A _ _ A.

%worlds (objvar) (efxmap-same-object-respects-eq _ _ _ _).
%total { } (efxmap-same-object-respects-eq _ _ _ _).


%theorem efxmap-same-object/U-inversion :
	forall*	{M1} {M2} {X} {N} {D}
	forall	{A2: efxmap-same-object M2 X}
		{F: efxmap`fresh M1 N}
		{U: efxmap`update M1 N D M2}
	exists	{A1: efxmap-same-object M1 X}
		{R: match-index? N X true}
	true.

%theorem efxmap-same-object/U-inversion/L :
	forall*	{N0} {D0} {M0} {X} {N} {D} {B} {M1} {M2}
	forall	{A0: efxmap-same-object M0 X}
		{R1: match-index? N0 X true}
		{F0: efxmap`fresh M0 N0}
		{U0: efxmap`update M0 N0 D0 M2}
		{F1: efxmap`fresh M1 N}
		{U1: efxmap`update M1 N D M2}
		{EQ?: nat`eq? N N0 B}
	exists	{A1: efxmap-same-object M1 X}
		{R: match-index? N X true}
	true.

- : efxmap-same-object/U-inversion/L A0 R0 F0 U0 F1 U1 nat`eq?/yes A1 R0
    <- efxmap`fresh-update-cancels F0 U0 F1 U1 nat`eq/ efxmap`eq/ D0=D1 M0=M1
    <- efxmap-same-object-respects-eq A0 M0=M1 nat`eq/ A1.

- : efxmap-same-object/U-inversion/L
	A0 R0 F0 U0 F1 U1 (nat`eq?/no N<>N1) (efxmap-same-object/U A2 R0 F3 U3) R1
    <- efxmap`update-commutes-converse U1 U0 N<>N1 _ U3 U2
    <- efxmap`update-preserves-fresh-converse F1 U3 F2
    <- efxmap-same-object/U-inversion A0 F2 U2 A2 R1
    <- efxmap`update-preserves-fresh-converse F0 U2 F3.

- : efxmap-same-object/U-inversion (efxmap-same-object/U A0 R0 F0 U0) F U A1 R
    <- nat`eq?-total EQ?
    <- efxmap-same-object/U-inversion/L A0 R0 F0 U0 F U EQ? A1 R.

%worlds (objvar) (efxmap-same-object/U-inversion _ _ _ _ _)
  (efxmap-same-object/U-inversion/L _ _ _ _ _ _ _ _ _).
%total (A B) (efxmap-same-object/U-inversion A _ _ _ _)
  (efxmap-same-object/U-inversion/L B _ _ _ _ _ _ _ _).


%theorem efxmap-map-objects-total*
  : forall {M}
    exists {OS} {M-OS: efxmap-map-objects M OS}
    true.

%worlds () (efxmap-map-objects-total* _ _ _).
%trustme %total {} (efxmap-map-objects-total* _ _ _).

%abbrev efxmap-map-objects-total = efxmap-map-objects-total* _ _.


%theorem efxmap-map-objects-unique
  : forall* {M} {MP} {OS} {OSP}
    forall {M->OS: efxmap-map-objects M OS}
    {MP->OSP: efxmap-map-objects MP OSP}
    {M=MP: efxmap`eq M MP}
    exists {OS=OSP: set`eq OS OSP}
    true.

%worlds () (efxmap-map-objects-unique _ _ _ _).
%trustme %total { } (efxmap-map-objects-unique _ _ _ _).


%theorem efxmap-map-objects-respects-eq
  : forall* {M} {MP} {S} {SP}
    forall {MOS: efxmap-map-objects M S}
    {ME: efxmap`eq M MP} {SE: set`eq S SP}
    exists {MOS: efxmap-map-objects MP SP}
    true.

- : efxmap-map-objects-respects-eq MOS efxmap`eq/ set`eq/ MOS.

%worlds () (efxmap-map-objects-respects-eq _ _ _ _).
%total { } (efxmap-map-objects-respects-eq _ _ _ _).


%theorem efxmap-map-objects-empty-implies-empty
  : forall* {M}
    forall {MOS: efxmap-map-objects M set/0}
    exists {ME: efxmap`eq M efxmap/0}
    true.

- : efxmap-map-objects-empty-implies-empty efxmap-map-objects/0 efxmap`eq/.

%worlds () (efxmap-map-objects-empty-implies-empty _ _).
%total { } (efxmap-map-objects-empty-implies-empty _ _).


%theorem set-map-objects-total*
  : forall {S}
    exists {OS} {S-OS: set-map-objects S OS}
    true.

%worlds () (set-map-objects-total* _ _ _).
%trustme %total {} (set-map-objects-total* _ _ _).

%abbrev set-map-objects-total = set-map-objects-total* _ _.


%theorem subst-object-set-no-change
  : forall* {OS} {GS} {N} {S} {FS}
    forall {SUB: subst-object-set GS N S OS FS}
    {NM: set`not-member S N}
    exists {EQ: set`eq OS S} {EQ: set`eq FS set/0}
    true.

%worlds () (subst-object-set-no-change _ _ _ _).
%trustme %total { } (subst-object-set-no-change _ _ _ _).


%theorem subst-field-set-no-change
  : forall* {S} {GS} {N} {FS} {SS}
    forall {SUB: subst-field-set GS N S FS}
    {S-SS: set-map-objects S SS}
    {NM: set`not-member SS N}
    exists {EQ: set`eq FS S}
    true.

%worlds () (subst-field-set-no-change _ _ _ _).
%trustme %total { } (subst-field-set-no-change _ _ _ _).


%theorem efxmap-map-fields-total*
  : forall {M} exists {MF} {MP: efxmap-map-fields M MF} true.

%abbrev efxmap-map-fields-total = efxmap-map-fields-total* _ _.

%worlds () (efxmap-map-fields-total* _ _ _).
%trustme %total { } (efxmap-map-fields-total* _ _ _).


%theorem efxmap-map-fields-implies-nat+map2map
  : forall* {M} {N} {MF}
    forall {M=>MF: efxmap-map-fields M MF}
    {M-N: efxmap-same-object M N}
    exists {N+MF=M: nat+map2map N MF M}
    true.

%worlds () (efxmap-map-fields-implies-nat+map2map _ _ _).
%trustme %total {} (efxmap-map-fields-implies-nat+map2map _ _ _).


%theorem efxmap-map-fields-preserves-size
  : forall* {M} {MF} {N}
    forall {DM: efxmap`size M N}
    {MP: efxmap-map-fields M MF}
    exists {DM: efxmap`size MF N}
    true.

%worlds () (efxmap-map-fields-preserves-size _ _ _).
%trustme %total {} (efxmap-map-fields-preserves-size _ _ _).
