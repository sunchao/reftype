%%% Explicit Substitution

%%% Definitions

%abbrev empty-target = (targets/unique set/0 set/0).

% Union two targets together - this is simply
% union of corresponding parts (set,bool) for the two targets.

targets`union : targets -> targets -> targets -> type.

targets`union/
  : set`union S1 R1 SR1
    -> set`union S2 R2 SR2
    -> bool`or SB RB SRB
    -> targets`union (targets/unique S1 S2) (targets/unique R1 R2 RB)
      (targets/unique SR1 SR2 SRB).


% Given an object target set `gs`, replace the occurrence of
% an object index `n` (if it exist) with given targets `gs1`.
% Return substituted targets `gs'` where all occurences of the
% index `n` has been replaced by `gs1`.
%  `targets`: the targets used for substitution
%  `nat`: the index of object to substitute
%  `set`: the set of object targets to substitute
%  `targets`: the result targets

% Don't need recursion

extend-set : targets -> nat -> set -> targets -> type.

extend-set/0 : extend-set _ _ set/0 empty-target.

extend-set/in
  : set`not-member S' N
    -> set`add S' N S
    -> targets`union GS (targets/unique S' set/0 false) GS1
    -> extend-set GS N S GS1.

extend-set/out
  : set`not-member S N
    -> extend-set _ N S (targets/unique S set/0 false).


% Given an field target set `gs`, replace all occurences of
% an object index `n` with given targets `gs1`.
% Return substituted targets `gs'` where all occurences of the
% index `n` has been replaced by `gs1`.
%  `targets`: the targets used for substitution
%  `nat`: the index of object to substitute
%  `set`: the set of field targets to substitute
%  `targets`: the result targets

extend-set2 : targets -> nat -> set -> targets -> type.

extend-set2/0 : extend-set2 _ _ set/0 empty-target.

extend-set2/U/in
  : extend-set2 (targets/unique S S2 SB) N R' GS2
    -> nat2pair K (pair/ N' F)
    -> nat`eq N N'
    -> set+nat2set S F S'
    -> set`union S' S2 S3
    -> targets`union (targets/unique set/0 S3 SB) GS2 GS3
    -> set`not-member R' K
    -> set`add R' K R
    -> extend-set2 (targets/unique S S2 SB) N R GS3.

extend-set2/U/out
  : extend-set2 GS1 N R' GS2
    -> nat2pair K (pair/ N' F)
    -> nat`ne N N'
    -> targets`union GS1 (targets/unique set/0 (set/1 K) false) GS2
    -> set`not-member R' K
    -> set`add R' K R
    -> extend-set2 GS1 N R GS3.


% substitution for targets
%  `targets`: the targets used for substitution.
%  `nat`: the index of object we are looking to substitute
%  `targets`: the targets to substitute
%  `targets`: the result targets

subst-targets : targets -> nat -> targets -> targets -> type.

% If the targets used for substitution is shared, we don't need
% to do anything, since shared targets only represent some facts.

subst-targets/shared : subst-targets targets/shared N GS GS.

% If the targets used for substitution is unique, while the targets
% to substitute is shared, we don't need to anything either, since
% the object we are looking for will not occur in shared targets.

subst-targets/unique/shared
  : subst-targets (targets/unique _ _ _) _ targets/shared targets/shared.

% If both targets are unique, we need to do the explicit substitution:
% we first replace all occurences of parameter `nat` in the object set
% of the `targets` to be substituted, and then replace all occurences
% of parameter `nat` in the field set of that targets. Finally, we
% set the bool flag for shared.

subst-targets/unique/unique
  : extend-set (targets/unique S S2 SB) N R GS1
    -> extend-set2 (targets/unique S S2 SB) N R2 GS2
    -> targets`union GS1 GS2 GS3
    -> targets`union GS3 (targets/unique set/0 set/0 RB) GS
    -> subst-targets (targets/unique S S2 SB) N (targets/unique R R2 RB) GS.


% subst-effects

% Replace all occurences of an object index `n` in the efxmap `xm`
% with given targets `gs`. Return effects, since the targets `gs`
% might contain shared, in which case the result will contain effects
% on shared.
%  `targets`: the targets used for substitution
%  `nat`: the object index
%  `efxmap`: the efxmap to substitute
%  `effects`: the result effects

extend-efxmap : targets -> nat -> efxmap -> effects -> type.

extend-efxmap/0 : extend-efxmap _ _ efxmap/0 no-effect.

% If `(n',f)` is in the keyset of the map, and input object index `n`
% is equal to `n'`, then we need to do the hard work of substitution:
%
% first, we find the set of all object targets associated with `n`,
% and "extend" the set with `f`, we then union this resulting set with
% the set of all field targets associated with `n`, and converting the
% resulting set to a efxmap, using the efx (value) `x` corresponds to
% the key `(n',f)` in the original map.
%
% We also need to consider the case that the targets contain shared.
% If so, we put a shared-efx in the resulting effects.

% TODO: think to make it more modular
extend-efxmap/U/in : extend-efxmap (targets/unique S S2 SB) N M' XX'
                     -> efxmap`fresh M' K
                     -> efxmap`update M' K X M
                     -> nat2pair K (pair/ N' F)
                     -> nat`eq N N'
                     -> set+nat2set S F S'
                     -> set`union S' S2 S3
                     -> set2efxmap S3 X M3
                     -> efxmap`join M' M3 MO
                     -> create-shared-efx X SX'
                     -> efx-on-shared SB SX' SX
                     -> effects`join XX' (effects/ MO set/0 SX set/0) XX
                     -> extend-efxmap (targets/unique S S2 SB) N M XX.

% If `(n',f)` is in the keyset of the map, and input object index `n`
% is NOT equal to `n'`, then things are easy: we produce intermediate
% effects which only contain a singleton map consists of key `(n',f)`
% and its associated efx, and union this effects with the rest of result.

extend-efxmap/U/out : extend-efxmap GS N M' XX'
                     -> efxmap`fresh M' K
                     -> efxmap`update M' K X M
                     -> nat2pair K (pair/ N' F)
                     -> nat`ne N N'
                     -> effects`join XX' (effects/ (efxmap/+ K X efxmap/0)
                                           set/0 shared-efx/none set/0) XX
                     -> extend-efxmap GS N M XX.


% extending the "whole consume object" set.

efx-extend-set : targets -> nat -> set -> effects -> type.

efx-extend-set/0 : efx-extend-set _ _ set/0 no-effect.

efx-extend-set/U/in
  : set`not-member R' N
    -> set`add R' N R
    -> set`union S R' SR
    -> efx-extend-set (targets/unique S S2 false) N R
      (effects/ efxmap/0 S2 shared-efx/none SR).

efx-extend-set/U/out
  : set`not-member R N
    -> efx-extend-set _ N R (effects/ efxmap/0 set/0 shared-efx/none R).


% Replace occurences of a given object index in a consumed
% field target set with targets.

efx-extend-set2 : targets -> nat -> set -> effects -> type.

efx-extend-set2/0 : efx-extend-set2 _ _ set/0 no-effect.

% it's possible here that we consume S2 multiple times, but it
% should be OK, since we could consume a.f.h1 and a.f.h2 even
% though they all maps to a.f. This offers us the ability to
% consume more than one level of fields, with the let binding.

efx-extend-set2/U/in
  : efx-extend-set2 (targets/unique S S2 false) N R' XX'
    -> nat2pair K (pair/ N' F)
    -> nat`eq N N'
    -> set+nat2set S F S'
    -> set`union S' S2 S3
    -> set`not-member R' K
    -> set`add R' K R
    -> effects`join XX' (effects/ efxmap/0 S3 shared-efx/none set/0) XX
    -> efx-extend-set2 (targets/unique S S2 false) N R XX.

efx-extend-set2/U/out
  : efx-extend-set2 GS N R' XX'
    -> nat2pair K (pair/ N' F)
    -> nat`ne N N'
    -> set`not-member R' K
    -> set`add R' K R
    -> effects`join XX'
      (effects/ efxmap/0 (set/1 K) shared-efx/none set/0) XX
    -> efx-extend-set2 GS N R XX.


subst-effects : targets -> nat -> effects -> effects -> type.

subst-effects/shared : subst-effects targets/shared _ XX XX.

% problem: in extend-set2 we might consume shared! However this
% shouldn't happen given compatible relation in reftyping/let.

subst-effects/unique
  : compatible (targets/unique S S2 SB) (effects/ M R SX Q)
    -> extend-efxmap (targets/unique S S2 SB) N M XX1
    -> efx-extend-set2 (targets/unique S S2 SB) N R XX2 % ignore SB for now
    -> efx-extend-set (targets/unique S S2 SB) N Q XX3
    -> effects`join XX1 XX2 XX4
    -> effects`join XX4 XX3 XX
    -> subst-effects (targets/unique S S2 SB) N (effects/ M R SX Q) XX.


%%% Theorems: properties about substitution
%%% Question: what are the properties about subst-targets?



%{
IDEA (for unique only):
first, suppose the object associated with the nat N is x, then
we need to show that, given permission:

  x == r, r == a1 \/ r == a2 ... \/ r == an \/ r == o,
  (o.all -> 0, P(o)) ,
  (o.all -> 0, P(o)) --|- (Pi(b1.f1) , Pi(b2.f2) , ... , Pi(bn.fn))

We need to prove that :
  (r == r1 \/ r == r2 \/ G(r)) ==> (r == k \/ G(r) , k == r1 \/ k == r2)
}%


%theorem combine-disj/L1
  : forall* {PF:object -> permission}
    {Pi1} {Pi2}
    exists {Pi3:object -> object -> object -> permission}
    {IMP: {o}{v1}{v2} implies
          (unitperm (nonlinear (disj (objequal o v1) (objequal o v2))) ,
            (combine ((PF v1) , (unitperm (encumbered (PF v1) Pi1)))
              ((PF v2) , (unitperm (encumbered (PF v2) Pi2)))))
          (((PF o) , (unitperm (encumbered (PF o) (Pi1 , Pi2)))) ,
            (Pi3 o v1 v2))}
    true.

- : combine-disj/L1 _
    ([o][v1][v2] implies/trans6
      (implies/combine
        (implies/disj2cond) (implies/reflexive))
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans6
          (implies/combine
            (implies/nonlinear bimplies/objequal-symmetric)
            (implies/equiv equiv/identity))
          (implies/objequal
            ([v1] (combine ((PF v1) , (unitperm (encumbered (PF v1) Pi1)))
                    ((PF v2) , (unitperm (encumbered (PF v2) Pi2))))))
          (implies/combine
            (implies/reflexive) (implies/linear-modus-ponens))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive) (add-encumber))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans
          (implies/combine
            (implies/reflexive)
            (implies/trans7
              (implies/equiv equiv/commute)
              (implies/combine
                (implies/nonlinear bimplies/objequal-symmetric)
                (implies/reflexive))
              (implies/objequal
                ([v2] (combine ((PF v1) , (unitperm (encumbered (PF v1) Pi1)))
                    ((PF v2) , (unitperm (encumbered (PF v2) Pi2))))))
              (implies/combine
                (implies/linear-modus-ponens) (implies/reflexive))
              (implies/equiv equiv/commute)
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/reflexive)
                (implies/trans
                  (add-encumber)
                  (implies/equiv-encumbered
                    (equiv/reflexive)
                    (equiv/commute))))))
          (implies/equiv equiv/commute)))
      (implies/cond-pull)).

%worlds () (combine-disj/L1 _ _).
%total { } (combine-disj/L1 _ _).


%theorem combine-disj
  : forall* {GF1:object -> formula}
    {PF} {GF2:object -> formula} {Pi1} {Pi2}
    exists
    {IMP: transform
          (output/exists [x]
            (output/exists [r1]
              (output/exists [r2]
                (output/expr x
                  (combine
                    (unitperm
                      (nonlinear
                        (disj (disj (GF1 x) (GF2 x))
                          (disj (objequal x r1) (objequal x r2)))))
                    (combine ((PF r1) , (unitperm (encumbered (PF r1) Pi1)))
                      ((PF r2) , (unitperm (encumbered (PF r2) Pi2)))))))))
          (output/exists [x]
            (output/exists [r]
              (output/expr x
                (combine
                  (unitperm
                    (nonlinear
                      (disj (disj (GF1 x) (GF2 x)) (objequal x r))))
                  ((PF r) , (unitperm (encumbered (PF r) (Pi1 , Pi2))))))))}
    true.

- : combine-disj
    (transform/trans
      (transform/inside [x]
        (transform/inside [r1]
          (transform/inside [r2]
            (transform/trans3
              (transform/implies
                (implies/equiv
                  (equiv/commute)))
              (transform/new _)
              (transform/inside [v]
                (transform/trans
                  (transform/implies
                    (implies/trans4
                      (implies/equiv
                        (equiv/associate))
                      (implies/combine
                        (implies/trans3
                          (implies/equiv equiv/commute)
                          (IMP v r1 r2)
                          (implies/equiv equiv/commute))
                        (implies/reflexive))
                      (implies/equiv (equiv/symmetric equiv/associate))
                      (implies/combine
                        (implies/reflexive)
                        (implies/equiv equiv/commute))))
                  (transform/drop)))))))
      (transform/inside [x]
        (transform/trans
          (transform/inside [v1]
            (transform/rem-unused))
          (transform/rem-unused))))
    <- combine-disj/L1 _ IMP.

%worlds () (combine-disj _).
%total { } (combine-disj _).