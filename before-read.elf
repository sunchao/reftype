% Transformations before reading a field.
% $Id: before-read.elf,v 1.1 2013/10/16 16:09:15 csun Exp csun $

% we have this definition in effects2output before. However
% we found out that it can be combined into effects2output/unique/t.
% To avoid breaking existing proof, we made another definition
% and prove that the two formats can be transformed to each other.

effects2output/unique/0t*
  : clsmap -> predmap -> cxt -> reftype -> effects -> expr-output -> type.

effects2output/unique/0t
  : effects2output/unique/0t* CM PM B
    (reftype/ NN C (targets/unique S S2 true)) (effects/ M _ SX _)
    (output/exists [o]
      (output/exists [r]
        (output/expr o
          (combine Pi1
            (combine (unitperm (nonlinear (disj (objequal o r) (GF o))))
              (combine (scale Q (PF r))
                (combine (unitperm (encumbered (scale Q (PF r)) Pi3)) Pi2)))))))
    <- set`size S2 z
    <- cxt2perm CM PM B Pi1
    <- ({r} set2facts r S (GF r))
    <- efxmap2perm CM PM B M Pi2
    <- shared-efx2perm SX Pi3
    <- shared-efx2efx SX X
    <- efx2frac X Q
    <- ty2perm PM (ty/ NN annot/unique C) PF.


%theorem can-transform-to-unique/0t
  : forall* {CM} {PM} {B} {NN} {C} {S} {XX} {Out}
    forall {XX=>Out: effects2output CM PM B
                     (reftype/ NN C (targets/unique S set/0 true)) XX Out}
    exists {Out'} {XX=>Out': effects2output/unique/0t* CM PM B
                      (reftype/ NN C (targets/unique S set/0 true)) XX Out'}
    {TRANS: transform Out Out'}
    true.

- : can-transform-to-unique/0t
    (effects2output/unique/t T2PF SX=>Pi4 X2Q MX SX=>X2 MX-M2=X1
      M2=>Pi3 M1=>Pi2 M|S2=M1+M2 ([x] S=>GF x) B=>Pi1)
    _ (effects2output/unique/0t T2PF X22Q SX=>X2 SX=>Pi4 M=>Pi2
      ([x] S=>GF x) B=>Pi1 set`size/0)
    (transform/inside [o]
      (transform/inside [r]
        (transform/implies
          (implies/combine
            (implies/reflexive)
            (implies/combine
              (implies/reflexive)
              (implies/combine implies/reflexive
                (implies/combine
                  (implies/equiv-encumbered
                    (equiv/reflexive)
                    (equiv/transitive3
                      (equiv/combine Pi3<=>0 equiv/reflexive)
                      (equiv/commute)
                      (equiv/identity)))
                  (implies/reflexive))))))))
    <- efxmap`partition-on-empty-set _ M|S2=M+0
    <- efxmap`partition-unique M|S2=M1+M2 M|S2=M+0 efxmap`eq/ set`eq/
      M1=M M2=0
    <- efxmap2perm-respects-eq M1=>Pi2 clsmap`eq/ predmap`eq/
      cxt`eq/ M1=M permission`eq/ M=>Pi2
    <- efxmap2perm-equiv M2=>Pi3 efxmap2perm/0 clsmap`eq/ predmap`eq/
      cxt`eq/ M2=0 Pi3<=>0
    <- efxmap-minimum-efx-unique MX-M2=X1 efxmap-minimum-efx/0 efx`eq/
      M2=0 X1=W
    <- efx/write-is-upper-bound _ MX'
    <- efx`min-unique MX MX' X1=W efx`eq/ X=X2
    <- efx2frac-respects-eq X2Q X=X2 X22Q.

%worlds () (can-transform-to-unique/0t _ _ _ _).
%total { } (can-transform-to-unique/0t _ _ _ _).


%theorem can-transform-to-unique/0t-converse
  : forall* {CM} {PM} {B} {NN} {C} {S} {XX} {Out}
    forall {XX=>Out: effects2output/unique/0t* CM PM B
                      (reftype/ NN C (targets/unique S set/0 true)) XX Out}
    exists {Out'} {XX=>Out': effects2output CM PM B
                     (reftype/ NN C (targets/unique S set/0 true)) XX Out'}
    {TRANS: transform Out Out'}
    true.

- : can-transform-to-unique/0t-converse
    (effects2output/unique/0t T2PF X2Q SX=>X2 SX=>Pi4 M=>Pi2
      ([x] S=>GF x) B=>Pi1 set`size/0)
    _ (effects2output/unique/t T2PF SX=>Pi4 X2Q MX SX=>X2
        efxmap-minimum-efx/0 efxmap2perm/0 M=>Pi2 M|S2=M1+M2 ([x] S=>GF x) B=>Pi1)
    (transform/inside [o]
      (transform/inside [r]
        (transform/implies
          (implies/combine
            (implies/reflexive)
            (implies/combine
              (implies/reflexive)
              (implies/combine implies/reflexive
                (implies/combine
                  (implies/equiv-encumbered
                    (equiv/reflexive)
                    (equiv/transitive
                      (equiv/symmetric equiv/identity)
                      (equiv/commute)))
                  (implies/reflexive))))))))
    <- efxmap`partition-on-empty-set _ M|S2=M1+M2
    <- efx/write-is-upper-bound _ MX.

%worlds () (can-transform-to-unique/0t-converse _ _ _ _).
%total { } (can-transform-to-unique/0t-converse _ _ _ _).


%%% short of names for this lemma, but from the definition
% it should be clear what it means.

%theorem efx2frac-leq-implies-implies*
  : forall* {X1} {X2} {Q1} {Q2} {Pi1:object -> permission} {Pi2}
    forall {X2Q: efx2frac X1 Q1}
    {X1<=X2: efx`leq X2 X1}
    {X2Q: efx2frac X2 Q2}
    exists {IMP: {x} implies
                 (scale Q1 (Pi1 x) ,
                   (unitperm (encumbered (scale Q1 (Pi1 x)) Pi2)))
                 (scale Q2 (Pi1 x) ,
                   (unitperm (encumbered (scale Q2 (Pi1 x)) Pi2)))}
    true.

- : efx2frac-leq-implies-implies* efx2frac/read (efx`geq/= efx`eq/)
    efx2frac/read ([_] implies/reflexive).

- : efx2frac-leq-implies-implies* efx2frac/write (efx`geq/= efx`eq/)
    efx2frac/write ([_] implies/reflexive).

- : efx2frac-leq-implies-implies* efx2frac/write (efx`geq/> efx`grt/wr)
    efx2frac/read ([_] implies/trans3
      (implies/combine
        (implies/trans4
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/equiv
              (equiv/symmetric (equiv/add 1/2+1/2=1)))
            (implies/trans5
              (implies/equiv (equiv/symmetric equiv/one))
              (implies/scale implies/self-implication)
              (implies/scale-distribute-encumbered)
              (implies/equiv-encumbered
                (equiv/symmetric (equiv/add 1/2+1/2=1))
                (equiv/reflexive))
              (implies/combine-assoc-encumbered)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/linear-modus-ponens)))
        (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/chain-implication))).

%worlds (objvar) (efx2frac-leq-implies-implies* _ _ _ _).
%total {} (efx2frac-leq-implies-implies* _ _ _ _).


%{
 This lemma says if we are given a set of facts about objequal in the form
 of x == r_i, and a set of packed field permissions about each object r_i
 in the facts, then we can get a single field permission for the object x,
 as well as permission for x encumbered in permission for the combined
 field permissions from each r_i.
}%

%theorem combine-fldperm
  : forall* {S} {B} {C} {CM} {PM} {FM} {MS}
    {NN} {A} {FC} {G} {F} {M} {Pi} {PF}
    forall {K} {Z: set`size S (s K)}
    {SC: same-class B S C}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {S2S: set+nat2set S F MS}
    {S2G: {x} set2facts x S (G x)}
    {DM: efxmap`domain M MS}
    {M2P: efxmap2perm CM PM B M Pi}
    {T2PF: ty2perm PM (ty/ NN A FC) PF}
    exists {X} {MX-X: efxmap-minimum-efx M X}
    {Q:fraction} {X2Q: efx2frac X Q}
    {IMP: {x} implies
          (combine (unitperm (nonlinear (G x))) Pi)
          (combine (scale Q (unitperm (precise-exists x F ([v] PF v))))
            (unitperm (encumbered
                        (scale Q (unitperm (precise-exists x F PF))) Pi)))}
    true.

%worlds (objvar) (combine-fldperm _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (N) (combine-fldperm N _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%{
 Now the main proof for the case that the receiver is shared. First, we
 show that the result of checking the receiver can be transformed into
 a format ready for reading.
}%

%theorem before-read/shared/L
  : forall* {SX} {Pi} {SX'}
    forall {SX-NN: shared-efx-not-none SX'}
    {LE: shared-efx`leq SX' SX}
    {SX=>Pi: shared-efx2perm SX Pi}
    exists {X} {SX2P: shared-efx2efx SX X}
    {Q} {P2Q: efx2frac X Q}
    {Pi2} {T: equiv Pi (scale Q (allperm null) , Pi2)}
    true.

- : before-read/shared/L _
    (shared-efx`leq/= (efx`geq/= efx`eq/))
    (shared-efx2perm/read apply-efx/read)
    efx/read shared-efx2efx/ half efx2frac/read
    _ (equiv/symmetric equiv/identity).

- : before-read/shared/L _
    (shared-efx`leq/= (efx`geq/> (efx`grt/wr)))
    (shared-efx2perm/write apply-efx/write)
    efx/write shared-efx2efx/ (fraction/ one) efx2frac/write
    _ (equiv/transitive
      (equiv/symmetric equiv/one)
      (equiv/symmetric equiv/identity)).

- : before-read/shared/L _ _
    (shared-efx2perm/write apply-efx/write)
    efx/write shared-efx2efx/ (fraction/ one) efx2frac/write
    _ (equiv/transitive
      (equiv/symmetric equiv/one)
      (equiv/symmetric equiv/identity)).

%worlds () (before-read/shared/L _ _ _ _ _ _ _ _ _).
%total {} (before-read/shared/L _ _ _ _ _ _ _ _ _).


%theorem before-read/shared
  : forall* {CM} {PM} {FM} {C} {NN} {A} {FC}
    {B} {XM} {SX} {Rslt} {F} {S} {Q} {SX'}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {LE: shared-efx`leq SX' SX}
    {SX-NN: shared-efx-not-none SX'}
    {XX=>Rslt: effects2output CM PM B
              (reftype/ nn/yes C targets/shared) (effects/ XM S SX Q) Rslt}
    exists {Pi3} {Pi1} {Pi2} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi3: cxt2perm CM PM B Pi3}
    {SX=>Pi2: shared-efx2perm SX Pi2}
    {X} {SX2B: shared-efx2efx SX X}
    {Q} {B2Q: efx2frac X Q}
    {XM=>Pi1: efxmap2perm CM PM B XM Pi1}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/expr r
                (combine Pi3
                  ((ffperm Q r F TF) ,
                    ((unitperm
                       (encumbered
                         (ffperm Q r F TF) Pi2)) , Pi1)))))}
    true.

- : before-read/shared
    CM-CM CM2PM CM-L FM-L SX1<=SX SX1-NN
    (effects2output/simple (ty2perm/ PM-L nn2perm/yes annot2perm/shared)
      reftype2ty/shared simple-targets/shared
      SX=>Pi2 XM=>Pi1 B=>Pi3) %{=>}% _ _ _ _ (ty2perm/ PM-LF NN2PF A2AF)
    B=>Pi3 SX=>Pi2 _ SX2X _ X2Q XM=>Pi1
    (transform/inside [r]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/symmetric equiv/associate)
                    (equiv/combine
                      (equiv/reflexive)
                      (equiv/transitive3
                        (equiv/symmetric equiv/associate)
                        (equiv/combine equiv/reflexive equiv/commute)
                        (equiv/associate)))))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans6
                    (implies/combine
                      (IMP1 r) (IMP2 r))
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/symmetric equiv/associate)
                        (equiv/combine equiv/reflexive equiv/commute)
                        (equiv/associate)))
                    (implies/combine
                      (implies/trans
                        (implies/equiv equiv/commute)
                        (implies/trans5
                          (implies/combine
                            (implies/scale-into-formula)
                            (implies/reflexive))
                          (implies/equiv (equiv/symmetric equiv/distribute))
                          (implies/scale implies/carve)
                          (implies/equiv equiv/distribute)
                          (implies/combine
                            implies/reflexive
                            (implies/scale-distribute-encumbered))))
                      (implies/reflexive))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine implies/reflexive implies/chain-implication))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))))))
            (implies/equiv equiv/reorder)))
        (transform/drop)))
    <- before-read/shared/L SX1-NN SX1<=SX SX=>Pi2 _ SX2X _ X2Q _ EQV
    <- can-carve-out-of-shared EQV IMP1
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L _ _ _ A2AF NN2PF PM-LF ([r] IMP2 r).

%worlds () (before-read/shared _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/shared _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

%{
How to prove this? First we need to show that M2 is
less than or equal to M2P, therefore we can get back the
permission for reading field F. For this we need the following
theorem:

  if we have:
    S + F => GM
    GM    => M2
    M2   <= M
    M/GM == M1 , M2P
    --------------------
  then we can get:
    M2   <= M2P
    DM(M2) = DM(M2P)

The immediate result of this is we can convert M2P to two
sets of permissions, say Pi1 and Pi2, and Pi1 is the permissions
generated from M2.

Since we have permission Pi1, as well as the object equal relations,
we can get the field permission, and thus this theorem can be done.

One problem is M1 \join M2 = M, here it's possible that M1 overlaps
with M2, and thus if M2 => GM2, and M / GM2 = M1P + M2P,
M1P will be less than M1.

}%

% this lemma is probably not necessary.

%theorem before-read/unique/L1
  : forall* {CM} {PM} {B} {R} {M2} {M} {S} {X}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {R2M: set2efxmap R X M2}
    {M2<=M: efxmap`leq M2 M}
    {DM: efxmap`domain M S}
    {CM-B-M: clsmap-cxt-set CM B S}
    exists {M1'} {M2'}
    {SG: efxmap`partition M R M1' M2'}
    {M2'=>R: efxmap`domain M2' R}
    {Pi1'} {M1'=>Pi1': efxmap2perm CM PM B M1' Pi1'}
    {Pi2'} {M2'=>Pi2': efxmap2perm CM PM B M2' Pi2'}
    true.

- : before-read/unique/L1 CM-CM CM2PM R2=>M2
    M2<=M DM CM-B-S _ _ M/R2=M1'+M2' M2'=>R2 _ M1'=>Pi1' _ M2'=>Pi2'
    <- set2efxmap-implies-domain R2=>M2 M2=>R2
    <- efxmap`partition-total M/R2=M1'+M2'
    <- efxmap`partition-implies-leq M/R2=M1'+M2' M1'<=M M2'<=M
    <- efxmap`domain-total DM1'
    <- efxmap`domain-total DM2'
    <- efxmap`domain-preserves-leq* M2'<=M DM2' DM S2'<=S
    <- efxmap`domain-preserves-leq* M1'<=M DM1' DM S1'<=S
    <- clsmap-cxt-set-respects-geq CM-B-S S2'<=S CM-B-S2'
    <- clsmap-cxt-set-respects-geq CM-B-S S1'<=S CM-B-S1'
    <- partition-leq-implies-leq M/R2=M1'+M2' R2=>M2 M2<=M M2<=M2'
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM2' CM-B-S2' Pi2' M2'=>Pi2'
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM1' CM-B-S1' Pi1' M1'=>Pi1'
    <- efxmap`domain-preserves-leq M2<=M M2=>R2 _ M=>R R2<=R
    <- efxmap`partition-implies-domain M/R2=M1'+M2' M=>R R2<=R M2'=>R2.

%worlds () (before-read/unique/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique/0
  : forall* {B} {CM} {PM} {FM} {C} {XM} {SX}
    {F} {NN} {A} {FC} {Out} {S} {Q}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XM=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique set/0 set/0 false))
              (effects/ XM S SX Q) Out}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi3} {B=>Pi3: cxt2perm CM PM B Pi3}
    {CP} {PML: predmap`lookup PM C CP}
    {Pi2} {SX=>Pi2: shared-efx2perm SX Pi2}
    {Pi1} {XM=>Pi: efxmap2perm CM PM B XM Pi1}
    {TRANS: transform Out
            (output/exists [r]
              (output/expr r
                (combine Pi3
                  (combine (unitperm (precise-exists r F TF))
                    (combine
                      (unitperm
                        (encumbered (unitperm (precise-exists r F TF))
                          (nonnull-unique-perm r CP)))
                      (combine Pi1 Pi2))))))}
    true.

- : before-read/unique/0
    CM-CM CM2PM CML FML
    (effects2output/simple
      (ty2perm/ PML nn2perm/yes annot2perm/unique)
      reftype2ty/unique simple-targets/unique
      SX=>Pi2 XM=>Pi1 B=>Pi3)
    %{=>}% _ (ty2perm/ PMFL NN2PF A2AF) _ B=>Pi3 _ PML _ SX=>Pi2 _ XM=>Pi1
    (transform/inside [r]
      (transform/implies
        (implies/combine
          (implies/reflexive)
          (implies/trans
            (implies/combine
              (implies/trans10
                (implies/equiv (equiv/symmetric equiv/identity))
                (implies/combine
                  (implies/equiv equiv/commute)
                  (implies/trans
                    (implies/self-implication)
                    (implies/combine-assoc-encumbered)))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/linear-modus-ponens))
                (implies/combine
                  (implies/trans % (r.all->0, P(r))
                    (implies/combine
                      (implies/reflexive)
                      (implies/duplicate))
                    (implies/equiv equiv/associate))
                  (implies/trans
                    (implies/equiv-encumbered
                      (equiv/commute)
                      (equiv/reflexive))
                    (implies/combine-assoc-encumbered)))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/linear-modus-ponens))
                (implies/combine
                  (implies/trans3
                    (implies/equiv equiv/commute)
                    (implies/combine
                      (IMP r)
                      (implies/reflexive))
                    (implies/carve))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/chain-implication)))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))))))
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF NN2PF PMFL IMP.

%worlds () (before-read/unique/0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique/0f
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M} {SX}
    {F} {NN} {A} {FC} {S} {G2} {Out} {K} {CS} {R} {Q} {X}
    forall {DM: efxmap`domain M R}
    {CM-B-R: clsmap-cxt-set CM B R}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>G2: set+nat2set S F G2}
    {G2=>M2: set2efxmap G2 X M2}
    {M2<=M: efxmap`leq M2 M}
    {M=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique S set/0 false))
              (effects/ M CS SX Q) Out}
    {SC: same-class B S C}
    {SZ: set`size S (s K)}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {Pi3} {SX=>Pi3: shared-efx2perm SX Pi3}
    {M1P} {M2P} {M/G2=M1+M2P: efxmap`partition M G2 M1P M2P}
    {Pi1} {M1P=>Pi1: efxmap2perm CM PM B M1P Pi1}
    {Pi2} {M2P=>Pi2: efxmap2perm CM PM B M2P Pi2}
    {X} {MX-M2P: efxmap-minimum-efx M2P X}
    {Q} {X2Q: efx2frac X Q}
    {TRANS: transform Out
            (output/exists [r]
              (output/expr r
                (combine Pi4
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q r F TF) Pi2))
                      (combine Pi1 Pi3))))))}
    true.

- : before-read/unique/0f
    DM CM-B-R CM-CM CM2PM CM-L FM-L S+F=>G2 G2=>M2 M2<=M
    (effects2output/unique/0f _ SX=>Pi3 M=>Pi S=>GF B=>Pi4
      set`size/0 SZ-SP)
    B-S-C SZ-S %{=>}% _ T2PF _ B=>Pi4 _ SX=>Pi3
    _ _ M/G2=M1P+M2P _ M1P=>Pi1P _ M2P=>Pi2P _ MX-M2P Q X2Q
    (transform/inside [r]
      (transform/trans3
        (transform/implies
          (implies/equiv equiv/roll2))
        (transform/drop)
        (transform/implies
          (implies/combine
            (implies/reflexive)
            (implies/trans3
              (implies/equiv
                (equiv/transitive
                  (equiv/combine
                    (equiv/reflexive) % GF
                    (equiv/transitive
                      (equiv/combine
                        (equiv/transitive
                          (Pi<=>Pi1P+Pi2P)
                          (equiv/commute))
                        (equiv/reflexive))
                      (equiv/symmetric equiv/associate)))
                  (equiv/associate)))
              (implies/combine
                (implies/trans4
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (IMP r)
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans3
                          (implies/self-implication)
                          (implies/equiv-encumbered
                            (equiv/reflexive)
                            (equiv/transitive
                              (equiv/commute)
                              (equiv/identity)))
                          (implies/combine-assoc-encumbered)))
                      (implies/linear-modus-ponens)))
                  (implies/equiv (equiv/symmetric equiv/associate))
                  (implies/combine
                    (implies/reflexive)
                    (implies/chain-implication)))
                (implies/reflexive))
              (implies/equiv (equiv/symmetric equiv/associate)))))))
    <- before-read/unique/L1
      CM-CM CM2PM G2=>M2 M2<=M DM CM-B-R M1P M2P
      M/G2=M1P+M2P M2P=>G2 _ M1P=>Pi1P _ M2P=>Pi2P
    <- lookup-implies-clsmap-fldmap CM-CM CM-L CM-FM
    <- lookup-implies-clsmap-ty CM-FM FM-L CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- combine-fldperm _ SZ-S B-S-C CM-CM CM2PM CM-L FM-L S+F=>G2
      S=>GF M2P=>G2 M2P=>Pi2P T2PF _ MX-M2P _ X2Q IMP
    <- efxmap`partition-implies-permission-combine*
      M/G2=M1P+M2P M=>Pi M1P=>Pi1P M2P=>Pi2P Pi<=>Pi1P+Pi2P.

%worlds ()
(before-read/unique/0f
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(before-read/unique/0f
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique/0t
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M} {SX}
    {F} {NN} {A} {FC} {S} {G2} {Out} {CS} {R} {Q} {X}
    forall {N} {SZ: set`size S N}
    {SC: same-class B S C}
    {DM: efxmap`domain M R}
    {CM-B-M: clsmap-cxt-set CM B R}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>G2: set+nat2set S F G2}
    {G2=>M2: set2efxmap G2 X M2}
    {M2<=M: efxmap`leq M2 M}
    {M=>Out: effects2output/unique/0t* CM PM B
              (reftype/ nn/yes C (targets/unique S set/0 true))
              (effects/ M CS SX Q) Out}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {Pi3} {SX=>Pi3: shared-efx2perm SX Pi3}
    {M1P} {M2P} {M/G2=M1P+M2P: efxmap`partition M G2 M1P M2P}
    {Pi1} {M1P=>Pi1: efxmap2perm CM PM B M1P Pi1}
    {Pi2} {M2P=>Pi2: efxmap2perm CM PM B M2P Pi2}
    {X1} {MX-M2P: efxmap-minimum-efx M2P X1}
    {X2} {SX2X: shared-efx2efx SX X2}
    {X} {MX: efx`min X1 X2 X}
    {Q} {X2Q: efx2frac X Q}
    {TRANS: transform Out
            (output/exists [r]
              (output/expr r
                (combine Pi4
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q r F TF) (Pi2 , Pi3))) Pi1)))))}
    true.

- : before-read/unique/0t
    z set`size/0 _ DM CM-B-R CM-CM CM2PM CM-L FM-L
    set+nat2set/0 G2=>M2 M2<=M
    (effects2output/unique/0t (ty2perm/ PM-L nn2perm/yes annot2perm/unique)
      EX2=>Q2 SX=>EX2 SX=>Pi3 F+M=>Pi ([_]set2facts/0) B=>Pi4 set`size/0)
    _ (ty2perm/ PM-FL NN2PF A2AF) _ B=>Pi4 _ SX=>Pi3
    _ _ M/G2=M1P+M2P _ F+M1P=>Pi1P _ F+M2P=>Pi2P _
    MX-M2P=W EX2 SX=>EX2 EX2 MX=EX _ EX2=>Q2
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/implies
            (implies/combine
              (implies/reflexive)
              (implies/trans4
                (implies/combine
                  (implies/nonlinear
                    (bimplies/trans
                      (disj-to-objequal o r)
                      (bimplies/objequal-symmetric)))
                  (implies/reflexive))
                (implies/objequal
                  ([o] (scale Q (nonnull-unique-perm o CP) ,
                         ((unitperm
                            (encumbered
                              (scale Q (nonnull-unique-perm o CP)) Pi3)) , Pi2))))
                (IMP2 o)
                (implies/combine
                  (implies/reflexive)
                  (implies/combine
                    (implies/equiv-encumbered
                      (equiv/reflexive)
                      (equiv/transitive3
                        (equiv/symmetric equiv/identity)
                        (equiv/commute)
                        (equiv/combine
                          (equiv/symmetric Pi2P<=>EMP)
                          (equiv/reflexive))))
                    (implies/reflexive)))))))
        (transform/rem-unused)))
    <- efxmap`partition-total M/G2=M1P+M2P
    <- efxmap`partition-implies-leq M/G2=M1P+M2P M1P<=M M2P<=M
    <- efxmap`partition-on-empty-set _ M/0=M+0
    <- efxmap`partition-unique
      M/0=M+0 M/G2=M1P+M2P efxmap`eq/ set`eq/ M=M1P E=G2
    <- efxmap`eq-symmetric E=G2 G2=E
    <- efxmap2perm-respects-eq F+M=>Pi clsmap`eq/ predmap`eq/
      cxt`eq/ M=M1P permission`eq/ F+M1P=>Pi1P
    <- efxmap`domain-total DMP
    <- efxmap`domain-preserves-leq* M2P<=M DMP DM R2P<=R
    <- clsmap-cxt-set-respects-geq CM-B-R R2P<=R CM-B-R2P
    <- clsmap-cxt-set-implies-efxmap2perm
      CM-CM CM2PM DMP CM-B-R2P _ F+M2P=>Pi2P
    <- efxmap2perm-equiv F+M2P=>Pi2P efxmap2perm/0 clsmap`eq/
      predmap`eq/ cxt`eq/ G2=E Pi2P<=>EMP
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L _ _ _ A2AF NN2PF PM-FL IMP1
    <- pullout-fldperm IMP1 IMP2
    <- efx/write-is-upper-bound _ MX=EX
    <- efxmap-minimum-efx-respects-eq efxmap-minimum-efx/0 efx`eq/ E=G2
      efx`eq/ MX-M2P=W.

- : before-read/unique/0t
    (s _) SZ SOC DM CM-B-R CM-CM CM2PM CM-L FM-L
    S+F=>G2 G2=>M2 M2<=M
    (effects2output/unique/0t (ty2perm/ PM-L nn2perm/yes annot2perm/unique)
      (EX2=>Q2:efx2frac EX2 Q2)
      SX=>EX2 SX=>Pi3 M=>Pi ([r] S=>G r) B=>Pi4 set`size/0)
  %{=>}% _ (ty2perm/ PM-FL NN2PF A2AF) _ B=>Pi4 _ SX=>Pi3
    _ _ M/G2=M1P+M2P _ M1P=>Pi1P _ M2P=>Pi2P _
    MX-M2P=EX1 EX2 SX=>EX2 EX MX=EX _ EX=>Q
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/trans
            (transform/implies
              (implies/trans3
                (implies/combine
                  (implies/reflexive)
                  (implies/trans5
                    (implies/combine
                      (implies/disj2cond)
                      (implies/reflexive))
                    (implies/equiv equiv/commute)
                    (implies/cond-push)
                    (implies/cond-gen-inner)
                    (implies/cond-inner
                      (bimplies/reflexive)
                      (bimplies/reflexive)
                      (implies/trans9
                        (implies/combine
                          (implies/nonlinear (bimplies/objequal-symmetric))
                          (implies/equiv equiv/identity))
                        (implies/objequal
                          ([o] (scale Q2 (nonnull-unique-perm o CP) ,
                                 ((unitperm
                                    (encumbered
                                      (scale Q2 (nonnull-unique-perm o CP)) Pi3)) ,
                                   Pi2))))
                        (IMP2 o)
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (EMP2 o)
                          (implies/equiv
                            (equiv/transitive
                              (Pi<=>Pi1P+Pi2P)
                              (equiv/commute))))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (implies/reflexive)
                              (implies/trans
                                (add-encumber)
                                (implies/equiv-encumbered
                                  (equiv/reflexive)
                                  (equiv/commute)))))
                          (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/equiv (equiv/symmetric equiv/identity)))
                      (implies/trans
                        (implies/combine
                          (implies/reflexive)
                          (implies/trans7
                            (implies/combine
                              (implies/trans3
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/linear-modus-ponens)
                                  (implies/equiv Pi<=>Pi1P+Pi2P))
                                (implies/equiv equiv/associate)) % Pi3 , Pi2
                              (implies/reflexive))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (implies/reflexive)
                              (implies/trans
                                (implies/equiv equiv/commute)
                                (IMP3 o)))
                            (implies/equiv equiv/commute)
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans3
                                (implies/equiv (equiv/symmetric equiv/associate))
                                (implies/combine
                                  (implies/reflexive)
                                  (add-encumber))
                                (EMP1 o))
                              (implies/reflexive))
                            (implies/equiv (equiv/symmetric equiv/associate))))
                        (implies/equiv equiv/commute)))))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/cond-pull)
                    (implies/equiv equiv/commute)))
                (implies/equiv equiv/reorder)))
            (transform/drop)))
        (transform/rem-unused)))
    <- before-read/unique/L1
      CM-CM CM2PM G2=>M2 M2<=M DM CM-B-R _ _
      M/G2=M1P+M2P M2P=>G2 Pi1P M1P=>Pi1P Pi2P M2P=>Pi2P
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L _ _ _ A2AF NN2PF PM-FL IMP1
    <- efxmap`partition-implies-permission-combine*
      M/G2=M1P+M2P M=>Pi M1P=>Pi1P M2P=>Pi2P Pi<=>Pi1P+Pi2P
    <- pullout-fldperm IMP1 IMP2
    <- combine-fldperm _ SZ SOC CM-CM CM2PM CM-L FM-L S+F=>G2 S=>G
      M2P=>G2 M2P=>Pi2P (ty2perm/ PM-FL NN2PF A2AF)
      EX1 MX-M2P=EX1 Q1 EX1=>Q1 IMP3
    <- efx`min-total MX=EX
    <- efx`min-implies-geq MX=EX EX1>=EX EX2>=EX
    <- efx2frac-total EX=>Q
    <- efx2frac-leq-implies-implies* EX1=>Q1 EX1>=EX EX=>Q EMP1
    <- efx2frac-leq-implies-implies* EX2=>Q2 EX2>=EX EX=>Q EMP2.

%worlds ()
(before-read/unique/0t
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(before-read/unique/0t
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique/L2
  : forall* {X1} {X2} {X} {G} {F} {PF} {CP} {Pi2} {Pi12} {Q1} {Q2} {Q}
    forall {X1=>Q1: efx2frac X1 Q1}
    {X2=>Q2: efx2frac X2 Q2}
    {X2Q: efx2frac X Q}
    {MX: efx`min X1 X2 X}
    {IMP1: {x} implies
          (combine (unitperm (nonlinear (G x))) (Pi12))
          (combine (scale Q1 (unitperm (precise-exists x F ([v] PF v))))
            (unitperm
              (encumbered
                (scale Q1 (unitperm (precise-exists x F PF))) Pi12)))}
    {IMP2: {x} implies (one-predcall CP x)
           (unitperm
             (nonlinear
               (nested (unitperm (precise-exists x F PF)) x all)))}
    exists {Pi}
    {IMP: {o}{x} implies
          (combine
            (unitperm (nonlinear (disj (objequal o x) (G o))))
            (combine
              (scale Q2 (nonnull-unique-perm x CP))
              (combine
                (unitperm
                  (encumbered (scale Q2 (nonnull-unique-perm x CP)) Pi2))
                Pi12)))
          (combine
            (combine
              (scale Q (unitperm (precise-exists o F PF)))
              (unitperm
                (encumbered
                  (scale Q (unitperm (precise-exists o F PF)))
                  (combine Pi12 Pi2))))
            (Pi o x))}
    true.

- : before-read/unique/L2 X1=>Q1 X2=>Q2 X=>Q MX IMP1 IMP2 _
    ([o][x]
      (implies/trans5
        (implies/combine
          (implies/trans
            (implies/disj2cond)
            (implies/cond-gen-inner))
          (implies/reflexive))
        (implies/equiv equiv/commute)
        (implies/cond-push)
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/trans10
            (implies/combine
              (implies/equiv equiv/associate)
              (implies/equiv equiv/identity))
            (implies/equiv equiv/commute)
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/trans
                (implies/combine
                  (implies/nonlinear bimplies/objequal-symmetric)
                  (implies/reflexive))
                (implies/objequal
                  ([o] (scale Q2 (nonnull-unique-perm o CP)) ,
                    (unitperm
                      (encumbered (scale Q2 (nonnull-unique-perm o CP))
                        (Pi2))))))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (add-encumber)
                (implies/equiv-encumbered
                  (equiv/reflexive)
                  (equiv/commute))))
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/identity)
                (equiv/symmetric equiv/associate)))
            (IMP2' o)
            (implies/equiv equiv/associate)
            (implies/combine
              (EMP2 o)
              (implies/reflexive)))
          (implies/trans4
            (implies/equiv
              (equiv/transitive
                (equiv/commute)
                (equiv/symmetric equiv/associate)))
            (implies/combine
              (implies/reflexive)
              (implies/trans5
                (implies/combine % (G , (Pf, (Pf --|- P2 , P12)))
                  (implies/reflexive)
                  (implies/trans3
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv equiv/commute)))
                (implies/equiv equiv/associate)
                (implies/combine
                  (IMP1 o)
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (add-encumber))))
            (implies/equiv equiv/commute)
            (implies/combine
              (EMP1 o)
              (implies/reflexive))))
        (implies/cond-pull)))
    <- pullout-fldperm IMP2 IMP2'
    <- efx`min-implies-geq MX X<=X1 X<=X2
    <- efx2frac-leq-implies-implies* X1=>Q1 X<=X1 X=>Q EMP1
    <- efx2frac-leq-implies-implies* X2=>Q2 X<=X2 X=>Q EMP2.

%worlds () (before-read/unique/L2 _ _ _ _ _ _ _ _).
%total {} (before-read/unique/L2 _ _ _ _ _ _ _ _).


%theorem efxmap`partition-disjoint-leq-implies-leq
  : forall* {M} {G1} {G2} {M1} {M2} {MS}
    forall {P: efxmap`partition M G1 M1 M2}
    {DJ: set`disjoint G1 G2} {DM: efxmap`domain M MS}
    {LE1: set`leq G1 MS} {LE2: set`leq G2 MS}
    exists {MS1} {DM: efxmap`domain M1 MS1} {LE: set`leq G2 MS1}
    true.

%worlds () (efxmap`partition-disjoint-leq-implies-leq _ _ _ _ _ _ _ _).
%trustme %total {} (efxmap`partition-disjoint-leq-implies-leq _ _ _ _ _ _ _ _).


%theorem before-read/unique/+f
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M} {N1} {N2}
    {SX} {F} {NN} {A} {FC} {G1} {G2} {Out} {G} {R} {CS} {CQ} {X}
    forall {S} {SZ: set`size G1 (s N1)}
    {CM-B-M: clsmap-cxt-set CM B R}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CL: clsmap`lookup CM C FM}
    {FL: fldmap`lookup FM F (ty/ NN A FC)}
    {DM: efxmap`domain M R}
    {G1<=R: set`leq G1 R}
    {S=>G2: set+nat2set S F G2}
    {G1^G2: set`disjoint G1 G2}
    {G1+G2=G: set`join G1 G2 G}
    {G=>M2: set2efxmap G X M2}
    {M2<=M: efxmap`leq M2 M}
    {M=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique S G1 false))
              (effects/ M CS SX CQ) Out}
    {SOC: same-class B S C}
    {SZ: set`size S N2}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {Pi3} {SX=>Pi3: shared-efx2perm SX Pi3}
    {M1P} {M2P} {M+G=>M1P+M2P: efxmap`partition M G M1P M2P}
    {Pi1} {M1P=>Pi1: efxmap2perm CM PM B M1P Pi1}
    {Pi2} {M2P=>Pi2: efxmap2perm CM PM B M2P Pi2}
    {X} {MX: efxmap-minimum-efx M2P X}
    {Q} {X2Q: efx2frac X Q}
    {TRANS: transform (Out)
            (output/exists [o]
              (output/expr o
                (combine Pi4
                  (combine (ffperm Q o F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q o F TF) Pi2))
                      (combine Pi1 Pi3))))))}
    true.

- : before-read/unique/+f (set/+ _ _) _
    CM-B-M CM-CM CM2PM CML FML (DM-M=R:efxmap`domain M R)
    G1<=R S=>G2 G1^G2
    (G1+G2=G:set`union G1 G2 G)
    (G=>M2:set2efxmap G X M2) M2<=M
    (effects2output/unique/+f
      (ty2perm/ PML nn2perm/yes annot2perm/unique)
      (SX=>Pi3:shared-efx2perm SX Pi3) (EX2=>Q2:efx2frac EX2 Q2) MX-M4=EX2
      (M4=>Pi2:efxmap2perm _ _ _ M4 Pi2)
      (M3=>Pi1:efxmap2perm _ _ _ M3 Pi1) M+G1=>M3+M4 S=>GF B=>Pj1 _)
    SOC S-SZ _ (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1 _ SX=>Pi3
    M5 M7 M+G=>M5+M7 Pi11 M5=>Pi11 Pi12+Pi2 M7=>Pi12+Pi2 _ MX-M7=EX _ EX=>Q
    ((transform/inside [o]
       (transform/trans
         (transform/inside [r]
           (transform/trans
             (transform/implies
               (implies/combine
                 (implies/reflexive)
                 (implies/trans4
                   (implies/combine
                     (implies/reflexive)
                     (implies/trans
                       (implies/combine
                         (implies/reflexive)
                         (implies/trans
                           (implies/combine
                             (implies/reflexive)
                             (implies/trans
                               (implies/combine
                                 (implies/equiv
                                   (equiv/transitive
                                     (Pi1<=>Pi11+Pi12)
                                     (equiv/commute)))
                                 (implies/reflexive))
                               (implies/equiv
                                 (equiv/symmetric
                                   equiv/associate))))
                           (implies/equiv equiv/associate)))
                       (implies/equiv equiv/associate)))
                   (implies/equiv equiv/associate)
                   (implies/combine
                     (implies/trans
                       (IMP4 o r)
                       (implies/combine
                         (implies/combine
                           (implies/reflexive)
                           (implies/equiv-encumbered
                             (equiv/reflexive)
                             (EQV)))
                         (implies/reflexive)))
                     (implies/reflexive))
                   (implies/equiv
                     (equiv/transitive3
                       (equiv/combine
                         (equiv/commute)
                         (equiv/reflexive))
                       (equiv/symmetric equiv/associate)
                       (equiv/combine
                         (equiv/reflexive)
                         (equiv/symmetric equiv/associate)))))))
             (transform/trans
               (transform/implies (implies/equiv equiv/roll2))
               (transform/drop))))
         (transform/rem-unused))))
    <- efxmap`partition-total (M3+G2=>M5+M6:efxmap`partition M3 G2 M5 M6)
    <- set`union-implies-leq G1+G2=G G1<=G G2<=G
    <- set2efxmap-implies-domain G=>M2 DM-M2=G
    <- efxmap`domain-preserves-leq* M2<=M DM-M2=G DM-M=R G<=R
    <- set`leq-transitive G2<=G G<=R G2<=R
    <- efxmap`partition-disjoint-leq-implies-leq M+G1=>M3+M4 G1^G2
      DM-M=R G1<=R G2<=R _ DM-M1=MS1 G2<=MS1
    <- efxmap`partition-associates M+G1=>M3+M4
      M3+G2=>M5+M6 DM-M=R DM-M1=MS1 G1<=R G2<=MS1 G1^G2
      G1+G2=G M7 (M6^M4:efxmap`disjoint M6 M4)
      (M6+M4=M7:efxmap`join M6 M4 M7)
      (M+G=>M5+M7:efxmap`partition M G M5 M7)
    <- set2efxmap-implies-domain G=>M2 M2=>G
    <- efxmap`join-implies-leq M6+M4=M7 M6<=M7 M4<=M7
    <- efxmap`partition-implies-permission-combine
      M3+G2=>M5+M6 M3=>Pi1 Pi11 Pi12
      (M5=>Pi11:efxmap2perm _ _ _ M5 Pi11)
      (M6=>Pi12:efxmap2perm _ _ _ M6 Pi12) Pi1<=>Pi11+Pi12
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- efxmap`disjoint-join-implies-equiv-converse
      M6^M4 M6+M4=M7 M6=>Pi12 M4=>Pi2 Pi12+Pi2 M7=>Pi12+Pi2 EQV
    <- efxmap`partition-implies-domain M3+G2=>M5+M6 DM-M1=MS1 G2<=MS1 M6=>G2
    <- combine-fldperm _ S-SZ SOC CM-CM CM2PM CML FML S=>G2 S=>GF
      M6=>G2 M6=>Pi12 (ty2perm/ PML2 NN2PF2 A2AF2) EX1
      MX-M6=EX1 Q1 EX1=>Q1 IMP3
    <- efxmap`join-joins-minimum-efx M6+M4=M7 MX-M6=EX1
      MX-M4=EX2 _ MX MX-M7=EX
    <- efx2frac-total EX=>Q
    <- before-read/unique/L2 EX1=>Q1 EX2=>Q2
      EX=>Q MX IMP3 IMP _ IMP4.

%theorem before-read/unique/+f/F
  : forall* {CM} {PM} {B} {NN} {A} {FC} {M} {G} {SX} {Out} {F}
    forall {V:void}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {Pi3} {SX=>Pi3: shared-efx2perm SX Pi3}
    {M1P} {M2P} {M+G=>M1P+M2P: efxmap`partition M G M1P M2P}
    {Pi1} {M1P=>Pi1: efxmap2perm CM PM B M1P Pi1}
    {Pi2} {M2P=>Pi2: efxmap2perm CM PM B M2P Pi2}
    {X} {MX: efxmap-minimum-efx M2P X}
    {Q} {X2Q: efx2frac X Q}
    {TRANS: transform (Out)
            (output/exists [o]
              (output/expr o
                (combine Pi4
                  (combine (ffperm Q o F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q o F TF) Pi2))
                      (combine Pi1 Pi3))))))}
    true.

%worlds ()
(before-read/unique/+f/F _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(before-read/unique/+f/F _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

- : before-read/unique/+f _ _ _ _ _ _ _ _ _
    (S=>G2:set+nat2set set/0 _ (set/+ _ _))
    _ _ _ _ _ _ _ _ K1 K2 K3 K4 K5 K6 K7 K8 K9 K10 K11 K12 K13 K14 K15 K16 K17
    <- set`size-total MZ
    <- set+nat2set-preserves-size-converse S=>G2 MZ SZ
    <- set`size-unique set`size/0 SZ set`eq/ E
    <- nat`eq-contradiction E V
    <- before-read/unique/+f/F
      V _ K1 K2 K3 K4 K5 K6 K7 K8 K9 K10 K11 K12 K13 K14 K15 K16 K17.

- : before-read/unique/+f set/0 _
    CM-B-M CM-CM CM2PM CML FML DM-M1=MS G1<=M1 _ _ set`union/R
    (G1=>M2:set2efxmap G1 X M2) M2<=M
    (effects2output/unique/+f
      (ty2perm/ PML nn2perm/yes annot2perm/unique)
      (SX=>Pi3:shared-efx2perm SX Pi3) X2Q MX-M2=X
      (M4=>Pi2:efxmap2perm _ _ _ M4 Pi2)
      (M3=>Pi1:efxmap2perm _ _ _ M3 Pi1)
      (M+G1=>M3+M4:efxmap`partition M G1 M3 M4)
      ([_] set2facts/0) B=>Pj1 _)
    _ _ %{=>}% _ (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1 _ SX=>Pi3
    _ _ M+G1=>M3+M4 _ M3=>Pi1 _ M4=>Pi2 _ MX-M2=X _ X2Q
    (transform/inside [o]
        (transform/trans
          (transform/inside [r]
            (transform/implies
              (implies/combine
                (implies/reflexive)
                (implies/trans3
                  (implies/combine
                    (implies/nonlinear
                      (bimplies/trans
                        (bimplies/neg
                          (bimplies/trans
                            (bimplies/conj/XX
                              (bimplies/reflexive)
                              (bimplies/rem-negneg))
                            (bimplies/conj-true))
                          (bool`ne/FT))
                        (bimplies/trans
                          (bimplies/rem-negneg)
                          (bimplies/objequal-symmetric))))
                    (implies/reflexive))
                  (implies/objequal
                    ([x] (combine (scale Q (nonnull-unique-perm x CP))
                           (combine
                             (unitperm
                               (encumbered
                                 (scale Q (nonnull-unique-perm x CP))
                                 (Pi2)))
                             (combine (Pi1) (Pi3))))))
                  (IMP2 o)))))
          (transform/rem-unused)))
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- pullout-fldperm IMP IMP2.

%worlds ()
(before-read/unique/+f
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(before-read/unique/+f
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique/t
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M} {N1} {N2}
    {SX} {F} {NN} {A} {FC} {G1} {G2} {Out} {G} {R} {CS} {CQ} {X}
    forall {S} {SZ: set`size G1 (s N1)}
    {CM-B-M: clsmap-cxt-set CM B R}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {DM: efxmap`domain M R}
    {G1<=M1: set`leq G1 R}
    {S=>G2: set+nat2set S F G2}
    {G1^G2: set`disjoint G1 G2}
    {G1+G2=G: set`union G1 G2 G}
    {G=>M2: set2efxmap G X M2}
    {M2<=M: efxmap`leq M2 M}
    {M=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique S G1 true))
              (effects/ M CS SX CQ) Out}
    {SOC: same-class B S C}
    {SZ: set`size S N2}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {Pi3} {SX=>Pi3: shared-efx2perm SX Pi3}
    {M1P} {M2P} {M+G=>M1P+M2P: efxmap`partition M G M1P M2P}
    {Pi1} {M1P=>Pi1: efxmap2perm CM PM B M1P Pi1}
    {Pi2} {M2P=>Pi2: efxmap2perm CM PM B M2P Pi2}
    {X1} {MX-M2P: efxmap-minimum-efx M2P X1}
    {X2} {MX-SX: shared-efx2efx SX X2}
    {X} {MX: efx`min X1 X2 X}
    {Q} {X2Q: efx2frac X Q}
    {TRANS: transform (Out)
            (output/exists [o]
              (output/expr o
                (combine Pi4
                  (combine (ffperm Q o F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q o F TF) (combine (Pi2) (Pi3)))) Pi1)))))}
    true.

%theorem before-read/unique/t/F
  : forall* {CM} {PM} {B} {NN} {A} {FC} {M} {G} {SX} {Out} {F}
    forall {V:void}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {Pi3} {SX=>Pi3: shared-efx2perm SX Pi3}
    {M1P} {M2P} {M+G=>M1P+M2P: efxmap`partition M G M1P M2P}
    {Pi1} {M1P=>Pi1: efxmap2perm CM PM B M1P Pi1}
    {Pi2} {M2P=>Pi2: efxmap2perm CM PM B M2P Pi2}
    {X1} {MX-M2P: efxmap-minimum-efx M2P X1}
    {X2} {MX-SX: shared-efx2efx SX X2}
    {X} {MX: efx`min X1 X2 X}
    {Q} {X2Q: efx2frac X Q}
    {TRANS: transform (Out)
            (output/exists [o]
              (output/expr o
                (combine Pi4
                  (combine (ffperm Q o F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q o F TF) (combine (Pi2) (Pi3))))
                      (Pi1))))))}
    true.

%worlds ()
(before-read/unique/t/F _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(before-read/unique/t/F _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

- : before-read/unique/t _ _ _ _ _ _ _ _ _
    (S=>G2:set+nat2set set/0 _ (set/+ _ _))
    _ _ _ _ _ _ _ _ K1 K2 K3 K4 K5 K6 K7 K8 K9 K10 K11 K12 K13 K14 K15
    V1 V2 V3 V4 V5 V6
    <- set`size-total MZ
    <- set+nat2set-preserves-size-converse S=>G2 MZ SZ
    <- set`size-unique set`size/0 SZ set`eq/ E
    <- nat`eq-contradiction E V
    <- before-read/unique/t/F
      V _ K1 K2 K3 K4 K5 K6 K7 K8 K9 K10 K11 K12 K13 K14 K15 V1 V2 V3 V4 V5 V6.

- : before-read/unique/t set/0 _
    CM-B-M CM-CM CM2PM CML FML DM-G1=R1 G1<=R1 _ _ set`join/R
    (G1=>M2:set2efxmap G1 X M2) M2<=M
    (effects2output/unique/t
      (ty2perm/ PML nn2perm/yes annot2perm/unique)
      (SX=>Pi3:shared-efx2perm SX Pi3)
      (EX=>Q:efx2frac EX Q) MX=EX SX=>EX2 MX-M4=EX1
      (M4=>Pi2:efxmap2perm _ _ _ M4 Pi2)
      (M3=>Pi1:efxmap2perm _ _ _ M3 Pi1)
      (M+G1=>M3+M4:efxmap`partition M G1 M3 M4)
      ([_] set2facts/0) B=>Pj1) _ _
    _ (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1 _ SX=>Pi3
    _ _ M+G1=>M3+M4 _ M3=>Pi1 _ M4=>Pi2 _ MX-M4=EX1 _ SX=>EX2 _ MX=EX _ EX=>Q
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/implies
            (implies/combine
              (implies/reflexive)
              (implies/trans3
                (implies/combine
                  (implies/nonlinear
                    (bimplies/trans
                      (bimplies/neg
                        (bimplies/trans
                          (bimplies/conj/XX
                            (bimplies/reflexive)
                            (bimplies/rem-negneg))
                          (bimplies/conj-true))
                        (bool`ne/FT))
                      (bimplies/trans
                        (bimplies/rem-negneg)
                        (bimplies/objequal-symmetric))))
                  (implies/reflexive))
                (implies/objequal
                  ([x] (combine (scale Q (nonnull-unique-perm x CP))
                         (combine
                           (unitperm
                             (encumbered
                               (scale Q (nonnull-unique-perm x CP))
                               (combine (Pi2) (Pi3))))
                           (Pi1)))))
                (IMP2 o)))))
        (transform/rem-unused)))
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- pullout-fldperm IMP IMP2.

- : before-read/unique/t (set/+ _ _) _
    CM-B-M CM-CM CM2PM CML FML DM-M=R G1<=R S=>G2 G1^G2
    (G1+G2=G:set`join G1 G2 G)
    (G=>M2:set2efxmap G X M2) M2<=M
    (effects2output/unique/t
      (ty2perm/ PML nn2perm/yes annot2perm/unique)
      (SX=>Pi3:shared-efx2perm SX Pi3) (EX5=>Q5:efx2frac EX5 Q5)
      (MX42=EX5) (SX=>EX2:shared-efx2efx SX EX2)
      (MX-M4=EX4:efxmap-minimum-efx M4 EX4)
      (M4=>Pi2:efxmap2perm _ _ _ M4 Pi2)
      (M3=>Pi1:efxmap2perm _ _ _ M3 Pi1)
      (M+G1=>M3+M4:efxmap`partition M G1 M3 M4)
      S=>GF B=>Pj1) SOC S-SZ
    _ (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1 _ SX=>Pi3
    M5 M7 M+G=>M5+M7 Pi11 M5=>Pi11 Pi12+Pi2 M7=>Pi12+Pi2
    _ MX-M7=EX6 _ SX=>EX2 _ MX62=EX _ EX=>Q
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/trans
            (transform/implies
              (implies/combine
                (implies/reflexive)
                (implies/trans4
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/combine
                            (implies/reflexive)
                            (implies/equiv
                              (equiv/transitive
                                (Pi1<=>Pi11+Pi12)
                                (equiv/commute))))
                          (implies/equiv equiv/associate)))
                      (implies/equiv equiv/associate)))
                  (implies/equiv equiv/associate)
                  (implies/combine
                    (implies/trans
                      (IMP4 o r)
                      (implies/combine
                        (implies/combine
                          (implies/reflexive)
                          (implies/equiv-encumbered
                            (equiv/reflexive)
                            (equiv/transitive
                              (equiv/associate)
                              (equiv/combine
                                (EQV)
                                (equiv/reflexive)))))
                        (implies/reflexive)))
                    (implies/reflexive))
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine
                        (equiv/commute)
                        (equiv/reflexive))
                      (equiv/symmetric equiv/associate)
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))
            (transform/trans
              (transform/implies (implies/equiv equiv/roll2))
              (transform/drop))))
        (transform/rem-unused)))
    <- efxmap`partition-total (M3+G2=>M5+M6:efxmap`partition M3 G2 M5 M6)
    <- set`union-implies-leq G1+G2=G G1<=G G2<=G
    <- set2efxmap-implies-domain G=>M2 DM-M2=G
    <- efxmap`domain-preserves-leq* M2<=M DM-M2=G DM-M=R G<=R
    <- set`leq-transitive G2<=G G<=R G2<=R
    <- efxmap`partition-disjoint-leq-implies-leq M+G1=>M3+M4 G1^G2
      DM-M=R G1<=R G2<=R _ DM-M1=R1 G2<=R1
    <- efxmap`partition-associates M+G1=>M3+M4
      M3+G2=>M5+M6 DM-M=R DM-M1=R1 G1<=R G2<=R1 G1^G2
      G1+G2=G M7 (M6^M4:efxmap`disjoint M6 M4)
      (M6+M4=M7:efxmap`join M6 M4 M7)
      (M+G=>M5+M7:efxmap`partition M G M5 M7)
    <- set2efxmap-implies-domain G=>M2 M2=>G
    <- efxmap`join-implies-leq M6+M4=M7 M6<=M7 M4<=M7
    <- efxmap`partition-implies-permission-combine
      M3+G2=>M5+M6 M3=>Pi1 Pi11 Pi12
      (M5=>Pi11:efxmap2perm _ _ _ M5 Pi11)
      (M6=>Pi12:efxmap2perm _ _ _ M6 Pi12) Pi1<=>Pi11+Pi12
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- efxmap`disjoint-join-implies-equiv-converse
      M6^M4 M6+M4=M7 M6=>Pi12 M4=>Pi2 Pi12+Pi2 M7=>Pi12+Pi2 EQV
    <- efxmap`partition-implies-domain M3+G2=>M5+M6 DM-M1=R1 G2<=R1 M6=>G2
    <- combine-fldperm _ S-SZ SOC CM-CM CM2PM CML FML S=>G2 S=>GF
      M6=>G2 M6=>Pi12 (ty2perm/ PML2 NN2PF2 A2AF2) EX3 MX-M6=EX3 Q3 EX3=>Q3 IMP3
    <- efx`min-total MX35=EX
    <- efx`min-associative-converse MX42=EX5 MX35=EX EX6 MX34=EX6 MX62=EX
    <- efxmap`join-joins-minimum-efx M6+M4=M7 MX-M6=EX3
      MX-M4=EX4 EX6' MX34=EX6' MX-M7=EX6'
    <- efx`min-unique MX34=EX6' MX34=EX6 efx`eq/ efx`eq/ EX6'=EX6
    <- efxmap-minimum-efx-respects-eq
      MX-M7=EX6' efx`eq/ efxmap`eq/ EX6'=EX6 MX-M7=EX6
    <- efx2frac-total EX=>Q
    <- before-read/unique/L2 EX3=>Q3 EX5=>Q5 EX=>Q MX35=EX IMP3 IMP _ IMP4.

%worlds ()
(before-read/unique/t
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(before-read/unique/t
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique/t*
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M} {N1} {N2}
    {SX} {F} {NN} {A} {FC} {G1} {G2} {Out} {G} {R} {CS} {CQ} {X}
    forall {S} {SZ: set`size G1 N1}
    {CM-B-M: clsmap-cxt-set CM B R}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {DM: efxmap`domain M R}
    {G1<=M1: set`leq G1 R}
    {S=>G2: set+nat2set S F G2}
    {G1^G2: set`disjoint G1 G2}
    {G1+G2=G: set`union G1 G2 G}
    {G=>M2: set2efxmap G X M2}
    {M2<=M: efxmap`leq M2 M}
    {M=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique S G1 true))
              (effects/ M CS SX CQ) Out}
    {SOC: same-class B S C}
    {SZ: set`size S N2}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {Pi3} {SX=>Pi3: shared-efx2perm SX Pi3}
    {M1P} {M2P} {M+G=>M1P+M2P: efxmap`partition M G M1P M2P}
    {Pi1} {M1P=>Pi1: efxmap2perm CM PM B M1P Pi1}
    {Pi2} {M2P=>Pi2: efxmap2perm CM PM B M2P Pi2}
    {X1} {MX-M2P: efxmap-minimum-efx M2P X1}
    {X2} {MX-SX: shared-efx2efx SX X2}
    {X} {MX: efx`min X1 X2 X}
    {Q} {X2Q: efx2frac X Q}
    {TRANS: transform (Out)
            (output/exists [o]
              (output/expr o
                (combine Pi4
                  (combine (ffperm Q o F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q o F TF) (combine (Pi2) (Pi3)))) Pi1)))))}
    true.

- : before-read/unique/t* _ set`size/0
    CM-B-R CM-CM CM2PM CML FML DM-M=R G1<=R S+F=>G2 G1^G2 G1+G2=G
    G=>M2 M2<=M XX=>Out BSC SZ-S %{=>}% _ T2TF _ B=>Pi4 _ SX=>Pi3
    _ _ M|G=M1P+M2P _ M1P=>Pi1 _ M2P=>Pi2 _ MX-M2P _ MX-SX _ MX _ X2Q
    (transform/trans TRANS1 TRANS)
    <- can-transform-to-unique/0t XX=>Out _ XX=>Out' TRANS1
    <- set`union-unique G1+G2=G set`union/L set`eq/ set`eq/ G=G2
    <- set2efxmap-respects-eq G=>M2 G=G2 efx`eq/ efxmap`eq/ G2=>M2
    <- before-read/unique/0t _ SZ-S BSC DM-M=R CM-B-R CM-CM CM2PM
      CML FML S+F=>G2 G2=>M2 M2<=M XX=>Out' _ T2TF _ B=>Pi4 _ SX=>Pi3
      _ _ M|G2=M1P+M2P _ M1P=>Pi1 _ M2P=>Pi2 _ MX-M2P _ MX-SX _ MX _ X2Q TRANS
    <- set`eq-symmetric G=G2 G2=G
    <- efxmap`partition-respects-eq M|G2=M1P+M2P efxmap`eq/ G2=G
      efxmap`eq/ efxmap`eq/ M|G=M1P+M2P.

- : before-read/unique/t* _ (set`size/+ SZ)
    CM-B-R CM-CM CM2PM CML FML DM-M=R G1<=R S+F=>G2 G1^G2 G1+G2=G
    G=>M2 M2<=M XX=>Out BSC SZ-S %{=>}% _ T2TF _ B=>Pi4 _ SX=>Pi3
    _ _ M|G=M1P+M2P _ M1P=>Pi1 _ M2P=>Pi2 _ MX-M2P _ MX-SX _ MX _ X2Q TRANS
    <- before-read/unique/t  _ (set`size/+ SZ)
    CM-B-R CM-CM CM2PM CML FML DM-M=R G1<=R S+F=>G2 G1^G2 G1+G2=G
    G=>M2 M2<=M XX=>Out BSC SZ-S %{=>}% _ T2TF _ B=>Pi4 _ SX=>Pi3
    _ _ M|G=M1P+M2P _ M1P=>Pi1 _ M2P=>Pi2 _ MX-M2P _ MX-SX _ MX _ X2Q TRANS.

%worlds ()
(before-read/unique/t*
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { }
(before-read/unique/t*
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


% a format ready for reading a field

read-format : clsmap -> predmap -> cxt -> nat ->
	 targets -> effects -> (object -> permission) ->
	 permission -> fraction -> type.

read-format/unique/0
  : predmap`lookup PM C CP
    -> shared-efx2perm SX Pi1
    -> efxmap2perm CM PM B M Pi2
    -> read-format CM PM B C
      (targets/unique set/0 set/0 false) (effects/ M _ SX _)
      ([r] nonnull-unique-perm r CP) (Pi2 , Pi1) (fraction/ one).

read-format/unique/+f
  : set`size S (s N)
    -> shared-efx2perm SX Pi1
    -> efxmap`partition M S M1 M2
    -> efxmap2perm CM PM B M1 Pi2
    -> efxmap2perm CM PM B M2 Pi3
    -> efxmap-minimum-efx M2 X
    -> efx2frac X Q
    -> read-format CM PM B _ (targets/unique set/0 S false)
      (effects/ M _ SX _) ([_] Pi3) (Pi2 , Pi1) Q.

read-format/unique/t
  : shared-efx2perm SX Pi1
    -> efxmap`partition M S M1 M2
    -> efxmap2perm CM PM B M1 Pi2
    -> efxmap2perm CM PM B M2 Pi3
    -> efxmap-minimum-efx M2 X1
    -> shared-efx2efx SX X2
    -> efx`min X1 X2 X
    -> efx2frac X Q
    -> read-format CM PM B _ (targets/unique set/0 S true)
      (effects/ M _ SX _) ([_] Pi3 , Pi1) Pi2 Q.


effects-leq-without-consume
  : effects -> effects -> type.

effects-leq-without-consume/
  : efxmap`leq M M'
    -> shared-efx`leq SX SX'
    -> effects-leq-without-consume (effects/ M set/0 SX set/0)
    (effects/ M' CS SX' CQ).


%theorem effects`join-right-implies-effects-leq-without-consume
  : forall* {XX1} {XX} {M} {SX}
    forall {LE: effects`join XX1 (effects/ M set/0 SX set/0) XX}
    exists {LE: effects-leq-without-consume (effects/ M set/0 SX set/0) XX}
    true.

- : effects`join-right-implies-effects-leq-without-consume
    (effects`join/ _ _ _ _ _ _ _ _ M1'+M2=M _ X1+X2=X _ _)
    (effects-leq-without-consume/ M2<=M X2<=X)
    <- efxmap`join-implies-leq M1'+M2=M _ M2<=M
    <- shared-efx`join-implies-leq X1+X2=X _ X2<=X.

%worlds () (effects`join-right-implies-effects-leq-without-consume _ _).
%total {} (effects`join-right-implies-effects-leq-without-consume _ _).


%theorem before-read/unique/L
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Rslt}
    {XX} {XX'} {S2} {S1} {G} {X} {NN1}
    forall {N1} {SZ1: set`size S1 N1}
    {N2} {SZ1: set`size S2 N2} {SB}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: effects2output CM PM B
               (reftype/ nn/yes C (targets/unique S1 S2 SB)) XX' Rslt}
    {MG: make-targets-and-effects (targets/unique S1 S2 SB) F X G XX}
    {LE: effects-leq-without-consume XX XX'}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ NN1 C (targets/unique S1 S2 SB))}
    {CM-B-XX: clsmap-cxt-effects CM B XX'}
    {G-XX: targets-effects (targets/unique S1 S2 SB) XX'}
    exists {Pi1} {Pi2} {Pi3} {Q} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm CM PM B Pi1}
    {REE: read-format CM PM B C G XX' ([r] Pi2 r) Pi3 Q}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/expr r
                (combine Pi1
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm (encumbered (ffperm Q r F TF) (Pi2 r))) Pi3)))))}
    true.

- : before-read/unique/L (s N) SZ-S z _ false
    CM-CM CM2PM CML FML XX=>Rslt
    (make-targets-and-effects/unique S+F=>G D U S=>M
      (CSE: create-shared-efx Efx SXx) _)
    (effects-leq-without-consume/ M<=M' SX<=SX')
    (clsmap-cxt-reftype/unique SOC _ _ _)
    (clsmap-cxt-effects/ DM-M=R' _ _ _ CM-B-R' _)
    (targets-effects/unique DM-M=R S2<=R _)
    _ _ _ _ _ T2TF B=>Pi1
    (read-format/unique/+f
      SZ-G SX=>Pi1 M|G=>M1+M2 M1=>Pi1 M2=>Pi2 M2=>X X2Q) TRANS
    <- efxmap`domain-unique DM-M=R' DM-M=R efxmap`eq/ R'=R
    <- clsmap-cxt-set-respects-eq CM-B-R' clsmap`eq/ cxt`eq/ R'=R CM-B-R
    <- set+nat2set-preserves-size S+F=>G SZ-S SZ-G
    <- before-read/unique/0f DM-M=R CM-B-R CM-CM
      CM2PM CML FML S+F=>G S=>M M<=M' XX=>Rslt SOC SZ-S _ T2TF
      _ B=>Pi1 _ SX=>Pi1 _ _ M|G=>M1+M2 _ M1=>Pi1 _ M2=>Pi2 _ M2=>X _ X2Q TRANS.

- : before-read/unique/L z _ z _ false
    CM-CM CM2PM CML FML XX=>Rslt
    (make-targets-and-effects/unique set+nat2set/0 D U S=>M _ _)
    (effects-leq-without-consume/ M<=M' SX<=SX')
    (clsmap-cxt-reftype/unique SOC _ _ _)
    (clsmap-cxt-effects/ DM-M=R' _ _ _ CM-B-R' _)
    (targets-effects/unique DM-M=R S2<=R _) _ _ _ _ _ T2TF B=>Pi1
    (read-format/unique/0 PML SX=>Pi2 M=>Pi3)
    (transform/trans TRANS
      (transform/inside [r]
        (transform/implies
          (implies/combine
            (implies/reflexive)
            (implies/combine
              (implies/equiv (equiv/symmetric equiv/one))
              (implies/combine
                (implies/equiv-encumbered
                  (equiv/symmetric equiv/one)
                  (equiv/reflexive))
                (implies/reflexive)))))))
    <- efxmap`domain-unique DM-M=R' DM-M=R efxmap`eq/ R'=R
    <- clsmap-cxt-set-respects-eq CM-B-R' clsmap`eq/ cxt`eq/ R'=R CM-B-R
    <- before-read/unique/0 CM-CM CM2PM CML FML
      XX=>Rslt _ T2TF _ B=>Pi1 _ PML _ SX=>Pi2 _ M=>Pi3 TRANS.

- : before-read/unique/L _ SZ-S1 (s N) SZ-S2 true
    CM-CM CM2PM CML FML XX=>Rslt
    (make-targets-and-effects/unique S+F=>G D U S=>M _ _)
    (effects-leq-without-consume/ M<=M' SX<=SX')
    (clsmap-cxt-reftype/unique SOC _ _ _)
    (clsmap-cxt-effects/ DM-M=R' _ _ _ CM-B-R' _)
    (targets-effects/unique DM-M=R S2<=R _)
    _ _ _ _ _ T2TF B=>Pi1
    (read-format/unique/t
      SX=>Pi1 M|G=>M1+M2 M1=>Pi1 M2=>Pi2 M2=>X1 SX=>X2 X1+X2=X X2Q) TRANS
    <- efxmap`domain-unique DM-M=R' DM-M=R efxmap`eq/ R'=R
    <- clsmap-cxt-set-respects-eq CM-B-R' clsmap`eq/ cxt`eq/ R'=R CM-B-R
    <- set`union-implies-leq U S2<=S _
    <- set`size-total SZ-S
    <- set`leq-implies-size-le S2<=S SZ-S2 SZ-S SZ-LE
    <- ge-succ-implies-succ SZ-LE _ EQ
    <- set`size-respects-eq SZ-S set`eq/ EQ SZ-S'
    <- before-read/unique/t _ SZ-S2
      CM-B-R CM-CM CM2PM CML FML DM-M=R S2<=R S+F=>G D U S=>M M<=M'
      XX=>Rslt SOC SZ-S1 _ T2TF _ B=>Pi1 _ SX=>Pi1 _ _ M|G=>M1+M2
      _ M1=>Pi1 _ M2=>Pi2 _ M2=>X1 _ SX=>X2 _ X1+X2=X _ X2Q TRANS.

- : before-read/unique/L _ SZ-S1 (s N) SZ-S2 false
    CM-CM CM2PM CML FML XX=>Rslt
    (make-targets-and-effects/unique S+F=>G D U S=>M _ _)
    (effects-leq-without-consume/ M<=M' SX<=SX')
    (clsmap-cxt-reftype/unique SOC _ _ _)
    (clsmap-cxt-effects/ DM-M=R' _ _ _ CM-B-R' _)
    (targets-effects/unique DM-M=R S2<=R _)
    _ _ _ _ _ T2TF B=>Pi1
    (read-format/unique/+f
      SZ-S' SX=>Pi1 M|G=>M1+M2 M1=>Pi1 M2=>Pi2 M2=>X X2Q) TRANS
    <- efxmap`domain-unique DM-M=R' DM-M=R efxmap`eq/ R'=R
    <- clsmap-cxt-set-respects-eq CM-B-R' clsmap`eq/ cxt`eq/ R'=R CM-B-R
    <- set`union-implies-leq U S2<=S _
    <- set`size-total SZ-S
    <- set`leq-implies-size-le S2<=S SZ-S2 SZ-S SZ-LE
    <- ge-succ-implies-succ SZ-LE _ EQ
    <- set`size-respects-eq SZ-S set`eq/ EQ SZ-S'
    <- before-read/unique/+f _ SZ-S2
      CM-B-R CM-CM CM2PM CML FML DM-M=R S2<=R S+F=>G D U S=>M M<=M'
      XX=>Rslt SOC SZ-S1 _ T2TF _ B=>Pi1 _ SX=>Pi1 _ _ M|G=>M1+M2
      _ M1=>Pi1 _ M2=>Pi2 _ M2=>X _ X2Q TRANS.

- : before-read/unique/L _ SZ-S z _ true
    CM-CM CM2PM CML FML XX=>Rslt
    (make-targets-and-effects/unique S+F=>G D U S=>M _ _)
    (effects-leq-without-consume/ M<=M' SX<=SX')
    (clsmap-cxt-reftype/unique SOC _ _ _)
    (clsmap-cxt-effects/ DM-M=R' _ _ _ CM-B-R' _)
    (targets-effects/unique DM-M=R S2<=R _)
    _ _ _ _ _ T2TF B=>Pi1
    (read-format/unique/t SX=>Pi1 M|G=>M1+M2 M1=>Pi1 M2=>Pi2
      M2=>X1 SX=>X2 X1+X2=X X2Q) (transform/trans TRANS2 TRANS)
    <- efxmap`domain-unique DM-M=R' DM-M=R efxmap`eq/ R'=R
    <- clsmap-cxt-set-respects-eq CM-B-R' clsmap`eq/ cxt`eq/ R'=R CM-B-R
    <- set+nat2set-preserves-size S+F=>G SZ-S SZ-G
    <- can-transform-to-unique/0t XX=>Rslt _ XX=>Rslt' TRANS2
    <- before-read/unique/0t _ SZ-S SOC
      DM-M=R CM-B-R CM-CM CM2PM CML FML S+F=>G S=>M M<=M' XX=>Rslt'
      _ T2TF _ B=>Pi1 _ SX=>Pi1 _ _ M|G=>M1+M2 _ M1=>Pi1 _ M2=>Pi2
      _ M2=>X1 _ SX=>X2 _ X1+X2=X _ X2Q TRANS.

- : before-read/unique/L (s N) SZ-S z _ false
    CM-CM CM2PM CML FML XX=>Rslt
    (make-targets-and-effects/unique S+F=>G D U S=>M _ _)
    (effects-leq-without-consume/ M<=M' SX<=SX')
    (clsmap-cxt-reftype/unique SOC _ _ _)
    (clsmap-cxt-effects/ DM-M=R' _ _ _ CM-B-R' _)
    (targets-effects/unique DM-M=R S2<=R _) _ _ _ _ _ T2TF B=>Pi1
    (read-format/unique/+f
      SZ-G SX=>Pi1 M|G=>M1+M2 M1=>Pi1 M2=>Pi2 M2=>X X2Q) TRANS
    <- efxmap`domain-unique DM-M=R' DM-M=R efxmap`eq/ R'=R
    <- clsmap-cxt-set-respects-eq CM-B-R' clsmap`eq/ cxt`eq/ R'=R CM-B-R
    <- set+nat2set-preserves-size S+F=>G SZ-S SZ-G
    <- before-read/unique/0f DM-M=R CM-B-R CM-CM
      CM2PM CML FML S+F=>G S=>M M<=M' XX=>Rslt SOC SZ-S _ T2TF
      _ B=>Pi1 _ SX=>Pi1 _ _ M|G=>M1+M2 _ M1=>Pi1 _ M2=>Pi2
      _ M2=>X _ X2Q TRANS.

%worlds ()
(before-read/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(before-read/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Rslt}
    {S1} {S2} {SB} {G} {X} {XX} {XX'} {NN1}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: effects2output CM PM B
               (reftype/ nn/yes C (targets/unique S1 S2 SB)) XX' Rslt}
    {MG: make-targets-and-effects (targets/unique S1 S2 SB) F X G XX}
    {LE: effects-leq-without-consume XX XX'}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ NN1 C (targets/unique S1 S2 SB))}
    {CM-B-XX: clsmap-cxt-effects CM B XX'}
    {G-XX: targets-effects (targets/unique S1 S2 SB) XX'}
    exists {Pi1} {Pi2} {Pi3} {Q} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm CM PM B Pi1}
    {REE: read-format CM PM B C G XX' ([r] Pi2 r) Pi3 Q}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/expr r
                (combine Pi1
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm (encumbered (ffperm Q r F TF) (Pi2 r))) Pi3)))))}
    true.

- : before-read/unique CM-CM CM2PM CML FML XX=>Rslt
    MG LE CM-B-G CM-B-XX G-XX _ _ _ _ _ T2TF B=>Pi1 BWF TRANS
    <- set`size-total Z1
    <- set`size-total Z2
    <- before-read/unique/L _ Z1 _ Z2 _
      CM-CM CM2PM CML FML XX=>Rslt MG LE CM-B-G CM-B-XX G-XX
      _ _ _ _ _ T2TF B=>Pi1 BWF TRANS.

%worlds ()
(before-read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(before-read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Rslt}
    {XX} {XX'} {G} {G1} {X}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: effects2output CM PM B (reftype/ nn/yes C G) XX' Rslt}
    {MG: make-targets-and-effects G F X G1 XX}
    {LE: effects-leq-without-consume XX XX'}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ nn/yes C G)}
    {CM-B-XX: clsmap-cxt-effects CM B XX'}
    {G-XX: targets-effects G XX'}
    exists {Pi1} {Pi2} {Pi3} {Q} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm CM PM B Pi1}
    {REE: read-format CM PM B C G1 XX' ([r] Pi2 r) Pi3 Q}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/expr r
                (combine Pi1
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm (encumbered (ffperm Q r F TF) (Pi2 r))) Pi3)))))}
    true.

- : before-read CM-CM CM2PM CML FML XX=>Rslt
    MG LE CM-B-RT CM-B-XX G-XX _ _ _ _ _ T2TF B=>Pi1 BWE TRANS
    <- before-read/unique CM-CM CM2PM CML FML XX=>Rslt
      MG LE CM-B-RT CM-B-XX G-XX _ _ _ _ _ T2TF B=>Pi1 BWE TRANS.

- : before-read CM-CM CM2PM CML FML XX=>Rslt
    (make-targets-and-effects/shared CSE)
    (effects-leq-without-consume/ _ SX<=SX') LE CM-B-G CM-B-XX _ _ _ _ _
    T2TF B=>Pi1 (read-format/unique/t SX=>Pi1 PP M=>Pi2
    efxmap2perm/0 efxmap-minimum-efx/0 SX2X MX X2Q)
    (transform/trans
      (TRANS)
      (transform/inside [r]
        (transform/implies
          (implies/combine implies/reflexive
            (implies/combine implies/reflexive
              (implies/combine
                (implies/equiv-encumbered equiv/reflexive
                  (equiv/transitive
                    (equiv/symmetric equiv/identity)
                    equiv/commute))
                (implies/reflexive)))))))
    <- create-shared-efx-not-none CSE SX-NN
    <- efxmap`partition-on-empty-set _ PP
    <- before-read/shared CM-CM CM2PM CML FML SX<=SX' SX-NN XX=>Rslt
      _ _ _ _ T2TF B=>Pi1 SX=>Pi1 _ SX2X _ X2Q M=>Pi2 TRANS
    <- efx/write-is-upper-bound _ MX.

%worlds () (before-read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).