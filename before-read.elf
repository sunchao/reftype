% Transformations before reading a field.

%theorem cap2frac-leq-implies-implies*
  : forall* {X1} {X2} {Q1} {Q2} {Pi1:object -> permission} {Pi2}
    forall {X2Q: cap2frac X1 Q1}
    {X1<=X2: cap`leq X2 X1}
    {X2Q: cap2frac X2 Q2}
    exists {IMP: {x} implies
      (scale Q1 (Pi1 x) ,
        (unitperm (encumbered (scale Q1 (Pi1 x)) Pi2)))
      (scale Q2 (Pi1 x) ,
        (unitperm (encumbered (scale Q2 (Pi1 x)) Pi2)))}
    true.

- : cap2frac-leq-implies-implies* cap2frac/read (cap`geq/= cap`eq/)
    cap2frac/read ([_] implies/reflexive).

- : cap2frac-leq-implies-implies* cap2frac/write (cap`geq/= cap`eq/)
    cap2frac/write ([_] implies/reflexive).

- : cap2frac-leq-implies-implies* cap2frac/write (cap`geq/> cap`grt/wr)
    cap2frac/read ([_] implies/trans3
      (implies/combine
        (implies/trans4
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/equiv
              (equiv/symmetric (equiv/add 1/2+1/2=1)))
            (implies/trans5
              (implies/equiv (equiv/symmetric equiv/one))
              (implies/scale implies/self-implication)
              (implies/scale-distribute-encumbered)
              (implies/equiv-encumbered
                (equiv/symmetric (equiv/add 1/2+1/2=1))
                (equiv/reflexive))
              (implies/combine-assoc-encumbered)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/linear-modus-ponens)))
        (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/chain-implication))).

%worlds (objvar) (cap2frac-leq-implies-implies* _ _ _ _).
%total {} (cap2frac-leq-implies-implies* _ _ _ _).


%{
 This lemma says if we are given a set of facts about objequal in the form
 of x == r_i, and a set of packed field permissions about each object r_i
 in the facts, then we can get a single field permission for the object x,
 as well as permission for x encumbered in permission for the combined
 field permissions from each r_i.
}%

%theorem combine-fldperm
  : forall* {S} {B} {C} {CM} {PM} {FM} {MS}
    {NN} {A} {FC} {G} {F} {M} {Pi} {PF} {ONN}
    forall {K} {Z: set`size S (s K)}
    {SC: same-class B S C}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {S2S: set+nat2set S F MS}
    {S2G: {x} set2cond B x S (G x)}
    {DM: capmap`domain M MS}
    {M2P: capmap2perm CM PM B M Pi}
    {T2PF: ty2perm PM (ty/ NN A FC) PF}
    {LNN: least-nonnull B S ONN}
    exists {X} {MX-X: capmap-min-cap M X}
    {Q:fraction} {X2Q: cap2frac X Q}
    {IMP: {x} implies
          (combine (G x) Pi)
          (combine (scale Q (unitperm (precise-exists x F PF)))
            (unitperm (encumbered (scale Q (unitperm (precise-exists x F PF))) Pi)))}
    true.

%worlds (objvar) (combine-fldperm _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (N) (combine-fldperm N _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%{
How to prove this? First we need to show that M2 is
less than or equal to M2P, therefore we can get back the
permission for reading field F. For this we need the following
theorem:

  if we have:
    S + F => GM
    GM    => M2
    M2   <= M
    M/GM == M1 , M2P
    --------------------
  then we can get:
    M2   <= M2P
    DM(M2) = DM(M2P)

The immediate result of this is we can convert M2P to two
sets of permissions, say Pi1 and Pi2, and Pi1 is the permissions
generated from M2.

Since we have permission Pi1, as well as the object equal relations,
we can get the field permission, and thus this theorem can be done.

One problem is M1 \join M2 = M, here it's possible that M1 overlaps
with M2, and thus if M2 => GM2, and M / GM2 = M1P + M2P,
M1P will be less than M1.
}%

% this lemma is probably not necessary.

%theorem before-read/unique/L1
  : forall* {CM} {PM} {B} {R} {M2} {M} {S} {X}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {R2M: set2capmap R X M2}
    {M2<=M: capmap`leq M2 M}
    {DM: capmap`domain M S}
    {CM-B-M: clsmap-cxt-fldset CM B S}
    exists {M1'} {M2'}
    {SG: capmap`partition M R M1' M2'}
    {M2'=>R: capmap`domain M2' R}
    {Pi1'} {M1'=>Pi1': capmap2perm CM PM B M1' Pi1'}
    {Pi2'} {M2'=>Pi2': capmap2perm CM PM B M2' Pi2'}
    true.

- : before-read/unique/L1 CM-CM CM2PM R2=>M2
    M2<=M DM CM-B-S _ _ M/R2=M1'+M2' M2'=>R2 _ M1'=>Pi1' _ M2'=>Pi2'
    <- set2capmap-implies-domain R2=>M2 M2=>R2
    <- capmap`partition-total M/R2=M1'+M2'
    <- capmap`partition-implies-leq M/R2=M1'+M2' M1'<=M M2'<=M
    <- capmap`domain-total DM1'
    <- capmap`domain-total DM2'
    <- capmap`domain-preserves-leq* M2'<=M DM2' DM S2'<=S
    <- capmap`domain-preserves-leq* M1'<=M DM1' DM S1'<=S
    <- clsmap-cxt-fldset-respects-geq CM-B-S S2'<=S CM-B-S2'
    <- clsmap-cxt-fldset-respects-geq CM-B-S S1'<=S CM-B-S1'
    <- partition-leq-implies-leq M/R2=M1'+M2' R2=>M2 M2<=M M2<=M2'
    <- clsmap-cxt-fldset-implies-capmap2perm CM-CM CM2PM DM2' CM-B-S2' Pi2' M2'=>Pi2'
    <- clsmap-cxt-fldset-implies-capmap2perm CM-CM CM2PM DM1' CM-B-S1' Pi1' M1'=>Pi1'
    <- capmap`domain-preserves-leq M2<=M M2=>R2 _ M=>R R2<=R
    <- capmap`partition-implies-domain M/R2=M1'+M2' M=>R R2<=R M2'=>R2.

%worlds () (before-read/unique/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _).


% %theorem before-read/unique/L3
%   : forall* {PF} {PF2}
%     forall {CNN: consider-nn PF nn/yes PF2}
%     exists {EQV: {x} equiv (PF2 x) (empty , (PF x))}
%     true.

% % - : before-read/unique/L3 consider-nn/yes
% %     ([_] equiv/transitive (equiv/symmetric equiv/identity) equiv/commute).

% %worlds (objvar) (before-read/unique/L3 _ _).
% %trustme %total { } (before-read/unique/L3 _ _).


%theorem before-read/unique/L2
  : forall* {X1} {X2} {X} {G} {F} {PF} {CP} {Pi2} {Pi12} {Q1} {Q2} {Q}
    forall {X1=>Q1: cap2frac X1 Q1}
    {X2=>Q2: cap2frac X2 Q2}
    {X2Q: cap2frac X Q}
    {MX: cap`min X1 X2 X}
    {IMP1: {x} implies (combine (G x) (Pi12))
          (combine (scale Q1 (unitperm (precise-exists x F PF)))
            (unitperm (encumbered (scale Q1 (unitperm (precise-exists x F PF))) Pi12)))}
    {IMP2: {x} implies (one-predcall CP x)
           (unitperm (nonlinear (nested (unitperm (precise-exists x F PF)) x all)))}
    exists {Pi}
    {IMP: {o}{x} implies
          (combine
            (unitperm (conditional (objequal o x) empty (G o)))
            (combine
              (scale Q2 (nonnull-unique-perm x CP))
              (combine
                (unitperm
                  (encumbered (scale Q2 (nonnull-unique-perm x CP)) Pi2))
                Pi12)))
          (combine
            (combine
              (scale Q (unitperm (precise-exists o F PF)))
              (unitperm
                (encumbered
                  (scale Q (unitperm (precise-exists o F PF)))
                  (combine Pi12 Pi2))))
            (Pi o x))}
    true.

- : before-read/unique/L2 X1=>Q1 X2=>Q2 X=>Q MX IMP1 IMP2 _
    ([o][x]
      (implies/trans5
        (implies/combine
          (implies/cond-gen-inner)
          (implies/reflexive))
        (implies/equiv equiv/commute)
        (implies/cond-push)
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/trans10
            (implies/combine
              (implies/equiv equiv/associate)
              (implies/equiv equiv/identity))
            (implies/equiv equiv/commute)
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/trans
                (implies/combine
                  (implies/nonlinear bimplies/objequal-symmetric)
                  (implies/reflexive))
                (implies/objequal
                  ([o] (scale Q2 (nonnull-unique-perm o CP)) ,
                    (unitperm
                      (encumbered (scale Q2 (nonnull-unique-perm o CP))
                        (Pi2))))))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (add-encumber)
                (implies/equiv-encumbered
                  (equiv/reflexive)
                  (equiv/commute))))
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/identity)
                (equiv/symmetric equiv/associate)))
            (IMP2' o)
            (implies/equiv equiv/associate)
            (implies/combine
              (EMP2 o)
              (implies/reflexive)))
          (implies/trans4
            (implies/equiv
              (equiv/transitive
                (equiv/commute)
                (equiv/symmetric equiv/associate)))
            (implies/combine
              (implies/reflexive)
              (implies/trans5
                (implies/combine % (G , (Pf, (Pf --|- P2 , P12)))
                  (implies/reflexive)
                  (implies/trans3
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv equiv/commute)))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans4
                    (IMP1 o)
                    (implies/combine
                      (implies/equiv
                        (equiv/transitive
                          (equiv/transitive
                            (equiv/symmetric equiv/identity)
                            (equiv/commute))
                          (equiv/commute)))
                      (implies/trans
                        (implies/equiv-encumbered
                          (equiv/transitive
                            (equiv/symmetric equiv/identity)
                            (equiv/commute))
                          equiv/reflexive)
                        (implies/combine-assoc-encumbered)))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/linear-modus-ponens)))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (add-encumber))))
            (implies/equiv equiv/commute)
            (implies/combine
              (EMP1 o)
              (implies/reflexive))))
        (implies/cond-pull)))
    <- pullout-fldperm IMP2 IMP2'
    <- cap`min-implies-geq MX X<=X1 X<=X2
    <- cap2frac-leq-implies-implies* X1=>Q1 X<=X1 X=>Q EMP1
    <- cap2frac-leq-implies-implies* X2=>Q2 X<=X2 X=>Q EMP2.

%worlds () (before-read/unique/L2 _ _ _ _ _ _ _ _).
%total {} (before-read/unique/L2 _ _ _ _ _ _ _ _).


%theorem before-read/unique/1
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M}
    {F} {NN} {A} {FC} {S} {G2} {Out} {K} {R} {X}
    forall {DM: capmap`domain M R}
    {CM-B-R: clsmap-cxt-fldset CM B R}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>G2: set+nat2set S F G2}
    {G2=>M2: set2capmap G2 X M2}
    {M2<=M: capmap`leq M2 M}
    {M=>Out: result2output CM PM
              (result/expr (reftype/ nn/yes C (targets/unique S set/0))
                (env/ B M)) Out}
    {SC: same-class B S C}
    {ANN: least-nonnull B S nn/yes}
    {SZ: set`size S (s K)}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {M1P} {M2P} {M/G2=M1+M2P: capmap`partition M G2 M1P M2P}
    {Pi1} {M1P=>Pi1: capmap2perm CM PM B M1P Pi1}
    {Pi2} {M2P=>Pi2: capmap2perm CM PM B M2P Pi2}
    {X} {MX-M2P: capmap-min-cap M2P X}
    {Q} {X2Q: cap2frac X Q}
    {TRANS: transform Out
            (output/exists [r]
              (output/expr r
                (combine Pi4
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q r F TF) Pi2)) Pi1)))))}
    true.

- : before-read/unique/1
    DM CM-B-R CM-CM CM2PM CM-L FM-L S+F=>G2 G2=>M2 M2<=M
    (result2output/unique/1 (set`size/+ _) set`size/0 _ S=>GF B=>Pi4 M=>Pi)
    B-S-C LNN SZ-S %{=>}% _ T2PF _ B=>Pi4
    _ _ M/G2=M1P+M2P _ M1P=>Pi1P _ M2P=>Pi2P _ MX-M2P Q X2Q
    (transform/inside [r]
      (transform/trans3
        (transform/implies
          (implies/equiv equiv/roll2))
        (transform/drop)
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/reflexive)
              (implies/trans4
                (implies/combine
                  (implies/reflexive)
                  (implies/equiv
                    (equiv/transitive
                      (Pi<=>Pi1P+Pi2P)
                      (equiv/commute))))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans4
                    (IMP r)
                    (implies/combine
                      (implies/equiv
                        (equiv/transitive
                          (equiv/transitive
                            (equiv/symmetric equiv/identity)
                            (equiv/commute))
                          (equiv/commute)))
                      (implies/trans
                        (implies/equiv-encumbered
                          (equiv/transitive
                            (equiv/symmetric equiv/identity)
                            (equiv/commute))
                          equiv/reflexive)
                        (implies/combine-assoc-encumbered)))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/linear-modus-ponens)))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))))
            implies/reflexive))))
    <- before-read/unique/L1
      CM-CM CM2PM G2=>M2 M2<=M DM CM-B-R M1P M2P
      M/G2=M1P+M2P M2P=>G2 _ M1P=>Pi1P _ M2P=>Pi2P
    <- lookup-implies-clsmap-fldmap CM-CM CM-L CM-FM
    <- lookup-implies-clsmap-ty CM-FM FM-L CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- combine-fldperm _ SZ-S B-S-C CM-CM CM2PM CM-L FM-L S+F=>G2
      S=>GF M2P=>G2 M2P=>Pi2P T2PF LNN  _ MX-M2P _ X2Q IMP
    <- capmap`partition-implies-permission-combine*
      M/G2=M1P+M2P M=>Pi M1P=>Pi1P M2P=>Pi2P Pi<=>Pi1P+Pi2P.

%worlds () (before-read/unique/1
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/1
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem capmap`partition-disjoint-leq-implies-leq
  : forall* {M} {G1} {G2} {M1} {M2} {MS}
    forall {P: capmap`partition M G1 M1 M2}
    {DJ: set`disjoint G1 G2} {DM: capmap`domain M MS}
    {LE1: set`leq G1 MS} {LE2: set`leq G2 MS}
    exists {MS1} {DM: capmap`domain M1 MS1} {LE: set`leq G2 MS1}
    true.

%worlds () (capmap`partition-disjoint-leq-implies-leq _ _ _ _ _ _ _ _).
%trustme %total {} (capmap`partition-disjoint-leq-implies-leq _ _ _ _ _ _ _ _).


%theorem before-read/unique/2
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M} {N1}
    {F} {NN} {A} {FC} {G1} {G2} {Out} {G} {R} {X}
    forall {S} {SZ: set`size G1 (s N1)}
    {CM-B-M: clsmap-cxt-fldset CM B R}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CL: clsmap`lookup CM C FM}
    {FL: fldmap`lookup FM F (ty/ NN A FC)}
    {DM: capmap`domain M R}
    {G1<=R: set`leq G1 R}
    {S=>G2: set+nat2set S F G2}
    {G1^G2: set`disjoint G1 G2}
    {G1+G2=G: set`join G1 G2 G}
    {G=>M2: set2capmap G X M2}
    {M2<=M: capmap`leq M2 M}
    {M=>Out: result2output CM PM
              (result/expr (reftype/ nn/yes C (targets/unique S G1))
                (env/ B M)) Out}
    {SOC: same-class B S C}
    {LNN: least-nonnull B S nn/yes}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {M1P} {M2P} {M+G=>M1P+M2P: capmap`partition M G M1P M2P}
    {Pi1} {M1P=>Pi1: capmap2perm CM PM B M1P Pi1}
    {Pi2} {M2P=>Pi2: capmap2perm CM PM B M2P Pi2}
    {X} {MX: capmap-min-cap M2P X}
    {Q} {X2Q: cap2frac X Q}
    {TRANS: transform Out
            (output/exists [o]
              (output/expr o
                (combine Pi4
                  (combine (ffperm Q o F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q o F TF) Pi2))
                      Pi1)))))}
    true.

- : before-read/unique/2 (set/+ _ _) _
    CM-B-M CM-CM CM2PM CML FML (DM-M=R:capmap`domain M R)
    G1<=R S=>G2 G1^G2
    (G1+G2=G:set`union G1 G2 G)
    (G=>M2:set2capmap G X M2) M2<=M
    (result2output/unique/2 _
      (ty2perm/ PML nn2perm/yes annot2perm/unique) S=>GF B=>Pj1
      M+G1=>M3+M4
      (M3=>Pi1:capmap2perm _ _ _ M3 Pi1)
      (M4=>Pi2:capmap2perm _ _ _ M4 Pi2)
      MX-M4=EX2
      (EX2=>Q2:cap2frac EX2 Q2))
    SOC LNN _ (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1
    M5 M7 M+G=>M5+M7 Pi11 M5=>Pi11 Pi12+Pi2 M7=>Pi12+Pi2 _ MX-M7=EX _ EX=>Q
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/trans
            (transform/implies
              (implies/combine
                (implies/reflexive)
                (implies/trans4
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/combine
                            (implies/reflexive)
                            (implies/equiv
                              (equiv/transitive
                                (Pi1<=>Pi11+Pi12)
                                (equiv/commute))))
                          (implies/equiv equiv/associate)))
                      (implies/equiv equiv/associate)))
                  (implies/equiv equiv/associate)
                  (implies/combine
                    (implies/trans
                      (IMP4 o r)
                      (implies/combine
                        (implies/combine
                          (implies/reflexive)
                          (implies/equiv-encumbered
                            (equiv/reflexive)
                            (EQV)))
                        (implies/reflexive)))
                    (implies/reflexive))
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine
                        (equiv/commute)
                        (equiv/reflexive))
                      (equiv/symmetric equiv/associate)
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))
            (transform/trans
              (transform/implies (implies/equiv equiv/roll2))
              (transform/drop)))))
         (transform/rem-unused))
    <- capmap`partition-total (M3+G2=>M5+M6:capmap`partition M3 G2 M5 M6)
    <- set`union-implies-leq G1+G2=G G1<=G G2<=G
    <- set2capmap-implies-domain G=>M2 DM-M2=G
    <- capmap`domain-preserves-leq* M2<=M DM-M2=G DM-M=R G<=R
    <- set`leq-transitive G2<=G G<=R G2<=R
    <- capmap`partition-disjoint-leq-implies-leq M+G1=>M3+M4 G1^G2
      DM-M=R G1<=R G2<=R _ DM-M1=MS1 G2<=MS1
    <- capmap`partition-associates M+G1=>M3+M4
      M3+G2=>M5+M6 DM-M=R DM-M1=MS1 G1<=R G2<=MS1 G1^G2
      G1+G2=G M7 (M6^M4:capmap`disjoint M6 M4)
      (M6+M4=M7:capmap`join M6 M4 M7)
      (M+G=>M5+M7:capmap`partition M G M5 M7)
    <- set2capmap-implies-domain G=>M2 M2=>G
    <- capmap`join-implies-leq M6+M4=M7 M6<=M7 M4<=M7
    <- capmap`partition-implies-permission-combine
      M3+G2=>M5+M6 M3=>Pi1 Pi11 Pi12
      (M5=>Pi11:capmap2perm _ _ _ M5 Pi11)
      (M6=>Pi12:capmap2perm _ _ _ M6 Pi12) Pi1<=>Pi11+Pi12
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- capmap`disjoint-join-implies-equiv-converse
      M6^M4 M6+M4=M7 M6=>Pi12 M4=>Pi2 Pi12+Pi2 M7=>Pi12+Pi2 EQV
    <- capmap`partition-implies-domain M3+G2=>M5+M6 DM-M1=MS1 G2<=MS1 M6=>G2
    <- set`size-total S-SZ
    <- combine-fldperm _ S-SZ SOC CM-CM CM2PM CML FML S=>G2 S=>GF
      M6=>G2 M6=>Pi12 (ty2perm/ PML2 NN2PF2 A2AF2) LNN EX1
      MX-M6=EX1 Q1 EX1=>Q1 IMP3
    <- capmap`join-joins-min-cap M6+M4=M7 MX-M6=EX1
      MX-M4=EX2 _ MX MX-M7=EX
    <- cap2frac-total EX=>Q
    <- before-read/unique/L2 EX1=>Q1 EX2=>Q2
      EX=>Q MX IMP3 IMP _ IMP4.

%theorem before-read/unique/2/F
  : forall* {CM} {PM} {B} {NN} {A} {FC} {M} {G} {Out} {F}
    forall {V:void}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {M1P} {M2P} {M+G=>M1P+M2P: capmap`partition M G M1P M2P}
    {Pi1} {M1P=>Pi1: capmap2perm CM PM B M1P Pi1}
    {Pi2} {M2P=>Pi2: capmap2perm CM PM B M2P Pi2}
    {X} {MX: capmap-min-cap M2P X}
    {Q} {X2Q: cap2frac X Q}
    {TRANS: transform (Out)
            (output/exists [o]
              (output/expr o
                (combine Pi4
                  (combine (ffperm Q o F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q o F TF) Pi2)) Pi1)))))}
    true.

%worlds () (before-read/unique/2/F _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/2/F _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


- : before-read/unique/2 _ _ _ _ _ _ _ _ _
    (S=>G2:set+nat2set set/0 _ (set/+ _ _))
    _ _ _ _ _ _ _ _ K1 K2 K3 K4 K5 K6 K9 K10 K11 K12 K13 K14 K15 K16 K17
    <- set`size-total MZ
    <- set+nat2set-preserves-size-converse S=>G2 MZ SZ
    <- set`size-unique set`size/0 SZ set`eq/ E
    <- nat`eq-contradiction E V
    <- before-read/unique/2/F
      V _ K1 K2 K3 K4 K5 K6 K9 K10 K11 K12 K13 K14 K15 K16 K17.

- : before-read/unique/2 set/0 _
    CM-B-M CM-CM CM2PM CML FML DM-M1=MS G1<=M1 _ _ set`union/R
    (G1=>M2:set2capmap G1 X M2) M2<=M
    (result2output/unique/2 _
      (ty2perm/ PML nn2perm/yes annot2perm/unique) ([_] set2cond/0) B=>Pj1
      (M+G1=>M3+M4:capmap`partition M G1 M3 M4)
      (M3=>Pi1:capmap2perm _ _ _ M3 Pi1)
      (M4=>Pi2:capmap2perm _ _ _ M4 Pi2)
      MX-M2=X X2Q)
    _ _ _ %{=>}% (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1
    _ _ M+G1=>M3+M4 _ M3=>Pi1 _ M4=>Pi2 _ MX-M2=X _ X2Q
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/implies
            (implies/combine
              (implies/reflexive)
              (implies/trans3
                (implies/combine
                  (implies/trans6
                    (implies/cond-gen-inner)
                    (implies/cond-inner
                      (bimplies/reflexive)
                      (bimplies/reflexive)
                      (implies/reflexive)
                      (implies/trans
                        (implies/equiv equiv/commute)
                        (implies/combine
                          (implies/contradiction)
                          (implies/trans
                            (implies/nonlinear bimplies/tt)
                            (implies/true2empty)))))
                    (implies/cond-pull)
                    (implies/combine implies/reflexive implies/cond-equal)
                    (implies/equiv equiv/identity)
                    (implies/nonlinear bimplies/objequal-symmetric))
                  (implies/reflexive))
                (implies/objequal
                  ([x] (combine (scale Q (nonnull-unique-perm x CP))
                         (combine
                           (unitperm
                             (encumbered
                               (scale Q (nonnull-unique-perm x CP))
                               (Pi2)))
                           Pi1))))
                (IMP2 o)))))
          (transform/rem-unused)))
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- pullout-fldperm IMP IMP2.

%worlds ()
(before-read/unique/2
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(before-read/unique/2
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


% a format ready for reading a field

read-format : clsmap -> predmap -> cxt -> nat ->
	 targets -> capmap -> permission -> permission -> fraction -> type.

% read-format/unique/0
%   : predmap`lookup PM C CP
%     -> capmap2perm CM PM B M Pi
%     -> read-format CM PM B C
%       (targets/unique set/0 set/0) (effects/ M _ _)
%       ([r] nonnull-unique-perm r CP) Pi (fraction/ one).

read-format/ : set`size S (s N)
               -> capmap`partition M S M1 M2
               -> capmap2perm CM PM B M1 Pi2
               -> capmap2perm CM PM B M2 Pi3
               -> capmap-min-cap M2 X
               -> cap2frac X Q
               -> read-format CM PM B _ (targets/unique set/0 S) M Pi3 Pi2 Q.


%theorem before-read/unique/L
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Rslt}
    {M} {M'} {S2} {S1} {G} {X}
    forall {N1} {SZ1: set`size S1 N1}
    {N2} {SZ1: set`size S2 N2}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: result2output CM PM
       (result/expr (reftype/ nn/yes C (targets/unique S1 S2)) (env/ B M')) Rslt}
    {MG: make-tgts-and-caps (targets/unique S1 S2) F X G M}
    {M<=M': capmap`leq M M'}
%     {LE: effects-leq-without-consume XX XX'}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ nn/yes C (targets/unique S1 S2))}
    {CM-B-XX: clsmap-cxt-capmap CM B M'}
    {G-XX: targets-capmap (targets/unique S1 S2) M'}
    exists {Pi1} {Pi2} {Pi3} {Q} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm CM PM B Pi1}
    {REE: read-format CM PM B C G M' Pi2 Pi3 Q}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/expr r
                (combine Pi1
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm (encumbered (ffperm Q r F TF) Pi2)) Pi3)))))}
    true.

- : before-read/unique/L (s N) SZ-S z _
    CM-CM CM2PM CML FML XX=>Rslt
    (make-tgts-and-caps/unique S+F=>G D U S=>M)
    M<=M'
    (clsmap-cxt-reftype/unique _ CM-B-S _ WF-TGT)
    (clsmap-cxt-capmap/ DM-M=R' CM-B-R')
    (targets-capmap/unique DM-M=R S2<=R)
    _ _ _ _ _ T2TF B=>Pi1
    (read-format/
      SZ-G M|G=>M1+M2 M1=>Pi1 M2=>Pi2 M2=>X X2Q) TRANS
    <- clsmap-cxt-unique-objset-implies-same-class CM-B-S SOC
    <- clsmap-cxt-unique-objset-implies-least-nonnull CM-B-S LNN
    <- capmap`domain-unique DM-M=R' DM-M=R capmap`eq/ R'=R
    <- clsmap-cxt-fldset-respects-eq CM-B-R' clsmap`eq/ cxt`eq/ R'=R CM-B-R
    <- set+nat2set-preserves-size S+F=>G SZ-S SZ-G
    <- before-read/unique/1 DM-M=R CM-B-R CM-CM
      CM2PM CML FML S+F=>G S=>M M<=M' XX=>Rslt SOC LNN SZ-S _ T2TF
      _ B=>Pi1 _ _ M|G=>M1+M2 _ M1=>Pi1 _ M2=>Pi2 _ M2=>X _ X2Q TRANS.

- : before-read/unique/L _ SZ-S1 (s N) SZ-S2
    CM-CM CM2PM CML FML XX=>Rslt
    (make-tgts-and-caps/unique S+F=>G D U S=>M)
    M<=M'
    (clsmap-cxt-reftype/unique _ CM-B-S _ _)
    (clsmap-cxt-capmap/ DM-M=R' CM-B-R')
    (targets-capmap/unique DM-M=R S2<=R)
    _ _ _ _ _ T2TF B=>Pi1
    (read-format/ SZ-S' M|G=>M1+M2 M1=>Pi1 M2=>Pi2 M2=>X X2Q) TRANS
    <- clsmap-cxt-unique-objset-implies-same-class CM-B-S SOC
    <- clsmap-cxt-unique-objset-implies-least-nonnull CM-B-S LNN
    <- capmap`domain-unique DM-M=R' DM-M=R capmap`eq/ R'=R
    <- clsmap-cxt-fldset-respects-eq CM-B-R' clsmap`eq/ cxt`eq/ R'=R CM-B-R
    <- set`union-implies-leq U S2<=S _
    <- set`size-total SZ-S
    <- set`leq-implies-size-le S2<=S SZ-S2 SZ-S SZ-LE
    <- ge-succ-implies-succ SZ-LE _ EQ
    <- set`size-respects-eq SZ-S set`eq/ EQ SZ-S'
    <- before-read/unique/2 _ SZ-S2
      CM-B-R CM-CM CM2PM CML FML DM-M=R S2<=R S+F=>G D U S=>M M<=M'
      XX=>Rslt SOC LNN _ T2TF _ B=>Pi1 _ _ M|G=>M1+M2
      _ M1=>Pi1 _ M2=>Pi2 _ M2=>X _ X2Q TRANS.

%worlds () (before-read/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Rslt}
    {S1} {S2} {G} {X} {M} {M'}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: result2output CM PM
      (result/expr (reftype/ nn/yes C (targets/unique S1 S2)) (env/ B M')) Rslt}
    {MG: make-tgts-and-caps (targets/unique S1 S2) F X G M}
    {LE: capmap`leq M M'}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ nn/yes C (targets/unique S1 S2))}
    {CM-B-XX: clsmap-cxt-capmap CM B M'}
    {G-XX: targets-capmap (targets/unique S1 S2) M'}
    exists {Pi1} {Pi2} {Pi3} {Q} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm CM PM B Pi1}
    {REE: read-format CM PM B C G M' Pi2 Pi3 Q}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/expr r
                (combine Pi1
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm (encumbered (ffperm Q r F TF) Pi2)) Pi3)))))}
    true.

- : before-read/unique CM-CM CM2PM CML FML XX=>Rslt
    MG LE CM-B-G CM-B-XX G-XX _ _ _ _ _ T2TF B=>Pi1 BWF TRANS
    <- set`size-total Z1
    <- set`size-total Z2
    <- before-read/unique/L _ Z1 _ Z2
      CM-CM CM2PM CML FML XX=>Rslt MG LE CM-B-G CM-B-XX G-XX
      _ _ _ _ _ T2TF B=>Pi1 BWF TRANS.

%worlds ()(before-read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%% Shared

%theorem before-read/shared/L1
  : forall* {XM} {X}
    forall {LE: capmap`leq (capmap/1 z X) XM}
    exists {XM1} {X1} {P: capmap`partition XM (set/1 z) XM1 (capmap/1 z X1)}
    {LE: cap`leq X X1}
    true.

%worlds () (before-read/shared/L1 _ _ _ _ _).
%trustme %total {} (before-read/shared/L1 _ _ _ _ _).


%theorem before-read/shared/L2
  : forall* {CM} {PM} {B} {X} {X1} {Pi}
    forall {XM=>Pi:capmap2perm CM PM B (capmap/1 z X1) Pi}
    {LE: cap`leq X X1}
    exists {Q} {X2Q: cap2frac X1 Q}
    {Pi2} {EQV: equiv Pi ((scale Q (allperm null)) , Pi2)}
    true.

%worlds () (before-read/shared/L2 _ _ _ _ _ _).
%trustme %total {} (before-read/shared/L2 _ _ _ _ _ _).


%theorem before-read/shared
  : forall* {CM} {PM} {FM} {C} {NN} {A} {FC}
    {B} {XM} {Rslt} {F} {X}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {LEQ: capmap`leq (capmap/1 z X) XM}
    {XX=>Rslt: result2output CM PM
      (result/expr (reftype/ nn/yes C targets/shared) (env/ B XM)) Rslt}
    exists {Pi1} {Pi2} {Pi3} {TF} {XM1}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi3: cxt2perm CM PM B Pi3}
    {X1} {Q} {X2Q: cap2frac X1 Q}
    {P: capmap`partition XM (set/1 z) XM1 (capmap/1 z X1)}
    {XM1=>Pi1: capmap2perm CM PM B XM1 Pi1}
    {XM2=>Pi2: capmap2perm CM PM B (capmap/1 z X1) Pi2}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/expr r
                (combine Pi3
                  ((ffperm Q r F TF) ,
                    (unitperm
                      (encumbered
                         (ffperm Q r F TF) Pi2) , Pi1)))))}
    true.

- : before-read/shared
    CM-CM CM2PM CM-L FM-L XM0<=XM
    (result2output/shared (ty2perm/ PM-L nn2perm/yes annot2perm/shared)
      B=>Pi3 XM=>Pi) %{=>}% _ _ _ _ _ (ty2perm/ PM-LF NN2PF A2AF)
    B=>Pi3 _ Q X2Q XM=>XM1+XM0 XM1=>Pi1 XM2=>Pi2
    (transform/inside [r]
      (transform/trans
        (transform/implies
          (implies/trans3
            (implies/combine
              (implies/reflexive)
              (implies/combine
                (implies/reflexive)
                (implies/equiv EQV1)))
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/symmetric equiv/associate)
                    (equiv/combine
                      (equiv/reflexive)
                      (equiv/transitive3
                        (equiv/symmetric equiv/associate)
                        (equiv/combine equiv/reflexive equiv/commute)
                        (equiv/associate)))))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans6
                    (implies/combine
                      (IMP1 r) (IMP2 r))
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/symmetric equiv/associate)
                        (equiv/combine equiv/reflexive equiv/commute)
                        (equiv/associate)))
                    (implies/combine
                      (implies/trans
                        (implies/equiv equiv/commute)
                        (implies/trans5
                          (implies/combine
                            (implies/scale-into-formula)
                            (implies/reflexive))
                          (implies/equiv (equiv/symmetric equiv/distribute))
                          (implies/scale implies/carve)
                          (implies/equiv equiv/distribute)
                          (implies/combine
                            implies/reflexive
                            (implies/scale-distribute-encumbered))))
                      (implies/reflexive))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine implies/reflexive implies/chain-implication))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))))))
            (implies/equiv equiv/reorder)))
        (transform/drop)))
    <- before-read/shared/L1 XM0<=XM _ _ XM=>XM1+XM0 (X<=X1:cap`leq EX EX1)
    <- capmap`partition-implies-permission-combine XM=>XM1+XM0
      XM=>Pi _ _ XM1=>Pi1 XM2=>Pi2 EQV1
    <- before-read/shared/L2 XM2=>Pi2 X<=X1 Q X2Q _ EQV2
    <- can-carve-out-of-shared EQV2 IMP1
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L _ _ _ A2AF NN2PF PM-LF ([r] IMP2 r).

%worlds () (before-read/shared _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/shared _ _ _ _ _ _  _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Rslt}
    {M} {M'} {G} {G1} {X}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: result2output CM PM
       (result/expr (reftype/ nn/yes C G) (env/ B M')) Rslt}
    {MG: make-tgts-and-caps G F X G1 M}
    {LE: capmap`leq M M'}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ nn/yes C G)}
    {CM-B-XX: clsmap-cxt-capmap CM B M'}
    {G-XX: targets-capmap G M'}
    exists {Pi1} {Pi2} {Pi3} {Q} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm CM PM B Pi1}
    {REE: read-format CM PM B C G1 M' Pi2 Pi3 Q}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/expr r
                (combine Pi1
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm (encumbered (ffperm Q r F TF) Pi2)) Pi3)))))}
    true.

- : before-read CM-CM CM2PM CML FML XX=>Rslt
    MG LE CM-B-RT CM-B-XX G-XX _ _ _ _ _ T2TF B=>Pi1 BWE TRANS
    <- before-read/unique CM-CM CM2PM CML FML XX=>Rslt
      MG LE CM-B-RT CM-B-XX G-XX _ _ _ _ _ T2TF B=>Pi1 BWE TRANS.

- : before-read CM-CM CM2PM CML FML XX=>Rslt
    make-tgts-and-caps/shared
    (XM0<=XM:capmap`leq _ XM)
    CM-B-G CM-B-XX G-XX %{=>}% _ _ _ _ _ T2TF B=>Pi3
    (read-format/ (set`size/+ set`size/0)
      XM=>XM0+XM1 XM1=>Pi1 XM0=>Pi0
      (capmap-min-cap/U capmap-min-cap/0 MX capmap`update/0
        capmap`fresh/0) (X2Q:cap2frac EX Q)) TRANS
    <- before-read/shared CM-CM CM2PM CML FML XM0<=XM XX=>Rslt
      %{=>}% _ _ _ _ _ T2TF B=>Pi3 _ _ X2Q XM=>XM0+XM1 XM1=>Pi1 XM0=>Pi0 TRANS
    <- cap/write-is-upper-bound _ MX.

%worlds () (before-read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
