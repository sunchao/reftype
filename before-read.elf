% Transformations before reading a field.

%theorem capmap`partition-disjoint-leq-implies-leq
  : forall* {M} {G1} {G2} {M1} {M2} {MS}
    forall {P: capmap`partition M G1 M1 M2}
    {DJ: set`disjoint G1 G2} {DM: capmap`domain M MS}
    {LE1: set`leq G1 MS} {LE2: set`leq G2 MS}
    exists {MS1} {DM: capmap`domain M1 MS1} {LE: set`leq G2 MS1}
    true.

%worlds (objvar) (capmap`partition-disjoint-leq-implies-leq _ _ _ _ _ _ _ _).
%trustme %total {} (capmap`partition-disjoint-leq-implies-leq _ _ _ _ _ _ _ _).


%theorem capmap-split-empty
  : forall {M}
    exists {M-0=M: capmap-split M capmap/0 M}
    true.

%worlds (objvar) (capmap-split-empty _ _).
%trustme %total { } (capmap-split-empty _ _).



%theorem cap2frac-leq-implies-implies*
  : forall* {X1} {X2} {Q1} {Q2} {Pi1:object -> permission} {Pi2}
    forall {X2Q: cap2frac X1 Q1}
    {X1<=X2: cap`leq X2 X1}
    {X2Q: cap2frac X2 Q2}
    exists {IMP: {x} implies
      (scale Q1 (Pi1 x) ,
        (unitperm (encumbered (scale Q1 (Pi1 x)) Pi2)))
      (scale Q2 (Pi1 x) ,
        (unitperm (encumbered (scale Q2 (Pi1 x)) Pi2)))}
    true.

- : cap2frac-leq-implies-implies* cap2frac/read (cap`geq/= cap`eq/)
    cap2frac/read ([_] implies/reflexive).

- : cap2frac-leq-implies-implies* cap2frac/write (cap`geq/= cap`eq/)
    cap2frac/write ([_] implies/reflexive).

- : cap2frac-leq-implies-implies* cap2frac/write (cap`geq/> cap`grt/wr)
    cap2frac/read ([_] implies/trans3
      (implies/combine
        (implies/trans4
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/equiv
              (equiv/symmetric (equiv/add 1/2+1/2=1)))
            (implies/trans5
              (implies/equiv (equiv/symmetric equiv/one))
              (implies/scale implies/self-implication)
              (implies/scale-distribute-encumbered)
              (implies/equiv-encumbered
                (equiv/symmetric (equiv/add 1/2+1/2=1))
                (equiv/reflexive))
              (implies/combine-assoc-encumbered)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/linear-modus-ponens)))
        (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/chain-implication))).

%worlds (objvar) (cap2frac-leq-implies-implies* _ _ _ _).
%total {} (cap2frac-leq-implies-implies* _ _ _ _).


%{
 This lemma says if we are given a set of facts about objequal in the form
 of x == r_i, and a set of packed field permissions about each object r_i
 in the facts, then we can get a single field permission for the object x,
 as well as permission for x encumbered in permission for the combined
 field permissions from each r_i.
}%

%theorem combine-fldperm
  : forall* {S} {B} {C} {CM} {PM} {FM} {X}
    {NN} {A} {FC} {G} {F} {M} {Pi} {PF} {ONN} {Q}
    forall {K} {Z: set`size S (s K)}
    {SC: same-class B S C}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {S2S: set+nat2capmap S F X M}
    {X2Q: cap2frac X Q}
    {S2G: {x} set2cond B x S (G x)}
    {M2P: capmap2perm CM PM B M Pi}
    {T2PF: ty2perm PM (ty/ NN A FC) PF}
    {LNN: least-nonnull B S ONN}
    exists
    {IMP: {x} implies
          (combine (G x) Pi)
          (combine (scale Q (unitperm (precise-exists x F PF)))
            (unitperm (encumbered (scale Q (unitperm (precise-exists x F PF))) Pi)))}
    true.

%worlds (objvar) (combine-fldperm _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (N) (combine-fldperm N _ _ _ _ _ _ _ _ _ _ _ _ _).


%{
How to prove this? First we need to show that M2 is
less than or equal to M2P, therefore we can get back the
permission for reading field F. For this we need the following
theorem:

  if we have:
    S + F => GM
    GM    => M2
    M2   <= M
    M/GM == M1 , M2P
    --------------------
  then we can get:
    M2   <= M2P
    DM(M2) = DM(M2P)

The immediate result of this is we can convert M2P to two
sets of permissions, say Pi1 and Pi2, and Pi1 is the permissions
generated from M2.

Since we have permission Pi1, as well as the object equal relations,
we can get the field permission, and thus this theorem can be done.

One problem is M1 \join M2 = M, here it's possible that M1 overlaps
with M2, and thus if M2 => GM2, and M / GM2 = M1P + M2P,
M1P will be less than M1.
}%

% this lemma is probably not necessary.

%theorem before-read/unique/L1
  : forall* {CM} {PM} {B} {M2} {M3} {M}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {M2<=M: capmap-split M M2 M3}
    {CM-B-M: clsmap-cxt-capmap CM B M}
    exists {Pi1} {M3=>Pi1: capmap2perm CM PM B M3 Pi1}
    {Pi2} {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    true.

- : before-read/unique/L1 CM-CM CM2PM M-M2=M3 CM-B-M _ M3=>Pi3 _ M2=>Pi2
    <- capmap-split-implies-leq M-M2=M3 M2<=M M3<=M
    <- clsmap-cxt-capmap-respects-geq CM-B-M M2<=M CM-B-M2
    <- clsmap-cxt-capmap-respects-geq CM-B-M M3<=M CM-B-M3
    <- clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM CM-B-M2 Pi2 M2=>Pi2
    <- clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM CM-B-M3 Pi3 M3=>Pi3.

%worlds (objvar) (before-read/unique/L1 _ _ _ _ _ _ _ _).
%total {} (before-read/unique/L1 _ _ _ _ _ _ _ _).


% %theorem before-read/unique/L3
%   : forall* {PF} {PF2}
%     forall {CNN: consider-nn PF nn/yes PF2}
%     exists {EQV: {x} equiv (PF2 x) (empty , (PF x))}
%     true.

% % - : before-read/unique/L3 consider-nn/yes
% %     ([_] equiv/transitive (equiv/symmetric equiv/identity) equiv/commute).

% %worlds (objvar) (before-read/unique/L3 _ _).
% %trustme %total { } (before-read/unique/L3 _ _).


%theorem before-read/unique/L2
  : forall* {G} {F} {PF} {CP} {Pi2} {Pi12} {Q}
    forall
    {IMP1: {x} implies (combine (G x) (Pi12))
      (combine (scale Q (unitperm (precise-exists x F PF)))
        (unitperm (encumbered (scale Q (unitperm (precise-exists x F PF))) Pi12)))}
    {IMP2: {x} implies (one-predcall CP x)
           (unitperm (nonlinear (nested (unitperm (precise-exists x F PF)) x all)))}
    exists {Pi}
    {IMP: {o}{x} implies
          (combine
            (unitperm (conditional (objequal o x) empty (G o)))
            (combine
              (scale Q (nonnull-unique-perm x CP))
              (combine
                (unitperm
                  (encumbered (scale Q (nonnull-unique-perm x CP)) Pi2))
                Pi12)))
          (combine
            (combine
              (scale Q (unitperm (precise-exists o F PF)))
              (unitperm
                (encumbered
                  (scale Q (unitperm (precise-exists o F PF)))
                  (combine Pi12 Pi2))))
            (Pi o x))}
    true.

- : before-read/unique/L2 IMP1 IMP2 _
    ([o][x]
      (implies/trans5
        (implies/combine
          (implies/cond-gen-inner)
          (implies/reflexive))
        (implies/equiv equiv/commute)
        (implies/cond-push)
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/trans10
            (implies/combine
              (implies/equiv equiv/associate)
              (implies/equiv equiv/identity))
            (implies/equiv equiv/commute)
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/trans
                (implies/combine
                  (implies/nonlinear bimplies/objequal-symmetric)
                  (implies/reflexive))
                (implies/objequal
                  ([o] (scale Q2 (nonnull-unique-perm o CP)) ,
                    (unitperm
                      (encumbered (scale Q2 (nonnull-unique-perm o CP))
                        (Pi2))))))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (add-encumber)
                (implies/equiv-encumbered
                  (equiv/reflexive)
                  (equiv/commute))))
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/identity)
                (equiv/symmetric equiv/associate)))
            (IMP2' o)
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/reflexive)
              (implies/reflexive)))
          (implies/trans4
            (implies/equiv
              (equiv/transitive
                (equiv/commute)
                (equiv/symmetric equiv/associate)))
            (implies/combine
              (implies/reflexive)
              (implies/trans5
                (implies/combine % (G , (Pf, (Pf --|- P2 , P12)))
                  (implies/reflexive)
                  (implies/trans3
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv equiv/commute)))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans4
                    (IMP1 o)
                    (implies/combine
                      (implies/equiv
                        (equiv/transitive
                          (equiv/transitive
                            (equiv/symmetric equiv/identity)
                            (equiv/commute))
                          (equiv/commute)))
                      (implies/trans
                        (implies/equiv-encumbered
                          (equiv/transitive
                            (equiv/symmetric equiv/identity)
                            (equiv/commute))
                          equiv/reflexive)
                        (implies/combine-assoc-encumbered)))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/linear-modus-ponens)))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (add-encumber))))
            (implies/equiv equiv/commute)
            (implies/combine
              (implies/reflexive)
              (implies/reflexive))))
        (implies/cond-pull)))
    <- pullout-fldperm IMP2 IMP2'.

%worlds (objvar) (before-read/unique/L2 _ _ _ _).
%total {} (before-read/unique/L2 _ _ _ _).


%theorem before-read/unique/1
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M} {M3}
    {F} {NN} {A} {FC} {S} {Out} {K} {X} {Q}
    forall {CM-B-M: clsmap-cxt-capmap CM B M}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S+F+X=>M2: set+nat2capmap S F X M2}
    {X2Q: cap2frac X Q}
    {M-M2P=M3: capmap-split M M2 M3}
    {M=>Out: result2output CM PM
      (result/expr (reftype/ nn/yes C (targets/unique S capmap/0)) (env/ B M)) Out}
    {SC: same-class B S C}
    {ANN: least-nonnull B S nn/yes}
    {SZ: set`size S (s K)}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {Pi1} {M1P=>Pi1: capmap2perm CM PM B M3 Pi1}
    {Pi2} {M2P=>Pi2: capmap2perm CM PM B M2 Pi2}
    {MX-M2P: capmap-min M2 X}
    {TRANS: transform Out
            (output/exists [r]
              (output/expr r
                (combine Pi4
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q r F TF) Pi2)) Pi1)))))}
    true.

- : before-read/unique/1 CM-B-M CM-CM CM2PM CM-L FM-L S+F+X=>M2 X2Q
    (M-M2=M3:capmap-split M M2 M3)
    (result2output/unique/1 (set`size/+ _) capmap`size/0 _ S=>GF B=>Pi4 M=>Pi)
    B-S-C LNN SZ-S %{=>}% _ T2PF _ B=>Pi4
    _ M3=>Pi3 _ M2=>Pi2 MX-M2
    (transform/inside [r]
      (transform/trans3
        (transform/implies
          (implies/equiv equiv/roll2))
        (transform/drop)
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/reflexive)
              (implies/trans4
                (implies/combine
                  (implies/reflexive)
                  (implies/equiv
                    (Pi<=>Pi2+Pi3)
                    ))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans4
                    (IMP r)
                    (implies/combine
                      (implies/equiv
                        (equiv/transitive
                          (equiv/transitive
                            (equiv/symmetric equiv/identity)
                            (equiv/commute))
                          (equiv/commute)))
                      (implies/trans
                        (implies/equiv-encumbered
                          (equiv/transitive
                            (equiv/symmetric equiv/identity)
                            (equiv/commute))
                          equiv/reflexive)
                        (implies/combine-assoc-encumbered)))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/linear-modus-ponens)))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))))
            implies/reflexive))))
    <- before-read/unique/L1
      CM-CM CM2PM M-M2=M3 CM-B-M Pi3
      (M3=>Pi3:capmap2perm CM PM B M3 Pi3) Pi2
      (M2=>Pi2:capmap2perm CM PM B M2 Pi2)
    <- lookup-implies-clsmap-fldmap CM-CM CM-L CM-FM
    <- lookup-implies-clsmap-ty CM-FM FM-L CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- set+nat2capmap-implies-min-cap S+F+X=>M2 MX-M2
    <- combine-fldperm _ SZ-S B-S-C CM-CM CM2PM CM-L FM-L S+F+X=>M2
      X2Q S=>GF M2=>Pi2 T2PF LNN IMP
    <- capmap-split-implies-permission-combine*
      M-M2=M3 M=>Pi M2=>Pi2 M3=>Pi3 Pi<=>Pi2+Pi3.

%worlds (objvar) (before-read/unique/1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique/2/L1
  : forall* {X1} {X2} {Q1} {Q2} {CP} {Pi1} {Pi}
    forall {CE: cap`eq X1 X2}
    {X1=>Q1: cap2frac X1 Q1}
    {X2=>Q2: cap2frac X2 Q2}
    exists {EQV: {x} equiv
                 (combine (scale Q1 (nonnull-unique-perm x CP))
                   (combine
                     (unitperm
                       (encumbered
                         (scale Q1 (nonnull-unique-perm x CP)) Pi1))
                     Pi))
                 (combine (scale Q2 (nonnull-unique-perm x CP))
                   (combine
                     (unitperm
                       (encumbered
                         (scale Q2 (nonnull-unique-perm x CP)) Pi1))
                     Pi))}
    true.

- : before-read/unique/2/L1 cap`eq/ _ _ ([_] equiv/reflexive).

%worlds (objvar) (before-read/unique/2/L1 _ _ _ _).
%total { } (before-read/unique/2/L1 _ _ _ _).


%theorem before-read/unique/2/L2
  : forall* {X1} {X2} {Q1} {Q2} {X4} {Pi1} {Pi2} {Pi}
    forall {CE: cap`eq X1 X2}
    {X1=>Q1: cap2frac X1 Q1}
    {X2=>Q2: cap2frac X2 Q2}
    exists {EQV: {x}{x1} equiv
                 (combine
                       (unitperm (conditional (objequal x x1) empty (Pi x)))
                       (combine
                           (scale Q1
                               (combine
                                   (unitperm
                                       (nonlinear (neg (objequal x1 null))))
                                   (combine (allperm x1) (one-predcall X4 x1))))
                           (combine
                               (unitperm
                                   (encumbered
                                       (scale Q1
                                           (combine
                                               (unitperm
                                                   (nonlinear
                                                       (neg (objequal x1 null))))
                                               (combine (allperm x1)
                                                   (one-predcall X4 x1))))
                                       Pi1))
                               Pi2)))
                 (combine
                       (unitperm (conditional (objequal x x1) empty (Pi x)))
                       (combine
                           (scale Q2
                               (combine
                                   (unitperm
                                       (nonlinear (neg (objequal x1 null))))
                                   (combine (allperm x1) (one-predcall X4 x1))))
                           (combine
                               (unitperm
                                   (encumbered
                                       (scale Q2
                                           (combine
                                               (unitperm
                                                   (nonlinear
                                                       (neg (objequal x1 null))))
                                               (combine (allperm x1)
                                                   (one-predcall X4 x1))))
                                       Pi1))
                               Pi2)))}
    true.

- : before-read/unique/2/L2 cap`eq/ _ _ ([_][_] equiv/reflexive).

%worlds (objvar) (before-read/unique/2/L2 _ _ _ _).
%total { } (before-read/unique/2/L2 _ _ _ _).


%theorem before-read/unique/2
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M} {M1} {N1} {M3} {M4}
    {F} {NN} {A} {FC} {Out} {X} {Q}
    forall {S} {SZ: capmap`size M1 (s N1)}
    {MX-M1: capmap-min M1 X}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CL: clsmap`lookup CM C FM}
    {FL: fldmap`lookup FM F (ty/ NN A FC)}
    {G=>M2: set+nat2capmap S F X M2}
    {X2Q: cap2frac X Q}
    {G1^G2: capmap`disjoint M1 M2}
    {G1+G2=G: capmap`join M1 M2 M3}
    {M2<=M: capmap-split M M2 M4}
    {M=>Out: result2output CM PM
      (result/expr (reftype/ nn/yes C (targets/unique S M1)) (env/ B M)) Out}
    {SOC: same-class B S C}
    {LNN: least-nonnull B S nn/yes}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {Pi1} {M1P=>Pi1: capmap2perm CM PM B M4 Pi1}
    {Pi2} {M2P=>Pi2: capmap2perm CM PM B M3 Pi2}
    {MX: capmap-min M3 X}
    {TRANS: transform Out
            (output/exists [o]
              (output/expr o
                (combine Pi4
                  (combine (ffperm Q o F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q o F TF) Pi2)) Pi1)))))}
    true.


%theorem before-read/unique/2/F
  : forall* {CM} {PM} {B} {NN} {A} {FC} {M4} {M3} {Out} {F} {Q} {X}
    forall {V:void}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm CM PM B Pi4}
    {Pi1} {M1P=>Pi1: capmap2perm CM PM B M4 Pi1}
    {Pi2} {M2P=>Pi2: capmap2perm CM PM B M3 Pi2}
    {MX: capmap-min M3 X}
    {TRANS: transform Out
            (output/exists [o]
              (output/expr o
                (combine Pi4
                  (combine (ffperm Q o F TF)
                    (combine
                      (unitperm
                        (encumbered
                          (ffperm Q o F TF) Pi2)) Pi1)))))}
    true.

%worlds (objvar) (before-read/unique/2/F _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/2/F _ _ _ _ _ _ _ _ _ _ _).


- : before-read/unique/2 (set/+ _ _) _
    (MX-M1=Xx:capmap-min M1 Xx) CM-CM CM2PM CML FML
    (S+F+X=>M2:set+nat2capmap _ F Xx M2) (Xx=>Q:cap2frac Xx Q1) M1^M2
    (M1+M2=M3:capmap`join M1 M2 M3) (M-M2=M4:capmap-split M M2 M4)
    (result2output/unique/2 _
      (ty2perm/ PML nn2perm/yes annot2perm/unique) S=>GF B=>Pj1
      (M=>Pi:capmap2perm _ _ _ M Pi)
      (M1=>Pi1:capmap2perm _ _ _ M1 Pi1)
      (MX-M1=Xx1:capmap-min M1 Xx1)
      (Xx1=>Q:cap2frac Xx1 Q))
    SOC LNN _ (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1
    Pi4 M4=>Pi4 Pi3 M3=>Pi3 MX-M3=Xx
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/trans
            (transform/implies
              (implies/combine
                (implies/reflexive)
                (implies/trans4
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/combine
                            (implies/reflexive)
                            (implies/equiv
                              (Pi<=>Pi2+Pi4)))
                          (implies/equiv equiv/associate)))
                      (implies/equiv equiv/associate)))
                  (implies/equiv equiv/associate)
                  (implies/combine
                    (implies/trans3
                      (implies/equiv (EQV o r))
                      (IMP4 o r)
                      (implies/combine
                        (implies/combine
                          (implies/reflexive)
                          (implies/equiv-encumbered
                            (equiv/reflexive)
                            (equiv/transitive (equiv/commute) Pi1+Pi2<=>Pi3)))
                        (implies/reflexive)))
                    (implies/reflexive))
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine
                        (equiv/commute)
                        (equiv/reflexive))
                      (equiv/symmetric equiv/associate)
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))
            (transform/trans
              (transform/implies (implies/equiv equiv/roll2))
              (transform/drop)))))
         (transform/rem-unused))
    <- set+nat2capmap-implies-min-cap S+F+X=>M2 MX-M2=Xx
    <- capmap-min-unique MX-M1=Xx1 MX-M1=Xx cap`eq/ capmap`eq/ Xx1=Xx
    <- capmap-join-preserves-min-cap MX-M1=Xx MX-M2=Xx M1+M2=M3 MX-M3=Xx
    <- capmap-split-implies-permission-combine M-M2=M4 M=>Pi
      Pi2 Pi4 M2=>Pi2 M4=>Pi4 Pi<=>Pi2+Pi4
    <- capmap`disjoint-join-implies-equiv-converse M1^M2 M1+M2=M3
      M1=>Pi1 M2=>Pi2 Pi3 M3=>Pi3 Pi1+Pi2<=>Pi3
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- set`size-total S-SZ
    <- combine-fldperm _ S-SZ SOC CM-CM CM2PM CML FML S+F+X=>M2 Xx=>Q
      S=>GF M2=>Pi2 (ty2perm/ PML2 NN2PF2 A2AF2) LNN IMP3
    <- before-read/unique/L2 IMP3 IMP _ IMP4
    <- before-read/unique/2/L2 Xx1=Xx Xx1=>Q Xx=>Q EQV.

- : before-read/unique/2 set/0 _ _ _ _ _ _
    (S=>G2:set+nat2capmap set/0 _ _ (capmap/+ _ _ _)) _
    _ _ _ _ _ _ K1 K2 K3 K4 K5 K6 K9 K12 K13 K14
    <- capmap`size-total MZ
    <- set+nat2capmap-preserves-size-converse S=>G2 (capmap`size/+ MZ) SZ
    <- set`size-unique set`size/0 SZ set`eq/ E
    <- nat`eq-contradiction E V
    <- before-read/unique/2/F V K1 K2 K3 K4 K5 K6 K9 K12 K13 K14.

- : before-read/unique/2 set/0 _
    MX-M1=X CM-CM CM2PM CML FML _ (X=>Q:cap2frac Xx2 Q2) _ capmap`join/R M-M2=M4
    (result2output/unique/2 _
      (ty2perm/ PML nn2perm/yes annot2perm/unique) ([_] set2cond/0) B=>Pj1
      (M=>Pi:capmap2perm _ _ _ M Pi)
      (M1=>Pi1:capmap2perm _ _ _ M1 Pi1)
      (MX-M1=Xx1:capmap-min M1 Xx1) (Xx1=>Q:cap2frac Xx1 Q1))
    _ _ _ %{=>}% (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1
    _ M4=>Pi Pi1 M1=>Pi1 MX-M1=X
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/implies
            (implies/combine
              (implies/reflexive)
              (implies/trans3
                (implies/combine
                  (implies/trans6
                    (implies/cond-gen-inner)
                    (implies/cond-inner
                      (bimplies/reflexive)
                      (bimplies/reflexive)
                      (implies/reflexive)
                      (implies/trans
                        (implies/equiv equiv/commute)
                        (implies/combine
                          (implies/contradiction)
                          (implies/trans
                            (implies/nonlinear bimplies/tt)
                            (implies/true2empty)))))
                    (implies/cond-pull)
                    (implies/combine implies/reflexive implies/cond-equal)
                    (implies/equiv equiv/identity)
                    (implies/nonlinear bimplies/objequal-symmetric))
                  (implies/reflexive))
                (implies/objequal
                  ([x] (combine (scale Q1 (nonnull-unique-perm x CP))
                         (combine
                           (unitperm
                             (encumbered
                               (scale Q1 (nonnull-unique-perm x CP))
                               (Pi1)))
                           Pi))))
                (implies/trans (implies/equiv (EQV o)) (IMP2 o))))))
          (transform/rem-unused)))
    <- capmap-split-empty _ M-0=M
    <- capmap-split-unique M-0=M M-M2=M4 capmap`eq/ capmap`eq/ (M=M4:capmap`eq M M4)
    <- capmap2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/ cxt`eq/
      M=M4 permission`eq/ M4=>Pi
    <- capmap-min-unique MX-M1=Xx1 MX-M1=X cap`eq/ capmap`eq/ Xx1=Xx2
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- pullout-fldperm IMP IMP2
    <- before-read/unique/2/L1 Xx1=Xx2 Xx1=>Q X=>Q EQV.

%worlds (objvar) (before-read/unique/2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%%% a format ready for reading a field

read-format : clsmap -> predmap -> cxt ->
	 targets -> capmap -> permission -> permission -> fraction -> type.

read-format/ : capmap`size M2 (s N)
               -> capmap2perm CM PM B M1 Pi2
               -> capmap2perm CM PM B M2 Pi3
               -> capmap-min M2 X
               -> cap2frac X Q
               -> read-format CM PM B (targets/unique set/0 M2) M1 Pi3 Pi2 Q.


%theorem before-read/unique/L
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Rslt}
    {M0} {S2} {S1} {G} {X} {M2} {Q}
    forall {N1} {SZ1: set`size S1 N1}
    {N2} {SZ1: capmap`size S2 N2}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: result2output CM PM
      (result/expr (reftype/ nn/yes C (targets/unique S1 S2)) (env/ B M0)) Rslt}
    {MG: make-tgts-and-caps M0 (targets/unique S1 S2) F X G M2}
    {X2Q: cap2frac X Q}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ nn/yes C (targets/unique S1 S2))}
    {CM-B-XX: clsmap-cxt-capmap CM B M0}
    exists {Pi1} {Pi2} {Pi3} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm CM PM B Pi1}
    {REE: read-format CM PM B G M2 Pi2 Pi3 Q}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/expr r
                (combine Pi1
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm (encumbered (ffperm Q r F TF) Pi2)) Pi3)))))}
    true.

- : before-read/unique/L (s N) SZ-S z _ CM-CM CM2PM CML FML XX=>Rslt
    (make-tgts-and-caps/unique S1+F+X=>M
      MX-S2=X _ (M0-M=M2: capmap-split M0 M M2)) X2Q
    (clsmap-cxt-reftype/unique _ CM-B-S CM-B-S2 WF-TGT)
    CM-B-M0 _ _ _ _ T2TF B=>Pi1
    (read-format/ SZ-M M2=>Pi2 M=>Pi M=>X X2Q) TRANS
    <- cxt-unique-objset-implies-same-class CM-B-S SOC
    <- cxt-unique-objset-implies-least-nonnull CM-B-S LNN
    <- set+nat2capmap-preserves-size S1+F+X=>M SZ-S SZ-M
    <- before-read/unique/1 CM-B-M0 CM-CM CM2PM CML FML S1+F+X=>M X2Q M0-M=M2
      XX=>Rslt SOC LNN SZ-S _ T2TF _ B=>Pi1 _ M2=>Pi2 _ M=>Pi M=>X TRANS.

- : before-read/unique/L _ SZ-S1 (s N) SZ-S2 CM-CM CM2PM CML FML XX=>Rslt
    (make-tgts-and-caps/unique S1+F+X=>M MX-S2=X M3=S2+M
      (M0-M=M2: capmap-split M0 M M2)) X2Q
    (clsmap-cxt-reftype/unique _ CM-B-S CM-B-S2 WF-TGT)
    CM-B-M0 _ _ _ _ T2TF B=>Pi1
    (read-format/ (capmap`size/+ SZ-M3) M2=>Pi2 M3=>Pi3 M3=>X X2Q) TRANS
    <- capmap-split-implies-disjoint-join M3=S2+M S2^M S2+M=M3
    <- cxt-unique-objset-implies-same-class CM-B-S SOC
    <- cxt-unique-objset-implies-least-nonnull CM-B-S LNN
    <- capmap`size-total SZ-M3
    <- before-read/unique/2 _ SZ-S2
      MX-S2=X CM-CM CM2PM CML FML S1+F+X=>M X2Q S2^M S2+M=M3 M0-M=M2
      XX=>Rslt SOC LNN _ T2TF _ B=>Pi1 _ M2=>Pi2 _ M3=>Pi3 M3=>X TRANS.

%worlds (objvar) (before-read/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Rslt}
    {S1} {S2} {G} {X} {M0} {M2} {Q}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: result2output CM PM
      (result/expr (reftype/ nn/yes C (targets/unique S1 S2)) (env/ B M0)) Rslt}
    {MG: make-tgts-and-caps M0 (targets/unique S1 S2) F X G M2}
    {X2Q: cap2frac X Q}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ nn/yes C (targets/unique S1 S2))}
    {CM-B-XX: clsmap-cxt-capmap CM B M0}
    exists {Pi1} {Pi2} {Pi3} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm CM PM B Pi1}
    {REE: read-format CM PM B G M2 Pi2 Pi3 Q}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/expr r
                (combine Pi1
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm (encumbered (ffperm Q r F TF) Pi2)) Pi3)))))}
    true.

- : before-read/unique CM-CM CM2PM CML FML XX=>Rslt
    MG X2Q CM-B-G CM-B-XX _ _ _ _ T2TF B=>Pi1 BWF TRANS
    <- set`size-total Z1
    <- capmap`size-total Z2
    <- before-read/unique/L _ Z1 _ Z2
      CM-CM CM2PM CML FML XX=>Rslt MG X2Q CM-B-G CM-B-XX _ _ _ _ T2TF B=>Pi1 BWF TRANS.

%worlds (objvar)(before-read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%% Shared

%theorem before-read/shared/L1
  : forall* {XM} {X}
    forall {LE: capmap`leq (capmap/1 z X) XM}
    exists {XM1} {X1} {P: capmap`partition XM (set/1 z) XM1 (capmap/1 z X1)}
    {LE: cap`leq X X1}
    true.

%worlds (objvar) (before-read/shared/L1 _ _ _ _ _).
%trustme %total {} (before-read/shared/L1 _ _ _ _ _).


%theorem before-read/shared/L2
  : forall* {CM} {PM} {B} {X} {Pi} {Q}
    forall {XM=>Pi:capmap2perm CM PM B (capmap/1 z X) Pi}
    {X2Q: cap2frac X Q}
    exists {Pi2} {EQV: equiv Pi ((scale Q (allperm null)) , Pi2)}
    true.

%worlds (objvar) (before-read/shared/L2 _ _ _ _).
%trustme %total {} (before-read/shared/L2 _ _ _ _).


%theorem before-read/shared
  : forall* {CM} {PM} {FM} {C} {NN} {A} {FC} {B} {M} {Rslt} {F} {X} {M2} {Q}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {M-SM=M2: capmap-split M (capmap/1 shared-tgt X) M2}
    {X=>Q: cap2frac X Q}
    {XX=>Rslt: result2output CM PM
      (result/expr (reftype/ nn/yes C targets/shared) (env/ B M)) Rslt}
    exists {Pi1} {Pi2} {Pi3} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi3: cxt2perm CM PM B Pi3}
    {M1=>Pi1: capmap2perm CM PM B M2 Pi1}
    {M2=>Pi2: capmap2perm CM PM B (capmap/1 z X) Pi2}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/expr r
                (combine Pi3
                  ((ffperm Q r F TF) ,
                    (unitperm
                      (encumbered
                         (ffperm Q r F TF) Pi2) , Pi1)))))}
    true.

- : before-read/shared
    CM-CM CM2PM CM-L FM-L M-SM=M2 X2Q
    (result2output/shared (ty2perm/ PM-L nn2perm/yes annot2perm/shared)
      B=>Pi3 M=>Pi) %{=>}% _ _ _ _ (ty2perm/ PM-LF NN2PF A2AF)
    B=>Pi3 M2=>Pi2 SM=>Pi1
    (transform/inside [r]
      (transform/trans
        (transform/implies
          (implies/trans3
            (implies/combine
              (implies/reflexive)
              (implies/combine
                (implies/reflexive)
                (implies/equiv
                  (equiv/transitive
                    (EQV1)
                    (equiv/commute)))))
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/symmetric equiv/associate)
                    (equiv/combine
                      (equiv/reflexive)
                      (equiv/transitive3
                        (equiv/symmetric equiv/associate)
                        (equiv/combine equiv/reflexive equiv/commute)
                        (equiv/associate)))))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans6
                    (implies/combine
                      (IMP1 r) (IMP2 r))
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/symmetric equiv/associate)
                        (equiv/combine equiv/reflexive equiv/commute)
                        (equiv/associate)))
                    (implies/combine
                      (implies/trans
                        (implies/equiv equiv/commute)
                        (implies/trans5
                          (implies/combine
                            (implies/scale-into-formula)
                            (implies/reflexive))
                          (implies/equiv (equiv/symmetric equiv/distribute))
                          (implies/scale implies/carve)
                          (implies/equiv equiv/distribute)
                          (implies/combine
                            implies/reflexive
                            (implies/scale-distribute-encumbered))))
                      (implies/reflexive))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine implies/reflexive implies/chain-implication))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))))))
            (implies/equiv equiv/reorder)))
        (transform/drop)))
    <- capmap-split-implies-permission-combine M-SM=M2
      M=>Pi _ _ SM=>Pi1 M2=>Pi2 EQV1
    <- before-read/shared/L2 SM=>Pi1 X2Q _ EQV2
    <- can-carve-out-of-shared EQV2 IMP1
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L _ _ _ A2AF NN2PF PM-LF ([r] IMP2 r).

%worlds (objvar) (before-read/shared _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/shared _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Out}
    {M0} {M2} {G} {G1} {X} {Q}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: result2output CM PM (result/expr (reftype/ nn/yes C G) (env/ B M0)) Out}
    {MG: make-tgts-and-caps M0 G F X G1 M2}
    {X2Q: cap2frac X Q}
    {CM-RSLT: clsmap-result CM (result/expr (reftype/ nn/yes C G) (env/ B M0))}
    exists {Pi1} {Pi2} {Pi3} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm CM PM B Pi1}
    {REE: read-format CM PM B G1 M2 Pi2 Pi3 Q}
    {TRANS: transform Out
            (output/exists [r]
              (output/expr r
                (combine Pi1
                  (combine (ffperm Q r F TF)
                    (combine
                      (unitperm (encumbered (ffperm Q r F TF) Pi2)) Pi3)))))}
    true.

- : before-read CM-CM CM2PM CML FML XX=>Rslt
    MG X2Q (clsmap-result/expr _ _ CM-B-RT CM-B-XX) _ _ _ _ T2TF B=>Pi1 BWE TRANS
    <- before-read/unique CM-CM CM2PM CML FML XX=>Rslt
      MG X2Q CM-B-RT CM-B-XX _ _ _ _ T2TF B=>Pi1 BWE TRANS.

- : before-read CM-CM CM2PM CML FML XX=>Rslt (make-tgts-and-caps/shared SP) X2Q
    (clsmap-result/expr _ _ CM-B-G CM-B-XX) %{=>}% _ _ _ _ T2TF B=>Pi3
    (read-format/ (capmap`size/+ capmap`size/0)
      M1=>Pi1 M0=>Pi0
      (capmap-min/U capmap-min/0 MX capmap`update/0
        capmap`fresh/0) (X2Q:cap2frac EX Q)) TRANS
    <- before-read/shared CM-CM CM2PM CML FML SP X2Q XX=>Rslt
      %{=>}% _ _ _ _ T2TF B=>Pi3 M1=>Pi1 M0=>Pi0 TRANS
    <- cap/write-is-upper-bound _ MX.

%worlds (objvar) (before-read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


read-result-format : clsmap -> nat -> cap -> expr-result -> type.

read-result-format/base :
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F (ty/ NN A FC) ->
    make-tgts-and-caps M0 G F X G1 M2 ->
  read-result-format CM F X (result/expr (reftype/ nn/yes C G) (env/ B M0)).

read-result-format/exists :
    ({x} read-result-format CM F X (Rslt x)) ->
  read-result-format CM F X (result/exists [x] (Rslt x)).


read-format-new : clsmap -> predmap -> nat -> expr-result -> expr-output -> type.

read-format-new/base :
    make-tgts-and-caps M0 G F X G1 M2 ->
    cap2frac X Q ->
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F (ty/ NN A FC) ->
    ty2perm PM (ty/ NN A FC) TF ->
    cxt2perm CM PM B Pi1 ->
    read-format CM PM B G1 M2 Pi2 Pi3 Q ->
  read-format-new CM PM F (result/expr (reftype/ nn/yes C G) (env/ B M0))
      (output/exists [r]
        (output/expr r
          (combine Pi1
            (combine (ffperm Q r F TF)
              (combine
                (unitperm (encumbered (ffperm Q r F TF) Pi2)) Pi3))))).

read-format-new/exists :
    ({x} read-format-new CM PM F (Rslt x) (Out x)) ->
  read-format-new CM PM F (result/exists [x] (Rslt x)) (output/exists [x] (Out x)).


%theorem before-read/new
  : forall* {CM} {PM} {F} {Out} {Rslt} {X}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-RSLT: clsmap-result CM Rslt}
    {RTYP-HELPER: read-result-format CM F X Rslt}
    {XX=>Rslt: result2output CM PM Rslt Out}
    exists {Out2} {TRANS: transform Out Out2}
    {R-FMT-NEW: read-format-new CM PM F Rslt Out2}
    true.

- : before-read/new CM-CM CM2PM CM-Rslt
    (read-result-format/base CML FML MG) Rslt=>Out _ TRANS
    (read-format-new/base MG X2Q CML FML T2PF B2P R-FMT)
    <- cap2frac-total X2Q
    <- before-read CM-CM CM2PM CML FML Rslt=>Out MG X2Q CM-Rslt
      %{=>}% _ _ _ _ T2PF B2P R-FMT TRANS.

- : before-read/new CM-CM CM2PM (clsmap-result/exists ([x] CM-Rslt x))
    (read-result-format/exists ([x] RRF x))
    (result2output/exists ([x] Rslt=>Out x)) _
    (transform/inside [x] (TRANS x))
    (read-format-new/exists ([x] R-FMT-NEW x))
    <- ({x} before-read/new CM-CM CM2PM
         (CM-Rslt x) (RRF x) (Rslt=>Out x) _ (TRANS x) (R-FMT-NEW x)).

%worlds (objvar) (before-read/new _ _ _ _ _ _ _ _).
%total (K) (before-read/new _ _ _ K _ _ _ _).