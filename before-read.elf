% Transformations before reading a field.

%theorem combine-fldperm/L1
  : forall* {PM} {B} {Pi} {N} {O} {A} {C}
    forall {B=>PiB: cxt2perm PM B Pi}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ nn/yes A C))}
    exists {IMP: implies Pi (combine (unitperm (nonlinear (neg (objequal O null)))) Pi)}
    true.

- : combine-fldperm/L1 B=>Pi
    (BL: cxt`lookup _ _ (cxt-info/ O (ty/ _ annot/shared _)))
    (implies/trans6
      (implies/equiv EQV)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/duplicate implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/equiv (equiv/combine equiv/reflexive equiv/associate))
      (implies/combine implies/reflexive (implies/equiv (equiv/symmetric EQV))))
    <- cxt`lookup-implies-fresh-update BL _ FS UD
    <- cxt2perm/U-inversion B=>Pi FS UD _ BP=>PiBP _
      (ty2perm2/shared (ty2perm/ PML nn2perm/yes annot2perm/shared)) EQV.

- : combine-fldperm/L1 B=>Pi
    (BL: cxt`lookup _ _ (cxt-info/ O (ty/ _ annot/borrow _)))
    (implies/trans6
      (implies/equiv EQV)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/duplicate implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/equiv (equiv/combine equiv/reflexive equiv/associate))
      (implies/combine implies/reflexive (implies/equiv (equiv/symmetric EQV))))
    <- cxt`lookup-implies-fresh-update BL _ FS UD
    <- cxt2perm/U-inversion B=>Pi FS UD _ BP=>PiBP _
      (ty2perm2/borrow (ty2perm/ PML nn2perm/yes annot2perm/borrow)) EQV.

- : combine-fldperm/L1 B=>Pi
    (BL: cxt`lookup _ _ (cxt-info/ O (ty/ _ annot/unique _)))
    (implies/trans6
      (implies/equiv EQV)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/duplicate implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/equiv (equiv/combine equiv/reflexive equiv/associate))
      (implies/combine implies/reflexive (implies/equiv (equiv/symmetric EQV))))
    <- cxt`lookup-implies-fresh-update BL _ FS UD
    <- cxt2perm/U-inversion B=>Pi FS UD _ BP=>PiBP _
      (ty2perm2/unique (ty2perm/ PML nn2perm/yes annot2perm/borrow)) EQV.

%worlds (gtermvar) (combine-fldperm/L1 _ _ _).
%total { } (combine-fldperm/L1 _ _ _).


%theorem combine-fldperm/L2
  : forall* {O1} {O2} {F1} {PF1} {Pi}
    forall {EQ: object`eq O1 O2}
    exists {IMP: implies
                 (combine (unitperm (nonlinear (neg (objequal O2 null))))
                   (combine
                     (unitperm
                       (conditional (objequal O1 null) empty
                         (unitperm
                           (precise-exists O1 F1
                             ([x1:gterm objectk] PF1 x1)))))
                     (unitperm
                       (encumbered
                         (unitperm
                           (conditional (objequal O1 null) empty
                             (unitperm
                               (precise-exists O1 F1
                                 ([x2:gterm objectk]
                                   PF1 x2)))))
                         Pi))))
                 (combine
                   (unitperm
                     (precise-exists O1 F1
                       ([x1:gterm objectk] PF1 x1)))
                   (unitperm
                     (encumbered
                       (unitperm
                         (precise-exists O1 F1
                           ([x2:gterm objectk] PF1 x2)))
                       Pi)))}
    true.

- : combine-fldperm/L2 object`eq/
    (implies/trans5
      (implies/combine implies/duplicate implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/equiv (equiv/combine equiv/reflexive equiv/roll2))
      (implies/equiv equiv/associate)
      (implies/combine
        (implies/trans
          (implies/combine implies/reflexive implies/cond-neg)
          (implies/cond-elim))
        (implies/cond-assoc-encumbered/false))).

%worlds (gtermvar) (combine-fldperm/L2 _ _).
%total { } (combine-fldperm/L2 _ _).


%theorem combine-fldperm/L3
  : forall* {OP} {O1} {F1} {PF1} {PF} {F} {Pi}
    forall {OP=O1: {x} object`eq (OP x) O1}
    {F=F1: nat`eq F F1}
    {PE: {x} permission`eq (PF x) (PF1 x)}
    exists {IMP: {x} implies
                 (combine (unitperm (nonlinear (objequal x (OP x))))
                   (combine
                     (unitperm
                       (precise-exists O1 F1
                         ([x1:gterm objectk] PF1 x1)))
                     (unitperm
                       (encumbered
                         (unitperm
                           (precise-exists O1 F1
                             ([x2:gterm objectk] PF1 x2))) Pi))))
                 (combine
                   (unitperm
                     (precise-exists x F ([x1:gterm objectk] PF x1)))
                   (unitperm
                     (encumbered
                       (unitperm
                         (precise-exists x F
                           ([x1:gterm objectk] PF x1))) Pi)))}
    true.

- : combine-fldperm/L3 ([_] object`eq/) nat`eq/ ([_] permission`eq/)
    ([x] implies/trans
      (implies/combine (implies/nonlinear bimplies/objequal-symmetric) implies/reflexive)
      (implies/objequal
        ([y] (combine
               (unitperm
                 (precise-exists y F1
                   ([x1:gterm objectk] PF1 x1)))
               (unitperm
                 (encumbered
                   (unitperm
                     (precise-exists y F1
                       ([x2:gterm objectk] PF1 x2))) Pi)))))).

%worlds (gtermvar) (combine-fldperm/L3 _ _ _ _).
%total { } (combine-fldperm/L3 _ _ _ _).


%theorem combine-fldperm/L4
  : forall* {O1} {O2} {F1} {PF1}
    forall {OE: object`eq O1 O2}
    exists {IMP: implies
                 (combine (unitperm (nonlinear (neg (objequal O2 null))))
                   (unitperm
                     (conditional (objequal O1 null) empty
                       (unitperm
                         (precise-exists O1 F1
                           ([x1:gterm objectk] PF1 x1))))))
                 (unitperm
                   (precise-exists O1 F1
                     ([x1:gterm objectk] PF1 x1)))}
    true.

- : combine-fldperm/L4 object`eq/
    (implies/trans
      (implies/combine implies/reflexive implies/cond-neg)
      (implies/cond-elim)).

%worlds (gtermvar) (combine-fldperm/L4 _ _).
%total { } (combine-fldperm/L4 _ _).


%theorem combine-fldperm/L5
  : forall* {SP} {K} {S}
    forall {NM: set`not-member SP (s K)} {AD: set`add SP (s K) S}
    {SZ: set`size S (s z)}
    exists {E: set`eq SP set/0}
    true.

- : combine-fldperm/L5 set`not-member/0 set`update/0 (set`size/+ set`size/0) set`eq/.

- : combine-fldperm/L5 NM (set`update/= nat`eq/) _ E
    <- set`not-member-contradiction NM F
    <- set`false-implies-eq F E.

%worlds () (combine-fldperm/L5 _ _ _ _).
%total {} (combine-fldperm/L5 _ _ _ _).


%{
 This lemma says if we are given a set of facts about objequal in the form
 of x == r_i, and a set of packed field permissions about each object r_i
 in the facts, then we can get a single field permission for the object x,
 as well as permission for x encumbered in permission for the combined
 field permissions from each r_i.
}%

%theorem combine-fldperm
  : forall* {S} {B} {C} {CM} {PM} {FM}
    {NN} {A} {FC} {G} {F} {M} {Pi} {PF} {PiB}
    forall {K} {Z: set`size S (s K)}
    {SC: cxt-unique-objset B nn/yes C S}
    {B2G: cxt2perm PM B PiB}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {S2S: set+nat2set S F M}
    {S2G: {x} set2cond B x S (G x)}
    {M2P: capset2perm CM PM B M Pi}
    {T2PF: ty2perm PM (ty/ NN A FC) PF}
    exists {IMP: {x} implies
      (combine PiB (combine (G x) Pi))
        (combine PiB
          (combine (unitperm (precise-exists x F PF))
            (unitperm (encumbered (unitperm (precise-exists x F PF)) Pi))))}
    true.

- : combine-fldperm z SZ
    (cxt-unique-objset/U (B-SP-C:cxt-unique-objset B nn/yes C SP)
      (BL:cxt`lookup B (s N) (cxt-info/ O (ty/ nn/yes A C))) _ (nonnull`leq/= nonnull`eq/)
      (N!<SP:set`not-member SP (s N)) (SP+N=S:set`add SP (s N) S)) B2P
    CM-CM CM2PM (CML:clsmap`lookup CM C FM)
    (FML:fldmap`lookup FM F (ty/ FNN FA FC))
    (S+F+X=>M:set+nat2set S F M)
    (S=>G: {x} set2cond B x S (G x))
    (M=>Pi:capset2perm CM PM B M Pi) (T2PF:ty2perm PM (ty/ FNN FA FC) PF)
    ([x] implies/trans7
      (implies/combine implies/reflexive
        (implies/combine (IMP1 x) (implies/equiv (equiv/symmetric EQV))))
      (implies/combine implies/reflexive
        (implies/trans3
          (implies/equiv equiv/commute)
          (implies/cond-push)
          (implies/cond-gen-inner)))
      (implies/cond-push)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans4
          (implies/combine (implies/trans IMP5 (implies/equiv equiv/commute))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive
            (implies/trans5
              (implies/combine implies/reflexive
                (implies/combine implies/reflexive
                  (implies/trans
                    (implies/equiv equiv/identity)
                    (implies/combine (implies/reflexive)
                      (implies/trans5
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/equiv equiv/commute)
                        (implies/combine implies/self-implication implies/reflexive)
                        (add-encumber)
                        (implies/equiv-encumbered equiv/reflexive (EQV)))))))
              (implies/equiv equiv/roll2)
              (implies/combine implies/reflexive IMP6)
              (IMP7 x)
              (implies/equiv (equiv/symmetric equiv/identity))))
          (implies/equiv equiv/associate))
        (implies/trans
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/combine implies/reflexive
                (implies/trans
                  (implies/combine implies/reflexive (IMP3 x))
                  (implies/equiv equiv/commute)))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans3
                  (implies/combine implies/nonlinear2empty implies/reflexive)
                  (implies/equiv (equiv/transitive equiv/commute equiv/identity))
                  (implies/contradiction))
                (implies/equiv (equiv/symmetric equiv/identity)))))
          (implies/trans4
            (implies/combine (implies/trans IMP5 (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/trans5
                (implies/combine implies/reflexive
                  (implies/combine implies/reflexive
                    (implies/trans
                      (implies/equiv equiv/identity)
                      (implies/combine (implies/reflexive)
                        (implies/trans5
                          (implies/equiv (equiv/symmetric equiv/identity))
                          (implies/equiv equiv/commute)
                          (implies/combine implies/self-implication implies/reflexive)
                          (add-encumber)
                          (implies/equiv-encumbered equiv/reflexive (EQV)))))))
                (implies/equiv equiv/roll2)
                (implies/combine implies/reflexive IMP6)
                (IMP7 x)
                (implies/equiv (equiv/symmetric equiv/identity))))
            (implies/equiv equiv/associate))))
      (implies/cond-pull)
      (implies/combine implies/reflexive implies/cond-equal)
      (implies/equiv equiv/identity))
    <- set+nat2set/U-inversion S+F+X=>M N!<SP SP+N=S MP SP+F+X=>MP KP N+F=>KP MP+KP+X=M
    <- pair2nat-total-s _ _ K N+F=>K
    <- nat`succ-preserves-eq nat`eq/ SE
    <- pair-preserves-eq SE nat`eq/ PE
    <- pair2nat-unique N+F=>KP N+F=>K PE KP=K
    <- set`add-respects-eq MP+KP+X=M set`eq/ KP=K set`eq/ MP+K+X=M
    <- ({x} set2cond/U-inversion (S=>G x) N!<SP SP+N=S (GP x) (SP=>GP x) _ TP (BLP x)
         (IMP1 x) (IMP2 x))
    <- set+nat2set-preserves-not-member SP+F+X=>MP N!<SP N+F=>K K!<MP
    <- capset2perm/U-inversion M=>Pi K!<MP MP+K+X=M _ F1 N1+F1=>K O1 NN1 A1 C1 BL1
      PF1 (create-fldperm/ CML1 FML1 T2PF1) PiP MP=>PiP EQV
    <- combine-fldperm/L5 N!<SP SP+N=S SZ SP=E
    <- ({x} set2cond-implies (SP=>GP x) set2cond/0 object`eq/ SP=E (IMP3 x) (IMP4 x))
    <- set+nat2set-unique SP+F+X=>MP set+nat2set/0 SP=E nat`eq/ MP=E
    <- capset2perm-equiv MP=>PiP capset2perm/0 clsmap`eq/ predmap`eq/ cxt`eq/ MP=E EQV2
    <- nat2pair-unique N1+F1=>K N+F=>K nat`eq/ PAIR-E
    <- pair-eq-implies-eq PAIR-E N1=N F1=F
    <- nat`eq-symmetric N1=N N=N1
    <- nat`eq-symmetric F1=F F=F1
    <- ({x} cxt`lookup-unique (BLP x) BL1 cxt`eq/ N=N1 (CIE-P1 x))
    <- ({x} cxt-info-eq-inversion (CIE-P1 x) (OP=O1 x) TP=T1)
    <- cxt`lookup-unique BL BL1 cxt`eq/ N=N1 CIE-1
    <- cxt-info-eq-inversion CIE-1 O=O1 T=T1
    <- ty-eq-inversion T=T1 NN=NN1 A=A1 C=C1
    <- ty`eq-symmetric T=T1 T1=T
    <- clsmap`lookup-unique CML CML1 clsmap`eq/ C=C1 FM=FM1
    <- fldmap`lookup-unique FML FML1 FM=FM1 F=F1 FT=FT1
    <- ty2perm-deterministic T2PF T2PF1 predmap`eq/ FT=FT1 PF=PF1
    <- cxt-info-preserves-eq object`eq/ T1=T CIE-EQ
    <- cxt`lookup-respects-eq BL1 cxt`eq/ nat`eq/ CIE-EQ BL1P
    <- combine-fldperm/L1 B2P BL1P IMP5
    <- combine-fldperm/L2 object`eq/ IMP6
    <- combine-fldperm/L3 OP=O1 F=F1 PF=PF1 IMP7.

- : combine-fldperm (s _) SZ
    (cxt-unique-objset/U (B-SP-C:cxt-unique-objset B nn/yes C SP)
      (BL:cxt`lookup B (s N) (cxt-info/ O (ty/ nn/yes A C))) _ (nonnull`leq/= nonnull`eq/)
      (N!<SP:set`not-member SP (s N)) (SP+N=S:set`add SP (s N) S)) B2P
    CM-CM CM2PM (CML:clsmap`lookup CM C FM)
    (FML:fldmap`lookup FM F (ty/ FNN FA FC))
    (S+F+X=>M:set+nat2set S F M)
    (S=>G: {x} set2cond B x S (G x))
    (M=>Pi:capset2perm CM PM B M Pi) (T2PF:ty2perm PM (ty/ FNN FA FC) PF)
    ([x] implies/trans7
      (implies/combine implies/reflexive
        (implies/combine (IMP1 x) (implies/equiv (equiv/symmetric EQV))))
      (implies/combine implies/reflexive
        (implies/trans3
          (implies/equiv equiv/commute)
          (implies/cond-push)
          (implies/cond-gen-inner)))
      (implies/cond-push)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans4
          (implies/combine (implies/trans IMP3 (implies/equiv equiv/commute))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive
            (implies/trans5
              (implies/combine implies/reflexive
                (implies/combine implies/reflexive
                  (implies/trans
                    (implies/equiv equiv/identity)
                    (implies/combine (implies/reflexive)
                      (implies/trans5
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/equiv equiv/commute)
                        (implies/combine implies/self-implication implies/reflexive)
                        (add-encumber)
                        (implies/equiv-encumbered equiv/reflexive (EQV)))))))
              (implies/equiv equiv/roll2)
              (implies/combine implies/reflexive IMP4)
              (IMP5 x)
              (implies/equiv (equiv/symmetric equiv/identity))))
          (implies/equiv equiv/associate))
        (implies/trans9
          (implies/combine implies/reflexive
            (implies/trans
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/associate))
                  (implies/combine implies/reflexive
                    (implies/trans (implies/equiv equiv/commute) implies/reflexive))
                  (implies/equiv equiv/commute)))
              (implies/equiv equiv/roll2)))
          (implies/equiv equiv/associate)
          (implies/combine (IMPP x) implies/reflexive)
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/equiv
            (equiv/transitive
              (equiv/combine equiv/reflexive (equiv/commute))
              (equiv/associate)))
          (implies/combine
            (implies/combine implies/reflexive
              (implies/trans
                (implies/combine implies/nonlinear2empty implies/reflexive)
                (implies/equiv (equiv/transitive equiv/commute equiv/identity))))
            (implies/equiv equiv/commute))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans3
                  (implies/equiv equiv/commute)
                  (add-encumber)
                  (implies/equiv-encumbered
                    (equiv/reflexive)
                    (equiv/transitive equiv/commute EQV)))
                (implies/reflexive))
              (implies/equiv equiv/commute)))
          (implies/equiv (equiv/symmetric equiv/identity))))
      (implies/cond-pull)
      (implies/combine implies/reflexive implies/cond-equal)
      (implies/equiv equiv/identity))
    <- set+nat2set/U-inversion S+F+X=>M N!<SP SP+N=S MP SP+F+X=>MP KP N+F=>KP MP+KP+X=M
    <- pair2nat-total-s _ _ K N+F=>K
    <- nat`succ-preserves-eq nat`eq/ SE
    <- pair-preserves-eq SE nat`eq/ PE
    <- pair2nat-unique N+F=>KP N+F=>K PE KP=K
    <- set`add-respects-eq MP+KP+X=M set`eq/ KP=K set`eq/ MP+K+X=M
    <- ({x} set2cond/U-inversion (S=>G x) N!<SP SP+N=S _ (SP=>GP x) _
         TP (BLP x) (IMP1 x) (IMP2 x))
    <- set+nat2set-preserves-not-member SP+F+X=>MP N!<SP N+F=>K K!<MP
    <- capset2perm/U-inversion M=>Pi K!<MP MP+K+X=M _ F1 N1+F1=>K O1 NN1 A1 C1 BL1
      PF1 (create-fldperm/ CML1 FML1 T2PF1) PiP MP=>PiP EQV
    <- set`not-member-update-increases-size-converse SZ N!<SP SP+N=S SZP
    <- combine-fldperm _ SZP B-SP-C B2P CM-CM CM2PM CML FML SP+F+X=>MP ([x] SP=>GP x)
      MP=>PiP T2PF IMPP
    <- nat2pair-unique N1+F1=>K N+F=>K nat`eq/ PAIR-E
    <- pair-eq-implies-eq PAIR-E N1=N F1=F
    <- nat`eq-symmetric N1=N N=N1
    <- nat`eq-symmetric F1=F F=F1
    <- ({x} cxt`lookup-unique (BLP x) BL1 cxt`eq/ N=N1 (CIE-P1 x))
    <- ({x} cxt-info-eq-inversion (CIE-P1 x) (OP=O1 x) TP=T1)
    <- cxt`lookup-unique BL BL1 cxt`eq/ N=N1 CIE-1
    <- cxt-info-eq-inversion CIE-1 O=O1 T=T1
    <- ty-eq-inversion T=T1 _ _ C=C1
    <- ty`eq-symmetric T=T1 T1=T
    <- clsmap`lookup-unique CML CML1 clsmap`eq/ C=C1 FM=FM1
    <- fldmap`lookup-unique FML FML1 FM=FM1 F=F1 FT=FT1
    <- ty2perm-deterministic T2PF T2PF1 predmap`eq/ FT=FT1 PF=PF1
    <- cxt-info-preserves-eq object`eq/ T1=T CIE-EQ
    <- cxt`lookup-respects-eq BL1 cxt`eq/ nat`eq/ CIE-EQ BL1P
    <- combine-fldperm/L1 B2P BL1P IMP3
    <- combine-fldperm/L2 object`eq/ IMP4
    <- combine-fldperm/L3 OP=O1 F=F1 PF=PF1 IMP5.

%worlds (gtermvar) (combine-fldperm _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N) (combine-fldperm N _ _ _ _ _ _ _ _ _ _ _ _).

%{
How to prove this? First we need to show that M2 is
less than or equal to M2P, therefore we can get back the
permission for reading field F. For this we need the following
theorem:

  if we have:
    S + F => GM
    GM    => M2
    M2   <= M
    M/GM == M1 , M2P
    --------------------
  then we can get:
    M2   <= M2P
    DM(M2) = DM(M2P)

The immediate result of this is we can convert M2P to two
sets of permissions, say Pi1 and Pi2, and Pi1 is the permissions
generated from M2.

Since we have permission Pi1, as well as the object equal relations,
we can get the field permission, and thus this theorem can be done.

One problem is M1 \join M2 = M, here it's possible that M1 overlaps
with M2, and thus if M2 => GM2, and M / GM2 = M1P + M2P,
M1P will be less than M1.
}%


% this lemma is probably not necessary.

%theorem before-read/unique/L1
  : forall* {CM} {PM} {B} {M2} {M3} {M}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {M2<=M: set`split M M2 M3}
    {CM-B-M: clsmap-cxt-capset CM B M}
    exists {Pi1} {M3=>Pi1: capset2perm CM PM B M3 Pi1}
    {Pi2} {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    true.

- : before-read/unique/L1 CM-CM CM2PM
    (set`split/ _ M2+M3=M) CM-B-M _ M3=>Pi3 _ M2=>Pi2
    <- set`union-implies-leq M2+M3=M M2<=M M3<=M
    <- clsmap-cxt-capset-respects-geq CM-B-M M2<=M CM-B-M2
    <- clsmap-cxt-capset-respects-geq CM-B-M M3<=M CM-B-M3
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-B-M2 Pi2 M2=>Pi2
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-B-M3 Pi3 M3=>Pi3.

%worlds (gtermvar) (before-read/unique/L1 _ _ _ _ _ _ _ _).
%total {} (before-read/unique/L1 _ _ _ _ _ _ _ _).


%theorem before-read/unique/L2
  : forall* {G} {F} {PF} {CP} {Pi2} {Pi12} {PiB}
    forall
    {IMP1: {x} implies (combine PiB (combine (G x) (Pi12)))
      (combine PiB
        (combine (unitperm (precise-exists x F PF))
          (unitperm (encumbered (unitperm (precise-exists x F PF)) Pi12))))}
    {IMP2: {x} implies (one-predcall CP x)
           (unitperm (nonlinear (nested (unitperm (precise-exists x F PF)) x all)))}
    exists {Pi}
    {IMP: {o}{x}{v:permission} implies
          (combine PiB
            (combine
              (unitperm (conditional (objequal o x) empty (G o)))
              (combine
                (nonnull-unique-perm x CP)
                (combine
                  (unitperm
                    (encumbered (nonnull-unique-perm x CP) Pi2))
                  Pi12))))
          (combine PiB
            (combine
               (combine
                 (unitperm (precise-exists o F PF))
                 (unitperm
                   (encumbered
                     (unitperm (precise-exists o F PF))
                     (combine Pi12 Pi2))))
              (Pi o x)))}
    true.

- : before-read/unique/L2 IMP1 IMP2 _
    ([o][x][v]
      (implies/trans5
        (implies/combine (implies/reflexive)
          (implies/trans3
            (implies/combine
              (implies/cond-gen-inner)
              (implies/reflexive))
            (implies/equiv equiv/commute)
            (implies/cond-push)))
        (implies/cond-push)
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/combine (implies/reflexive)
            (implies/trans10
              (implies/combine
                (implies/equiv equiv/associate)
                (implies/equiv equiv/identity))
              (implies/equiv equiv/commute)
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans
                  (implies/combine
                    (implies/nonlinear bimplies/objequal-symmetric)
                    (implies/reflexive))
                  (implies/objequal
                    ([o] (nonnull-unique-perm o CP) ,
                      (unitperm
                        (encumbered (nonnull-unique-perm o CP)
                          (Pi2))))))
                (implies/reflexive))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/reflexive)
                (implies/trans
                  (add-encumber)
                  (implies/equiv-encumbered
                    (equiv/reflexive)
                    (equiv/commute))))
              (implies/equiv
                (equiv/transitive
                  (equiv/symmetric equiv/identity)
                  (equiv/symmetric equiv/associate)))
              (IMP2' o v)
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/reflexive)
                (implies/reflexive))))
          (implies/trans3
            (implies/combine (implies/reflexive)
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/commute)
                    (equiv/symmetric equiv/associate)))
                (implies/combine implies/reflexive
                  (implies/trans
                    (implies/combine % (G , (Pf, (Pf --|- P2 , P12)))
                      (implies/reflexive)
                      (implies/trans3
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/linear-modus-ponens)
                          (implies/reflexive))
                        (implies/equiv equiv/commute)))
                    (implies/equiv equiv/associate)))))
            (implies/trans5
              (implies/combine implies/reflexive (implies/equiv equiv/roll2))
              (implies/equiv equiv/associate)
              (implies/combine (IMP1 o) (implies/reflexive))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive (implies/equiv equiv/roll2)))
            (implies/combine (implies/reflexive)
              (implies/trans3
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/trans3
                        (implies/combine
                          (implies/equiv
                            (equiv/transitive
                              (equiv/transitive
                                (equiv/symmetric equiv/identity)
                                (equiv/commute))
                              (equiv/commute)))
                          (implies/trans
                            (implies/equiv-encumbered
                              (equiv/transitive
                                (equiv/symmetric equiv/identity)
                                (equiv/commute))
                              equiv/reflexive)
                            (implies/combine-assoc-encumbered)))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine
                          (implies/reflexive)
                          (implies/linear-modus-ponens)))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans
                        (add-encumber)
                        (implies/equiv-encumbered
                          (equiv/reflexive)
                          (equiv/reflexive))))))
                (implies/equiv equiv/commute)
                (implies/combine
                  (implies/reflexive)
                  (implies/reflexive))))))
        (implies/cond-pull)
        (implies/combine (implies/reflexive)
          (implies/cond-pull))))
  <- pullout-fldperm-var IMP2 IMP2'.

%worlds (gtermvar) (before-read/unique/L2 _ _ _ _).
%total {} (before-read/unique/L2 _ _ _ _).


%theorem before-read/borrow
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M} {M3}
    {F} {NN} {A} {FC} {S} {Out} {K} {U}
    forall {CM-B-M: clsmap-cxt-capset CM B M}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S+F+X=>M2: set+nat2set S F M2}
    {M-M2P=M3: set`split M M2 M3}
    {M=>Out: result2output CM PM B
      (result/expr (reftype/ nn/yes C (targets/unique S set/0 false)) (env/ U M)) Out}
    {SC: cxt-unique-objset B nn/yes C S}
    {SZ: set`size S (s K)}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm PM B Pi4}
    {PiU} {U=>PiU: make-encumbered CM PM B U PiU}
    {Pi1} {M1P=>Pi1: capset2perm CM PM B M3 Pi1}
    {Pi2} {M2P=>Pi2: capset2perm CM PM B M2 Pi2}
    {TRANS: transform Out
            (output/exists [r]
              (output/exists [v:permission]
                (output/expr r
                  (combine PiU
                    (combine Pi4
                      (combine (fperm r F TF)
                        (combine
                          (unitperm
                            (encumbered
                              (fperm r F TF) Pi2)) Pi1)))))))}
    true.

- : before-read/borrow CM-B-M CM-CM CM2PM CM-L FM-L S+F+X=>M2
    (M-M2=M3:set`split M M2 M3)
    (result2output/expr B=>Pi4 (env2input/ U=>PiU M=>Pi)
      (reftype2perm/borrow (set`size/+ _) set`size/0 _ S=>GF))
    B-S-C SZ-S _ T2PF _ B=>Pi4 _ U=>PiU _ M3=>Pi3 _ M2=>Pi2
    (transform/inside [o]
      (transform/trans
        (transform/rem-unused)
        (transform/inside [v]
          (transform/trans3
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/identity)
                    (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))
                (implies/equiv equiv/roll2)))
            (transform/drop)
            (transform/implies
              (implies/trans
                (implies/equiv equiv/roll3)
                (implies/combine
                  (implies/reflexive)
                  (implies/trans3
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans
                        (implies/combine
                          (implies/reflexive)
                          (implies/equiv
                            (Pi<=>Pi2+Pi3)))
                        (implies/equiv equiv/associate)))
                    (implies/trans4
                      (implies/equiv equiv/associate)
                      (implies/combine (IMP o) implies/reflexive)
                      (implies/equiv (equiv/symmetric equiv/associate))
                      (implies/combine
                        (implies/reflexive)
                        (implies/combine
                          (implies/trans3
                            (implies/combine
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/transitive
                                    (equiv/symmetric equiv/identity)
                                    (equiv/commute))
                                  (equiv/commute)))
                              (implies/trans
                                (implies/equiv-encumbered
                                  (equiv/transitive
                                    (equiv/symmetric equiv/identity)
                                    (equiv/commute))
                                  equiv/reflexive)
                                (implies/combine-assoc-encumbered)))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (implies/reflexive)
                              (implies/linear-modus-ponens)))
                          (implies/reflexive))))
                    (implies/combine implies/reflexive
                      (implies/equiv (equiv/symmetric equiv/associate)))))))))))
    <- before-read/unique/L1 CM-CM CM2PM M-M2=M3 CM-B-M Pi3
      (M3=>Pi3:capset2perm CM PM B M3 Pi3) Pi2 (M2=>Pi2:capset2perm CM PM B M2 Pi2)
    <- lookup-implies-clsmap-fldmap CM-CM CM-L CM-FM
    <- lookup-implies-clsmap-ty CM-FM FM-L CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- combine-fldperm _ SZ-S B-S-C B=>Pi4 CM-CM CM2PM CM-L FM-L S+F+X=>M2
      S=>GF M2=>Pi2 T2PF IMP
    <- set`split-implies-permission-combine* M-M2=M3 M=>Pi M2=>Pi2 M3=>Pi3 Pi<=>Pi2+Pi3.

%worlds (gtermvar) (before-read/borrow _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/borrow _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique/2
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M} {M1} {N1} {M3} {M4}
    {F} {NN} {A} {FC} {Out} {U}
    forall {S} {SZ: set`size M1 (s N1)}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CL: clsmap`lookup CM C FM}
    {FL: fldmap`lookup FM F (ty/ NN A FC)}
    {G=>M2: set+nat2set S F M2}
    {G1^G2: set`disjoint M1 M2}
    {G1+G2=G: set`union M1 M2 M3}
    {M2<=M: set`split M M2 M4}
    {M=>Out: result2output CM PM B
      (result/expr (reftype/ nn/yes C (targets/unique S M1 false)) (env/ U M)) Out}
    {SOC: cxt-unique-objset B nn/yes C S}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm PM B Pi4}
    {PiU} {U=>PiU: make-encumbered CM PM B U PiU}
    {Pi1} {M1P=>Pi1: capset2perm CM PM B M4 Pi1}
    {Pi2} {M2P=>Pi2: capset2perm CM PM B M3 Pi2}
    {TRANS: transform Out
            (output/exists [o]
              (output/exists [v:permission]
                (output/expr o
                  (combine PiU
                    (combine Pi4
                      (combine (fperm o F TF)
                        (combine
                          (unitperm
                            (encumbered
                              (fperm o F TF)
                              (Pi2)))
                          Pi1)))))))}
    true.

%theorem before-read/unique/2/F
  : forall* {CM} {PM} {B} {NN} {A} {FC} {M4} {M3} {Out} {F} {U}
    forall {V:void}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm PM B Pi4}
    {PiU} {U=>PiU: make-encumbered CM PM B U PiU}
    {Pi1} {M1P=>Pi1: capset2perm CM PM B M4 Pi1}
    {Pi2} {M2P=>Pi2: capset2perm CM PM B M3 Pi2}
    {TRANS: transform Out
            (output/exists [o]
              (output/exists [v:permission]
                (output/expr o
                  (combine PiU
                    (combine Pi4
                      (combine (fperm o F TF)
                        (combine
                          (unitperm
                            (encumbered
                              (fperm o F TF)
                              (Pi2)))
                          Pi1)))))))}
    true.

%worlds (gtermvar) (before-read/unique/2/F _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/2/F _ _ _ _ _ _ _ _ _ _ _ _).

- : before-read/unique/2 (set/+ _ _) _ CM-CM CM2PM CML FML
    (S+F+X=>M2:set+nat2set _ F M2) M1^M2
    (M1+M2=M3:set`union M1 M2 M3) (M-M2=M4:set`split M M2 M4)
    (result2output/expr B=>Pj1
      (env2input/ U=>PiU M=>Pi)
      (reftype2perm/unique (SZ-M:set`size M1 (s _))
        (ty2perm/ PML nn2perm/yes annot2perm/unique)
        S=>GF (M1=>Pi1:capset2perm _ _ _ M1 Pi1)))
    SOC _ (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1 _ U=>PiU
    Pi4 M4=>Pi4 Pi3 M3=>Pi3
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans3
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/identity)
                      (equiv/roll3)
                      (equiv/combine equiv/reflexive
                        (equiv/combine equiv/reflexive
                          (equiv/transitive
                            (equiv/symmetric equiv/associate)
                            (equiv/combine equiv/reflexive
                              (equiv/symmetric equiv/associate)))))))
                  (implies/combine (implies/reflexive)
                    (implies/trans4
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/combine
                            (implies/reflexive)
                            (implies/trans
                              (implies/combine
                                (implies/reflexive)
                                (implies/trans
                                  (implies/combine
                                    (implies/reflexive)
                                    (implies/equiv
                                      (Pi<=>Pi2+Pi4)))
                                  (implies/equiv equiv/associate)))
                              (implies/equiv equiv/associate)))
                          (implies/equiv equiv/associate)))
                      (implies/trans5
                        (implies/combine implies/reflexive
                          (implies/combine (implies/equiv equiv/reflexive) implies/reflexive))
                        (implies/equiv equiv/associate)
                        (implies/combine (IMP4 o r v) (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine (implies/reflexive)
                          (implies/combine
                            (implies/combine
                              (implies/combine
                                (implies/reflexive)
                                (implies/equiv-encumbered
                                  (equiv/reflexive)
                                  (equiv/transitive (equiv/commute) Pi1+Pi2<=>Pi3)))
                              (implies/reflexive))
                            (implies/reflexive))))
                      (implies/combine
                        (implies/reflexive)
                        (implies/equiv
                          (equiv/transitive3
                            (equiv/combine
                              (equiv/commute)
                              (equiv/reflexive))
                            (equiv/symmetric equiv/associate)
                            (equiv/combine
                              (equiv/reflexive)
                              (equiv/symmetric equiv/associate)))))
                      (implies/equiv equiv/roll2)))
                  (implies/equiv equiv/roll2)))
              (transform/drop))))
        (transform/rem-unused)))
    <- set`split-implies-permission-combine M-M2=M4 M=>Pi
      Pi2 Pi4 M2=>Pi2 M4=>Pi4 Pi<=>Pi2+Pi4
    <- capset`disjoint-join-implies-equiv-converse M1^M2 M1+M2=M3
      M1=>Pi1 M2=>Pi2 Pi3 M3=>Pi3 Pi1+Pi2<=>Pi3
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- set`size-total S-SZ
    <- combine-fldperm _ S-SZ SOC B=>Pj1 CM-CM CM2PM CML FML S+F+X=>M2
      S=>GF M2=>Pi2 (ty2perm/ PML2 NN2PF2 A2AF2) IMP3
    <- before-read/unique/L2 IMP3 IMP _ IMP4.

- : before-read/unique/2 set/0 _ _ _ _ _
    (S=>G2:set+nat2set set/0 _ (set/+ _ _)) _ _ _ _ _
    K1 K2 K3 K4 K5 K6 K9 K12 K13 K14 K15
    <- set`size-total MZ
    <- set+nat2set-preserves-size-converse S=>G2 (set`size/+ MZ) SZ
    <- set`size-unique set`size/0 SZ set`eq/ E
    <- nat`eq-contradiction E V
    <- before-read/unique/2/F V K1 K2 K3 K4 K5 K6 K9 K12 K13 K14 K15.

- : before-read/unique/2 set/0 _
    CM-CM CM2PM CML FML _ _ (M1+0=M1P:set`union M1 set/0 M1P) M-M2=M4
    (result2output/expr B=>Pj1 (env2input/ U=>PiU (M=>Pi:capset2perm _ _ _ M Pi))
      (reftype2perm/unique (SZ-M1:set`size M1 (s _))
        (ty2perm/ PML nn2perm/yes annot2perm/unique) ([_] set2cond/0)
        (M1=>Pi1:capset2perm _ _ _ M1 Pi1)))
    _ _ (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1 _ U=>PiU
    _ M4=>Pi Pi1 M1P=>Pi1
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive3
                    (equiv/identity)
                    (equiv/roll3)
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/symmetric equiv/associate)
                          (equiv/combine equiv/reflexive
                            (equiv/symmetric equiv/associate)))))))
                (implies/combine
                  (implies/reflexive)
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/combine
                        (implies/trans6
                          (implies/cond-gen-inner)
                          (implies/cond-inner
                            (bimplies/reflexive)
                            (bimplies/reflexive)
                            (implies/reflexive)
                            (implies/trans
                              (implies/equiv equiv/commute)
                              (implies/combine
                                (implies/contradiction)
                                (implies/trans
                                  (implies/nonlinear bimplies/tt)
                                  (implies/true2empty)))))
                          (implies/cond-pull)
                          (implies/combine implies/reflexive implies/cond-equal)
                          (implies/equiv equiv/identity)
                          (implies/nonlinear bimplies/objequal-symmetric))
                        (implies/reflexive))
                      (implies/objequal
                        ([x] (combine (nonnull-unique-perm x CP)
                               (combine
                                 (unitperm
                                   (encumbered
                                     (nonnull-unique-perm x CP)
                                     (Pi1)))
                                 Pi))))
                      (IMP2 o v))))))))
        (transform/rem-unused)))
    <- set`union-unique set`union/R M1+0=M1P set`eq/ set`eq/ (M1=M1P:set`eq M1 M1P)
    <- capset2perm-respects-eq M1=>Pi1 clsmap`eq/ predmap`eq/ cxt`eq/
      M1=M1P permission`eq/ M1P=>Pi1
    <- set`split-unique (set`split/ set`disjoint/L set`union/L)
      M-M2=M4 set`eq/ set`eq/ (M=M4:set`eq M M4)
    <- capset2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/ cxt`eq/
      M=M4 permission`eq/ M4=>Pi
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- pullout-fldperm-var IMP IMP2.

%worlds (gtermvar) (before-read/unique/2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique/L3
  : forall* {G} {F} {PF} {CP} {Pi2} {Pi12} {PiB}
    forall
    {IMP1: {x} implies (combine PiB (combine (G x) (Pi12)))
      (combine PiB
        (combine (unitperm (precise-exists x F PF))
          (unitperm (encumbered (unitperm (precise-exists x F PF)) Pi12))))}
    {IMP2: {x} implies (one-predcall CP x)
           (unitperm (nonlinear (nested (unitperm (precise-exists x F PF)) x all)))}
    exists {Pi}
    {IMP: {o}{x}{v:permission} implies
          (combine PiB
            (combine
              (unitperm (conditional (objequal o x) empty (G o)))
              (combine
                (nonnull-unique-perm x CP)
                (combine
                  (unitperm
                    (encumbered (nonnull-unique-perm x CP) (combine Pi2 v)))
                  Pi12))))
          (combine PiB
            (combine
               (combine
                 (unitperm (precise-exists o F PF))
                 (unitperm
                   (encumbered
                     (unitperm (precise-exists o F PF))
                     (combine (combine Pi12 Pi2) v))))
              (Pi o x)))}
    true.

- : before-read/unique/L3 IMP1 IMP2 _
    ([o][x][v:permission]
      (implies/trans5
        (implies/combine (implies/reflexive)
          (implies/trans3
            (implies/combine
              (implies/cond-gen-inner)
              (implies/reflexive))
            (implies/equiv equiv/commute)
            (implies/cond-push)))
        (implies/cond-push)
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/combine (implies/reflexive)
            (implies/trans10
              (implies/combine
                (implies/equiv equiv/associate)
                (implies/equiv equiv/identity))
              (implies/equiv equiv/commute)
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans
                  (implies/combine
                    (implies/nonlinear bimplies/objequal-symmetric)
                    (implies/reflexive))
                  (implies/objequal
                    ([o] (nonnull-unique-perm o CP) ,
                      (unitperm
                        (encumbered (nonnull-unique-perm o CP)
                          (combine Pi2 v))))))
                (implies/reflexive))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/reflexive)
                (implies/trans
                  (add-encumber)
                  (implies/equiv-encumbered
                    (equiv/reflexive)
                    (equiv/transitive equiv/commute equiv/associate))))
              (implies/equiv
                (equiv/transitive
                  (equiv/symmetric equiv/identity)
                  (equiv/symmetric equiv/associate)))
              (IMP2' o x v)
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/reflexive)
                (implies/reflexive))))
          (implies/trans3
            (implies/combine (implies/reflexive)
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/commute)
                    (equiv/symmetric equiv/associate)))
                (implies/combine implies/reflexive
                  (implies/trans
                    (implies/combine % (G , (Pf, (Pf --|- P2 , P12)))
                      (implies/reflexive)
                      (implies/trans3
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/linear-modus-ponens)
                          (implies/reflexive))
                        (implies/equiv equiv/commute)))
                    (implies/equiv equiv/associate)))))
            (implies/trans5
              (implies/combine implies/reflexive (implies/equiv equiv/roll2))
              (implies/equiv equiv/associate)
              (implies/combine (IMP1 o) (implies/reflexive))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive (implies/equiv equiv/roll2)))
            (implies/combine (implies/reflexive)
              (implies/trans3
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/trans3
                        (implies/combine
                          (implies/equiv
                            (equiv/transitive
                              (equiv/transitive
                                (equiv/symmetric equiv/identity)
                                (equiv/commute))
                              (equiv/commute)))
                          (implies/trans
                            (implies/equiv-encumbered
                              (equiv/transitive
                                (equiv/symmetric equiv/identity)
                                (equiv/commute))
                              equiv/reflexive)
                            (implies/combine-assoc-encumbered)))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine
                          (implies/reflexive)
                          (implies/linear-modus-ponens)))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans
                        (add-encumber)
                        (implies/equiv-encumbered
                          (equiv/reflexive)
                          (equiv/associate))))))
                (implies/equiv equiv/commute)
                (implies/combine
                  (implies/reflexive)
                  (implies/reflexive))))))
        (implies/cond-pull)
        (implies/combine (implies/reflexive)
          (implies/cond-pull))))
  <- pullout-fldperm-var2 IMP2 IMP2'.

%worlds (gtermvar) (before-read/unique/L3 _ _ _ _).
%total {} (before-read/unique/L3 _ _ _ _).


%theorem before-read/unique/3
  : forall* {B} {CM} {PM} {FM} {C} {M2} {M} {M1} {M3} {M4}
    {F} {NN} {A} {FC} {Out} {U}
    forall {S}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CL: clsmap`lookup CM C FM}
    {FL: fldmap`lookup FM F (ty/ NN A FC)}
    {G=>M2: set+nat2set S F M2}
    {G1^G2: set`disjoint M1 M2}
    {G1+G2=G: set`union M1 M2 M3}
    {M2<=M: set`split M M2 M4}
    {M=>Out: result2output CM PM B
      (result/expr (reftype/ nn/yes C (targets/unique S M1 true)) (env/ U M)) Out}
    {SOC: cxt-unique-objset B nn/yes C S}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm PM B Pi4}
    {PiU} {U=>PiU: make-encumbered CM PM B U PiU}
    {Pi1} {M1P=>Pi1: capset2perm CM PM B M4 Pi1}
    {Pi2} {M2P=>Pi2: capset2perm CM PM B M3 Pi2}
    {TRANS: transform Out
            (output/exists [o]
              (output/exists [v:permission]
                (output/expr o
                  (combine PiU
                    (combine Pi4
                      (combine (fperm o F TF)
                        (combine
                          (unitperm
                            (encumbered
                              (fperm o F TF)
                              (combine Pi2 v))) Pi1)))))))}
    true.

%theorem before-read/unique/3/F
  : forall* {CM} {PM} {B} {NN} {A} {FC} {M4} {M3} {Out} {F} {U}
    forall {V:void}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm PM B Pi4}
    {PiU} {U=>PiU: make-encumbered CM PM B U PiU}
    {Pi1} {M1P=>Pi1: capset2perm CM PM B M4 Pi1}
    {Pi2} {M2P=>Pi2: capset2perm CM PM B M3 Pi2}
    {TRANS: transform Out
            (output/exists [o]
              (output/exists [v:permission]
                (output/expr o
                  (combine PiU
                    (combine Pi4
                      (combine (fperm o F TF)
                        (combine
                          (unitperm
                            (encumbered
                              (fperm o F TF)
                              (combine Pi2 v))) Pi1)))))))}
    true.

%worlds (gtermvar) (before-read/unique/3/F _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/3/F _ _ _ _ _ _ _ _ _ _ _ _).

- : before-read/unique/3 (set/+ _ _) CM-CM CM2PM CML FML
    (S+F+X=>M2:set+nat2set _ F M2) M1^M2
    (M1+M2=M3:set`union M1 M2 M3) (M-M2=M4:set`split M M2 M4)
    (result2output/expr B=>Pj1
      (env2input/ U=>PiU M=>Pi)
      (reftype2perm/unique+fresh
        (ty2perm/ PML nn2perm/yes annot2perm/unique)
        S=>GF (M1=>Pi1:capset2perm _ _ _ M1 Pi1)))
    SOC _ (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1 _ U=>PiU
    Pi4 M4=>Pi4 Pi3 M3=>Pi3
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans3
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/identity)
                      (equiv/roll3)
                      (equiv/combine equiv/reflexive
                        (equiv/combine equiv/reflexive
                          (equiv/transitive
                            (equiv/symmetric equiv/associate)
                            (equiv/combine equiv/reflexive
                              (equiv/symmetric equiv/associate)))))))
                  (implies/combine (implies/reflexive)
                    (implies/trans4
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/combine
                            (implies/reflexive)
                            (implies/trans
                              (implies/combine
                                (implies/reflexive)
                                (implies/trans
                                  (implies/combine
                                    (implies/reflexive)
                                    (implies/equiv
                                      (Pi<=>Pi2+Pi4)))
                                  (implies/equiv equiv/associate)))
                              (implies/equiv equiv/associate)))
                          (implies/equiv equiv/associate)))
                      (implies/trans5
                        (implies/combine implies/reflexive
                          (implies/combine (implies/equiv equiv/reflexive) implies/reflexive))
                        (implies/equiv equiv/associate)
                        (implies/combine (IMP4 o r v) (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine (implies/reflexive)
                          (implies/combine
                            (implies/combine
                              (implies/combine
                                (implies/reflexive)
                                (implies/equiv-encumbered
                                  (equiv/reflexive)
                                  (equiv/combine
                                    (equiv/transitive equiv/commute (Pi1+Pi2<=>Pi3))
                                    (equiv/reflexive))))
                              (implies/reflexive))
                            (implies/reflexive))))
                      (implies/combine
                        (implies/reflexive)
                        (implies/equiv
                          (equiv/transitive3
                            (equiv/combine
                              (equiv/commute)
                              (equiv/reflexive))
                            (equiv/symmetric equiv/associate)
                            (equiv/combine
                              (equiv/reflexive)
                              (equiv/symmetric equiv/associate)))))
                      (implies/equiv equiv/roll2)))
                  (implies/equiv equiv/roll2)))
              (transform/drop))))
        (transform/rem-unused)))
    <- set`split-implies-permission-combine M-M2=M4 M=>Pi
      Pi2 Pi4 M2=>Pi2 M4=>Pi4 Pi<=>Pi2+Pi4
    <- capset`disjoint-join-implies-equiv-converse M1^M2 M1+M2=M3
      M1=>Pi1 M2=>Pi2 Pi3 M3=>Pi3 Pi1+Pi2<=>Pi3
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- set`size-total S-SZ
    <- combine-fldperm _ S-SZ SOC B=>Pj1 CM-CM CM2PM CML FML S+F+X=>M2
      S=>GF M2=>Pi2 (ty2perm/ PML2 NN2PF2 A2AF2) IMP3
    <- before-read/unique/L3 IMP3 IMP _ IMP4.

- : before-read/unique/3 set/0 CM-CM CM2PM CL FL
    (S=>G2:set+nat2set set/0 _ (set/+ _ _)) G1^G2 G1+G2=G M2<=M M=>O SOC
    TF T2PF _ B=>Pi4 _ U=>PiU _ M1P=>Pi1 _ M2P=>Pi2 TRANS
    <- set`size-total MZ
    <- set+nat2set-preserves-size-converse S=>G2 (set`size/+ MZ) SZ
    <- set`size-unique set`size/0 SZ set`eq/ E
    <- nat`eq-contradiction E V
    <- before-read/unique/3/F V TF T2PF _ B=>Pi4 _ U=>PiU _ M1P=>Pi1 _ M2P=>Pi2 TRANS.

- : before-read/unique/3 set/0
    CM-CM CM2PM CML FML _ _ (M1+0=M1P:set`union M1 set/0 M1P) M-M2=M4
    (result2output/expr B=>Pj1 (env2input/ U=>PiU (M=>Pi:capset2perm _ _ _ M Pi))
      (reftype2perm/unique+fresh
        (ty2perm/ PML nn2perm/yes annot2perm/unique) ([_] set2cond/0)
        (M1=>Pi1:capset2perm _ _ _ M1 Pi1)))
    _ _ (ty2perm/ PML2 NN2PF2 A2AF2) _ B=>Pj1 _ U=>PiU
    _ M4=>Pi Pi1 M1P=>Pi1
    (transform/inside [o]
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive3
                    (equiv/identity)
                    (equiv/roll3)
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/symmetric equiv/associate)
                          (equiv/combine equiv/reflexive
                            (equiv/symmetric equiv/associate)))))))
                (implies/combine
                  (implies/reflexive)
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/combine
                        (implies/trans6
                          (implies/cond-gen-inner)
                          (implies/cond-inner
                            (bimplies/reflexive)
                            (bimplies/reflexive)
                            (implies/reflexive)
                            (implies/trans
                              (implies/equiv equiv/commute)
                              (implies/combine
                                (implies/contradiction)
                                (implies/trans
                                  (implies/nonlinear bimplies/tt)
                                  (implies/true2empty)))))
                          (implies/cond-pull)
                          (implies/combine implies/reflexive implies/cond-equal)
                          (implies/equiv equiv/identity)
                          (implies/nonlinear bimplies/objequal-symmetric))
                        (implies/reflexive))
                      (implies/objequal
                        ([x] (combine (nonnull-unique-perm x CP)
                               (combine
                                 (unitperm
                                   (encumbered
                                     (nonnull-unique-perm x CP)
                                     (combine Pi1 v)))
                                 Pi))))
                      (IMP2 o r v))))))))
        (transform/rem-unused)))
    <- set`union-unique set`union/R M1+0=M1P set`eq/ set`eq/ (M1=M1P:set`eq M1 M1P)
    <- capset2perm-respects-eq M1=>Pi1 clsmap`eq/ predmap`eq/ cxt`eq/
      M1=M1P permission`eq/ M1P=>Pi1
    <- set`split-unique (set`split/ set`disjoint/L set`union/L)
      M-M2=M4 set`eq/ set`eq/ (M=M4:set`eq M M4)
    <- capset2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/ cxt`eq/
      M=M4 permission`eq/ M4=>Pi
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- pullout-fldperm-var2 IMP IMP2.

%worlds (gtermvar) (before-read/unique/3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%%% a format ready for reading a field

read-format : clsmap -> predmap -> cxt -> nat -> (object -> permission) ->
	 targets -> set -> (object -> permission -> permission) -> permission -> type.

read-format/unique :
    set`size M2 (s N) ->
    capset2perm CM PM B M1 Pi2 ->
    capset2perm CM PM B M2 Pi3 ->
  read-format CM PM B F TF (targets/unique set/0 M2 false) M1
    ([r][v] unitperm (encumbered (fperm r F TF) Pi3)) Pi2.

read-format/unique+fresh :
    capset2perm CM PM B M1 Pi2 ->
    capset2perm CM PM B M2 Pi3 ->
  read-format CM PM B F TF (targets/unique set/0 M2 true) M1
    ([r][v] unitperm (encumbered (fperm r F TF) (combine Pi3 v))) Pi2.


%theorem before-read/unique/L
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Rslt}
    {M0} {S2} {S1} {G} {M2} {U} {W}
    forall {N1} {SZ1: set`size S1 N1}
    {N2} {SZ1: set`size S2 N2}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: result2output CM PM B
      (result/expr (reftype/ nn/yes C (targets/unique S1 S2 W)) (env/ U M0)) Rslt}
    {MG: make-tgts-and-caps M0 (targets/unique S1 S2 W) F G M2}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ nn/yes C (targets/unique S1 S2 W))}
    {CM-B-XX: clsmap-cxt-capset CM B M0}
    exists {Pi1} {Pi2} {Pi3} {PiU} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm PM B Pi1}
    {U=>PiU: make-encumbered CM PM B U PiU}
    {REE: read-format CM PM B F TF G M2 Pi2 Pi3}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/exists [v]
                (output/expr r
                  (combine PiU
                    (combine Pi1
                      (combine (fperm r F TF)
                        (combine (Pi2 r v) Pi3)))))))}
    true.

- : before-read/unique/L (s N) SZ-S z _ CM-CM CM2PM CML FML XX=>Rslt
    (make-tgts-and-caps/unique S1+F+X=>M
      _ (M0-M=M2: set`split M0 M M2))
    (clsmap-cxt-reftype/unique _ CM-B-S CM-B-S2 (wf-unique-targets/borrow _ _))
    CM-B-M0 _ _ _ _ _ T2TF B=>Pi1 U=>PiU
    (read-format/unique SZ-M M2=>Pi2 M=>Pi) TRANS
    <- set+nat2set-preserves-size S1+F+X=>M SZ-S SZ-M
    <- before-read/borrow CM-B-M0 CM-CM CM2PM CML FML S1+F+X=>M M0-M=M2
      XX=>Rslt CM-B-S SZ-S _ T2TF _ B=>Pi1 _ U=>PiU _ M2=>Pi2 _ M=>Pi TRANS.

- : before-read/unique/L _ SZ-S1 (s N) SZ-S2 CM-CM CM2PM CML FML XX=>Rslt
    (make-tgts-and-caps/unique S1+F+X=>M (set`split/ S2^M S2+M=M3)
      (M0-M=M2: set`split M0 M M2))
    (clsmap-cxt-reftype/unique _ CM-B-S CM-B-S2 (wf-unique-targets/unique _))
    CM-B-M0 _ _ _ _ _ T2TF B=>Pi1 U=>PiU
    (read-format/unique (set`size/+ SZ-M3) M2=>Pi2 M3=>Pi3) TRANS
    <- set`size-total SZ-M3
    <- before-read/unique/2 _ SZ-S2 CM-CM CM2PM CML FML S1+F+X=>M S2^M S2+M=M3 M0-M=M2
      XX=>Rslt CM-B-S _ T2TF _ B=>Pi1 _ U=>PiU _ M2=>Pi2 _ M3=>Pi3 TRANS.

- : before-read/unique/L _ SZ-S1 _ SZ-S2 CM-CM CM2PM CML FML XX=>Rslt
    (make-tgts-and-caps/unique S1+F+X=>M (set`split/ S2^M S2+M=M3)
      (M0-M=M2: set`split M0 M M2))
    (clsmap-cxt-reftype/unique _ CM-B-S CM-B-S2
      (wf-unique-targets/unique+fresh) )
    CM-B-M0 _ _ _ _ _ T2TF B=>Pi1 U=>PiU
    (read-format/unique+fresh M2=>Pi2 M3=>Pi3) TRANS
    <- before-read/unique/3 _ CM-CM CM2PM CML FML S1+F+X=>M S2^M S2+M=M3 M0-M=M2
      XX=>Rslt CM-B-S _ T2TF _ B=>Pi1 _ U=>PiU _ M2=>Pi2 _ M3=>Pi3 TRANS.

%worlds (gtermvar) (before-read/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/unique
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Rslt}
    {S1} {S2} {G} {M0} {M2} {U} {W}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: result2output CM PM B
      (result/expr (reftype/ nn/yes C (targets/unique S1 S2 W)) (env/ U M0)) Rslt}
    {MG: make-tgts-and-caps M0 (targets/unique S1 S2 W) F G M2}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ nn/yes C (targets/unique S1 S2 W))}
    {CM-B-XX: clsmap-cxt-capset CM B M0}
    exists {Pi1} {Pi2} {Pi3} {PiU} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm PM B Pi1}
    {U=>PiU: make-encumbered CM PM B U PiU}
    {REE: read-format CM PM B F TF G M2 Pi2 Pi3}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/exists [v]
                (output/expr r
                  (combine PiU
                    (combine Pi1
                      (combine (fperm r F TF)
                        (combine (Pi2 r v) Pi3)))))))}
    true.

- : before-read/unique CM-CM CM2PM CML FML XX=>Rslt
    MG CM-B-G CM-B-XX _ _ _ _ _ T2TF B=>Pi1 U=>PiU BWF TRANS
    <- set`size-total Z1
    <- set`size-total Z2
    <- before-read/unique/L _ Z1 _ Z2
      CM-CM CM2PM CML FML XX=>Rslt MG CM-B-G CM-B-XX _ _ _ _ _ T2TF B=>Pi1 U=>PiU BWF TRANS.

%worlds (gtermvar)(before-read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%% Shared

%theorem before-read/shared/L2
  : forall* {CM} {PM} {B} {Pi}
    forall {XM=>Pi:capset2perm CM PM B (set/1 shared) Pi}
    exists {Pi2} {EQV: equiv Pi ((allperm null) , Pi2)}
    true.

%theorem before-read/shared/L2L1
  : forall* {MP}
    forall {NM: set`not-member MP shared} {UD: set`add MP shared (set/1 shared)}
    exists {E: set`eq MP set/0}
    true.

- : before-read/shared/L2L1 set`not-member/0 set`update/0 set`eq/.

- : before-read/shared/L2L1 FS (set`update/= nat`eq/) E
    <- set`not-member-contradiction FS F
    <- set`false-implies-eq F E.

- : before-read/shared/L2 M=>Pi _ (equiv/symmetric EQV1)
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) MP FS UD
    <- capset2perm/z-inversion M=>Pi FS UD _ MP=>PiP EQV1.

%worlds (gtermvar) (before-read/shared/L2L1 _ _ _).
%total {} (before-read/shared/L2L1 _ _ _).

%worlds (gtermvar) (before-read/shared/L2 _ _ _).
%total {} (before-read/shared/L2 _ _ _).


%theorem before-read/shared
  : forall* {CM} {PM} {FM} {C} {NN} {A} {FC} {B} {M} {Rslt} {F} {M2} {U}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {M-SM=M2: set`split M (set/1 shared) M2}
    {XX=>Rslt: result2output CM PM B
      (result/expr (reftype/ nn/yes C targets/shared) (env/ U M)) Rslt}
    exists {Pi1} {Pi2} {Pi3} {PiU} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi3: cxt2perm PM B Pi3}
    {U=>PiU: make-encumbered CM PM B U PiU}
    {M1=>Pi1: capset2perm CM PM B M2 Pi1}
    {M2=>Pi2: capset2perm CM PM B (set/1 shared) Pi2}
    {TRANS: transform Rslt
            (output/exists [r]
              (output/exists [v:permission]
                (output/expr r
                  (combine PiU
                    (combine Pi3
                      ((fperm r F TF) ,
                        (unitperm
                          (encumbered
                            (fperm r F TF) Pi2) , Pi1)))))))}
    true.

- : before-read/shared
    CM-CM CM2PM CM-L FM-L M-SM=M2
    (result2output/expr B=>Pi3 (env2input/ U=>PiU M=>Pi)
      (reftype2perm/shared
        (ty2perm/ PM-L nn2perm/yes annot2perm/shared)))
    _ _ _ _ _ (ty2perm/ PM-LF NN2PF A2AF)
    B=>Pi3 U=>PiU M2=>Pi2 SM=>Pi1
    (transform/inside [r]
      (transform/trans3
        (transform/rem-unused)
        (transform/inside [v]
          (transform/implies
            (implies/trans4
              (implies/combine
                (implies/combine implies/reflexive
                  (implies/combine
                    (implies/trans3
                      (implies/combine implies/duplicate implies/cond-neg)
                      (implies/symmetric-associate)
                      (implies/combine implies/reflexive implies/cond-elim))
                    (implies/reflexive)))
                (implies/reflexive))
              (implies/equiv
                (equiv/transitive
                  (equiv/identity)
                  (equiv/roll3)))
              (implies/combine
                (implies/reflexive)
                (implies/trans3
                  (implies/combine
                    (implies/reflexive)
                    (implies/combine
                      (implies/reflexive)
                      (implies/equiv
                        (equiv/transitive
                          (EQV1)
                          (equiv/commute)))))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/equiv
                        (equiv/transitive
                          (equiv/symmetric equiv/associate)
                          (equiv/combine
                            (equiv/reflexive)
                            (equiv/transitive3
                              (equiv/symmetric equiv/associate)
                              (equiv/combine equiv/reflexive equiv/commute)
                              (equiv/associate)))))
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans6
                          (implies/combine
                            (IMP1 r) (IMP2 r))
                          (implies/equiv
                            (equiv/transitive3
                              (equiv/symmetric equiv/associate)
                              (equiv/combine equiv/reflexive equiv/commute)
                              (equiv/associate)))
                          (implies/combine
                            (implies/trans
                              (implies/equiv equiv/commute)
                              (implies/carve))
                            (implies/reflexive))
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/trans
                              (implies/equiv (equiv/symmetric equiv/associate))
                              (implies/combine implies/reflexive implies/chain-implication))
                            (implies/reflexive))
                          (implies/equiv (equiv/symmetric equiv/associate))))))
                  (implies/equiv equiv/reorder)))
              (implies/equiv equiv/roll2))))
        (transform/inside [v] transform/drop)))
    <- set`split-implies-permission-combine M-SM=M2 M=>Pi _ _ SM=>Pi1 M2=>Pi2 EQV1
    <- before-read/shared/L2 SM=>Pi1 _ EQV2
    <- can-carve-out-of-shared EQV2 IMP1
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L _ _ _ A2AF NN2PF PM-LF ([r] IMP2 r).

%worlds (gtermvar) (before-read/shared _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/shared _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read/fresh
  : forall* {B} {CM} {PM} {FM} {C} {M} {NN} {A} {F} {FC} {Out} {U}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {M=>Out: result2output CM PM B
      (result/expr (reftype/ nn/yes C targets/fresh) (env/ U M)) Out}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi4} {B=>Pi4: cxt2perm PM B Pi4}
    {PiU} {U=>PiU: make-encumbered CM PM B U PiU}
    {Pi1} {M=>Pi1: capset2perm CM PM B M Pi1}
    {TRANS: transform Out
            (output/exists [r]
              (output/exists [v:permission]
                (output/expr r
                  (combine PiU
                    (combine Pi4
                      (combine (fperm r F TF)
                        (combine
                          (unitperm (encumbered (fperm r F TF) (combine empty v)))
                          Pi1)))))))}
    true.

- : before-read/fresh CM-CM CM2PM CM-L FM-L
    (result2output/expr B=>Pi4 (env2input/ U=>PiU M=>Pi)
      (reftype2perm/fresh (ty2perm/ PM-L nn2perm/yes annot2perm/unique)))
    _ (ty2perm/ F-PM-L F-NN2P F-A2AF) _ B=>Pi4 _ U=>PiU _ M=>Pi
    (transform/trans
      (transform/inside [o]
        (transform/trans
          (transform/inside [r]
            (transform/inside [v]
              (transform/trans
                (transform/implies
                  (implies/trans5
                    (implies/combine
                      (implies/combine implies/reflexive
                        (implies/combine
                          (implies/trans3
                            (implies/combine implies/duplicate implies/cond-neg)
                            (implies/symmetric-associate)
                            (implies/combine implies/reflexive implies/cond-elim))
                          (implies/reflexive)))
                      (implies/reflexive))
                    (implies/identity)
                    (implies/combine implies/reflexive
                      (implies/trans
                        (implies/combine
                          (implies/trans
                            (implies/combine implies/nonlinear2empty
                              (implies/trans3
                                (implies/combine implies/reflexive (IMP o))
                                (implies/commute)
                                (implies/carve)))
                            (implies/commute-identity))
                          (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))))
                    (implies/equiv equiv/roll3)
                    (implies/combine implies/reflexive
                      (implies/trans
                        (implies/equiv equiv/roll3)
                        (implies/combine implies/reflexive
                          (implies/combine implies/reflexive
                            (implies/combine implies/reflexive
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/symmetric equiv/identity)
                                  (equiv/commute))))))))))
                (transform/drop))))
          (transform/rem-unused)))
      (transform/trans
        (transform/inside [o]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/combine implies/reflexive
                  (implies/combine implies/reflexive
                    (implies/combine implies/reflexive
                      (implies/combine
                        (implies/self-implication)
                        (implies/reflexive))))))
              (transform/gen-exists* (termk permissionk) exprk
                ([p] output/expr o
                  (combine X11
                    (combine X10
                      (combine
                        (unitperm (precise-exists o N ([x] PF FCP x)))
                        (combine
                          (unitperm
                            (encumbered
                              (unitperm (precise-exists o N ([x] PF FCP x)))
                              p))
                          X12)))))
                (unitperm (precise-exists o N ([x] PF FCP x)))))))
        (transform/inside [o]
          (transform/trans
            (transform/inside [v]
              (transform/inside [p]
                (transform/implies
                  (implies/combine implies/reflexive
                    (implies/combine implies/reflexive
                      (implies/combine implies/reflexive
                        (implies/combine
                          (implies/equiv-encumbered
                            (equiv/reflexive)
                            (equiv/transitive
                              (equiv/symmetric equiv/identity)
                              (equiv/commute)))
                          (implies/reflexive))))))))
            (transform/rem-unused)))))
    <- lookup-implies-clsmap-fldmap CM-CM CM-L CM-FM
    <- lookup-implies-clsmap-ty CM-FM FM-L CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L AF PF FCP F-A2AF F-NN2P F-PM-L IMP.

%worlds (gtermvar) (before-read/fresh _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read/fresh _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem before-read
  : forall* {CM} {PM} {B} {FM} {C} {NN} {A} {FC} {F} {Out}
    {M0} {M2} {G} {G1} {U}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XX=>Rslt: result2output CM PM B (result/expr (reftype/ nn/yes C G) (env/ U M0)) Out}
    {MG: make-tgts-and-caps M0 G F G1 M2}
    {CM-RSLT: clsmap-result CM B (result/expr (reftype/ nn/yes C G) (env/ U M0))}
    exists {Pi1} {Pi2} {Pi3} {PiU} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {B=>Pi1: cxt2perm PM B Pi1}
    {U=>PiU: make-encumbered CM PM B U PiU}
    {REE: read-format CM PM B F TF G1 M2 Pi2 Pi3}
    {TRANS: transform Out
            (output/exists [r]
              (output/exists [v]
                (output/expr r
                  (combine PiU
                    (combine Pi1
                      (combine (fperm r F TF)
                        (combine (Pi2 r v) Pi3)))))))}
    true.

- : before-read CM-CM CM2PM CML FML XX=>Rslt
    MG (clsmap-result/expr CM-B-RT (clsmap-cxt-env/ _ CM-B-XX))
    _ _ _ _ _ T2TF B=>Pi1 U=>PiU BWE TRANS
    <- before-read/unique CM-CM CM2PM CML FML XX=>Rslt
      MG CM-B-RT CM-B-XX _ _ _ _ _ T2TF B=>Pi1 U=>PiU BWE TRANS.

- : before-read CM-CM CM2PM CML FML XX=>Rslt (make-tgts-and-caps/shared SP)
    (clsmap-result/expr CM-B-G (clsmap-cxt-env/ _ CM-B-XX))
    _ _ _ _ _ T2TF B=>Pi3 U=>PiU
    (read-format/unique (set`size/+ set`size/0) M1=>Pi1 M0=>Pi0) TRANS
    <- before-read/shared CM-CM CM2PM CML FML SP XX=>Rslt
      _ _ _ _ _ T2TF B=>Pi3 U=>PiU M1=>Pi1 M0=>Pi0 TRANS.

- : before-read CM-CM CM2PM CML FML XX=>Rslt (make-tgts-and-caps/fresh)
    (clsmap-result/expr CM-B-G (clsmap-cxt-env/ _ CM-B-XX))
    _ _ _ _ _ T2TF B=>Pi3 U=>PiU
    (read-format/unique+fresh M1=>Pi1 capset2perm/0) TRANS
    <- before-read/fresh CM-CM CM2PM CML FML XX=>Rslt
      _ T2TF _ B=>Pi3 _ U=>PiU _ M1=>Pi1 TRANS.

%worlds (gtermvar) (before-read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (before-read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).