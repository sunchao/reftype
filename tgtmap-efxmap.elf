%%% Interactions between tgtmap and efxmap
%%% $Id: tgtmap-efxmap.elf,v 1.3 2013/03/05 18:49:09 csun Exp csun $


%%% convert a set of fields and a particular effect on those
%%% fields to a inner-efxmap.

set2inner-efxmap : set -> efx -> inner-efxmap -> type.

set2inner-efxmap/0 : set2inner-efxmap set/0 _ inner-efxmap/0.

set2inner-efxmap/+
  : set2inner-efxmap (set/+ F S) X (inner-efxmap/+ F X FM)
    <- set2inner-efxmap S X FM.


tgtmap2efxmap : tgtmap -> efx -> efxmap -> type.

tgtmap2efxmap/0 : tgtmap2efxmap tgtmap/0 _ efxmap/0.

tgtmap2efxmap/+
  : tgtmap2efxmap (tgtmap/+ L S GM) X (efxmap/+ L M XM)
     <- set2inner-efxmap S X M
     <- tgtmap2efxmap GM X XM.


efxmap2tgtmap : efxmap -> tgtmap -> type.

efxmap2tgtmap/0 : efxmap2tgtmap efxmap/0 tgtmap/0.

efxmap2tgtmap/+
  : efxmap2tgtmap (efxmap/+ L M XM) (tgtmap/+ L S GM)
    <- inner-efxmap`domain M S
    <- efxmap2tgtmap XM GM.


%{% We need to prove that for any tgtmap and efxmap
  in type checking output, the tgtmap should <= the efxmap. %}%

tgtmap-leq-efxmap : tgtmap -> efxmap -> type.

tgtmap-leq-efxmap/
  : tgtmap-leq-efxmap GM XM
    <- efxmap2tgtmap XM GMP
    <- tgtmap`leq GM GMP.


% "extend" this object target set with input field and
% get a field target map.

set+nat2tgtmap : set -> nat -> tgtmap -> type.

set+nat2tgtmap/0 : set+nat2tgtmap set/0 _ tgtmap/0.

set+nat2tgtmap/+
  : set+nat2tgtmap (set/+ L S) F (tgtmap/+ L (set/1 F) GM)
     <- set+nat2tgtmap S F GM.

  
% extend the object target set with a field set and generate a field target map.

set+set2tgtmap : set -> set -> tgtmap -> type.

set+set2tgtmap/0 : set+set2tgtmap set/0 _ tgtmap/0.

set+set2tgtmap/+
  : set+set2tgtmap GS S GM
    <- set`add SP F S
    <- set+nat2tgtmap GS F M
    <- set+set2tgtmap GS SP GMP
    <- tgtmap`join GMP M GM.
 

% remove a tgtmap from a efxmap
% first efxmap is the ones that are left, the second is all that removed.

efxmap`remove-tgtmap : efxmap -> tgtmap -> efxmap -> efxmap -> type.

efxmap`remove-tgtmap/0 : efxmap`remove-tgtmap efxmap/0 _ efxmap/0 efxmap/0.

efxmap`remove-tgtmap/+/in
  : efxmap`remove-tgtmap (efxmap`map/+ F M XM) GM XM1 XM2
    <- tgtmap`lookup GM F S2
    <- inner-efxmap`domain M MS
    <- set`remove MS S2 S1
    <- inner-efxmap`restrict M S1 M1
    <- inner-efxmap`restrict M S2 M2
    <- efxmap`shift F XM XMP
    <- efxmap`remove-tgtmap XMP GM XM1P XM2P
    <- efxmap`update XM1P F M1 XM1
    <- efxmap`update XM2P F M2 XM2.

efxmap`remove-tgtmap/+/out
  : efxmap`remove-tgtmap (efxmap`map/+ F M XM) GM XM1 XM2
    <- tgtmap`fresh GM F
    <- efxmap`shift F XM XMP
    <- efxmap`remove-tgtmap XMP GM XM1P XM2
    <- efxmap`update XM1P F M XM1.


%%% Theorems 


%%% theorems about set2inner-efxmap

%theorem set2inner-efxmap-total* :
    forall {X} {S} 
    exists {M} {S+X=>M: set2inner-efxmap S X M}
    true.

- : set2inner-efxmap-total* _ set/0 inner-efxmap/0 set2inner-efxmap/0.

- : set2inner-efxmap-total* X (set/+ F S) (inner-efxmap/+ F X M)
    (set2inner-efxmap/+ S+X=>M)
    <- set2inner-efxmap-total* X S M S+X=>M.

%worlds () (set2inner-efxmap-total* _ _ _ _).
%total (S) (set2inner-efxmap-total* _ S _ _).

%abbrev set2inner-efxmap-total = set2inner-efxmap-total* _ _ _.


%theorem shift-preserves-set2inner-efxmap : 
    forall* {S} {M} {SS} {MS} {N} {X}
    forall  {S=>M: set2inner-efxmap S X M}
            {SH-S: set`shift N S SS}
            {SH-M: inner-efxmap`shift N M MS}
    exists  {SS=>MS: set2inner-efxmap SS X MS}
    true.

- : shift-preserves-set2inner-efxmap 
    set2inner-efxmap/0 set`shift/0 inner-efxmap`shift/0 set2inner-efxmap/0.

- : shift-preserves-set2inner-efxmap
    (set2inner-efxmap/+ S=>M) _ _ (set2inner-efxmap/+ S=>M).

%worlds () (shift-preserves-set2inner-efxmap _ _ _ _).
%total  {} (shift-preserves-set2inner-efxmap _ _ _ _).


%theorem set2inner-efxmap-implies-domain :
    forall* {X} {S} {M}
    forall  {S=>M: set2inner-efxmap S X M}
    exists  {DM-M=S: inner-efxmap`domain M S}
    true.

- : set2inner-efxmap-implies-domain set2inner-efxmap/0 inner-efxmap`domain/0.

- : set2inner-efxmap-implies-domain 
    (set2inner-efxmap/+ S+X=>M) (inner-efxmap`domain/+ DM-M=S)
    <- set2inner-efxmap-implies-domain S+X=>M DM-M=S.

%worlds () (set2inner-efxmap-implies-domain _ _).
%total (A) (set2inner-efxmap-implies-domain A _).



%%% theorems about tgtmap2efxmap

%theorem false-implies-tgtmap2efxmap :
    forall* {GM} {X}
    forall  {F:void}
    exists  {XM} {GM=>XM: tgtmap2efxmap GM X XM}
    true.

%worlds () (false-implies-tgtmap2efxmap _ _ _).
%total  {} (false-implies-tgtmap2efxmap _ _ _).


%theorem shift-preserves-tgtmap2efxmap :
	forall* {GM} {XM} {X} {L} {GM'} {XM'}
	forall  {GM=>XM: tgtmap2efxmap GM X XM}
    		{L<=GM=GM': tgtmap`shift L GM GM'}
	        {L<=XM=XM': efxmap`shift L XM XM'}
	exists  {GM'=>XM': tgtmap2efxmap GM' X XM'}
	true.

- : shift-preserves-tgtmap2efxmap tgtmap2efxmap/0 _ _ tgtmap2efxmap/0.

- : shift-preserves-tgtmap2efxmap
     (tgtmap2efxmap/+ GM=>XM S=>M) _ _ (tgtmap2efxmap/+ GM=>XM S=>M).

%worlds () (shift-preserves-tgtmap2efxmap _ _ _ _).
%total  {} (shift-preserves-tgtmap2efxmap _ _ _ _).


%theorem shift-preserves-tgtmap2efxmap-converse :
    forall* {GM} {XM} {X} {L} {GMP} {XMP}
    forall  {GM=>XM: tgtmap2efxmap GMP X XMP}
            {L<=GM=GMP: tgtmap`shift L GM GMP}
	    {L<=XM=XMP: efxmap`shift L XM XMP}
    exists  {GMP=>XMP: tgtmap2efxmap GM X XM}
    true.

- : shift-preserves-tgtmap2efxmap-converse 
     tgtmap2efxmap/0 _ _ tgtmap2efxmap/0.

- : shift-preserves-tgtmap2efxmap-converse
     (tgtmap2efxmap/+ GM=>XM S=>M) _ _ (tgtmap2efxmap/+ GM=>XM S=>M).

%worlds () (shift-preserves-tgtmap2efxmap-converse _ _ _ _).
%trustme %total  {} (shift-preserves-tgtmap2efxmap-converse _ _ _ _).


%theorem tgtmap2efxmap-preserves-domain :
    forall* {S} {X} {GM} {XM}
    forall  {GM=>XM: tgtmap2efxmap GM X XM}
            {DM-GM: tgtmap`domain GM S}
    exists  {DM-XM: efxmap`domain XM S}
    true.

- : tgtmap2efxmap-preserves-domain 
    tgtmap2efxmap/0 tgtmap`domain/0 efxmap`domain/0.

- : tgtmap2efxmap-preserves-domain 
    (tgtmap2efxmap/+ GM=>XM S=>M) (tgtmap`domain/+ DM-GM)
    (efxmap`domain/+ DM-XM)
    <- tgtmap2efxmap-preserves-domain GM=>XM DM-GM DM-XM.

%worlds () (tgtmap2efxmap-preserves-domain _ _ _).
%total (A) (tgtmap2efxmap-preserves-domain A _ _).


%theorem tgtmap2efxmap-implies-efxmap2tgtmap :
    forall* {X} {GM} {XM}
    forall  {GM=>XM: tgtmap2efxmap GM X XM}
    exists  {XM=>GM: efxmap2tgtmap XM GM}
    true.

- : tgtmap2efxmap-implies-efxmap2tgtmap 
    tgtmap2efxmap/0 efxmap2tgtmap/0.

- : tgtmap2efxmap-implies-efxmap2tgtmap 
    (tgtmap2efxmap/+ GM=>XM S=>M) (efxmap2tgtmap/+ XM=>GM DM-M=S)
    <- tgtmap2efxmap-implies-efxmap2tgtmap GM=>XM XM=>GM
    <- set2inner-efxmap-implies-domain S=>M DM-M=S.

%worlds () (tgtmap2efxmap-implies-efxmap2tgtmap _ _).
%total (A) (tgtmap2efxmap-implies-efxmap2tgtmap A _).


%%% theorems about efxmap2tgtmap

%theorem false-implies-efxmap2tgtmap :
    forall* {XM} {GM}
    forall  {F:void}
    exists  {V: efxmap2tgtmap XM GM}
    true.

%worlds () (false-implies-efxmap2tgtmap _ _).
%total {} (false-implies-efxmap2tgtmap _ _).


%theorem efxmap2tgtmap-total* :
    forall {XM}
    exists {GM} {XM=>GM: efxmap2tgtmap XM GM}
    true.

- : efxmap2tgtmap-total* efxmap/0 tgtmap/0 efxmap2tgtmap/0. 

- : efxmap2tgtmap-total* (efxmap/+ L M XM) (tgtmap/+ L S GM)
    (efxmap2tgtmap/+ XM=>GM DM-M=S)
    <- inner-efxmap`domain-total* M S DM-M=S
    <- efxmap2tgtmap-total* XM GM XM=>GM.

%worlds () (efxmap2tgtmap-total* _ _ _).
%total (XM) (efxmap2tgtmap-total* XM _ _).

%abbrev efxmap2tgtmap-total = efxmap2tgtmap-total* _ _.


%theorem efxmap2tgtmap-respects-eq :
    forall* {XM} {GM} {XMP} {GMP}
    forall  {XM=>GM: efxmap2tgtmap XM GM}
            {EQ: efxmap`eq XM XMP} {EQ: tgtmap`eq GM GMP}
    exists  {XMP=>GMP: efxmap2tgtmap XMP GMP}
    true.

- : efxmap2tgtmap-respects-eq efxmap2tgtmap/0 _ _ efxmap2tgtmap/0.

- : efxmap2tgtmap-respects-eq (efxmap2tgtmap/+ DM XM=>GM) 
    efxmap`eq/ tgtmap`eq/ (efxmap2tgtmap/+ DM XM=>GM) .

%worlds () (efxmap2tgtmap-respects-eq _ _ _ _).
%total {} (efxmap2tgtmap-respects-eq _ _ _ _).

      
%theorem shift-preserves-efxmap2tgtmap :
    forall* {N} {XM} {GM} {XMP} {GMP}
    forall  {XM=>GM: efxmap2tgtmap XM GM}
            {SH: efxmap`shift N XM XMP}
            {SH: tgtmap`shift N GM GMP}
    exists  {XMP=>GMP: efxmap2tgtmap XMP GMP}
    true.

- : shift-preserves-efxmap2tgtmap efxmap2tgtmap/0 _ _ efxmap2tgtmap/0.

- : shift-preserves-efxmap2tgtmap 
    (efxmap2tgtmap/+ XM=>GM DM-M=S) _ _ (efxmap2tgtmap/+ XM=>GM DM-M=S).
    
%worlds () (shift-preserves-efxmap2tgtmap _ _ _ _).
%total  {} (shift-preserves-efxmap2tgtmap _ _ _ _).


%theorem efxmap2tgtmap-preserves-efxmap-leq/L :
    forall* {XM1} {XM2} {GM1} {GM2}
    forall  {N} {SZ: efxmap`size XM2 N}
            {XM1<=XM2: efxmap`leq XM1 XM2}
            {XM1=>GM1: efxmap2tgtmap XM1 GM1}
            {XM2=>GM2: efxmap2tgtmap XM2 GM2}
    exists  {GM1<=GM2: tgtmap`leq GM1 GM2}
    true.

- : efxmap2tgtmap-preserves-efxmap-leq/L _ _ efxmap`leq/0 _ _ tgtmap`leq/0.

- : efxmap2tgtmap-preserves-efxmap-leq/L _ (efxmap`size/+ SZ2)
    (efxmap`leq/= XM1<=XM2 M1<=M2 EQ) 
    (efxmap2tgtmap/+ XM1=>GM1 DM-M1=S1) 
    (efxmap2tgtmap/+ XM2=>GM2 DM-M2=S2) 
    (tgtmap`leq/= GM1<=GM2 S1<=S2 EQ)
    <- inner-efxmap`domain-preserves-leq* M1<=M2 DM-M1=S1 DM-M2=S2 S1<=S2
    <- efxmap2tgtmap-preserves-efxmap-leq/L 
      _ SZ2 XM1<=XM2 XM1=>GM1 XM2=>GM2 GM1<=GM2.

- : efxmap2tgtmap-preserves-efxmap-leq/L _ (efxmap`size/+ SZ2)
    (efxmap`leq/> N3D1XM1<=XM2 P) N1D1XM1=>GM1 
    (efxmap2tgtmap/+ XM2=>GM2 _) GM1<=GM2
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- efxmap`shift-total SH-XM2=XM2P
    <- efxmap`shift-preserves-leq*
      N3D1XM1<=XM2 (efxmap`shift/+ P2) SH-XM2=XM2P N1D1XM1<=XM2P
    <- tgtmap`shift-total SH-GM2=GM2P
    <- shift-preserves-efxmap2tgtmap 
      XM2=>GM2 SH-XM2=XM2P SH-GM2=GM2P XM2P=>GM2P
    <- efxmap`shift-preserves-size SZ2 SH-XM2=XM2P SZ2P
    <- efxmap2tgtmap-preserves-efxmap-leq/L _ SZ2P
      N1D1XM1<=XM2P N1D1XM1=>GM1 XM2P=>GM2P GM1<=GM2P
    <- tgtmap`shift-implies-update SH-GM2=GM2P UD
    <- tgtmap`shift-implies-fresh SH-GM2=GM2P FS
    <- tgtmap`fresh-update-implies-leq FS UD GM2P<=GM2
    <- tgtmap`leq-transitive GM1<=GM2P GM2P<=GM2 GM1<=GM2.

%worlds () (efxmap2tgtmap-preserves-efxmap-leq/L _ _ _ _ _ _).
%total {N} (efxmap2tgtmap-preserves-efxmap-leq/L N _ _ _ _ _).


%theorem efxmap2tgtmap-preserves-efxmap-leq :
    forall* {XM1} {XM2} {GM1} {GM2}
    forall  {XM1<=XM2: efxmap`leq XM1 XM2}
            {XM1=>GM1: efxmap2tgtmap XM1 GM1}
            {XM2=>GM2: efxmap2tgtmap XM2 GM2}
    exists  {GM1<=GM2: tgtmap`leq GM1 GM2}
    true.

- : efxmap2tgtmap-preserves-efxmap-leq 
    XM1<=XM2 XM1=>GM1 XM2=>GM2 GM1<=GM2
    <- efxmap`size-total SZ
    <- efxmap2tgtmap-preserves-efxmap-leq/L 
      _ SZ XM1<=XM2 XM1=>GM1 XM2=>GM2 GM1<=GM2.

%worlds () (efxmap2tgtmap-preserves-efxmap-leq _ _ _ _).
%total  {} (efxmap2tgtmap-preserves-efxmap-leq _ _ _ _).



%theorem fresh-update-preserves-efxmap2tgtmap :
    forall* {XM} {GM} {XMP} {GMP} {N} {M} {S}
    forall  {XMP2GMP: efxmap2tgtmap XMP GMP}
            {FS: efxmap`fresh XMP N} {UD: efxmap`update XMP N M XM}
            {FS: tgtmap`fresh GMP N} {UD: tgtmap`update GMP N S GM}
            {DM: inner-efxmap`domain M S}
    exists  {XM2GM: efxmap2tgtmap XM GM}
    true.

- : fresh-update-preserves-efxmap2tgtmap 
    efxmap2tgtmap/0 _ _ _ _ DM (efxmap2tgtmap/+ efxmap2tgtmap/0 DM).

- : fresh-update-preserves-efxmap2tgtmap
    _ (efxmap`fresh/< GT) (efxmap`update/= nat`eq/) _ _ _ D
    <- nat`gt-anti-reflexive GT V
    <- false-implies-efxmap2tgtmap V D.

- : fresh-update-preserves-efxmap2tgtmap
    _ (efxmap`fresh/> _ P1) (efxmap`update/= nat`eq/) _ _ _ D
    <- nat`plus-implies-gt P1 nat`eq/ GT
    <- nat`gt-anti-reflexive GT V
    <- false-implies-efxmap2tgtmap V D.

- : fresh-update-preserves-efxmap2tgtmap
    _ _ _ (tgtmap`fresh/< GT) (tgtmap`update/= nat`eq/) _ D
    <- nat`gt-anti-reflexive GT V
    <- false-implies-efxmap2tgtmap V D.

- : fresh-update-preserves-efxmap2tgtmap
    _ _ _ (tgtmap`fresh/> _ P1) (tgtmap`update/= nat`eq/) _ D
    <- nat`plus-implies-gt P1 nat`eq/ GT
    <- nat`gt-anti-reflexive GT V
    <- false-implies-efxmap2tgtmap V D.

- : fresh-update-preserves-efxmap2tgtmap
    _ (efxmap`fresh/< GT) (efxmap`update/> _ P) _ _ _ D
    <- nat`plus-implies-gt P nat`eq/ GTP
    <- nat`gt-anti-symmetric GT GTP V
    <- false-implies-efxmap2tgtmap V D.

- : fresh-update-preserves-efxmap2tgtmap
    _ _ _ (tgtmap`fresh/< GT) (tgtmap`update/> _ P) _ D
    <- nat`plus-implies-gt P nat`eq/ GTP
    <- nat`gt-anti-symmetric GT GTP V
    <- false-implies-efxmap2tgtmap V D.

- : fresh-update-preserves-efxmap2tgtmap
    _ (efxmap`fresh/> _ P1) (efxmap`update/< P2) _ _ _ D
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 V
    <- false-implies-efxmap2tgtmap V D.

- : fresh-update-preserves-efxmap2tgtmap
    _ _ _ (tgtmap`fresh/> _ P1) (tgtmap`update/< P2) _ D
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 V
    <- false-implies-efxmap2tgtmap V D.

- : fresh-update-preserves-efxmap2tgtmap 
    (efxmap2tgtmap/+ XMP2GMP DM-M=S) 
    _ (efxmap`update/< XMP)
    _ (tgtmap`update/< GMP) DM 
    (efxmap2tgtmap/+ XM2GM DM)
    <- nat`plus-right-cancels XMP GMP nat`eq/ nat`eq/ EQ
    <- nat`succ-cancels EQ EQP
    <- tgtmap`map/+-preserves-eq EQP set`eq/ tgtmap`eq/ GMEQ
    <- efxmap2tgtmap-respects-eq
      (efxmap2tgtmap/+ XMP2GMP DM-M=S) efxmap`eq/ GMEQ XM2GM.

- : fresh-update-preserves-efxmap2tgtmap
    (efxmap2tgtmap/+ XMP2GMP DM-M=S)
    (efxmap`fresh/> F1 P11) (efxmap`update/> U1 P12)
    (tgtmap`fresh/> F2 P21) (tgtmap`update/> U2 P22)
    DM (efxmap2tgtmap/+ DD DM-M=S)
    <- nat`plus-right-cancels P11 P12 nat`eq/ nat`eq/ SN1=SN2
    <- nat`succ-cancels SN1=SN2 N1=N2
    <- nat`plus-right-cancels P11 P21 nat`eq/ nat`eq/ SN1=SN3
    <- nat`succ-cancels SN1=SN3 N1=N3
    <- nat`plus-right-cancels P11 P22 nat`eq/ nat`eq/ SN1=SN4
    <- nat`succ-cancels SN1=SN4 N1=N4
    <- nat`eq-symmetric N1=N2 N2=N1
    <- nat`eq-symmetric N1=N3 N3=N1
    <- nat`eq-symmetric N1=N4 N4=N1
    <- efxmap`update-respects-eq 
      U1 efxmap`eq/ N2=N1 inner-efxmap`eq/ efxmap`eq/ U1'
    <- tgtmap`fresh-respects-eq F2 tgtmap`eq/ N3=N1 F2'
    <- tgtmap`update-respects-eq U2 tgtmap`eq/ N4=N1 set`eq/ tgtmap`eq/ U2'
    <- fresh-update-preserves-efxmap2tgtmap XMP2GMP F1 U1' F2' U2' DM DD. 

- : fresh-update-preserves-efxmap2tgtmap 
    (efxmap2tgtmap/+ XMP2GMP DM-M=S)
    (efxmap`fresh/> F1 P1) (efxmap`update/> U1 P2)
    (tgtmap`fresh/< GT) (tgtmap`update/< P3) _ D
    <- nat`plus-implies-gt P2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N2>N1 GT V
    <- false-implies-efxmap2tgtmap V D.

- : fresh-update-preserves-efxmap2tgtmap 
    (efxmap2tgtmap/+ XMP2GMP DM-M=S)
    (efxmap`fresh/< GT) (efxmap`update/< P3) 
    (tgtmap`fresh/> F1 P1) (tgtmap`update/> U1 P2) _ D
    <- nat`plus-implies-gt P2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N2>N1 GT V
    <- false-implies-efxmap2tgtmap V D.

- : fresh-update-preserves-efxmap2tgtmap
    (efxmap2tgtmap/+ XMP2GMP DM-M=S)
    (efxmap`fresh/> F1 P1) (efxmap`update/< XMP)
    (tgtmap`fresh/> F2 P2) (tgtmap`update/< GMP) DM 
    (efxmap2tgtmap/+ XM2GM DM)
    <- nat`plus-right-cancels XMP GMP nat`eq/ nat`eq/ EQ
    <- nat`succ-cancels EQ EQP
    <- tgtmap`map/+-preserves-eq EQP set`eq/ tgtmap`eq/ GMEQ
    <- efxmap2tgtmap-respects-eq
      (efxmap2tgtmap/+ XMP2GMP DM-M=S) efxmap`eq/ GMEQ XM2GM.

%worlds () (fresh-update-preserves-efxmap2tgtmap _ _ _ _ _ _ _).
%total (U) (fresh-update-preserves-efxmap2tgtmap U _ _ _ _ _ _).


%theorem fresh-update-preserves-efxmap2tgtmap-converse/L :
    forall* {M} {GM} {N} {XMP}
    forall  {F:void}
    exists  {S} {GMP} {DM-M=S: inner-efxmap`domain M S}
            {N!<GMP: tgtmap`fresh GMP N}
            {GMP+N=GM: tgtmap`update GMP N S GM}
            {XMP2GMP: efxmap2tgtmap XMP GMP}
    true.

%worlds () (fresh-update-preserves-efxmap2tgtmap-converse/L _ _ _ _ _ _ _).
%total  {} (fresh-update-preserves-efxmap2tgtmap-converse/L _ _ _ _ _ _ _).


%theorem fresh-update-preserves-efxmap2tgtmap-converse :
    forall* {XM} {XMP} {GM} {N} {M}
    forall  {XM2GM: efxmap2tgtmap XM GM}
            {N!<XMP: efxmap`fresh XMP N}
            {XMP+N=XM: efxmap`update XMP N M XM}
    exists  {S} {GMP} {DM-M=S: inner-efxmap`domain M S}
            {N!<GMP: tgtmap`fresh GMP N}
            {GMP+N=GM: tgtmap`update GMP N S GM}
            {XMP2GMP: efxmap2tgtmap XMP GMP}
    true.

- : fresh-update-preserves-efxmap2tgtmap-converse
     (efxmap2tgtmap/+ XM2GM DM-M=S) _ efxmap`update/0 %{=>}%
    _ _ DM-M=S tgtmap`fresh/0 tgtmap`update/0 efxmap2tgtmap/0.

- : fresh-update-preserves-efxmap2tgtmap-converse
    (efxmap2tgtmap/+ XM2GM DM-M=S) (efxmap`fresh/< GT) (efxmap`update/< P)
    _ _ DM-M=S FS1 UD1 XM2GMP
    <- tgtmap`shift-total SH
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- shift-preserves-efxmap2tgtmap 
      XM2GM (efxmap`shift/+ P2) SH XM2GMP
    <- tgtmap`shift-implies-fresh SH FS1
    <- tgtmap`shift-implies-update SH UD1.

- : fresh-update-preserves-efxmap2tgtmap-converse
    (efxmap2tgtmap/+ XM2GM DM-M=S) (efxmap`fresh/> F P1) (efxmap`update/> U P2)
    _ _ DM (tgtmap`fresh/> FS P2) (tgtmap`update/> UD P2)
    (efxmap2tgtmap/+ XMP2GMP DM-M=S)
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ
    <- nat`succ-cancels EQ EQ'
    <- efxmap`fresh-respects-eq F efxmap`eq/ EQ' F'
    <- fresh-update-preserves-efxmap2tgtmap-converse
      XM2GM F' U _ _ DM FS UD XMP2GMP.

%% impossible cases

- : fresh-update-preserves-efxmap2tgtmap-converse
    _ (efxmap`fresh/> _ P1) (efxmap`update/< P2)
    _ _ DM-M=S FS UD XMP2GMP
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 V
    <- fresh-update-preserves-efxmap2tgtmap-converse/L V S GMP DM-M=S FS UD XMP2GMP.

- : fresh-update-preserves-efxmap2tgtmap-converse
    _ (efxmap`fresh/< GT1) (efxmap`update/> _ P2) _ _ DM-M=S FS UD XMP2GMP
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 V
    <- fresh-update-preserves-efxmap2tgtmap-converse/L V S GMP DM-M=S FS UD XMP2GMP.

- : fresh-update-preserves-efxmap2tgtmap-converse
    _ FS1 (efxmap`update/= nat`eq/) _ _ DM-M=S FS UD XMP2GMP
    <- efxmap`fresh-contradiction FS1 V
    <- fresh-update-preserves-efxmap2tgtmap-converse/L V S GMP DM-M=S FS UD XMP2GMP.

%worlds () (fresh-update-preserves-efxmap2tgtmap-converse _ _ _ _ _ _ _ _ _).
%total (U) (fresh-update-preserves-efxmap2tgtmap-converse _ _ U _ _ _ _ _ _).


%%% theorems about tgtmap-leq-efxmap


%theorem tgtmap-leq-efxmap-right-transitive : 
   forall* {GM} {XM1} {XM2}
   forall  {GM<=XM1: tgtmap-leq-efxmap GM XM1}
           {XM1<=XM2: efxmap`leq XM1 XM2}
   exists  {GM<=XM2: tgtmap-leq-efxmap GM XM2}
   true.

- : tgtmap-leq-efxmap-right-transitive
    (tgtmap-leq-efxmap/ GM<=GM1 XM1=>GM1) XM1<=XM2 
    (tgtmap-leq-efxmap/ GM<=GM2 XM2=>GM2)
    <- efxmap2tgtmap-total XM2=>GM2
    <- efxmap2tgtmap-preserves-efxmap-leq 
      XM1<=XM2 XM1=>GM1 XM2=>GM2 GM1<=GM2
    <- tgtmap`leq-transitive GM<=GM1 GM1<=GM2 GM<=GM2.

%worlds () (tgtmap-leq-efxmap-right-transitive _ _ _).
%total  {} (tgtmap-leq-efxmap-right-transitive _ _ _).


%theorem tgtmap-leq-efxmap-left-transitive :
    forall* {GM1} {GM2} {XM}
    forall  {GM0<=XM: tgtmap-leq-efxmap GM1 XM}
            {GM0<=GM1: tgtmap`leq GM2 GM1}
    exists  {GM1<=XM: tgtmap-leq-efxmap GM2 XM}
    true.

- : tgtmap-leq-efxmap-left-transitive 
    (tgtmap-leq-efxmap/ GM1<=GM XM=>GM) GM2<=GM1
    (tgtmap-leq-efxmap/ GM2<=GM XM=>GM)
    <- tgtmap`leq-transitive GM2<=GM1 GM1<=GM GM2<=GM.

%worlds () (tgtmap-leq-efxmap-left-transitive _ _ _).
%total  {} (tgtmap-leq-efxmap-left-transitive _ _ _).


%theorem fresh-update-preserves-tgtmap-leq-efxmap-converse :
    forall* {GM} {XM} {GMP} {XMP} {N} {S} {M}
    forall  {GM<=XM: tgtmap-leq-efxmap GM XM}
            {N!<GMP: tgtmap`fresh GMP N} 
            {GMP+N=GM: tgtmap`update GMP N S GM}
            {N!<XMP: efxmap`fresh XMP N}
            {XMP+N=XM: efxmap`update XMP N M XM}
    exists  {GMP<=XMP: tgtmap-leq-efxmap GMP XMP}
    true.

- : fresh-update-preserves-tgtmap-leq-efxmap-converse 
    (tgtmap-leq-efxmap/ GM<=XGM XM=>XGM) N!<GMP GMP+N=GM N!<XMP XMP+N=XM 
    (tgtmap-leq-efxmap/ GMP<=XGMP XMP=>XGMP)
    <- fresh-update-preserves-efxmap2tgtmap-converse
      XM=>XGM N!<XMP XMP+N=XM _ _ DM-M=S N!<XGMP XGMP+N=XGM XMP=>XGMP
    <- tgtmap`fresh-update-preserves-leq-converse
      GM<=XGM N!<GMP GMP+N=GM N!<XGMP XGMP+N=XGM GMP<=XGMP _.

%worlds () (fresh-update-preserves-tgtmap-leq-efxmap-converse _ _ _ _ _ _ ).
%total {} (fresh-update-preserves-tgtmap-leq-efxmap-converse _ _ _ _ _ _).
      

%theorem tgtmap2efxmap-implies-tgtmap-leq-efxmap :
    forall* {GM} {X} {XM}
    forall  {GM=>XM: tgtmap2efxmap GM X XM}
    exists  {GM<=XM: tgtmap-leq-efxmap GM XM}
    true.

- : tgtmap2efxmap-implies-tgtmap-leq-efxmap GM=>XM 
    (tgtmap-leq-efxmap/ GM<=GM XM=>GM)
    <- tgtmap2efxmap-implies-efxmap2tgtmap GM=>XM XM=>GM
    <- tgtmap`leq-reflexive _ GM<=GM.

%worlds () (tgtmap2efxmap-implies-tgtmap-leq-efxmap _ _).
%total  {} (tgtmap2efxmap-implies-tgtmap-leq-efxmap _ _).


%% theorems about set+nat2tgtmap

%theorem set+nat2tgtmap-total* :
    forall {S} {F}
    exists {GM} {S+F=>GM: set+nat2tgtmap S F GM}
    true.

- : set+nat2tgtmap-total* set/0 _ tgtmap/0 set+nat2tgtmap/0.

- : set+nat2tgtmap-total* (set/+ L S) F
    (tgtmap/+ L (set/1 F) M) (set+nat2tgtmap/+ S+F=>M)
    <- set+nat2tgtmap-total* S F M S+F=>M.

%worlds () (set+nat2tgtmap-total* _ _ _ _).
%total (S) (set+nat2tgtmap-total* S _ _ _).

%abbrev set+nat2tgtmap-total = set+nat2tgtmap-total* _ _ _.


%{% shift doesn't affect set+nat2tgtmap since
  we only look at values, not keys. %}%

%theorem shift-preserves-set+nat2tgtmap :
    forall* {S} {F} {GM} {SP} {GMP}
    forall  {S+F=>GM: set+nat2tgtmap S F GM}
            {F<=S=SP: set`shift F S SP}
            {F<=GM=GMP: tgtmap`shift F GM GMP}
    exists  {SP+F=>GMP: set+nat2tgtmap SP F GMP}
    true.

- : shift-preserves-set+nat2tgtmap 
     set+nat2tgtmap/0 set`shift/0 tgtmap`shift/0 set+nat2tgtmap/0.

- : shift-preserves-set+nat2tgtmap
     (set+nat2tgtmap/+ S+F=>GM) _ _ (set+nat2tgtmap/+ S+F=>GM).

%worlds () (shift-preserves-set+nat2tgtmap _ _ _ _).
%total  {} (shift-preserves-set+nat2tgtmap _ _ _ _).


%theorem shift-preserves-set+nat2tgtmap-converse :
    forall* {S} {F} {GM} {SP} {GMP} {L}
    forall  {S+F=>GM: set+nat2tgtmap SP F GMP}
            {F<=S=SP: set`shift L S SP}
            {F<=GM=GMP: tgtmap`shift L GM GMP}
    exists  {SP+F=>GMP: set+nat2tgtmap S F GM}
    true.

- : shift-preserves-set+nat2tgtmap-converse 
     set+nat2tgtmap/0 set`shift/0 tgtmap`shift/0 set+nat2tgtmap/0.

- : shift-preserves-set+nat2tgtmap-converse
     (set+nat2tgtmap/+ S+F=>GM) _ _ (set+nat2tgtmap/+ S+F=>GM).

%worlds () (shift-preserves-set+nat2tgtmap-converse _ _ _ _).
%trustme %total  {} (shift-preserves-set+nat2tgtmap-converse _ _ _ _).


%theorem set+nat2tgtmap-implies-domain :
    forall* {S} {F} {GM}
    forall  {S+F=>GM: set+nat2tgtmap S F GM}
    exists  {DM-GM=S: tgtmap`domain GM S}
    true.

- : set+nat2tgtmap-implies-domain set+nat2tgtmap/0 tgtmap`domain/0.

- : set+nat2tgtmap-implies-domain 
    (set+nat2tgtmap/+ S+F=>GM) (tgtmap`domain/+ DM-GM=S)
    <- set+nat2tgtmap-implies-domain S+F=>GM DM-GM=S.

%worlds () (set+nat2tgtmap-implies-domain _ _).
%total (A) (set+nat2tgtmap-implies-domain A _).



%%% theorems about efxmap`remove-tgtmap

%theorem efxmap`remove-tgtmap-implies-efxmap2tgtmap :
    forall* {XM} {GM} {XM1} {XM2}
    forall  {XM/GM=XM1UXM2: efxmap`remove-tgtmap XM GM XM1 XM2}
            {GM<=XM: tgtmap-leq-efxmap GM XM}
    exists  {XM1=>GM1: efxmap2tgtmap XM2 GM}
    true.

%theorem efxmap`remove-tgtmap-implies-leq :
    forall* {XM} {GM} {XM1} {XM2}
    forall  {R: efxmap`remove-tgtmap XM GM XM1 XM2}
    exists  {L1: efxmap`leq XM1 XM} {L2: efxmap`leq XM2 XM}
    true.

- : efxmap`remove-tgtmap-implies-leq 
    efxmap`remove-tgtmap/0 efxmap`leq/0 efxmap`leq/0.

- : efxmap`remove-tgtmap-implies-leq
    (efxmap`remove-tgtmap/+/in U2 U1 R SH R2 R1 R3 DM L) L1 L2
    <- efxmap`remove-tgtmap-implies-leq R XM1P<=XMP XM2P<=XMP.
      

%theorem efxmap`remove-tgtmap-respects-tgtmap-leq :
    forall* {XM} {GM} {XM1} {XM2} {GMP} {F} {S}
    forall  {XM/GM=XM1UXM2: efxmap`remove-tgtmap XM GM XM1 XM2}
            {FS: tgtmap`fresh GMP F}
            {U: tgtmap`update GMP F S GM} 
            {FS: efxmap`fresh XM F}
    exists  {R: efxmap`remove-tgtmap XM GMP XM1 XM2}
    true.

- : efxmap`remove-tgtmap-respects-tgtmap-leq
    efxmap`remove-tgtmap/0 _ _ _ efxmap`remove-tgtmap/0. 

- : efxmap`remove-tgtmap-respects-tgtmap-leq
    (efxmap`remove-tgtmap/+/in U1 U2 R SH-XM E1 E2 M D GM->N)
    F!<GMP GMP+F=GM F!<XM 
    (efxmap`remove-tgtmap/+/in U1 U2 R1 SH-XM E1 E2 M D GMP->N)
    <- efxmap`shift-implies-update SH-XM U-XM
    <- efxmap`shift-implies-fresh SH-XM FS-XM
    <- efxmap`fresh-update-implies-leq FS-XM U-XM XMP<=XM
    <- efxmap`fresh-respects-geq F!<XM XMP<=XM F!<XMP
    <- efxmap`remove-tgtmap-respects-tgtmap-leq R F!<GMP GMP+F=GM F!<XMP R1
    <- efxmap`fresh-lookup-not-equal F!<XM (efxmap`lookup/= nat`eq/) F!=N
    <- nat`ne-symmetric F!=N N!=F
    <- tgtmap`update-preserves-lookup-converse GM->N GMP+F=GM N!=F GMP->N.

- : efxmap`remove-tgtmap-respects-tgtmap-leq
    (efxmap`remove-tgtmap/+/out U R SH-XM N!<GM) F!<GMP GMP+F=GM F!<XM 
    (efxmap`remove-tgtmap/+/out U R1 SH-XM N!<GMP)
    <- efxmap`shift-implies-update SH-XM U-XM
    <- efxmap`shift-implies-fresh SH-XM FS-XM
    <- efxmap`fresh-update-implies-leq FS-XM U-XM XMP<=XM
    <- efxmap`fresh-respects-geq F!<XM XMP<=XM F!<XMP
    <- efxmap`remove-tgtmap-respects-tgtmap-leq R F!<GMP GMP+F=GM F!<XMP R1
    <- tgtmap`fresh-update-implies-leq F!<GMP GMP+F=GM GMP<=GM
    <- tgtmap`fresh-respects-geq N!<GM GMP<=GM N!<GMP. 
      
%worlds () (efxmap`remove-tgtmap-respects-tgtmap-leq _ _ _ _ _).
%total (R) (efxmap`remove-tgtmap-respects-tgtmap-leq R _ _ _ _).

% - : efxmap`remove-tgtmap-implies-efxmap2tgtmap
%     (efxmap`remove-tgtmap/+/in XM1P+F=XM1 XM2P+F=XM2 XMP/GM=XM1PUXM2P
%       F<<XM=XMP M/S1=M1 M/S2=M2 MS/S2=S1 DM-M=MS GM->F=S2)
%     GM<=XM _
%     <- tgtmap`lookup-implies-fresh-update GM->F=S2 GMP F!<GMP GMP+F=GM
%     <- efxmap`shift-implies-fresh F<<XM=XMP F!<XMP
%     <- efxmap`shift-implies-update F<<XM=XMP XMP+F=XM
%     <- efxmap`remove-tgtmap-respects-tgtmap-leq
%       XMP/GM=XM1PUXM2P F!<GMP GMP+F=GM F!<XMP XMP/GMP=XM1PUXM2P
%     <- fresh-update-preserves-tgtmap-leq-efxmap-converse
%       GM<=XM F!<GMP GMP+F=GM F!<XMP XMP+F=XM GMP<=XMP
%     <- efxmap`remove-tgtmap-implies-efxmap2tgtmap
%       XMP/GMP=XM1PUXM2P GMP<=XMP XM2P=>GMP
%     <- fresh-update-preserves-efxmap2tgtmap XM2P=>GMP
%       N!<XM2P XM2P+F=XM2 N!<GMP GMP+F=GM XM2P
      
      

