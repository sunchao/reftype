%%% Theorems about capmap-vleq

%theorem capmap-vleq-reflexive
  : forall* {M}
    exists {M=<=M: capmap-vleq M M}
    true.

- : capmap-vleq-reflexive (capmap-vleq/ DM DM M<=M)
    <- capmap`domain-total DM
    <- capmap`leq-reflexive _ M<=M.

%worlds () (capmap-vleq-reflexive _).
%total { } (capmap-vleq-reflexive _).


%theorem capmap-vleq-implies-leq
  : forall* {M} {MP}
    forall {M=<=MP: capmap-vleq M MP}
    exists {M<=MP: capmap`leq M MP}
    true.

- : capmap-vleq-implies-leq
    (capmap-vleq/ _ _ LE) LE.

%worlds () (capmap-vleq-implies-leq _ _).
%total { } (capmap-vleq-implies-leq _ _).


%theorem capmap-vleq-implies-same-domain
  : forall* {M} {MP}
    forall {M=<=MP: capmap-vleq M MP}
    exists {M-D-MP: capmap-same-domain M MP}
    true.

- : capmap-vleq-implies-same-domain
    (capmap-vleq/ DM1 DM2 _)
    (capmap-same-domain/ DM1 DM2).

%worlds () (capmap-vleq-implies-same-domain _ _).
%total { } (capmap-vleq-implies-same-domain _ _).


%theorem capmap-same-domain-implies-domain-left
  : forall* {M} {MP} {S}
    forall {M=<=MP: capmap-same-domain M MP}
    {DM-M: capmap`domain M S}
    exists {DM-MP: capmap`domain MP S}
    true.

- : capmap-same-domain-implies-domain-left
    (capmap-same-domain/ DM-M=SP DM-MP=SP) DM-M=S DM-MP=S
    <- capmap`domain-unique DM-M=SP DM-M=S capmap`eq/ SP=S
    <- capmap`domain-respects-eq DM-MP=SP capmap`eq/ SP=S DM-MP=S.

%worlds () (capmap-same-domain-implies-domain-left _ _ _).
%total { } (capmap-same-domain-implies-domain-left _ _ _).


%theorem capmap-same-domain-implies-domain-right
  : forall* {M} {MP} {S}
    forall {M=<=MP: capmap-same-domain M MP}
    {DM-MP: capmap`domain MP S}
    exists {DM-M: capmap`domain M S}
    true.

- : capmap-same-domain-implies-domain-right
    (capmap-same-domain/ DM-M=SP DM-MP=SP) DM-MP=S DM-M=S
    <- capmap`domain-unique DM-MP=SP DM-MP=S capmap`eq/ SP=S
    <- capmap`domain-respects-eq DM-M=SP capmap`eq/ SP=S DM-M=S.

%worlds () (capmap-same-domain-implies-domain-right _ _ _).
%total { } (capmap-same-domain-implies-domain-right _ _ _).


%theorem capmap-vleq-respects-disjoint
  : forall* {M1} {M1P} {M2} {M2P}
    forall {M1=<=M1P: capmap-vleq M1 M1P}
    {M2=<=M2P: capmap-vleq M2 M2P}
    {M1^M2: capmap`disjoint M1 M2}
    exists {M1P^M2P: capmap`disjoint M1P M2P}
    true.

%worlds () (capmap-vleq-respects-disjoint _ _ _ _).
%trustme %total { } (capmap-vleq-respects-disjoint _ _ _ _).


%%% For this lemma, we actually just need the "same-domain" condition.

% %theorem capmap-vleq-preserves-same-object
%   : forall* {M} {MP} {N}
%     forall {M-N: capmap-same-object M N}
%     {M<=MP: capmap-vleq M MP}
%     exists {MP-N: capmap-same-object MP N}
%     true.

% %worlds () (capmap-vleq-preserves-same-object _ _ _).
% %trustme %total {} (capmap-vleq-preserves-same-object _ _ _).


% %theorem capmap-map-fields-vleq
%   : forall* {M} {MP} {MF}
%     forall {M=>MF: capmap-map-fields M MF}
%     {SDM: capmap-vleq M MP}
%     exists {MFP}
%     {MP=>MFP: capmap-map-fields MP MFP}
%     {SDM: capmap-vleq MF MFP}
%     true.

% %worlds () (capmap-map-fields-vleq _ _ _ _ _).
% %trustme %total { } (capmap-map-fields-vleq _ _ _ _ _).


% %theorem capmap-map-fields-vleq-converse
%   : forall* {M} {MFP} {MF}
%     forall {M=>MF: capmap-map-fields M MF}
%     {SDM: capmap-vleq MF MFP}
%     exists {MP}
%     {MP=>MFP: capmap-map-fields MP MFP}
%     {SDM: capmap-vleq M MP}
%     true.

% %worlds () (capmap-map-fields-vleq-converse _ _ _ _ _).
% %trustme %total { } (capmap-map-fields-vleq-converse _ _ _ _ _).


% %theorem capmap-map-fields-vleq-converse*
%   : forall* {M} {MFP} {MF} {MP}
%     forall {M=>MF: capmap-map-fields M MF}
%     {SDM: capmap-vleq MF MFP}
%     {MP=>MFP: capmap-map-fields MP MFP}
%     exists {SDM: capmap-vleq M MP}
%     true.

% %worlds () (capmap-map-fields-vleq-converse* _ _ _ _).
% %trustme %total { } (capmap-map-fields-vleq-converse* _ _ _ _).


%theorem set+map2map-vleq
  : forall* {S} {MF} {M} {MFP}
    forall {S+MF=M: set+map2map S MF M}
    {MF<=MFP: capmap-vleq MF MFP}
    exists {MP} {S+MFP=MP: set+map2map S MFP MP}
    {MF<=MFP: capmap-vleq M MP}
    true.

%worlds () (set+map2map-vleq _ _ _ _ _).
%trustme %total {} (set+map2map-vleq _ _ _ _ _).


%{%

This theorem cannot be proved:
Suppose S is {a,b}, and MF is {f:R, g:W}, then M is {a.f:R, b.f:R, a.g:W, b.g:W}
Now, MP could be {a.f:R, b.f:W, a.g:W, b.g:W}, so MFP doesn't exist for this case.

%theorem set+map2map-vleq-converse
  : forall* {S} {MF} {M} {MP}
    forall {S+MF=M: set+map2map S MF M}
    {M<=MP: capmap-vleq M MP}
    exists {MFP} {S+MFP=MP: set+map2map S MFP MP}
    {MF<=MFP: capmap-vleq MF MFP}
    true.

%worlds () (set+map2map-vleq-converse _ _ _ _ _).
%trustme %total {} (set+map2map-vleq-converse _ _ _ _ _).

%}%


%theorem set2capmap-vleq
  : forall* {S} {X} {XP} {M}
    forall {S+MF=M: set2capmap S X M}
    {X<=XP: cap`leq X XP}
    exists {MP} {S+XP=MP: set2capmap S XP MP}
    {MF<=MFP: capmap-vleq M MP}
    true.

%worlds () (set2capmap-vleq _ _ _ _ _).
%trustme %total {} (set2capmap-vleq _ _ _ _ _).


%theorem set2capmap-vleq-converse
  : forall* {S} {X} {XP} {M}
    forall {S+X=M: set2capmap S X M}
    {X<=XP: cap`leq X XP}
    exists {MP} {S+MFP=MP: set2capmap S XP MP}
    {MF<=MFP: capmap-vleq M MP}
    true.

%worlds () (set2capmap-vleq-converse _ _ _ _ _).
%trustme %total {} (set2capmap-vleq-converse _ _ _ _ _).


%theorem set2capmap-vleq-converse*
  : forall* {S} {X} {XP} {M} {MP}
    forall {S+X=M: set2capmap S X M}
    {X<=XP: cap`leq X XP}
    {S+MFP=MP: set2capmap S XP MP}
    exists {MF<=MFP: capmap-vleq M MP}
    true.

%worlds () (set2capmap-vleq-converse* _ _ _ _).
%trustme %total {} (set2capmap-vleq-converse* _ _ _ _).


%theorem capmap-disjoint-join-vleq
  : forall* {M1} {M2} {M} {M1P} {M2P}
    forall {M1^M2: capmap`disjoint M1 M2}
    {M1+M2=M: capmap`join M1 M2 M}
    {M1<=M1P: capmap-vleq M1 M1P}
    {M2<=M2P: capmap-vleq M2 M2P}
    exists {MP}
    {M1P^M2P: capmap`disjoint M1P M2P}
    {M1P+M2P=MP: capmap`join M1P M2P MP}
    {M<=MP: capmap-vleq M MP}
    true.

%worlds () (capmap-disjoint-join-vleq _ _ _ _ _ _ _ _).
%trustme %total {} (capmap-disjoint-join-vleq _ _ _ _ _ _ _ _).


%theorem capmap-disjoint-join-vleq-converse
  : forall* {M1} {M2} {M} {MP}
    forall {M1^M2: capmap`disjoint M1 M2}
    {M1+M2=M: capmap`join M1 M2 M}
    {M<=MP: capmap-vleq M MP}
    exists {M1P} {M2P}
    {M1P^M2P: capmap`disjoint M1P M2P}
    {M1P+M2P=MP: capmap`join M1P M2P MP}
    {M1<=M1P: capmap-vleq M1 M1P}
    {M2<=M2P: capmap-vleq M2 M2P}
    true.

%worlds () (capmap-disjoint-join-vleq-converse _ _ _ _ _ _ _ _ _).
%trustme %total {} (capmap-disjoint-join-vleq-converse _ _ _ _ _ _ _ _ _).


% %theorem capmap-partition-on-index-vleq
%   : forall* {M} {N} {MP} {Mout} {Min}
%     forall {M|N=Mout+Min: capmap-partition-on-index M N Mout Min}
%     {M=<=MP: capmap-vleq M MP}
%     exists {MoutP} {MinP}
%     {MP|N=MoutP+MinP: capmap-partition-on-index MP N MoutP MinP}
%     {Mout=<=MoutP: capmap-vleq Mout MoutP}
%     {Min=<=MinP: capmap-vleq Min MinP}
%     true.

% %worlds () (capmap-partition-on-index-vleq _ _ _ _ _ _ _).
% %trustme %total {} (capmap-partition-on-index-vleq _ _ _ _ _ _ _).


% %theorem capmap-partition-on-index-vleq-converse
%   : forall* {N} {M} {Mout} {MoutP} {Min} {MinP}
%     forall {M|N=Mout+Min: capmap-partition-on-index M N Mout Min}
%     {Mout=<=MoutP: capmap-vleq Mout MoutP}
%     {Min=<=MinP: capmap-vleq Min MinP}
%     exists {MP}
%     {MP|N=MoutP+MinP: capmap-partition-on-index MP N MoutP MinP}
%     {M=<=MP: capmap-vleq M MP}
%     true.

% %worlds () (capmap-partition-on-index-vleq-converse _ _ _ _ _ _).
% %trustme %total {} (capmap-partition-on-index-vleq-converse _ _ _ _ _ _).


% %theorem join-preserves-capmap-vleq
%   : forall* {M1} {M2} {MP1} {MP2} {M}
%     forall {M1+M2=M: capmap`join M1 M2 M}
%     {M1=<=MP1: capmap-vleq M1 MP1}
%     {M2=<=MP2: capmap-vleq M2 MP2}
%     exists {MP} {MP1+MP2=MP: capmap`join MP1 MP2 MP}
%     {M=<=MP: capmap-vleq M MP}
%     true.

% %worlds () (join-preserves-capmap-vleq _ _ _ _ _ _).
% %trustme %total {} (join-preserves-capmap-vleq _ _ _ _ _ _).


% %theorem capmap-vleq-preserves-disjoint-left
%   : forall* {M1} {M1P} {M2}
%     forall {M1^M2: capmap`disjoint M1 M2}
%     {M1=<=M1P: capmap-vleq M1 M1P}
%     exists {M1P^M2: capmap`disjoint M1P M2}
%     true.

% - : capmap-vleq-preserves-disjoint-left M1^M2
%     (capmap-vleq/ DM-M1=S DM-M1P=S M1<=M1P) M1P^M2
%     <- capmap`domain-total DM-M2=S2
%     <- capmap`domain-preserves-disjoint M1^M2 DM-M1=S DM-M2=S2 S^S2
%     <- capmap`domain-preserves-disjoint-converse S^S2 DM-M1P=S DM-M2=S2 M1P^M2.

% %worlds () (capmap-vleq-preserves-disjoint-left _ _ _).
% %total { } (capmap-vleq-preserves-disjoint-left _ _ _).
