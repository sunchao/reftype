%%% Explicit Type Context
% $Id$


% definition

cxt : type.	%name cxt B.


% equality 

cxt`eq : cxt -> cxt -> type.

cxt`eq/ : cxt`eq B B.


% this vtype is really ugly. better solution?

vtype : type.	%name vtype VT.

vtype/unique : nat -> vtype.

vtype/shared : vtype.


% constructor

cxt/nil : cxt.

cxt/cons : object -> vtype -> ty -> cxt -> cxt.


%{ Well-formed Context:
  All indexes are different, and in monotonically increasing
    order from inner to outer context. 
  !! This definition is so complex! Anyway to make it simpler? }%

cxt-ordered : cxt -> type.

cxt-bounded : cxt -> nat -> type.

cxt-bounded/nil : cxt-bounded cxt/nil _.

cxt-bounded/cons/unique
  : nat`gt N M 
    -> cxt-bounded B M
    -> cxt-bounded (cxt/cons _ (vtype/unique M) _ B) N.

cxt-bounded/cons/shared
  : cxt-bounded B N
    -> cxt-bounded (cxt/cons _ vtype/shared _ B) N.

cxt-ordered/nil : cxt-ordered cxt/nil.

cxt-ordered/cons/unique
  : cxt-bounded B N
    -> cxt-ordered (cxt/cons _ (vtype/unique N) _ B).

cxt-ordered/cons/shared
  : cxt-ordered B
    -> cxt-ordered (cxt/cons _ vtype/shared _ B).


% lookup object

cxt-lookup : cxt -> object -> vtype -> ty -> type.

cxt-lookup/hit : cxt-lookup (cxt/cons O VT T B) O VT T.

cxt-lookup/miss
  : cxt-lookup (cxt/cons O _ _ B) O' VT T
    <- cxt-lookup B O' VT T.


% lookup location

cxt-lookup-index : cxt -> nat -> object -> ty -> type.

cxt-lookup-index/hit
  : cxt-lookup-index (cxt/cons O (vtype/unique N) T _) N O T.

cxt-lookup-index/miss
  : cxt-lookup-index (cxt/cons _ _ _ B) N O T
    <- cxt-lookup-index B N O T.


%%% theorems

%theorem false-implies-object-eq :
	forall* {O1:object} {O2}
	forall  {F:void}
	exists  {EQ: object`eq O1 O2}
	true.

%worlds (objvar) (false-implies-object-eq _ _).
%total  {} (false-implies-object-eq _ _).


%theorem false-implies-ty-eq :
	forall* {T1} {T2}
	forall  {F:void}
	exists  {EQ: ty`eq T1 T2}
	true.

%worlds (objvar) (false-implies-ty-eq _ _).
%total  {} (false-implies-ty-eq _ _).


%theorem false-implies-cxt-lookup-index :
    forall* {B} {L} {O} {T}
    forall  {F:void}
    exists  {B-L: cxt-lookup-index B L O T}
    true.

%worlds () (false-implies-cxt-lookup-index _ _).
%total  {} (false-implies-cxt-lookup-index _ _).


cxt-bounded-weaken 
  : cxt-bounded B L
    -> nat`gt M L 
    -> cxt-bounded B M
    -> type.

%mode cxt-bounded-weaken +B1 +G1 -B2.

- : cxt-bounded-weaken cxt-bounded/nil _ cxt-bounded/nil.

- : cxt-bounded-weaken (cxt-bounded/cons/unique GT2 B-B) GT 
    (cxt-bounded/cons/unique GT3 B-B)
    <- nat`gt-transitive GT GT2 GT3.

- : cxt-bounded-weaken (cxt-bounded/cons/shared B-B) 
    GT2 (cxt-bounded/cons/shared B-B2)
    <- cxt-bounded-weaken B-B GT2 B-B2.

%worlds () (cxt-bounded-weaken _ _ _).
%total (B) (cxt-bounded-weaken B _ _).


cxt-lookup-bounded-false
  : cxt-lookup-index B L O T
    -> cxt-bounded B L
    -> void
    -> type.

%mode cxt-lookup-bounded-false  +D1 +D2 -V.

- : cxt-lookup-bounded-false 
    cxt-lookup-index/hit (cxt-bounded/cons/unique GT _) V
    <- nat`gt-anti-reflexive GT V.

- : cxt-lookup-bounded-false 
    (cxt-lookup-index/miss B-L) (cxt-bounded/cons/unique GT B-B) V
    <- cxt-bounded-weaken B-B GT B-B2
    <- cxt-lookup-bounded-false B-L B-B2 V.

- : cxt-lookup-bounded-false
    (cxt-lookup-index/miss B-L) (cxt-bounded/cons/shared B-B) V
    <- cxt-lookup-bounded-false B-L B-B V.

%worlds () (cxt-lookup-bounded-false _ _ _).
%total (L) (cxt-lookup-bounded-false L _ _).