%%% Explicit type context.
%%% $Id: cxt.elf,v 1.1 2013/09/19 14:51:33 csun Exp csun $


%%% Definitions

cxt : type. %name cxt B.

cxt/nil : cxt.

cxt/cons : object -> ty -> cxt -> cxt.


cxt`eq : cxt -> cxt -> type.

cxt`eq/ : cxt`eq B B.


%{
 Two objects are not equal if their representing nat is
 not equal (of course). This is defined in simple-concur/object.elf,
 but is later overwritten by frac-nesting/permission.elf.
}%

object`ne : object -> object -> type.

object`ne/ : nat`ne N1 N2 -> object`ne (object/ N1) (object/ N2).


% lookup operation

cxt`lookup : cxt -> object -> ty -> type.

cxt`lookup/hit
  : cxt`lookup (cxt/cons O T B) O T.

cxt`lookup/miss
  : cxt`lookup (cxt/cons O' _ B) O T
    <- object`ne O O'
    <- cxt`lookup B O T.


%%% Theorems

%theorem cxt`lookup-respects-eq
  : forall* {B1} {B2} {O1} {O2} {T1} {T2}
    forall {L: cxt`lookup B1 O1 T1}
    {E: cxt`eq B1 B2} {E: object`eq O1 O2}
    {E: ty`eq T1 T2}
    exists {L: cxt`lookup B2 O2 T2}
    true.

- : cxt`lookup-respects-eq L cxt`eq/ object`eq/ ty`eq/ L.

%worlds (objvar) (cxt`lookup-respects-eq _ _ _ _ _).
%total {} (cxt`lookup-respects-eq _ _ _ _ _).


%theorem cxt`eq/cons-inversion
  : forall* {O1} {O2} {T1} {T2} {B1} {B2}
    forall {E: cxt`eq (cxt/cons O1 T1 B1) (cxt/cons O2 T2 B2)}
    exists {OE: object`eq O1 O2} {E: ty`eq T1 T2} {E: cxt`eq B1 B2}
    true.

- : cxt`eq/cons-inversion cxt`eq/ object`eq/ ty`eq/ cxt`eq/.

%worlds (objvar) (cxt`eq/cons-inversion _ _ _ _).
%total {} (cxt`eq/cons-inversion _ _ _ _).


%theorem cxt`lookup-unique
  : forall* {B1} {B2} {O1} {O2} {T1} {T2}
    forall {L1: cxt`lookup B1 O1 T1}
    {L2: cxt`lookup B2 O2 T2}
    {E: cxt`eq B1 B2} {E: object`eq O1 O2}
    exists {E: ty`eq T1 T2}
    true.

- : cxt`lookup-unique cxt`lookup/hit cxt`lookup/hit cxt`eq/ object`eq/ ty`eq/.

- : cxt`lookup-unique
    (cxt`lookup/miss L1 N1) (cxt`lookup/miss L2 N2) CE OE TE
    <- cxt`eq/cons-inversion CE _ _ CE1
    <- cxt`lookup-unique L1 L2 CE1 OE TE.

- : cxt`lookup-unique (cxt`lookup/hit) (cxt`lookup/miss _ (object`ne/ N<>N))
    cxt`eq/ object`eq/ E
    <- nat`ne-anti-reflexive N<>N F
    <- ty`false-implies-eq F E.

- : cxt`lookup-unique (cxt`lookup/miss _ (object`ne/ N<>N)) (cxt`lookup/hit)
    cxt`eq/ object`eq/ E
    <- nat`ne-anti-reflexive N<>N F
    <- ty`false-implies-eq F E.

%worlds (objvar) (cxt`lookup-unique _ _ _ _ _).
%total (L) (cxt`lookup-unique L _ _ _ _).