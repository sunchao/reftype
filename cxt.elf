%%% Context (Type Environment)
%%% nat -> (object,ty)

cxt-info : type. %name cxt-info CI.

cxt-info/ : object -> ty -> cxt-info.

eq : cxt-info -> cxt-info -> type.

eq/ : eq CI CI.



%theorem false-implies-eq :
	forall* {X1} {X2}
	forall {F:void}
	exists {E:eq X1 X2}
	true.

%worlds (objvar) (false-implies-eq _ _).
%total { } (false-implies-eq _ _).


%theorem meta-eq :
	forall {X1} {X2} {E:eq X1 X2}
	true.

- : meta-eq _ _ eq/.

%worlds (objvar) (meta-eq _ _ _).
%total { } (meta-eq _ _ _).
%reduces X = Y (meta-eq X Y _).

	
%theorem eq-reflexive : 
	forall {X} 
	exists {E:eq X X} 
	true.

- : eq-reflexive _ eq/.

%worlds (objvar) (eq-reflexive _ _).
%total { } (eq-reflexive _ _).


%theorem eq-symmetric : 
	forall* {X} {Y}
	forall {E:eq X Y}
	exists {F:eq Y X}
	true.

- : eq-symmetric (eq/) (eq/).

%worlds (objvar) (eq-symmetric _ _).
%total { } (eq-symmetric _ _).


%theorem eq-transitive : 
	forall* {X} {Y} {Z}
	forall {E1:eq X Y} {E2:eq Y Z}
	exists {F:eq X Z}
	true.

- : eq-transitive (eq/) (eq/) (eq/).

%worlds (objvar) (eq-transitive _ _ _).
%total { } (eq-transitive _ _ _).



%abbrev cxt-info`eq = eq.
%abbrev cxt-info`eq/ = eq/.
%abbrev cxt-info`meta-eq = meta-eq.
%abbrev cxt-info`false-implies-eq = false-implies-eq.
%abbrev cxt-info`eq-reflexive = eq-reflexive.
%abbrev cxt-info`eq-symmetric = eq-symmetric.
%abbrev cxt-info`eq-transitive = eq-transitive.

%theorem cxt-info-preserves-eq
  : forall* {O1} {O2} {T1} {T2}
    forall {OE: object`eq O1 O2} {TE: ty`eq T1 T2}
    exists {TE: cxt-info`eq (cxt-info/ O1 T1) (cxt-info/ O2 T2)}
    true.

- : cxt-info-preserves-eq object`eq/ ty`eq/ cxt-info`eq/.

%worlds (objvar) (cxt-info-preserves-eq _ _ _).
%total { } (cxt-info-preserves-eq _ _ _).


%theorem cxt-info-eq-inversion :
    forall* {O1} {O2} {T1} {T2}
    forall  {T1=T2: cxt-info`eq (cxt-info/ O1 T1) (cxt-info/ O2 T2)}
    exists  {OE: object`eq O1 O2} {TE: ty`eq T1 T2}
    true.

- : cxt-info-eq-inversion cxt-info`eq/ object`eq/ ty`eq/.

%worlds (objvar) (cxt-info-eq-inversion _ _ _).
%total  {} (cxt-info-eq-inversion _ _ _).


%%%%%% vector.elf
%%%%%% John Boyland
%%%%%% You may freely use, modify and distribute this file without restrictions.


%%%%% This file requires the "nat.elf" signature (base only).

%{%
This signature implements vectors of a arbitrary ring
(we do not even require either operation to be invertible).
The vectors carry their length around so that we can
ensure that operations succeed.

The representation is "adequate" in that every vector
has a unique representation.  In other words, equality of the terms
is the same as semantic equality.
%}%

%{% 
This signature is incomplete.  It requires the following declarations:

cxt-info : type.
cxt-info`eq : cxt-info -> cxt-info -> type
cxt-info`eq/ : cxt-info`eq X X.
%theorem cxt-info`false-implies-eq : 
	forall* {X} {XP} forall {F:void} exists {E:cxt-info`eq X XP} true.
%worlds () (cxt-info`false-implies-eq _ %{=>}% X=XP).
%total {} (cxt-info`false-implies-eq _ _).

If ARITH is defined, it also assumes the existence of add and mul operations
and that these operators are unique/total/commutative/associative.

This file is intended to be copied and modified to apply to specific
cxt-info types.  If/when Twelf gets a module system, this signature
should be rewritten as a functor.
%}%

%{%
This file follows the same theorem naming convention as nat.elf (q.v.)
%}%



%%%% Definitions



%%% Definition of vectors


vector : nat -> type.


vector/0 : vector z.

vector/+ : cxt-info -> vector N -> vector (s N).



%%% Relations on vectors


eq : vector N -> vector N -> type.

eq/ : eq V V.





%%% lookup


get : vector N -> nat -> cxt-info -> type.


get/0 : get (vector/+ X _) nat`z X.

get/+ : get V N X ->
    get (vector/+ _ V) (s N) X.


rget : vector N -> nat -> cxt-info -> type.

rget/N : rget (vector/+ X (V:vector N)) N X.

rget/+ : rget V N X ->
    rget (vector/+ _ V) N X.



%%% update


set : vector N -> nat -> cxt-info -> vector N -> type.


set/0 : set (vector/+ X1 V) nat`z X2 (vector/+ X2 V).

set/+ : set V1 N X2 V2 ->
    set (vector/+ X1 V1) (s N) X2 (vector/+ X1 V2).


rset : vector N -> nat -> cxt-info -> vector N -> type.

rset/N : rset (vector/+ X1 (V:vector N)) N X2 (vector/+ X2 V).

rset/+ : rset V1 N X2 V2 ->
    rset (vector/+ X1 V1) N X2 (vector/+ X1 V2).



%%%% Theorems



%%% Theorems about eq


%theorem false-implies-eq :
        forall* {N} {X1:vector N} {X2}
        forall {F:void}
        exists {E:eq X1 X2}
        true.

%worlds (objvar) (false-implies-eq _ _).
%total { } (false-implies-eq _ _).


%theorem meta-eq :
	forall* {N}
        forall {X1: vector N} {X2} {E:eq X1 X2}
        true.

- : meta-eq _ _ eq/.

%worlds (objvar) (meta-eq _ _ _).
%total { } (meta-eq _ _ _).
%reduces X = Y (meta-eq X Y _).

        
%theorem eq-reflexive : 
	forall* {N}
        forall {X: vector N} 
        exists {E:eq X X} 
        true.

- : eq-reflexive _ eq/.

%worlds (objvar) (eq-reflexive _ _).
%total { } (eq-reflexive _ _).


%theorem eq-symmetric : 
        forall* {N} {X:vector N} {Y}
        forall {E:eq X Y}
        exists {F:eq Y X}
        true.

- : eq-symmetric (eq/) (eq/).

%worlds (objvar) (eq-symmetric _ _).
%total { } (eq-symmetric _ _).


%theorem eq-transitive : 
        forall* {N} {X: vector N} {Y} {Z}
        forall {E1:eq X Y} {E2:eq Y Z}
        exists {F:eq X Z}
        true.

- : eq-transitive (eq/) (eq/) (eq/).

%worlds (objvar) (eq-transitive _ _ _).
%total { } (eq-transitive _ _ _).


%theorem vector/+-eq-implies-eq :
	forall* {N} {D1} {V1:vector N} {D2} {V2}
        forall {E:eq (vector/+ D1 V1) (vector/+ D2 V2)}
	exists {E1:cxt-info`eq D1 D2}
               {E2:eq V1 V2}
	true.

- : vector/+-eq-implies-eq eq/ cxt-info`eq/ eq/.

%worlds (objvar) (vector/+-eq-implies-eq _ _ _).
%total { } (vector/+-eq-implies-eq _ _ _).


%theorem vector/+-preserves-eq :
	forall* {N} {D1} {D2} {V1:vector N} {V2}
	forall {E1:cxt-info`eq D1 D2}
               {E2:eq V1 V2}
        exists {E:eq (vector/+ D1 V1) (vector/+ D2 V2)}
	true.

- : vector/+-preserves-eq cxt-info`eq/ eq/ eq/.

%worlds (objvar) (vector/+-preserves-eq _ _ _).
%total { } (vector/+-preserves-eq _ _ _).




%%% Theorems about get


%theorem false-implies-get:
	forall*	{N} {V: vector N} {I} {X}
	forall	{F: void}
	exists	{G: get V I X}
	true.

%worlds (objvar) (false-implies-get _ _).
%total { } (false-implies-get _ _).


%theorem get-respects-eq:
	forall* {N} {V1: vector N} {I1} {X1}
		{V2: vector N} {I2} {X2}
	forall	{G1: get V1 I1 X1}
		{EV: eq V1 V2}
		{EN: nat`eq I1 I2}
		{ED: cxt-info`eq X1 X2}
	exists	{G2: get V2 I2 X2}
	true.

- : get-respects-eq G eq/ nat`eq/ cxt-info`eq/ G.

%worlds (objvar) (get-respects-eq _ _ _ _ _).
%total { } (get-respects-eq _ _ _ _ _).


%theorem get-deterministic:
	forall* {N} {V1: vector N} {I1} {X1}
		{V2: vector N} {I2} {X2}
	forall	{G1: get V1 I1 X1}
		{G2: get V2 I2 X2}
		{EV: eq V1 V2}
		{EN: nat`eq I1 I2}
	exists	{ED: cxt-info`eq X1 X2}
	true.

%abbrev get-unique = get-deterministic.

- : get-deterministic get/0 get/0 _ _ cxt-info`eq/.

- : get-deterministic (get/+ G1) (get/+ G2) eq/ nat`eq/ DE
    <- get-deterministic G1 G2 eq/ nat`eq/ DE.

%worlds (objvar) (get-deterministic _ _ _ _ _).
%total (G) (get-deterministic G _ _ _ _).


%theorem get-implies-gt:
	forall* {N} {V:vector N} {I} {X}
	forall	{G: get V I X}
	exists	{GT: nat`gt N I}
	true.

- : get-implies-gt get/0 GT
    <- succ-implies-gt-zero _ GT.

- : get-implies-gt (get/+ G) GT
    <- get-implies-gt G GTP
    <- succ-preserves-gt GTP GT.

%worlds (objvar) (get-implies-gt _ _).
%total (G) (get-implies-gt G _).


%theorem gt-implies-get*:
	forall* {N} {V:vector N}
	forall	{I} {GT: nat`gt N I}
	exists	{X} {G: get V I X}
	true.

%abbrev gt-implies-get : (nat`gt N I) -> (get V I X) -> type
	= [GT] [G] gt-implies-get* _ GT _ G.

- : gt-implies-get* nat`z _ _ get/0.

- : gt-implies-get* (nat`s I) N+1>I+1 _ (get/+ G)
    <- succ-preserves-gt-converse N+1>I+1 N>I
    <- gt-implies-get* I N>I _ G.

%worlds (objvar) (gt-implies-get* _ _ _ _).
%total (I) (gt-implies-get* I _ _ _).



%%% Theorems about rget


%theorem false-implies-rget:
	forall*	{N} {V: vector N} {I} {X}
	forall	{F: void}
	exists	{G: rget V I X}
	true.

%worlds (objvar) (false-implies-rget _ _).
%total { } (false-implies-rget _ _).


%theorem rget-respects-eq:
	forall* {N} {V1: vector N} {I1} {X1}
		{V2: vector N} {I2} {X2}
	forall	{G1: rget V1 I1 X1}
		{EV: eq V1 V2}
		{EN: nat`eq I1 I2}
		{ED: cxt-info`eq X1 X2}
	exists	{G2: rget V2 I2 X2}
	true.

- : rget-respects-eq G eq/ nat`eq/ cxt-info`eq/ G.

%worlds (objvar) (rget-respects-eq _ _ _ _ _).
%total { } (rget-respects-eq _ _ _ _ _).


%theorem rget-implies-gt:
	forall* {N} {V:vector N} {I} {X}
	forall	{G: rget V I X}
	exists	{GT: nat`gt N I}
	true.

- : rget-implies-gt rget/N nat`gt/1.

- : rget-implies-gt (rget/+ G) (nat`gt/> GT)
    <- rget-implies-gt G GT.

%worlds (objvar) (rget-implies-gt _ _).
%total (G) (rget-implies-gt G _).


%theorem gt-implies-rget*:
	forall* {N} {I} {V:vector N}
	forall	{GT: nat`gt N I}
	exists	{X} {G: rget V I X}
	true.

%abbrev gt-implies-rget : (nat`gt N I) -> (rget V I X) -> type
	= [GT] [G] gt-implies-rget* GT _ G.

- : gt-implies-rget* gt/1 _ rget/N.

- : gt-implies-rget* (gt/> G) _ (rget/+ R)
    <- gt-implies-rget* G _ R.

%worlds (objvar) (gt-implies-rget* _ _ _).
%total (G) (gt-implies-rget* G _ _).


%theorem rget-deterministic:
	forall* {N} {V1: vector N} {I1} {X1}
		{V2: vector N} {I2} {X2}
	forall	{G1: rget V1 I1 X1}
		{G2: rget V2 I2 X2}
		{EV: eq V1 V2}
		{EN: nat`eq I1 I2}
	exists	{ED: cxt-info`eq X1 X2}
	true.

%abbrev rget-unique = rget-deterministic.

- : rget-deterministic rget/N rget/N _ _ cxt-info`eq/.

- : rget-deterministic rget/N (rget/+ R) eq/ nat`eq/ EQ
    <- rget-implies-gt R GT
    <- nat`gt-anti-reflexive GT F
    <- cxt-info`false-implies-eq F EQ.

- : rget-deterministic (rget/+ R) rget/N eq/ nat`eq/ EQ
    <- rget-implies-gt R GT
    <- nat`gt-anti-reflexive GT F
    <- cxt-info`false-implies-eq F EQ.

- : rget-deterministic (rget/+ G1) (rget/+ G2) eq/ nat`eq/ DE
    <- rget-deterministic G1 G2 eq/ nat`eq/ DE.

%worlds (objvar) (rget-deterministic _ _ _ _ _).
%total (G) (rget-deterministic G _ _ _ _).


% The following theorem is NOT true for regular get:
%theorem vector/+-preserves-rget :
	forall*	{N} {V:vector N} {I} {X} {XP}
	forall	{R: rget V I X}
	exists	{RP: rget (vector/+ XP V) I X}
	true.

- : vector/+-preserves-rget R (rget/+ R).

%worlds (objvar) (vector/+-preserves-rget _ _).
%total { } (vector/+-preserves-rget _ _).



%%% Theorems about set


%theorem false-implies-set:
	forall*	{N} {V: vector N} {I} {X} {VP}
	forall	{F: void}
	exists	{G: set V I X VP}
	true.

%worlds (objvar) (false-implies-set _ _).
%total { } (false-implies-set _ _).


%theorem set-respects-eq:
	forall* {N} {V1: vector N} {I1} {X1} {V3}
		{V2: vector N} {I2} {X2} {V4}
	forall	{G1: set V1 I1 X1 V3}
		{EV: eq V1 V2}
		{EN: nat`eq I1 I2}
		{ED: cxt-info`eq X1 X2}
		{ER: eq V3 V4}
	exists	{G2: set V2 I2 X2 V4}
	true.

- : set-respects-eq G eq/ nat`eq/ cxt-info`eq/ eq/ G.

%worlds (objvar) (set-respects-eq _ _ _ _ _ _).
%total { } (set-respects-eq _ _ _ _ _ _).


%theorem set-deterministic:
	forall* {N} {V1: vector N} {I1} {X1} {V3}
		{V2: vector N} {I2} {X2} {V4}
	forall	{G1: set V1 I1 X1 V3}
		{G2: set V2 I2 X2 V4}
		{EV: eq V1 V2}
		{EN: nat`eq I1 I2}
		{ED: cxt-info`eq X1 X2}
	exists	{ER: eq V3 V4}
	true.

%abbrev set-unique = set-deterministic.

- : set-deterministic set/0 set/0 _ _ cxt-info`eq/ eq/.

- : set-deterministic (set/+ G1) (set/+ G2) eq/ nat`eq/ cxt-info`eq/ EQ
    <- set-deterministic G1 G2 eq/ nat`eq/ cxt-info`eq/ EQP
    <- vector/+-preserves-eq cxt-info`eq/ EQP EQ.

%worlds (objvar) (set-deterministic _ _ _ _ _ _).
%total (G) (set-deterministic G _ _ _ _ _).


%theorem set-implies-gt:
	forall* {N} {V:vector N} {I} {X} {VP}
	forall	{G: set V I X VP}
	exists	{GT: nat`gt N I}
	true.

- : set-implies-gt set/0 GT
    <- succ-implies-gt-zero _ GT.

- : set-implies-gt (set/+ G) GT
    <- set-implies-gt G GTP
    <- succ-preserves-gt GTP GT.

%worlds (objvar) (set-implies-gt _ _).
%total (G) (set-implies-gt G _).


%theorem gt-implies-set*:
	forall* {N} {V:vector N} {X}
	forall	{I} {GT: nat`gt N I}
	exists	{VP} {G: set V I X VP}
	true.

%abbrev gt-implies-set : (nat`gt N I) -> (set V I X VP) -> type
	= [GT] [S] gt-implies-set* _ GT _ S.

- : gt-implies-set* nat`z _ _ set/0.

- : gt-implies-set* (nat`s I) N+1>I+1 _ (set/+ S)
    <- succ-preserves-gt-converse N+1>I+1 N>I
    <- gt-implies-set* I N>I _ S.

%worlds (objvar) (gt-implies-set* _ _ _ _).
%total (I) (gt-implies-set* I _ _ _).


%theorem set-idempotent:
	forall* {N} {V: vector N} {I} {X} {VP}
	forall	{S: set V I X VP}
	exists	{S: set VP I X VP}
	true.

- : set-idempotent set/0 set/0.

- : set-idempotent (set/+ S) (set/+ SP)
    <- set-idempotent S SP.

%worlds (objvar) (set-idempotent _ _).
%total (S) (set-idempotent S _).

	
%theorem set-implies-get:
	forall* {N} {V: vector N} {I} {X} {VP}
	forall	{S: set V I X VP}
	exists	{G: get VP I X}
	true.

- : set-implies-get set/0 get/0.

- : set-implies-get (set/+ S) (get/+ G)
    <- set-implies-get S G.

%worlds (objvar) (set-implies-get _ _).
%total (S) (set-implies-get S _).


%theorem set-overwrites:
	forall* {N} {V: vector N} {I} {X1} {V1} {X2} {V2}
	forall	{S1: set V I X1 V1}
		{S2: set V1 I X2 V2}
	exists	{S12: set V I X2 V2}
	true.

- : set-overwrites set/0 set/0 set/0.

- : set-overwrites (set/+ S1) (set/+ S2) (set/+ S12)
    <- set-overwrites S1 S2 S12.

%worlds (objvar) (set-overwrites _ _ _).
%total (S) (set-overwrites S _ _).


%theorem set-preserves-get:
	forall*	{N} {V1:vector N} {I1} {X1} {I2} {X2} {V2}
	forall	{G: get V1 I1 X1}
		{S: set V1 I2 X2 V2}
		{N: nat`ne I1 I2}
	exists	{G: get V2 I1 X1}
	true.

- : set-preserves-get get/0 set/0 Z<>Z G
    <- nat`eq-ne-implies-false nat`eq/ Z<>Z F
    <- false-implies-get F G.

- : set-preserves-get get/0 (set/+ S) _ get/0.

- : set-preserves-get (get/+ G) set/0 _ (get/+ G).

- : set-preserves-get (get/+ G) (set/+ S) I1+1<>I2+1 (get/+ GP)
    <- nat`succ-preserves-ne-converse I1+1<>I2+1 I1<>I2
    <- set-preserves-get G S I1<>I2 GP.

%worlds (objvar) (set-preserves-get _ _ _ _).
%total (G) (set-preserves-get G _ _ _).


%theorem set-preserves-get-converse:
	forall*	{N} {V1:vector N} {I1} {X1} {I2} {X2} {V2}
	forall	{G: get V2 I1 X1}
		{S: set V1 I2 X2 V2}
		{N: nat`ne I1 I2}
	exists	{G: get V1 I1 X1}
	true.

- : set-preserves-get-converse get/0 set/0 Z<>Z G
    <- nat`eq-ne-implies-false nat`eq/ Z<>Z F
    <- false-implies-get F G.

- : set-preserves-get-converse get/0 (set/+ S) _ get/0.

- : set-preserves-get-converse (get/+ G) set/0 _ (get/+ G).

- : set-preserves-get-converse (get/+ G) (set/+ S) I1+1<>I2+1 (get/+ GP)
    <- nat`succ-preserves-ne-converse I1+1<>I2+1 I1<>I2
    <- set-preserves-get-converse G S I1<>I2 GP.

%worlds (objvar) (set-preserves-get-converse _ _ _ _).
%total (G) (set-preserves-get-converse G _ _ _).



%%% Theorems about rset


%theorem false-implies-rset:
	forall*	{N} {V: vector N} {I} {X} {VP}
	forall	{F: void}
	exists	{G: rset V I X VP}
	true.

%worlds (objvar) (false-implies-rset _ _).
%total { } (false-implies-rset _ _).


%theorem rset-respects-eq:
	forall* {N} {V1: vector N} {I1} {X1} {V3}
		{V2: vector N} {I2} {X2} {V4}
	forall	{G1: rset V1 I1 X1 V3}
		{EV: eq V1 V2}
		{EN: nat`eq I1 I2}
		{ED: cxt-info`eq X1 X2}
		{ER: eq V3 V4}
	exists	{G2: rset V2 I2 X2 V4}
	true.

- : rset-respects-eq G eq/ nat`eq/ cxt-info`eq/ eq/ G.

%worlds (objvar) (rset-respects-eq _ _ _ _ _ _).
%total { } (rset-respects-eq _ _ _ _ _ _).


%theorem rset-implies-rget:
	forall* {N} {V: vector N} {I} {X} {VP}
	forall	{S: rset V I X VP}
	exists	{G: rget VP I X}
	true.

- : rset-implies-rget rset/N rget/N.

- : rset-implies-rget (rset/+ S) (rget/+ G)
    <- rset-implies-rget S G.

%worlds (objvar) (rset-implies-rget _ _).
%total (S) (rset-implies-rget S _).


%theorem rset-implies-gt:
	forall* {N} {V:vector N} {I} {X} {VP}
	forall	{G: rset V I X VP}
	exists	{GT: nat`gt N I}
	true.

- : rset-implies-gt RS GT
    <- rset-implies-rget RS RG
    <- rget-implies-gt RG GT.

%worlds (objvar) (rset-implies-gt _ _).
%total (G) (rset-implies-gt G _).


%theorem gt-implies-rset*:
	forall* {N} {V:vector N} {I} {X}
	forall	{GT: nat`gt N I}
	exists	{VP} {G: rset V I X VP}
	true.

%abbrev gt-implies-rset : (nat`gt N I) -> (rset V I X VP) -> type
	= [GT] [S] gt-implies-rset* GT _ S.

- : gt-implies-rset* gt/1 _ rset/N.

- : gt-implies-rset* (gt/> GT) _ (rset/+ S)
    <- gt-implies-rset* GT _ S.

%worlds (objvar) (gt-implies-rset* _ _ _).
%total (G) (gt-implies-rset* G _ _).


%theorem rset-deterministic:
	forall* {N} {V1: vector N} {I1} {X1} {V3}
		{V2: vector N} {I2} {X2} {V4}
	forall	{G1: rset V1 I1 X1 V3}
		{G2: rset V2 I2 X2 V4}
		{EV: eq V1 V2}
		{EN: nat`eq I1 I2}
		{ED: cxt-info`eq X1 X2}
	exists	{ER: eq V3 V4}
	true.

%abbrev rset-unique = rset-deterministic.

- : rset-deterministic rset/N rset/N _ _ cxt-info`eq/ eq/.

- : rset-deterministic rset/N (rset/+ RS) eq/ nat`eq/ cxt-info`eq/ EQ
    <- rset-implies-gt RS GT
    <- gt-anti-reflexive GT F
    <- false-implies-eq F EQ.

- : rset-deterministic (rset/+ RS) rset/N eq/ nat`eq/ cxt-info`eq/ EQ
    <- rset-implies-gt RS GT
    <- gt-anti-reflexive GT F
    <- false-implies-eq F EQ.

- : rset-deterministic (rset/+ G1) (rset/+ G2) eq/ nat`eq/ cxt-info`eq/ EQ
    <- rset-deterministic G1 G2 eq/ nat`eq/ cxt-info`eq/ EQP
    <- vector/+-preserves-eq cxt-info`eq/ EQP EQ.

%worlds (objvar) (rset-deterministic _ _ _ _ _ _).
%total (G) (rset-deterministic G _ _ _ _ _).


%theorem rset-idempotent:
	forall* {N} {V: vector N} {I} {X} {VP}
	forall	{S: rset V I X VP}
	exists	{S: rset VP I X VP}
	true.

- : rset-idempotent rset/N rset/N.

- : rset-idempotent (rset/+ S) (rset/+ SP)
    <- rset-idempotent S SP.

%worlds (objvar) (rset-idempotent _ _).
%total (S) (rset-idempotent S _).

	
%theorem rset-overwrites:
	forall* {N} {V: vector N} {I} {X1} {V1} {X2} {V2}
	forall	{S1: rset V I X1 V1}
		{S2: rset V1 I X2 V2}
	exists	{S12: rset V I X2 V2}
	true.

- : rset-overwrites rset/N rset/N rset/N.

- : rset-overwrites rset/N (rset/+ RS) RSP
    <- rset-implies-gt RS GT
    <- gt-anti-reflexive GT F
    <- false-implies-rset F RSP.

- : rset-overwrites (rset/+ RS) rset/N RSP
    <- rset-implies-gt RS GT
    <- gt-anti-reflexive GT F
    <- false-implies-rset F RSP.

- : rset-overwrites (rset/+ S1) (rset/+ S2) (rset/+ S12)
    <- rset-overwrites S1 S2 S12.

%worlds (objvar) (rset-overwrites _ _ _).
%total (S) (rset-overwrites S _ _).


%theorem rset-preserves-rget:
	forall*	{N} {V1:vector N} {I1} {X1} {I2} {X2} {V2}
	forall	{G: rget V1 I1 X1}
		{S: rset V1 I2 X2 V2}
		{N: nat`ne I1 I2}
	exists	{G: rget V2 I1 X1}
	true.

- : rset-preserves-rget rget/N rset/N N<>N G
    <- nat`eq-ne-implies-false nat`eq/ N<>N F
    <- false-implies-rget F G.

- : rset-preserves-rget rget/N (rset/+ S) _ rget/N.

- : rset-preserves-rget (rget/+ G) rset/N _ (rget/+ G).

- : rset-preserves-rget (rget/+ G) (rset/+ S) I1<>I2 (rget/+ GP)
    <- rset-preserves-rget G S I1<>I2 GP.

%worlds (objvar) (rset-preserves-rget _ _ _ _).
%total (G) (rset-preserves-rget G _ _ _).


%theorem rset-preserves-rget-converse:
	forall*	{N} {V1:vector N} {I1} {X1} {I2} {X2} {V2}
	forall	{G: rget V2 I1 X1}
		{S: rset V1 I2 X2 V2}
		{N: nat`ne I1 I2}
	exists	{G: rget V1 I1 X1}
	true.

- : rset-preserves-rget-converse rget/N rset/N N<>N G
    <- nat`eq-ne-implies-false nat`eq/ N<>N F
    <- false-implies-rget F G.

- : rset-preserves-rget-converse rget/N (rset/+ S) _ rget/N.

- : rset-preserves-rget-converse (rget/+ G) rset/N _ (rget/+ G).

- : rset-preserves-rget-converse (rget/+ G) (rset/+ S) I1<>I2 (rget/+ GP)
    <- rset-preserves-rget-converse G S I1<>I2 GP.

%worlds (objvar) (rset-preserves-rget-converse _ _ _ _).
%total (G) (rset-preserves-rget-converse G _ _ _).


%theorem vector/+-preserves-rset :
	forall*	{N} {V:vector N} {I} {X} {VP} {XP}
	forall	{RS: rset V I X VP}
	exists	{RSP: rset (vector/+ XP V) I X (vector/+ XP VP)}
	true.

- : vector/+-preserves-rset RS (rset/+ RS).

%worlds (objvar) (vector/+-preserves-rset _ _).
%total { } (vector/+-preserves-rset _ _).




%%% Exports

%abbrev cxt = vector.
%abbrev cxt/0 = vector/0.
%abbrev cxt/+ = vector/+.


%%% Additional Theorems

cxt`lookup-obj : cxt N -> object -> nat -> ty -> type.

cxt`lookup-obj/ : get B N (cxt-info/ O T)
                  -> cxt`lookup-obj B O N T.

%theorem cxt`lookup-obj-implies-lookup
  : forall* {K} {B:cxt K} {O} {N} {T}
    forall {BLO: cxt`lookup-obj B O N T}
    exists {BL: get B N (cxt-info/ O T)}
    true.

- : cxt`lookup-obj-implies-lookup (cxt`lookup-obj/ BL) BL.

%worlds (objvar) (cxt`lookup-obj-implies-lookup _ _).
%total { } (cxt`lookup-obj-implies-lookup _ _).

%abbrev cxt`cxt-info = cxt-info.
%abbrev cxt`cxt-info/ = cxt-info/.
%abbrev cxt`eq = eq.
%abbrev cxt`eq/ = eq/.
%abbrev cxt`false-implies-eq = false-implies-eq.
%abbrev cxt`meta-eq = meta-eq.
%abbrev cxt`eq-reflexive = eq-reflexive.
%abbrev cxt`eq-symmetric = eq-symmetric.
%abbrev cxt`eq-transitive = eq-transitive.
%abbrev cxt`cxt-info-preserves-eq = cxt-info-preserves-eq.
%abbrev cxt`cxt-info-eq-inversion = cxt-info-eq-inversion.
%abbrev cxt`vector = vector.
%abbrev cxt`vector/0 = vector/0.
%abbrev cxt`vector/+ = vector/+.
%abbrev cxt`eq = eq.
%abbrev cxt`eq/ = eq/.
%abbrev cxt`get = get.
%abbrev cxt`get/0 = get/0.
%abbrev cxt`get/+ = get/+.
%abbrev cxt`rget = rget.
%abbrev cxt`rget/N = rget/N.
%abbrev cxt`rget/+ = rget/+.
%abbrev cxt`set = set.
%abbrev cxt`set/0 = set/0.
%abbrev cxt`set/+ = set/+.
%abbrev cxt`rset = rset.
%abbrev cxt`rset/N = rset/N.
%abbrev cxt`rset/+ = rset/+.
%abbrev cxt`false-implies-eq = false-implies-eq.
%abbrev cxt`meta-eq = meta-eq.
%abbrev cxt`eq-reflexive = eq-reflexive.
%abbrev cxt`eq-symmetric = eq-symmetric.
%abbrev cxt`eq-transitive = eq-transitive.
%abbrev cxt`vector/+-eq-implies-eq = vector/+-eq-implies-eq.
%abbrev cxt`vector/+-preserves-eq = vector/+-preserves-eq.
%abbrev cxt`false-implies-get = false-implies-get.
%abbrev cxt`get-respects-eq = get-respects-eq.
%abbrev cxt`get-deterministic = get-deterministic.
%abbrev cxt`get-unique = get-unique.
%abbrev cxt`get-implies-gt = get-implies-gt.
%abbrev cxt`gt-implies-get* = gt-implies-get*.
%abbrev cxt`gt-implies-get = gt-implies-get.
%abbrev cxt`false-implies-rget = false-implies-rget.
%abbrev cxt`rget-respects-eq = rget-respects-eq.
%abbrev cxt`rget-implies-gt = rget-implies-gt.
%abbrev cxt`gt-implies-rget* = gt-implies-rget*.
%abbrev cxt`gt-implies-rget = gt-implies-rget.
%abbrev cxt`rget-deterministic = rget-deterministic.
%abbrev cxt`rget-unique = rget-unique.
%abbrev cxt`vector/+-preserves-rget = vector/+-preserves-rget.
%abbrev cxt`false-implies-set = false-implies-set.
%abbrev cxt`set-respects-eq = set-respects-eq.
%abbrev cxt`set-deterministic = set-deterministic.
%abbrev cxt`set-unique = set-unique.
%abbrev cxt`set-implies-gt = set-implies-gt.
%abbrev cxt`gt-implies-set* = gt-implies-set*.
%abbrev cxt`gt-implies-set = gt-implies-set.
%abbrev cxt`set-idempotent = set-idempotent.
%abbrev cxt`set-implies-get = set-implies-get.
%abbrev cxt`set-overwrites = set-overwrites.
%abbrev cxt`set-preserves-get = set-preserves-get.
%abbrev cxt`set-preserves-get-converse = set-preserves-get-converse.
%abbrev cxt`false-implies-rset = false-implies-rset.
%abbrev cxt`rset-respects-eq = rset-respects-eq.
%abbrev cxt`rset-implies-rget = rset-implies-rget.
%abbrev cxt`rset-implies-gt = rset-implies-gt.
%abbrev cxt`gt-implies-rset* = gt-implies-rset*.
%abbrev cxt`gt-implies-rset = gt-implies-rset.
%abbrev cxt`rset-deterministic = rset-deterministic.
%abbrev cxt`rset-unique = rset-unique.
%abbrev cxt`rset-idempotent = rset-idempotent.
%abbrev cxt`rset-overwrites = rset-overwrites.
%abbrev cxt`rset-preserves-rget = rset-preserves-rget.
%abbrev cxt`rset-preserves-rget-converse = rset-preserves-rget-converse.
%abbrev cxt`vector/+-preserves-rset = vector/+-preserves-rset.
%abbrev cxt`cxt = cxt.
%abbrev cxt`cxt/0 = cxt/0.
%abbrev cxt`cxt/+ = cxt/+.
