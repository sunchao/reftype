%%% Type Context
%%% $Id: cxt.elf,v 1.1 2013/03/04 21:24:37 csun Exp csun $

%%% definition

cxt : type.	%name cxt B.


%%% equality 

cxt`eq : cxt -> cxt -> type.
cxt`eq/ : cxt`eq B B.


%%% constructor

cxt/nil : cxt.
cxt/cons : object -> reftype -> cxt -> cxt.

%abbrev reftgts/1 : nat -> reftgts = [N] (reftgts/unique (set/1 N) tgtmap/0).

%{% wellformed context:
  1. in each reftype, if its unique, then it should only
     have a singleton set and empty tgtmap.
  2. the nat in each reftype/unique is in decreasing order,
     from outer context to inner context. %}%

cxt-wf : cxt -> type.

cxt-wf/nil : cxt-wf cxt/nil.

cxt-wf/cons/nil : cxt-wf (cxt/cons _ _ cxt/nil).

cxt-wf/cons/cons
  : cxt-wf (cxt/cons _ T1  (cxt/cons O T2 B))
    <- cxt-wf (cxt/cons O T2 B).
              


%%% lookup object

cxt-lookup : cxt -> object -> reftype -> type.

cxt-lookup/hit : cxt-lookup (cxt/cons O T B) O T.

cxt-lookup/miss
  : cxt-lookup (cxt/cons O _ B) O' T
    <- cxt-lookup B O' T.


%%% lookup location

cxt-lookup-index : cxt -> nat -> object -> ty -> type.

cxt-lookup-index/hit : cxt-lookup-index
    (cxt/cons O (reftype/ T (reftgts/1 N)) _) N O T.

cxt-lookup-index/miss/unique : cxt-lookup-index
    (cxt/cons _ (reftype/ _ (reftgts/1 M)) B) N O T
    <- cxt-lookup-index B N O T.

cxt-lookup-index/miss/shared : cxt-lookup-index
    (cxt/cons _ (reftype/ _ (reftgts/shared)) B) N O T
    <- cxt-lookup-index B N O T.


%%% theorems

%theorem false-implies-object-eq :
	forall* {O1:object} {O2}
	forall  {F:void}
	exists  {EQ: object`eq O1 O2}
	true.

%worlds (objvar) (false-implies-object-eq _ _).
%total  {} (false-implies-object-eq _ _).


%theorem false-implies-ty-eq :
	forall* {T1} {T2}
	forall  {F:void}
	exists  {EQ: ty`eq T1 T2}
	true.

%worlds (objvar) (false-implies-ty-eq _ _).
%total  {} (false-implies-ty-eq _ _).