%% Second part of proof

add-output : expr-output -> expr-output -> expr-output -> type.

add-output/expr : add-output (output/expr _ Pi) Out Out'
                  <- envadd Pi Out Out'.

add-output/exists : add-output (output/exists [x] (Out1 x)) Out2 (output/exists [x] (Out3 x))
                    <- ({x} add-output (Out1 x) Out2 (Out3 x)).


%theorem fake
  : forall* {Out} {PM} {B} {NN2} {C2} {XX} {Out2: object -> expr-output}
    forall {CM}
    exists {Out3} {Out4} {ADD: {x} add-output (Out x) (Out2 x) (Out3 x)}
    {Out3=>Out4: transform (output/exists [x] (Out3 x)) Out4}
    {XX-Out: effects2output CM PM B (reftype/ NN2 C2 unique-target) XX Out4}
    true.

%worlds (objvar) (fake _ _ _ _ _ _).
%trustme %total { } (fake _ _ _ _ _ _).


%{%
1: effects2output/simple
2: effects2output/0f
3: effects2output/+f
%}%

%theorem let-helper-after/11
  : forall* {CM} {PM} {B} {BP} {N} {XX} {XX2} {Out} {NN1} {C1} {Out2} {NN2} {C2}
    forall {BF: cxt`fresh B N}
    {BU: {x} cxt`update B N (cxt-info/ x (ty/ NN1 annot/borrow C1)) (BP x)}
    {FMT: let-output-format CM PM B N (reftype/ NN1 C1 unique-target) XX XX2 ([x] Out x)}
    {XX2=>Out2: {x} effects2output CM PM (BP x) (reftype/ NN2 C2 unique-target) XX2 (Out2 x)}
    exists {Out3} {Out4} {ADD: {x} add-output (Out x) (Out2 x) (Out3 x)}
    {Out3=>Out4: transform (output/exists [x] (Out3 x)) Out4}
    {XX-Out: effects2output CM PM B (reftype/ NN2 C2 unique-target) XX Out4}
    true.

- : let-helper-after/11 BF BU
    (let-output-format/simple/unique ([x] BU2 x) (T2PF:ty2perm PM _ PF)
      (M2|N=M2out+M2in:efxmap-partition-on-index M2 N M2out M2in)
      (M=>M1+M2out:efxmap-split M M1 M2out)
      ([x] M2in=>Pxf x)
      (M1=>Pi3:efxmap2perm CM PM B M1 Pi3))
    ([x] effects2output/simple (T2PF2F x)
      reftype2ty/unique simple-targets/unique
      (M2=>Pi2 x) (BP=>PiB x))
    %{=>}% _ _ ([_] add-output/expr (envadd/exists ([_] envadd/expr)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [v]
          (transform/trans
            (transform/implies
              (implies/trans5
                (implies/combine
                  (implies/reflexive)
                  (implies/combine
                    (implies/trans3
                      (implies/equiv (EQV x))
                      (implies/combine (IMP x) implies/reflexive)
                      (implies/equiv
                        (equiv/transitive
                          (equiv/commute)
                          (equiv/identity))))
                    (implies/combine
                      (implies/equiv (EQV2 x v))
                      (implies/equiv
                        (equiv/transitive
                          (Pi2<=>Pi2outF+Pi2in' x)
                          (equiv/combine (Pi2outF<=>Pi2out x) equiv/reflexive))))))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive % encumber
                  (implies/trans4 % Pi3
                    (implies/combine implies/reflexive (implies/equiv equiv/roll3))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/equiv (Pi3+Pi2out<=>Pi))
                      (implies/combine
                        (implies/reflexive) % PiB
                        (implies/equiv equiv/commute)))
                    (implies/equiv equiv/roll3)))
                (implies/equiv equiv/associate)
                (implies/combine implies/reflexive
                  (implies/equiv
                    (equiv/transitive
                      (equiv/roll2)
                      (equiv/combine equiv/reflexive equiv/commute))))))
            (transform/drop))))
      (transform/rem-unused))
    (effects2output/simple T2PF2 reftype2ty/unique simple-targets/unique M=>Pi B=>PiB)
    <- let-helper/L10 M2|N=M2out+M2in _ _ M2out^M2in M2out+M2in=M2
    <- ({x} efxmap`disjoint-join-implies-equiv M2out^M2in M2out+M2in=M2
         (M2=>Pi2 x) (Pi2outF x) (Pi2in' x) (M2out=>Pi2outF x) (M2in=>Pi2in' x)
         (Pi2<=>Pi2outF+Pi2in' x))
    <- let-helper/L4 M2|N=M2out+M2in _ M2in-N M2out=>O2out N!<O2out
    <- let-helper/L21-converse M2out=>O2out N!<O2out BF BU ([x] M2out=>Pi2outF x)
      Pi2out M2out=>Pi2out ([x] Pi2outF<=>Pi2out x)
    <- cxt2perm-fresh-update-no-var BF BU BP=>PiB _ _ B=>PiB T2PF3 EQV
    <- efxmap-split-implies-disjoint-join M=>M1+M2out M1^M2out M1+M2out=M
    <- efxmap`disjoint-join-implies-equiv-converse M1^M2out M1+M2out=M M1=>Pi3
      M2out=>Pi2out Pi M=>Pi Pi3+Pi2out<=>Pi
    <- borrow-permission-to-empty T2PF3 IMP
    <- ty2perm-no-var T2PF2F _ EQF T2PF2
    <- ({x}{v} permission`eq-implies-equiv (EQF x v) (EQV2 x v)).

%worlds (objvar) (let-helper-after/11 _ _ _ _ _ _ _ _ _).
%total { } (let-helper-after/11 _ _ _ _ _ _ _ _ _).


%theorem let-helper-after/21
  : forall* {CM} {PM} {B} {BP} {N} {XX} {XX2} {Out} {NN1} {C1} {Out2} {NN2} {C2} {OS} {GS}
    {OS1} {FS1} {K} {K1}
    forall {SZ-OS: set`size OS (s K)}
    {SZ-OS1: set`size OS1 (s K1)}
    {BF: cxt`fresh B N}
    {BU: {x} cxt`update B N (cxt-info/ x (ty/ NN1 annot/borrow C1)) (BP x)}
    {FMT: let-output-format CM PM B N (reftype/ NN1 C1 (targets/unique OS1 FS1)) XX XX2 ([x] Out x)}
    {XX2=>Out2: {x} effects2output CM PM (BP x)
                (reftype/ NN2 C2 (targets/unique OS set/0)) XX2 (Out2 x)}
    {SUB: subst-targets (targets/unique OS1 FS1) N unique-target GS}
    exists {Out3} {Out4} {ADD: {x} add-output (Out x) (Out2 x) (Out3 x)}
    {Out3=>Out4: transform (output/exists [x] (Out3 x)) Out4}
    {XX-Out: effects2output CM PM B (reftype/ NN2 C2 GS) XX Out4}
    true.

%theorem let-helper-after/11
  : forall* {CM} {PM} {B} {BP} {N} {XX} {XX2} {Out} {NN1} {C1} {Out2} {NN2} {C2}
    forall {BF: cxt`fresh B N}
    {BU: {x} cxt`update B N (cxt-info/ x (ty/ NN1 annot/borrow C1)) (BP x)}
    {FMT: let-output-format CM PM B N (reftype/ NN1 C1 unique-target) XX XX2 ([x] Out x)}
    {XX2=>Out2: {x} effects2output CM PM (BP x) (reftype/ NN2 C2 unique-target) XX2 (Out2 x)}
    exists {Out3} {Out4} {ADD: {x} add-output (Out x) (Out2 x) (Out3 x)}
    {Out3=>Out4: transform (output/exists [x] (Out3 x)) Out4}
    {XX-Out: effects2output CM PM B (reftype/ NN2 C2 unique-target) XX Out4}
    true.


- : let-helper-after/2 (s _) SZ-OS BF BU
    (let-output-format/simple/unique ([x] BU2 x) (T2PF:ty2perm PM _ PF)
      (M2|N=M2out+M2in:efxmap-partition-on-index M2 N M2out M2in)
      (M=>M1+M2out:efxmap-split M M1 M2out)
      ([x] M2in=>Pxf x)
      (M1=>Pi3:efxmap2perm CM PM B M1 Pi3))
    ([x] effects2output/unique/0f (T2PF2F x)
      (M2=>Pi2 x)
      ([r] OS=>GF r) (BP=>PiB x) SZ-FS SZ-OS')
    (subst-targets/unique/unique
      (subst-object-set/in (N!<OSP:set`not-member OSP N)
        (OSP+N=OS:set`add OSP N OS)  set`union/L)
      (subst-field-set/out select-to-substitute/0) set`union/L)
    %{=>}% _ _ ([_] add-output/expr (envadd/exists ([_] envadd/expr)))
    KKK
    (effects2output/unique/0f T2PF2
      (M=>Pi:efxmap2perm CM PM B M Pi) ([r] OSP=>GFP r) (B=>PiB) SZ-FS SZ-OSP)
    <- let-helper/L10 M2|N=M2out+M2in _ _ M2out^M2in M2out+M2in=M2
    <- ({x} efxmap`disjoint-join-implies-equiv M2out^M2in M2out+M2in=M2
         (M2=>Pi2 x) (Pi2outF x) (Pi2in' x) (M2out=>Pi2outF x) (M2in=>Pi2in' x)
         (Pi2<=>Pi2outF+Pi2in' x))
    <- let-helper/L4 M2|N=M2out+M2in _ M2in-N M2out=>O2out N!<O2out
    <- let-helper/L21-converse M2out=>O2out N!<O2out BF BU ([x] M2out=>Pi2outF x)
      Pi2out M2out=>Pi2out ([x] Pi2outF<=>Pi2out x)
    <- cxt2perm-fresh-update-no-var BF BU BP=>PiB _ _ B=>PiB T2PF3 EQV
    <- efxmap-split-implies-disjoint-join M=>M1+M2out M1^M2out M1+M2out=M
    <- efxmap`disjoint-join-implies-equiv-converse M1^M2out M1+M2out=M M1=>Pi3
      M2out=>Pi2out Pi M=>Pi Pi3+Pi2out<=>Pi
    <- borrow-permission-to-empty T2PF3 IMP
    <- ty2perm-no-var T2PF2F _ EQF T2PF2
    <- ({x}{v} permission`eq-implies-equiv (EQF x v) (EQV2 x v)).

%worlds (objvar) (let-helper-after/2 _ _ _ _ _ _ _ _ _).
%total { } (let-helper-after/2 _ _ _ _ _ _ _ _ _).


%theorem let-helper-after/2/L1
  : forall* {CM} {PM} {B} {OS} {OS'} {NN} {C} {Pi} {G} {N}
    forall {CM-B-OS: clsmap-cxt-unique-objset CM B NN C OS}
    {B=>PiB: cxt2perm CM PM B Pi}
    {OS=>G: {x} set2cond B x OS (G x)}
    {NM: set`not-member OS' N}
    {A: set`add OS' N OS}
    exists {G'} {OS'=>G': {x} set2cond B x OS' (G' x)}
    {IMP: {x} implies (Pi , (G x)) (Pi , (G' x))}
    true.

- : let-helper-after/2/L1 clsmap-cxt-unique-objset/0 B=>Pi
    ([x] OS=>G x) N!<OS' OS'+N=OS %{=>}% _ OS'=>G'
    ([x] implies/trans
      (implies/combine implies/reflexive (IMP1 x))
      (KK x))
    <- ({x} set2cond/U-inversion (OS=>G x) N!<OS' OS'+N=OS
         (G' x) (OS'=>G' x) _ _ (BL x) (IMP1 x) (IMP2 x)).


%theorem let-helper-after/2
  : forall* {CM} {PM} {B} {BP} {N} {XX} {XX2} {Out} {NN1} {C1} {Out2} {NN2} {C2} {OS} {GS}
    forall {K} {SZ-OS: set`size OS (s K)}
    {BF: cxt`fresh B N}
    {BU: {x} cxt`update B N (cxt-info/ x (ty/ NN1 annot/borrow C1)) (BP x)}
    {FMT: let-output-format CM PM B N (reftype/ NN1 C1 unique-target) XX XX2 ([x] Out x)}
    {XX2=>Out2: {x} effects2output CM PM (BP x)
                (reftype/ NN2 C2 (targets/unique OS set/0)) XX2 (Out2 x)}
    {SUB: subst-targets unique-target N (targets/unique OS set/0) GS}
    exists {Out3} {Out4} {ADD: {x} add-output (Out x) (Out2 x) (Out3 x)}
    {Out3=>Out4: transform (output/exists [x] (Out3 x)) Out4}
    {XX-Out: effects2output CM PM B (reftype/ NN2 C2 GS) XX Out4}
    true.

- : let-helper-after/2 (s _) SZ-OS BF BU
    (let-output-format/simple/unique ([x] BU2 x) (T2PF:ty2perm PM _ PF)
      (M2|N=M2out+M2in:efxmap-partition-on-index M2 N M2out M2in)
      (M=>M1+M2out:efxmap-split M M1 M2out)
      ([x] M2in=>Pxf x)
      (M1=>Pi3:efxmap2perm CM PM B M1 Pi3))
    ([x] effects2output/unique/0f (T2PF2F x)
      (M2=>Pi2 x)
      ([r] OS=>GF r) (BP=>PiB x) SZ-FS SZ-OS')
    (subst-targets/unique/unique
      (subst-object-set/in (N!<OSP:set`not-member OSP N)
        (OSP+N=OS:set`add OSP N OS)  set`union/L)
      (subst-field-set/out select-to-substitute/0) set`union/L)
    %{=>}% _ _ ([_] add-output/expr (envadd/exists ([_] envadd/expr)))
    KKK
    (effects2output/unique/0f T2PF2
      (M=>Pi:efxmap2perm CM PM B M Pi) ([r] OSP=>GFP r) (B=>PiB) SZ-FS SZ-OSP)
    <- let-helper/L10 M2|N=M2out+M2in _ _ M2out^M2in M2out+M2in=M2
    <- ({x} efxmap`disjoint-join-implies-equiv M2out^M2in M2out+M2in=M2
         (M2=>Pi2 x) (Pi2outF x) (Pi2in' x) (M2out=>Pi2outF x) (M2in=>Pi2in' x)
         (Pi2<=>Pi2outF+Pi2in' x))
    <- let-helper/L4 M2|N=M2out+M2in _ M2in-N M2out=>O2out N!<O2out
    <- let-helper/L21-converse M2out=>O2out N!<O2out BF BU ([x] M2out=>Pi2outF x)
      Pi2out M2out=>Pi2out ([x] Pi2outF<=>Pi2out x)
    <- cxt2perm-fresh-update-no-var BF BU BP=>PiB _ _ B=>PiB T2PF3 EQV
    <- efxmap-split-implies-disjoint-join M=>M1+M2out M1^M2out M1+M2out=M
    <- efxmap`disjoint-join-implies-equiv-converse M1^M2out M1+M2out=M M1=>Pi3
      M2out=>Pi2out Pi M=>Pi Pi3+Pi2out<=>Pi
    <- borrow-permission-to-empty T2PF3 IMP
    <- ty2perm-no-var T2PF2F _ EQF T2PF2
    <- ({x}{v} permission`eq-implies-equiv (EQF x v) (EQV2 x v)).

%worlds (objvar) (let-helper-after/2 _ _ _ _ _ _ _ _ _).
%total { } (let-helper-after/2 _ _ _ _ _ _ _ _ _).
