%%% Type judgments for conservative type system based on FP.


%%% Type Checking Rules

reftyping : clsmap -> methmap -> env -> term K -> result K -> type.

letRefTyping : clsmap -> methmap -> expr-result -> (object -> term K) -> result K -> type.

%{
TODO:
What if the minimum capability of M1 is not write? If the capability is read,
then it means you only cannot consume the object. Then, what the context and capmap
look like? We cannot make x unique anymore.

For unique G in "let x = G in ...", we take away capabilities for G, and add x
as a unique parameter in the environment. After x is out of the scope, those unique
capabilties should be returned to G, but this is a future work.
}%

letRefTyping/base/unique :
    clsmap`lookup CM C FM ->
    fldmap`domain FM FS ->
    set+set2capmap S FS cap/write M2 ->
    cxt-remove-unique B0 S B1 ->
    cxt`fresh B1 (s N) ->
    ({x} cxt`update B1 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B2 x)) ->
    capmap-split M0 M2 M4 ->
    nat+set2capmap (s N) FS cap/write M3 ->
    capmap-split M5 M3 M4 ->
    capmap-min M1 cap/write ->
    ({x} reftyping CM MM (env/ (B2 x) M5) (F x) (R x)) ->
  letRefTyping CM MM (result/expr (reftype/ NN C (targets/unique S M1)) (env/ B0 M0))
    F (result/exists [x] (R x)).

letRefTyping/base/shared :
    clsmap`lookup CM C _ ->
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
    ({x} reftyping CM MM (env/ (B1 x) M0) (F x) (R x)) ->
  letRefTyping CM MM (result/expr (reftype/ NN C targets/shared) (env/ B0 M0))
    F (result/exists [x] (R x)).

letRefTyping/exists :
    ({x} letRefTyping CM MM (V x) F (R x)) ->
  letRefTyping CM MM (result/exists [x] (V x)) F (result/exists [x] (R x)).



%%% Checking Literals

reftyping/lit :
    cxt`lookup-obj B O (s N) T ->
    ty2reftype (s N) T RT ->
  reftyping _ _ (env/ B M) (lit O) (result/expr RT (env/ B M)).


%%% Type Rules with Direct Effect

%%% Reading a field

targets-capmap : targets -> capmap -> type.

targets-capmap/shared : targets-capmap targets/shared _.

targets-capmap/unique :
   capmap`disjoint M1 M2 ->
  targets-capmap (targets/unique _ M1) M2.


reftyping-helper/read : clsmap -> expr-result -> nat -> expr-result -> type.

reftyping-helper/read/base :
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F (ty/ NN A FC) ->
    make-tgts-and-caps M0 G0 F cap/read G1 M1 ->
    consider-ftype G1 M1 A G2 M2 ->
    targets-capmap G0 M0 ->
  reftyping-helper/read CM (result/expr (reftype/ nn/yes C G0) (env/ B0 M0)) F
    (result/expr (reftype/ NN FC G2) (env/ B0 M2)).

reftyping-helper/read/exists :
    ({v} reftyping-helper/read CM (In v) F (Rslt v)) ->
  reftyping-helper/read CM (result/exists In) F (result/exists Rslt).

reftyping/read :
    reftyping CM MM V E Rslt ->
    reftyping-helper/read CM Rslt F Rslt2 ->
  reftyping CM MM V (read E F) Rslt2.


%%% Writing a field

reftyping-helper/write : clsmap -> methmap -> expr-result -> nat -> expr ->
    targets -> ty -> expr-result -> type.

reftyping-helper/write/base :
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F (ty/ NN A FC) ->
    make-tgts-and-caps M0 G0 F cap/write G1 M1 ->
    reftyping CM MM (env/ B0 M1) E (result/expr RT V2) ->
    subtype CM RT V2 (ty/ NN A FC) (env/ B2 M3) ->
    consider-ftype G1 M3 A G2 M4 ->
  reftyping-helper/write CM MM (result/expr (reftype/ nn/yes C G0) (env/ B0 M0))
    F E G1 (ty/ NN A FC) (result/expr (reftype/ NN FC G2) (env/ B2 M4)).

reftyping-helper/write/exists :
    ({v} reftyping-helper/write CM MM (In v) F E G T (Rslt v)) ->
  reftyping-helper/write CM MM (result/exists In) F E G T (result/exists Rslt).

reftyping/write
  : reftyping CM MM V1 E1 Rslt1 ->
    reftyping-helper/write CM MM Rslt1 F E2 G T Rslt2 ->
  reftyping CM MM V1 (write E1 F E2) Rslt2.


%%% Type Rules with Indirect Effects


%%% Let

%{
For let, we have two approaches
1. change the context to map to reftype, instead of ty. So, the variable x
is mapped to the reftype from checking E. But, whenever consume something,
we need to trace down to the "root" of each binding. This approach is a bit
complicated.

2. suppose x is bound to (reftype/unique S G), we remove field capabilities for
all objects in S. For instance, if S = {a, b}, and in M we have (a.f,W),
(a.g, R), (b.f, R), then as result, we remove these from M, and add (x.f, R) to it.
In other words, we compute the most conservative capabilities we can get for x.
During the life time of x, all objects in S are not allowed to use, until x is being
released out of scope.

Currently, we use the second approach, since it's easier to implement.
In the future, we can come back here and switch to the first approach.
}%


% %%% TODO: add substitution.

reftyping/let :
    reftyping CM MM B E Rslt ->
    letRefTyping CM MM Rslt F Rslt2 ->
  reftyping CM MM B (let E F) Rslt2.

%%% Method Calls

%{
Type checking arguments

One issue we need to consider is aliasing between unique arguments.
For instance, if a method is annotated as "reads a.f, writes b.f", and
a and b are aliases to each other, then we cannot check the call.

Given this situation doesn't occur very often, here we just simply
disallow "duplicated" cap while checking method call effects.
}%


reftyping/args : clsmap -> methmap -> env -> args -> args-result -> type.

reftyping/args/0 : reftyping/args _ _ V args/0 (result/args/0 V).

reftyping/args/+ :
    reftyping CM MM V1 E (result/expr RT V2) ->
    reftyping/args CM MM V2 A ARslt ->
  reftyping CM MM V (args/+ E A) (result/args/+ RT ARslt).


%%% Call Typing

%{
How to check method call:
1. Check arguments, given an input type context and capability set.
   For each argument, type checking will yield a corresponding
   result reftype, and produce a output capability set. After checking all
   arguments, we get a output (unchanged) type context, and a set of
   remaining capabilities.
2. Check method type using the result/args and remaining capability set.
   For each formal parameter, check it against the reftype generated from
   the corresponding actual parameter in step 1. During the process, some
   capabilities may be reclaimed (for instance, unique to borrowed).

Note that both step 1 and 2 may modify the context and capability set (step 1
will only weaken the condition, while step 2 will only strengthen the
condition).

To make the rule interesting, we should need to prove that capabilities can be
reclaimed after they are not needed after the method call checking. This is
also needed for checking tLet.
}%

callRefTyping : clsmap -> args-result -> methty -> expr-result -> type.

reftyping/call :
    clsmap`fresh CM M ->
    methmap`lookup MM M MT ->
    reftyping/args CM MM B V A ARslt ->
    callRefTyping CM AR MT Rslt ->
  reftyping CM MM V (call M A) Rslt.


%{
reftyping/const
  : clsmap`lookup CM C FM
    -> fldmap`domain FM S
    -> methmap`lookup MM C (methty/arg _ _ _ MT)
    -> reftyping/args CM MM B no-effect A AO
    -> callRefTyping CM no-effect AO MT (result/expr RT XX)
    -> reftyping CM MM B (call C (args/+ (alloc C S set/0) A)) (result/expr RT XX).
}%



%{
reftyping/if
  : reftyping CM MM B C (result/cond XXC)
    -> reftyping CM MM B E1 (result/expr RT XXE)
    -> reftyping CM MM B E2 (result/expr RT XXE)
    -> effects`join XXC XXE XX
    -> reftyping CM MM B (if C E1 E2) (result/expr RT XX).
}%


%{
no-consume-effect : effects -> type. % To be defined later

reftyping/while
  : reftyping CM MM B C (result/cond XX1)
    -> reftyping CM MM B E (result/expr _ XX2)
    -> no-consume-effect XX2
    -> effects`join XX1 XX2 XX
    -> reftyping CM MM B (while C E) (result/expr reftype/null XX).
}%


%%% Conditionals

% reftyping/eq : reftyping N CM MM B E1 (result/expr _ XX1)
%                -> reftyping N CM MM B E2 (result/expr _ XX2)
%                -> effects`join XX1 XX2 XX
%                -> reftyping N CM MM B (eql E1 E2) (result/cond XX).

% reftyping/not : reftyping N CM MM B (not C) R
%                 -> reftyping N CM MM B C R.

% reftyping/and : reftyping N CM MM B C1 (result/cond XX1)
%                 -> reftyping N CM MM B C2 (result/cond XX2)
%                 -> effects`join XX1 XX2 XX
%                 -> reftyping N CM MM B (and C1 C2) (result/cond XX).


%%% Arguments

% reftyping/args/0 : reftyping L _ _ _ args/0 result/args/0 L.

% reftyping/args/+
%   : reftyping L1 CM MM B E (result/expr RT XX) L2
%     -> reftyping L2 CM MM B A R L3
%     -> reftyping L1 CM MM B (args/+ E A) (result/args/+ (result/expr RT XX) R) L3.


%%% Method Typing

% Checking method type against func

% methtymatch* : efxmap -> set ->
% 	clsmap -> methmap -> cxt -> func -> methty -> type.

% if we have sub rule, then RT should match T,
% hence subtype will not be needed.

% methtymatch/base
%   : methtymatch* M S CM MM B (func/0 E) (methty/base T SX)
%     <- reftype2ty RT T
%     <- reftyping CM MM B E (result/expr RT (effects/ M SX)).

% methtymatch/args/unique
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/unique C) set/0 set/0 MT)
%     <- ({n} set`add S n (SF n))
%     <- ({n}{x}{_:object-index x n} methtymatch*
%          M (SF n) CM MM (cxt/cons x (ty/ N annot/unique C) B) (F x) MT).

% methtymatch/args/borrow
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/borrow C) Rs Ws MT)
%     <- ({n} nat+set2set n Rs (R n))
%     <- ({n} nat+set2set n Ws (W n))
%     <- ({n} set2efxmap (R n) efx/read (MR n))
%     <- ({n} set2efxmap (W n) efx/read (MW n))
%     <- ({n} efxmap`join (MR n) (MW n) (MF n))
%     <- ({n}{x}{_:object-index x n} methtymatch*
%          (MF n) S CM MM (cxt/cons x (ty/ NN annot/borrow C) B) (F x) MT).

% methtymatch/args/shared
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/shared C) set/0 set/0 MT)
%     <- ({x} methtymatch* M S CM MM (cxt/cons x (ty/ NN annot/shared C) B) (F x) MT).

% %abbrev methtymatch = [CM][MM][F][MT] methtymatch* efxmap/0 set/0 CM MM cxt/0 F MT.


% constyping* : effects -> clsmap -> methmap -> fldmap
%     -> cxt -> set -> (object -> expr) -> effects -> type.

% constyping/0 : constyping* XX _ _ _ _ set/0 ([t] lit t) XX.

% constyping/nn
%   : constyping* XX1 CM MM FM B S ([t] seq (write (lit t) F E) (EF t)) XX
%     <- fldmap`lookup FM F (ty/ nn/yes A C)
%     <- set`remove S (set/1 F) SP
%     <- reftype2ty RT (ty/ nn/yes A C)
%     <- reftyping CM MM B E (result/expr RT XX2)
%     <- effects`join XX1 XX2 XX12
%     <- constyping* XX12 CM MM FM B SP ([t] EF t) XX.

% constyping/mn
%   : constyping* XX1 CM MM FM B S ([t] seq (write (lit t) F E) (EF t)) XX
%     <- fldmap`lookup FM F (ty/ nn/may A C)
%     <- reftype2ty RT (ty/ nn/may A C)
%     <- reftyping CM MM B E (result/expr RT XX2)
%     <- effects`join XX1 XX2 XX12
%     <- constyping* XX12 CM MM FM B S ([t] EF t) XX.

% %abbrev constyping
%   = [CM][MM][FM][B][S][E][XX] constyping* no-effect CM MM FM B S E XX.


% the first set is accumulated consumed objects, the second set is all nonnull fields.

% constymatch*
%   : efxmap -> set -> clsmap -> methmap -> fldmap
%     -> cxt -> set -> (object -> func) -> methty -> type.

% constymatch/base
%   : constymatch* M S CM MM FM B FS ([t] func/0 (E t))
%     (methty/base (ty/ nn/yes annot/unique C) SX)
%     <- constyping CM MM FM B FS ([t] E t) (effects/ M SX).

% constymatch/args/unique
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/unique C) set/0 set/0 CT)
%     <- ({n} set`add S n (SF n))
%     <- ({n}{x}{_:object-index x n} constymatch* M (SF n)
%          CM MM FM (cxt/cons x (ty/ NN annot/unique C) B) FS ([t] (F t x)) CT).

% constymatch/args/borrow
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/borrow C) set/0 set/0 CT)
%     <- ({n} nat+set2set n Rs (R n))
%     <- ({n} nat+set2set n Ws (W n))
%     <- ({n} set2efxmap (R n) efx/read (MR n))
%     <- ({n} set2efxmap (W n) efx/read (MW n))
%     <- ({n} efxmap`join (MR n) (MW n) (MF n))
%     <- ({n}{x}{_:object-index x n} constymatch* (MF n) S CM MM FM
%          (cxt/cons x (ty/ NN annot/borrow C) B) FS ([t] (F t x)) CT).

% constymatch/args/shared
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/shared C) set/0 set/0 CT)
%     <- ({x} constymatch* M S CM MM FM
%          (cxt/cons x (ty/ NN annot/shared C) B) FS ([t] (F t x)) CT).

% %abbrev constymatch
%   = [CM][MM][FM][S][F][CT] constymatch* efxmap/0 set/0 CM MM FM cxt/0 S F CT.



%%% Program Typing: checking method map against prog


% select-fields : fldmap -> set -> type.

% select-fields/0 : select-fields fldmap/0 set`set/0.

% select-fields/+/in
%   : select-fields (fldmap/+ F (ty/ nn/yes _ _) M) S
%     <- fldmap`shift F M M'
%     <- select-fields M' S'
%     <- set`union S' (set/1 F) S.

% select-fields/+/result
%   : select-fields (fldmap/+ F (ty/ nn/may _ _) M) S
%     <- fldmap`shift F M M'
%     <- select-fields M' S.


% methmapmatch* : clsmap -> methmap -> methmap -> prog -> type.

% methmapmatch/0 : methmapmatch* _ _ methmap/0 prog`map/0.

% methmapmatch/+/const
%   : methmapmatch* CM MM0
%     (methmap/+ C (methty/arg (ty/ nn/yes _ C) _ CT) MM)
%     (prog`map/+ C (func/+ ([t] FF t)) M)
%     <- clsmap`lookup CM C FM
%     <- select-fields FM S
%     <- constymatch CM MM0 FM S FF CT
%     <- methmap`shift C MM MM'
%     <- prog`shift C M M'
%     <- methmapmatch* CM MM0 MM' M'.

% methmapmatch/+/meth
%   : methmapmatch* CM MM0
%     (methmap/+ N MT MM) (prog`map/+ N FUN M)
%     <- clsmap`fresh CM N
%     <- methtymatch CM MM0 FUN MT
%     <- methmap`shift N MM MM'
%     <- prog`shift N M M'
%     <- methmapmatch* CM MM0 MM' M'.

% %abbrev methmapmatch = [CM][MM][G] methmapmatch* CM MM MM G.


%%% Theorems

% %theorem result/expr-respects-eq
%   : forall* {RT1} {RT2} {X1} {X2}
%     forall {TE: reftype`eq RT1 RT2} {XE: effects`eq X1 X2}
%     exists {RE: result`eq (result/expr RT1 X1) (result/expr RT2 X2)}
%     true.

% - : result/expr-respects-eq reftype`eq/ effects`eq/ result`eq/.

% %worlds () (result/expr-respects-eq _ _ _).
% %total {} (result/expr-respects-eq _ _ _).


% %theorem reftyping-respects-eq
%   : forall* {N} {N'} {CM} {CM'} {MM} {MM'} {B} {B'} {E:expr} {E':expr} {R} {R'}
%     forall {RTYP: reftyping N CM MM B E R} {NE: nat`eq N N'}
%     {CME: clsmap`eq CM CM'} {MME: methmap`eq MM MM'}
%     {BE: cxt`eq B B'} {EE: expr`eq E E'} {RE: result`eq R R'}
%     exists {RTYP': reftyping N' CM' MM' B' E' R'}
%     true.

% - : reftyping-respects-eq RTYP nat`eq/ clsmap`eq/ methmap`eq/ cxt`eq/
%     expr`eq/ result`eq/ RTYP.

% %worlds () (reftyping-respects-eq _ _ _ _ _ _ _ _).
% %total {} (reftyping-respects-eq _ _ _ _ _ _ _ _).