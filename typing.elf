%%% Type judgments for conservative type system based on FP.

%%% Type Checking Result

result : kind -> type.

%abbrev expr-result = result exprk.

%abbrev cond-result = result condk.

%abbrev args-result = result argsk.


result/expr : reftype -> env -> expr-result.

result/cond : env -> cond-result.

result/args/0 : env -> args-result.

result/args/+ : reftype -> env -> args-result -> args-result.


%%% Equality

result`eq : result K -> result K -> type.

result`eq/ : result`eq R R.



%%% Type Checking Rules

reftyping : clsmap -> methmap -> cxt -> env -> term K -> result K -> type.


%%% ====================== Type Check Rules =======================

%%% Checking Literals

reftyping/lit :
    cxt`lookup-obj B O (s N) T ->
    ty2reftype (s N) T RT ->
  reftyping _ _ B V (lit O) (result/expr RT V).


%%% Type Rules with Direct Effect

%%% Reading a field

targets-capset : targets -> set -> type.

targets-capset/shared : targets-capset targets/shared _.

targets-capset/unique :
    set`disjoint M1 M2 ->
  targets-capset (targets/unique _ M1) M2.


readRefTyping : clsmap -> expr-result -> nat -> expr-result -> type.

readRefTyping/base :
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F (ty/ NN A FC) ->
    make-tgts-and-caps M0 G0 F G1 M1 ->
    consider-ftype G1 M1 A G2 M2 ->
    targets-capset G0 M0 ->
  readRefTyping CM (result/expr (reftype/ nn/yes C G0) (env/ U M0)) F
    (result/expr (reftype/ NN FC G2) (env/ U M2)).

reftyping/read :
    reftyping CM MM B V E R ->
    readRefTyping CM R F R2 ->
  reftyping CM MM B V (read E F) R2.


%%% Writing a field

writeRefTyping : clsmap -> methmap -> cxt -> expr-result -> nat -> expr ->
    targets -> ty -> expr-result -> type.

writeRefTyping/base :
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F (ty/ NN A FC) ->
    make-tgts-and-caps M0 G0 F G1 M1 ->
    reftyping CM MM B (env/ U0 M1) E (result/expr RT V2) ->
    subtype CM FS RT V2 (ty/ NN A FC) _ (env/ U1 M3) ->
    consider-ftype G1 M3 A G2 M4 ->
  writeRefTyping CM MM B (result/expr (reftype/ nn/yes C G0) (env/ U0 M0))
    F E G1 (ty/ NN A FC) (result/expr (reftype/ NN FC G2) (env/ U1 M4)).

reftyping/write
  : reftyping CM MM B V1 E1 R1 ->
    writeRefTyping CM MM B R1 F E2 G T R2 ->
  reftyping CM MM B V1 (write E1 F E2) R2.


%%% Type Rules with Indirect Effects


%%% Let

%{
For let, we have two approaches
1. change the context to map to reftype, instead of ty. So, the variable x
is mapped to the reftype from checking E. But, whenever consume something,
we need to trace down to the "root" of each binding. This approach is a bit
complicated.

2. suppose x is bound to (reftype/unique S G), we remove field capabilities for
all objects in S. For instance, if S = {a, b}, and in M we have (a.f,W),
(a.g, R), (b.f, R), then as result, we remove these from M, and add (x.f, R) to it.
In other words, we compute the most conservative capabilities we can get for x.
During the life time of x, all objects in S are not allowed to use, until x is being
released out of scope.

Currently, we use the second approach, since it's easier to implement.
In the future, we can come back here and switch to the first approach.
}%


%{
update-cxt : clsmap -> env -> ty -> (object -> env) -> type.

update-cxt/unique :
    clsmap`lookup CM C FM ->
    fldmap`domain FM FS ->
    nat+set2capmap (s N) FS cap/write M1 ->
    capmap-split M2 M1 M0 ->
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) ->
  update-cxt CM (env/ B0 M0) (ty/ NN annot/unique C) ([x] env/ (B1 x) M2).

update-cxt/shared :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
  update-cxt CM (env/ B0 M0) (ty/ NN annot/shared C) ([x] env/ (B1 x) M0).
}%

%%% Make sure the let variable is not in the result target (no leaking).

not-in-capset : nat -> set -> type.

not-in-capset/0 : not-in-capset _ set/0.

not-in-capset/U :
    not-in-capset N CS' ->
    nat2pair K (pair/ N' F) ->
    nat`ne N N' ->
    set`not-member CS' K ->
    set`add CS' K CS ->
  not-in-capset N CS.

not-in-targets : nat -> targets -> type.

not-in-targets/unique :
    set`not-member S N ->
    not-in-capset N M ->
  not-in-targets N (targets/unique S M).

not-in-targets/shared : not-in-targets _ targets/shared.


%%% Reclaim capabilities encumbered by the let variable.

%%% At the moment we just be conservative, and don't allow ANY field
%%% from the let variable be consumed.

letRefTyping : clsmap -> methmap -> cxt ->
    expr-result -> (object -> term K) -> result K -> type.

%%% M5 = M0 - M2 + M3
letRefTyping/base/unique :
    clsmap`lookup CM C FM ->
    fldmap`domain FM FS ->
    set+set2set S FS M2 ->
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) ->
    set`leq S U0 ->
    set`remove U0 S U1 ->
    set`add U1 (s N) U2 ->
    capset-split M0 M2 M4 ->
    nat+set2set (s N) FS M3 ->
    capset-split M5 M3 M4 ->
    ({x} reftyping CM MM (B1 x) (env/ U2 M5) (F x)
      (result/expr (reftype/ NN1 C1 G1) (env/ U3 M6))) ->
    not-in-targets (s N) G1 ->
    capset-split M6 M3 M7 -> % M3 still in result
    capset-split M8 M2 M7 ->
    capset-split M9 M1 M8 ->
    set`not-member U4 (s N) ->
    set`add U4 (s N) U3 ->
    set`union U4 S U5 ->
  letRefTyping CM MM B0 (result/expr (reftype/ NN C (targets/unique S M1)) (env/ U0 M0))
    F (result/expr (reftype/ NN1 C1 G1) (env/ U5 M9)).

letRefTyping/base/shared :
    clsmap`lookup CM C FM ->
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
    ({x} reftyping CM MM (B1 x) V (F x)
      (result/expr (reftype/ NN1 C1 G1) V1)) ->
    not-in-targets (s N) G1 ->
  letRefTyping CM MM B0 (result/expr (reftype/ NN C targets/shared) V)
    F (result/expr (reftype/ NN1 C1 G1) V1).

reftyping/let :
    reftyping CM MM B V E R1 ->
    letRefTyping CM MM B R1 F R2 ->
  reftyping CM MM B V (let E F) R2.


%%% Method Calls

%{
Type checking arguments

One issue we need to consider is aliasing between unique arguments.
For instance, if a method is annotated as "reads a.f, writes b.f", and
a and b are aliases to each other, then we cannot check the call.

Given this situation doesn't occur very often, and is also illegal in FP,
here we just simply disallow "duplicated" cap while checking method call effects.
}%

argsRefTyping : clsmap -> methmap -> cxt -> env -> args -> methty -> args-result -> type.

argsRefTyping/0 : argsRefTyping _ _ _ V args/0 (methty/base T) (result/args/0 V).

argsRefTyping/+ :
    reftyping CM MM B V0 E (result/expr RT V1) ->
    subtype CM FS RT V1 T V3 V2 ->
    argsRefTyping CM MM B V2 A MT AR ->
  argsRefTyping CM MM B V0 (args/+ E A) (methty/arg T FS MT) (result/args/+ RT V3 AR).


%{
How to check method call:
1. Check arguments, given an input type context and capability set.
   For each argument, type checking will yield a corresponding
   result reftype, and produce a output capability set. After checking all
   arguments, we get a output (unchanged) type context, and a set of
   remaining capabilities.
2. Check method type using the result/args and remaining capability set.
   For each formal argument, if it's unique, remove the associated capabilities
   from output capability set. Otherwise, we'll just return the same capabilities
   for the argument.

Note that both step 1 and 2 may modify the context and capability set (step 1
will only weaken the condition, while step 2 will only strengthen the
condition).

To make the rule interesting, we should need to prove that capabilities can be
reclaimed after they are not needed after the method call checking. This is
also needed for checking tLet.
}%

%%% Converting a ty to a reftype for a fresh new object.

ty2new-reftype : ty -> reftype -> type.

ty2new-reftype/unique :
    ty2new-reftype (ty/ NN annot/unique C) (reftype/ NN C (targets/unique set/0 set/0)).

ty2new-reftype/shared :
    ty2new-reftype (ty/ NN annot/shared C) (reftype/ NN C targets/shared).



callRefTyping* : clsmap -> methmap -> env -> args-result -> methty -> expr-result -> type.

callRefTyping/arg/0 :
    set`union U0 U1 U2 ->
    capset-split M2 M0 M1 ->
    ty2new-reftype T RT ->
  callRefTyping* CM MM (env/ U0 M0) (result/args/0 (env/ U1 M1)) (methty/base T)
      (result/expr RT (env/ U2 M2)).

callRefTyping/arg/+/unique :
    callRefTyping* CM MM V AR A R ->
  callRefTyping* CM MM V (result/args/+ _ _ AR)
      (methty/arg (ty/ _ annot/unique _) set/0 A) R.

callRefTyping/arg/+/borrow :
    set`union U0 U1 U2 ->
    capset-split M2 M0 M1 ->
    capset-split M4 M2 M3 ->
    callRefTyping* CM MM (env/ U2 M4) AR A R ->
  callRefTyping* CM MM (env/ U0 M0)
      (result/args/+ (reftype/ NN C (targets/unique S M1)) (env/ U1 M3) AR)
      (methty/arg (ty/ _ annot/borrow _) _ A) R.

callRefTyping/arg/+/shared :
    callRefTyping* CM MM V AR A R ->
  callRefTyping* CM MM V (result/args/+ _ empty-env AR)
      (methty/arg (ty/ _ annot/shared _) set/0 A) R.

%abbrev callRefTyping = [CM][MM][AR][A][R] callRefTyping* CM MM empty-env AR A R.


%{
reftyping/call :
    clsmap`fresh CM M ->
    methmap`lookup MM M MT ->
    argsRefTyping CM MM B V A MT AR ->
    callRefTyping CM MM AR MT R ->
  reftyping CM MM B V (call M A) R.
}%

%{
reftyping/const : clsmap`lookup CM C FM ->
    -> fldmap`domain FM S
    -> methmap`lookup MM C (methty/arg _ _ _ MT)
    -> reftyping/args CM MM B no-effect A AO
    -> callRefTyping CM no-effect AO MT (result/expr RT XX)
    -> reftyping CM MM B (call C (args/+ (alloc C S set/0) A)) (result/expr RT XX).
}%

%{
reftyping/if
  : reftyping CM MM B C (result/cond XXC)
    -> reftyping CM MM B E1 (result/expr RT XXE)
    -> reftyping CM MM B E2 (result/expr RT XXE)
    -> effects`join XXC XXE XX
    -> reftyping CM MM B (if C E1 E2) (result/expr RT XX).
}%


%{
no-consume-effect : effects -> type. % To be defined later

reftyping/while
  : reftyping CM MM B C (result/cond XX1)
    -> reftyping CM MM B E (result/expr _ XX2)
    -> no-consume-effect XX2
    -> effects`join XX1 XX2 XX
    -> reftyping CM MM B (while C E) (result/expr reftype/null XX).
}%


%%% Conditionals

% reftyping/eq : reftyping N CM MM B E1 (result/expr _ XX1)
%                -> reftyping N CM MM B E2 (result/expr _ XX2)
%                -> effects`join XX1 XX2 XX
%                -> reftyping N CM MM B (eql E1 E2) (result/cond XX).

% reftyping/not : reftyping N CM MM B (not C) R
%                 -> reftyping N CM MM B C R.

% reftyping/and : reftyping N CM MM B C1 (result/cond XX1)
%                 -> reftyping N CM MM B C2 (result/cond XX2)
%                 -> effects`join XX1 XX2 XX
%                 -> reftyping N CM MM B (and C1 C2) (result/cond XX).


%%% Method Typing

% Checking method type against func

% methtymatch* : efxmap -> set ->
% 	clsmap -> methmap -> cxt -> func -> methty -> type.

% if we have sub rule, then RT should match T,
% hence subtype will not be needed.

% methtymatch/base
%   : methtymatch* M S CM MM B (func/0 E) (methty/base T SX)
%     <- reftype2ty RT T
%     <- reftyping CM MM B E (result/expr RT (effects/ M SX)).

% methtymatch/args/unique
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/unique C) set/0 set/0 MT)
%     <- ({n} set`add S n (SF n))
%     <- ({n}{x}{_:object-index x n} methtymatch*
%          M (SF n) CM MM (cxt/cons x (ty/ N annot/unique C) B) (F x) MT).

% methtymatch/args/borrow
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/borrow C) Rs Ws MT)
%     <- ({n} nat+set2set n Rs (R n))
%     <- ({n} nat+set2set n Ws (W n))
%     <- ({n} set2efxmap (R n) efx/read (MR n))
%     <- ({n} set2efxmap (W n) efx/read (MW n))
%     <- ({n} efxmap`join (MR n) (MW n) (MF n))
%     <- ({n}{x}{_:object-index x n} methtymatch*
%          (MF n) S CM MM (cxt/cons x (ty/ NN annot/borrow C) B) (F x) MT).

% methtymatch/args/shared
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/shared C) set/0 set/0 MT)
%     <- ({x} methtymatch* M S CM MM (cxt/cons x (ty/ NN annot/shared C) B) (F x) MT).

% %abbrev methtymatch = [CM][MM][F][MT] methtymatch* efxmap/0 set/0 CM MM cxt/0 F MT.


% constyping* : effects -> clsmap -> methmap -> fldmap
%     -> cxt -> set -> (object -> expr) -> effects -> type.

% constyping/0 : constyping* XX _ _ _ _ set/0 ([t] lit t) XX.

% constyping/nn
%   : constyping* XX1 CM MM FM B S ([t] seq (write (lit t) F E) (EF t)) XX
%     <- fldmap`lookup FM F (ty/ nn/yes A C)
%     <- set`remove S (set/1 F) SP
%     <- reftype2ty RT (ty/ nn/yes A C)
%     <- reftyping CM MM B E (result/expr RT XX2)
%     <- effects`join XX1 XX2 XX12
%     <- constyping* XX12 CM MM FM B SP ([t] EF t) XX.

% constyping/mn
%   : constyping* XX1 CM MM FM B S ([t] seq (write (lit t) F E) (EF t)) XX
%     <- fldmap`lookup FM F (ty/ nn/may A C)
%     <- reftype2ty RT (ty/ nn/may A C)
%     <- reftyping CM MM B E (result/expr RT XX2)
%     <- effects`join XX1 XX2 XX12
%     <- constyping* XX12 CM MM FM B S ([t] EF t) XX.

% %abbrev constyping
%   = [CM][MM][FM][B][S][E][XX] constyping* no-effect CM MM FM B S E XX.


% the first set is accumulated consumed objects, the second set is all nonnull fields.

% constymatch*
%   : efxmap -> set -> clsmap -> methmap -> fldmap
%     -> cxt -> set -> (object -> func) -> methty -> type.

% constymatch/base
%   : constymatch* M S CM MM FM B FS ([t] func/0 (E t))
%     (methty/base (ty/ nn/yes annot/unique C) SX)
%     <- constyping CM MM FM B FS ([t] E t) (effects/ M SX).

% constymatch/args/unique
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/unique C) set/0 set/0 CT)
%     <- ({n} set`add S n (SF n))
%     <- ({n}{x}{_:object-index x n} constymatch* M (SF n)
%          CM MM FM (cxt/cons x (ty/ NN annot/unique C) B) FS ([t] (F t x)) CT).

% constymatch/args/borrow
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/borrow C) set/0 set/0 CT)
%     <- ({n} nat+set2set n Rs (R n))
%     <- ({n} nat+set2set n Ws (W n))
%     <- ({n} set2efxmap (R n) efx/read (MR n))
%     <- ({n} set2efxmap (W n) efx/read (MW n))
%     <- ({n} efxmap`join (MR n) (MW n) (MF n))
%     <- ({n}{x}{_:object-index x n} constymatch* (MF n) S CM MM FM
%          (cxt/cons x (ty/ NN annot/borrow C) B) FS ([t] (F t x)) CT).

% constymatch/args/shared
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/shared C) set/0 set/0 CT)
%     <- ({x} constymatch* M S CM MM FM
%          (cxt/cons x (ty/ NN annot/shared C) B) FS ([t] (F t x)) CT).

% %abbrev constymatch
%   = [CM][MM][FM][S][F][CT] constymatch* efxmap/0 set/0 CM MM FM cxt/0 S F CT.



%%% Program Typing: checking method map against prog


% select-fields : fldmap -> set -> type.

% select-fields/0 : select-fields fldmap/0 set`set/0.

% select-fields/+/in
%   : select-fields (fldmap/+ F (ty/ nn/yes _ _) M) S
%     <- fldmap`shift F M M'
%     <- select-fields M' S'
%     <- set`union S' (set/1 F) S.

% select-fields/+/result
%   : select-fields (fldmap/+ F (ty/ nn/may _ _) M) S
%     <- fldmap`shift F M M'
%     <- select-fields M' S.


% methmapmatch* : clsmap -> methmap -> methmap -> prog -> type.

% methmapmatch/0 : methmapmatch* _ _ methmap/0 prog`map/0.

% methmapmatch/+/const
%   : methmapmatch* CM MM0
%     (methmap/+ C (methty/arg (ty/ nn/yes _ C) _ CT) MM)
%     (prog`map/+ C (func/+ ([t] FF t)) M)
%     <- clsmap`lookup CM C FM
%     <- select-fields FM S
%     <- constymatch CM MM0 FM S FF CT
%     <- methmap`shift C MM MM'
%     <- prog`shift C M M'
%     <- methmapmatch* CM MM0 MM' M'.

% methmapmatch/+/meth
%   : methmapmatch* CM MM0
%     (methmap/+ N MT MM) (prog`map/+ N FUN M)
%     <- clsmap`fresh CM N
%     <- methtymatch CM MM0 FUN MT
%     <- methmap`shift N MM MM'
%     <- prog`shift N M M'
%     <- methmapmatch* CM MM0 MM' M'.

% %abbrev methmapmatch = [CM][MM][G] methmapmatch* CM MM MM G.


%%% Theorems

% %theorem result/expr-respects-eq
%   : forall* {RT1} {RT2} {X1} {X2}
%     forall {TE: reftype`eq RT1 RT2} {XE: effects`eq X1 X2}
%     exists {RE: result`eq (result/expr RT1 X1) (result/expr RT2 X2)}
%     true.

% - : result/expr-respects-eq reftype`eq/ effects`eq/ result`eq/.

% %worlds () (result/expr-respects-eq _ _ _).
% %total {} (result/expr-respects-eq _ _ _).


% %theorem reftyping-respects-eq
%   : forall* {N} {N'} {CM} {CM'} {MM} {MM'} {B} {B'} {E:expr} {E':expr} {R} {R'}
%     forall {RTYP: reftyping N CM MM B E R} {NE: nat`eq N N'}
%     {CME: clsmap`eq CM CM'} {MME: methmap`eq MM MM'}
%     {BE: cxt`eq B B'} {EE: expr`eq E E'} {RE: result`eq R R'}
%     exists {RTYP': reftyping N' CM' MM' B' E' R'}
%     true.

% - : reftyping-respects-eq RTYP nat`eq/ clsmap`eq/ methmap`eq/ cxt`eq/
%     expr`eq/ result`eq/ RTYP.

% %worlds () (reftyping-respects-eq _ _ _ _ _ _ _ _).
% %total {} (reftyping-respects-eq _ _ _ _ _ _ _ _).