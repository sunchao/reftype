%%% Type judgments for conservative type system based on FP.


% ===============================================
% =============== Abbreviations =================
% ===============================================

null : object = (object/ z).	% null object

utgt : nat -> targets = [n] (targets/unique (set/1 n) tgtmap/0 false).


% ===============================================
% ========== Output for Type Checking ===========
% ===============================================

out : kind -> type.

%abbrev expr-out = out exprk.

%abbrev cond-out = out condk.

%abbrev args-out = out argsk.


out/expr : reftype -> effects -> expr-out.

out/cond : effects -> cond-out.

out/args/0 : effects -> args-out.

out/args/+ : reftype -> args-out -> args-out.


% ===============================================
% === Index for object (simulate location) ======
% ===============================================

object-index : object -> nat -> type.

object-index/ : object-index (object/ N) N.


% ===============================================
% ======== Convert a "ty" to a "reftype" ========
% ===============================================

ty2reftype : nat -> ty -> reftype -> type.

ty2reftype/shared
  : ty2reftype L (ty/ NN annot/shared C) (reftype/ NN C targets/shared).

ty2reftype/borrow
  : ty2reftype L (ty/ NN annot/borrow C)
    (reftype/ NN C (targets/unique (set/1 L) tgtmap/0 false)).


% ===============================================
% ============ Typing Judgments =================
% ===============================================

reftyping : clsmap -> methmap -> cxt -> term K -> out K -> type.


% ================== Type Checking Arguments ==========================
% One issue we need to consider is aliasing between unique arguments.
% For instance, if a method is annotated as "reads a.f, writes b.f", and
% a and b are aliases to each other, then we cannot check the call.
%
% Given this situation doesn't occur very often, here we just simply
% disallow "duplicated" effects while checking method call effects.
% ======================================================================

reftyping/args
  : clsmap -> methmap -> cxt -> effects -> args -> args-out -> type.

reftyping/args/0 : reftyping/args _ _ _ XX args/0 (out/args/0 XX).

reftyping/args/+
  : reftyping CM MM B E (out/expr RT XX2)
    -> effects`join XX1 XX2 XX
    -> reftyping/args CM MM B XX A AO
    -> reftyping/args CM MM B XX1 (args/+ E A) (out/args/+ RT AO).

% =======================================================================



% ============================== Calltyping ================================

ref-calltyping : clsmap -> effects -> args-out
  -> methty -> expr-out -> type.

ref-calltyping/call/unique
  : effects`disjoint XX1 (effects/ efxmap/0 MX)
    -> effects`join XX0 XX1 XX01
    -> effects`join XX01 (effects/ efxmap/0 MX) XX
    -> ref-calltyping CM XX1 (out/args/0 XX0)
      (methty/base (ty/ NN annot/unique C) MX)
      (out/expr (reftype/ NN C (targets/unique set/0 tgtmap/0 false)) XX).

ref-calltyping/call/shared
  : effects`disjoint XX1 (effects/ efxmap/0 MX)
    -> effects`join XX0 XX1 XX01
    -> effects`join XX01 (effects/ efxmap/0 MX) XX
    -> ref-calltyping CM XX1 (out/args/0 XX0)
      (methty/base (ty/ NN annot/shared C) MX)
      (out/expr (reftype/ NN C targets/shared) XX).

ref-calltyping/args
  : subtype CM RT T RS WS XX1
    -> effects`disjoint XX0 XX1
    -> effects`join XX0 XX1 XX01
    -> ref-calltyping CM XX01 AO MT (out/expr ART XX)
    -> ref-calltyping CM XX0 (out/args/+ RT AO)
      (methty/arg T RS WS MT) (out/expr ART XX).

% ============================================================================


% ======================= checking literal ======================

reftyping/lit
  : reftyping _ _ B (lit O) (out/expr RT no-effect)
    <- cxt`lookup B O T
    <- object-index O N
    <- ty2reftype N T RT.

%{
reftyping/null
  : reftyping _ _ _ (lit null) (out/expr reftype/null no-effect).
}%

% ================ end of checking literal =======================


% ==================== consider-ftype ===============================
% Consider field annotation, and returns either the input unique
% targets, or a shared targets. (no borrowed targets since field
% cannot be borrowed).
% ===================================================================

consider-ftype : targets -> annot -> targets -> type.

consider-ftype/shared : consider-ftype _ annot/shared targets/shared.

consider-ftype/unique : consider-ftype GS annot/unique GS.

% ====================== end of consider-ftype ======================


% ===================== make-targets-and-effects =====================
% Given input targets for field reference receiver,
% field annotation, field ID, and effects, compute the result
% targets and effects.
% ====================================================================

make-targets-and-effects
  : targets -> annot -> nat -> efx -> targets -> effects -> type.

make-targets-and-effects/shared
  : consider-ftype (targets/unique set/0 tgtmap/0 true) A GS
    -> make-targets-and-effects targets/shared A _ X GS (shared-effect X).

make-targets-and-effects/unique
  : set+nat2tgtmap S F GM2
    -> tgtmap`deep-disjoint GM1 GM2
    -> tgtmap`join GM1 GM2 GM
    -> tgtmap2efxmap GM X XM
    -> efx-on-shared SB (maybe-efx/just X) MX
    -> consider-ftype (targets/unique set/0 GM SB) A GS
    -> make-targets-and-effects
      (targets/unique S GM1 SB) A F X GS (effects/ XM MX).

% ==================== end of make-targets-and-effects ================


% ========================= Reading Field ================================

reftyping/read
  : reftyping CM MM B E (out/expr (reftype/ nn/yes C GS) XX1)
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN A FC)
    -> make-targets-and-effects GS A F efx/read GSP XX2
    -> effects`join XX1 XX2 XX
    -> reftyping CM MM B (read E F) (out/expr (reftype/ NN FC GSP) XX).

% ====================== end of Reading Field ============================


% ========================= Write Field =====================================

reftyping/write
  : reftyping CM MM B E1 (out/expr (reftype/ nn/yes C GS) XX1)
    -> reftyping CM MM B E2 (out/expr RT XX2)
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN A FC)
    -> subtype CM RT (ty/ NN A FC) set/0 set/0 XX3
    -> make-targets-and-effects GS A F efx/write GSP XX4
    -> effects`join XX1 XX2 XX5
    -> effects`join XX5 XX3 XX6
    -> effects`join XX6 XX4 XX7
    -> reftyping CM MM B (write E1 F E2) (out/expr (reftype/ NN FC GSP) XX7).

% ======================== end of Write Field ================================


% ======================= reftyping/let =================================
% Note:
% 06-16-13: any possibility to simplify this?
% =======================================================================

% reftyping/let/unique
%   : reftyping CM MM B E
%     (out/expr (reftype/ NN C (targets/unique S GM SB)) XX1)
%     -> ({n}{x}{_:object-index x n}
%          reftyping CM MM (cxt/cons x (ty/ NN annot/unique C) B) (F x)
%          (out/expr (reftype/ NN2 C2 (GS2 n)) (XX2 n)))
%     -> ({n} subst-targets GS n (GS2 n) GS3)
%     -> ({n} subst-effects GS n (XX2 n) XX3)
%     -> effects`join XX1 XX3 XX
%     -> reftyping CM MM B (let E F) (out/expr (reftype/ NN2 C2 GS3) XX).

% ========================== end of reftyping/let ========================


% ======================== reftyping/if ==========================
% Note:
% 06-16-13: needs reftyping/sub to check this
% ================================================================

%{
reftyping/if
  : reftyping CM MM B C (out/cond XXC)
    -> reftyping CM MM B E1 (out/expr RT XXE)
    -> reftyping CM MM B E2 (out/expr RT XXE)
    -> effects`join XXC XXE XX
    -> reftyping CM MM B (if C E1 E2) (out/expr RT XX).
}%

% ===================== end of reftyping/if ======================


% ======================= reftyping/while ========================

%{
no-consume-effect : effects -> type. % To be defined later

reftyping/while
  : reftyping CM MM B C (out/cond XX1)
    -> reftyping CM MM B E (out/expr _ XX2)
    -> no-consume-effect XX2
    -> effects`join XX1 XX2 XX
    -> reftyping CM MM B (while C E) (out/expr reftype/null XX).
}%

% ===================== end of reftyping/while ===================


% ==================== Conditionals ===========================

reftyping/eq : reftyping CM MM B E1 (out/expr _ XX1)
               -> reftyping CM MM B E2 (out/expr _ XX2)
               -> effects`join XX1 XX2 XX
               -> reftyping CM MM B (eql E1 E2) (out/cond XX).

reftyping/not : reftyping CM MM B (not C) R
                -> reftyping CM MM B C R.

reftyping/and : reftyping CM MM B C1 (out/cond XX1)
                -> reftyping CM MM B C2 (out/cond XX2)
                -> effects`join XX1 XX2 XX
                -> reftyping CM MM B (and C1 C2) (out/cond XX).

% ==================== end of Conditionals =====================



%%% Arguments

% reftyping/args/0 : reftyping L _ _ _ args/0 out/args/0 L.

% reftyping/args/+
%   : reftyping L1 CM MM B E (out/expr RT XX) L2
%     -> reftyping L2 CM MM B A R L3
%     -> reftyping L1 CM MM B (args/+ E A) (out/args/+ (out/expr RT XX) R) L3.


% ======================== reftyping/call ==============================

%{
reftyping/call
  : clsmap`fresh CM M
    -> methmap`lookup MM M MT
    -> reftyping/args CM MM B no-effect A AR
    -> ref-calltyping CM no-effect AR MT R
    -> reftyping CM MM B (call M A) R.
}%

% ====================== end of reftyping/call =========================


% ========================= reftyping/const ============================

%{
reftyping/const
  : clsmap`lookup CM C FM
    -> fldmap`domain FM S
    -> methmap`lookup MM C (methty/arg _ _ _ MT)
    -> reftyping/args CM MM B no-effect A AO
    -> ref-calltyping CM no-effect AO MT (out/expr RT XX)
    -> reftyping CM MM B (call C (args/+ (alloc C S set/0) A)) (out/expr RT XX).
}%

% ======================= end of reftyping/const =======================



% ============================ Method Typing =============================
% Checking method type against func
% ========================================================================

methtymatch* : efxmap -> clsmap -> methmap -> cxt -> func -> methty -> type.

methtymatch/base
  : reftyping CM MM B E (out/expr RT XX1)
    -> subtype CM RT T set/0 set/0 XX2
    -> effects`join XX1 XX2 XX12
    -> effects`leq XX12 (effects/ XM MX)
    -> methtymatch* XM CM MM B (func/0 E) (methty/base T MX).

methtymatch/args/unique
  : clsmap`lookup CM C FM
    -> fldmap`domain FM S
    -> set2inner-efxmap S efx/consume M
    -> ({n} efxmap`join XM1 (efxmap/+ n M efxmap/0) (XM n))
    -> ({n}{x}{_:object-index x n} methtymatch*
         (XM n) CM MM (cxt/cons x (ty/ NN annot/unique C) B) (F x) MT)
    -> methtymatch* XM1 CM MM B (func/+ F)
      (methty/arg (ty/ NN annot/unique C) set/0 set/0 MT).

methtymatch/args/borrow
  : set2inner-efxmap RS efx/read Mr
    -> set2inner-efxmap WS efx/write Mw
    -> inner-efxmap`join Mr Mw Mrw
    -> ({n} efxmap`join XM1 (efxmap/+ n Mrw efxmap/0) (XM n))
    -> ({n}{x}{_:object-index x n} methtymatch*
         (XM n) CM MM (cxt/cons x (ty/ NN annot/borrow C) B) (F x) MT)
    -> methtymatch* XM1 CM MM B (func/+ F)
      (methty/arg (ty/ NN annot/borrow C) RS WS MT).

methtymatch/args/shared
  : ({x} methtymatch* XM CM MM (cxt/cons x (ty/ NN annot/shared C) B) (F x) MT)
    -> methtymatch* XM1 CM MM B (func/+ F)
      (methty/arg (ty/ NN annot/borrow C) RS WS MT).

%abbrev methtymatch = [CM][MM][F][MT] methtymatch* efxmap/0 CM MM cxt/nil F MT.


constyping : effects -> clsmap -> methmap -> fldmap
  -> cxt -> set -> (object -> expr) -> effects -> type.

constyping/0 : constyping XX _ _ _ _ set/0 ([t] lit t) XX.

constyping/nn
  : fldmap`lookup FM F (ty/ nn/yes A C)
    -> set`remove S (set/1 F) SP
    -> reftyping CM MM B E (out/expr RT XX1)
    -> subtype CM RT (ty/ nn/yes A C) set/0 set/0 XX2
    -> effects`join XX1 XX2 XX12
    -> effects`join XXin XX12 XXin2
    -> constyping XXin2 CM MM FM B SP ([t] EF t) XXout
    -> constyping XXin CM MM FM B S
      ([t] seq (write (lit t) F E) (EF t)) XXout.

constyping/mn
  : fldmap`lookup FM F (ty/ nn/yes A C)
    -> reftyping CM MM B E (out/expr RT XX1)
    -> subtype CM RT (ty/ nn/may A C) set/0 set/0 XX2
    -> effects`join XX1 XX2 XX12
    -> effects`join XXin XX12 XXin2
    -> constyping XXin2 CM MM FM B S ([t] EF t) XXout
    -> constyping XXin CM MM FM B S
      ([t] seq (write (lit t) F E) (EF t)) XXout.

constymatch*
  : efxmap -> clsmap -> methmap -> fldmap -> cxt
    -> set -> (object -> func) -> methty -> type.

constymatch/base
  : clsmap`lookup CM C FM
    -> constyping no-effect CM MM FM B S ([t] E t) XXactual
    -> effects`leq XXactual (effects/ XM MX)
    -> constymatch* XM CM MM FM B S ([t] func/0 (E t))
      (methty/base (ty/ nn/yes annot/unique C) MX).

constymatch/args/unique
  : clsmap`lookup CM C FM1
    -> fldmap`domain FM1 S1
    -> set2inner-efxmap S1 efx/consume M
    -> ({n} efxmap`join XM1 (efxmap/+ n M efxmap/0) (XM n))
    -> ({n}{x}{_:object-index x n}
         constymatch* (XM n) CM MM FM (cxt/cons x (ty/ NN annot/unique C) B)
         S ([t] (F t x)) CT)
    -> constymatch* XM1 CM MM FM B S ([t] (func/+ ([o] F t o)))
      (methty/arg (ty/ NN annot/unique C) set/0 set/0 CT).

constymatch/args/borrow
  : set2inner-efxmap RS efx/read Mr
    -> set2inner-efxmap WS efx/write Mw
    -> inner-efxmap`join Mr Mw Mrw
    -> ({n} efxmap`join XM1 (efxmap/+ n Mrw efxmap/0) (XM n))
    -> ({n}{x}{_:object-index x n}
         constymatch* (XM n) CM MM FM (cxt/cons x (ty/ NN annot/borrow C) B)
         S ([t] (F t x)) CT)
    -> constymatch* XM1 CM MM FM B S ([t] (func/+ ([o] F t o)))
      (methty/arg (ty/ NN annot/borrow C) set/0 set/0 CT).

constymatch/args/shared
  : ({x} constymatch* XM CM MM FM
      (cxt/cons x (ty/ NN annot/shared C) B) S ([t] (F t x)) CT)
    -> constymatch* XM CM MM FM B S ([t] (func/+ ([o] F t o)))
      (methty/arg (ty/ NN annot/shared C) set/0 set/0 CT).

%abbrev constymatch
  = [CM][MM][FM][S][F][CT] constymatch* efxmap/0 CM MM FM cxt/nil S F CT.

% ======================== end of Method Typing ============================


% ======================= Program Typing =================================
% Checking method map against prog
% ========================================================================

select-fields : fldmap -> set -> type.

select-fields/0 : select-fields fldmap/0 set`set/0.

select-fields/+/in
  : select-fields (fldmap/+ F (ty/ nn/yes _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S'
    <- set`union S' (set/1 F) S.

select-fields/+/out
  : select-fields (fldmap/+ F (ty/ nn/may _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S.


methmapmatch* : clsmap -> methmap -> methmap -> prog -> type.

methmapmatch/0 : methmapmatch* _ _ methmap/0 prog`map/0.

methmapmatch/+/const
  : methmapmatch* CM MM0
    (methmap/+ C (methty/arg (ty/ nn/yes _ C) _ _ CT) MM)
    (prog`map/+ C (func/+ ([t] FF t)) XM)
    <- clsmap`lookup CM C FM
    <- select-fields FM S
    <- constymatch CM MM0 FM S FF CT
    <- methmap`shift C MM MM'
    <- prog`shift C XM XM'
    <- methmapmatch* CM MM0 MM' XM'.

methmapmatch/+/meth
  : methmapmatch* CM MM0
    (methmap/+ N MT MM) (prog`map/+ N FUN XM)
    <- clsmap`fresh CM N
    <- methtymatch CM MM0 FUN MT
    <- methmap`shift N MM MM'
    <- prog`shift N XM XM'
    <- methmapmatch* CM MM0 MM' XM'.

%abbrev methmapmatch = [CM][MM][G] methmapmatch* CM MM MM G.

% ===================== end of Program Typing =============================