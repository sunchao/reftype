%%% Type judgments for conservative type system based on FP.


% =========================================================================
% =============== Abbreviations ===========================================
% =========================================================================

null : object = (object/ z).	% null object


% ========== Output for Type Checking =====================================
% =========================================================================

result : kind -> type.

%abbrev expr-result = result exprk.

%abbrev cond-result = result condk.

%abbrev args-result = result argsk.


result/expr : reftype -> effects -> expr-result.

result/cond : effects -> cond-result.

result/args/0 : effects -> args-result.

result/args/+ : reftype -> args-result -> args-result.


% =================== Index for object (simulate location) ================
% =========================================================================

object-index : object -> nat -> type.

object-index/ : object-index (object/ N) N.


% ============ Convert between a "ty" and a "reftype" =====================
% =========================================================================

ty2reftype : nat -> ty -> reftype -> type.

ty2reftype/shared
  : ty2reftype L (ty/ NN annot/shared C) (reftype/ NN C targets/shared).

ty2reftype/borrow
  : ty2reftype L (ty/ NN annot/borrow C)
    (reftype/ NN C (targets/unique (set/1 L) tgtmap/0 false)).

reftype2ty : reftype -> ty -> type.

reftype2ty/shared : reftype2ty (reftype/ NN C targets/shared)
                    (ty/ NN annot/shared C).

reftype2ty/unique : reftype2ty (reftype/ NN C (targets/unique _ _ _))
                    (ty/ NN annot/unique C).


% ======================= Typing Judgments ================================
% =========================================================================

reftyping : clsmap -> methmap -> cxt -> term K -> result K -> type.


% ================== Type Checking Arguments ==============================
% One issue we need to consider is aliasing between unique arguments.
% For instance, if a method is annotated as "reads a.f, writes b.f", and
% a and b are aliases to each other, then we cannot check the call.
%
% Given this situation doesn't occur very often, here we just simply
% disallow "duplicated" effects while checking method call effects.
% =========================================================================

reftyping/args : clsmap -> methmap -> cxt -> effects -> args -> args-result -> type.

reftyping/args/0 : reftyping/args _ _ _ XX args/0 (result/args/0 XX).

reftyping/args/+
  : reftyping/args CM MM B XX1 (args/+ E A) (result/args/+ RT AO)
    <- effects`join XX1 XX2 XX
    <- reftyping CM MM B E (result/expr RT XX2)
    <- reftyping/args CM MM B XX A AO.

% =========================================================================


% ============================== Calltyping ===============================

ref-calltyping : clsmap -> effects -> args-result -> methty -> expr-result -> type.

ref-calltyping/call/unique
  : ref-calltyping CM XX1 (result/args/0 XX0)
    (methty/base (ty/ NN annot/unique C) SX)
    (result/expr (reftype/ NN C (targets/unique set/0 tgtmap/0 false)) XX)
    <- effects`disjoint XX0 XX1
    <- effects`join XX0 XX1 XX01
    <- effects`join XX01 (effects/ efxmap/0 SX set/0) XX.

ref-calltyping/call/shared
  : ref-calltyping CM XX1 (result/args/0 XX0)
    (methty/base (ty/ NN annot/shared C) SX)
    (result/expr (reftype/ NN C targets/shared) XX)
    <- effects`disjoint XX0 XX1
    <- effects`join XX0 XX1 XX01
    <- effects`join XX01 (effects/ efxmap/0 SX set/0) XX.

ref-calltyping/args
  : ref-calltyping
    CM XX0 (result/args/+ RT A0) (methty/arg T Rs Ws MT) (result/expr ART XX)
    <- subtype CM RT T Rs Ws XX1
    <- effects`disjoint XX0 XX1
    <- effects`join XX0 XX1 XX01
    <- ref-calltyping CM XX01 A0 MT (result/expr ART XX).

% =========================================================================


% ============================ checking literal ===========================
% =========================================================================

reftyping/lit
  : reftyping _ _ B (lit O) (result/expr RT no-effect)
    <- cxt`lookup B O T
    <- object-index O N
    <- ty2reftype N T RT.

%{
reftyping/null
  : reftyping _ _ _ (lit null) (result/expr reftype/null no-effect).
}%

% =========================================================================


% ========================= Reading Field =================================

reftyping/read
  : reftyping CM MM B E (result/expr (reftype/ nn/yes C GS) XX1)
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN A FC)
    -> make-targets-and-effects GS A F efx/read GSP XX2
    -> effects`join XX1 XX2 XX
    -> reftyping CM MM B (read E F) (result/expr (reftype/ NN FC GSP) XX).

% ====================== end of Reading Field =============================


% ========================= Write Field ===================================

reftyping/write
  : reftyping CM MM B E1 (result/expr (reftype/ nn/yes C GS) XX1)
    -> reftyping CM MM B E2 (result/expr RT XX2)
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN A FC)
    -> make-targets-and-effects GS A F efx/write GSP XX3
    -> subtype CM RT (ty/ NN A FC) set/0 set/0 XX4
    -> effects`join XX1 XX2 XX5
    -> effects`join XX5 XX3 XX6
    -> effects`join XX6 XX4 XX7
    -> reftyping CM MM B (write E1 F E2) (result/expr (reftype/ NN FC GSP) XX7).

% ======================== end of Write Field =============================


% ======================= reftyping/let ===================================
% Note:
% 06-16-13: any possibility to simplify this?
% =========================================================================

% reftyping/let/unique
%   : reftyping CM MM B E
%     (result/expr (reftype/ NN C (targets/unique S GM SB)) XX1)
%     -> ({n}{x}{_:object-index x n}
%          reftyping CM MM (cxt/cons x (ty/ NN annot/unique C) B) (F x)
%          (result/expr (reftype/ NN2 C2 (GS2 n)) (XX2 n)))
%     -> ({n} subst-targets GS n (GS2 n) GS3)
%     -> ({n} subst-effects GS n (XX2 n) XX3)
%     -> effects`join XX1 XX3 XX
%     -> reftyping CM MM B (let E F) (result/expr (reftype/ NN2 C2 GS3) XX).

% ========================== end of reftyping/let =========================


% ======================== reftyping/if ===================================
% Note:
% 06-16-13: needs reftyping/sub to check this
% =========================================================================

%{
reftyping/if
  : reftyping CM MM B C (result/cond XXC)
    -> reftyping CM MM B E1 (result/expr RT XXE)
    -> reftyping CM MM B E2 (result/expr RT XXE)
    -> effects`join XXC XXE XX
    -> reftyping CM MM B (if C E1 E2) (result/expr RT XX).
}%

% ===================== end of reftyping/if ===============================


% ============================ reftyping/while ============================

%{
no-consume-effect : effects -> type. % To be defined later

reftyping/while
  : reftyping CM MM B C (result/cond XX1)
    -> reftyping CM MM B E (result/expr _ XX2)
    -> no-consume-effect XX2
    -> effects`join XX1 XX2 XX
    -> reftyping CM MM B (while C E) (result/expr reftype/null XX).
}%

% ===================== end of reftyping/while ===================


% ==================== Conditionals ===========================

reftyping/eq : reftyping CM MM B E1 (result/expr _ XX1)
               -> reftyping CM MM B E2 (result/expr _ XX2)
               -> effects`join XX1 XX2 XX
               -> reftyping CM MM B (eql E1 E2) (result/cond XX).

reftyping/not : reftyping CM MM B (not C) R
                -> reftyping CM MM B C R.

reftyping/and : reftyping CM MM B C1 (result/cond XX1)
                -> reftyping CM MM B C2 (result/cond XX2)
                -> effects`join XX1 XX2 XX
                -> reftyping CM MM B (and C1 C2) (result/cond XX).

% ==================== end of Conditionals ================================


%%% Arguments

% reftyping/args/0 : reftyping L _ _ _ args/0 result/args/0 L.

% reftyping/args/+
%   : reftyping L1 CM MM B E (result/expr RT XX) L2
%     -> reftyping L2 CM MM B A R L3
%     -> reftyping L1 CM MM B (args/+ E A) (result/args/+ (result/expr RT XX) R) L3.


% ======================== reftyping/call ==============================

%{
reftyping/call
  : clsmap`fresh CM M
    -> methmap`lookup MM M MT
    -> reftyping/args CM MM B no-effect A AR
    -> ref-calltyping CM no-effect AR MT R
    -> reftyping CM MM B (call M A) R.
}%

% ====================== end of reftyping/call =========================


% ========================= reftyping/const ============================

%{
reftyping/const
  : clsmap`lookup CM C FM
    -> fldmap`domain FM S
    -> methmap`lookup MM C (methty/arg _ _ _ MT)
    -> reftyping/args CM MM B no-effect A AO
    -> ref-calltyping CM no-effect AO MT (result/expr RT XX)
    -> reftyping CM MM B (call C (args/+ (alloc C S set/0) A)) (result/expr RT XX).
}%

% ======================= end of reftyping/const ==========================



% ============================ Method Typing ==============================
% Checking method type against func
% =========================================================================

methtymatch* : efxmap -> set -> clsmap -> methmap -> cxt -> func -> methty -> type.

% if we have sub rule, then RT should match T, hence subtype will not be needed.

methtymatch/base
  : methtymatch* XM S CM MM B (func/0 E) (methty/base T SX)
    <- reftype2ty RT T
    <- reftyping CM MM B E (result/expr RT (effects/ XM SX S)).

methtymatch/args/unique
  : methtymatch* XM S CM MM B (func/+ F)
    (methty/arg (ty/ NN annot/unique C) set/0 set/0 MT)
    <- ({n} set`add S n (SF n))
    <- ({n}{x}{_:object-index x n} methtymatch*
         XM (SF n) CM MM (cxt/cons x (ty/ N annot/unique C) B) (F x) MT).

methtymatch/args/borrow
  : methtymatch* XM S CM MM B (func/+ F)
    (methty/arg (ty/ NN annot/borrow C) Rs Ws MT)
    <- set2inner-efxmap Rs efx/read R
    <- set2inner-efxmap Ws efx/write W
    <- inner-efxmap`join R W M
    <- ({n} efxmap`join XM (efxmap/+ n M efxmap/0) (XMF n))
    <- ({n}{x}{_:object-index x n} methtymatch*
         (XMF n) S CM MM (cxt/cons x (ty/ NN annot/borrow C) B) (F x) MT).

methtymatch/args/shared
  : methtymatch* XM S CM MM B (func/+ F)
    (methty/arg (ty/ NN annot/shared C) set/0 set/0 MT)
    <- ({x} methtymatch* XM S CM MM (cxt/cons x (ty/ NN annot/shared C) B) (F x) MT).

%abbrev methtymatch = [CM][MM][F][MT] methtymatch* efxmap/0 set/0 CM MM cxt/nil F MT.


constyping* : effects -> clsmap -> methmap -> fldmap
    -> cxt -> set -> (object -> expr) -> effects -> type.

constyping/0 : constyping* XX _ _ _ _ set/0 ([t] lit t) XX.

constyping/nn
  : constyping* XX1 CM MM FM B S ([t] seq (write (lit t) F E) (EF t)) XX
    <- fldmap`lookup FM F (ty/ nn/yes A C)
    <- set`remove S (set/1 F) SP
    <- reftype2ty RT (ty/ nn/yes A C)
    <- reftyping CM MM B E (result/expr RT XX2)
    <- effects`join XX1 XX2 XX12
    <- constyping* XX12 CM MM FM B SP ([t] EF t) XX.

constyping/mn
  : constyping* XX1 CM MM FM B S ([t] seq (write (lit t) F E) (EF t)) XX
    <- fldmap`lookup FM F (ty/ nn/may A C)
    <- reftype2ty RT (ty/ nn/may A C)
    <- reftyping CM MM B E (result/expr RT XX2)
    <- effects`join XX1 XX2 XX12
    <- constyping* XX12 CM MM FM B S ([t] EF t) XX.

%abbrev constyping = [CM][MM][FM][B][S][E][XX] constyping* no-effect CM MM FM B S E XX.


% the first set is accumulated consumed objects, the second set is all nonnull fields.

constymatch*
  : efxmap -> set -> clsmap -> methmap -> fldmap
    -> cxt -> set -> (object -> func) -> methty -> type.
   
constymatch/base
  : constymatch* XM S CM MM FM B FS ([t] func/0 (E t))
    (methty/base (ty/ nn/yes annot/unique C) SX)
    <- constyping CM MM FM B FS ([t] E t) (effects/ XM SX S).

constymatch/args/unique
  : constymatch* XM S CM MM FM B FS ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/unique C) set/0 set/0 CT)
    <- ({n} set`add S n (SF n))
    <- ({n}{x}{_:object-index x n} constymatch* XM (SF n)
         CM MM FM (cxt/cons x (ty/ NN annot/unique C) B) FS ([t] (F t x)) CT).

constymatch/args/borrow
  : constymatch* XM S CM MM FM B FS ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/borrow C) set/0 set/0 CT)
    <- set2inner-efxmap Rs efx/read R
    <- set2inner-efxmap Ws efx/write W
    <- inner-efxmap`join R W M
    <- ({n} efxmap`join XM (efxmap/+ n M efxmap/0) (XMF n))
    <- ({n}{x}{_:object-index x n} constymatch* (XMF n) S CM MM FM 
         (cxt/cons x (ty/ NN annot/borrow C) B) FS ([t] (F t x)) CT).

constymatch/args/shared
  : constymatch* XM S CM MM FM B FS ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/shared C) set/0 set/0 CT)
    <- ({x} constymatch* XM S CM MM FM
         (cxt/cons x (ty/ NN annot/shared C) B) FS ([t] (F t x)) CT).

%abbrev constymatch
  = [CM][MM][FM][S][F][CT] constymatch* efxmap/0 set/0 CM MM FM cxt/nil S F CT.

% ======================== end of Method Typing ===========================


% ============================ Program Typing =============================
% Checking method map against prog
% =========================================================================

select-fields : fldmap -> set -> type.

select-fields/0 : select-fields fldmap/0 set`set/0.

select-fields/+/in
  : select-fields (fldmap/+ F (ty/ nn/yes _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S'
    <- set`union S' (set/1 F) S.

select-fields/+/result
  : select-fields (fldmap/+ F (ty/ nn/may _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S.


methmapmatch* : clsmap -> methmap -> methmap -> prog -> type.

methmapmatch/0 : methmapmatch* _ _ methmap/0 prog`map/0.

methmapmatch/+/const
  : methmapmatch* CM MM0
    (methmap/+ C (methty/arg (ty/ nn/yes _ C) _ _ CT) MM)
    (prog`map/+ C (func/+ ([t] FF t)) XM)
    <- clsmap`lookup CM C FM
    <- select-fields FM S
    <- constymatch CM MM0 FM S FF CT
    <- methmap`shift C MM MM'
    <- prog`shift C XM XM'
    <- methmapmatch* CM MM0 MM' XM'.

methmapmatch/+/meth
  : methmapmatch* CM MM0
    (methmap/+ N MT MM) (prog`map/+ N FUN XM)
    <- clsmap`fresh CM N
    <- methtymatch CM MM0 FUN MT
    <- methmap`shift N MM MM'
    <- prog`shift N XM XM'
    <- methmapmatch* CM MM0 MM' XM'.

%abbrev methmapmatch = [CM][MM][G] methmapmatch* CM MM MM G.

% ===================== end of Program Typing =============================
