%%% Type judgments for conservative type system based on FP.
%%% $Id: typing.elf,v 1.2 2013/06/04 20:41:29 csun Exp csun $

%%% Abbreviations

%abbrev null = (object/ z).	% null object

%abbrev loc = nat. % alias for location


%%% Output for Type Checking

out : kind -> type.

%abbrev expr-out = out exprk.

%abbrev cond-out = out condk.

%abbrev args-out = out argsk.


out/expr : reftype -> effects -> expr-out.

out/cond : effects -> cond-out.

out/args/0 : effects -> args-out.

out/args/+ : reftype -> args-out -> args-out.


%% Conversions between ty and reftype

% ty => reftype

ty2reftype : nat -> ty -> reftype -> type.

ty2reftype/unique
  : ty2reftype L (ty/ NN annot/unique C) 
    (reftype/ NN C (targets/unique (set/1 L) tgtmap/0 false)).

ty2reftype/shared
  : ty2reftype L (ty/ NN annot/shared C)
    (reftype/ NN C targets/shared).

ty2reftype/borrow
  : ty2reftype L (ty/ NN annot/borrow C)
    (reftype/ NN C (targets/unique (set/1 L) tgtmap/0 false)).

% reftype => ty 

reftype2ty : reftype -> ty -> type.

reftype2ty/unique
  : reftype2ty (reftype/ NN C (targets/unique _ _ _)) (ty/ NN annot/unique C).
    
reftype2ty/shared
  : reftype2ty (reftype/ NN C targets/shared) (ty/ NN annot/shared C).


%%% Field Subtyping

fld-subtype : clsmap -> reftype -> ty -> effects -> type.

fld-subtype/shared
 : fld-subtype _ RT (ty/ NN annot/shared C) XX
   <- subtype RT (ty/ NN annot/shared C) set/0 set/0 set/0 XX.

fld-subtype/unique
  : clsmap`lookup CM C FM
    -> fldmap`domain FM S
    -> subtype RT (ty/ NN annot/unique C) set/0 set/0 S XX
    -> fld-subtype CM RT (ty/ NN annot/unique C) XX.


%%% Type Judgments

reftyping : loc -> clsmap -> methmap -> cxt -> term K -> out K -> loc -> type.

%{
One issue we need to consider is aliasing between unique arguments.
For instance, if a method is annotated as "reads a.f, writes b.f", and
a and b are aliases to each other, then we cannot check the call.

Given this situation doesn't occur very often, here we just simply
disallow "duplicated" effects while checking method call effects.
}%

reftyping/args
  : loc -> clsmap -> methmap -> cxt -> effects -> args -> args-out -> loc -> type.

reftyping/args/0 : reftyping/args L _ _ _ XX args/0 (out/args/0 XX) L.

reftyping/args/+
  : reftyping L1 CM MM B E (out/expr RT XX2) L2
    -> effects`join XX1 XX2 XX
    -> reftyping/args L2 CM MM B XX A AO L3
    -> reftyping/args L1 CM MM B XX1 (args/+ E A) (out/args/+ RT AO) L3.


%{ 
RS, WS and CS are sets of fields that may be read, write or
consumed, respectively.
}%
ref-calltyping : loc -> effects -> args-out -> methty -> expr-out -> type.

ref-calltyping/call
  : ty2reftype L T RT
    -> effects`disjoint XX1 (effects/ efxmap/0 MX)
    -> effects`join XX0 XX1 XX01
    -> effects`join XX01 (effects/ efxmap/0 MX) XX
    -> ref-calltyping L XX1 (out/args/0 XX0) (methty/base T MX) (out/expr RT XX).

ref-calltyping/args
  : subtype RT T RS WS CS XX1
    -> effects`disjoint XX0 XX1
    -> effects`join XX0 XX1 XX01
    -> ref-calltyping L XX01 AO MT (out/expr ART XX)
    -> ref-calltyping L XX0 (out/args/+ RT AO)
      (methty/arg T RS WS CS MT) (out/expr ART XX).


% expressions

reftyping/lit
  : reftyping L _ _ B (lit O) (out/expr RT no-effect) L
    <- cxt`lookup-object B O T N
    <- ty2reftype N T RT.

reftyping/null : reftyping L _ _ _ (lit null) (out/expr RT no-effect) L.


%{ consider field annotation, and returns either
the input unique targets, or a shared targets. 
(no borrowed targets since field cannot be borrowed). }%

consider-ftype : targets -> annot -> targets -> type.

consider-ftype/shared : consider-ftype _ annot/shared targets/shared.

consider-ftype/unique : consider-ftype GS annot/unique GS.


%{ Given input targets for field reference receiver,
field annotation, field ID, and effects, compute the result
targets and effects. }%

make-targets-and-effects
  : targets -> annot -> nat -> efx -> targets -> effects -> type.

make-targets-and-effects/shared 
  : consider-ftype (targets/unique set/0 tgtmap/0 true) A GS
    -> make-targets-and-effects targets/shared A _ X GS (shared-effect X).

make-targets-and-effects/unique 
  : set+nat2tgtmap S F GM2
    -> tgtmap`join GM1 GM2 GM
    -> tgtmap2efxmap GM X XM
    -> efx-on-shared SB (maybe-efx/just X) MX
    -> consider-ftype (targets/unique set/0 GM SB) A GS
    -> make-targets-and-effects
      (targets/unique S GM1 SB) A F X GS (effects/ XM MX).


% Read and Write

reftyping/read
  : reftyping L1 CM MM B E (out/expr (reftype/ nn/yes C GS) XX1) L2
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN A FC)
    -> make-targets-and-effects GS A F efx/read GSP XX2
    -> effects`join XX1 XX2 XX
    -> reftyping L1 CM MM B (read E F) (out/expr (reftype/ NN FC GSP) XX) L2.

reftyping/write
  : reftyping L1 CM MM B E1 (out/expr (reftype/ nn/yes C GS) XX1) L2
    -> reftyping L2 CM MM B E2 (out/expr RT XX2) L3
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN A FC)
    -> fld-subtype CM RT (ty/ NN A FC) XX3 
    -> make-targets-and-effects GS A F efx/write GSP XX4
    -> effects`join XX1 XX2 XX5
    -> effects`join XX5 XX3 XX6
    -> effects`join XX6 XX4 XX7
    -> reftyping L1 CM MM B (write E1 F E2) (out/expr (reftype/ NN FC GSP) XX7) L3.

reftyping/destructive-read
  : cxt`lookup-object B O (ty/ nn/yes A C) N
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN FA FC)
    -> reftyping L1 CM MM B E1 (out/expr RT XX1) L2
    -> fld-subtype CM RT (ty/ NN FA FC) XX2
    -> make-targets-and-effects
      (targets/unique set/0 (tgtmap/+ N (set/1 F) tgtmap/0) false) 
      A F efx/write _ XX3
    -> ({x} cxt`update B L1 (cxtv/ x FT) (BF x))
    -> ({x} reftyping L2 CM MM (BF x) (E2 x) (out/expr RT2 XX4) L3)
    -> effects`join XX1 XX2 XX12
    -> effects`join XX12 XX3 XX123
    -> effects`join XX123 XX4 XX1234
    -> reftyping L1 CM MM B
      (let (read (lit O) F)
        ([x] (seq (write (lit O) F E1) (E2 x)))) (out/expr RT3 XX1234) L3.

%{
06-16-13: any possibility to simplify this?
}%
reftyping/let
  : reftyping L1 CM MM B E (out/expr (reftype/ NN C GS) XX1) L2
    -> reftype2ty (reftype/ NN C GS) T
    -> ({x} cxt`update B L2 (cxtv/ x T) (BF x))
    -> ({x} reftyping (s L2) CM MM (BF x)
         (F x) (out/expr (reftype/ NN2 C2 GS2) XX2) L3)
    -> subst-targets GS L2 GS2 GS3 
    -> subst-effects GS L2 XX2 XX3
    -> effects`join XX1 XX3 XX
    -> reftyping L1 CM MM B (let E F) (out/expr (reftype/ NN2 C2 GS3) XX) L3.

%{
06-16-13: needs reftyping/sub to check this
}%
reftyping/if
  : reftyping L1 CM MM B C (out/cond XXC) L2
    -> reftyping L2 CM MM B E1 (out/expr RT XXE) L3
    -> reftyping L3 CM MM B E2 (out/expr RT XXE) L4
    -> effects`join XXC XXE XX
    -> reftyping L1 CM MM B (if C E1 E2) (out/expr RT XX) L4.

no-consume-effect : effects -> type. % To be defined later

reftyping/while
  : reftyping L1 CM MM B C (out/cond XX1) L2
    -> reftyping L2 CM MM B E (out/expr _ XX2) L3
    -> no-consume-effect XX2
    -> effects`join XX1 XX2 XX
    -> reftyping L1 CM MM B (while C E) (out/expr RT XX) L3.
    

%%% Conditionals

reftyping/eq
  : reftyping L1 CM MM B E1 (out/expr _ XX1) L2
    -> reftyping L2 CM MM B E2 (out/expr _ XX2) L3
    -> effects`join XX1 XX2 XX
    -> reftyping L1 CM MM B (eql E1 E2) (out/cond XX) L3.

reftyping/not
  : reftyping L1 CM MM B (not C) R L2 
    -> reftyping L1 CM MM B C R L2.

reftyping/and
  : reftyping L1 CM MM B C1 (out/cond XX1) L2
    -> reftyping L2 CM MM B C2 (out/cond XX2) L3
    -> effects`join XX1 XX2 XX
    -> reftyping L1 CM MM B (and C1 C2) (out/cond XX) L3.


%%% Arguments


% reftyping/args/0 : reftyping L _ _ _ args/0 out/args/0 L.

% reftyping/args/+
%   : reftyping L1 CM MM B E (out/expr RT XX) L2
%     -> reftyping L2 CM MM B A R L3
%     -> reftyping L1 CM MM B (args/+ E A) (out/args/+ (out/expr RT XX) R) L3.


%%% Method and Constructor Calls

reftyping/call
  : clsmap`fresh CM M
    -> methmap`lookup MM M MT
    -> reftyping/args L1 CM MM B no-effect A AR L2
    -> ref-calltyping L2 no-effect AR MT R
    -> reftyping L1 CM MM B (call M A) R (s L2).

reftyping/const
  : clsmap`lookup CM C FM
    -> fldmap`domain FM S
    -> methmap`lookup MM C (methty/arg _ _ _ _ MT)
    -> reftyping/args L1 CM MM B no-effect A AO L2
    -> ref-calltyping L2 no-effect AO MT (out/expr RT XX)
    -> reftyping L1 CM MM B
      (call C (args/+ (alloc C S set/0) A)) (out/expr RT XX) (s L2).


% methtymatch

methtymatch*
  : loc -> effects -> clsmap -> methmap -> cxt -> 
  func -> methty -> loc -> type.

methtymatch/base
  : reftyping L1 CM MM B E (out/expr RT XX1) L2
    -> fld-subtype CM RT T XX2
    -> effects`join XX1 XX2 XX12
    -> effects`join XX (effects/ efxmap/0 MX) XX3
    -> effects`leq XX12 XX3
    -> methtymatch* L1 XX CM MM B (func/0 E) (methty/base T MX) L2.

methtymatch/args
  : set2inner-efxmap RS efx/read M1
    -> set2inner-efxmap WS efx/write M2
    -> set2inner-efxmap CS efx/consume M3
    -> inner-efxmap`join M1 M2 M12
    -> inner-efxmap`join M12 M3 M123
    -> effects`join XX1 (effects/ (efxmap/+ L1 M123 efxmap/0) maybe-efx/nothing) XX
    -> ({x} cxt`update B L1 (cxtv/ x T) (BF x))
    -> ({x} methtymatch* (s L1) XX CM MM (BF x) (F x) MT L2)
    -> methtymatch* L1 XX1 CM MM B (func/+ F) (methty/arg T RS WS CS MT) L2.

%abbrev methtymatch
  = [CM][MM][F][MT] methtymatch* (s z) no-effect CM MM cxt/nil F MT L.


% constructor type

constyping
  : loc -> efxmap -> clsmap -> methmap -> fldmap 
  -> cxt -> set -> (object -> expr) -> efxmap -> loc -> type.

% TODO: define later
constyping/0 : constyping L XM _ _ _ _ set/0 ([t] lit t) XM L.

constymatch*
  : loc -> efxmap -> clsmap -> methmap -> fldmap -> cxt
  -> set -> (object -> func) -> methty -> loc -> type.

%abbrev constymatch
  = [CM][MM][FM][S][F][CT] 
    constymatch* (s (s z)) efxmap/0 CM MM FM cxt/nil S F CT L.


%%% program type

select-fields : fldmap -> set -> type.

select-fields/0 : select-fields fldmap/0 set`set/0.

select-fields/+/in
  : select-fields (fldmap/+ F (ty/ nn/yes _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S'
    <- set`union S' (set/1 F) S.

select-fields/+/out
  : select-fields (fldmap/+ F (ty/ nn/may _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S.


methmapmatch* : clsmap -> methmap -> methmap -> prog -> type.

methmapmatch/0 : methmapmatch* _ _ methmap/0 prog`map/0.

methmapmatch/+/const
  : methmapmatch* CM MM0
    (methmap/+ C (methty/arg (ty/ nn/yes _ C) _ _ _ CT) MM)
    (prog`map/+ C (func/+ ([t] FF t)) XM)
    <- clsmap`lookup CM C FM
    <- select-fields FM S
    <- constymatch CM MM0 FM S FF CT
    <- methmap`shift C MM MM'
    <- prog`shift C XM XM'
    <- methmapmatch* CM MM0 MM' XM'.

methmapmatch/+/meth
  : methmapmatch* CM MM0
    (methmap/+ N MT MM) (prog`map/+ N FUN XM)
    <- clsmap`fresh CM N
    <- methtymatch CM MM0 FUN MT
    <- methmap`shift N MM MM'
    <- prog`shift N XM XM'
    <- methmapmatch* CM MM0 MM' XM'.

%abbrev methmapmatch = [CM][MM][G] methmapmatch* CM MM MM G.


%%% Theorems