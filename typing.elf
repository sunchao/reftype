%%% Type judgments for conservative type system based on FP.

%%% Type Checking Result

result : kind -> type.

%abbrev expr-result = result exprk.

%abbrev cond-result = result condk.

%abbrev args-result = result argsk.


result/expr : reftype -> env -> expr-result.

result/cond : env -> cond-result.

result/args/0 : env -> args-result.

result/args/+ : reftype -> env -> args-result -> args-result.


%%% Equality

result`eq : result K -> result K -> type.

result`eq/ : result`eq R R.


%theorem result/expr-eq-inversion
  : forall* {RT1} {V1} {RT2} {V2}
    forall {E: result`eq (result/expr RT1 V1) (result/expr RT2 V2)}
    exists {TE: reftype`eq RT1 RT2} {VE: env`eq V1 V2}
    true.

- : result/expr-eq-inversion result`eq/ reftype`eq/ env`eq/.

%worlds (gtermvar) (result/expr-eq-inversion _ _ _).
%total { } (result/expr-eq-inversion _ _ _).


%theorem result/cond-eq-inversion
  : forall* {V1} {V2}
    forall {E: result`eq (result/cond V1) (result/cond V2)}
    exists {VE: env`eq V1 V2}
    true.

- : result/cond-eq-inversion result`eq/ env`eq/.

%worlds (gtermvar) (result/cond-eq-inversion _ _).
%total { } (result/cond-eq-inversion _ _).


%theorem result/args/0-eq-inversion
  : forall* {V1} {V2}
    forall {E: result`eq (result/args/0 V1) (result/args/0 V2)}
    exists {VE: env`eq V1 V2}
    true.

- : result/args/0-eq-inversion result`eq/ env`eq/.

%worlds (gtermvar) (result/args/0-eq-inversion _ _).
%total { } (result/args/0-eq-inversion _ _).


%theorem result/args/+-eq-inversion
  : forall* {V1} {V2} {RT1} {RT2} {A1} {A2}
    forall {E: result`eq (result/args/+ RT1 V1 A1) (result/args/+ RT2 V2 A2)}
    exists {TE: reftype`eq RT1 RT2} {VE: env`eq V1 V2} {AE: result`eq A1 A2}
    true.

- : result/args/+-eq-inversion result`eq/ reftype`eq/ env`eq/ result`eq/.

%worlds (gtermvar) (result/args/+-eq-inversion _ _ _ _).
%total { } (result/args/+-eq-inversion _ _ _ _).


%%% Type Checking Rules

reftyping : clsmap -> methmap -> cxt -> env -> term K -> result K -> type.


%%% ====================== Type Check Rules =======================

%%% Checking Literals

reftyping/lit :
    cxt`lookup-obj B O (s N) T ->
    ty2reftype (s N) T RT ->
  reftyping _ _ B V (lit O) (result/expr RT V).


%%% Type Rules with Direct Effect

%%% Reading a field

%%% TODO: thinking about removing this.
targets-capset : targets -> set -> type.

targets-capset/shared : targets-capset targets/shared _.

targets-capset/unique :
    set`disjoint M1 M2 ->
  targets-capset (targets/unique _ M1 _) M2.


readRefTyping : clsmap -> expr-result -> nat -> expr-result -> type.

readRefTyping/base :
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F (ty/ NN A FC) ->
    make-tgts-and-caps M0 G0 F G1 M1 ->
    consider-ftype G1 M1 A G2 M2 ->
    targets-capset G0 M0 ->
  readRefTyping CM (result/expr (reftype/ nn/yes C G0) (env/ U M0)) F
    (result/expr (reftype/ NN FC G2) (env/ U M2)).

reftyping/read :
    reftyping CM MM B V E R ->
    readRefTyping CM R F R2 ->
  reftyping CM MM B V (read E F) R2.


%%% Writing a field

writeRefTyping : clsmap -> methmap -> cxt -> expr-result -> nat -> expr ->
    targets -> ty -> expr-result -> type.

%%% In subtype, we don't care about FS, since it's impossible for
%%% a field to be borrowed.
%%% TODO: looks like the result for this shouldn't have attached field caps.
%%% The result of writing a field should be unit
writeRefTyping/base :
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F (ty/ NN A FC) ->
    make-tgts-and-caps M0 G0 F G1 M1 ->
    reftyping CM MM B (env/ U0 M1) E (result/expr RT V2) ->
    subtype CM _ RT V2 (ty/ NN A FC) _ (env/ U1 M3) ->
    consider-ftype G1 M3 A G2 M4 ->
  writeRefTyping CM MM B (result/expr (reftype/ nn/yes C G0) (env/ U0 M0))
    F E G1 (ty/ NN A FC) (result/expr (reftype/ NN FC G2) (env/ U1 M4)).

reftyping/write
  : reftyping CM MM B V1 E1 R1 ->
    writeRefTyping CM MM B R1 F E2 G T R2 ->
  reftyping CM MM B V1 (write E1 F E2) R2.


%%% Type Rules with Indirect Effects


%%% Let

%{
For let, we have two approaches
1. change the context to map to reftype, instead of ty. So, the variable x
is mapped to the reftype from checking E. But, whenever consume something,
we need to trace down to the "root" of each binding. This approach is a bit
complicated.

2. suppose x is bound to (reftype/unique S G), we remove field capabilities for
all objects in S. For instance, if S = {a, b}, and in M we have (a.f,W),
(a.g, R), (b.f, R), then as result, we remove these from M, and add (x.f, R) to it.
In other words, we compute the most conservative capabilities we can get for x.
During the life time of x, all objects in S are not allowed to use, until x is being
released out of scope.

Currently, we use the second approach, since it's easier to implement.
In the future, we can come back here and switch to the first approach.
}%


%{
update-cxt : clsmap -> env -> ty -> (object -> env) -> type.

update-cxt/unique :
    clsmap`lookup CM C FM ->
    fldmap`domain FM FS ->
    nat+set2capmap (s N) FS cap/write M1 ->
    capmap-split M2 M1 M0 ->
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) ->
  update-cxt CM (env/ B0 M0) (ty/ NN annot/unique C) ([x] env/ (B1 x) M2).

update-cxt/shared :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
  update-cxt CM (env/ B0 M0) (ty/ NN annot/shared C) ([x] env/ (B1 x) M0).
}%

%%% Make sure the let variable is not in the result target (no leaking).

not-in-capset : nat -> set -> type.

not-in-capset/0 : not-in-capset _ set/0.

not-in-capset/U :
    not-in-capset N CS' ->
    nat2pair K (pair/ N' F) ->
    nat`ne N N' ->
    set`not-member CS' K ->
    set`add CS' K CS ->
  not-in-capset N CS.

not-in-targets : nat -> targets -> type.

not-in-targets/unique :
    set`not-member S N ->
    not-in-capset N M ->
  not-in-targets N (targets/unique S M _).

not-in-targets/shared : not-in-targets _ targets/shared.

not-in-targets/fresh : not-in-targets _ targets/fresh.


%%% Reclaim capabilities encumbered by the let variable.

%%% At the moment we just be conservative, and don't allow ANY field
%%% from the let variable be consumed.

letRefTyping : clsmap -> methmap -> cxt ->
    expr-result -> (object -> term K) -> result K -> type.

%%% M5 = M0 - M2 + M3
letRefTyping/base/unique :
    clsmap`lookup CM C FM ->
    fldmap`domain FM FS ->
    set+set2set S FS M2 ->
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) ->
    set`split U0 S U1 ->
    set`not-member U1 (s N) ->
    set`add U1 (s N) U2 ->
    set`split M0 M2 M4 ->
    nat+set2set (s N) FS M3 ->
    set`split M5 M3 M4 ->
    ({x} reftyping CM MM (B1 x) (env/ U2 M5) (F x)
      (result/expr (reftype/ NN1 C1 G1) (env/ U3 M6))) ->
    not-in-targets (s N) G1 ->
    set`split M6 M3 M7 -> % M3 still in result
    set`split M8 M2 M7 ->
    set`split M9 M1 M8 ->
    set`not-member U4 (s N) ->
    set`add U4 (s N) U3 ->
    set`union U4 S U5 ->
  letRefTyping CM MM B0 (result/expr (reftype/ NN C (targets/unique S M1 W)) (env/ U0 M0))
    F (result/expr (reftype/ NN1 C1 G1) (env/ U5 M9)).

letRefTyping/base/shared :
    clsmap`lookup CM C FM ->
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
    ({x} reftyping CM MM (B1 x) V (F x)
      (result/expr (reftype/ NN1 C1 G1) V1)) ->
    not-in-targets (s N) G1 ->
  letRefTyping CM MM B0 (result/expr (reftype/ NN C targets/shared) V)
    F (result/expr (reftype/ NN1 C1 G1) V1).

reftyping/let :
    reftyping CM MM B V E R1 ->
    letRefTyping CM MM B R1 F R2 ->
  reftyping CM MM B V (let E F) R2.


%%% Method Calls

%{
Type checking arguments

One issue we need to consider is aliasing between unique arguments.
For instance, if a method is annotated as "reads a.f, writes b.f", and
a and b are aliases to each other, then we cannot check the call.

Given this situation doesn't occur very often, and is also illegal in FP,
here we just simply disallow "duplicated" cap while checking method call effects.

For borrowed parameter type, we'll get back the associated capabilities after
the method call is checked. Consider:

@write b.f
foo(@borrow T b): ...

And both x and y are unique reference of type T, and both f and g are unique fields.
Then,

call foo(if a > 3 then x else y.g)

will need input capabilities (x.f, y.g)

After foo is checked, we should get permissions for x.f and y.g back.

}%


argsRefTyping : clsmap -> methmap -> cxt -> env -> args -> methty -> args-result -> type.

argsRefTyping/0 : argsRefTyping _ _ _ V args/0 (methty/base T) (result/args/0 V).

argsRefTyping/+ :
    reftyping CM MM B V0 E (result/expr RT V1) ->
    subtype CM FS RT V1 T AV V2 ->
    argsRefTyping CM MM B V2 A MT AR ->
  argsRefTyping CM MM B V0 (args/+ E A) (methty/arg T FS MT) (result/args/+ RT AV AR).


%{
How to check method call:
1. Check arguments, given an input type context and capability set.
   For each argument, type checking will yield a corresponding
   result reftype, and produce a output capability set. After checking all
   arguments, we get a output (unchanged) type context, and a set of
   remaining capabilities.
2. Check method type using the result/args and remaining capability set.
   For each formal argument, if it's unique, remove the associated capabilities
   from output capability set. Otherwise, we'll just return the same capabilities
   for the argument.

Note that both step 1 and 2 may modify the context and capability set (step 1
will only weaken the condition, while step 2 will only strengthen the
condition).

To make the rule interesting, we should need to prove that capabilities can be
reclaimed after they are not needed after the method call checking. This is
also needed for checking tLet.
}%

%%% Converting a ty to a reftype for a fresh new object.

ty2new-reftype : ty -> reftype -> type.

ty2new-reftype/unique :
    ty2new-reftype (ty/ NN annot/unique C) (reftype/ NN C targets/fresh).

ty2new-reftype/shared :
    ty2new-reftype (ty/ NN annot/shared C) (reftype/ NN C targets/shared).


%%% Look for encumbered capabilities and put them back in the holding capability set

restore-cap-targets : env -> targets -> env -> type.

restore-cap-targets/shared : restore-cap-targets V targets/shared V.

restore-cap-targets/unique :
    set`combine M0 M1 M ->
  restore-cap-targets (env/ U M0) (targets/unique _ M1 _) (env/ U M).


restore-cap-call : env -> reftype -> env -> ty -> env -> type.

restore-cap-call/uniqueORshared :
    not-borrow A ->
  restore-cap-call V _ _ (ty/ _ A _) V.

restore-cap-call/borrow :
    restore-cap-targets V0 (targets/unique S M _) V0' ->
    env`combine V0' V1 V2 ->
  restore-cap-call V0 (reftype/ _ _ (targets/unique S M _)) V1 (ty/ _ annot/borrow _) V2.


callRefTyping* : clsmap -> methmap -> env -> args-result -> methty -> expr-result -> type.

callRefTyping/arg/0 :
    env`combine V0 V1 V ->
    ty2new-reftype T RT ->
  callRefTyping* CM MM V0 (result/args/0 V1) (methty/base T) (result/expr RT V).

callRefTyping/arg/+ :
    restore-cap-call V0 RT AV T V1 ->
    callRefTyping* CM MM V1 AR MT R ->
  callRefTyping* CM MM V0 (result/args/+ RT AV AR) (methty/arg T _ MT) R.

%abbrev callRefTyping = [CM][MM][AR][MT][R] callRefTyping* CM MM empty-env AR MT R.


reftyping/call :
    clsmap`fresh CM M ->
    methmap`lookup MM M MT ->
    argsRefTyping CM MM B V A MT AR ->
    callRefTyping CM MM AR MT R ->
  reftyping CM MM B V (call M A) R.

reftyping/const :
    clsmap`lookup CM C FM ->
    fldmap`domain FM S ->
    methmap`lookup MM C (methty/arg _ _ MT) ->
    argsRefTyping CM MM B V A MT AR ->
    callRefTyping CM MM AR MT R ->
  reftyping CM MM B V (call C (args/+ (alloc C S set/0) A)) R.


reftyping/if :
    reftyping CM MM B V0 C (result/cond V1) ->
    reftyping CM MM B V1 E1 (result/expr RT V2) ->
    reftyping CM MM B V1 E2 (result/expr RT V2) ->
  reftyping CM MM B V0 (if C E1 E2) (result/expr RT V2).


%%% Conditionals

%%% After the "eql" statement, we need to reclaim the capabilities
%%% encumbered in `RT1` and `RT2`.

reftyping/eq :
    reftyping CM MM B V0 E1 (result/expr (reftype/ _ _ G1) V1) ->
    reftyping CM MM B V1 E2 (result/expr (reftype/ _ _ G2) V2) ->
    restore-cap-targets V2 G1 V3 ->
    restore-cap-targets V3 G2 V4 ->
  reftyping CM MM B V0 (eql E1 E2) (result/cond V4).

reftyping/not :
    reftyping CM MM B V C R ->
  reftyping CM MM B V (not C) R.

%%% For the second branch, the input capabilities need to be the same
%%% as output (e.g., no a.f = new C in C2). Otherwise, for the conditional
%%% in the output the two branches will have different permissions.
reftyping/and :
    reftyping CM MM B V0 C1 (result/cond V1) ->
    reftyping CM MM B V1 C2 (result/cond V1) ->
  reftyping CM MM B V0 (and C1 C2) (result/cond V1).


%%% Method Typing

% Checking method type against func

methtymatch* : env -> env -> clsmap -> methmap -> cxt -> func -> methty -> type.

%%% if we have sub rule, then RT should match T,
%%% hence subtype will not be needed.

methtymatch/base :
    ty2new-reftype T RT ->
    reftyping CM MM B Vin E (result/expr RT Vout) ->
  methtymatch* Vin Vout CM MM B (func/0 E) (methty/base T).

methtymatch/args/shared :
    cxt`fresh B0 N ->
    ({x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
    ({x} methtymatch* Vin Vout CM MM (B1 x) (F x) MT) ->
  methtymatch* Vin Vout CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/shared C) _ MT).

methtymatch/args/unique :
    cxt`fresh B0 N ->
    ({x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) ->
    clsmap`lookup CM C FM ->
    fldmap`domain FM FS ->
    nat+set2set N FS Mf ->
    set`add Uin N Uin' ->
    set`union Min Mf Min' ->
    ({x} methtymatch* (env/ Uin' Min') Vout CM MM (B1 x) (F x) MT) ->
  methtymatch* (env/ Uin Min) Vout CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/unique C) _ MT).

methtymatch/args/borrow :
    cxt`fresh B0 N ->
    ({x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/borrow C)) (B1 x)) ->
    nat+set2set N FS Mf ->
    set`union Min Mf Min' ->
    set`union Mout Mf Mout' ->
    ({x} methtymatch* (env/ Uin Min') (env/ Uout Mout') CM MM (B1 x) (F x) MT) ->
  methtymatch* (env/ Uin Min) (env/ Uout Mout) CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/borrow C) FS MT).

%abbrev methtymatch = [CM][MM][F][MT] methtymatch* empty-env empty-env CM MM cxt/0 F MT.


constyping* : clsmap -> methmap -> fldmap
    -> cxt -> env -> set -> (object -> expr) -> env -> type.

constyping/0 : constyping* _ _ _ _ V set/0 ([t] lit t) V.

constyping/nn :
    fldmap`lookup FM F (ty/ nn/yes A C) ->
    set`remove S (set/1 F) SP ->
    reftyping CM MM B V0 E (result/expr RT V1) ->
    subtype CM _ RT V1 (ty/ nn/yes A C) _ V2 ->
    constyping* CM MM FM B V2 SP ([t] EF t) V3 ->
  constyping* CM MM FM B V0 SP ([t] seq (write (lit t) F E) (EF t)) V3.

constyping/mn :
    fldmap`lookup FM F (ty/ nn/yes A C) ->
    reftyping CM MM B V0 E (result/expr RT V1) ->
    subtype CM _ RT V1 (ty/ nn/yes A C) _ V2 ->
    constyping* CM MM FM B V2 S ([t] EF t) V3 ->
  constyping* CM MM FM B V0 SP ([t] seq (write (lit t) F E) (EF t)) V3.


%%% the first set is accumulated consumed objects, the second set is all nonnull fields.

methtymatch/base :
    ty2new-reftype T RT ->
    reftyping CM MM B Vin E (result/expr RT Vout) ->
  methtymatch* Vin Vout CM MM B (func/0 E) (methty/base T).

methtymatch/args/shared :
    cxt`fresh B0 N ->
    ({x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
    ({x} methtymatch* Vin Vout CM MM (B1 x) (F x) MT) ->
  methtymatch* Vin Vout CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/shared C) _ MT).

methtymatch/args/borrow :
    cxt`fresh B0 N ->
    ({x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/borrow C)) (B1 x)) ->
    nat+set2set N FS Mf ->
    set`union Min Mf Min' ->
    set`union Mout Mf Mout' ->
    ({x} methtymatch* (env/ Uin Min') (env/ Uout Mout') CM MM (B1 x) (F x) MT) ->
  methtymatch* (env/ Uin Min) (env/ Uout Mout) CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/borrow C) FS MT).

methtymatch/args/unique :
    cxt`fresh B0 N ->
    ({x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) ->
    clsmap`lookup CM C FM ->
    fldmap`domain FM FS ->
    nat+set2set N FS Mf ->
    set`add Uin N Uin' ->
    set`union Min Mf Min' ->
    ({x} methtymatch* (env/ Uin' Min') Vout CM MM (B1 x) (F x) MT) ->
  methtymatch* (env/ Uin Min) Vout CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/unique C) _ MT).

constymatch* : env -> env -> clsmap -> methmap -> fldmap -> cxt -> set ->
    (object -> func) -> methty -> type.

constymatch/base :
    ty2new-reftype (ty/ nn/yes annot/unique C) RT ->
    constyping* CM MM FM B Vin FS ([t] E t) Vout ->
  constymatch* Vin Vout CM MM FM B FS ([t] func/0 (E t))
    (methty/base (ty/ nn/yes annot/unique C)).

constymatch/args/shared :
    cxt`fresh B0 N ->
    ({x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
    ({x} constymatch* Vin Vout CM MM FM (B1 x) FS ([t] F t x) CT) ->
  constymatch* Vin Vout CM MM FM B0 FS ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/shared C) set/0 CT).

constymatch/args/borrow :
    cxt`fresh B0 N ->
    ({x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/borrow C)) (B1 x)) ->
    nat+set2set N FS Mf ->
    set`union Min Mf Min' ->
    set`union Mout Mf Mout' ->
    ({x} constymatch* (env/ Uin Min') (env/ Uout Mout') CM MM FM (B1 x) S ([t] F t x) CT) ->
  constymatch* (env/ Uin Min) (env/ Uout Mout) CM MM FM B0 S ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/borrow C) FS CT).

constymatch/args/unique :
    cxt`fresh B0 N ->
    ({x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) ->
    clsmap`lookup CM C FFM ->
    fldmap`domain FFM FFS ->
    nat+set2set N FFS Mf ->
    set`add Uin N Uin' ->
    set`union Min Mf Min' ->
    ({x} constymatch* (env/ Uin' Min') Vout CM MM FM (B1 x) S ([t] F t x) CT) ->
  constymatch* (env/ Uin Min) Vout CM MM FM B0 S ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/unique C) set/0 CT).

%abbrev constymatch
  = [CM][MM][FM][S][F][CT] constymatch* empty-env empty-env CM MM FM cxt/0 S F CT.


%%% Program Typing: checking method map against prog

select-fields : fldmap -> set -> type.

select-fields/0 : select-fields fldmap/0 set`set/0.

select-fields/+/in
 : select-fields (fldmap/+ F (ty/ nn/yes _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S'
    <- set`union S' (set/1 F) S.

select-fields/+/result
  : select-fields (fldmap/+ F (ty/ nn/may _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S.


methmapmatch* : clsmap -> methmap -> methmap -> prog -> type.

methmapmatch/0 : methmapmatch* _ _ methmap/0 prog`map/0.

methmapmatch/+/const
  : methmapmatch* CM MM0
    (methmap/+ C (methty/arg (ty/ nn/yes _ C) _ CT) MM)
    (prog`map/+ C (func/+ ([t] FF t)) M)
    <- clsmap`lookup CM C FM
    <- select-fields FM S
    <- constymatch CM MM0 FM S FF CT
    <- methmap`shift C MM MM'
    <- prog`shift C M M'
    <- methmapmatch* CM MM0 MM' M'.

methmapmatch/+/meth
  : methmapmatch* CM MM0
    (methmap/+ N MT MM) (prog`map/+ N FUN M)
    <- clsmap`fresh CM N
    <- methtymatch CM MM0 FUN MT
    <- methmap`shift N MM MM'
    <- prog`shift N M M'
    <- methmapmatch* CM MM0 MM' M'.

%abbrev methmapmatch = [CM][MM][G] methmapmatch* CM MM MM G.
