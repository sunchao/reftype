%%% Type judgments for conservative type system based on FP.
%%% $Id$

%%% Definitions

result : kind -> type.

%abbrev expr-result = result exprk.

%abbrev cond-result = result condk.

%abbrev args-result = result argsk.


result/expr : reftype -> effects -> expr-result.

result/cond : effects -> cond-result.

result/args/0 : effects -> args-result.

result/args/+ : reftype -> args-result -> args-result.


result`eq : result K -> result K -> type.

result`eq/ : result`eq R R.


% get index of an object

object-index : object -> nat -> type.

object-index/ : object-index (object/ N) N.



reftyping : clsmap -> methmap -> cxt -> term K -> result K -> type.


%{
 Type checking arguments

 One issue we need to consider is aliasing between unique arguments.
 For instance, if a method is annotated as "reads a.f, writes b.f", and
 a and b are aliases to each other, then we cannot check the call.

 Given this situation doesn't occur very often, here we just simply
 disallow "duplicated" effects while checking method call effects.
}%

reftyping/args : clsmap -> methmap ->
	cxt -> effects -> args -> args-result -> type.

reftyping/args/0 : reftyping/args _ _ _ XX args/0 (result/args/0 XX).

reftyping/args/+
  : reftyping/args CM MM B XX1 (args/+ E A) (result/args/+ RT AO)
    <- effects`join XX1 XX2 XX
    <- reftyping CM MM B E (result/expr RT XX2)
    <- reftyping/args CM MM B XX A AO.


%%% Call Typing

ref-calltyping : clsmap -> effects ->
	args-result -> methty -> expr-result -> type.

ref-calltyping/call/unique
  : ref-calltyping CM XX1 (result/args/0 XX0)
    (methty/base (ty/ NN annot/unique C) SX)
    (result/expr (reftype/ NN C (targets/unique set/0 set/0 false)) XX)
    <- effects`disjoint XX0 XX1
    <- effects`join XX0 XX1 XX01
    <- effects`join XX01 (effects/ efxmap/0 set/0 SX set/0) XX.

ref-calltyping/call/shared
  : ref-calltyping CM XX1 (result/args/0 XX0)
    (methty/base (ty/ NN annot/shared C) SX)
    (result/expr (reftype/ NN C targets/shared) XX)
    <- effects`disjoint XX0 XX1
    <- effects`join XX0 XX1 XX01
    <- effects`join XX01 (effects/ efxmap/0 set/0 SX set/0) XX.

ref-calltyping/args
  : ref-calltyping
    CM XX0 (result/args/+ RT A0) (methty/arg T Rs Ws MT) (result/expr ART XX)
    <- subtype CM RT T Rs Ws XX1
    <- effects`disjoint XX0 XX1
    <- effects`join XX0 XX1 XX01
    <- ref-calltyping CM XX01 A0 MT (result/expr ART XX).


%%% Checking Literals

reftyping/lit
  : reftyping _ _ B (lit O) (result/expr RT no-effect)
    <- cxt`lookup B O T
    <- object-index O N
    <- ty2reftype N T RT.

%{
reftyping/null
  : reftyping _ _ _ (lit null) (result/expr reftype/null no-effect).
}%



%%% Type Rules with Direct Effect

reftyping/read
  : reftyping CM MM B E (result/expr (reftype/ nn/yes C G) XX1)
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN A FC)
    -> make-targets-and-effects G F efx/read G' (effects/ M set/0 SX set/0)
    -> consider-ftype G' A GP
    -> effects`join XX1 (effects/ M set/0 SX set/0) XX
    -> reftyping CM MM B (read E F) (result/expr (reftype/ NN FC GP) XX).


% make sure effects XX6 does not uses any permission from
% those encumbered by targets from E1.

reftyping/write
  : reftyping CM MM B E1 (result/expr (reftype/ nn/yes C G) XX1)
    -> reftyping CM MM B E2 (result/expr RT XX2)
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN A FC)
    -> make-targets-and-effects G F efx/write G' (effects/ M3 set/0 SX3 set/0)
    -> consider-ftype G' A GP
    -> subtype CM RT (ty/ NN A FC) set/0 set/0 XX4
    -> effects`join XX1 (effects/ M3 set/0 SX3 set/0) XX5
    -> effects`join XX2 XX4 XX6
    -> effects`join XX5 XX6 XX7
    -> compatible G' XX6
    -> reftyping CM MM B (write E1 F E2) (result/expr (reftype/ NN FC GP) XX7).


% Note: to handle reftype/null

reftyping/let
  : reftyping CM MM B E (result/expr (reftype/ NN C GS) XX1)
    -> reftype2ty (reftype/ NN C GS) (ty/ NN A C)
    -> ({n}{x}{_:object-index x n}
         reftyping CM MM (cxt/cons x (ty/ NN A C) B) (F x)
         (result/expr (reftype/ NN2 C2 (GS2 n)) (XX2 n)))
    -> ({n} compatible GS (XX2 n))
    -> ({n} subst-targets GS n (GS2 n) GS3)
    -> ({n} subst-effects GS n (XX2 n) XX3)
    -> effects`join XX1 XX3 XX
    -> reftyping CM MM B (let E F) (result/expr (reftype/ NN2 C2 GS3) XX).



%%% Type Rules with Indirect Effects

% Note:
% 06-16-13: needs reftyping/sub to check this

%{
reftyping/if
  : reftyping CM MM B C (result/cond XXC)
    -> reftyping CM MM B E1 (result/expr RT XXE)
    -> reftyping CM MM B E2 (result/expr RT XXE)
    -> effects`join XXC XXE XX
    -> reftyping CM MM B (if C E1 E2) (result/expr RT XX).
}%


%{
no-consume-effect : effects -> type. % To be defined later

reftyping/while
  : reftyping CM MM B C (result/cond XX1)
    -> reftyping CM MM B E (result/expr _ XX2)
    -> no-consume-effect XX2
    -> effects`join XX1 XX2 XX
    -> reftyping CM MM B (while C E) (result/expr reftype/null XX).
}%


%%% Conditionals

reftyping/eq : reftyping CM MM B E1 (result/expr _ XX1)
               -> reftyping CM MM B E2 (result/expr _ XX2)
               -> effects`join XX1 XX2 XX
               -> reftyping CM MM B (eql E1 E2) (result/cond XX).

reftyping/not : reftyping CM MM B (not C) R
                -> reftyping CM MM B C R.

reftyping/and : reftyping CM MM B C1 (result/cond XX1)
                -> reftyping CM MM B C2 (result/cond XX2)
                -> effects`join XX1 XX2 XX
                -> reftyping CM MM B (and C1 C2) (result/cond XX).


%%% Arguments

% reftyping/args/0 : reftyping L _ _ _ args/0 result/args/0 L.

% reftyping/args/+
%   : reftyping L1 CM MM B E (result/expr RT XX) L2
%     -> reftyping L2 CM MM B A R L3
%     -> reftyping L1 CM MM B (args/+ E A) (result/args/+ (result/expr RT XX) R) L3.


%%% Method Calls

%{
reftyping/call
  : clsmap`fresh CM M
    -> methmap`lookup MM M MT
    -> reftyping/args CM MM B no-effect A AR
    -> ref-calltyping CM no-effect AR MT R
    -> reftyping CM MM B (call M A) R.
}%


%{
reftyping/const
  : clsmap`lookup CM C FM
    -> fldmap`domain FM S
    -> methmap`lookup MM C (methty/arg _ _ _ MT)
    -> reftyping/args CM MM B no-effect A AO
    -> ref-calltyping CM no-effect AO MT (result/expr RT XX)
    -> reftyping CM MM B (call C (args/+ (alloc C S set/0) A)) (result/expr RT XX).
}%



%%% Method Typing

% Checking method type against func

methtymatch* : efxmap -> set ->
	clsmap -> methmap -> cxt -> func -> methty -> type.

% if we have sub rule, then RT should match T,
% hence subtype will not be needed.

% methtymatch/base
%   : methtymatch* M S CM MM B (func/0 E) (methty/base T SX)
%     <- reftype2ty RT T
%     <- reftyping CM MM B E (result/expr RT (effects/ M SX)).

% methtymatch/args/unique
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/unique C) set/0 set/0 MT)
%     <- ({n} set`add S n (SF n))
%     <- ({n}{x}{_:object-index x n} methtymatch*
%          M (SF n) CM MM (cxt/cons x (ty/ N annot/unique C) B) (F x) MT).

% methtymatch/args/borrow
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/borrow C) Rs Ws MT)
%     <- ({n} nat+set2set n Rs (R n))
%     <- ({n} nat+set2set n Ws (W n))
%     <- ({n} set2efxmap (R n) efx/read (MR n))
%     <- ({n} set2efxmap (W n) efx/read (MW n))
%     <- ({n} efxmap`join (MR n) (MW n) (MF n))
%     <- ({n}{x}{_:object-index x n} methtymatch*
%          (MF n) S CM MM (cxt/cons x (ty/ NN annot/borrow C) B) (F x) MT).

% methtymatch/args/shared
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/shared C) set/0 set/0 MT)
%     <- ({x} methtymatch* M S CM MM (cxt/cons x (ty/ NN annot/shared C) B) (F x) MT).

%abbrev methtymatch = [CM][MM][F][MT] methtymatch* efxmap/0 set/0 CM MM cxt/nil F MT.


constyping* : effects -> clsmap -> methmap -> fldmap
    -> cxt -> set -> (object -> expr) -> effects -> type.

% constyping/0 : constyping* XX _ _ _ _ set/0 ([t] lit t) XX.

% constyping/nn
%   : constyping* XX1 CM MM FM B S ([t] seq (write (lit t) F E) (EF t)) XX
%     <- fldmap`lookup FM F (ty/ nn/yes A C)
%     <- set`remove S (set/1 F) SP
%     <- reftype2ty RT (ty/ nn/yes A C)
%     <- reftyping CM MM B E (result/expr RT XX2)
%     <- effects`join XX1 XX2 XX12
%     <- constyping* XX12 CM MM FM B SP ([t] EF t) XX.

% constyping/mn
%   : constyping* XX1 CM MM FM B S ([t] seq (write (lit t) F E) (EF t)) XX
%     <- fldmap`lookup FM F (ty/ nn/may A C)
%     <- reftype2ty RT (ty/ nn/may A C)
%     <- reftyping CM MM B E (result/expr RT XX2)
%     <- effects`join XX1 XX2 XX12
%     <- constyping* XX12 CM MM FM B S ([t] EF t) XX.

%abbrev constyping = [CM][MM][FM][B][S][E][XX] constyping* no-effect CM MM FM B S E XX.


% the first set is accumulated consumed objects, the second set is all nonnull fields.

constymatch*
  : efxmap -> set -> clsmap -> methmap -> fldmap
    -> cxt -> set -> (object -> func) -> methty -> type.

% constymatch/base
%   : constymatch* M S CM MM FM B FS ([t] func/0 (E t))
%     (methty/base (ty/ nn/yes annot/unique C) SX)
%     <- constyping CM MM FM B FS ([t] E t) (effects/ M SX).

% constymatch/args/unique
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/unique C) set/0 set/0 CT)
%     <- ({n} set`add S n (SF n))
%     <- ({n}{x}{_:object-index x n} constymatch* M (SF n)
%          CM MM FM (cxt/cons x (ty/ NN annot/unique C) B) FS ([t] (F t x)) CT).

% constymatch/args/borrow
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/borrow C) set/0 set/0 CT)
%     <- ({n} nat+set2set n Rs (R n))
%     <- ({n} nat+set2set n Ws (W n))
%     <- ({n} set2efxmap (R n) efx/read (MR n))
%     <- ({n} set2efxmap (W n) efx/read (MW n))
%     <- ({n} efxmap`join (MR n) (MW n) (MF n))
%     <- ({n}{x}{_:object-index x n} constymatch* (MF n) S CM MM FM
%          (cxt/cons x (ty/ NN annot/borrow C) B) FS ([t] (F t x)) CT).

% constymatch/args/shared
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/shared C) set/0 set/0 CT)
%     <- ({x} constymatch* M S CM MM FM
%          (cxt/cons x (ty/ NN annot/shared C) B) FS ([t] (F t x)) CT).

%abbrev constymatch
  = [CM][MM][FM][S][F][CT] constymatch* efxmap/0 set/0 CM MM FM cxt/nil S F CT.



%%% Program Typing: checking method map against prog


select-fields : fldmap -> set -> type.

select-fields/0 : select-fields fldmap/0 set`set/0.

select-fields/+/in
  : select-fields (fldmap/+ F (ty/ nn/yes _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S'
    <- set`union S' (set/1 F) S.

select-fields/+/result
  : select-fields (fldmap/+ F (ty/ nn/may _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S.


methmapmatch* : clsmap -> methmap -> methmap -> prog -> type.

methmapmatch/0 : methmapmatch* _ _ methmap/0 prog`map/0.

methmapmatch/+/const
  : methmapmatch* CM MM0
    (methmap/+ C (methty/arg (ty/ nn/yes _ C) _ _ CT) MM)
    (prog`map/+ C (func/+ ([t] FF t)) M)
    <- clsmap`lookup CM C FM
    <- select-fields FM S
    <- constymatch CM MM0 FM S FF CT
    <- methmap`shift C MM MM'
    <- prog`shift C M M'
    <- methmapmatch* CM MM0 MM' M'.

methmapmatch/+/meth
  : methmapmatch* CM MM0
    (methmap/+ N MT MM) (prog`map/+ N FUN M)
    <- clsmap`fresh CM N
    <- methtymatch CM MM0 FUN MT
    <- methmap`shift N MM MM'
    <- prog`shift N M M'
    <- methmapmatch* CM MM0 MM' M'.

%abbrev methmapmatch = [CM][MM][G] methmapmatch* CM MM MM G.


%%% Theorems

%theorem result/expr-respects-eq
  : forall* {RT1} {RT2} {X1} {X2}
    forall {TE: reftype`eq RT1 RT2} {XE: effects`eq X1 X2}
    exists {RE: result`eq (result/expr RT1 X1) (result/expr RT2 X2)}
    true.

- : result/expr-respects-eq reftype`eq/ effects`eq/ result`eq/.

%worlds () (result/expr-respects-eq _ _ _).
%total {} (result/expr-respects-eq _ _ _).


%theorem reftyping-respects-eq
  : forall* {CM} {CM'} {MM} {MM'} {B} {B'} {E:expr} {E':expr} {R} {R'}
    forall {RTYP: reftyping CM MM B E R}
    {CME: clsmap`eq CM CM'} {MME: methmap`eq MM MM'}
    {BE: cxt`eq B B'} {EE: expr`eq E E'} {RE: result`eq R R'}
    exists {RTYP': reftyping CM' MM' B' E' R'}
    true.

- : reftyping-respects-eq RTYP clsmap`eq/ methmap`eq/ cxt`eq/
    expr`eq/ result`eq/ RTYP.

%worlds () (reftyping-respects-eq _ _ _ _ _ _ _).
%total {} (reftyping-respects-eq _ _ _ _ _ _ _).