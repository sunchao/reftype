%%% Type judgments for conservative type system based on FP.

%%% Definitions


cxt-remove-consume : cxt -> set -> cxt -> type.

cxt-remove-consume/0 : cxt-remove-consume cxt/0 _ cxt/0.

cxt-remove-consume/U
  : cxt-remove-consume B S' B'
    -> cxt`lookup B' N (cxt-info/ O (ty/ NN annot/unique C))
    -> cxt`update B' N (cxt-info/ O (ty/ NN annot/borrow C)) B''
    -> set`not-member S' N
    -> set`add S' N S
    -> cxt-remove-consume B S B''.


env-remove-consume : env -> capmap -> env -> type.

env-remove-consume/
  : cxt-remove-consume B M B'
    -> capmap-split M0 M1 M2
    -> env-remove-consume (env/ B M0) M1 (env/ B' M2).



%%% Type Checking Rules

reftyping : nat -> clsmap -> methmap -> env -> term K -> result K -> type.

letRefTyping : nat -> clsmap -> methmap -> expr-result ->
    expr -> expr-result -> type.

letRefTyping/base :
    reftyping N CM MM V E R ->
  letRefTyping N CM MM (result/expr RT V) E R.

letRefTyping/exists :
    ({x} letRefTyping N CM MM (V x) E (R x)) ->
  letRefTyping N CM MM (result/exists [x] (V x)) E (result/exists [x] (V x)).


%{
 Type checking arguments

 One issue we need to consider is aliasing between unique arguments.
 For instance, if a method is annotated as "reads a.f, writes b.f", and
 a and b are aliases to each other, then we cannot check the call.

 Given this situation doesn't occur very often, here we just simply
 disallow "duplicated" cap while checking method call effects.
}%

% reftyping/args : nat -> clsmap -> methmap ->
% 	cxt -> effects -> args -> args-result -> type.

% reftyping/args/0 : reftyping/args _ _ _ _ XX args/0 (result/args/0 XX).

% reftyping/args/+
%   : reftyping/args N CM MM B XX1 (args/+ E A) (result/args/+ RT AO)
%     <- effects`join XX1 XX2 XX
%     <- reftyping N CM MM B E (result/expr RT XX2)
%     <- reftyping/args N CM MM B XX A AO.


%%% Call Typing

% ref-calltyping : clsmap -> effects ->
% 	args-result -> methty -> expr-result -> type.

% ref-calltyping/call/unique
%   : ref-calltyping CM XX1 (result/args/0 XX0)
%     (methty/base (ty/ NN annot/unique C))
%     (result/expr (reftype/ NN C (targets/unique set/0 set/0)) XX)
%     <- effects`disjoint XX0 XX1
%     <- effects`join XX0 XX1 XX01
%     <- effects`join XX01 (effects/ efxmap/0 set/0 set/0) XX.

% ref-calltyping/call/shared
%   : ref-calltyping CM XX1 (result/args/0 XX0)
%     (methty/base (ty/ NN annot/shared C))
%     (result/expr (reftype/ NN C targets/shared) XX)
%     <- effects`disjoint XX0 XX1
%     <- effects`join XX0 XX1 XX01
%     <- effects`join XX01 (effects/ efxmap/0 set/0 set/0) XX.

% ref-calltyping/args
%   : ref-calltyping CM XX0 (result/args/+ RT A0)
%     (methty/arg T XMd MT) (result/expr ART XX)
%     <- subtype CM RT T XMd XX1
%     <- effects`disjoint XX0 XX1
%     <- effects`join XX0 XX1 XX01
%     <- ref-calltyping CM XX01 A0 MT (result/expr ART XX).


%%% Checking Literals

% reftyping/lit
%   : Reftyping _ _ _ B (lit O) (result/expr RT no-effect)
%     <- cxt`lookup-obj B O N T
%     <- ty2reftype N T RT.


%%% Type Rules with Direct Effect

%%% ========================== READ ============================== %%%

reftyping-helper/read : clsmap -> expr-result -> nat -> expr-result -> type.

reftyping-helper/read/base :
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F (ty/ NN A FC) ->
    make-tgts-and-caps M0 G0 F cap/read G1 M1 ->
    consider-ftype G1 M1 A G2 M2 ->
  reftyping-helper/read CM (result/expr (reftype/ nn/yes C G0) (env/ B0 M0)) F
    (result/expr (reftype/ NN FC G2) (env/ B0 M2)).

reftyping-helper/read/exists :
    ({v} reftyping-helper/read CM (In v) F (Rslt v)) ->
  reftyping-helper/read CM (result/exists In) F (result/exists Rslt).

reftyping/read :
    reftyping N CM MM V E Rslt ->
    reftyping-helper/read CM Rslt F Rslt2 ->
  reftyping N CM MM V (read E F) Rslt2.


%%% ========================== WRITE ============================== %%%

% reftyping-helper/write : clsmap -> expr-result -> nat -> targets -> ty -> expr-result -> type.

% reftyping-helper/write/base :
%     clsmap`lookup CM C FM ->
%     fldmap`lookup FM F (ty/ NN A FC) ->
%     make-tgts-and-caps M0 G0 F cap/read G1 M1 ->
%   reftyping-helper/write CM (result/expr (reftype/ nn/yes C G0) (env/ B0 M0)) F
%     G1 (ty/ NN A FC) (result/expr (reftype/ NN FC G2) (env/ B0 M1)).

% reftyping-helper/write/exists :
%     ({v} reftyping-helper/write CM (In v) F G T (Rslt v)) ->
%   reftyping-helper/write CM (result/exists In) F G T (result/exists Rslt).

% reftyping-helper/write/2 : clsmap -> targets -> ty -> expr-result -> expr-result -> type.

% reftyping-helper/write/2/base :
%     subtype CM RT V2 (ty/ NN A FC) (env/ B2 M3) ->
%     consider-ftype G1 M3 A G2 M4 ->
%   reftyping-helper/write/2 CM G1 (ty/ NN A FC) (result/expr RT V2)
%         (result/expr (reftype/ NN FC G2) (env/ B2 M4)).

% reftyping-helper/write/2/exists :
%     ({x} reftyping-helper/write/2 CM G T (R x) (R2 x)) ->
%   reftyping-helper/write/2 CM G T (result/exists [x] (R x)) (result/exists [x] (R2 x)).

% reftyping/write
%   : reftyping N CM MM V1 E1 Rslt1
%     -> reftyping-helper/write CM Rslt1 F G T Rslt2
%     -> letRefTyping N CM MM Rslt2 E2 Rslt3
%     -> reftyping-helper/write/2 CM G T Rslt3 Rslt4
%     -> reftyping N CM MM V1 (write E1 F E2) Rslt4.

% reftyping/write
%   : reftyping N CM MM V1 E1 (result/expr (reftype/ nn/yes C G0) (env/ B0 M0))
%     -> clsmap`lookup CM C FM
%     -> fldmap`lookup FM F (ty/ NN A FC)
%     -> make-tgts-and-caps M0 G0 F cap/write G1 M1 % wrong: can't release yet
%     -> reftyping N CM MM (env/ B0 M1) E2 (result/expr RT V2)
%     -> subtype CM RT V2 (ty/ NN A FC) (env/ B2 M3)
%     -> consider-ftype G1 M3 A G2 M4
%     -> reftyping N CM MM V1 (write E1 F E2)
%       (result/expr (reftype/ NN FC G2) (env/ B2 M4)).


%%% Type Rules with Indirect Effects

%% should NOT use reftype2ty

% reftyping/let
%    : reftyping N CM MM B E (result/expr (reftype/ NN C GS) XX1)
%      -> reftype2ty (reftype/ NN C GS) (ty/ NN A C)
%      -> ({x} cxt`update B N (cxt-info/ x (ty/ NN A C)) (BF x))
%      -> ({x} reftyping (s N) CM MM (BF x) (F x)
%           (result/expr (reftype/ NN2 C2 GS2) XX2))
%      -> compatible CM B GS XX2
%      -> subst-targets GS N GS2 GS3
%      -> subst-effects CM B NN GS N XX2 XX3
%      -> effects`join XX1 XX3 XX
%      -> reftyping N CM MM B (let E F) (result/expr (reftype/ NN2 C2 GS3) XX).

%{
reftyping/if
  : reftyping CM MM B C (result/cond XXC)
    -> reftyping CM MM B E1 (result/expr RT XXE)
    -> reftyping CM MM B E2 (result/expr RT XXE)
    -> effects`join XXC XXE XX
    -> reftyping CM MM B (if C E1 E2) (result/expr RT XX).
}%


%{
no-consume-effect : effects -> type. % To be defined later

reftyping/while
  : reftyping CM MM B C (result/cond XX1)
    -> reftyping CM MM B E (result/expr _ XX2)
    -> no-consume-effect XX2
    -> effects`join XX1 XX2 XX
    -> reftyping CM MM B (while C E) (result/expr reftype/null XX).
}%


%%% Conditionals

% reftyping/eq : reftyping N CM MM B E1 (result/expr _ XX1)
%                -> reftyping N CM MM B E2 (result/expr _ XX2)
%                -> effects`join XX1 XX2 XX
%                -> reftyping N CM MM B (eql E1 E2) (result/cond XX).

% reftyping/not : reftyping N CM MM B (not C) R
%                 -> reftyping N CM MM B C R.

% reftyping/and : reftyping N CM MM B C1 (result/cond XX1)
%                 -> reftyping N CM MM B C2 (result/cond XX2)
%                 -> effects`join XX1 XX2 XX
%                 -> reftyping N CM MM B (and C1 C2) (result/cond XX).


%%% Arguments

% reftyping/args/0 : reftyping L _ _ _ args/0 result/args/0 L.

% reftyping/args/+
%   : reftyping L1 CM MM B E (result/expr RT XX) L2
%     -> reftyping L2 CM MM B A R L3
%     -> reftyping L1 CM MM B (args/+ E A) (result/args/+ (result/expr RT XX) R) L3.


%%% Method Calls

%{
reftyping/call
  : clsmap`fresh CM M
    -> methmap`lookup MM M MT
    -> reftyping/args CM MM B no-effect A AR
    -> ref-calltyping CM no-effect AR MT R
    -> reftyping CM MM B (call M A) R.
}%


%{
reftyping/const
  : clsmap`lookup CM C FM
    -> fldmap`domain FM S
    -> methmap`lookup MM C (methty/arg _ _ _ MT)
    -> reftyping/args CM MM B no-effect A AO
    -> ref-calltyping CM no-effect AO MT (result/expr RT XX)
    -> reftyping CM MM B (call C (args/+ (alloc C S set/0) A)) (result/expr RT XX).
}%



%%% Method Typing

% Checking method type against func

% methtymatch* : efxmap -> set ->
% 	clsmap -> methmap -> cxt -> func -> methty -> type.

% if we have sub rule, then RT should match T,
% hence subtype will not be needed.

% methtymatch/base
%   : methtymatch* M S CM MM B (func/0 E) (methty/base T SX)
%     <- reftype2ty RT T
%     <- reftyping CM MM B E (result/expr RT (effects/ M SX)).

% methtymatch/args/unique
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/unique C) set/0 set/0 MT)
%     <- ({n} set`add S n (SF n))
%     <- ({n}{x}{_:object-index x n} methtymatch*
%          M (SF n) CM MM (cxt/cons x (ty/ N annot/unique C) B) (F x) MT).

% methtymatch/args/borrow
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/borrow C) Rs Ws MT)
%     <- ({n} nat+set2set n Rs (R n))
%     <- ({n} nat+set2set n Ws (W n))
%     <- ({n} set2efxmap (R n) efx/read (MR n))
%     <- ({n} set2efxmap (W n) efx/read (MW n))
%     <- ({n} efxmap`join (MR n) (MW n) (MF n))
%     <- ({n}{x}{_:object-index x n} methtymatch*
%          (MF n) S CM MM (cxt/cons x (ty/ NN annot/borrow C) B) (F x) MT).

% methtymatch/args/shared
%   : methtymatch* M S CM MM B (func/+ F)
%     (methty/arg (ty/ NN annot/shared C) set/0 set/0 MT)
%     <- ({x} methtymatch* M S CM MM (cxt/cons x (ty/ NN annot/shared C) B) (F x) MT).

% %abbrev methtymatch = [CM][MM][F][MT] methtymatch* efxmap/0 set/0 CM MM cxt/0 F MT.


% constyping* : effects -> clsmap -> methmap -> fldmap
%     -> cxt -> set -> (object -> expr) -> effects -> type.

% constyping/0 : constyping* XX _ _ _ _ set/0 ([t] lit t) XX.

% constyping/nn
%   : constyping* XX1 CM MM FM B S ([t] seq (write (lit t) F E) (EF t)) XX
%     <- fldmap`lookup FM F (ty/ nn/yes A C)
%     <- set`remove S (set/1 F) SP
%     <- reftype2ty RT (ty/ nn/yes A C)
%     <- reftyping CM MM B E (result/expr RT XX2)
%     <- effects`join XX1 XX2 XX12
%     <- constyping* XX12 CM MM FM B SP ([t] EF t) XX.

% constyping/mn
%   : constyping* XX1 CM MM FM B S ([t] seq (write (lit t) F E) (EF t)) XX
%     <- fldmap`lookup FM F (ty/ nn/may A C)
%     <- reftype2ty RT (ty/ nn/may A C)
%     <- reftyping CM MM B E (result/expr RT XX2)
%     <- effects`join XX1 XX2 XX12
%     <- constyping* XX12 CM MM FM B S ([t] EF t) XX.

% %abbrev constyping
%   = [CM][MM][FM][B][S][E][XX] constyping* no-effect CM MM FM B S E XX.


% the first set is accumulated consumed objects, the second set is all nonnull fields.

% constymatch*
%   : efxmap -> set -> clsmap -> methmap -> fldmap
%     -> cxt -> set -> (object -> func) -> methty -> type.

% constymatch/base
%   : constymatch* M S CM MM FM B FS ([t] func/0 (E t))
%     (methty/base (ty/ nn/yes annot/unique C) SX)
%     <- constyping CM MM FM B FS ([t] E t) (effects/ M SX).

% constymatch/args/unique
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/unique C) set/0 set/0 CT)
%     <- ({n} set`add S n (SF n))
%     <- ({n}{x}{_:object-index x n} constymatch* M (SF n)
%          CM MM FM (cxt/cons x (ty/ NN annot/unique C) B) FS ([t] (F t x)) CT).

% constymatch/args/borrow
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/borrow C) set/0 set/0 CT)
%     <- ({n} nat+set2set n Rs (R n))
%     <- ({n} nat+set2set n Ws (W n))
%     <- ({n} set2efxmap (R n) efx/read (MR n))
%     <- ({n} set2efxmap (W n) efx/read (MW n))
%     <- ({n} efxmap`join (MR n) (MW n) (MF n))
%     <- ({n}{x}{_:object-index x n} constymatch* (MF n) S CM MM FM
%          (cxt/cons x (ty/ NN annot/borrow C) B) FS ([t] (F t x)) CT).

% constymatch/args/shared
%   : constymatch* M S CM MM FM B FS ([t] (func/+ ([o] F t o)))
%     (methty/arg (ty/ NN annot/shared C) set/0 set/0 CT)
%     <- ({x} constymatch* M S CM MM FM
%          (cxt/cons x (ty/ NN annot/shared C) B) FS ([t] (F t x)) CT).

% %abbrev constymatch
%   = [CM][MM][FM][S][F][CT] constymatch* efxmap/0 set/0 CM MM FM cxt/0 S F CT.



%%% Program Typing: checking method map against prog


% select-fields : fldmap -> set -> type.

% select-fields/0 : select-fields fldmap/0 set`set/0.

% select-fields/+/in
%   : select-fields (fldmap/+ F (ty/ nn/yes _ _) M) S
%     <- fldmap`shift F M M'
%     <- select-fields M' S'
%     <- set`union S' (set/1 F) S.

% select-fields/+/result
%   : select-fields (fldmap/+ F (ty/ nn/may _ _) M) S
%     <- fldmap`shift F M M'
%     <- select-fields M' S.


% methmapmatch* : clsmap -> methmap -> methmap -> prog -> type.

% methmapmatch/0 : methmapmatch* _ _ methmap/0 prog`map/0.

% methmapmatch/+/const
%   : methmapmatch* CM MM0
%     (methmap/+ C (methty/arg (ty/ nn/yes _ C) _ CT) MM)
%     (prog`map/+ C (func/+ ([t] FF t)) M)
%     <- clsmap`lookup CM C FM
%     <- select-fields FM S
%     <- constymatch CM MM0 FM S FF CT
%     <- methmap`shift C MM MM'
%     <- prog`shift C M M'
%     <- methmapmatch* CM MM0 MM' M'.

% methmapmatch/+/meth
%   : methmapmatch* CM MM0
%     (methmap/+ N MT MM) (prog`map/+ N FUN M)
%     <- clsmap`fresh CM N
%     <- methtymatch CM MM0 FUN MT
%     <- methmap`shift N MM MM'
%     <- prog`shift N M M'
%     <- methmapmatch* CM MM0 MM' M'.

% %abbrev methmapmatch = [CM][MM][G] methmapmatch* CM MM MM G.


%%% Theorems

% %theorem result/expr-respects-eq
%   : forall* {RT1} {RT2} {X1} {X2}
%     forall {TE: reftype`eq RT1 RT2} {XE: effects`eq X1 X2}
%     exists {RE: result`eq (result/expr RT1 X1) (result/expr RT2 X2)}
%     true.

% - : result/expr-respects-eq reftype`eq/ effects`eq/ result`eq/.

% %worlds () (result/expr-respects-eq _ _ _).
% %total {} (result/expr-respects-eq _ _ _).


% %theorem reftyping-respects-eq
%   : forall* {N} {N'} {CM} {CM'} {MM} {MM'} {B} {B'} {E:expr} {E':expr} {R} {R'}
%     forall {RTYP: reftyping N CM MM B E R} {NE: nat`eq N N'}
%     {CME: clsmap`eq CM CM'} {MME: methmap`eq MM MM'}
%     {BE: cxt`eq B B'} {EE: expr`eq E E'} {RE: result`eq R R'}
%     exists {RTYP': reftyping N' CM' MM' B' E' R'}
%     true.

% - : reftyping-respects-eq RTYP nat`eq/ clsmap`eq/ methmap`eq/ cxt`eq/
%     expr`eq/ result`eq/ RTYP.

% %worlds () (reftyping-respects-eq _ _ _ _ _ _ _ _).
% %total {} (reftyping-respects-eq _ _ _ _ _ _ _ _).