%%% Type judgments for conservative type system based on FP.
%%% $Id: typing.elf,v 1.1 2013/03/04 21:39:55 csun Exp $

%%% abbreviations

%abbrev null = (object/ nat`z).	% null object

%abbrev all = nat`z. % special 'All' field

%abbrev loc = nat. % location

%abbrev efxmap/1 : nat -> nat -> efx -> efxmap 
  = [L][F][X] (efxmap/+ L (inner-efxmap/+ F X inner-efxmap/0) efxmap/0).


% whether there is a effect on shared

maybe-efx : type.

maybe-efx/just : efx -> maybe-efx. 

maybe-efx/nothing : maybe-efx.


maybe-efx-join : maybe-efx -> maybe-efx -> maybe-efx -> type.

maybe-efx-join/1
  : maybe-efx-join (maybe-efx/just X) maybe-efx/nothing (maybe-efx/just X).

maybe-efx-join/2
  : maybe-efx-join maybe-efx/nothing (maybe-efx/just X)  (maybe-efx/just X).

maybe-efx-join/3
  : maybe-efx-join
    (maybe-efx/just X1) (maybe-efx/just X2) (maybe-efx/just X3)
    <- efx`join X1 X2 X3.

maybe-efx-leq : maybe-efx -> maybe-efx -> type.

maybe-efx-leq/1 : maybe-efx-leq maybe-efx/nothing (maybe-efx/just _).

maybe-efx-leq/2
  : maybe-efx-leq (maybe-efx/just X1) (maybe-efx/just X2)
    <- efx`leq X1 X2.


%%% output for type checking

out : kind -> type.

%abbrev expr-out = out exprk.

%abbrev cond-out = out condk.

%abbrev args-out = out argsk.


out/expr : reftype -> efxmap -> maybe-efx -> expr-out.

out/cond : efxmap -> maybe-efx -> cond-out.

out/args/0 : args-out.

out/args/+ : expr-out -> args-out -> args-out.

%abbrev reftgts/1 = [N] (reftgts/unique (set/1 N) tgtmap/0).



%%% type judgments

ref-typing : loc -> clsmap -> methmap -> cxt -> term K -> out K -> loc -> type.

ref-calltyping : loc -> clsmap -> args-out -> methty -> expr-out -> type.

% The declared effects use numbers for the formal parameters,
% so here we need to map them to the numbers of acutal parameters.
ref-calltyping/call/shared
  : ref-calltyping _ _ out/args/0 (methty/base (ty/ NN annot/shared C))
    (out/expr
      (reftype/ (ty/ NN annot/shared C) 
        reftgts/shared) efxmap/0 maybe-efx/nothing).

ref-calltyping/call/unique
  : ref-calltyping L _ out/args/0 (methty/base (ty/ NN annot/unique C))
    (out/expr
      (reftype/ (ty/ NN annot/unique C) 
        (reftgts/1 L)) efxmap/0 maybe-efx/nothing).

%{% R and W are sets of fields being read and write, respectively.
  here the order of efxmap`join matters: the effects of evaluating
  arguments should occur first, and then the effects generated
  by evaluating the method call. %}%

reftype-extend-rw : clsmap -> ty -> reftype -> set -> set -> efxmap -> type.

reftype-extend-rw/shared
  : reftype-extend-rw _ (ty/ NN annot/shared C)
    (reftype/ (ty/ NN annot/shared C) reftgts/shared) _ _ efxmap/0.

%{% all object targets in S are consumed, meaning consume effects on
 all fields of the object targets. %}%
reftype-extend-rw/unique
  : reftype-extend-rw CM (ty/ NN annot/unique C)
    (reftype/ (ty/ NN annot/unique C) (reftgts/unique S GM)) R W XM
    <- clsmap`lookup CM C FM
    <- fldmap`domain FM FS
    <- set+set2tgtmap S FS FGM
    <- tgtmap`join FGM GM GMP
    <- tgtmap2efxmap GMP efx/consume XM.
      
reftype-extend-rw/borrow 
  : reftype-extend-rw _ (ty/ NN annot/borrow C) 
    (reftype/ (ty/ NN annot/unique C) (reftgts/unique S GM)) R W XM
    <- set+set2tgtmap S R RGM
    <- set+set2tgtmap S W WGM
    <- tgtmap`join RGM GM RGMP
    <- tgtmap`join WGM GM WGMP
    <- tgtmap2efxmap RGMP efx/read RXM
    <- tgtmap2efxmap WGMP efx/write WXM
    <- efxmap`join RXM WXM XM.

ref-calltyping/args
  : ref-calltyping L CM (out/args/+ (out/expr RT XM MX) AO)
    (methty/arg A T R W) (out/expr ART OXM OMX)
    <- ref-calltyping L CM AO A (out/expr ART AXM AMX)
    <- reftype-extend-rw CM T RT R W RWXM
    <- efxmap`join XM AXM XMP
    <- efxmap`join XMP RWXM OXM
    <- maybe-efx-join MX AMX OMX.


%%% expressions

ref-typing/lit/unique
  : ref-typing L _ _ B (lit O) 
    (out/expr (reftype/ T (reftgts/unique (set/1 N) tgtmap/0)) 
      efxmap/0 maybe-efx/nothing) L
    <- cxt-lookup B O (vtype/unique N) T.

ref-typing/lit/shared
  : ref-typing L _ _ B (lit O) 
    (out/expr (reftype/ T reftgts/shared) efxmap/0 maybe-efx/nothing) L
    <- cxt-lookup B O (vtype/shared) T.
    

ref-typing/null
 : ref-typing L _ _ _ (lit null)
   (out/expr reftype/null efxmap/0 maybe-efx/nothing) L.


read-type
  : reftgts -> nat -> annot -> efx -> reftgts -> efxmap -> maybe-efx -> type.

read-type/s_
  : read-type reftgts/shared _ _ X reftgts/shared efxmap/0 (maybe-efx/just X).
    
read-type/us
  : read-type (reftgts/unique S GM) 
    F annot/shared X reftgts/shared XM maybe-efx/nothing
    <- tgtmap`domain GM SP
    <- set`disjoint S SP
    <- set+nat2tgtmap S F GMP
    <- tgtmap`join GM GMP GMS
    <- tgtmap2efxmap GMS X XM.

read-type/uu
  : read-type (reftgts/unique S GM) 
    F annot/unique X (reftgts/unique set/0 GMS) XM maybe-efx/nothing
    <- tgtmap`domain GM SP
    <- set`disjoint S SP
    <- set+nat2tgtmap S F GMP
    <- tgtmap`join GM GMP GMS
    <- tgtmap2efxmap GMS X XM.


ref-typing/read
  : ref-typing L1 CM MM B (read E F)
    (out/expr (reftype/ (ty/ NN A FC) GP) XM MX) L2
    <- ref-typing L1 CM MM B E
      (out/expr (reftype/ (ty/ nn/yes _ C) G) XM1 MX1) L2
    <- clsmap`lookup CM C FM
    <- fldmap`lookup FM F (ty/ NN A FC)
    <- read-type G F A efx/read GP XM2 MX2
    <- efxmap`join XM1 XM2 XM
    <- maybe-efx-join MX1 MX2 MX.

%{% When checking E2, all permissions for E1.F will
 be encumbered and not available. THis is possibly
 too restrictive. But for now, I don't have good solution. %}%

ref-typing/write
  : ref-typing L1 CM MM B (write E1 F E2) (out/expr RT XM5 MX5) L3
    <- ref-typing L1 CM MM B E1
      (out/expr (reftype/ (ty/ nn/yes _ C) G) XM1 MX1) L2
    <- ref-typing L2 CM MM B E2 (out/expr RT XM2 MX2) L3
    <- clsmap`lookup CM C FM
    <- fldmap`lookup FM F (ty/ NN A FC)
    <- read-type G F A efx/write _ XM3 MX3
    <- efxmap`disjoint XM3 XM2
    <- efxmap`join XM1 XM2 XM4
    <- efxmap`join XM4 XM3 XM5
    <- maybe-efx-join MX1 MX2 MX4
    <- maybe-efx-join MX4 MX3 MX5.


%{% Should clear local effects at end
 first, clear effects on locations L1, L1+1, ... , L2-1
 then, remove locations appear in efxmap of T2. %}%

% TODO: add substitution
% here T could be unique OR shared
ref-typing/let/shared
  : ref-typing L1 CM MM B (let E F) (out/expr RT XM MX) L3
    <- ref-typing L1 CM MM B E
      (out/expr (reftype/ T reftgts/shared) XM1 MX1) L2
    <- ({x} ref-typing L2 CM MM
	 (cxt/cons x vtype/shared T B)
	 (F x) (out/expr RT XM2 MX2) L3)
    <- efxmap`join XM1 XM2 XM
    <- maybe-efx-join MX1 MX2 MX.

% TODO: substitution
ref-typing/let/unique
  : ref-typing L1 CM MM B (let E F) (out/expr RT XM MX2) L3
    <- ref-typing L1 CM MM B E
      (out/expr (reftype/ T (reftgts/unique S GM)) XM1 MX1) L2
    <- ({x} ref-typing (s L2) CM MM
         (cxt/cons x (vtype/unique L2) T B)
         (F x) (out/expr RT XM2 MX2) L3)
    <- efxmap`join XM1 XM2 XM
    <- maybe-efx-join MX1 MX2 MX.

ref-typing/if
  : ref-typing L1 CM MM B (if C E1 E2) (out/expr T XM2 MX2) L4
    <- ref-typing L1 CM MM B C (out/cond XM0 MX0) L2
    <- ref-typing L2 CM MM B E1 (out/expr T XM1 MX) L3
    <- ref-typing L3 CM MM B E2 (out/expr T XM1 MX) L4
    <- efxmap`join XM0 XM1 XM2
    <- maybe-efx-join MX0 MX MX2.


%%% conditionals
 
ref-typing/eq
  : ref-typing L1 CM MM B (eql E1 E2) (out/cond XM MX) L3
    <- ref-typing L1 CM MM B E1 (out/expr _ XM1 MX) L2
    <- ref-typing L2 CM MM B E2 (out/expr _ XM2 MX) L3
    <- efxmap`join XM1 XM2 XM.

ref-typing/not
  : ref-typing L1 CM MM B (not C) R L2
    <- ref-typing L1 CM MM B C R L2.

ref-typing/and
  : ref-typing L1 CM MM B (and C1 C2) (out/cond XM MX) L3
    <- ref-typing L1 CM MM B C1 (out/cond XM1 MX1) L2
    <- ref-typing L2 CM MM B C2 (out/cond XM2 MX2) L3
    <- efxmap`join XM1 XM2 XM
    <- maybe-efx-join MX1 MX2 MX.

ref-typing/args/0 : ref-typing L _ _ _ args/0 out/args/0 L.

ref-typing/args/+
  : ref-typing L1 CM MM B
    (args/+ E A) (out/args/+ (out/expr T XM MX) R) L3
    <- ref-typing L1 CM MM B E (out/expr T XM MX) L2
    <- ref-typing L2 CM MM B A R L3.

% return value takes one binding
ref-typing/call
  : ref-typing L1 CM MM B (call M A) R (s L2)
    <- clsmap`fresh CM M
    <- methmap`lookup MM M MT
    <- ref-typing L1 CM MM B A AR L2
    <- ref-calltyping L2 CM AR MT R.

% constructor will have write effect on every field
ref-typing/const
  : ref-typing L1 CM MM B
    (call C (args/+ (alloc C S set/0) A)) (out/expr T XM MX) (s L2)
    <- clsmap`lookup CM C FM
    <- fldmap`domain FM S
    <- methmap`lookup MM C (methty/arg MT _ _ _)
    <- ref-typing L1 CM MM B A AO L2
    <- ref-calltyping L2 CM AO MT (out/expr T XM MX).


% methtymatch

methtymatch*
  : loc -> efxmap -> clsmap -> methmap -> cxt -> func -> methty -> loc -> type.

% TODO: fix methty
methtymatch/base
  : methtymatch* L1 XM CM MM B (func/0 E) (methty/base T) L2
    <- ref-typing L1 CM MM B E (out/expr (reftype/ T _) XMP MXP) L2
    <- efxmap`leq XMP XM
    <- maybe-efx-leq MXP MX.


%{ shared annotation doesn't carry any effect, read/write 
shared effects comes from methty/base }%
methtymatch/args/shared
  : methtymatch* L1 XM CM MM B (func/+ F)
    (methty/arg A (ty/ NN annot/shared C) R W) L2
    <- ({o} methtymatch* L1 XM CM MM
         (cxt/cons o vtype/shared (ty/ NN annot/shared C) B) (F o) A L2).

methtymatch/args/unique
  : methtymatch* L1 XM CM MM B (func/+ F)
    (methty/arg A (ty/ NN annot/unique C) R W) L2
    <- reftype-extend-rw CM (ty/ NN annot/unique C)
      (reftype/ (ty/ NN annot/unique C) (reftgts/1 L1)) R W XMP
    <- efxmap`join XM XMP XMS
    <- ({o} methtymatch* (s L1) XMS CM MM
         (cxt/cons o (vtype/unique L1) (ty/ NN annot/unique C) B) (F o) A L2).

methtymatch/args/borrow
  : methtymatch* L1 XM CM MM B (func/+ F)
    (methty/arg A (ty/ NN annot/borrow C) R W) L2
    <- reftype-extend-rw CM (ty/ NN annot/unique C)
      (reftype/ (ty/ NN annot/unique C) (reftgts/1 L1)) R W XMP
    <- efxmap`join XM XMP XMS
    <- ({o} methtymatch* (s L1) XMS CM MM
         (cxt/cons o (vtype/unique L1) (ty/ NN annot/unique C) B) (F o) A L2).

%abbrev methtymatch 
  = [CM][MM][F][MT] methtymatch* (s z) efxmap/0 CM MM cxt/nil F MT L.


%%% constructor type

constyping
  : loc -> efxmap -> clsmap -> methmap -> fldmap 
  -> cxt -> set -> (object -> expr) -> efxmap -> loc -> type.

% TODO: define later
constyping/0 : constyping L XM _ _ _ _ set/0 ([t] lit t) XM L.

constymatch*
  : loc -> efxmap -> clsmap -> methmap -> fldmap -> cxt
  -> set -> (object -> func) -> methty -> loc -> type.

%abbrev constymatch
  = [CM][MM][FM][S][F][CT] 
    constymatch* (s (s z)) efxmap/0 CM MM FM cxt/nil S F CT L.


%%% program type

select-fields : fldmap -> set -> type.

select-fields/0 : select-fields fldmap/0 set`set/0.

select-fields/+/in
  : select-fields (fldmap/+ F (ty/ nn/yes _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S'
    <- set`union S' (set/1 F) S.

select-fields/+/out
  : select-fields (fldmap/+ F (ty/ nn/may _ _) M) S
    <- fldmap`shift F M M'
    <- select-fields M' S.


methmapmatch* : clsmap -> methmap -> methmap -> prog -> type.

methmapmatch/0 : methmapmatch* _ _ methmap/0 prog`map/0.

methmapmatch/+/const
  : methmapmatch* CM MM0
    (methmap/+ C (methty/arg CT (ty/ nn/yes _ C) _ _) MM)
    (prog`map/+ C (func/+ ([t] FF t)) XM)
    <- clsmap`lookup CM C FM
    <- select-fields FM S
    <- constymatch CM MM0 FM S FF CT
    <- methmap`shift C MM MM'
    <- prog`shift C XM XM'
    <- methmapmatch* CM MM0 MM' XM'.

methmapmatch/+/meth
  : methmapmatch* CM MM0
    (methmap/+ N MT MM) (prog`map/+ N FUN XM)
    <- clsmap`fresh CM N
    <- methtymatch CM MM0 FUN MT
    <- methmap`shift N MM MM'
    <- prog`shift N XM XM'
    <- methmapmatch* CM MM0 MM' XM'.

%abbrev methmapmatch = [CM][MM][G] methmapmatch* CM MM MM G.


%%% Theorems

%%% This theorem is definitely provable, but a little bit tedius.
%theorem efxmap`join-implies-leq :
	forall* {M1} {M2} {M3}
	forall {J:efxmap`join M1 M2 M3}
        exists {L:efxmap`leq M1 M3} {L:efxmap`leq M2 M3}
	true.

- : efxmap`join-implies-leq efxmap`join/L efxmap`leq/0 M<=M
     <- efxmap`leq-reflexive _ M<=M.

- : efxmap`join-implies-leq efxmap`join/R M<=M efxmap`leq/0
     <- efxmap`leq-reflexive _ M<=M.

%worlds () (efxmap`join-implies-leq _ _ _).
%trustme %total  {} (efxmap`join-implies-leq _ _ _).