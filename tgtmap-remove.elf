%%% remove operation on tgtmap.

%%% all these definitions and theorems are
%%% similar to set`remove. 

%%% HOWEVER, we need to define what is a 
%%% "well-formed" tgtmap: a tgtmap that doesn't have set/0 as value.

wf-tgtmap : tgtmap -> type.

wf-tgtmap/0 : wf-tgtmap tgtmap/0.

wf-tgtmap/+ 
  : wf-tgtmap (tgtmap/+ _ S M)
    <- set`size S (s _)
    <- wf-tgtmap M.

tgtmap`remove : tgtmap -> tgtmap -> tgtmap -> type.

tgtmap`remove/
  : wf-tgtmap M1 ->
    wf-tgtmap M2 ->
    wf-tgtmap M3 -> 
    tgtmap`leq M3 M1 -> 
    tgtmap`deep-disjoint M2 M3 ->
    tgtmap`join M2 M3 M4 ->
    tgtmap`leq M1 M4 ->
    tgtmap`remove M1 M2 M3.
		   

%%%% theorems


%%% theorem about well-formedness

%theorem update-non-empty-preserves-wf :
    forall* {GM} {GMP} {S} {N} {B}
    forall  {WF: wf-tgtmap GM} 
            {SZ: set`size S (s B)}
            {U: tgtmap`update GM N S GMP}
    exists  {WF: wf-tgtmap GMP}
    true.

% - : update-non-empty-preserves-wf 

%worlds () (update-non-empty-preserves-wf _ _ _ _).
%trustme %total  {} (update-non-empty-preserves-wf _ _ _ _).


%theorem join-preserves-wf :
    forall* {M1} {M2} {M3}
    forall  {WF-M1: wf-tgtmap M1}
            {WF-M1: wf-tgtmap M2}
            {J: tgtmap`join M1 M2 M3}
    exists  {WF-M3: wf-tgtmap M3}
    true.

%worlds () (join-preserves-wf _ _ _ _).
%trustme %total  {} (join-preserves-wf _ _ _ _).


%theorem size-succ-contradiction :
    forall* {N}
    forall  {SZ: set`size set/0 (s N)}
    exists  {F: void}
    true.

%worlds () (size-succ-contradiction _ _).
%total  {} (size-succ-contradiction _ _).



%theorem remove-implies-wf :
    forall* {A} {B} {C}
    forall  {R: tgtmap`remove A B C}
    exists  {WF-A: wf-tgtmap A} {WF-B: wf-tgtmap B}
            {WF-C: wf-tgtmap C}
    true.

- : remove-implies-wf (tgtmap`remove/ WF-A WF-B WF-C _ _ _ _) 
    WF-A WF-B WF-C.

%worlds () (remove-implies-wf _ _ _ _).
%total  {} (remove-implies-wf _ _ _ _).


%theorem wf-tgtmap-lookup-emptyset-implies-contradiction :
    forall* {M} {N} 
    forall  {WF: wf-tgtmap M}
            {L: tgtmap`lookup M N set/0}
    exists  {F:void}
    true.

- : wf-tgtmap-lookup-emptyset-implies-contradiction 
    (wf-tgtmap/+ WF SZ) (tgtmap`lookup/= nat`eq/) F
    <- size-succ-contradiction SZ F.

- : wf-tgtmap-lookup-emptyset-implies-contradiction
    (wf-tgtmap/+ WF _) (tgtmap`lookup/> L P) F
    <- wf-tgtmap-lookup-emptyset-implies-contradiction WF L F.

%worlds () (wf-tgtmap-lookup-emptyset-implies-contradiction _ _ _).
%total (WF) (wf-tgtmap-lookup-emptyset-implies-contradiction WF _ _).


%theorem shift-preserves-wf : 
    forall* {GM} {N} {GMP}
    forall  {WF: wf-tgtmap GM}
            {SH: tgtmap`shift N GM GMP}
    exists  {WF: wf-tgtmap GMP}
    true.

- : shift-preserves-wf wf-tgtmap/0 _ wf-tgtmap/0.

- : shift-preserves-wf (wf-tgtmap/+ WF SZ)
    (tgtmap`shift/+ P) (wf-tgtmap/+ WF SZ).

%worlds () (shift-preserves-wf _ _ _).
%total  {} (shift-preserves-wf _ _ _).


%theorem tgtmap`join-is-lub :
        forall* {M1} {M2} {M3} {M4}
        forall {J:tgtmap`join M1 M2 M3}
               {L1:tgtmap`leq M1 M4} {L2:tgtmap`leq M2 M4}
        exists {L3:tgtmap`leq M3 M4}
        true.

- : tgtmap`join-is-lub tgtmap`join/L _ L L.

- : tgtmap`join-is-lub tgtmap`join/R L _ L.

- : tgtmap`join-is-lub
    (tgtmap`join/= M1+M2=M3 D1+D2=D3 nat`eq/)
    (tgtmap`leq/= M1<=M4 D1<=D4 nat`eq/)
    (tgtmap`leq/= M2<=M4 D2<=D4 nat`eq/)
    (tgtmap`leq/= M3<=M4 D3<=D4 nat`eq/)
    <- set`union-is-lub D1+D2=D3 D1<=D4 D2<=D4 D3<=D4
    <- tgtmap`join-is-lub M1+M2=M3 M1<=M4 M2<=M4 M3<=M4.

- : tgtmap`join-is-lub (tgtmap`join/= _ _ nat`eq/)
    (tgtmap`leq/= _ _ nat`eq/) (tgtmap`leq/> _ N3+1+N=N) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub (tgtmap`join/= _ _ nat`eq/)
    (tgtmap`leq/> _ N3+1+N=N) (tgtmap`leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub
    (tgtmap`join/= M1+M2=M3 D1+D2=D3 nat`eq/)
    (tgtmap`leq/> M511<=M4 N5+1+N4=N)
    (tgtmap`leq/> M622<=M4 N6+1+N4=N)
    (tgtmap`leq/> M633<=M4 N6+1+N4=N)
    <- nat`plus-right-cancels N5+1+N4=N N6+1+N4=N nat`eq/ nat`eq/ N5+1=N6+1
    <- nat`succ-cancels N5+1=N6+1 N5=N6
    <- tgtmap`map/+-preserves-eq N5=N6 set`eq/ tgtmap`eq/ M511=M611
    <- tgtmap`leq-respects-eq M511<=M4 M511=M611 tgtmap`eq/ M611<=M4
    <- tgtmap`join-is-lub (tgtmap`join/= M1+M2=M3 D1+D2=D3 nat`eq/)
                   M611<=M4 M622<=M4 M633<=M4.

- : tgtmap`join-is-lub (tgtmap`join/< _ N0+1+N=N)
    (tgtmap`leq/= _ _ nat`eq/) (tgtmap`leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub
    (tgtmap`join/< M1+M022=M3 N0+1+N1=N2)
    (tgtmap`leq/= M1<=M4 D1<=D4 nat`eq/)
    (tgtmap`leq/> M622<=M4 N6+1+N1=N2)
    (tgtmap`leq/= M3<=M4 D1<=D4 nat`eq/)
    <- nat`plus-right-cancels
      N6+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N6+1=N0+1
    <- succ-cancels N6+1=N0+1 N6=N0
    <- tgtmap`map/+-preserves-eq N6=N0 set`eq/ tgtmap`eq/ M622=M022
    <- tgtmap`leq-respects-eq M622<=M4 M622=M022 tgtmap`eq/ M022<=M4
    <- tgtmap`join-is-lub M1+M022=M3 M1<=M4 M022<=M4 M3<=M4.

- : tgtmap`join-is-lub (tgtmap`join/< _ N0+1+N1=N2)
    (tgtmap`leq/> _ N3+1+N2=N1) (tgtmap`leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub
    (tgtmap`join/< M1+M022=M3 N0+1+N1=N2)
    (tgtmap`leq/> M511<=M4 N5+1+N4=N1)
    (tgtmap`leq/> M622<=M4 N6+1+N4=N2)
    (tgtmap`leq/> M513<=M4 N5+1+N4=N1)
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-associative-converse
      N5+N4+1=N1 N0+1+N1=N2 N6P N0+1+N5=N6P N6P+N4+1=N2
    <- nat`plus-swap-succ-converse N6P+N4+1=N2 N6P+1+N4=N2
    <- nat`plus-right-cancels
      N6P+1+N4=N2 N6+1+N4=N2 nat`eq/ nat`eq/ N6P+1=N6+1
    <- nat`succ-cancels N6P+1=N6+1 N6P=N6
    <- nat`plus-respects-eq N0+1+N5=N6P nat`eq/ nat`eq/ N6P=N6 N0+1+N5=N6
    <- tgtmap`join-is-lub (tgtmap`join/< M1+M022=M3 N0+1+N5=N6) 
      M511<=M4 M622<=M4 M513<=M4.

- : tgtmap`join-is-lub (tgtmap`join/> _ N3+1+N=N)
    (tgtmap`leq/= _ _ nat`eq/) (tgtmap`leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub (tgtmap`join/> _ N3+1+N2=N1)
    (tgtmap`leq/= _ _ nat`eq/) (tgtmap`leq/> _ N0+1+N1=N2) L
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub
    (tgtmap`join/> M311+M2=M3 N3+1+N2=N1)
    (tgtmap`leq/> M511<=M4 N5+1+N2=N1)
    (tgtmap`leq/= M2<=M4 D2<=D4 nat`eq/)
    (tgtmap`leq/= M3<=M4 D2<=D4 nat`eq/)
    <- nat`plus-right-cancels
      N3+1+N2=N1 N5+1+N2=N1 nat`eq/ nat`eq/ N3+1=N5+1
    <- nat`succ-cancels N3+1=N5+1 N3=N5
    <- tgtmap`map/+-preserves-eq N3=N5 set`eq/ tgtmap`eq/ M311=M511
    <- tgtmap`join-respects-eq 
      M311+M2=M3 M311=M511 tgtmap`eq/ tgtmap`eq/ M511+M2=M3
    <- tgtmap`join-is-lub M511+M2=M3 M511<=M4 M2<=M4 M3<=M4.

- : tgtmap`join-is-lub
    (tgtmap`join/> M311+M2=M3 N3+1+N2=N1)
    (tgtmap`leq/> M511<=M4 N5+1+N4=N1)
    (tgtmap`leq/> M622<=M4 N6+1+N4=N2)
    (tgtmap`leq/> M623<=M4 N6+1+N4=N2)
    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- nat`plus-associative-converse
      N6+N4+1=N2 N3+1+N2=N1 N5P N3+1+N6=N5P N5P+N4+1=N1
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-right-cancels N5P+N4+1=N1 N5+N4+1=N1 nat`eq/ nat`eq/ N5P=N5
    <- nat`plus-respects-eq N3+1+N6=N5P nat`eq/ nat`eq/ N5P=N5 N3+1+N6=N5
    <- tgtmap`join-is-lub (tgtmap`join/> M311+M2=M3 N3+1+N6=N5) 
      M511<=M4 M622<=M4 M623<=M4.

%worlds () (tgtmap`join-is-lub _ _ _ _).
%total (L) (tgtmap`join-is-lub _ L _ _).


%theorem tgtmap`fresh-implies-unit-deep-disjoint :
    forall* {N} {M} {D}
    forall  {F:tgtmap`fresh M N}
    exists  {D: tgtmap`deep-disjoint M (tgtmap`map/+ N D tgtmap`map/0)}
    true.

- : tgtmap`fresh-implies-unit-deep-disjoint 
    tgtmap`fresh/0 tgtmap`deep-disjoint/L.

- : tgtmap`fresh-implies-unit-deep-disjoint
    (tgtmap`fresh/< G) (tgtmap`deep-disjoint/> tgtmap`deep-disjoint/R P)
    <- gt-implies-plus G _ P.

- : tgtmap`fresh-implies-unit-deep-disjoint
    (tgtmap`fresh/> F P) (tgtmap`deep-disjoint/< D P)
    <- tgtmap`fresh-implies-unit-deep-disjoint F D.

%worlds () (tgtmap`fresh-implies-unit-deep-disjoint _ _).
%total (F) (tgtmap`fresh-implies-unit-deep-disjoint F _).


%theorem set`leq-implies-remove-all-converse :
    forall* {A} {B}
    forall  {R: set`remove A B set/0}
    exists  {LE: set`leq A B}
    true.

- : set`leq-implies-remove-all-converse 
    (set`remove/ set`leq/0 _ _ A<=B) A<=B.

%worlds () (set`leq-implies-remove-all-converse _ _).
%total  {} (set`leq-implies-remove-all-converse _ _).
    

%theorem tgtmap`can-remove :
    forall* {M} {S} {N} {D}
    forall  {WF: wf-tgtmap M} {SZ:tgtmap`size M S} {L:tgtmap`lookup M N D}
    exists  {M-} {S-} {K} {WF: wf-tgtmap M-}
            {SZ-:tgtmap`size M- S-} {E:nat`eq (s S-) S}
            {U:tgtmap`update M- N D M} {SZ: set`size D (s K)}
            {F:tgtmap`fresh M- N}
    true.

- : tgtmap`can-remove 
    (wf-tgtmap/+ _ SZ) (tgtmap`size/+ _) (tgtmap`lookup/= _) 
    _ _ _ wf-tgtmap/0 tgtmap`size/0 nat`eq/ tgtmap`update/0 SZ tgtmap`fresh/0.

- : tgtmap`can-remove
    (wf-tgtmap/+ WF S-SZ) (tgtmap`size/+ (tgtmap`size/+ SZ))
    (tgtmap`lookup/= nat`eq/) _ _ _ WF2
    (tgtmap`size/+ SZ) nat`eq/
    (tgtmap`update/< N3+1+N2=N1) S-SZ (tgtmap`fresh/< N1>N2)
    <- plus-total N3+1+N2=N1
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-swap-succ N3+1+N2=N1 P
    <- nat`plus-commutative P P1
    <- shift-preserves-wf WF (tgtmap`shift/+ P1) WF2.

- : tgtmap`can-remove (wf-tgtmap/+ WF S-SZ)
    (tgtmap`size/+ SZ) (tgtmap`lookup/> LK N0+1+N1=N2) _ _ _ 
    (wf-tgtmap/+ WF2 S-SZ) (tgtmap`size/+ SZ2) E
    (tgtmap`update/> U2 N0+1+N1=N2) SS-SZ (tgtmap`fresh/> F2 N0+1+N1=N2)
    <- tgtmap`can-remove WF SZ LK M- S- _ WF2 SZ2 E2 U2 SS-SZ F2
    <- succ-deterministic E2 E.

%worlds () (tgtmap`can-remove _ _ _ _ _ _ _ _ _ _ _ _).
%total (L) (tgtmap`can-remove _ _ L _ _ _ _ _ _ _ _ _).


%theorem tgtmap`can-remove* :
    forall* {M} {S}
    forall  {WF: wf-tgtmap M} {SZ:tgtmap`size M (s S)}
    exists  {MP} {N} {D} {K}
            {WF: wf-tgtmap MP}
            {SZP:tgtmap`size MP S}
            {U:tgtmap`update MP N D M}
            {SZS: set`size D (s K)}
            {F:tgtmap`fresh MP N}
    true.

- : tgtmap`can-remove* (wf-tgtmap/+ SS-SZ WF-M)
    (tgtmap`size/+ SZ) MP N D K WF SZP U S-SZ F
    <- tgtmap`can-remove (wf-tgtmap/+ SS-SZ WF-M) (tgtmap`size/+ SZ)
      (tgtmap`lookup/= nat`eq/) MP NP K WF SZPP EQ U S-SZ F
    <- succ-cancels EQ EQP
    <- tgtmap`size-respects-eq SZPP tgtmap`eq/ EQP SZP.

%worlds () (tgtmap`can-remove* _ _ _ _ _ _ _ _ _ _ _).
%total { } (tgtmap`can-remove* _ _ _ _ _ _ _ _ _ _ _).


%theorem tgtmap`false-implies-remove :
        forall* {S1} {S2} {S3}
        forall {F:void}
        exists {D:tgtmap`remove S1 S2 S3}
        true.

%worlds () (tgtmap`false-implies-remove _ %{=>}% S1-S2=S3).
%total {} (tgtmap`false-implies-remove _ _).


%theorem tgtmap`remove-respects-eq :
        forall* {S1} {S2} {S3} {T1} {T2} {T3}
        forall  {DS:tgtmap`remove S1 S2 S3}
                {E1:tgtmap`eq S1 T1} {E2:tgtmap`eq S2 T2} 
                {E3:tgtmap`eq S3 T3}
        exists  {DT:tgtmap`remove T1 T2 T3}
        true.

- : tgtmap`remove-respects-eq R tgtmap`eq/ tgtmap`eq/ tgtmap`eq/ R.

%worlds () 
(tgtmap`remove-respects-eq S1-S2=S3 S1=T1 S2=T2 S3=T3 %{=>}% T1-T2=T3).
%total {} (tgtmap`remove-respects-eq _ _ _ _ _).
%reduces R = RP (tgtmap`remove-respects-eq R _ _ _ RP).


%theorem tgtmap`remove-total* :
        forall* {S1} {S2} 
        forall {WF-S1: wf-tgtmap S1} {WF-S2: wf-tgtmap S2}
        exists {S3} {R:tgtmap`remove S1 S2 S3}
        true.

%theorem tgtmap`remove-total/L1 :
        forall* {A} {B}
        forall  {N} {S: tgtmap`size A N}
                {WF: wf-tgtmap A} {WF: wf-tgtmap B}
        exists  {C} {R:tgtmap`remove A B C}
        true.

%theorem tgtmap`remove-total/L2 :
        forall* {B} {A} {AP} {CP} {X} {B?} {S} {N}
        forall  {SZ: set`size S (s N)}
                {FS: tgtmap`fresh AP X} {AD: tgtmap`update AP X S A}
                {R: tgtmap`remove AP B CP}
                {D?: tgtmap`domain? B X B?}
        exists  {C} {R:tgtmap`remove A B C}
        true.

%theorem tgtmap`remove-total/L3 :
    forall* {S} {S'} {DP} {AP} {A} {B} {X} {CP} {Q}
    forall  {N} {SZ-Q: set`size Q N} 
            {R: set`remove S' S Q} {WF-AP: wf-tgtmap AP}
            {WF-B: wf-tgtmap B} {WF-CP: wf-tgtmap CP} 
            {L: tgtmap`lookup B X S} {LE: tgtmap`leq CP AP}
            {DX: tgtmap`deep-disjoint B CP}
            {U: tgtmap`join B CP DP} {LE: tgtmap`leq AP DP}
            {FS: tgtmap`fresh AP X} {UD: tgtmap`update AP X S' A}
    exists  {CP'} {WF-CP: wf-tgtmap CP'}
            {LE: tgtmap`leq CP' A} {DX: tgtmap`deep-disjoint B CP'}
            {DP'} {U: tgtmap`join B CP' DP'} {LE: tgtmap`leq A DP'}
    true.

- : tgtmap`remove-total/L3 _ set`size/0
    (set`remove/ set`leq/0 _ _ S'<=S) WF-AP WF-B
    WF-CP B<X>=S CP<=AP B^CP BUCP=DP AP<=DP X!<AP AP+S'=A %{=>}%
    CP WF-CP CP<=A B^CP DP BUCP=DP A<=DP
    <- tgtmap`fresh-update-implies-unit-join X!<AP AP+S'=A APUS'=A
    <- tgtmap`join-implies-leq APUS'=A AP<=A S'<=A
    <- tgtmap`leq-transitive CP<=AP AP<=A CP<=A
    <- tgtmap`join-implies-leq BUCP=DP B<=DP CP<=DP
    <- tgtmap`lookup-respects-leq B<X>=S B<=DP S1 DP<X>=S1 S<=S1
    <- tgtmap`lookup-implies-unit-leq DP<X>=S1 S1<=DP
    <- set`leq-transitive S'<=S S<=S1 S'<=S1
    <- tgtmap`leq-transitive (tgtmap`leq/= tgtmap`leq/0 S'<=S1 nat`eq/)
      S1<=DP S'<=DP
    <- tgtmap`fresh-implies-unit-disjoint X!<AP AP^S'
    <- tgtmap`disjoint-leq-implies-join-leq* AP^S' AP<=DP S'<=DP APUS'=A A<=DP.
    
- : tgtmap`remove-total/L3 (s _) SZQ
    (set`remove/ Q<=S' S^Q SUQ=R S'<=R) WF-AP WF-B WF-CP
    B<X>=S CP<=AP B^CP BUCP=DP AP<=DP X!<AP AP+S'=A %{=>}% 
    _ WF-CP' CP'<=A B^CP' DP' BUCP'=DP' A<=DP'
    <- tgtmap`update-total CP+Q=CP'
    <- update-non-empty-preserves-wf WF-CP SZQ CP+Q=CP' WF-CP'
    <- tgtmap`fresh-respects-geq X!<AP CP<=AP X!<CP
    <- tgtmap`fresh-update-implies-leq X!<CP CP+Q=CP' CP<=CP'
    <- tgtmap`update-preserves-leq* CP<=AP Q<=S' CP+Q=CP' AP+S'=A CP'<=A
    <- tgtmap`update-implies-lookup CP+Q=CP' CP'<X>=Q
    <- tgtmap`lookup-implies-update B<X>=S B+S=B
    <- tgtmap`update-disjoint-implies-disjoint B^CP B+S=B CP+Q=CP' S^Q B^CP'
    <- tgtmap`join-total* _ _ DP' BUCP'=DP'
    <- tgtmap`join-joins-lookup* B<X>=S CP'<X>=Q BUCP'=DP' SUQ=R DP'<X>=R
    <- tgtmap`lookup-implies-update DP'<X>=R DP'+R=DP'
    <- tgtmap`join-left-preserves-leq* CP<=CP' BUCP=DP BUCP'=DP' DP<=DP'
    <- tgtmap`leq-transitive AP<=DP DP<=DP' AP<=DP'
    <- tgtmap`update-preserves-leq* AP<=DP' S'<=R AP+S'=A DP'+R=DP' A<=DP'.

%worlds () (tgtmap`remove-total/L3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total  {} (tgtmap`remove-total/L3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


- : tgtmap`remove-total/L2 SZ X!<AP AP+X=A
    (tgtmap`remove/ WF-AP WF-B WF-CP CP<=AP B^CP BUCP=DP AP<=DP) 
    (tgtmap`domain?/in X<-B) CP'
    (tgtmap`remove/ WF-A WF-B WF-CP' CP'<=A B^CP' BUCP'=DP' A<=DP')
    <- set`remove-total S'/S=Q
    <- set`size-total SZQ
     <- tgtmap`remove-total/L3 _ SZQ S'/S=Q WF-AP WF-B WF-CP X<-B
       CP<=AP B^CP BUCP=DP AP<=DP X!<AP AP+X=A CP' WF-CP' CP'<=A 
       B^CP' DP' BUCP'=DP' A<=DP'
     <- update-non-empty-preserves-wf WF-AP SZ AP+X=A WF-A. 

- : tgtmap`remove-total/L2 SZ X!<AP AP+X=A
    (tgtmap`remove/ WF-AP WF-B WF-CP CP<=AP B^CP BUCP=DP AP<=DP)
    (domain?/out X</-B) C (tgtmap`remove/ WF-A WF-B WF-C C<=A B^C BUC=D A<=D)
    <- tgtmap`fresh-implies-unit-deep-disjoint X</-B B^X
    <- tgtmap`join-total* CP (tgtmap/+ X S tgtmap/0) C CPUX=C
    <- tgtmap`fresh-respects-geq X!<AP CP<=AP X!<CP
    <- tgtmap`fresh-unit-join-implies-update X!<CP CPUX=C CP+X=C
    <- update-non-empty-preserves-wf WF-CP SZ CP+X=C WF-C
    <- tgtmap`join-right-preserves-deep-disjoint* B^CP B^X CPUX=C B^C
     <- tgtmap`fresh-update-implies-unit-join X!<AP AP+X=A APUX=A
    <- tgtmap`join-implies-leq APUX=A AP<=A X<=A
    <- tgtmap`leq-transitive CP<=AP AP<=A CP<=A
    <- tgtmap`join-is-lub CPUX=C CP<=A X<=A C<=A
    <- tgtmap`join-total* DP (tgtmap/+ X S tgtmap/0) D DPUX=D
    <- tgtmap`join-associative* BUCP=DP DPUX=D CPUX=C BUC=D
    <- tgtmap`join-implies-leq DPUX=D DP<=D X<=D
    <- tgtmap`leq-transitive AP<=DP DP<=D AP<=D
    <- tgtmap`join-is-lub APUX=A AP<=D X<=D A<=D
     <- update-non-empty-preserves-wf WF-AP SZ AP+X=A WF-A. 

%worlds () (tgtmap`remove-total/L2 _ _ _ _ _ _ _).
%total { } (tgtmap`remove-total/L2 _ _ _ _ _ _ _).


- : tgtmap`remove-total/L1 _ tgtmap`size/0 wf-tgtmap/0 
    WF-B tgtmap/0
    (tgtmap`remove/ wf-tgtmap/0 WF-B wf-tgtmap/0 tgtmap`leq/0 
      tgtmap`deep-disjoint/R tgtmap`join/R tgtmap`leq/0).

- : tgtmap`remove-total/L1 _ SZ-A WF-A WF-B C A-B=C
    <- tgtmap`can-remove* WF-A SZ-A _ _ _ _ WF-AP SZP AP+X=A SZ-S X!<AP
    <- tgtmap`remove-total/L1 _ SZP WF-AP WF-B CP AP-B=CP
    <- tgtmap`domain?-total M?
    <- tgtmap`remove-total/L2 SZ-S X!<AP AP+X=A AP-B=CP M? C A-B=C. 

%worlds () (tgtmap`remove-total/L1 _ _ _ _ _ _).
%total (N) (tgtmap`remove-total/L1 N _ _ _ _ _).

- : tgtmap`remove-total* WF-A WF-B _ R
    <- tgtmap`size-total SZ
    <- tgtmap`remove-total/L1 _ SZ WF-A WF-B _  R.

%worlds () (tgtmap`remove-total* _ _ _ _).
%total { } (tgtmap`remove-total* _ _ _ _).


%abbrev tgtmap`remove-total = tgtmap`remove-total*.


%theorem tgtmap`remove-deterministic :
        forall* {S1} {S2} {S3} {T1} {T2} {T3}
        forall {RS:tgtmap`remove S1 S2 S3} {RT:tgtmap`remove T1 T2 T3}
               {E1:tgtmap`eq S1 T1} {E2:tgtmap`eq S2 T2}
        exists {E3:tgtmap`eq S3 T3}
        true.

%abbrev tgtmap`remove-unique = tgtmap`remove-deterministic.



%theorem test/L : 
    forall* {C} {E} {SC} {SE} {N} {X} {B} {F}
    forall  {K} {MB?: tgtmap`domain? B X K} 
            {LC: tgtmap`lookup C X SC}
            {LE: tgtmap`lookup E X SE}
            {MB: set`member SC N}
            {NM: set`not-member SE N}
            {D: tgtmap`deep-disjoint B C}
            {BUE: tgtmap`join B E F}
    exists  {SF} {LF: tgtmap`lookup F X SF} {NM: set`not-member SF N}
    true.

- : test/L true (tgtmap`domain?/in B<X>=SB)
    C<X>=SC E<X>=SE N<-SC N!<SE B^C BUE=F SF F<X>=SF N!<SF
    <- tgtmap`deep-disjoint-lookup-implies-disjoint B^C B<X>=SB C<X>=SC SB^SC
    <- set`disjoint-symmetric SB^SC SC^SB
    <- set`disjoint-lookup-implies-not-member N<-SC SC^SB N!<SB
    <- tgtmap`join-joins-lookup B<X>=SB E<X>=SE BUE=F SF SBUSE=SF F<X>=SF
    <- set`union-preserves-not-member* N!<SB N!<SE SBUSE=SF N!<SF.

- : test/L false (tgtmap`domain?/out X!<B)
    C<X>=SC E<X>=SE N<-SC N!<SE B^C BUE=F _ F<X>=SE N!<SE
    <- tgtmap`fresh-join-left-preserves-lookup* X!<B E<X>=SE BUE=F F<X>=SE.

%worlds () (test/L _ _ _ _ _ _ _ _ _ _ _).
%total  {} (test/L _ _ _ _ _ _ _ _ _ _ _).

%theorem tgtmap`remove-deterministic/L :
        forall* {S1} {S2} {S3} {T3} {B}
        forall {RS:tgtmap`remove S1 S2 S3} {RT:tgtmap`remove S1 S2 T3}
               {E: tgtmap`eq? S3 T3 B}
        exists {E3: tgtmap`eq S3 T3}
        true.

- : tgtmap`remove-deterministic/L _ _ tgtmap`eq?/yes tgtmap`eq/.

% since A<=D and A<=F, if A(x) = S, then S cannot contain
% both all elements from C(x) and all elements from E(x).

- : tgtmap`remove-deterministic/L 
    (tgtmap`remove/ _ _ _ C<=A B^C BUC=D A<=D)
    (tgtmap`remove/ _ _ _ E<=A B^E BUE=F A<=F)
    (tgtmap`ne/= C<X>=S1 E<X>=S2 (set`ne/< N<-S1 N!<S2)) EQ
    <- tgtmap`lookup-respects-leq C<X>=S1 C<=A S1P A<X>=S1P S1<=S1P
    <- set`member-respects-leq N<-S1 S1<=S1P N<-S1P
    <- tgtmap`domain?-total X<-B?
    <- test/L _ X<-B? C<X>=S1 E<X>=S2 N<-S1 N!<S2 B^C BUE=F _ F<X>=SF N!<SF
    <- tgtmap`lookup-respects-leq* A<X>=S1P A<=F F<X>=SF S1P<=SF
    <- set`not-member-respects-geq N!<SF S1P<=SF N!<S1P
    <- set`member-not-member-contradiction N<-S1P N!<S1P F
    <- tgtmap`false-implies-eq F EQ.

- : tgtmap`remove-deterministic/L 
    (tgtmap`remove/ _ _ _ E<=A B^E BUE=F A<=F)
    (tgtmap`remove/ _ _ _ C<=A B^C BUC=D A<=D)
    (tgtmap`ne/= E<X>=S2 C<X>=S1 (set`ne/> N!<S2 N<-S1)) EQ
    <- tgtmap`lookup-respects-leq C<X>=S1 C<=A S1P A<X>=S1P S1<=S1P
    <- set`member-respects-leq N<-S1 S1<=S1P N<-S1P
    <- tgtmap`domain?-total X<-B?
    <- test/L _ X<-B? C<X>=S1 E<X>=S2 N<-S1 N!<S2 B^C BUE=F _ F<X>=SF N!<SF
    <- tgtmap`lookup-respects-leq* A<X>=S1P A<=F F<X>=SF S1P<=SF
    <- set`not-member-respects-geq N!<SF S1P<=SF N!<S1P
    <- set`member-not-member-contradiction N<-S1P N!<S1P F
    <- tgtmap`false-implies-eq F EQ.

- : tgtmap`remove-deterministic/L
        (tgtmap`remove/ _ _  WF-C C<=A B^C BUC=D A<=D)
        (tgtmap`remove/ _ _ _  E<=F B^E BUE=F A<=F)
        (tgtmap`ne/< C<X>=S X!<E) C=E
    <- tgtmap`lookup-respects-leq C<X>=S C<=A _ A<X>=S1 S<=S1
    <- tgtmap`lookup-respects-leq A<X>=S1 A<=F _ F<X>=S2 S1<=S2
    <- set`leq-transitive S<=S1 S1<=S2 S<=S2
    <- tgtmap`deep-disjoint-symmetric B^C C^B
    <- tgtmap`fresh-join-right-preserves-lookup-converse F<X>=S2 X!<E BUE=F B<X>=S2
    <- tgtmap`deep-disjoint-lookup-implies-disjoint C^B C<X>=S B<X>=S2 S^S2
    <- set`disjoint-leq-implies-empty S^S2 S<=S2 E=S
    <- set`eq-symmetric E=S S=E
    <- tgtmap`lookup-respects-eq C<X>=S tgtmap`eq/ nat`eq/ S=E C<X>=E
    <- wf-tgtmap-lookup-emptyset-implies-contradiction WF-C C<X>=E F
    <- tgtmap`false-implies-eq F C=E.

- : tgtmap`remove-deterministic/L
        (tgtmap`remove/ _ _ _ E<=F B^E BUE=F A<=F)
        (tgtmap`remove/ _ _ WF-C C<=A B^C BUC=D A<=D)
        (ne/> X!<E C<X>=S) E=C
    <- tgtmap`lookup-respects-leq C<X>=S C<=A _ A<X>=S1 S<=S1
    <- tgtmap`lookup-respects-leq A<X>=S1 A<=F _ F<X>=S2 S1<=S2
    <- set`leq-transitive S<=S1 S1<=S2 S<=S2
    <- tgtmap`deep-disjoint-symmetric B^C C^B
    <- tgtmap`fresh-join-right-preserves-lookup-converse F<X>=S2 X!<E BUE=F B<X>=S2
    <- tgtmap`deep-disjoint-lookup-implies-disjoint C^B C<X>=S B<X>=S2 S^S2
    <- set`disjoint-leq-implies-empty S^S2 S<=S2 E=S
    <- set`eq-symmetric E=S S=E
    <- tgtmap`lookup-respects-eq C<X>=S tgtmap`eq/ nat`eq/ S=E C<X>=E
    <- wf-tgtmap-lookup-emptyset-implies-contradiction WF-C C<X>=E F
    <- tgtmap`false-implies-eq F E=C.

%worlds () (tgtmap`remove-deterministic/L _ _ _ _).
%total { } (tgtmap`remove-deterministic/L _ _ _ _).

- : tgtmap`remove-deterministic R1 R2 tgtmap`eq/ tgtmap`eq/ EQ
    <- tgtmap`eq?-total EQ?
    <- tgtmap`remove-deterministic/L R1 R2 EQ? EQ.

%worlds () (tgtmap`remove-deterministic _ _ _ _ _).
%total { } (tgtmap`remove-deterministic _ _ _ _ _).


%theorem tgtmap`remove-implies-deep-disjoint :
    forall* {M1} {M2} {M3}
    forall  {D: tgtmap`remove M1 M2 M3}
    exists  {I: tgtmap`deep-disjoint M2 M3}
    true.

- : tgtmap`remove-implies-deep-disjoint
    (tgtmap`remove/ _ _ _ _ M2^M3 _ _) M2^M3.
    
%worlds () (tgtmap`remove-implies-deep-disjoint _ _).
%total  {} (tgtmap`remove-implies-deep-disjoint _ _).


%theorem tgtmap`remove-implies-leq :
    forall* {M1} {M2} {M3}
    forall  {D: tgtmap`remove M1 M2 M3}
    exists  {L: tgtmap`leq M3 M1}
    true.

- : tgtmap`remove-implies-leq (tgtmap`remove/ _ _ _ L _ _ _) L.

%worlds () (tgtmap`remove-implies-leq _ _).
%total  {} (tgtmap`remove-implies-leq _ _).


%theorem tgtmap`remove-implies-leq-join :
    forall* {M1} {M2} {M3} {M4}
    forall  {D: tgtmap`remove M1 M2 M3}
            {U: tgtmap`join M2 M3 M4}
    exists  {L: tgtmap`leq M1 M4}
    true.

- : tgtmap`remove-implies-leq-join
    (tgtmap`remove/ _ _ _ M3<=M1 M2^M3 M2UM3=M4 M1<=M4) M2UM3=M5 M1<=M5
    <- tgtmap`join-deterministic 
      M2UM3=M4 M2UM3=M5 tgtmap`eq/ tgtmap`eq/ M4=M5
    <- tgtmap`leq-respects-eq M1<=M4 tgtmap`eq/ M4=M5 M1<=M5.

%worlds () (tgtmap`remove-implies-leq-join _ _ _).
%total  {} (tgtmap`remove-implies-leq-join _ _ _).


%theorem tgtmap`leq-implies-remove-all :
    forall* {M1} {M2}
    forall  {WF-M1: wf-tgtmap M1} {WF-M2: wf-tgtmap M2}
            {L: tgtmap`leq M1 M2}
    exists  {R: tgtmap`remove M1 M2 tgtmap/0}
    true.

- : tgtmap`leq-implies-remove-all WF-M1 WF-M2 M1<=M2
    (tgtmap`remove/ WF-M1 WF-M2 wf-tgtmap/0 tgtmap`leq/0 
      tgtmap`deep-disjoint/R tgtmap`join/R M1<=M2).

%worlds () (tgtmap`leq-implies-remove-all _ _ _ _).
%total  {} (tgtmap`leq-implies-remove-all _ _ _ _).


%theorem tgtmap`remove-characterization:
        forall* {A} {B} {C} {D}
        forall  {WF-A: wf-tgtmap A}
                {WF-B: wf-tgtmap B}
                {WF-B: wf-tgtmap C}
                {L: tgtmap`leq C A}
                {I: tgtmap`deep-disjoint B C}
                {U: tgtmap`join B C D}
                {G: tgtmap`leq A D}
        exists {R: tgtmap`remove A B C}
        true.

- : tgtmap`remove-characterization WF1 WF2 WF3 D1 D2 D3 D4
    (tgtmap`remove/ WF1 WF2 WF3 D1 D2 D3 D4).

%worlds () (tgtmap`remove-characterization _ _ _ _ _ _ _ _).
%total { } (tgtmap`remove-characterization _ _ _ _ _ _ _ _).


%theorem tgtmap`remove-submap-implies-join :
    forall* {M1} {M2} {M3}
    forall  {R: tgtmap`remove M1 M2 M3}
            {L: tgtmap`leq M2 M1}
    exists  {J: tgtmap`join M2 M3 M1}
    true.

%worlds () (tgtmap`remove-submap-implies-join _ _ _).
%trustme %total  {} (tgtmap`remove-submap-implies-join _ _ _).


%theorem tgtmap`remove-preserves-lookup :
    forall* {M1} {M2} {M3} {X} {S}
    forall {M: tgtmap`lookup M1 X S}
           {R: tgtmap`remove M1 M2 M3}
           {N: tgtmap`fresh M2 X}
    exists {M: tgtmap`lookup M3 X S}
    true.

- : tgtmap`remove-preserves-lookup M1 R NM2 M5
    <- tgtmap`join-total BUC=D
    <- tgtmap`remove-implies-leq-join R BUC=D A<=D
    <- tgtmap`lookup-respects-leq M1 A<=D _ M4 LE
    <- tgtmap`fresh-join-left-preserves-lookup-converse NM2 M4 BUC=D M3
    <- tgtmap`remove-implies-leq R C<=A
    <- tgtmap`lookup-respects-leq* M3 C<=A M1 LE2
    <- set`leq-anti-symmetric LE2 LE EQ
    <- tgtmap`lookup-respects-eq M3 tgtmap`eq/ nat`eq/ EQ M5.

%worlds () (tgtmap`remove-preserves-lookup _ _ _ _).
%total { } (tgtmap`remove-preserves-lookup _ _ _ _).


%theorem tgtmap`remove-associates-join* :
        forall* {A} {B} {C} {D} {E} {F}
        forall {R1: tgtmap`remove A B C}
                {R2: tgtmap`remove C D E}
                {U: tgtmap`join B D F}
        exists {R3: tgtmap`remove A F E}
        true.

- : {YY1:map} {YY2:map} {YY3:map} {YY4:map} {YY5:map} {YY6:map}
    {YY7:map} {YY8:wf-tgtmap YY1}
    {YY9:wf-tgtmap YY2} {YY10:wf-tgtmap YY3} {YY11:leq? YY3 YY1 true}
    {YY12:deep-disjoint YY2 YY3} 
    {YY13:join YY2 YY3 YY7} {YY14:leq? YY1 YY7 true} {YY15:map}
    {YY16:wf-tgtmap YY3} {YY17:wf-tgtmap YY4} {YY18:wf-tgtmap YY5}
    {YY19:leq? YY5 YY3 true} {YY20:deep-disjoint YY4 YY5} {YY21:join YY4 YY5 YY15}
    {YY22:leq? YY3 YY15 true} {YY23:join YY2 YY4 YY6}
    {WF-F: wf-tgtmap YY6} {I: tgtmap} {BUH=I: tgtmap`join YY2 YY15 I}
    {FUE=I: tgtmap`join YY6 YY5 I} {B<=B: tgtmap`leq YY2 YY2}
    {B^E: tgtmap`deep-disjoint YY2 YY5} {F^E: tgtmap`deep-disjoint YY6 YY5}
    {G<=I: tgtmap`leq YY7 I} {A<=I: tgtmap`leq YY1 I} {E<=A: tgtmap`leq YY5 YY1}
    tgtmap`remove-associates-join*
    (tgtmap`remove/ YY8 YY9 YY10 YY11 YY12 YY13 YY14)
    (tgtmap`remove/ YY16 YY17 YY18 YY19 YY20 YY21 YY22) 
    YY23 (tgtmap`remove/ YY8 WF-F YY18 E<=A F^E FUE=I A<=I)
    <- join-preserves-wf YY9 YY17 YY23 WF-F
    <- tgtmap`join-total BUH=I
    <- tgtmap`leq-transitive YY19 YY11 E<=A
    <- tgtmap`join-associative-converse* YY21 BUH=I YY23 FUE=I
    <- tgtmap`leq-reflexive YY2 B<=B
    <- tgtmap`deep-disjoint-respects-geq YY12 B<=B YY19 B^E
    <- tgtmap`join-preserves-deep-disjoint* B^E YY20 YY23 F^E
    <- tgtmap`join-left-preserves-leq* YY22 YY13 BUH=I G<=I
    <- tgtmap`leq-transitive YY14 G<=I A<=I.

% - : tgtmap`remove-associates-join*
%         (tgtmap`remove/ WF-A WF-B WF-C C<=A B^C BUC=G A<=G)
%         (tgtmap`remove/ WF-C WF-D WF-E E<=C D^E DUE=H C<=H) BUD=F
%         (tgtmap`remove/ WF-A WF-F WF-E E<=A F^E FUE=I A<=I)
%     <- join-preserves-wf WF-B WF-D BUD=F WF-F
%     <- tgtmap`leq-transitive E<=C C<=A E<=A
%     <- tgtmap`join-total BUH=I
%     <- tgtmap`join-associative-converse* DUE=H BUH=I BUD=F FUE=I
%     <- tgtmap`leq-reflexive B B<=B
%     <- tgtmap`deep-disjoint-respects-geq B^C B<=B E<=C B^E
%     <- tgtmap`join-preserves-deep-disjoint* B^E D^E BUD=F F^E
%     <- tgtmap`join-left-preserves-leq* C<=H BUC=G BUH=I G<=I
%     <- tgtmap`leq-transitive A<=G G<=I A<=I.

%worlds () (tgtmap`remove-associates-join* _ _ _ _).
%total { } (tgtmap`remove-associates-join* _ _ _ _).


%theorem tgtmap`remove-associates-join :
        forall* {A} {B} {C} {D} {E}
        forall  {R1: tgtmap`remove A B C}
                {R2: tgtmap`remove C D E}
        exists  {F}
                {U: tgtmap`join B D F}
                {R3: tgtmap`remove A F E}
        true.

- : tgtmap`remove-associates-join A-B=C C-D=E F BUD=F A-F=E
    <- tgtmap`join-total BUD=F
    <- tgtmap`remove-associates-join* A-B=C C-D=E BUD=F A-F=E.

%worlds () (tgtmap`remove-associates-join _ _ _ _ _).
%total { } (tgtmap`remove-associates-join _ _ _ _ _).


%theorem tgtmap`remove-associates-join-converse* :
        forall* {A} {B} {C} {D} {E} {F}
        forall  {WF-D: wf-tgtmap D} {U: tgtmap`join B D F}
                {R3: tgtmap`remove A F E}
                {R1: tgtmap`remove A B C}
        exists  {R2: tgtmap`remove C D E}
        true.

- : tgtmap`remove-associates-join-converse* WF-D BUD=F A-F=E A-B=C C-D=E
    <- remove-implies-wf A-B=C _ _ WF-C
    <- tgtmap`remove-total WF-C WF-D _ C-D=EP
    <- tgtmap`remove-associates-join* A-B=C C-D=EP BUD=F A-F=EP
    <- tgtmap`remove-unique A-F=EP A-F=E tgtmap`eq/ tgtmap`eq/ EP=E
    <- tgtmap`remove-respects-eq C-D=EP tgtmap`eq/ tgtmap`eq/ EP=E C-D=E.

%worlds () (tgtmap`remove-associates-join-converse* _ _ _ _ _).
%total { } (tgtmap`remove-associates-join-converse* _ _ _ _ _).


%theorem tgtmap`remove-associates-join-converse :
        forall* {A} {B} {D} {E} {F}
        forall  {WF-B: wf-tgtmap B} {WF-D: wf-tgtmap D}
                {U: join B D F}
                {R3: tgtmap`remove A F E}
        exists {C}
                {R1: tgtmap`remove A B C}
                {R2: tgtmap`remove C D E}
        true.

- : tgtmap`remove-associates-join-converse WF-B WF-D BUD=F A-F=E C A-B=C C-D=E
    <- remove-implies-wf A-F=E WF-A _ _ 
    <- tgtmap`remove-total WF-A WF-B _ A-B=C
    <- tgtmap`remove-associates-join-converse* WF-D BUD=F A-F=E A-B=C C-D=E.

%worlds () (tgtmap`remove-associates-join-converse _ _ _ _ _ _ _).
%total { } (tgtmap`remove-associates-join-converse _ _ _ _ _ _ _).


%theorem tgtmap`remove-reorders* :
        forall* {A} {B} {C} {D} {E} {F}
        forall {R1: tgtmap`remove A B C}
                {R2: tgtmap`remove C D E}
                {R3: tgtmap`remove A D F}
        exists {R4: tgtmap`remove F B E}
        true.

- : tgtmap`remove-reorders* A-B=C C-D=E A-D=G G-B=E
    <- tgtmap`remove-associates-join A-B=C C-D=E F BUD=F A-F=E
    <- tgtmap`join-commutative BUD=F DUB=F
    <- remove-implies-wf A-B=C _ WF-B _
    <- remove-implies-wf C-D=E _ WF-D _
    <- tgtmap`remove-associates-join-converse* WF-B DUB=F A-F=E A-D=G G-B=E.
      
%worlds () (tgtmap`remove-reorders* _ _ _ _).
%total { } (tgtmap`remove-reorders* _ _ _ _).


%theorem tgtmap`remove-reorders :
        forall* {A} {B} {C} {D} {E}
        forall {R1: tgtmap`remove A B C}
                {R2: tgtmap`remove C D E}
        exists {F}
                {R3: tgtmap`remove A D F}
                {R4: tgtmap`remove F B E}
        true.

- : tgtmap`remove-reorders A-B=C C-D=E G A-D=G G-B=E
    <- remove-implies-wf A-B=C WF-A _ _
    <- remove-implies-wf C-D=E _ WF-D _
    <- tgtmap`remove-total WF-A WF-D _ A-D=G
    <- tgtmap`remove-reorders* A-B=C C-D=E A-D=G G-B=E.

%worlds () (tgtmap`remove-reorders _ _ _ _ _).
%total { } (tgtmap`remove-reorders _ _ _ _ _).



%theorem tgtmap`disjoint-implies-remove-nothing :
        forall* {A} {B}
        forall {WF-A: wf-tgtmap A} {WF-B: wf-tgtmap B}
               {D: tgtmap`deep-disjoint A B}
        exists {R: tgtmap`remove A B A}
        true.

- : tgtmap`disjoint-implies-remove-nothing WF-A WF-B A^B A-B=A
    <- tgtmap`leq-reflexive A A<=A
    <- tgtmap`join-total* B A C BUA=C
    <- tgtmap`join-implies-leq BUA=C B<=C A<=C
    <- tgtmap`deep-disjoint-symmetric A^B B^A
    <- tgtmap`remove-characterization WF-A WF-B WF-A A<=A B^A BUA=C A<=C A-B=A.

%worlds () (tgtmap`disjoint-implies-remove-nothing _ _ _ _).
%total { } (tgtmap`disjoint-implies-remove-nothing _ _ _ _).


%theorem tgtmap`remove-subset-implies-join :
        forall* {A} {B} {C}
        forall {R: tgtmap`remove A B C}
                {L: tgtmap`leq B A}
        exists {U: tgtmap`join B C A}
        true.

- : tgtmap`remove-subset-implies-join A-B=C B<=A BUC=A
    <- tgtmap`remove-implies-leq A-B=C C<=A
    <- tgtmap`join-total* B C AX BUC=AX
    <- tgtmap`remove-implies-leq-join A-B=C BUC=AX A<=AX
    <- tgtmap`remove-implies-deep-disjoint A-B=C B^C
    <- tgtmap`disjoint-leq-implies-join-leq* B^C B<=A C<=A BUC=AX AX<=A.
    <- leq-anti-symmetric AX<=A A<=AX AX=A
    <- union-respects-eq BUC=AX eq/ eq/ AX=A BUC=A.

%worlds () (remove-subset-implies-union _ _ _).
%total { } (remove-subset-implies-union _ _ _).
    <- tgtmap`disjoint-leq-implies-join-leq* AP^S' AP<=DP S'<=DP APUS'=A A<=DP.

%theorem union-right-commutes-remove* :
        forall* {A} {B} {C} {D} {E} {F} {G}
        forall {R: remove A B C}
                {U1: union A G D}
                {R2: remove B G E}
                {U3: union C G F}
        exists {EP: remove D E F}
        true.

- : union-right-commutes-remove* A-B=C AUG=D B-G=E CUG=F D-E=F
    <- remove-implies-leq A-B=C C<=A
    <- union-implies-leq AUG=D A<=D G<=D
    <- leq-transitive C<=A A<=D C<=D
    <- union-is-lub CUG=F C<=D G<=D F<=D
    <- remove-implies-disjoint B-G=E G^E
    <- remove-implies-disjoint A-B=C B^C
    <- remove-implies-leq B-G=E E<=B
    <- disjoint-respects-geq* B^C E<=B E^C
    <- disjoint-symmetric E^C C^E
    <- union-preserves-disjoint* C^E G^E CUG=F F^E
    <- disjoint-symmetric F^E E^F
    <- union-total* B C I BUC=I
    <- union-total* E F H EUF=H
    <- union-commutative EUF=H FUE=H
    <- union-associative CUG=F FUE=H J GUE=J CUJ=H
    <- union-implies-leq GUE=J G<=J E<=J
    <- union-implies-leq CUJ=H C<=H J<=H
    <- remove-implies-leq-union A-B=C BUC=I A<=I
    <- remove-implies-leq-union B-G=E GUE=J B<=J
    <- leq-transitive B<=J J<=H B<=H
    <- leq-transitive G<=J J<=H G<=H
    <- union-is-lub BUC=I B<=H C<=H I<=H
    <- leq-transitive A<=I I<=H A<=H
    <- union-is-lub AUG=D A<=H G<=H D<=H
    <- remove-characterization F<=D E^F EUF=H D<=H D-E=F.

%worlds () (union-right-commutes-remove* _ _ _ _ _).
%total { } (union-right-commutes-remove* _ _ _ _ _).


%theorem union-right-commutes-remove :
        forall* {A} {B} {C} {G}
        forall {R: remove A B C}
        exists {D} {E} {F}
                {U1: union A G D}
                {R2: remove B G E}
                {U3: union C G F}
                {EP: remove D E F}
        true.

- : union-right-commutes-remove A-B=C D E F AUG=D B-G=E CUG=F D-E=F
    <- union-total AUG=D
    <- remove-total B-G=E
    <- union-total CUG=F
    <- union-right-commutes-remove* A-B=C AUG=D B-G=E CUG=F D-E=F.

%worlds () (union-right-commutes-remove _ _ _ _ _ _ _ _).
%total { } (union-right-commutes-remove _ _ _ _ _ _ _ _).


%theorem union-right-preserves-remove :
        forall* {A} {B} {C} {D} {G}
        forall {R: remove A B C}
                {U1: union A G D}
                {R2: leq G B}
        exists {EP: remove D B C}
        true.

- : union-right-preserves-remove A-B=C AUG=D G<=B D-B=C
    <- union-total* B C E BUC=E
    <- remove-implies-leq A-B=C C<=A
    <- remove-implies-leq-union A-B=C BUC=E A<=E
    <- remove-implies-disjoint A-B=C B^C
    <- union-implies-leq AUG=D A<=D G<=D
    <- union-implies-leq BUC=E B<=E C<=E
    <- leq-transitive C<=A A<=D C<=D
    <- leq-transitive G<=B B<=E G<=E
    <- union-is-lub AUG=D A<=E G<=E D<=E
    <- remove-characterization C<=D B^C BUC=E D<=E D-B=C.

%worlds () (union-right-preserves-remove _ _ _ _).
%total { } (union-right-preserves-remove _ _ _ _).


%theorem remove-right-distributes-over-union* :
        forall* {A} {B} {C} {D} {E} {F} {G}
        forall {U: union A B C}
                {R: remove C D E}
                {RA: remove A D F}
                {RB: remove B D G}
        exists {U: union F G E}
        true.

%theorem remove-right-distributes-over-union/L :
        forall* {A} {B} {C} {D} {E} {F} {G} {B?} {EP}
        forall {U: union A B C}
                {R: remove C D E}
                {RA: remove A D F}
                {RB: remove B D G}
                {U: union F G EP}
                {E?: eq? EP E B?}
        exists {E: eq EP E}
        true.

- : remove-right-distributes-over-union/L _ _ _ _ _ eq?/yes eq/.

- : remove-right-distributes-over-union/L AUB=C
        (remove/ E<=C D^E DUE=H C<=H)
        (remove/ F<=A D^F DUF=I A<=I)
        (remove/ G<=B D^G DUG=J B<=J) FUG=EP
        (ne/> X</-EP X<-E) EQ
    <- union-preserves-not-member-converse* X</-EP FUG=EP X</-F X</-G
    <- member-respects-leq X<-E E<=C X<-C
    <- disjoint-symmetric D^E E^D
    <- disjoint-member-implies-not-member X<-E E^D X</-D
    <- union-preserves-not-member* X</-D X</-F DUF=I X</-I
    <- union-preserves-not-member* X</-D X</-G DUG=J X</-J
    <- not-member-respects-geq X</-I A<=I X</-A
    <- not-member-respects-geq X</-J B<=J X</-B
    <- union-preserves-not-member* X</-A X</-B AUB=C X</-C
    <- member-not-member-contradiction X<-C X</-C FALSE
    <- false-implies-eq FALSE EQ.

%theorem remove-right-distributes-over-union/L/< :
        forall* {A} {B} {C} {D} {E} {F} {G} {X} {FB} {EP}
        forall {U: union A B C}
                {R: remove C D E}
                {RA: remove A D F}
                {RB: remove B D G}
                {U: union F G EP}
                {M: member EP X}
                {FM?: member? F X FB}
        exists {EM: member E X}
        true.

- : remove-right-distributes-over-union/L/< AUB=C
        (remove/ E<=C D^E DUE=H C<=H)
        (remove/ F<=A D^F DUF=I A<=I)
        (remove/ G<=B D^G DUG=J B<=J) FUG=EP X<-EP
        (member?/in X<-F) X<-E
    <- member-respects-leq X<-F F<=A X<-A
    <- union-right-preserves-member* X<-A AUB=C X<-C
    <- member-respects-leq X<-C C<=H X<-H
    <- disjoint-symmetric D^F F^D
    <- disjoint-member-implies-not-member X<-F F^D X</-D
    <- not-member-union-left-preserves-member-converse X</-D X<-H DUE=H X<-E.

- : remove-right-distributes-over-union/L/< AUB=C
        (remove/ E<=C D^E DUE=H C<=H)
        (remove/ F<=A D^F DUF=I A<=I)
        (remove/ G<=B D^G DUG=J B<=J) FUG=EP X<-EP
        (member?/out X</-F) X<-E
    <- not-member-union-left-preserves-member-converse X</-F X<-EP FUG=EP X<-G
    <- member-respects-leq X<-G G<=B X<-B
    <- union-left-preserves-member* X<-B AUB=C X<-C
    <- member-respects-leq X<-C C<=H X<-H
    <- disjoint-symmetric D^G G^D
    <- disjoint-member-implies-not-member X<-G G^D X</-D
    <- not-member-union-left-preserves-member-converse X</-D X<-H DUE=H X<-E.

%worlds () (remove-right-distributes-over-union/L/< _ _ _ _ _ _ _ _).
%total { } (remove-right-distributes-over-union/L/< _ _ _ _ _ _ _ _).

- : remove-right-distributes-over-union/L AUB=C C-D=E A-D=F B-D=G FUG=EP
        (ne/< X<-EP X</-E) EQ
    <- member?-total M?
    <- remove-right-distributes-over-union/L/<
        AUB=C C-D=E A-D=F B-D=G FUG=EP X<-EP M? X<-E
    <- member-not-member-contradiction X<-E X</-E FALSE
    <- false-implies-eq FALSE EQ.

%worlds () (remove-right-distributes-over-union/L _ _ _ _ _ _ _).
%total { } (remove-right-distributes-over-union/L _ _ _ _ _ _ _).

- : remove-right-distributes-over-union* U1 R1 R2 R3 U2
    <- union-total U2P
    <- eq?-total EQ?
    <- remove-right-distributes-over-union/L U1 R1 R2 R3 U2P EQ? EQ
    <- union-respects-eq U2P eq/ eq/ EQ U2.

%worlds () (remove-right-distributes-over-union* _ _ _ _ _).
%total { } (remove-right-distributes-over-union* _ _ _ _ _).


%theorem remove-right-distributes-over-union :
        forall* {A} {B} {C} {D} {E}
        forall {U: union A B C}
                {R: remove C D E}
        exists {F} {G}
                {RA: remove A D F}
                {RB: remove B D G}
                {U: union F G E}
        true.

- : remove-right-distributes-over-union U R1 _ _ R2 R3 UP
    <- remove-total R2
    <- remove-total R3
    <- remove-right-distributes-over-union* U R1 R2 R3 UP.

%worlds () (remove-right-distributes-over-union _ _ _ _ _ _ _).
%total { } (remove-right-distributes-over-union _ _ _ _ _ _ _).


%theorem remove-right-preserves-leq :
        forall* {A} {B} {C} {D} {E}
        forall {L: leq A D}
                {R: remove A B C}
                {RP: remove D B E}
        exists {LP: leq C E}
        true.

- : remove-right-preserves-leq A<=D A-B=C D-B=E C<=E
    <- remove-implies-leq A-B=C C<=A
    <- leq-transitive C<=A A<=D C<=D
    <- union-total* B E F BUE=F
    <- remove-implies-leq-union D-B=E BUE=F D<=F
    <- leq-transitive C<=D D<=F C<=F
    <- remove-implies-disjoint A-B=C B^C
    <- disjoint-symmetric B^C C^B
    <- leq-union-disjoint-implies-leq C<=F BUE=F C^B C<=E.

%worlds () (remove-right-preserves-leq _ _ _ _).
%total { } (remove-right-preserves-leq _ _ _ _).


%theorem remove-left-inverts-leq :
        forall* {A} {B} {C} {D} {E}
        forall {L: leq B D}
                {R1: remove A B C}
                {R2: remove A D E}
        exists {LP: leq E C}
        true.

%theorem remove-left-inverts-leq/L :
        forall* {A} {B} {C} {D} {E} {X}
        forall {L: leq B D}
                {R1: remove A B C}
                {R2: remove A D E}
                {L?: leq? E C X}
        exists {LP: leq E C}
        true.

- : remove-left-inverts-leq/L _ _ _ L L.

- : remove-left-inverts-leq/L B<=D A-B=C A-D=E (nle/< X<-E X/<-C) L
    <- remove-implies-leq A-D=E E<=A
    <- member-respects-leq X<-E E<=A X<-A
    <- remove-implies-disjoint A-D=E D^E
    <- disjoint-symmetric D^E E^D
    <- disjoint-member-implies-not-member X<-E E^D X/<-D
    <- not-member-respects-geq X/<-D B<=D X/<-B
    <- remove-preserves-member X<-A A-B=C X/<-B X<-C
    <- member-not-member-contradiction X<-C X/<-C F
    <- false-implies-leq F L.

%worlds () (remove-left-inverts-leq/L _ _ _ _ _).
%total { } (remove-left-inverts-leq/L _ _ _ _ _).

- : remove-left-inverts-leq B<=D A-B=C A-D=E E<=C
    <- leq?-total E<=C?
    <- remove-left-inverts-leq/L B<=D A-B=C A-D=E E<=C? E<=C.

%worlds () (remove-left-inverts-leq _ _ _ _).
%total { } (remove-left-inverts-leq _ _ _ _).


%theorem remove-right-preserves-disjoint :
        forall* {A} {B} {C} {D} {E}
        forall {L: disjoint A D}
                {R: remove A B C}
                {RP: remove D B E}
        exists {LP: disjoint C E}
        true.

- : remove-right-preserves-disjoint A^D A-B=C D-B=E C^E
    <- remove-implies-leq A-B=C C<=A
    <- remove-implies-leq D-B=E E<=D
    <- disjoint-respects-geq A^D C<=A E<=D C^E.

%worlds () (remove-right-preserves-disjoint _ _ _ _).
%total { } (remove-right-preserves-disjoint _ _ _ _).


%theorem remove-right-distributes-over-intersection* :
        forall* {A} {B} {C} {D} {E} {F} {G}
        forall {U: intersection A B C}
                {R: remove C D E}
                {RA: remove A D F}
                {RB: remove B D G}
        exists {U: intersection F G E}
        true.

%theorem remove-right-distributes-over-intersection/L :
        forall* {A} {B} {C} {D} {E} {F} {G} {X} {Y} {B?}
        forall {U: intersection A B C}
                {R: remove C D E}
                {RA: remove A D F}
                {RB: remove B D G}
                {RF: remove F E X}
                {RG: remove G E Y}
                {D?: disjoint? X Y B?}
        exists {D: disjoint X Y}
        true.

- : remove-right-distributes-over-intersection/L _ _ _ _ _ _
        (disjoint?/yes D) D.

- : remove-right-distributes-over-intersection/L
        A^B=C C-D=E A-D=F B-D=G F-E=X G-E=Y (disjoint?/no XM YM) X^Y
    <- remove-implies-disjoint F-E=X E^X
    <- disjoint-symmetric E^X X^E
    <- disjoint-member-implies-not-member XM X^E ENM
    <- remove-implies-leq F-E=X X<=F
    <- remove-implies-leq G-E=Y Y<=G
    <- member-respects-leq XM X<=F FM
    <- member-respects-leq YM Y<=G GM
    <- remove-implies-disjoint A-D=F D^F
    <- disjoint-symmetric D^F F^D
    <- disjoint-member-implies-not-member FM F^D DNM
    <- union-total* D E H DUE=H
    <- union-preserves-not-member* DNM ENM DUE=H HNM
    <- remove-implies-leq-union C-D=E DUE=H C<=H
    <- not-member-respects-geq HNM C<=H CNM
    <- remove-implies-leq A-D=F F<=A
    <- remove-implies-leq B-D=G G<=B
    <- member-respects-leq FM F<=A AM
    <- member-respects-leq GM G<=B BM
    <- intersection-preserves-member AM BM A^B=C CM
    <- member-not-member-contradiction CM CNM FALSE
    <- false-implies-disjoint FALSE X^Y.

%worlds () (remove-right-distributes-over-intersection/L _ _ _ _ _ _ _ _).
%total { } (remove-right-distributes-over-intersection/L _ _ _ _ _ _ _ _).

- : remove-right-distributes-over-intersection* A^B=C C-D=E A-D=F B-D=G F^G=E
    <- intersection-implies-leq A^B=C C<=A C<=B
    <- remove-right-preserves-leq C<=A C-D=E A-D=F E<=F
    <- remove-right-preserves-leq C<=B C-D=E B-D=G E<=G
    <- remove-total* F E X F-E=X
    <- remove-total* G E Y G-E=Y
    <- remove-subset-implies-union F-E=X E<=F EUX=F
    <- remove-subset-implies-union G-E=Y E<=G EUY=G
    <- disjoint?-total X^Y?
    <- remove-right-distributes-over-intersection/L
        A^B=C C-D=E A-D=F B-D=G F-E=X G-E=Y X^Y? X^Y
    <- intersection-characterization EUX=F EUY=G X^Y F^G=E.

%worlds () (remove-right-distributes-over-intersection* _ _ _ _ _).
%total { } (remove-right-distributes-over-intersection* _ _ _ _ _).


%theorem remove-right-distributes-over-intersection :
        forall* {A} {B} {C} {D} {E}
        forall {U: intersection A B C}
                {R: remove C D E}
        exists {F} {G}
                {RA: remove A D F}
                {RB: remove B D G}
                {U: intersection F G E}
        true.

- : remove-right-distributes-over-intersection U R _ _ RA RB UP
    <- remove-total RA
    <- remove-total RB
    <- remove-right-distributes-over-intersection* U R RA RB UP.

%worlds () (remove-right-distributes-over-intersection _ _ _ _ _ _ _).
%total { } (remove-right-distributes-over-intersection _ _ _ _ _ _ _).


%theorem not-member-add-implies-remove :
        forall* {A} {N} {B}
        forall {NM: not-member A N}
                {AD: add A N B}
        exists {R: remove B (set/1 N) A}
        true.

- : not-member-add-implies-remove NM A+N=B SR
    <- not-member-update-implies-unit-union NM A+N=B AUN=B
    <- union-commutative AUN=B NUA=B
    <- union-implies-leq NUA=B _ A<=B
    <- not-member-implies-unit-disjoint NM A^N
    <- disjoint-symmetric A^N N^A
    <- leq-reflexive B B<=B
    <- remove-characterization A<=B N^A NUA=B B<=B SR.

%worlds () (not-member-add-implies-remove _ _ _).
%total { } (not-member-add-implies-remove _ _ _).


%theorem remove-idempotent :
        forall* {A} {B} {C}
        forall {R:remove A B C}
        exists {R:remove C B C}
        true.

- : remove-idempotent A-B=C C-B=C
    <- remove-implies-disjoint A-B=C B^C
    <- disjoint-symmetric B^C C^B
    <- disjoint-implies-remove-nothing C^B C-B=C.

%worlds () (remove-idempotent _ _).
%total { } (remove-idempotent _ _).
