%%% remove operation on tgtmap.

%%% all these definitions and theorems are
%%% similar to set`remove.


tgtmap`remove : tgtmap -> tgtmap -> tgtmap -> type.

% tgtmap`remove/0 : tgtmap`remove tgtmap/0 _ tgtmap/0.

% tgtmap`remove/+/hit
%   : tgtmap`remove (tgtmap/+ F S1 M1) M2 M3
%     <- tgtmap`lookup M2 F S2
%     <- set`remove S1 S2 S3
%     <- tgtmap`shift F M1 M1P
%     <- tgtmap`remove M1P M2 M3P
%     <- tgtmap`update M3P F S3 M3.

% tgtmap`remove/+/miss
%   : tgtmap`remove (tgtmap/+ F S1 M1) M2 M3
%     <- tgtmap`fresh M2 F
%     <- tgtmap`shift F M1 M1P
%     <- tgtmap`remove M1P M2 M3P
%     <- tgtmap`update M3P F S1 M3.

% M2 = (map/1 (set/+ D1 (set/+ D2 set/0)))
% M1 = (map/1 (set/+ D3 set/0))
% M3 = (map/1 (set/+ D3 set/0))
tgtmap`remove/
  : tgtmap`leq M3 M1 -> 
	tgtmap`deep-disjoint M2 M3 ->
	tgtmap`join M2 M3 M4 ->
	tgtmap`leq M1 M4 ->
	tgtmap`remove M1 M2 M3.
		   

%%%% theorems


%theorem tgtmap`join-is-lub :
        forall* {M1} {M2} {M3} {M4}
        forall {J:tgtmap`join M1 M2 M3}
               {L1:tgtmap`leq M1 M4} {L2:tgtmap`leq M2 M4}
        exists {L3:tgtmap`leq M3 M4}
        true.

- : tgtmap`join-is-lub tgtmap`join/L _ L L.

- : tgtmap`join-is-lub tgtmap`join/R L _ L.

- : tgtmap`join-is-lub
    (tgtmap`join/= M1+M2=M3 D1+D2=D3 nat`eq/)
    (tgtmap`leq/= M1<=M4 D1<=D4 nat`eq/)
    (tgtmap`leq/= M2<=M4 D2<=D4 nat`eq/)
    (tgtmap`leq/= M3<=M4 D3<=D4 nat`eq/)
    <- set`union-is-lub D1+D2=D3 D1<=D4 D2<=D4 D3<=D4
    <- tgtmap`join-is-lub M1+M2=M3 M1<=M4 M2<=M4 M3<=M4.

- : tgtmap`join-is-lub (tgtmap`join/= _ _ nat`eq/)
    (tgtmap`leq/= _ _ nat`eq/) (tgtmap`leq/> _ N3+1+N=N) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub (tgtmap`join/= _ _ nat`eq/)
    (tgtmap`leq/> _ N3+1+N=N) (tgtmap`leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub
    (tgtmap`join/= M1+M2=M3 D1+D2=D3 nat`eq/)
    (tgtmap`leq/> M511<=M4 N5+1+N4=N)
    (tgtmap`leq/> M622<=M4 N6+1+N4=N)
    (tgtmap`leq/> M633<=M4 N6+1+N4=N)
    <- nat`plus-right-cancels N5+1+N4=N N6+1+N4=N nat`eq/ nat`eq/ N5+1=N6+1
    <- nat`succ-cancels N5+1=N6+1 N5=N6
    <- tgtmap`map/+-preserves-eq N5=N6 set`eq/ tgtmap`eq/ M511=M611
    <- tgtmap`leq-respects-eq M511<=M4 M511=M611 tgtmap`eq/ M611<=M4
    <- tgtmap`join-is-lub (tgtmap`join/= M1+M2=M3 D1+D2=D3 nat`eq/)
                   M611<=M4 M622<=M4 M633<=M4.

- : tgtmap`join-is-lub (tgtmap`join/< _ N0+1+N=N)
    (tgtmap`leq/= _ _ nat`eq/) (tgtmap`leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub
    (tgtmap`join/< M1+M022=M3 N0+1+N1=N2)
    (tgtmap`leq/= M1<=M4 D1<=D4 nat`eq/)
    (tgtmap`leq/> M622<=M4 N6+1+N1=N2)
    (tgtmap`leq/= M3<=M4 D1<=D4 nat`eq/)
    <- nat`plus-right-cancels
      N6+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N6+1=N0+1
    <- succ-cancels N6+1=N0+1 N6=N0
    <- tgtmap`map/+-preserves-eq N6=N0 set`eq/ tgtmap`eq/ M622=M022
    <- tgtmap`leq-respects-eq M622<=M4 M622=M022 tgtmap`eq/ M022<=M4
    <- tgtmap`join-is-lub M1+M022=M3 M1<=M4 M022<=M4 M3<=M4.

- : tgtmap`join-is-lub (tgtmap`join/< _ N0+1+N1=N2)
    (tgtmap`leq/> _ N3+1+N2=N1) (tgtmap`leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub
    (tgtmap`join/< M1+M022=M3 N0+1+N1=N2)
    (tgtmap`leq/> M511<=M4 N5+1+N4=N1)
    (tgtmap`leq/> M622<=M4 N6+1+N4=N2)
    (tgtmap`leq/> M513<=M4 N5+1+N4=N1)
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-associative-converse
      N5+N4+1=N1 N0+1+N1=N2 N6P N0+1+N5=N6P N6P+N4+1=N2
    <- nat`plus-swap-succ-converse N6P+N4+1=N2 N6P+1+N4=N2
    <- nat`plus-right-cancels
      N6P+1+N4=N2 N6+1+N4=N2 nat`eq/ nat`eq/ N6P+1=N6+1
    <- nat`succ-cancels N6P+1=N6+1 N6P=N6
    <- nat`plus-respects-eq N0+1+N5=N6P nat`eq/ nat`eq/ N6P=N6 N0+1+N5=N6
    <- tgtmap`join-is-lub (tgtmap`join/< M1+M022=M3 N0+1+N5=N6) 
      M511<=M4 M622<=M4 M513<=M4.

- : tgtmap`join-is-lub (tgtmap`join/> _ N3+1+N=N)
    (tgtmap`leq/= _ _ nat`eq/) (tgtmap`leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub (tgtmap`join/> _ N3+1+N2=N1)
    (tgtmap`leq/= _ _ nat`eq/) (tgtmap`leq/> _ N0+1+N1=N2) L
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- tgtmap`false-implies-leq F L.

- : tgtmap`join-is-lub
    (tgtmap`join/> M311+M2=M3 N3+1+N2=N1)
    (tgtmap`leq/> M511<=M4 N5+1+N2=N1)
    (tgtmap`leq/= M2<=M4 D2<=D4 nat`eq/)
    (tgtmap`leq/= M3<=M4 D2<=D4 nat`eq/)
    <- nat`plus-right-cancels
      N3+1+N2=N1 N5+1+N2=N1 nat`eq/ nat`eq/ N3+1=N5+1
    <- nat`succ-cancels N3+1=N5+1 N3=N5
    <- tgtmap`map/+-preserves-eq N3=N5 set`eq/ tgtmap`eq/ M311=M511
    <- tgtmap`join-respects-eq 
      M311+M2=M3 M311=M511 tgtmap`eq/ tgtmap`eq/ M511+M2=M3
    <- tgtmap`join-is-lub M511+M2=M3 M511<=M4 M2<=M4 M3<=M4.

- : tgtmap`join-is-lub
    (tgtmap`join/> M311+M2=M3 N3+1+N2=N1)
    (tgtmap`leq/> M511<=M4 N5+1+N4=N1)
    (tgtmap`leq/> M622<=M4 N6+1+N4=N2)
    (tgtmap`leq/> M623<=M4 N6+1+N4=N2)
    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- nat`plus-associative-converse
      N6+N4+1=N2 N3+1+N2=N1 N5P N3+1+N6=N5P N5P+N4+1=N1
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-right-cancels N5P+N4+1=N1 N5+N4+1=N1 nat`eq/ nat`eq/ N5P=N5
    <- nat`plus-respects-eq N3+1+N6=N5P nat`eq/ nat`eq/ N5P=N5 N3+1+N6=N5
    <- tgtmap`join-is-lub (tgtmap`join/> M311+M2=M3 N3+1+N6=N5) 
      M511<=M4 M622<=M4 M623<=M4.

%worlds () (tgtmap`join-is-lub _ _ _ _).
%total (L) (tgtmap`join-is-lub _ L _ _).


%theorem tgtmap`fresh-implies-unit-deep-disjoint :
    forall* {N} {M} {D}
    forall  {F:tgtmap`fresh M N}
    exists  {D: tgtmap`deep-disjoint 
		M (tgtmap`map/+ N D tgtmap`map/0)}
    true.

- : tgtmap`fresh-implies-unit-deep-disjoint 
    tgtmap`fresh/0 tgtmap`deep-disjoint/L.

- : tgtmap`fresh-implies-unit-deep-disjoint
    (tgtmap`fresh/< G) (tgtmap`deep-disjoint/> tgtmap`deep-disjoint/R P)
    <- gt-implies-plus G _ P.

- : tgtmap`fresh-implies-unit-deep-disjoint
    (tgtmap`fresh/> F P) (tgtmap`deep-disjoint/< D P)
    <- tgtmap`fresh-implies-unit-deep-disjoint F D.

%worlds () (tgtmap`fresh-implies-unit-deep-disjoint _ _).
%total (F) (tgtmap`fresh-implies-unit-deep-disjoint F _).



%theorem tgtmap`can-remove :
    forall* {M} {S} {N} {D}
    forall  {SZ:tgtmap`size M S} {L:tgtmap`lookup M N D}
    exists  {M-} {S-} {SZ-:tgtmap`size M- S-} {E:nat`eq (s S-) S}
            {U:tgtmap`update M- N D M} {F:tgtmap`fresh M- N}
    true.

- : tgtmap`can-remove (tgtmap`size/+ _) (tgtmap`lookup/= _) 
    _ _ tgtmap`size/0 nat`eq/ tgtmap`update/0 tgtmap`fresh/0.

- : tgtmap`can-remove (tgtmap`size/+ (tgtmap`size/+ SZ))
    (tgtmap`lookup/= nat`eq/) _ _ (tgtmap`size/+ SZ) nat`eq/
    (tgtmap`update/< N3+1+N2=N1) (tgtmap`fresh/< N1>N2)
    <- plus-total N3+1+N2=N1
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2.

- : tgtmap`can-remove
    (tgtmap`size/+ SZ) (tgtmap`lookup/> LK N0+1+N1=N2) _ _
    (tgtmap`size/+ SZ2) E
    (tgtmap`update/> U2 N0+1+N1=N2) (tgtmap`fresh/> F2 N0+1+N1=N2)
    <- tgtmap`can-remove SZ LK M- S- SZ2 E2 U2 F2
    <- succ-deterministic E2 E.

%worlds () (tgtmap`can-remove _ _ _ _ _ _ _ _).
%total (L) (tgtmap`can-remove _ L _ _ _ _ _ _).


%theorem tgtmap`can-remove* :
    forall* {M} {S}
    forall  {SZ:tgtmap`size M (s S)}
    exists  {MP} {N} {D}
            {SZP:tgtmap`size MP S}
            {U:tgtmap`update MP N D M}
            {F:tgtmap`fresh MP N}
    true.

- : tgtmap`can-remove* (tgtmap`size/+ SZ) MP N D SZP U F
    <- tgtmap`can-remove (tgtmap`size/+ SZ)
      (tgtmap`lookup/= nat`eq/) MP NP SZPP EQ U F
    <- succ-cancels EQ EQP
    <- tgtmap`size-respects-eq SZPP tgtmap`eq/ EQP SZP.

%worlds () (tgtmap`can-remove* _ _ _ _ _ _ _).
%total { } (tgtmap`can-remove* _ _ _ _ _ _ _).


%theorem tgtmap`false-implies-remove :
        forall* {S1} {S2} {S3}
        forall {F:void}
        exists {D:tgtmap`remove S1 S2 S3}
        true.

%worlds () (tgtmap`false-implies-remove _ %{=>}% S1-S2=S3).
%total {} (tgtmap`false-implies-remove _ _).


%theorem tgtmap`remove-respects-eq :
        forall* {S1} {S2} {S3} {T1} {T2} {T3}
        forall  {DS:tgtmap`remove S1 S2 S3}
                {E1:tgtmap`eq S1 T1} {E2:tgtmap`eq S2 T2} 
                {E3:tgtmap`eq S3 T3}
        exists  {DT:tgtmap`remove T1 T2 T3}
        true.

- : tgtmap`remove-respects-eq R tgtmap`eq/ tgtmap`eq/ tgtmap`eq/ R.

%worlds () 
(tgtmap`remove-respects-eq S1-S2=S3 S1=T1 S2=T2 S3=T3 %{=>}% T1-T2=T3).
%total {} (tgtmap`remove-respects-eq _ _ _ _ _).
%reduces R = RP (tgtmap`remove-respects-eq R _ _ _ RP).


%theorem tgtmap`remove-total* :
        forall {S1} {S2}
        exists {S3} {R:tgtmap`remove S1 S2 S3}
        true.

%abbrev tgtmap`remove-total = tgtmap`remove-total* _ _ _.

%theorem tgtmap`remove-total/L1 :
        forall* {A} {B}
        forall  {N} {S: tgtmap`size A N}
        exists  {C}
                {R:tgtmap`remove A B C}
        true.

%theorem tgtmap`remove-total/L2 :
        forall* {B} {A} {AP} {CP} {X} {B?} {M}
        forall  {FS: tgtmap`fresh AP X}
                {AD: tgtmap`update AP X M A}
                {R: tgtmap`remove AP B CP}
                {D?: tgtmap`domain? B X B?}
        exists  {C} {R:tgtmap`remove A B C}
        true.

% here X is in B's domain but it may points to a different
% set than M
% X<-B 
% - : tgtmap`remove-total/L2 FS AP+X=A
%     (tgtmap`remove/ CP<=AP B^CP BUCP=DP AP<=DP) 
%     (tgtmap`domain?/in X<-B) CP
%     (tgtmap`remove/ CP<=A B^CP BUCP=DP A<=DP)
%      <- tgtmap`fresh-update-implies-unit-join FS AP+X=A APUX=A
%      <- tgtmap`join-implies-leq APUX=A AP<=A X<=A
%      <- tgtmap`leq-transitive CP<=AP AP<=A CP<=A
%      <- tgtmap`join-implies-leq BUCP=DP B<=DP CP<=DP
%      <- tgtmap`lookup-respects-leq X<-B B<=DP _ XP<-DP S<=SP
%      <- tgtmap`lookup-implies-unit-leq XP<-DP XP<=DP
%      <- tgtmap`leq-transitive
%        (tgtmap`leq/= tgtmap`leq/0 S<=SP nat`eq/) XP<=DP X<=DP .

- : tgtmap`remove-total/L2 FS AP+X=A
    (tgtmap`remove/ CP<=AP B^CP BUCP=DP AP<=DP) (tgtmap`domain?/out X</-B) C
    (tgtmap`remove/ C<=A B^C BUC=D A<=D)
    <- tgtmap`fresh-implies-unit-deep-disjoint X</-B B^X
    <- tgtmap`join-total* CP (tgtmap/+ X M tgtmap/0) C CPUX=C
    <- tgtmap`join-right-preserves-deep-disjoint* B^CP B^X CPUX=C B^C
     <- tgtmap`fresh-update-implies-unit-join FS AP+X=A APUX=A
%    <- add-implies-unit-union AP+X=A APUX=A
    <- tgtmap`join-implies-leq APUX=A AP<=A X<=A
    <- tgtmap`leq-transitive CP<=AP AP<=A CP<=A
    <- tgtmap`join-is-lub CPUX=C CP<=A X<=A C<=A
    <- tgtmap`join-total* DP (tgtmap/+ X M tgtmap/0) D DPUX=D
    <- tgtmap`join-associative* BUCP=DP DPUX=D CPUX=C BUC=D
    <- tgtmap`join-implies-leq DPUX=D DP<=D X<=D
    <- tgtmap`leq-transitive AP<=DP DP<=D AP<=D
    <- tgtmap`join-is-lub APUX=A AP<=D X<=D A<=D.

%worlds () (tgtmap`remove-total/L2 _ _ _ _ _ _).
%trustme %total { } (tgtmap`remove-total/L2 _ _ _ _ _ _).

- : tgtmap`remove-total/L1
    _ tgtmap`size/0 _ 
    (tgtmap`remove/ tgtmap`leq/0 tgtmap`deep-disjoint/R tgtmap`join/R tgtmap`leq/0).

- : tgtmap`remove-total/L1 _ SZ C A-B=C
    <- tgtmap`can-remove* SZ AP X _ SZP AP+X=A FS
    <- tgtmap`remove-total/L1 _ SZP CP AP-B=CP
    <- tgtmap`domain?-total M?
    <- tgtmap`remove-total/L2 FS AP+X=A AP-B=CP M? C A-B=C.

%worlds () (tgtmap`remove-total/L1 _ _ _ _).
%total (N) (tgtmap`remove-total/L1 N _ _ _).

- : tgtmap`remove-total R
    <- tgtmap`size-total SZ
    <- tgtmap`remove-total/L1 _ SZ _ R.

%worlds () (tgtmap`remove-total* _ _ _ _).
%total { } (tgtmap`remove-total* _ _ _ _).



% remove is NOT deterministic: for instance
% remove (tgtmap/1 N (set/1 K)) (tgtmap/1 N (set/1 K)) could be
% either (tgtmap/1 N set/0) OR tgtmap/0



%theorem tgtmap`remove-implies-deep-disjoint :
    forall* {M1} {M2} {M3}
    forall  {D: tgtmap`remove M1 M2 M3}
    exists  {I: tgtmap`deep-disjoint M2 M3}
    true.

- : tgtmap`remove-implies-deep-disjoint
    (tgtmap`remove/ _ M2^M3 _ _) M2^M3.
    
%worlds () (tgtmap`remove-implies-deep-disjoint _ _).
%total  {} (tgtmap`remove-implies-deep-disjoint _ _).


%theorem tgtmap`remove-implies-leq :
    forall* {M1} {M2} {M3}
    forall  {D: tgtmap`remove M1 M2 M3}
    exists  {L: tgtmap`leq M3 M1}
    true.

- : tgtmap`remove-implies-leq (tgtmap`remove/ L _ _ _) L.

%worlds () (tgtmap`remove-implies-leq _ _).
%total  {} (tgtmap`remove-implies-leq _ _).


%theorem tgtmap`remove-implies-leq-join :
    forall* {M1} {M2} {M3} {M4}
    forall  {D: tgtmap`remove M1 M2 M3}
            {U: tgtmap`join M2 M3 M4}
    exists  {L: tgtmap`leq M1 M4}
    true.

- : tgtmap`remove-implies-leq-join
    (tgtmap`remove/ M3<=M1 M2^M3 M2UM3=M4 M1<=M4) M2UM3=M5 M1<=M5
    <- tgtmap`join-deterministic 
      M2UM3=M4 M2UM3=M5 tgtmap`eq/ tgtmap`eq/ M4=M5
    <- tgtmap`leq-respects-eq M1<=M4 tgtmap`eq/ M4=M5 M1<=M5.

%worlds () (tgtmap`remove-implies-leq-join _ _ _).
%total  {} (tgtmap`remove-implies-leq-join _ _ _).


%theorem tgtmap`leq-implies-remove-all :
    forall* {M1} {M2}
    forall  {L: tgtmap`leq M1 M2}
    exists  {R: tgtmap`remove M1 M2 tgtmap/0}
    true.

- : tgtmap`leq-implies-remove-all M1<=M2
    (tgtmap`remove/ tgtmap`leq/0 
      tgtmap`deep-disjoint/R tgtmap`join/R M1<=M2).

%worlds () (tgtmap`leq-implies-remove-all _ _).
%total  {} (tgtmap`leq-implies-remove-all _ _).


%theorem tgtmap`remove-characterization:
        forall* {A} {B} {C} {D}
        forall {L: tgtmap`leq C A}
                {I: tgtmap`deep-disjoint B C}
                {U: tgtmap`join B C D}
                {G: tgtmap`leq A D}
        exists {R: tgtmap`remove A B C}
        true.

- : tgtmap`remove-characterization D1 D2 D3 D4 (tgtmap`remove/ D1 D2 D3 D4).

%worlds () (tgtmap`remove-characterization _ _ _ _ _).
%total { } (tgtmap`remove-characterization _ _ _ _ _).


%theorem tgtmap`remove-submap-implies-join :
    forall* {M1} {M2} {M3}
    forall  {R: tgtmap`remove M1 M2 M3}
            {L: tgtmap`leq M2 M1}
    exists  {J: tgtmap`join M2 M3 M1}
    true.

%worlds () (tgtmap`remove-submap-implies-join _ _ _).
%trustme %total  {} (tgtmap`remove-submap-implies-join _ _ _).


%theorem tgtmap`remove-preserves-lookup :
    forall* {M1} {M2} {M3} {X} {S}
    forall {M: tgtmap`lookup M1 X S}
           {R: tgtmap`remove M1 M2 M3}
           {N: tgtmap`fresh M2 X}
    exists {M: tgtmap`lookup M3 X S}
    true.

- : tgtmap`remove-preserves-lookup M1 R NM2 M5
    <- tgtmap`join-total BUC=D
    <- tgtmap`remove-implies-leq-join R BUC=D A<=D
    <- tgtmap`lookup-respects-leq M1 A<=D _ M4 LE
    <- tgtmap`fresh-join-left-preserves-lookup-converse NM2 M4 BUC=D M3
    <- tgtmap`remove-implies-leq R C<=A
    <- tgtmap`lookup-respects-leq* M3 C<=A M1 LE2
    <- set`leq-anti-symmetric LE2 LE EQ
    <- tgtmap`lookup-respects-eq M3 tgtmap`eq/ nat`eq/ EQ M5.

%worlds () (tgtmap`remove-preserves-lookup _ _ _ _).
%total { } (tgtmap`remove-preserves-lookup _ _ _ _).


%theorem tgtmap`remove-associates-join* :
        forall* {A} {B} {C} {D} {E} {F}
        forall {R1: tgtmap`remove A B C}
                {R2: tgtmap`remove C D E}
                {U: tgtmap`join B D F}
        exists {R3: tgtmap`remove A F E}
        true.

- : tgtmap`remove-associates-join*
        (tgtmap`remove/ C<=A B^C BUC=G A<=G)
        (tgtmap`remove/ E<=C D^E DUE=H C<=H) BUD=F
        (tgtmap`remove/ E<=A F^E FUE=I A<=I)
    <- tgtmap`leq-transitive E<=C C<=A E<=A
    <- tgtmap`join-total BUH=I
    <- tgtmap`join-associative-converse* DUE=H BUH=I BUD=F FUE=I
    <- tgtmap`leq-reflexive B B<=B
    <- tgtmap`deep-disjoint-respects-geq B^C B<=B E<=C B^E
    <- tgtmap`join-preserves-deep-disjoint* B^E D^E BUD=F F^E
    <- tgtmap`join-left-preserves-leq* C<=H BUC=G BUH=I G<=I
    <- tgtmap`leq-transitive A<=G G<=I A<=I.

%worlds () (tgtmap`remove-associates-join* _ _ _ _).
%total { } (tgtmap`remove-associates-join* _ _ _ _).


%theorem tgtmap`remove-associates-join :
        forall* {A} {B} {C} {D} {E}
        forall  {R1: tgtmap`remove A B C}
                {R2: tgtmap`remove C D E}
        exists  {F}
                {U: tgtmap`join B D F}
                {R3: tgtmap`remove A F E}
        true.

- : tgtmap`remove-associates-join A-B=C C-D=E F BUD=F A-F=E
    <- tgtmap`join-total BUD=F
    <- tgtmap`remove-associates-join* A-B=C C-D=E BUD=F A-F=E.

%worlds () (tgtmap`remove-associates-join _ _ _ _ _).
%total { } (tgtmap`remove-associates-join _ _ _ _ _).


% %theorem todo :
%     forall* {XM1} {XM2:efxmap} {GM1} {GM} {XM2} {XM3}
%     forall  {LE: efxmap`leq XM1 XM2}
%             {XM=>GM: efxmap=>tgtmap XM1 GM1}
%             {DJ: tgtmap`deep-disjoint GM1 GM}
%             {RM: efxmap`remove-tgtmap XM2 GM XM3}
%     exists  {LE: efxmap`leq XM1 XM3}
%     true.



