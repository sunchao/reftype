%%%%% Permission implication
%%%%% John Boyland

%{%
Permission implication is a form of permission transformation.
Pi1 |= Pi2 means that whenever we have h |=_N Pi1, then h |=_N Pi2.
Here, instead, we define a relation Pi1 |- Pi2 extensionally,
and then prove that it satisfies the intensional definition.
This proof can also be viewed as the proof of many examples of
intensional implications (as in the article).

For boolean formulae, we have an extra parameter.  Then
G |-b-> G' means if A;N |- G V b, then A;N |- G' V b.
Unfortunately G |-b-> G' is not identical to G' |-~b-> G

%}%



%%%% Definitions

 %abbrev scale = permission`scale.

%% implication itself

implies : permission -> permission -> type.

bimplies : bool -> formula -> formula -> type. 


%% force reflexivity and transitivity

% NB: implies/reflexive is an abbrevation

bimplies/reflexive : bimplies B G G.

implies/trans : implies Pi1 Pi2 -> implies Pi2 Pi3 -> implies Pi1 Pi3.

bimplies/trans : bimplies B G1 G2 -> bimplies B G2 G3 -> bimplies B G1 G3.

%abbrev bimplies/trans2 = bimplies/trans.

%abbrev bimplies/trans3 
	: bimplies B Pi1 Pi2 -> bimplies B Pi2 Pi3 -> bimplies B Pi3 Pi4 ->
	  bimplies B Pi1 Pi4
	= [I12] [I23] [I34] (bimplies/trans (bimplies/trans I12 I23) I34).

%abbrev bimplies/trans4
	: bimplies B Pi1 Pi2 -> bimplies B Pi2 Pi3 -> bimplies B Pi3 Pi4 ->
	  bimplies B Pi4 Pi5 -> bimplies B Pi1 Pi5
	= [I12] [I23] [I34] [I45] 
	  (bimplies/trans (bimplies/trans3 I12 I23 I34) I45).

%abbrev bimplies/trans5
	: bimplies B Pi1 Pi2 -> bimplies B Pi2 Pi3 -> bimplies B Pi3 Pi4 ->
	  bimplies B Pi4 Pi5 -> bimplies B Pi5 Pi6 -> bimplies B Pi1 Pi6
	= [I12] [I23] [I34] [I45] [I56]
	  (bimplies/trans (bimplies/trans2 I12 I23) (bimplies/trans3 I34 I45 I56)).

%abbrev implies/trans2 = implies/trans.

%abbrev implies/trans3 
	: implies Pi1 Pi2 -> implies Pi2 Pi3 -> implies Pi3 Pi4 ->
	  implies Pi1 Pi4
	= [I12] [I23] [I34] (implies/trans (implies/trans I12 I23) I34).

%abbrev implies/trans4
	: implies Pi1 Pi2 -> implies Pi2 Pi3 -> implies Pi3 Pi4 ->
	  implies Pi4 Pi5 -> implies Pi1 Pi5
	= [I12] [I23] [I34] [I45] 
	  (implies/trans (implies/trans3 I12 I23 I34) I45).

%abbrev implies/trans5
	: implies Pi1 Pi2 -> implies Pi2 Pi3 -> implies Pi3 Pi4 ->
	  implies Pi4 Pi5 -> implies Pi5 Pi6 -> implies Pi1 Pi6
	= [I12] [I23] [I34] [I45] [I56]
	  (implies/trans (implies/trans2 I12 I23) (implies/trans3 I34 I45 I56)).

%abbrev implies/trans6
	: implies Pi1 Pi2 -> implies Pi2 Pi3 -> implies Pi3 Pi4 ->
	  implies Pi4 Pi5 -> implies Pi5 Pi6 -> implies Pi6 Pi7 ->
	  implies Pi1 Pi7
	= [I12] [I23] [I34] [I45] [I56] [I67]
	  (implies/trans (implies/trans3 I12 I23 I34) 
	     (implies/trans3 I45 I56 I67)).

%abbrev implies/trans7
	: implies Pi1 Pi2 -> implies Pi2 Pi3 -> implies Pi3 Pi4 ->
	  implies Pi4 Pi5 -> implies Pi5 Pi6 -> implies Pi6 Pi7 ->
	  implies Pi7 Pi8 -> implies Pi1 Pi8
	= [I12] [I23] [I34] [I45] [I56] [I67] [I78]
	  (implies/trans (implies/trans3 I12 I23 I34) 
	     (implies/trans4 I45 I56 I67 I78)).

%abbrev implies/trans8
	: implies Pi1 Pi2 -> implies Pi2 Pi3 -> implies Pi3 Pi4 ->
	  implies Pi4 Pi5 -> implies Pi5 Pi6 -> implies Pi6 Pi7 ->
	  implies Pi7 Pi8 -> implies Pi8 Pi9 -> implies Pi1 Pi9
	= [I12] [I23] [I34] [I45] [I56] [I67] [I78] [I89]
	  (implies/trans (implies/trans4 I12 I23 I34 I45) 
	     (implies/trans4 I56 I67 I78 I89)).

%abbrev implies/trans9
	: implies Pi1 Pi2 -> implies Pi2 Pi3 -> implies Pi3 Pi4 ->
	  implies Pi4 Pi5 -> implies Pi5 Pi6 -> implies Pi6 Pi7 ->
	  implies Pi7 Pi8 -> implies Pi8 Pi9 -> implies Pi9 Pi10 ->
	  implies Pi1 Pi10
	= [I12] [I23] [I34] [I45] [I56] [I67] [I78] [I89] [I90]
	  (implies/trans (implies/trans4 I12 I23 I34 I45) 
	     (implies/trans5 I56 I67 I78 I89 I90)).

%abbrev implies/trans10
	: implies Pi1 Pi2 -> implies Pi2 Pi3 -> implies Pi3 Pi4 ->
	  implies Pi4 Pi5 -> implies Pi5 Pi6 -> implies Pi6 Pi7 ->
	  implies Pi7 Pi8 -> implies Pi8 Pi9 -> implies Pi9 Pi10 ->
	  implies Pi10 Pi11 -> implies Pi1 Pi11
	= [I12] [I23] [I34] [I45] [I56] [I67] [I78] [I89] [I90] [I01]
	  (implies/trans (implies/trans5 I12 I23 I34 I45 I56) 
	     (implies/trans5 I67 I78 I89 I90 I01)).

%abbrev implies/trans11
	: implies Pi1 Pi2 -> implies Pi2 Pi3 -> implies Pi3 Pi4 ->
	  implies Pi4 Pi5 -> implies Pi5 Pi6 -> implies Pi6 Pi7 ->
	  implies Pi7 Pi8 -> implies Pi8 Pi9 -> implies Pi9 Pi10 ->
	  implies Pi10 Pi11 -> implies Pi11 Pi12 -> implies Pi1 Pi12
	= [I12] [I23] [I34] [I45] [I56] [I67] [I78] [I89] [I90] [I01] [I112]
	  (implies/trans (implies/trans5 I12 I23 I34 I45 I56) 
	     (implies/trans6 I67 I78 I89 I90 I01 I112)).


%% implication for Gamma:

bimplies/tt : bimplies true G t.

bimplies/tf : bimplies false t G.

bimplies/neg : 
	bimplies B G1 G2 -> 
	bool`ne B B' ->
    bimplies B' (neg G1) (neg G2).

bimplies/rem-negneg : bimplies B (neg (neg G)) G.

bimplies/add-negneg : bimplies B G (neg (neg G)).

%abbrev bimplies/ft : bimplies true f G = 
	bimplies/trans (bimplies/neg bimplies/tf bool`ne/FT)
                       bimplies/rem-negneg.

%abbrev bimplies/ff : bimplies false G f =
	bimplies/trans bimplies/add-negneg
		       (bimplies/neg bimplies/tt bool`ne/TF).
                       
bimplies/conj/XX : 
	bimplies B G1a G2a ->
	bimplies B G1b G2b ->
    bimplies B (conj G1a G1b) (conj G2a G2b).

%abbrev bimplies/disj/XX/true
  : {BI1:bimplies true G1a G2a}{BI2:bimplies true G1b G2b}
    bimplies true (disj G1a G1b) (disj G2a G2b)
    = [BI1][BI2]
      (bimplies/neg
        (bimplies/conj/XX
          (bimplies/neg
            (BI1)
            (bool`ne/TF))
          (bimplies/neg
            (BI2)
            (bool`ne/TF)))
        (bool`ne/FT)).

%abbrev bimplies/disj/XX/false
  : {BI1:bimplies false G1a G2a}{BI2:bimplies false G1b G2b}
    bimplies false (disj G1a G1b) (disj G2a G2b)
    = [BI1][BI2]
      (bimplies/neg
        (bimplies/conj/XX
          (bimplies/neg
            (BI1)
            (bool`ne/FT))
          (bimplies/neg
            (BI2)
            (bool`ne/FT)))
        (bool`ne/TF)).

bimplies/conj-true :
	bimplies B (conj G t) G.

bimplies/conj-false :
	bimplies B f (conj G f).

bimplies/conj-weaken/true :
	bimplies true (conj G1 G2) G1.

bimplies/conj-weaken/false :
	bimplies false G1 (conj G1 G2).

%abbrev bimplies/disj-weaken/true
  : bimplies true G1 (disj G1 G2)
    = (bimplies/trans
        (bimplies/add-negneg)
        (bimplies/neg
          (bimplies/conj-weaken/false)
          (bool`ne/FT))).

bimplies/conj-contract :
	bimplies B (conj G G) G.

bimplies/conj-duplicate :
	bimplies B G (conj G G).

%abbrev
bimplies/disj-contract/true :
	bimplies true (disj G G) G
      = bimplies/trans (bimplies/neg bimplies/conj-contract ne/FT)
                       bimplies/rem-negneg.

%abbrev
bimplies/disj-contract/false :
	bimplies false (disj G G) G
      = bimplies/trans (bimplies/neg bimplies/conj-contract ne/TF)
                       bimplies/rem-negneg.

%abbrev
bimplies/disj-duplicate/true :
	bimplies true G (disj G G)
      = bimplies/trans bimplies/add-negneg
                       (bimplies/neg bimplies/conj-duplicate ne/FT).

%abbrev
bimplies/disj-duplicate/false :
	bimplies false G (disj G G)
      = bimplies/trans bimplies/add-negneg
                       (bimplies/neg bimplies/conj-duplicate ne/TF).

%% See also theorems disj-contract and disj-duplicate below.

bimplies/conj-commutative : bimplies B (conj G1 G2) (conj G2 G1).

%abbrev bimplies/disj-commutative/true
  : bimplies true (disj G1 G2) (disj G2 G1)
    = bimplies/neg
      (bimplies/conj-commutative) bool`ne/FT.

%abbrev bimplies/disj-commutative/false
  : bimplies false (disj G1 G2) (disj G2 G1)
    = bimplies/neg
      (bimplies/conj-commutative) bool`ne/TF.

bimplies/conj-associative : bimplies B (conj (conj G1 G2) G3) 
                                   (conj G1 (conj G2 G3)).

bimplies/conj-associative-converse
	: bimplies B (conj G1 (conj G2 G3)) (conj (conj G1 G2) G3)
        = bimplies/trans5
	   bimplies/conj-commutative
	   (bimplies/conj/XX bimplies/conj-commutative bimplies/reflexive)
	   bimplies/conj-associative
	   (bimplies/conj/XX bimplies/reflexive bimplies/conj-commutative)
	   bimplies/conj-commutative.

%abbrev bimplies/disj-associative/true
  : bimplies true (disj (disj G1 G2) G3) (disj G1 (disj G2 G3))
  = (bimplies/neg
      (bimplies/trans
        (bimplies/conj/XX
          (bimplies/rem-negneg)
          (bimplies/reflexive))
        (bimplies/trans
          (bimplies/conj-associative)
          (bimplies/conj/XX
            (bimplies/reflexive)
            (bimplies/add-negneg))))
      (bool`ne/FT)).

%abbrev bimplies/disj-associative/false
  : bimplies false (disj (disj G1 G2) G3) (disj G1 (disj G2 G3))
  = (bimplies/neg
      (bimplies/trans
        (bimplies/conj/XX
          (bimplies/rem-negneg)
          (bimplies/reflexive))
        (bimplies/trans
          (bimplies/conj-associative)
          (bimplies/conj/XX
            (bimplies/reflexive)
            (bimplies/add-negneg))))
      (bool`ne/TF)).

%abbrev bimplies/disj-associative-converse/true
  : bimplies true (disj G1 (disj G2 G3)) (disj (disj G1 G2) G3)
    = (bimplies/trans
        (bimplies/disj-commutative/true)
        (bimplies/trans
          (bimplies/disj/XX/true
            (bimplies/disj-commutative/true)
            (bimplies/reflexive))
          (bimplies/trans
            (bimplies/disj-associative/true)
            (bimplies/trans
              (bimplies/disj-commutative/true)
              (bimplies/disj/XX/true
                (bimplies/disj-commutative/true)
                (bimplies/reflexive)))))).

%abbrev bimplies/disj-associative-converse/false
  : bimplies false (disj G1 (disj G2 G3)) (disj (disj G1 G2) G3)
    = (bimplies/trans
        (bimplies/disj-commutative/false)
        (bimplies/trans
          (bimplies/disj/XX/false
            (bimplies/disj-commutative/false)
            (bimplies/reflexive))
          (bimplies/trans
            (bimplies/disj-associative/false)
            (bimplies/trans
              (bimplies/disj-commutative/false)
              (bimplies/disj/XX/false
                (bimplies/disj-commutative/false)
                (bimplies/reflexive)))))).

bimplies/modus-ponens : bimplies true (conj G1 (impl G1 G2)) G2.

bimplies/contra : bimplies true (conj G (neg G)) f
                = bimplies/trans 
		   (bimplies/conj/XX bimplies/reflexive 
		      (bimplies/neg bimplies/conj-weaken/false ne/FT))
		   bimplies/modus-ponens.

bimplies/objequal-reflexive : bimplies B t (objequal O O).

bimplies/objequal-symmetric : bimplies B (objequal O O') (objequal O' O).

bimplies/objequal-transitive :
	bimplies true (conj (objequal O O') (objequal O' O'')) (objequal O O'').

bimplies/objequal-not : nat`ne N1 N2 ->
	bimplies B f (objequal (object/ N1) (object/ N2)).

bimplies/objequal-excluded-middle :
	bimplies B t (disj (objequal O O') (neg (objequal O O'))).

bimplies/nested/empty : bimplies true t (nested empty O F).

bimplies/nested/eq :
	equiv Pi Pi' ->
    bimplies true (nested Pi O F) (nested Pi' O F).

bimplies/nested/separate :
    bimplies true (nested (Pi1 , Pi2) O F) 
                  (conj (nested Pi1 O F) (nested Pi2 O F)).

bimplies/nested/combine :
	canon Pi1 C1 ->
	canon Pi2 C2 ->
        canonical`disjoint C1 C2 ->
    bimplies true (conj (nested Pi1 O F) (nested Pi2 O F))
                  (nested (Pi1 , Pi2) O F).

%% predicate calls:

bimplies/predcall/0/inline :
    bimplies B (predcall (predicate/0 G) predargs/0) G.

bimplies/predcall/0/extract :
    bimplies B G (predcall (predicate/0 G) predargs/0).

bimplies/predcall/+/inline : {X}
    bimplies B (predcall (predicate/+ ([x] FP x)) (predargs/+ X R))
	       (predcall (FP X) R).

bimplies/predcall/+/extract : {FP} {X}
    bimplies B (predcall (FP X) R)
 	       (predcall (predicate/+ ([x] FP x)) (predargs/+ X R)).

bimplies/predcall/Y/inline : 
    bimplies B (predcall (predicate/Y ([f] FP f)) R)
               (predcall (FP (predicate/Y ([f] (FP f)))) R).

bimplies/predcall/Y/extract :
    bimplies true (predcall (FP (predicate/Y ([f] (FP f)))) R)
                  (predcall (predicate/Y ([f] FP f)) R).

% NB: There is nothing here for existentials, but
% adding them would cause the consistency theorem to fail
% because abseval doesn't handle existentials.
% We could add existentials to BOTH as long as we maintain
% the completeness of bimplies w.r.t. abseval.


%% implication for permissions

implies/nonlinear :
	bimplies true G1 G2 ->
    implies (unitperm (nonlinear G1)) (unitperm (nonlinear G2)).

implies/objequal : {PF: object -> permission}
	implies (unitperm (nonlinear (objequal O1 O2)) , (PF O1)) 
                (PF O2).

implies/scale : implies Pi1 Pi2 -> implies (scale Q Pi1) (scale Q Pi2).

implies/combine : implies Pi1a Pi2a -> implies Pi1b Pi2b ->
    implies (combine Pi1a Pi1b) (combine Pi2a Pi2b).

implies/equiv : equiv Pi1 Pi2 -> implies Pi1 Pi2.

%abbrev implies/reflexive : implies Pi Pi = implies/equiv equiv/reflexive.


%% combine/scale/empty with gammas:

implies/combine2conj : 
	implies (unitperm (nonlinear G1) , unitperm (nonlinear G2))
                (unitperm (nonlinear (conj G1 G2))).

implies/conj2combine : 
	implies (unitperm (nonlinear (conj G1 G2)))
                (unitperm (nonlinear G1) , unitperm (nonlinear G2)).

%abbrev
implies/duplicate :
	implies (unitperm (nonlinear G))
		(unitperm (nonlinear G) , unitperm (nonlinear G)) =
	(implies/trans (implies/nonlinear bimplies/conj-duplicate)
	   implies/conj2combine).

implies/scale-into-formula :
	implies (unitperm (nonlinear G))
		(scale Q (unitperm (nonlinear G))).

implies/scale-from-formula :
	implies (scale Q (unitperm (nonlinear G)))
		(unitperm (nonlinear G)).

implies/empty2true : implies empty (unitperm  (nonlinear t)).

implies/true2empty : implies (unitperm (nonlinear t)) empty.

implies/gen-pack-encumber : {v} implies empty
				(unitperm
				   (encumbered (unitperm (basic O F v), (B v))
				      (unitperm (precise-exists O F B)))).

implies/push-exists : 
    implies (Pi1 , (unitperm (precise-exists O F B)))
	    (unitperm (precise-exists O F ([v] (Pi1 , B v)))).

implies/pull-exists :
    implies (unitperm (precise-exists O F ([v] (Pi1 , B v))))
            (Pi1 , (unitperm (precise-exists O F B))).

implies/cond-inner : 
	bimplies true G G' ->
	bimplies false G G' ->
	implies Pi1 Pi1' ->
	implies Pi2 Pi2' ->
    implies (unitperm (conditional G Pi1 Pi2))
	    (unitperm (conditional G' Pi1' Pi2')).

implies/cond-intro: implies (unitperm (nonlinear G), Pi1)
                            (unitperm (conditional G Pi1 Pi2)).

implies/cond-elim : implies (unitperm (nonlinear G),
			     unitperm (conditional G Pi1 Pi2))
		            Pi1.

implies/cond-neg : implies (unitperm (conditional G Pi1 Pi2))
                           (unitperm (conditional (neg G) Pi2 Pi1)).

%abbrev
implies/cond-unneg : implies (unitperm (conditional (neg G) Pi2 Pi1))
			     (unitperm (conditional G Pi1 Pi2)) =
	(implies/trans
	   implies/cond-neg
	   (implies/cond-inner bimplies/rem-negneg bimplies/rem-negneg
	      implies/reflexive implies/reflexive)).
                    
implies/cond-elim-conj : implies (unitperm (nonlinear (disj G1 (neg G1))) ,
                                  unitperm (conditional (conj G1 G2) Pi1 Pi2))
			  (unitperm (conditional G1
				       (unitperm (conditional G2 Pi1 Pi2))
				       Pi2)).

implies/cond-intr-conj : implies (unitperm 
				    (conditional G1
				       (unitperm (conditional G2 Pi1 Pi2))
				       Pi2))
			  (unitperm (conditional (conj G1 G2) Pi1 Pi2)).

%abbrev
implies/cond-elim-disj : implies (unitperm (nonlinear (disj G1 (neg G1))) ,
				  unitperm (conditional (disj G1 G2) Pi1 Pi2))
			  (unitperm (conditional G1 Pi1
				       (unitperm 
					  (conditional G2 Pi1 Pi2))))
			  = (implies/trans4
			       (implies/combine 
				  (implies/nonlinear
				     (bimplies/neg
					(bimplies/trans
					   bimplies/conj-commutative
					   (bimplies/conj/XX bimplies/reflexive
					      bimplies/add-negneg))
					ne/FT))
				  implies/cond-unneg)
			       implies/cond-elim-conj
			       implies/cond-unneg
			       (implies/cond-inner 
				  bimplies/reflexive bimplies/reflexive
				  implies/reflexive implies/cond-unneg)).

%abbrev
implies/cond-intr-disj : implies (unitperm 
				    (conditional G1 Pi1
				       (unitperm (conditional G2 Pi1 Pi2))))
			  (unitperm (conditional (disj G1 G2) Pi1 Pi2))
			  = (implies/trans4
			       (implies/cond-inner
				  bimplies/reflexive bimplies/reflexive
				  implies/reflexive implies/cond-neg)
			       implies/cond-neg
			       implies/cond-intr-conj
			       implies/cond-neg).
			     
implies/cond-equal : implies (unitperm (conditional G Pi Pi)) Pi.

implies/cond-equal-objequal
  : implies Pi (unitperm (conditional (objequal O O') Pi Pi)).

implies/cond-push : implies (Pi1 , (unitperm (conditional G Pi2 Pi3)))
                            (unitperm (conditional G (Pi1 , Pi2) (Pi1 , Pi3))).

implies/scale-distribute-cond : 
    implies (scale Q (unitperm (conditional G Pi1 Pi2)))
            (unitperm (conditional G (scale Q Pi1) (scale Q Pi2))).

implies/scale-factor-cond : 
    implies (unitperm (conditional G (scale Q Pi1) (scale Q Pi2)))
	    (scale Q (unitperm (conditional G Pi1 Pi2))).
            
%abbrev
implies/cond-intro-neg : implies (unitperm (nonlinear (neg G)), Pi2)       
				 (unitperm (conditional G Pi1 Pi2)) =
	(implies/trans implies/cond-intro implies/cond-unneg).

implies/cond-distribute:
    implies (unitperm (conditional G (Pi1 , Pi1') (Pi2 , Pi2')))
            (unitperm (conditional G Pi1 Pi2) , 
             unitperm (conditional G Pi1' Pi2')).

%abbrev implies/cond-pull:
    implies (unitperm (conditional G (Pi , Pi1') (Pi , Pi2')))
            (Pi , unitperm (conditional G Pi1' Pi2')) =
    (implies/trans implies/cond-distribute
       (implies/combine implies/cond-equal implies/reflexive)).

implies/cond-factor:
    implies (unitperm (conditional G Pi1 Pi2) , 
             unitperm (conditional G Pi1' Pi2'))
	    (unitperm (conditional G (Pi1 , Pi1') (Pi2 , Pi2'))).

implies/cond-gen-inner:
    implies (unitperm (conditional G Pi1 Pi2))
            (unitperm (conditional G (unitperm (nonlinear G) , Pi1)
                                     (unitperm (nonlinear (neg G)) , Pi2))).

%abbrev
implies/cond-add-outer:
    implies (unitperm (nonlinear G1) ,
             unitperm (conditional G2 Pi1 Pi2))
            (unitperm (conditional (conj G1 G2) Pi1 Pi2))
= implies/trans implies/cond-intro implies/cond-intr-conj.

%abbrev
implies/cond-rem-outer:
    implies (unitperm (nonlinear G1) ,
             unitperm (conditional (conj G1 G2) Pi1 Pi2))
            (unitperm (conditional G2 Pi1 Pi2))
= implies/trans4
   (implies/combine 
      (implies/trans implies/duplicate
	 (implies/combine implies/reflexive
	    (implies/nonlinear bimplies/disj-weaken/true)))
      implies/reflexive)
   (implies/equiv (equiv/symmetric equiv/associate))
   (implies/combine implies/reflexive implies/cond-elim-conj)
   implies/cond-elim.

implies/equiv-encumbered :
	equiv Pi1 Pi1' ->
	equiv Pi2 Pi2' ->
    implies (unitperm (encumbered Pi1 Pi2))
	    (unitperm (encumbered Pi1' Pi2')).

implies/gen-implication :
	implies Pi (unitperm (encumbered empty Pi)).

implies/self-implication :
	implies empty (unitperm (encumbered Pi Pi)).

% the converse of self-implication dos not always hold: imprecision

implies/remove-implication :
	implies (unitperm (encumbered empty Pi)) Pi.

implies/chain-implication :
	implies (unitperm (encumbered Pi1 Pi2) ,
                 unitperm (encumbered Pi2 Pi3))
                (unitperm (encumbered Pi1 Pi3)).

%abbrev implies/linear-modus-ponens :
	implies (Pi1 , (unitperm (encumbered Pi1 Pi2))) Pi2 =
        implies/trans 
          (implies/combine implies/gen-implication implies/reflexive)
          (implies/trans implies/chain-implication implies/remove-implication).

implies/carve :
	implies (unitperm (nonlinear (nested Pi O F)) , 
                          (unitperm (basic O F V)))
		(Pi , (unitperm (encumbered Pi (unitperm (basic O F V))))).

implies/combine-assoc-encumbered :
	implies (unitperm (encumbered (Pi1 , Pi2) Pi3))
                (unitperm (encumbered Pi1 (unitperm (encumbered Pi2 Pi3)))).

% no converse ?

implies/combine-merge-encumbered :
	implies (unitperm (encumbered Pi1 Pi2), unitperm (encumbered Pi3 Pi4))
                (unitperm (encumbered (Pi1 , Pi3) (Pi2 , Pi4))).

%abbrev
implies/push-encumbered
	: implies (Pi , unitperm (encumbered Pi1 Pi2))
                  (unitperm (encumbered Pi1 (Pi , Pi2)))
	= implies/trans3
	   (implies/combine implies/gen-implication implies/reflexive)
	   (implies/combine-merge-encumbered)
	   (implies/equiv-encumbered
	      (equiv/transitive equiv/commute equiv/identity)
	      equiv/reflexive).

implies/scale-distribute-encumbered :
	implies (scale Q (unitperm (encumbered Pi1 Pi2)))
		(unitperm (encumbered (scale Q Pi1) (scale Q Pi2))).

implies/scale-factor-encumbered :
	implies (unitperm (encumbered (scale Q Pi1) (scale Q Pi2)))
		(scale Q (unitperm (encumbered Pi1 Pi2))).

implies/gen-true-encumbered :
    implies (unitperm (nonlinear G))
	    (unitperm (encumbered Pi1 (unitperm (conditional G Pi1 Pi2)))).

implies/gen-false-encumbered :
    implies (unitperm (nonlinear (neg G)))
	    (unitperm (encumbered Pi2 (unitperm (conditional G Pi1 Pi2)))).

%abbrev
implies/cond-assoc-encumbered/true
	: implies (unitperm (nonlinear G) ,
		   unitperm (encumbered (unitperm (conditional G Pi1 Pi2)) Pi3))
		  (unitperm (encumbered Pi1 Pi3))
	= implies/trans
	    (implies/combine implies/gen-true-encumbered implies/reflexive)
	    implies/chain-implication. 

%abbrev
implies/cond-assoc-encumbered/false
	: implies (unitperm (nonlinear (neg G)) ,
		   unitperm (encumbered (unitperm (conditional G Pi1 Pi2)) Pi3))
		  (unitperm (encumbered Pi2 Pi3))
	= implies/trans
	    (implies/combine implies/gen-false-encumbered implies/reflexive)
	    implies/chain-implication.


implies/conditional/t 
	: implies (unitperm (conditional t Pi1 Pi2)) Pi1
	= implies/trans3
	   (implies/equiv
	      (equiv/transitive
		 (equiv/symmetric equiv/identity)
		 (equiv/commute)))
	   (implies/combine
	      implies/empty2true
	      implies/reflexive)
	   implies/cond-elim.

implies/conditional/f
	: implies (unitperm (conditional f Pi1 Pi2)) Pi2
	= implies/trans
	   implies/cond-unneg
	   implies/conditional/t.

%abbrev
implies/pack : {v} implies (unitperm (basic O F v), (B v))
                           (unitperm (precise-exists O F B))
             = [v] (implies/trans
		      (implies/equiv (equiv/symmetric equiv/identity))
		      (implies/trans
			 (implies/combine implies/reflexive 
			    (implies/gen-pack-encumber v))
			 implies/linear-modus-ponens)).

%abbrev implies/contradiction :
	implies (unitperm (nonlinear (neg t))) Pi =
    (implies/trans
       (implies/trans
	  (implies/equiv
	     (equiv/transitive
		(equiv/symmetric equiv/identity)
		(equiv/combine equiv/reflexive 
		   (equiv/symmetric equiv/identity))))
	  (implies/combine implies/reflexive
	     (implies/combine implies/empty2true implies/empty2true)))
       (implies/trans
	  (implies/combine implies/reflexive implies/cond-intro)
	  (implies/trans
	     (implies/combine implies/reflexive implies/cond-neg)
	     implies/cond-elim))).

implies/disj2cond :
	implies (unitperm (nonlinear (disj (objequal O1 O2) G2)))
                (unitperm (conditional (objequal O1 O2) (empty)
			     (unitperm (nonlinear (G2)))))
      = implies/trans5
	 (implies/equiv (equiv/symmetric equiv/identity))
	 (implies/cond-intro-neg
	    : implies _ (unitperm (conditional _ (unitperm (nonlinear G2)) _)))
	 (implies/cond-equal-objequal
	    : implies _ (unitperm (conditional (objequal O1 O2) _ _)))
	 (implies/cond-gen-inner)
	 (implies/cond-inner bimplies/reflexive bimplies/reflexive
	    (implies/trans3
	       implies/cond-add-outer
	       (implies/cond-inner
		  (bimplies/trans3
		     bimplies/conj-associative-converse
		     (bimplies/conj/XX
			bimplies/contra
			bimplies/reflexive)
		     bimplies/conj-weaken/true)
		  bimplies/ff implies/reflexive implies/reflexive)
	       implies/conditional/f)
	    (implies/trans5
	       implies/cond-rem-outer
	       implies/cond-unneg
	       implies/cond-gen-inner
	       (implies/cond-inner bimplies/reflexive bimplies/reflexive
		  (implies/equiv equiv/identity)
		  (implies/trans2
		     implies/combine2conj
		     (implies/nonlinear
			(bimplies/trans2
			   bimplies/conj-commutative
			   bimplies/conj-weaken/true))))
	       implies/cond-equal)).



%%%% Theorems


%%% Theorems about bimplies


%theorem false-implies-bimplies :
	forall* {B} {G1} {G2}
	forall	{F:void}
	exists	{BI:bimplies B G1 G2}
	true.

%worlds () (false-implies-bimplies _ _).
%total { } (false-implies-bimplies _ _).


%theorem bimplies-respects-eq :
	forall* {B1} {G1} {H1}
		{B2} {G2} {H2}
	forall	{BI1:bimplies B1 G1 H1}
		{BE: bool`eq B1 B2}
		{GE: permission`eq G1 G2}
		{HE: permission`eq H1 H2}
	exists	{BI2:bimplies B2 G2 H2}
	true.

- : bimplies-respects-eq BI bool`eq/ permission`eq/ permission`eq/ BI.

%worlds () (bimplies-respects-eq _ _ _ _ _).
%total { } (bimplies-respects-eq _ _ _ _ _).


%theorem disj-contract:
	forall*	{B} {G}
	exists	{X: bimplies B (disj G G) G}
	true.

- : disj-contract (bimplies/trans (bimplies/neg bimplies/conj-contract ne/TF)
		                    bimplies/rem-negneg).

- : disj-contract (bimplies/trans (bimplies/neg bimplies/conj-contract ne/FT)
		                    bimplies/rem-negneg).

%worlds () (disj-contract _).
%total { } (disj-contract _).


%theorem disj-duplicate:
	forall*	{B} {G}
	exists	{X: bimplies B G (disj G G)}
	true.

- : disj-duplicate (bimplies/trans 
		      bimplies/add-negneg
		      (bimplies/neg bimplies/conj-duplicate ne/TF)).

- : disj-duplicate (bimplies/trans 
		      bimplies/add-negneg
		      (bimplies/neg bimplies/conj-duplicate ne/FT)).

%worlds () (disj-duplicate _).
%total { } (disj-duplicate _).


%{%
The following theorem says that boolean implication only yields
formulae that evaluate the same way.  We can only handle empty
assumptions because bimplies/predcall/Y/extract can create
a "new" function that might happen to be in the assumptions,
even though it is unsupported.  We have two names for the theorem,
with different orders of arguments.
%}%

%theorem bimplies-preserves-booleval :
	forall* {B} {G1} {G2} {N}
	forall	{BE:booleval assumptions/0 N G1 B}
		{BI:bimplies B G1 G2}
	exists	{BE:booleval assumptions/0 N G2 B}
	true.

%abbrev bimplies-sound : 
	(bimplies B G1 G2) -> 
	(booleval assumptions/0 N G1 B) -> 
	(booleval assumptions/0 N G2 B) ->
    type = [BI] [BE1] [BE2] bimplies-preserves-booleval BE1 BI BE2.

- : bimplies-sound (bimplies/reflexive) BE BE.

- : bimplies-sound (bimplies/trans BI1->2 BI2->3) BE1 BE3
    <- bimplies-sound BI1->2 BE1 BE2
    <- bimplies-sound BI2->3 BE2 BE3.

- : bimplies-sound (bimplies/tt) _ booleval/true.

% - : bimplies-sound (bimplies/tf) IMPOSSIBLE _.

- : bimplies-sound (bimplies/neg BI bool`ne/TF) (booleval/neg/T BE)
                   (booleval/neg/T BE')
    <- bimplies-sound BI BE BE'.

- : bimplies-sound (bimplies/neg BI bool`ne/FT) (booleval/neg/F BE)
                   (booleval/neg/F BE')
    <- bimplies-sound BI BE BE'.

- : bimplies-sound bimplies/rem-negneg (booleval/neg/T (booleval/neg/F BE)) BE.

- : bimplies-sound bimplies/rem-negneg (booleval/neg/F (booleval/neg/T BE)) BE.

- : bimplies-sound bimplies/add-negneg BE (booleval/neg/T (booleval/neg/F BE)).

- : bimplies-sound bimplies/add-negneg BE (booleval/neg/F (booleval/neg/T BE)).

- : bimplies-sound (bimplies/conj/XX BI1 BI2) (booleval/conj/T BE1 BE2)
		   (booleval/conj/T BE1' BE2')
    <- bimplies-sound BI1 BE1 BE1'
    <- bimplies-sound BI2 BE2 BE2'.

- : bimplies-sound (bimplies/conj/XX BI1 BI2) (booleval/conj/F1 BE1)
		   (booleval/conj/F1 BE1')
    <- bimplies-sound BI1 BE1 BE1'.

- : bimplies-sound (bimplies/conj/XX BI1 BI2) (booleval/conj/F2 BE2)
		   (booleval/conj/F2 BE2')
    <- bimplies-sound BI2 BE2 BE2'.

- : bimplies-sound (bimplies/conj-true) (booleval/conj/T BE1 BE2) BE1.

- : bimplies-sound (bimplies/conj-true) (booleval/conj/F1 BE1) BE1.

- : bimplies-sound (bimplies/conj-false) _ 
	(booleval/conj/F2 (booleval/neg/T booleval/true)).

- : bimplies-sound (bimplies/conj-false) (booleval/neg/F T->false) BE
    <- booleval-deterministic 
	T->false 
	(booleval/true: booleval assumptions/0 _ _ _)
        nesting`eq/ permission`eq/ F=T
    <- bool`eq-ne-implies-false F=T bool`ne/FT F
    <- false-implies-booleval F BE.

- : bimplies-sound (bimplies/conj-weaken/true) (booleval/conj/T BE1 BE2) BE1.

- : bimplies-sound (bimplies/conj-weaken/false) BE1 (booleval/conj/F1 BE1).

- : bimplies-sound (bimplies/conj-contract)
		   (booleval/conj/T BE _) BE.

- : bimplies-sound (bimplies/conj-contract)
		   (booleval/conj/F1 BE) BE.

- : bimplies-sound (bimplies/conj-contract)
		   (booleval/conj/F2 BE) BE.

- : bimplies-sound (bimplies/conj-contract)
		   (booleval/conj/T BE _) BE.

- : bimplies-sound (bimplies/conj-duplicate) BE
		   (booleval/conj/T BE BE).

- : bimplies-sound (bimplies/conj-duplicate) BE
		   (booleval/conj/F1 BE).

- : bimplies-sound (bimplies/conj-commutative)
		   (booleval/conj/T BE1 BE2)
		   (booleval/conj/T BE2 BE1).

- : bimplies-sound (bimplies/conj-commutative)
		   (booleval/conj/F1 BE)
		   (booleval/conj/F2 BE).

- : bimplies-sound (bimplies/conj-commutative)
		   (booleval/conj/F2 BE)
		   (booleval/conj/F1 BE).

- : bimplies-sound (bimplies/conj-associative)
		   (booleval/conj/T (booleval/conj/T BE1 BE2) BE3)
		   (booleval/conj/T BE1 (booleval/conj/T BE2 BE3)).

- : bimplies-sound (bimplies/conj-associative)
		   (booleval/conj/F1 (booleval/conj/F1 BE1))
		   (booleval/conj/F1 BE1).

- : bimplies-sound (bimplies/conj-associative)
		   (booleval/conj/F1 (booleval/conj/F2 BE2))
		   (booleval/conj/F2 (booleval/conj/F1 BE2)).

- : bimplies-sound (bimplies/conj-associative)
		   (booleval/conj/F2 BE3)
		   (booleval/conj/F2 (booleval/conj/F2 BE3)).

- : bimplies-sound (bimplies/modus-ponens)
		   (booleval/conj/T BE1
                      (booleval/neg/F (booleval/conj/F1 BE1'))) BE
    <- booleval-deterministic BE1 BE1' nesting`eq/ permission`eq/ T=F
    <- bool`eq-ne-implies-false T=F bool`ne/TF F
    <- false-implies-booleval F BE.

- : bimplies-sound (bimplies/modus-ponens)
		   (booleval/conj/T BE1
                      (booleval/neg/F (booleval/conj/F2 (booleval/neg/T BE2))))
                   BE2.

- : bimplies-sound (bimplies/objequal-reflexive)
		   (booleval/true) (booleval/objequal (nat`eq?/yes)).

- : bimplies-sound (bimplies/objequal-symmetric)
		   (booleval/objequal (nat`eq?/yes))
		   (booleval/objequal (nat`eq?/yes)).

- : bimplies-sound (bimplies/objequal-symmetric)
		   (booleval/objequal (nat`eq?/no N1<>N2))
		   (booleval/objequal (nat`eq?/no N2<>N1))
    <- nat`ne-symmetric N1<>N2 N2<>N1.

- : bimplies-sound (bimplies/objequal-transitive)
		   (booleval/conj/T (booleval/objequal nat`eq?/yes)
                                    (booleval/objequal nat`eq?/yes))
		   (booleval/objequal nat`eq?/yes).

- : bimplies-sound (bimplies/objequal-not NE)
		   (booleval/neg/T booleval/true)
		   (booleval/objequal (nat`eq?/no NE)).

%theorem bimplies-sound/objequal-excluded-middle :
	forall*	{N1} {N2} {B} {N}
	forall	{EQ?: nat`eq? N1 N2 B}
	exists	{BE: booleval assumptions/0 N 
		      (disj (objequal (object/ N1) (object/ N2))
			 (neg (objequal (object/ N1) (object/ N2)))) true}
	true.

- : bimplies-sound/objequal-excluded-middle EQT
	(booleval/disj/T1 (booleval/objequal EQT)).

- : bimplies-sound/objequal-excluded-middle EQF
	(booleval/disj/T2 (booleval/neg/F (booleval/objequal EQF))).

%worlds () (bimplies-sound/objequal-excluded-middle _ _).
%total { } (bimplies-sound/objequal-excluded-middle _ _).

- : bimplies-sound (bimplies/objequal-excluded-middle) _ BE
    <- nat`eq?-total EQ?
    <- bimplies-sound/objequal-excluded-middle EQ? BE.

- : bimplies-sound (bimplies/nested/empty) _
		   (booleval/nested/0 equiv/reflexive).

- : bimplies-sound (bimplies/nested/eq Pi=Pi')
		   (booleval/nested/0 Pi=0)
		   (booleval/nested/0 
		     (equiv/transitive (equiv/symmetric Pi=Pi') Pi=0)).

- : bimplies-sound (bimplies/nested/eq Pi=Pi')
		   (booleval/nested P2N NL K CL)
		   (booleval/nested P2N NL K' CL)
    <- equiv-preserves-canon K Pi=Pi' K'.

- : bimplies-sound (bimplies/nested/separate)
		   (booleval/nested/0 Pi1,Pi2=0)
		   (booleval/conj/T (booleval/nested/0 Pi1=0)
                                    (booleval/nested/0 Pi2=0))
    <- equiv-preserves-canon-converse canon/0 Pi1,Pi2=0 
				      (canon/+ Pi1->C1 Pi2->C2 C1+C2=0)
    <- canonical`add-empty-implies-empty C1+C2=0 C1=0 C2=0
    <- canon-eq-implies-equiv Pi1->C1 canon/0 C1=0 Pi1=0
    <- canon-eq-implies-equiv Pi2->C2 canon/0 C2=0 Pi2=0.

- : bimplies-sound (bimplies/nested/separate)
		   (booleval/nested P2N NL (canon/+ K1 K2 C1+C2=C12) C12<=C)
                   (booleval/conj/T (booleval/nested P2N NL K1 C1<=C)
                                    (booleval/nested P2N NL K2 C2<=C))
    <- canonical`add-implies-leq C1+C2=C12 C1<=C12 C2<=C12
    <- canonical`leq-transitive C1<=C12 C12<=C C1<=C
    <- canonical`leq-transitive C2<=C12 C12<=C C2<=C.

- : bimplies-sound (bimplies/nested/combine U1->N1 U2->N2 N1<>N2)
                   (booleval/conj/T (booleval/nested/0 U1=0) 
                                    (booleval/nested/0 U2=0))
		   (booleval/nested/0 
		     (equiv/transitive 
                       (equiv/combine U1=0 U2=0)
                       (equiv/identity))).

- : bimplies-sound (bimplies/nested/combine U1->N1 U2->N2 N1<>N2)
                   (booleval/conj/T (booleval/nested/0 U1=0) 
                                    (booleval/nested P2N NL K CL))
                   (booleval/nested P2N NL (canon/+ U1->0 K canonical`add/L) CL)
    <- equiv-preserves-canon-converse canon/0 U1=0 U1->0.

- : bimplies-sound (bimplies/nested/combine U1->N1 U2->N2 N1<>N2)
                   (booleval/conj/T (booleval/nested P2N NL K CL)
                                    (booleval/nested/0 U2=0))
                   (booleval/nested P2N NL (canon/+ K U2->0 canonical`add/R) CL)
    <- equiv-preserves-canon-converse canon/0 U2=0 U2->0.

- : bimplies-sound (bimplies/nested/combine K1 K2 C1^C2)
                   (booleval/conj/T 
		     (booleval/nested P2N NL K1' C1'<=C)
                     (booleval/nested P2N' NL' K2' C2'<=C'))
                   (booleval/nested P2N NL 
                     (canon/+ K1 K2 C1+C2=C12)
                     C12<=C)
    <- pair2nat-deterministic P2N' P2N natpair`eq/ N'=N
    <- nesting`lookup-deterministic NL' NL nesting`eq/ N'=N C'=C
    <- canon-deterministic K1' K1 permission`eq/ C1'=C1
    <- canon-deterministic K2' K2 permission`eq/ C2'=C2
    <- canonical`leq-respects-eq C2'<=C' C2'=C2 C'=C C2<=C
    <- canonical`leq-respects-eq C1'<=C C1'=C1 canonical`eq/ C1<=C
    <- canonical`add-total C1+C2=C12
    <- canonical`disjoint-leq-implies-add-leq* 
	C1^C2 C1<=C C2<=C C1+C2=C12 C12<=C.

- : bimplies-sound (bimplies/predcall/0/inline)
                   (booleval/predcall/0 BE) BE.

- : bimplies-sound (bimplies/predcall/0/extract)
		   BE (booleval/predcall/0 BE).

- : bimplies-sound (bimplies/predcall/+/inline X)
		   (booleval/predcall/+ BE) BE.

- : bimplies-sound (bimplies/predcall/+/extract _ _)
		   BE (booleval/predcall/+ BE).

- : bimplies-sound (bimplies/predcall/Y/inline)
		   (booleval/predcall/Y BE) BE'
    <- booleval-unwind-assumption BE BE BE'.

- : bimplies-sound (bimplies/predcall/Y/extract)
		   BE (booleval/predcall/Y BE')
    <- booleval/weaken-admissible BE BE'.

%theorem bimplies-sound/predcall/Y:
	forall*	{A} {N} {PT} {P:predicate PT -> predicate PT} {AS} {B}
	forall	{BE:booleval A N (predcall (predicate/Y P) AS) B}
	exists	{BE:bool`eq true B}
	true.

- : bimplies-sound/predcall/Y booleval/predcall/A bool`eq/.

- : bimplies-sound/predcall/Y (booleval/predcall/AW _) bool`eq/.

- : bimplies-sound/predcall/Y (booleval/predcall/Y _) bool`eq/.

%worlds () (bimplies-sound/predcall/Y _ _).
%total { } (bimplies-sound/predcall/Y _ _).

- : bimplies-sound _ BE BE'
    <- bimplies-sound/predcall/Y BE T=F
    <- bool`eq-ne-implies-false T=F bool`ne/TF F
    <- false-implies-booleval F BE'.

%worlds () (bimplies-preserves-booleval _ _ _).
%total (B) (bimplies-preserves-booleval _ B _).


%{%
The following theorem is the proof for the theorem about 
semantic implication in the article.  It is actually a more 
general theorem that proves that an extensional version of 
semantic implication (implies) satisfies the requirements of the 
intensional version (|=). 
%}%

%theorem implies-preserves-models :
	forall* {H} {N} {Pi1} {Pi2}
	forall	{M: models H empty N cycle/0 Pi1}
		{I: implies Pi1 Pi2}
	exists	{M':models H empty N cycle/0 Pi2}
	true.

% mutually inductive theorem:

%theorem implies-preserves-models/unit :
	forall* {H} {N} {Pi1} {Pi2}
	forall	{M: models H empty N cycle/0 Pi1}
		{I: implies (unitperm Pi1) Pi2}
	exists	{M':models H empty N cycle/0 Pi2}
	true.

- : implies-preserves-models M I M'
    <- models-unit-inversion M MU
    <- implies-preserves-models/unit MU I M'.

- : implies-preserves-models M1 (implies/trans I12 I23) M3
    <- implies-preserves-models M1 I12 M2
    <- implies-preserves-models M2 I23 M3.

- : implies-preserves-models/unit M (implies/trans I1 I2) M''
    <- implies-preserves-models/unit M I1 M'
    <- implies-preserves-models M' I2 M''.

- : implies-preserves-models 
	M1 (implies/scale I)
	(models/equiv equiv/zero equiv/reflexive (models/scale M2' Q*H=QH))
    <- models/scale-inversion M1 H Q*H=QH M1'
    <- implies-preserves-models M1' I M2'.

- : implies-preserves-models M1 (implies/combine Ia Ib) 
                             (models/equiv equiv/identity equiv/reflexive
                               (models/combined M2a M2b H1+H2=H))
    <- models/combined-inversion M1 H1 H2 H1+H2=H M1a M1b
    <- implies-preserves-models M1a Ia M2a
    <- implies-preserves-models M1b Ib M2b.

- : implies-preserves-models M1 (implies/equiv E) 
			     (models/equiv equiv/reflexive E M1).

- : implies-preserves-models/unit M1 (implies/equiv E) 
			     (models/equiv equiv/reflexive E 
				(models/unit M1)).

- : implies-preserves-models M (implies/gen-pack-encumber O') M'
    <- models-empty-is-empty M null/0 _ Z=H
    <- models-respects-eq
       (models/unit
	  (models/encumbered
	     (models/equiv 
		(equiv/transitive (equiv/symmetric equiv/identity) 
		   equiv/commute)
		equiv/reflexive
		(models/unit
		   (models/exists* _ O'
		      (models/obligation))))))
       Z=H permission`eq/ nesting`eq/ cycle`eq/ permission`eq/ M'.

- : implies-preserves-models M (implies/push-exists) 
     (models/unit 
	(models/exists O 
	   (models/equiv 
	      (equiv/transitive 
		 (equiv/combine equiv/reflexive equiv/identity)
		 equiv/identity)
	      equiv/reflexive
	      (models/combined M2a
		 (models/combined M1 M2b HA1) HA'))))
    <- models/combined-inversion M H1 H2 HA M1 M2
    <- models/unit-inversion M2 (models/exists O M2')
    <- models/combined-inversion M2' H2a H2b HA2 M2a M2b
    <- heap`add-commutative HA HAc
    <- heap`add-associative HA2 HAc HA1b HA1c HA'
    <- heap`add-commutative HA1c HA1.

- : implies-preserves-models/unit 
     (models/exists O M) (implies/pull-exists)
     (models/combined* M2
	(models/unit (models/exists O (models/combined* M1 M4 H1+H4=H5))) 
	H2+H5=H7)
    <- models/combined-inversion M H1 H6 H1+H6=H7 M1 M6
    <- models/combined-inversion M6 H2 H4 H2+H4=H6 M2 M4
    <- pheap`add-associative-converse H2+H4=H6 H1+H6=H7 H3 H1+H2=H3 H3+H4=H7
    <- pheap`add-assoc-commutative H1+H2=H3 H3+H4=H7 H5 H1+H4=H5 H5+H2=H7
    <- pheap`add-commutative H5+H2=H7 H2+H5=H7.

- : implies-preserves-models M (implies/cond-intro)
     (models/unit (models/conditional/T BE M2'))
    <- models/combined-inversion M HG H2 HG+H2=H MUG M2
    <- models/unit-inversion MUG MG
    <- models/nonlinear-inversion MG Z=HG BE
    <- heap`add-deterministic pheap`add/L HG+H2=H Z=HG heap`eq/ H2=H
    <- models-respects-eq M2 H2=H permission`eq/ nesting`eq/ 
       cycle`eq/ permission`eq/ M2'.

%theorem implies-preserves-models/cond-elim:
	forall* {HG} {N} {G} {HC} {Pi1} {Pi2} {H}
	forall	{MG: models HG empty N cycle/0 (nonlinear G)}
		{MC: models HC empty N cycle/0 (conditional G Pi1 Pi2)}
		{HA: heap`add HG HC H}
	exists	{M: models H empty N cycle/0 Pi1}
	true.

- : implies-preserves-models/cond-elim 
	(models/nonlinear _)
	(models/conditional/T _ M1) ZERO+HC=H M1'
    <- heap`add-deterministic pheap`add/L ZERO+HC=H heap`eq/ heap`eq/ HC=H
    <- models-respects-eq M1 HC=H permission`eq/ nesting`eq/ 
       cycle`eq/ permission`eq/ M1'.

- : implies-preserves-models/cond-elim
	(models/nonlinear BET)
	(models/conditional/F BEF _) _ M1'
    <- booleval-deterministic BET BEF nesting`eq/ permission`eq/ T=F
    <- bool`eq-ne-implies-false T=F bool`ne/TF F
    <- false-implies-models F M1'.

%worlds () (implies-preserves-models/cond-elim _ _ _ _).
%total { } (implies-preserves-models/cond-elim _ _ _ _).

- : implies-preserves-models M (implies/cond-elim) M1'
    <- models/combined-inversion M HG H2 HG+HC=H MUG MUC
    <- models/unit-inversion MUG MG
    <- models/unit-inversion MUC MC
    <- implies-preserves-models/cond-elim MG MC HG+HC=H M1'.

- : implies-preserves-models/unit
     (models/conditional/T BET M) implies/cond-neg
     (models/unit (models/conditional/F (booleval/neg/T BET) M)).

- : implies-preserves-models/unit
     (models/conditional/F BEF M) implies/cond-neg
     (models/unit (models/conditional/T (booleval/neg/F BEF) M)).

- : implies-preserves-models/unit
     (models/conditional/T _ M) implies/cond-equal M.

- : implies-preserves-models/unit
     (models/conditional/F _ M) implies/cond-equal M.

%theorem implies-preserves-models/cond-equal-objequal
  : forall* {O1} {O2} {H} {N} {Pi}
    forall {B} {E?: nat`eq? O1 O2 B} {M: models H empty N cycle/0 Pi}
    exists {M: models H empty N cycle/0
               (conditional (objequal (object/ O1) (object/ O2)) Pi Pi)}
    true.

- : implies-preserves-models/cond-equal-objequal true EQ M
    (models/conditional/T (booleval/objequal EQ) M).

- : implies-preserves-models/cond-equal-objequal false NE M
    (models/conditional/F (booleval/objequal NE) M).

%worlds () (implies-preserves-models/cond-equal-objequal _ _ _ _).
%total { } (implies-preserves-models/cond-equal-objequal _ _ _ _).

- : implies-preserves-models M implies/cond-equal-objequal (models/unit M')
    <- nat`eq?-total E?
    <- implies-preserves-models/cond-equal-objequal _ E? M M'.

- : implies-preserves-models/unit MU implies/cond-equal-objequal 
	(models/unit M')
    <- nat`eq?-total E?
    <- implies-preserves-models/cond-equal-objequal _ E? (models/unit MU) M'.

%theorem implies-preserves-models/cond-push:
	forall* {H1} {NG} {Pi1} {H2} {G} {Pi2} {Pi3} {H}
	forall	{M1: models H1 empty NG cycle/0 Pi1}
		{MC: models H2 empty NG cycle/0 (conditional G Pi2 Pi3)}
		{HA: heap`add H1 H2 H}
	exists	{M: models H empty NG cycle/0 
		     (conditional G (Pi1 , Pi2) (Pi1 , Pi3)) }
	true.

- : implies-preserves-models/cond-push M1 
     (models/conditional/T BET M2) HA
     (models/conditional/T BET 
	(models/equiv equiv/identity equiv/reflexive
	   (models/combined M1 M2 HA))).

- : implies-preserves-models/cond-push M1 
     (models/conditional/F BEF M2) HA
     (models/conditional/F BEF 
	(models/equiv equiv/identity equiv/reflexive
	   (models/combined M1 M2 HA))).

%worlds () (implies-preserves-models/cond-push _ _ _ _).
%total { } (implies-preserves-models/cond-push _ _ _ _).

- : implies-preserves-models M implies/cond-push (models/unit M')
    <- models/combined-inversion M H1 H2 HA M1 M2U
    <- models/unit-inversion M2U M2
    <- implies-preserves-models/cond-push M1 M2 HA M'.
     
- : implies-preserves-models/unit
     (models/conditional/T BET M) (implies/cond-inner BI _ I _)
     (models/unit (models/conditional/T BET' M'))
    <- implies-preserves-models M I M'
    <- bimplies-sound BI BET BET'.

- : implies-preserves-models/unit
     (models/conditional/F BEF M) (implies/cond-inner _ BI _ I)
     (models/unit (models/conditional/F BEF' M'))
    <- implies-preserves-models M I M'
    <- bimplies-sound BI BEF BEF'.

%theorem implies-preserves-models/scale-distribute-cond :
	forall* {H} {HP} {NG} {G} {Q} {Pi1} {Pi2}
	forall	{M1: models H empty NG cycle/0 (conditional G Pi1 Pi2)}
    		{HS: heap`scale Q H HP}
	exists  {M: models HP empty NG cycle/0
		     (conditional G 
			(scale (fraction/ Q) Pi1) 
			(scale (fraction/ Q) Pi2))}
	true.

- : implies-preserves-models/scale-distribute-cond
    (models/conditional/T BET M1) HS
    (models/conditional/T BET
      (models/equiv (equiv/zero) (equiv/reflexive) (models/scale M1 HS))).

- : implies-preserves-models/scale-distribute-cond
    (models/conditional/F BET M1) HS
    (models/conditional/F BET
      (models/equiv (equiv/zero) (equiv/reflexive) (models/scale M1 HS))).

%worlds () (implies-preserves-models/scale-distribute-cond _ _ _).
%total { } (implies-preserves-models/scale-distribute-cond _ _ _).

- : implies-preserves-models M implies/scale-distribute-cond (models/unit MP)
    <- models/scale-inversion M H HS M1
    <- models/unit-inversion M1 M2
    <- implies-preserves-models/scale-distribute-cond M2 HS MP.

- : implies-preserves-models/unit 
	(models/conditional/T BET M) implies/scale-factor-cond
	(models/equiv equiv/zero equiv/reflexive 
	   (models/scale
	      (models/unit (models/conditional/T BET M1))
	      HS))
    <- models/scale-inversion M H HS M1.

- : implies-preserves-models/unit 
	(models/conditional/F BEF M) implies/scale-factor-cond
	(models/equiv equiv/zero equiv/reflexive 
	   (models/scale
	      (models/unit (models/conditional/F BEF M1))
	      HS))
    <- models/scale-inversion M H HS M1.

- : implies-preserves-models/unit
     (models/conditional/T BET M) (implies/cond-distribute)
     (models/equiv equiv/identity equiv/reflexive
	(models/combined
	   (models/unit (models/conditional/T BET M1))
	   (models/unit (models/conditional/T BET M2)) H1+H2=H'))
     <- models/combined-inversion M H1 H2 H1+H2=H' M1 M2.

- : implies-preserves-models/unit
     (models/conditional/F BEF M) (implies/cond-distribute)
     (models/equiv equiv/identity equiv/reflexive
	(models/combined
	   (models/unit (models/conditional/F BEF M1))
	   (models/unit (models/conditional/F BEF M2)) H1+H2=H'))
     <- models/combined-inversion M H1 H2 H1+H2=H' M1 M2.

%theorem implies-preserves-models/cond-factor :
	forall* {H1} {NG} {G} {Pi1} {Pi1'} {H2} {Pi2} {Pi2'} {H}
	forall	{M1: models H1 empty NG cycle/0 (conditional G Pi1 Pi1')}
		{M2: models H2 empty NG cycle/0 (conditional G Pi2 Pi2')}
		{HA: heap`add H1 H2 H}
	exists	{M: models H empty NG cycle/0
		     (conditional G (Pi1 , Pi2) (Pi1' , Pi2'))}
	true.

- : implies-preserves-models/cond-factor
     (models/conditional/T BET M1) (models/conditional/T _ M2) HA
     (models/conditional/T BET
	(models/equiv equiv/identity equiv/reflexive
	   (models/combined M1 M2 HA))).

- : implies-preserves-models/cond-factor
     (models/conditional/F BEF M1) (models/conditional/F _ M2) HA
     (models/conditional/F BEF
	(models/equiv equiv/identity equiv/reflexive
	   (models/combined M1 M2 HA))).

- : implies-preserves-models/cond-factor
     (models/conditional/T BET M1) (models/conditional/F BEF M2) _ M
    <- booleval-deterministic BET BEF nesting`eq/ permission`eq/ T=F
    <- bool`eq-ne-implies-false T=F ne/TF F
    <- false-implies-models F M.

- : implies-preserves-models/cond-factor
     (models/conditional/F BEF M1) (models/conditional/T BET M2) _ M
    <- booleval-deterministic BET BEF nesting`eq/ permission`eq/ T=F
    <- bool`eq-ne-implies-false T=F ne/TF F
    <- false-implies-models F M.

%worlds () (implies-preserves-models/cond-factor _ _ _ _).
%total { } (implies-preserves-models/cond-factor _ _ _ _).

- : implies-preserves-models M (implies/cond-factor) (models/unit M')
    <- models/combined-inversion M H1 H2 HA M1U M2U
    <- models/unit-inversion M1U M1
    <- models/unit-inversion M2U M2
    <- implies-preserves-models/cond-factor M1 M2 HA M'.

- : implies-preserves-models/unit
     (models/conditional/T BET M)
     (implies/cond-gen-inner)
     (models/unit
	(models/conditional/T BET
	   (models/equiv equiv/identity equiv/reflexive
	      (models/combined
		 (models/unit (models/nonlinear BET)) M pheap`add/L)))).

- : implies-preserves-models/unit
     (models/conditional/F BEF M)
     (implies/cond-gen-inner)
     (models/unit
	(models/conditional/F BEF
	   (models/equiv equiv/identity equiv/reflexive
	      (models/combined
		 (models/unit (models/nonlinear (booleval/neg/F BEF)))
		 M pheap`add/L)))).

%theorem implies-preserves-models/cond-elim-conj:
	forall*	{N} {G1} {G2} {Pi1} {Pi2} {H} {HP}
	forall	{BEF: booleval assumptions/0 N 
		       (conj (neg G1) (neg (neg G1))) false}
	   	{ZEH: heap`eq H HP}
		{MC:  models H permission`empty N cycle/0
		      (conditional (conj G1 G2) Pi1 Pi2)}
	exists	{MCP: models HP permission`empty N cycle/0
		       (conditional G1 (unitperm (conditional G2 Pi1 Pi2)) Pi2)}
	true.

- : implies-preserves-models/cond-elim-conj
	(booleval/conj/F1 (booleval/neg/T BET)) heap`eq/
	(models/conditional/F BETF MC)
        (models/conditional/T BET (models/unit (models/conditional/F BEF MC)))
    <- booleval/conj/F2-inversion BETF BET BEF.

- : implies-preserves-models/cond-elim-conj
	(booleval/conj/F2 (booleval/neg/T (booleval/neg/F BEF))) heap`eq/
	(models/conditional/F BETF MC)
	(models/conditional/F BEF MC).

- : implies-preserves-models/cond-elim-conj _ heap`eq/
	(models/conditional/T (booleval/conj/T BET1 BET2) MC)
        (models/conditional/T BET1 
	   (models/unit (models/conditional/T BET2 MC))).

%worlds () (implies-preserves-models/cond-elim-conj _ _ _ _).
%total { } (implies-preserves-models/cond-elim-conj _ _ _ _).

- : implies-preserves-models MOC
     (implies/cond-elim-conj) (models/unit MCP)
    <- models/combined-inversion MOC _ _ H1+H2=H MO MC
    <- models/unit-inversion MO MOU
    <- models/unit-inversion MC MCU
    <- models/nonlinear-inversion MOU Z=H1 (booleval/neg/F BEF)
    <- heap`add-unique pheap`add/L H1+H2=H Z=H1 heap`eq/ H2=H
    <- implies-preserves-models/cond-elim-conj BEF H2=H MCU MCP.

%theorem implies-preserves-models/cond-intr-conj:
	forall*	{N} {G1} {G2} {Pi1} {Pi2} {H}
	forall	{BET1: booleval assumptions/0 N G1 true}
		{MC2: models H permission`empty N cycle/0
		       (conditional G2 Pi1 Pi2)}
	exists	{MC:  models H permission`empty N cycle/0
		      (conditional (conj G1 G2) Pi1 Pi2)}
	true.

- : implies-preserves-models/cond-intr-conj BET1
	(models/conditional/T BET2 M)
	(models/conditional/T (booleval/conj/T BET1 BET2) M).

- : implies-preserves-models/cond-intr-conj BET1
	(models/conditional/F BEF2 M)
	(models/conditional/F (booleval/conj/F2 BEF2) M).

%worlds () (implies-preserves-models/cond-intr-conj _ _ _).
%total { } (implies-preserves-models/cond-intr-conj _ _ _).

- : implies-preserves-models/unit
	(models/conditional/T BET1 MC2)
        (implies/cond-intr-conj) (models/unit MCCP)
    <- models/unit-inversion MC2 MC2U
    <- implies-preserves-models/cond-intr-conj BET1 MC2U MCCP.

- : implies-preserves-models/unit
	(models/conditional/F BEF1 MC2)
	(implies/cond-intr-conj)
	(models/unit (models/conditional/F (booleval/conj/F1 BEF1) MC2)).

%theorem implies-preserves-models/cond-add-outer:
	forall* {G1} {H} {NG} {G2} {Pi1} {Pi2}
	forall	{BE: booleval assumptions/0 NG G1 true}
		{M: models H empty NG cycle/0 (conditional G2 Pi1 Pi2)}
	exists	{M: models H empty NG cycle/0
		     (conditional (conj G1 G2) Pi1 Pi2)}
	true.

- : implies-preserves-models/cond-add-outer BET1
     (models/conditional/T BET2 M)
     (models/conditional/T (booleval/conj/T BET1 BET2) M).

- : implies-preserves-models/cond-add-outer BET1
     (models/conditional/F BEF2 M)
     (models/conditional/F (booleval/conj/F2 BEF2) M).

%worlds () (implies-preserves-models/cond-add-outer _ _ _).
%total { } (implies-preserves-models/cond-add-outer _ _ _).

- : implies-preserves-models M implies/cond-add-outer (models/unit M')
    <- models/combined-inversion M H0 H1 H0+H1=H M1U M2U
    <- models/unit-inversion M1U M1
    <- models/nonlinear-inversion M1 Z=H0 BET
    <- heap`add-deterministic pheap`add/L H0+H1=H Z=H0 heap`eq/ H1=H
    <- models/unit-inversion M2U M2
    <- implies-preserves-models/cond-add-outer BET M2 M2'
    <- models-respects-eq 
       M2' H1=H permission`eq/ nesting`eq/ cycle`eq/ permission`eq/ M'.

% rem-outer is just like add-outer.

%theorem implies-preserves-models/cond-rem-outer:
	forall* {G1} {H} {NG} {G2} {Pi1} {Pi2}
	forall	{BE: booleval assumptions/0 NG G1 true}
		{M: models H empty NG cycle/0 
		     (conditional (conj G1 G2) Pi1 Pi2)}
	exists	{M: models H empty NG cycle/0
		     (conditional G2 Pi1 Pi2)}
	true.

- : implies-preserves-models/cond-rem-outer BET1
     (models/conditional/T (booleval/conj/T _ BET2) M)
     (models/conditional/T BET2 M).

- : implies-preserves-models/cond-rem-outer BET1
     (models/conditional/F (booleval/conj/F1 BEF1) _) M
    <- booleval-deterministic BET1 BEF1 nesting`eq/ permission`eq/ T=F
    <- bool`eq-ne-implies-false T=F ne/TF F
    <- false-implies-models F M.

- : implies-preserves-models/cond-rem-outer _
     (models/conditional/F (booleval/conj/F2 BEF2) M)
     (models/conditional/F BEF2 M).

%worlds () (implies-preserves-models/cond-rem-outer _ _ _).
%total { } (implies-preserves-models/cond-rem-outer _ _ _).

- : implies-preserves-models M implies/cond-rem-outer (models/unit M')
    <- models/combined-inversion M H0 H1 H0+H1=H M1U M2U
    <- models/unit-inversion M1U M1
    <- models/nonlinear-inversion M1 Z=H0 BET
    <- heap`add-deterministic pheap`add/L H0+H1=H Z=H0 heap`eq/ H1=H
    <- models/unit-inversion M2U M2
    <- implies-preserves-models/cond-rem-outer BET M2 M2'
    <- models-respects-eq 
       M2' H1=H permission`eq/ nesting`eq/ cycle`eq/ permission`eq/ M'.

- : implies-preserves-models/unit 
     (models/encumbered M1) 
     (implies/equiv-encumbered E1 E2)
     (models/unit
	(models/encumbered
	   (models/equiv (equiv/combine equiv/reflexive E1) E2 
	      M1))).

- : implies-preserves-models M1 (implies/gen-implication)
                             (models/unit
				(models/encumbered
				   (models/equiv 
				      (equiv/symmetric equiv/identity)
				      equiv/reflexive
				      M1))).

- : implies-preserves-models M1 (implies/self-implication) M2
    <- models-empty-is-empty M1 (null/0) _ ZERO=H
    <- models-respects-eq 
       (models/unit 
	  (models/encumbered
	     (models/equiv (equiv/transitive (equiv/symmetric equiv/identity)
			      equiv/commute)
		equiv/reflexive 
		models/obligation)))
       ZERO=H permission`eq/ nesting`eq/ cycle`eq/ permission`eq/ M2.
	
- : implies-preserves-models/unit
     M1 (implies/gen-implication)
     (models/unit
	(models/encumbered
	   (models/equiv 
	      (equiv/symmetric equiv/identity)
	      equiv/reflexive
	      (models/unit M1)))).

- : implies-preserves-models/unit 
     (models/encumbered M) (implies/remove-implication)
     (models/equiv equiv/identity equiv/reflexive M).

- : implies-preserves-models 
     (M1:models H empty NG cycle/0 
	   (unitperm (encumbered Pi1 Pi2) ,
	    unitperm (encumbered Pi2 Pi3)))
	   implies/chain-implication
     (models/unit 
	(models/encumbered 
	   (models/equiv 
	      (equiv/transitive
		 (equiv/combine
		    (equiv/transitive equiv/commute equiv/identity)
		    equiv/reflexive)
		 equiv/commute)
	      equiv/reflexive 
	      M2)))
    <- models/combined-inversion M1 Ha Hb HA M1a M1b
    <- models/unit-inversion M1a (models/encumbered M1a')
    <- models/unit-inversion M1b (models/encumbered M1b')
    <- heap`add-commutative HA HA'
    <- scepter-complements-combine M1b' M1a' HA' equiv/commute M2.

%theorem implies-preserves-models/carve :
	forall* {N} {Pi} {O} {F} {H} {H2} {HG} {V}
	forall	{MG:models HG empty N cycle/0 (nonlinear (nested Pi O F))}
		{M1:models H2 empty N cycle/0 (basic O F V)}
		{HA:heap`add HG H2 H}
	exists	{M2:models H empty N cycle/0 
                 (Pi , (unitperm (encumbered Pi (unitperm (basic O F V)))))}
	true.

- : implies-preserves-models/carve 
	(models/nonlinear (booleval/nested/0 Pi=0)) M1 ZERO+H2=H
        (models/equiv equiv/identity equiv/reflexive
        (models/combined
          (models/equiv equiv/reflexive (equiv/symmetric Pi=0) models/empty)
          (models/unit 
	    (models/encumbered 
	      (models/equiv 
                (equiv/symmetric
                  (equiv/transitive
                    (equiv/combine equiv/reflexive Pi=0)
                    equiv/identity))
                equiv/reflexive (models/unit M1))))
          ZERO+H2=H)).

- : implies-preserves-models/carve
	(models/nonlinear (booleval/nested P2N' NL' (K1:canon Pi1 C1) C1<=C'))
        (models/basic P2N NL (K:canon Pi C) M2 H+U=H2) 
	(ZERO+H2=H': heap`add _ H2 H')
        (models/equiv (equiv/transitive equiv/identity Psi1==0) equiv/reflexive
          (models/combined M1X
            (models/unit
              (models/encumbered 
                (models/equiv 
		  (equiv/symmetric 
                    (equiv/transitive equiv/commute equiv/identity))
                  equiv/reflexive
                  (models/unit
                    (models/basic P2N NL K
                      (models/equiv 
                        (equiv/transitive3 
                          (equiv/combine Psi0==0 equiv/reflexive)
                          equiv/commute equiv/identity) 
                        Pi0,Pi1=Pi
                        (models/combined
                          M0XX
                          models/obligation
                          pheap`add/R))
		       H0+U=H3)))))
              (H1+H3=H': heap`add H1 H3 H')))
    <- heap`add-deterministic (pheap`add/L) ZERO+H2=H' heap`eq/ heap`eq/ H2=H'
    <- heap`add-respects-eq H+U=H2 heap`eq/ heap`eq/ H2=H' H+U=H'
    <- pair2nat-deterministic P2N' P2N natpair`eq/ N'=N
    <- nesting`lookup-deterministic NL' NL nesting`eq/ N'=N C'=C
    <- canonical`leq-respects-eq C1<=C' canonical`eq/ C'=C C1<=C
    <- canonical`leq-implies-add C1<=C C0 C0+C1=C
    <- canon-onto (K0:canon Pi0 C0)
    <- canon-eq-implies-equiv 
	(canon/+ K0 K1 C0+C1=C) K canonical`eq/ Pi0,Pi1=Pi
    <- models-equiv-added-implies-models-added
	M2 K K0 K1 C0+C1=C H0 H1 H0+H1=H Psi0 Psi1 Psi0,Psi1==0
	M0 M1
    <- heap`add-commutative H0+H1=H H1+H0=H
    <- heap`add-associative H1+H0=H H+U=H' H3 H0+U=H3 H1+H3=H'
    <- cycle-models-implies-models 
	M1 (cycle-models/+ P2N NL K M2 cycle-models/0) M1X
    <- cycle-models-implies-models 
	M0 (cycle-models/+ P2N NL K M2 cycle-models/0) M0X
    <- models/weaken-admissible M0X M0XX
    <- equiv-empty-implies-null Psi0,Psi1==0 (null/+ Psi0=0 Psi1=0)
    <- null-implies-equiv-empty Psi0=0 Psi0==0
    <- null-implies-equiv-empty Psi1=0 Psi1==0.
        
%worlds () (implies-preserves-models/carve _ _ _ _).
%total { } (implies-preserves-models/carve _ _ _ _).

- : implies-preserves-models M1 (implies/carve) M2
    <- models/combined-inversion M1 HG H2 HG+H2=H MUG MUB
    <- models/unit-inversion MUG MG
    <- models/unit-inversion MUB MB
    <- implies-preserves-models/carve MG MB HG+H2=H M2.
    
- : implies-preserves-models/unit
	(models/encumbered M1) implies/combine-assoc-encumbered 
	(models/unit
	  (models/encumbered
	    (models/equiv
	      (equiv/symmetric 
                (equiv/transitive equiv/commute equiv/identity)) 
	      equiv/reflexive
	      (models/unit
		(models/encumbered
		  (models/equiv
                    (equiv/transitive equiv/commute equiv/identity)
                    equiv/reflexive M1)))))).

- : implies-preserves-models M12 implies/combine-merge-encumbered
     	(models/unit 
	   (models/encumbered
	      (models/equiv 
		 (equiv/transitive equiv/double-associate
		    (equiv/combine equiv/identity equiv/reflexive))
		 equiv/reflexive
		 (models/combined M1' M2' HA))))
    <- models/combined-inversion M12 _ _ HA M1 M2
    <- models/unit-inversion M1 (models/encumbered M1')
    <- models/unit-inversion M2 (models/encumbered M2').

- : implies-preserves-models M (implies/scale-distribute-encumbered)
     (models/unit
	(models/encumbered
	   (models/equiv 
	      (equiv/symmetric (equiv/transitive equiv/commute equiv/identity))
	      equiv/reflexive
	      (models/scale
		 (models/equiv 
		    (equiv/transitive equiv/commute equiv/identity)
		    equiv/reflexive 
		    M2) 
		 HS))))
    <- models/scale-inversion M H HS M1
    <- models/unit-inversion M1 (models/encumbered M2).

- : implies-preserves-models/unit 
     (models/encumbered M1) 
     (implies/scale-factor-encumbered)
     (models/equiv equiv/zero equiv/reflexive
	(models/scale
	   (models/unit
	      (models/encumbered
		 (models/equiv
		    (equiv/symmetric 
		       (equiv/transitive equiv/commute equiv/identity))
		    equiv/reflexive M2)))
	   HS))
    <- models/scale-inversion* 
       (models/equiv (equiv/transitive equiv/commute equiv/identity)
	  equiv/reflexive M1) H HS M2.
     
- : implies-preserves-models/unit M (implies/gen-true-encumbered) M'
    <- models/nonlinear-inversion M Z=H BE
    <- models-respects-eq
	(models/unit
	   (models/encumbered
	      (models/equiv
		 (equiv/transitive 
		    (equiv/symmetric equiv/identity) 
		    equiv/commute)
		 equiv/reflexive
		 (models/unit (models/conditional/T BE (models/obligation))))))
       Z=H permission`eq/ nesting`eq/ cycle`eq/ permission`eq/ M'.

- : implies-preserves-models/unit M (implies/gen-false-encumbered) M'
    <- models/nonlinear-inversion M Z=H (booleval/neg/F BE)
    <- models-respects-eq
	(models/unit
	   (models/encumbered
	      (models/equiv
		 (equiv/transitive 
		    (equiv/symmetric equiv/identity) 
		    equiv/commute)
		 equiv/reflexive
		 (models/unit (models/conditional/F BE (models/obligation))))))
       Z=H permission`eq/ nesting`eq/ cycle`eq/ permission`eq/ M'.

- : implies-preserves-models M implies/combine2conj M'
    <- models/combined-inversion M H1 H2 H1+H2=H M1 M2
    <- models/unit-inversion M1 MG1
    <- models/nonlinear-inversion MG1 Z=H1 BE1
    <- models/unit-inversion M2 MG2
    <- models/nonlinear-inversion MG2 Z=H2 BE2
    <- heap`add-deterministic pheap`add/L H1+H2=H Z=H1 Z=H2 Z=H
    <- models-respects-eq 
	(models/unit (models/nonlinear (booleval/conj/T BE1 BE2))) 
	Z=H permission`eq/ nesting`eq/ cycle`eq/ permission`eq/ M'.

- : implies-preserves-models/unit
	MG implies/conj2combine
	(models/equiv equiv/identity equiv/reflexive
	  (models/combined
	    (models/unit (models/nonlinear BE1))
            (models/unit (models/nonlinear BE2))
	    Z+Z=H))
    <- models/nonlinear-inversion MG Z=H (booleval/conj/T BE1 BE2)
    <- heap`add-respects-eq pheap`add/L heap`eq/ heap`eq/ Z=H Z+Z=H.
    
- : implies-preserves-models/unit
     (models/nonlinear BE)
     implies/scale-into-formula 
     (models/equiv equiv/zero equiv/reflexive
	(models/scale (models/unit (models/nonlinear BE)) pheap`scale/0)).

- : implies-preserves-models QM implies/scale-from-formula M'
    <- models/scale-inversion QM H Q*H=QH M1
    <- models/unit-inversion M1 MG
    <- models/nonlinear-inversion MG Z=H BE
    <- heap`scale-deterministic pheap`scale/0 Q*H=QH rat`eq/ Z=H Z=QH
    <- models-respects-eq (models/unit (models/nonlinear BE))
	Z=QH permission`eq/ nesting`eq/ cycle`eq/ permission`eq/ M'.

- : implies-preserves-models M implies/empty2true M'
    <- models-empty-is-empty M null/0 _ Z=H
    <- models-respects-eq 
	(models/unit (models/nonlinear booleval/true))
	Z=H permission`eq/ nesting`eq/ cycle`eq/ permission`eq/ M'.

- : implies-preserves-models/unit (models/nonlinear _) implies/true2empty
     (models/empty).

- : implies-preserves-models/unit 
     (models/nonlinear BE) (implies/nonlinear I) 
     (models/unit (models/nonlinear BE'))
    <- bimplies-sound I BE BE'.

%theorem object-eq-implies-perm-eq :
	forall* {N1} {N2}
	forall  {PF:object -> permission} {E: nat`eq? N1 N2 true}
	exists  {PE: permission`eq (PF (object/ N1)) (PF (object/ N2))}
	true.

- : object-eq-implies-perm-eq _ nat`eq?/yes permission`eq/.

%worlds () (object-eq-implies-perm-eq _ _ _).
%total  {} (object-eq-implies-perm-eq _ _ _).

- : implies-preserves-models M (implies/objequal PF) M'
    <- models/combined-inversion M H1 H2 H1+H2=H M1 M2
    <- models/unit-inversion M1 MG1
    <- models/nonlinear-inversion MG1 Z=H1 (booleval/objequal OEQ)
    <- heap`add-deterministic pheap`add/L H1+H2=H Z=H1 pheap`eq/ H2=H
    <- object-eq-implies-perm-eq PF OEQ PEQ
    <- models-respects-eq
       M2 H2=H permission`eq/ nesting`eq/ cycle`eq/ PEQ M'.

%worlds () (implies-preserves-models _ _ _) 
           (implies-preserves-models/unit _ _ _).
%total (I U) (implies-preserves-models/unit _ U _) 
             (implies-preserves-models _ I _).
           
