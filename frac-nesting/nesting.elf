%%%%% nesting.elf
%%%%% The nesting relation for permissions
%%%%% John Boyland

%{%
As with "pre-heaps", we map pairs of natural numbers.
But this time we map to canonical permissions.
%}%



%%%% Functor Use




%%%% Definitions of Maps

map : type.


map/0 : map.

map/+ : nat -> canonical -> map -> map.

%abbrev map/1 : nat -> canonical -> map = [N] [D] (map/+ N D map/0).


%%%% Relations on maps


% equality is defined assuming "ne" is available,
% but 'ne' may be isufficiently inhabited to
% prove things about.


eq? : map -> map -> bool -> type.

%abbrev eq : map -> map -> type = [M1] [M2] eq? M1 M2 true.

%abbrev ne : map -> map -> type = [M1] [M2] eq? M1 M2 false.


eq?/yes : eq M M.

%abbrev eq/ = eq?/yes.

%abbrev eq?/no : ne M1 M2 -> eq? M1 M2 false = [x] x.



lookup : map -> nat -> canonical -> type.


lookup/= : lookup (map/+ N1 D _) N2 D
    <- nat`eq N1 N2.

lookup/> : lookup (map/+ N1 _ F) N2 D
    <- plus (s N0) N1 N2
    <- lookup F N0 D.


fresh : map -> nat -> type.


fresh/0 : fresh map/0 M.

fresh/< : fresh (map/+ N _ F) M
    <- gt N M.

fresh/> : fresh (map/+ N _ F) M
    <- plus (s M1) N M
    <- fresh F M1.



ne/< : lookup M1 N D -> fresh M2 N -> ne M1 M2.

ne/> : fresh M1 N -> lookup M2 N D -> ne M1 M2.



domain? : map -> nat -> bool -> type.


domain?/in : domain? M N true
    <- lookup M N _.

domain?/out : domain? M N false
    <- fresh M N.



disjoint : map -> map -> type.


disjoint/L : disjoint map/0 M.

disjoint/R : disjoint M map/0.

disjoint/< : disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N0) N1 N2
    <- disjoint M1 (map/+ N0 D2 M2).

disjoint/> : disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N3) N2 N1
    <- disjoint (map/+ N3 D1 M1) M2.



disjoint? : map -> map -> bool -> type.


disjoint?/yes : disjoint M1 M2 -> disjoint? M1 M2 true.

disjoint?/no :
	lookup M1 N D1 ->
	lookup M2 N D2 ->
    disjoint? M1 M2 false.



size : map -> nat -> type.


size/0 : size map/0 z.

size/+ : size (map/+ _ _ M) (s N)
    <- size M N.



%% useful for proving termination on map operations:

bound : map -> nat -> type.


bound/0 : bound map/0 z.

bound/+ : bound (map/+ N1 D M) N3
    <- bound M N2
    <- plus (s N1) N2 N3.


%worlds () (bound _ _).
%unique bound +B -1N.



shift : nat -> map -> map -> type.


shift/0 : shift _ map/0 map/0.

shift/+ : shift N1 (map/+ N2 D M) (map/+ N3 D M)
    <- plus (s N1) N2 N3.


%worlds () (shift _ _ _).
%unique shift +N +M -1M3.



update : map -> nat -> canonical -> map -> type.


update/0 : update map/0 N D (map/+ N D map/0).

update/= : update (map/+ N1 _ F) N2 D (map/+ N2 D F)
    <- nat`eq N1 N2.

update/< : update (map/+ N1 D1 F) N2 D2 (map/+ N2 D2 (map/+ N3 D1 F))
    <- plus (s N3) N2 N1.

update/> : update (map/+ N1 D1 F1) N2 D2 (map/+ N1 D1 F2)
    <- plus (s N0) N1 N2
    <- update F1 N0 D2 F2.




%%%% Theorems



%%% Theorems about eq


%theorem meta-eq :
	forall {M} {N} {E:eq M N}
	true.
- : meta-eq M M eq/.
%worlds () (meta-eq _ _ _).
%total {} (meta-eq _ _ _).
%reduces M = N (meta-eq M N _).


%theorem false-implies-eq? :
	forall*	{M1} {M2} {B}
	forall	{F:void}
	exists	{E: eq? M1 M2 B}
	true.

%worlds () (false-implies-eq? _ _).
%total { } (false-implies-eq? _ _).

%abbrev false-implies-eq = false-implies-eq?.

%abbrev false-implies-ne = false-implies-eq?.


%theorem eq-reflexive : forall {M} exists {E:eq M M} true.

- : eq-reflexive _ eq/.

%worlds () (eq-reflexive M %{=>}% M=M).
%total {} (eq-reflexive _ _).


%theorem eq?-symmetric :
	forall*	{M1} {M2} {B}
	forall	{E1: eq? M1 M2 B}
	exists	{E2: eq? M2 M1 B}
	true.

- : eq?-symmetric eq/ eq/.

- : eq?-symmetric (ne/< L F) (ne/> F L).

- : eq?-symmetric (ne/> F L) (ne/< L F).


%worlds () (eq?-symmetric _ _).
%total { } (eq?-symmetric _ _).

%abbrev eq-symmetric = eq?-symmetric.

%abbrev ne-symmetric = eq?-symmetric.


%theorem eq-transitive:
	forall* {M1} {M2} {M3}
	forall {E12:eq M1 M2} {E23:eq M2 M3}
	exists {E13:eq M1 M3}
	true.

- : eq-transitive eq/ eq/ eq/.

%worlds () (eq-transitive M1=M2 M2=M3 %{=>}% M1=M3).
%total {} (eq-transitive _ _ _).


%theorem map/+-preserves-eq? :
	forall* {N} {NP} {D} {DP} {F} {FP} {B}
	forall {EN:nat`eq N NP} {ED:canonical`eq D DP} {EF:eq? F FP B}
	exists {E:eq? (map/+ N D F) (map/+ NP DP FP) B}
	true.

- : map/+-preserves-eq? nat`eq/ canonical`eq/ eq/ eq/.

- : map/+-preserves-eq? nat`eq/ canonical`eq/ (ne/< L F) 
	(ne/< (lookup/> L P) (fresh/> F P))
    <- plus-total P.

- : map/+-preserves-eq? nat`eq/ canonical`eq/ (ne/> F L) 
	(ne/> (fresh/> F P) (lookup/> L P))
    <- plus-total P.


%worlds () (map/+-preserves-eq? _ _ _ _).
%total { } (map/+-preserves-eq? _ _ _ _).

%abbrev map/+-preserves-eq = map/+-preserves-eq?.

%abbrev map/+-preserves-ne = map/+-preserves-eq?.


%theorem map/+-preserves-eq-converse :
	forall* {N} {NP} {D} {DP} {F} {FP}
	forall {E:eq (map/+ N D F) (map/+ NP DP FP)}
	exists {EN:nat`eq N NP} {ED:canonical`eq D DP} {EF:eq F FP}
	true.

- : map/+-preserves-eq-converse eq/ nat`eq/ canonical`eq/ eq/.

%worlds () (map/+-preserves-eq-converse _ _ _ _).
%total {} (map/+-preserves-eq-converse _ _ _ _).


%theorem eq-no-occur :
	forall*  {M} {N} {D}
	forall {E:eq M (map/+ N D M)}
	exists {F:void}
	true.

%worlds () (eq-no-occur _ _).
%total {} (eq-no-occur _ _).


%theorem eq-contradiction :
	forall* {N} {D} {M}
	forall {E:eq map/0 (map/+ N D M)}
	exists {F:void}
	true.

%worlds () (eq-contradiction _ _).
%total {} (eq-contradiction _ _).



%%% Theorems about lookup


%theorem false-implies-lookup : 
	forall* {M} {N} {D}
	forall {F:void}
	exists {L:lookup M N D}
	true.

%worlds () (false-implies-lookup _ %{=>}% F^N=D).
%total {} (false-implies-lookup _ _).


%theorem lookup-respects-eq :
	forall* {M} {N} {D} {MP} {NP} {DP}
	forall {L:lookup M N D} {EM:eq M MP} {EN:nat`eq N NP} {ED:canonical`eq D DP}
	exists {LP:lookup MP NP DP}
	true.

- : lookup-respects-eq L eq/ nat`eq/ canonical`eq/ L.

%worlds () (lookup-respects-eq M^N=D M=MP N=NP D=DP %{=>}% MP^NP=DP).
%total {} (lookup-respects-eq _ _ _ _ _).
%reduces X = Y (lookup-respects-eq X _ _ _ Y).


%theorem meta-reduces-lookup :
	forall*	{M1} {M2} {N1} {N2} {D1} {D2}
	forall	{F: void}
		{L1: lookup M1 N1 D1}
		{L2: lookup M2 N2 D2}
	true.

%worlds () (meta-reduces-lookup _ _ _).
%total { } (meta-reduces-lookup _ _ _).
%reduces X < Y (meta-reduces-lookup _ X Y).


%theorem lookup/>-inversion :
	forall*	{N1} {D1} {M1} {N2} {D2} {N0}
	forall	{L: lookup (map/+ N1 D1 M1) N2 D2}
		{P: plus (s N0) N1 N2}
	exists	{LP: lookup M1 N0 D2}
	true. 

- : lookup/>-inversion (LEQ:lookup (map/+ N _ _) N _) P L
    <- plus-implies-gt P nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-lookup F L
    <- meta-reduces-lookup F L LEQ.

- : lookup/>-inversion (lookup/> LP P) PX LPX
    <- plus-right-cancels P PX nat`eq/ nat`eq/ SN0=SNX
    <- succ-cancels SN0=SNX N0=NX
    <- lookup-respects-eq LP eq/ N0=NX canonical`eq/ LPX.

%worlds () (lookup/>-inversion _ _ _).
%total { } (lookup/>-inversion _ _ _).
%reduces Y < X (lookup/>-inversion X _ Y).


%theorem lookup-deterministic :
	forall* {M} {N} {D} {MP} {NP} {DP}
	forall {L:lookup M N D} {LP:lookup MP NP DP}
               {EM:eq M MP} {EN:nat`eq N NP}
	exists {ED:canonical`eq D DP}
	true.

%abbrev lookup-unique = lookup-deterministic.

- : lookup-deterministic (lookup/= nat`eq/) (lookup/= nat`eq/) eq/ nat`eq/ canonical`eq/.

- : lookup-deterministic (lookup/> F^N0=D   N0+1+N1=N2) 
                         (lookup/> F^N0P=DP N0P+1+N1=N2) eq/ nat`eq/ D=DP
    <- plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- lookup-deterministic F^N0=D F^N0P=DP eq/ N0=N0P D=DP.

%% contradiction cases
- : lookup-deterministic (lookup/= nat`eq/) (lookup/> _ N0+1+N=N) 
                         eq/ nat`eq/ D=DP
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N FALSE
    <- canonical`false-implies-eq FALSE D=DP.

- : lookup-deterministic (lookup/> _ N0+1+N=N) (lookup/= nat`eq/)
                         eq/ nat`eq/ D=DP
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N FALSE
    <- canonical`false-implies-eq FALSE D=DP.

%worlds () (lookup-deterministic M^N=D MP^NP=DP M=MP N=NP %{=>}% D=DP).
%total (L) (lookup-deterministic L _ _ _ _).


%% lookup is NOT total


%theorem lookup-contradiction :
	forall* {N} {D}
	forall {L:lookup map/0 N D}
	exists {F:void}
	true.

%worlds () (lookup-contradiction _ _).
%total { } (lookup-contradiction _ _).


%theorem lookup-one-choice :
	forall* {N1} {D1} {N2} {D2}
	forall  {L:lookup (map/+ N1 D1 map/0) N2 D2}
	exists  {NE:nat`eq N1 N2} {DE:canonical`eq D1 D2}
	true.

- : lookup-one-choice (lookup/= nat`eq/) nat`eq/ canonical`eq/.

%worlds () (lookup-one-choice _ _ _).
%total { } (lookup-one-choice _ _ _).


%theorem lookup-implies-ge :
        forall* {N1} {D1} {M1} {N} {D}
        forall  {L: lookup (map/+ N1 D1 M1) N D}
        exists  {G: nat`ge N N1}
        true.

- : lookup-implies-ge (lookup/= nat`eq/) (nat`ge/= nat`eq/).

- : lookup-implies-ge (lookup/> _ P) (nat`ge/> GT)
    <- plus-implies-gt P nat`eq/ GT.
    
%worlds () (lookup-implies-ge _ _).
%total { } (lookup-implies-ge _ _).



%%% Theorems about fresh


%theorem false-implies-fresh : 
	forall* {M} {N} forall {F:void} exists {D:fresh M N} true.

%worlds () (false-implies-fresh _ %{=>}% N-not-in-domain-M).
%total {} (false-implies-fresh _ _).


%theorem fresh-respects-eq :
	forall* {M} {N} {MP} {NP}
	forall {D:fresh M N} {EM:eq M MP} {EN:nat`eq N NP}
	exists {DP:fresh MP NP}
	true.

- : fresh-respects-eq D eq/ nat`eq/ D.

%worlds () (fresh-respects-eq _ _ _ _).
%total {} (fresh-respects-eq _ _ _ _).


%theorem fresh/>-inversion :
	forall*	{M} {N} {D} {N1} {N2}
	forall	{F: fresh (map/+ N D M) N1}
		{P: plus (s N2) N N1}
	exists	{F1: fresh M N2}
	true.

- : fresh/>-inversion (fresh/< G1) P FR
    <- plus-implies-gt P nat`eq/ G
    <- gt-anti-symmetric G1 G F
    <- false-implies-fresh F FR.

- : fresh/>-inversion (fresh/> F1 P1) P F
    <- plus-right-cancels P1 P nat`eq/ nat`eq/ SEQ
    <- succ-cancels SEQ EQ
    <- fresh-respects-eq F1 eq/ EQ F.

%worlds () (fresh/>-inversion _ _ _).
%total { } (fresh/>-inversion _ _ _).


%% fresh is NOT deterministic

%theorem fresh-total* :
	forall {M}
	exists {N} {F:fresh M N}
	true.

- : fresh-total* map/0 z fresh/0.

- : fresh-total* (map/+ N1 _ M) N3 (fresh/> F N+1+N1=N3)
    <- fresh-total* M N F
    <- plus-total* (s N) N1 N3 N+1+N1=N3.

%worlds () (fresh-total* M %{=>}% N N-not-in-domain-of-M).
%total (M) (fresh-total* M _ _).

%abbrev fresh-total = fresh-total* _ _.


%theorem fresh-lookup-not-equal :
	forall* {M} {N1} {N2} {D2}
	forall {F:fresh M N1} {L:lookup M N2 D2}
	exists {NE:nat`ne N1 N2}
	true.

- : fresh-lookup-not-equal (fresh/< N2>N1) (lookup/= nat`eq/) (nat`ne/< N2>N1).

- : fresh-lookup-not-equal (fresh/< N1>N3) (lookup/> _ N0+1+N1=N2) 
                           (nat`ne/< N2>N3)
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- gt-transitive N2>N1 N1>N3 N2>N3.

- : fresh-lookup-not-equal (fresh/> _ X+1+N2=N1) (lookup/= nat`eq/) (nat`ne/> N1>N2)
    <- plus-implies-gt X+1+N2=N1 nat`eq/ N1>N2.

- : fresh-lookup-not-equal (fresh/> F N4+1+N1=N3) (lookup/> L N0+1+N1=N2)
                           N3<>N2
    <- fresh-lookup-not-equal F L N4<>N0
    <- succ-preserves-ne N4<>N0 N4+1<>N0+1
    <- plus-right-preserves-ne* N4+1<>N0+1 N4+1+N1=N3 N0+1+N1=N2 N3<>N2.

%worlds () (fresh-lookup-not-equal N1-not-in-domain-of-M M^N2=D %{=>}% N1<>N2).
%total (F) (fresh-lookup-not-equal F _ _).


%theorem fresh-contradiction :
	forall* {M} {N} {D}
	forall {F:fresh (map/+ N D M) N}
        exists {V:void}
	true.

- : fresh-contradiction (fresh/< N>N) V
    <- nat`gt-anti-reflexive N>N V.

- : fresh-contradiction (fresh/> _ N0+1+N=N) V
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N V.

%worlds () (fresh-contradiction _ _).
%total {} (fresh-contradiction _ _).


%theorem ne-implies-unit-map-fresh :
	forall* {N1} {D} {N2}
	forall {NE:nat`ne N1 N2}
	exists {F:fresh (map/+ N1 D map/0) N2}
	true.

- : ne-implies-unit-map-fresh 
     (nat`ne/< N1<N2) (fresh/> fresh/0 N0+1+N1=N2)
    <- nat`gt-implies-plus N1<N2 N0 N0+1+N1=N2.

- : ne-implies-unit-map-fresh
     (nat`ne/> N1>N2) (fresh/< N1>N2).

%worlds () (ne-implies-unit-map-fresh _ _).
%total { } (ne-implies-unit-map-fresh _ _).


%theorem plus-right-preserves-fresh* :
	forall* {M} {N1} {D} {N2} {N} {N3} {N4}
        forall {F:fresh (map/+ N1 D M) N2}
               {P1:plus N1 N N3} {P2:plus N2 N N4}
        exists {FP:fresh (map/+ N3 D M) N4}
	true.

- : plus-right-preserves-fresh* (fresh/< N2>N1) N1+N=N3 N2+N=N4 (fresh/< N4>N3)
    <- nat`plus-right-preserves-gt* N2>N1 N1+N=N3 N2+N=N4 N4>N3.

- : plus-right-preserves-fresh* (fresh/> F10 N0+1+N1=N2) N1+N=N3 N2+N=N4
                                (fresh/> F10 N0+1+N3=N4)
    <- nat`plus-associative* N0+1+N1=N2 N2+N=N4 N1+N=N3 N0+1+N3=N4.

%worlds () (plus-right-preserves-fresh* _ _ _ _).
%total {} (plus-right-preserves-fresh* _ _ _ _).


%theorem fresh-lookup-implies-ne :
	forall* {M1} {N1} {M2} {N2} {D2}
	forall {L1:fresh M1 N1}
	       {L2:lookup M2 N2 D2}
	       {EN:nat`eq N1 N2}
	exists {NM:ne M1 M2}
	true.

- : fresh-lookup-implies-ne F L nat`eq/ (ne/> F L).

%worlds () (fresh-lookup-implies-ne _ _ _ _).
%total { } (fresh-lookup-implies-ne _ _ _ _).



%%% Theorems about eq?/ne


%% false-implies-eq? already done

%theorem eq?-respects-eq :
	forall* {M11} {M12} {M21} {M22} {B}
	forall {N1:eq? M11 M12 B} {E1:eq M11 M21} {E2:eq M12 M22}
	exists {N2:eq? M21 M22 B}
	true.

%abbrev ne-respects-eq = eq?-respects-eq.


%theorem ne-anti-reflexive :
	forall* {M}
	forall {N:ne M M}
	exists {F:void}
	true.

- : ne-anti-reflexive (ne/< L F) V
    <- fresh-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N V.

- : ne-anti-reflexive (ne/> F L) V
    <- fresh-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N V.


%worlds () (ne-anti-reflexive _ _).
%total (N) (ne-anti-reflexive N _).


%theorem eq-ne-implies-false :
        forall* {X} {Y}
        forall {D1:eq X Y} {D2:ne X Y}
        exists {F:void}
        true.

- : eq-ne-implies-false eq/ X<>X F
    <- ne-anti-reflexive X<>X F.

%worlds () (eq-ne-implies-false _ _ _).
%total { } (eq-ne-implies-false _ _ _).




%%% Theorems about map/domain


%theorem false-implies-domain? :
	forall* {M} {N} {D}
	forall {F:void}
	exists {MD:domain? M N D}
	true.

%worlds () (false-implies-domain? _ _).
%total {} (false-implies-domain? _ _).


%theorem domain?-respects-eq :
	forall* {M1} {N1} {B1} {M2} {N2} {B2}
	forall  {MD1:domain? M1 N1 B1}
		{EM:eq M1 M2}
		{EN:nat`eq N1 N2}
		{BE:bool`eq B1 B2}
	exists  {MD2:domain? M2 N2 B2}
	true.

- : domain?-respects-eq MD eq/ nat`eq/ bool`eq/ MD.

%worlds () (domain?-respects-eq _ _ _ _ _).
%total { } (domain?-respects-eq _ _ _ _ _).


%theorem domain?-deterministic :
	forall* {M1} {N1} {B1} {M2} {N2} {B2}
	forall  {MD1:domain? M1 N1 B1}
		{MD2:domain? M2 N2 B2}
		{EM:eq M1 M2}
		{EN:nat`eq N1 N2}
	exists	{BE:bool`eq B1 B2}
	true.

%abbrev domain?-unique = domain?-deterministic.

- : domain?-deterministic _ _ _ _ bool`eq/.

- : domain?-deterministic (domain?/in L) (domain?/out F) eq/ nat`eq/ BE
    <- fresh-lookup-not-equal F L NE
    <- nat`ne-anti-reflexive NE V
    <- bool`false-implies-eq V BE.

- : domain?-deterministic (domain?/out F) (domain?/in L) eq/ nat`eq/ BE
    <- fresh-lookup-not-equal F L NE
    <- nat`ne-anti-reflexive NE V
    <- bool`false-implies-eq V BE.

%worlds () (domain?-deterministic _ _ _ _ _).
%total { } (domain?-deterministic _ _ _ _ _).


%theorem domain?-total* :
	forall {M} {N}
	exists {B} {MD:domain? M N B}
	true.

%% we need a lemma
%theorem domain?-map/+-total :
	forall {N1} {D1} {M1} {N2} {C} {CMP:nat`compare N1 N2 C}
	exists {B} {MD:domain? (map/+ N1 D1 M1) N2 B}
	true.

%% and this lemma needs a lemma
%theorem domain?-map/+-complete :
	forall {N1} {D1} {M1} {N2} {N0} {P:plus (s N0) N1 N2}
               {B} {MD1:domain? M1 N0 B}
	exists {MD:domain? (map/+ N1 D1 M1) N2 B}
	true.

- : domain?-total* map/0 N false (domain?/out fresh/0).

- : domain?-total* (map/+ N1 D1 M1) N2 B MD
    <- nat`compare-total* N1 N2 C CMP
    <- domain?-map/+-total N1 D1 M1 N2 C CMP B MD.

- : domain?-map/+-total N1 D1 M1 N2 equal CMP true 
                           (domain?/in (lookup/= N1=N2))
    <- equal-implies-eq CMP N1=N2.

- : domain?-map/+-total N1 D1 M1 N2 greater CMP false 
                           (domain?/out (fresh/< N1>N2))
    <- greater-implies-gt CMP N1>N2.

- : domain?-map/+-total N1 D1 M1 N2 less CMP B MD
    <- less-implies-lt CMP N2>N1
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- domain?-total* M1 N0 B MD1
    <- domain?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 B MD1 MD.

- : domain?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 true (domain?/in L1)
                              (domain?/in (lookup/> L1 N0+1+N1=N2)).

- : domain?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 false (domain?/out F1)
                              (domain?/out (fresh/> F1 N0+1+N1=N2)).

%worlds () (domain?-map/+-complete _ _ _ _ _ _ _ _ _).
%total {} (domain?-map/+-complete _ _ _ _ _ _ _ _ _).

%worlds () (domain?-total* _ _ _ _)
           (domain?-map/+-total _ _ _ _ _ _ _ _).
%total (M M1) (domain?-total* M _ _ _) 
              (domain?-map/+-total _ _ M1 _ _ _ _ _).

%abbrev domain?-total = domain?-total* _ _ _.


%theorem in-implies-lookup :
	forall* {M} {N}
	forall {MD:domain? M N true}
	exists {D} {L:lookup M N D}
	true.

- : in-implies-lookup (domain?/in L) _ L.

%worlds () (in-implies-lookup _ _ _).
%total {} (in-implies-lookup _ _ _).


%theorem out-implies-fresh :
	forall* {M} {N}
	forall {MD:domain? M N false}
	exists {F:fresh M N}
	true.

- : out-implies-fresh (domain?/out F) F.

%worlds () (out-implies-fresh _ _).
%total {} (out-implies-fresh _ _).



%%% Theorems about disjoint


%theorem false-implies-disjoint :
	forall* {M1} {M2}
	forall {F:void}
	exists {D:disjoint M1 M2}
	true.

%worlds () (false-implies-disjoint _ _).
%total { } (false-implies-disjoint _ _).


%theorem disjoint-respects-eq :
	forall* {M1} {M2} {M1P} {M2P}
	forall {A:disjoint M1 M2} {E1:eq M1 M1P} {E2:eq M2 M2P} 
	exists {AP:disjoint M1P M2P}
	true.

- : disjoint-respects-eq A eq/ eq/ A.

%worlds () (disjoint-respects-eq _ _ _ _).
%total {} (disjoint-respects-eq _ _ _ _).
%reduces A = AP (disjoint-respects-eq A _ _ AP).


%theorem disjoint/=-contradiction :
	forall* {N1} {D1} {M1} {N2} {D2} {M2}
	forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
	       {G:nat`eq N1 N2}
	exists {F:void}
	true.

- : disjoint/=-contradiction (disjoint/< _ N0+1+N=N) nat`eq/ F
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F.

- : disjoint/=-contradiction (disjoint/> _ N3+1+N=N) nat`eq/ F
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F.

%worlds () (disjoint/=-contradiction _ _ _).
%total { } (disjoint/=-contradiction _ _ _).


%theorem disjoint/<-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}
	forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
               {P:plus (s N0) N1 N2} 	       
	exists {AP:disjoint M1 (map/+ N0 D2 M2)}
	true.

- : disjoint/<-inversion (disjoint/< A P) PP AP
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P canonical`eq/ eq/ M022=M022P
    <- disjoint-respects-eq A eq/ M022=M022P AP.

- : disjoint/<-inversion (disjoint/> AP N3+1+N2=N1) N0+1+N1=N2 A
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M311=M1
    <- false-implies-eq F M2=M022
    <- disjoint-respects-eq AP M311=M1 M2=M022 A.

%worlds () (disjoint/<-inversion _ _ _).
%total {}  (disjoint/<-inversion _ _ _).
%reduces AP < A (disjoint/<-inversion A _ AP).


%theorem disjoint/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
	forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
	       {P:plus (s N3) N2 N1}
	exists {AP:disjoint (map/+ N3 D1 M1) M2}
	true.

- : disjoint/>-inversion (disjoint/> A P) PP AP
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P canonical`eq/ eq/ M311=M311P
    <- disjoint-respects-eq A M311=M311P eq/ AP.

- : disjoint/>-inversion (disjoint/< AP N0+1+N1=N2) N3+1+N2=N1 A
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M1=M311
    <- false-implies-eq F M022=M2
    <- disjoint-respects-eq AP M1=M311 M022=M2 A.

%worlds () (disjoint/>-inversion _ _ _).
%total { } (disjoint/>-inversion _ _ _).
%reduces AP < A (disjoint/>-inversion A _ AP).


%theorem disjoint-anti-reflexive :
	forall* {M}
	forall {D:disjoint M M}
	exists {E:eq map/0 M}
	true.

- : disjoint-anti-reflexive disjoint/L eq/.

- : disjoint-anti-reflexive disjoint/R eq/.

- : disjoint-anti-reflexive (A:disjoint (map/+ N D M) (map/+ N D M)) E
    <- disjoint/=-contradiction A nat`eq/ F
    <- false-implies-eq F E.

%worlds () (disjoint-anti-reflexive _ _).
%total { } (disjoint-anti-reflexive _ _).


%theorem disjoint-symmetric :
	forall* {M1} {M2}
	forall {D:disjoint M1 M2} 
	exists {D:disjoint M2 M1}
	true.

- : disjoint-symmetric disjoint/L disjoint/R.

- : disjoint-symmetric disjoint/R disjoint/L.

- : disjoint-symmetric (disjoint/< D P) (disjoint/> DP P)
    <- disjoint-symmetric D DP.

- : disjoint-symmetric (disjoint/> D P) (disjoint/< DP P)
    <- disjoint-symmetric D DP.

%worlds () (disjoint-symmetric _ _).
%total (D) (disjoint-symmetric D _).


%theorem disjoint-lookup-contradiction :
	forall* {M1} {M2} {N} {D1} {D2}
	forall {A:disjoint M1 M2}
               {L1:lookup M1 N D1} {L2:lookup M2 N D2}
	exists {F:void}
	true.

- : disjoint-lookup-contradiction disjoint/L L _ F
    <- lookup-contradiction L F.

- : disjoint-lookup-contradiction disjoint/R _ L F
    <- lookup-contradiction L F.

- : disjoint-lookup-contradiction (disjoint/< _ N0+1+N=N)
                                  (lookup/= nat`eq/) (lookup/= nat`eq/) F
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : disjoint-lookup-contradiction (disjoint/< _ N0+1+N1=N2)
                                  (lookup/= nat`eq/) 
                                  (lookup/> _ N3+1+N2=N1) F
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- gt-anti-symmetric N2>N1 N1>N2 F.
    
- : disjoint-lookup-contradiction (disjoint/< D N0+1+N1=N2)
                                  (lookup/> L1P N0P+1+N1=N2)
                                  (lookup/= nat`eq/) F
    <- plus-right-cancels N0P+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N0P+1=N0+1
    <- succ-cancels N0P+1=N0+1 N0P=N0
    <- lookup-respects-eq L1P eq/ N0P=N0 canonical`eq/ L1
    <- disjoint-lookup-contradiction D L1 (lookup/= nat`eq/) F.

- : disjoint-lookup-contradiction (disjoint/< D N0+1+N1=N2)
                                  (lookup/> L1 N1P+1+N1=N) 
                                  (lookup/> L2 N2P+1+N2=N) F
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N2P+1+N2=N NX
                                 N2P+1+N0=NX NX+N1+1=N
    <- plus-swap-succ N1P+1+N1=N N1P+N1+1=N
    <- plus-right-cancels NX+N1+1=N N1P+N1+1=N nat`eq/ nat`eq/ NX=N1P
    <- plus-respects-eq N2P+1+N0=NX nat`eq/ nat`eq/ NX=N1P N2P+1+N0=N1P
    <- disjoint-lookup-contradiction D L1 (lookup/> L2 N2P+1+N0=N1P) F.

- : disjoint-lookup-contradiction (disjoint/> _ N3+1+N=N)
                                  (lookup/= nat`eq/) (lookup/= nat`eq/) F
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : disjoint-lookup-contradiction (disjoint/> _ N3+1+N2=N1)
                                  (lookup/> _ N3+1+N1=N2)
                                  (lookup/= nat`eq/) F
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- plus-implies-gt N3+1+N1=N2 nat`eq/ N2>N1
    <- gt-anti-symmetric N1>N2 N2>N1 F.
    
- : disjoint-lookup-contradiction (disjoint/> D N3+1+N2=N1)
                                  (lookup/= nat`eq/)
                                  (lookup/> L2P N3P+1+N2=N1) F
    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- succ-cancels N3P+1=N3+1 N3P=N3
    <- lookup-respects-eq L2P eq/ N3P=N3 canonical`eq/ L2
    <- disjoint-lookup-contradiction D (lookup/= nat`eq/) L2 F.

- : disjoint-lookup-contradiction (disjoint/> D N3+1+N2=N1)
                                  (lookup/> L1 N1P+1+N1=N)
                                  (lookup/> L2 N2P+1+N2=N) F 
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N1P+1+N1=N NX
                                 N1P+1+N3=NX NX+N2+1=N
    <- plus-swap-succ N2P+1+N2=N N2P+N2+1=N
    <- plus-right-cancels NX+N2+1=N N2P+N2+1=N nat`eq/ nat`eq/ NX=N2P
    <- plus-respects-eq N1P+1+N3=NX nat`eq/ nat`eq/ NX=N2P N1P+1+N3=N2P
    <- disjoint-lookup-contradiction D (lookup/> L1 N1P+1+N3=N2P) L2 F.

%worlds () (disjoint-lookup-contradiction _ _ _ _).
%total (D) (disjoint-lookup-contradiction D _ _ _).


%theorem disjoint-lookup-implies-fresh :
	forall*	{M1} {N} {D} {M2}
	forall	{L: lookup M1 N D}
		{A: disjoint M1 M2}
	exists	{F: fresh M2 N}
	true.

%theorem disjoint-lookup-implies-fresh/L :
	forall*	{M1} {N} {D} {M2} {B}
	forall	{L: lookup M1 N D}
		{A: disjoint M1 M2}
		{D?: domain? M2 N B}
	exists	{F: fresh M2 N}
	true.

- : disjoint-lookup-implies-fresh/L
	L1 A (domain?/in L2) FR
    <- disjoint-lookup-contradiction A L1 L2 F
    <- false-implies-fresh F FR.

- : disjoint-lookup-implies-fresh/L
	_ _ (domain?/out FR) FR.

%worlds () (disjoint-lookup-implies-fresh/L _ _ _ _).
%total { } (disjoint-lookup-implies-fresh/L _ _ _ _).

- : disjoint-lookup-implies-fresh L D F
    <- domain?-total D?
    <- disjoint-lookup-implies-fresh/L L D D? F.

%worlds () (disjoint-lookup-implies-fresh _ _ _).
%total { } (disjoint-lookup-implies-fresh _ _ _).


%theorem shift-left-preserves-disjoint :
	forall* {N} {D} {M1} {M2} {SM1}
	forall {A:disjoint M1 M2} {S1:shift N M1 SM1}
        exists {SA:disjoint SM1 (map/+ N D M2)}
        true.

- : shift-left-preserves-disjoint _ shift/0 disjoint/L.

- : shift-left-preserves-disjoint M111*M2 (shift/+ N+1+N1=N1P)
                              (disjoint/> M111*M2 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-disjoint _ _ _).
%total { } (shift-left-preserves-disjoint _ _ _).


%theorem shift-left-preserves-disjoint-converse :
	forall* {N} {D} {M1} {M2} {SM1}
	forall {SA:disjoint SM1 (map/+ N D M2)} {S1:shift N M1 SM1}
        exists {A:disjoint M1 M2}
	true.

- : shift-left-preserves-disjoint-converse _ shift/0 disjoint/L.

- : shift-left-preserves-disjoint-converse M111*M222 (shift/+ N2+1+N3=N1)
                                           M311*M2
    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1
    <- disjoint/>-inversion M111*M222 N3+1+N2=N1 M311*M2.

%worlds () (shift-left-preserves-disjoint-converse _ _ _).
%total { } (shift-left-preserves-disjoint-converse _ _ _).


%theorem shift-right-preserves-disjoint :
	forall* {N} {D} {M1} {M2} {SM2}
	forall {A:disjoint M1 M2} {S2:shift N M2 SM2}
        exists {SA:disjoint (map/+ N D M1) SM2}
	true.

- : shift-right-preserves-disjoint _ shift/0 disjoint/R.

- : shift-right-preserves-disjoint M1*M222 (shift/+ N+1+N2=N2P)
                               (disjoint/< M1*M222 N2+1+N=N2P)
    <- plus-swap-succ N+1+N2=N2P N+N2+1=N2P
    <- plus-commutative N+N2+1=N2P N2+1+N=N2P.

%worlds () (shift-right-preserves-disjoint _ _ _).
%total { } (shift-right-preserves-disjoint _ _ _).


%theorem shift-right-preserves-disjoint-converse :
	forall* {N} {D} {M1} {M2} {SM2}
	forall {SA:disjoint (map/+ N D M1) SM2} {S2:shift N M2 SM2}
        exists {A:disjoint M1 M2}
	true.

- : shift-right-preserves-disjoint-converse _ shift/0 disjoint/R.

- : shift-right-preserves-disjoint-converse M111*M322 (shift/+ N1+1+N2=N3)
                                            M1*M222
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- disjoint/<-inversion M111*M322 N2+1+N1=N3 M1*M222.

%worlds () (shift-right-preserves-disjoint-converse _ _ _).
%total { } (shift-right-preserves-disjoint-converse _ _ _).


%theorem shift-preserves-disjoint :
	forall* {N} {M1} {M2} {SM1} {SM2}
	forall {A:disjoint M1 M2} 
               {S1:shift N M1 SM1} {S2:shift N M2 SM2}
	exists {SA:disjoint SM1 SM2}
	true.

- : shift-preserves-disjoint _ shift/0 _ disjoint/L.

- : shift-preserves-disjoint _ _ shift/0 disjoint/R.

- : shift-preserves-disjoint (disjoint/< M1*M022 N0+1+N1=N2)
                             (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                             (disjoint/< M1*M022 N0+1+N4=N5)
    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4
    <- plus-commutative N+N1+1=N4 N1+1+N=N4
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.

- : shift-preserves-disjoint (disjoint/> M311*M2 N3+1+N2=N1)
                             (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                             (disjoint/> M311*M2 N3+1+N5=N4)
    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5
    <- plus-commutative N+N2+1=N5 N2+1+N=N5
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4.

%worlds () (shift-preserves-disjoint _ _ _ _).
%total { } (shift-preserves-disjoint _ _ _ _).


%theorem shift-preserves-disjoint-converse :
	forall* {N} {M1} {M2} {SM1} {SM2}
	forall {SA:disjoint SM1 SM2}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	exists {A:disjoint M1 M2}
	true.

- : shift-preserves-disjoint-converse _ shift/0 _ disjoint/L.

- : shift-preserves-disjoint-converse _ _ shift/0 disjoint/R.

- : shift-preserves-disjoint-converse (disjoint/< M1*M055 N0+1+N4=N5)
                                      (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
				      (disjoint/< M1*M055 N0+1+N1=N2)
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4
    <- plus-associative-converse N1+N+1=N4 N0+1+N4=N5 N2P N0+1+N1=N2P N2P+N+1=N5
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-right-cancels N2P+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2P=N2
    <- plus-respects-eq N0+1+N1=N2P nat`eq/ nat`eq/ N2P=N2 N0+1+N1=N2.
                                  
- : shift-preserves-disjoint-converse (disjoint/> M611*M2 N6+1+N5=N4)
                                      (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                                      (disjoint/> M611*M2 N6+1+N2=N1)
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5
    <- plus-associative-converse N2+N+1=N5 N6+1+N5=N4 N1P N6+1+N2=N1P N1P+N+1=N4
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-right-cancels N1P+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1P=N1
    <- plus-respects-eq N6+1+N2=N1P nat`eq/ nat`eq/ N1P=N1 N6+1+N2=N1.

%worlds () (shift-preserves-disjoint-converse _ _ _ _).
%total { } (shift-preserves-disjoint-converse _ _ _ _).


%theorem can-construct-unit-disjoint:
	forall*	{N} {D} {M1} {M}
	forall	{S: shift N M1 M}
	exists	{A: disjoint M (map/+ N D map/0)}
	true.

- : can-construct-unit-disjoint shift/0 disjoint/L.

- : can-construct-unit-disjoint (shift/+ P) (disjoint/> disjoint/R PPP)
    <- plus-swap-succ P PP
    <- plus-commutative PP PPP.

%worlds () (can-construct-unit-disjoint _ _).
%total { } (can-construct-unit-disjoint _ _).


%theorem ne-implies-disjoint :
	forall* {N1} {D1} {N2} {D2}
	forall	{NE:nat`ne N1 N2}
	exists	{D:disjoint (map/+ N1 D1 map/0) (map/+ N2 D2 map/0)}
	true.

- : ne-implies-disjoint (nat`ne/< N1<N2) 
	(disjoint/< disjoint/L N0+1+N1=N2)
    <- gt-implies-plus N1<N2 _ N0+1+N1=N2.

- : ne-implies-disjoint (nat`ne/> N1>N2) 
	(disjoint/> disjoint/R N3+1+N2=N1)
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1.

%worlds () (ne-implies-disjoint _ _).
%total { } (ne-implies-disjoint _ _).


%theorem fresh-implies-unit-disjoint :
	forall*	{N} {M} {D}
	forall	{F:fresh M N}
	exists	{D: disjoint M (map/+ N D map/0)}
	true.

- : fresh-implies-unit-disjoint fresh/0 disjoint/L.

- : fresh-implies-unit-disjoint (fresh/< G) (disjoint/> disjoint/R P)
    <- gt-implies-plus G _ P.

- : fresh-implies-unit-disjoint (fresh/> F P) (disjoint/< D P)
    <- fresh-implies-unit-disjoint F D.

%worlds () (fresh-implies-unit-disjoint _ _).
%total (F) (fresh-implies-unit-disjoint F _).



%%% Theorems about size


%theorem false-implies-size :
	forall* {M} {N}
	forall {F:void}
	exists {SZ:size M N}
	true.

%worlds () (false-implies-size _ _).
%total { } (false-implies-size _ _).


%theorem size-total* :
	forall {M} 
	exists {N} {MX:size M N}
	true.

- : size-total* map/0 _ size/0.

- : size-total* _ _ (size/+ SZ)
    <- size-total* _ _ SZ.

%worlds () (size-total* _ _ _).
%total (M) (size-total* M _ _).


%abbrev size-total = size-total* _ _.


%theorem size-respects-eq :
	forall* {M1} {M2} {N1} {N2}
	forall  {SZ1:size M1 N1} 
		{EM:eq M1 M2}
        	{EN:nat`eq N1 N2}
	exists	{SZ2:size M2 N2} 
	true.

- : size-respects-eq S eq/ nat`eq/ S.

%worlds () (size-respects-eq _ _ _ _).
%total { } (size-respects-eq _ _ _ _).


%theorem size-deterministic :
	forall* {M1} {M2} {N1} {N2}
	forall {SZ1:size M1 N1} {SZ2:size M2 N2} {EM:eq M1 M2}
        exists {EN:nat`eq N1 N2}
	true.

%abbrev size-unique = size-deterministic.

- : size-deterministic size/0 size/0 eq/ nat`eq/.

- : size-deterministic (size/+ N1=|M1|) (size/+ N2=|M2|) eq/ N1+1=N2+1
    <- size-deterministic N1=|M1| N2=|M2| eq/ N1=N2
    <- succ-deterministic N1=N2 N1+1=N2+1.

%worlds () (size-deterministic _ _ _ _).
%total (S) (size-deterministic S _ _ _).


%theorem shift-preserves-size :
	forall* {M1} {N1} {M2} {N}
	forall	{SZ1: size M1 N1}
		{SH: shift N M1 M2}
	exists	{SZ2: size M2 N1}
	true.

- : shift-preserves-size (size/0) (shift/0) (size/0).

- : shift-preserves-size (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size _ _ _).
%total { } (shift-preserves-size _ _ _).


%theorem shift-preserves-size-converse:
	forall* {M1} {N1} {M2} {N}
	forall	{SZ2: size M2 N1}
		{SH: shift N M1 M2}
	exists	{SZ1: size M1 N1}
	true.

- : shift-preserves-size-converse (size/0) (shift/0) (size/0).

- : shift-preserves-size-converse (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size-converse _ _ _).
%total { } (shift-preserves-size-converse _ _ _).



%%% Theorems about bound

%theorem false-implies-bound :
	forall* {M} {N}
	forall {F:void}
	exists {MX:bound M N}
	true.

%worlds () (false-implies-bound _ _).
%total { } (false-implies-bound _ _).


%theorem bound-respects-eq :
	forall*	{M1} {N1} {M2} {N2}
	forall	{B1: bound M1 N1}
		{EM: eq M1 M2}
		{EN: nat`eq N1 N2}
	exists	{B2: bound M2 N2}
	true.

- : bound-respects-eq B _ _ B.

%worlds () (bound-respects-eq _ _ _ _).
%total { } (bound-respects-eq _ _ _ _).


%theorem bound-unique :
	forall*	{M1} {N1} {M2} {N2}
	forall	{B1: bound M1 N1}
		{B2: bound M2 N2}
		{EM: eq M1 M2}
	exists	{EN: nat`eq N1 N2}
	true.

%abbrev bound-deterministic = bound-unique.

- : bound-unique bound/0 bound/0 _ nat`eq/.

- : bound-unique (bound/+ P1 B1) (bound/+ P2 B2) eq/ EQ2
    <- bound-unique B1 B2 eq/ EQ1
    <- plus-unique P1 P2 nat`eq/ EQ1 EQ2.

%worlds () (bound-unique _ _ _ _).
%total (B) (bound-unique B _ _ _).


%theorem bound-total* :
	forall {M} 
	exists {N} {MX:bound M N}
	true.

- : bound-total* map/0 _ bound/0.

- : bound-total* _ _ (bound/+ P MX)
    <- bound-total* _ _ MX
    <- plus-total P.

%worlds () (bound-total* _ _ _).
%total (M) (bound-total* M _ _).


%abbrev bound-total = bound-total* _ _.


%theorem bound-lookup-implies-gt :
        forall* {M} {N} {D} {X}
        forall  {B: bound M X}
                {L: lookup M N D}
        exists  {G: gt X N}
        true.

- : bound-lookup-implies-gt (bound/+ P _) (lookup/= nat`eq/) G
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- plus-implies-gt Psc (nat`eq/) G.

- : bound-lookup-implies-gt (bound/+ P1 B) (lookup/> L P2) G
    <- bound-lookup-implies-gt B L G1
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- plus-left-preserves-gt* G1 P1 P2sc G.

%worlds () (bound-lookup-implies-gt _ _ _).
%total (B) (bound-lookup-implies-gt B _ _).


%theorem ge-bound-implies-fresh :
	forall* {M} {X} {N}
	forall {B:bound M X} {G:nat`ge N X}
	exists {F:fresh M N}
	true.

- : ge-bound-implies-fresh bound/0 _ fresh/0.

- : ge-bound-implies-fresh (bound/+ M1+1+X1=X B) N>=X (fresh/> F1 N1+1+M1=N)
    <- nat`ge-implies-plus N>=X Y1 Y1+X=N
    <- nat`plus-commutative M1+1+X1=X X1+M1+1=X
    <- nat`plus-associative-converse X1+M1+1=X Y1+X=N N1 Y1+X1=N1 N1+M1+1=N
    <- plus-swap-succ-converse N1+M1+1=N N1+1+M1=N
    <- plus-implies-ge Y1+X1=N1 N1>=X1
    <- ge-bound-implies-fresh B N1>=X1 F1.

%worlds () (ge-bound-implies-fresh _ _ _).
%total (B) (ge-bound-implies-fresh B _ _).



%%% Theorems about shift

%theorem false-implies-shift :
	forall* {M} {N} {MP}
	forall {F:void}
	exists {S:shift N M MP}
	true.
%worlds () (false-implies-shift _ _).
%total { } (false-implies-shift _ _).


%theorem shift-respects-eq :
	forall* {N} {M1} {M2} {NP} {M1P} {M2P}
	forall {S:shift N M1 M2} 
               {EN:nat`eq N NP} {E1:eq M1 M1P} {E2:eq M2 M2P}
        exists {SP:shift NP M1P M2P}
	true.

- : shift-respects-eq S nat`eq/ eq/ eq/ S.

%worlds () (shift-respects-eq _ _ _ _ _).
%total { } (shift-respects-eq _ _ _ _ _).


%theorem shift-total* :
	forall {N} {M1}
	exists {M2} {S:shift N M1 M2}
	true.

- : shift-total* N map/0 map/0 shift/0.

- : shift-total* N1 (map/+ N2 D M) (map/+ N3 D M) (shift/+ N1+1+N2=N3)
    <- plus-total N1+1+N2=N3.

%worlds () (shift-total* _ _ _ _).
%total { } (shift-total* _ _ _ _).

%abbrev shift-total = shift-total* _ _ _.


%theorem shift-deterministic :
	forall* {N} {M1} {M2} {NP} {M1P} {M2P}
	forall {S:shift N M1 M2} {SP:shift NP M1P M2P}
	       {EN:nat`eq N NP} {EM1:eq M1 M1P}
	exists {EM2:eq M2 M2P}
	true.

%abbrev shift-unique = shift-deterministic.

- : shift-deterministic shift/0 shift/0 nat`eq/ eq/ eq/.

- : shift-deterministic (shift/+ N1+1+N2=N3) (shift/+ N1+1+N2=N3P) nat`eq/ eq/ E
    <- plus-deterministic N1+1+N2=N3 N1+1+N2=N3P nat`eq/ nat`eq/ N3=N3P
    <- map/+-preserves-eq N3=N3P canonical`eq/ eq/ E.

%worlds () (shift-deterministic _ _ _ _ _).
%total { } (shift-deterministic _ _ _ _ _).


%theorem shift-cancels :
	forall* {N} {M1} {M2} {NP} {M1P} {M2P}
	forall {S:shift N M1 M2} {SP:shift NP M1P M2P}
	       {EN:nat`eq N NP} {EM1:eq M2 M2P}
	exists {EM2:eq M1 M1P}
	true.

- : shift-cancels shift/0 shift/0 nat`eq/ eq/ eq/.

- : shift-cancels (shift/+ N1+1+N2=N3) (shift/+ N1+1+N2P=N3) nat`eq/ eq/ E
    <- plus-left-cancels N1+1+N2=N3 N1+1+N2P=N3 nat`eq/ nat`eq/ N2=N2P
    <- map/+-preserves-eq N2=N2P canonical`eq/ eq/ E.

%worlds () (shift-cancels _ _ _ _ _).
%total { } (shift-cancels _ _ _ _ _).


%theorem shifts-add :
	forall* {N1} {N2} {N3} {M0} {M1} {M3}
	forall {S1:shift N1 M0 M1} {S2:shift N2 M1 M3} {P:plus (s N1) N2 N3}
        exists {S3:shift N3 M0 M3}
	true.

- : shifts-add shift/0 shift/0 _ shift/0.

- : shifts-add (shift/+ N1+1+N4=N5) (shift/+ N2+1+N5=N7) N1+1+N2=N3
               (shift/+ N3+1+N4=N7)          
    <- plus-total N3+1+N4=N7P
    <- plus-swap-succ N3+1+N4=N7P N3+N4+1=N7P
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-swap-succ N1+1+N4=N5 N1+N4+1=N5
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- plus-associative* N2+1+N1=N3 N3+N4+1=N7P N1+N4+1=N5 N2+1+N5=N7P
    <- plus-deterministic N2+1+N5=N7P N2+1+N5=N7 nat`eq/ nat`eq/ N7P=N7
    <- plus-respects-eq N3+1+N4=N7P nat`eq/ nat`eq/ N7P=N7 N3+1+N4=N7.

%worlds () (shifts-add _ _ _ _).
%total { } (shifts-add _ _ _ _).


%theorem shifts-add-converse :
	forall* {N1} {N2} {N3} {M0} {M3}
	forall {S3:shift N3 M0 M3} {P:plus (s N1) N2 N3}
	exists {M1} {S1:shift N1 M0 M1} {S2:shift N2 M1 M3}
        true.

- : shifts-add-converse S3 P M1 S1 S2
    <- shift-total S1
    <- shift-total S2P
    <- shifts-add S1 S2P P S3P
    <- shift-deterministic S3P S3 nat`eq/ eq/ M3P=M3
    <- shift-respects-eq S2P nat`eq/ eq/ M3P=M3 S2.

%worlds () (shifts-add-converse _ _ _ _ _).
%total { } (shifts-add-converse _ _ _ _ _).


%theorem shift-preserves-fresh :
        forall* {M1} {N1} {N2} {N0}
        forall	{L1:fresh M1 N1}
        	{P:plus (s N0) N1 N2} 
	exists	{M2} {S:shift N0 M1 M2}
		{L2:fresh M2 N2} 
	true.
	
- : shift-preserves-fresh fresh/0 P _ shift/0 fresh/0.

- : shift-preserves-fresh 
	(fresh/< G) P _ (shift/+ PP)
	(fresh/< GP)
    <- plus-total PP
    <- plus-left-preserves-gt* G PP P GP.

- : shift-preserves-fresh
	(fresh/> F D+1+N3=N1) N0+1+N1=N2 _ (shift/+ N0+1+N3=N4)
	(fresh/> F D+1+N4=N2)
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative D+1+N3=N1 N1+N0+1=N2 N4 N3+N0+1=N4 D+1+N4=N2
    <- plus-commutative N3+N0+1=N4 N0+1+N3=N4.

%worlds () (shift-preserves-fresh _ _ _ _ _).
%total (F) (shift-preserves-fresh F _ _ _ _).


%theorem shift-preserves-fresh* :
        forall* {M1} {N1} {N2} {N0} {M2}
        forall	{L1:fresh M1 N1}
        	{P:plus (s N0) N1 N2} 
		{S:shift N0 M1 M2}
	exists	{L2:fresh M2 N2} 
	true.
	
- : shift-preserves-fresh* F P S1 FP1
    <- shift-preserves-fresh F P _ S2 FP2
    <- shift-deterministic S2 S1 nat`eq/ eq/ EQ
    <- fresh-respects-eq FP2 EQ nat`eq/ FP1.

%worlds () (shift-preserves-fresh* _ _ _ _).
%total { } (shift-preserves-fresh* _ _ _ _).


%theorem shift-preserves-fresh-converse* :
        forall* {M1} {N1} {N2} {M2} {N0}
	forall {L2:fresh M2 N2} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2} 
        exists {L1:fresh M1 N1}
	true.

- : shift-preserves-fresh-converse* fresh/0 shift/0 _ fresh/0.

- : shift-preserves-fresh-converse* 
	(fresh/< N1>N) (shift/+ S+1+N2=N1) S+1+NP=N
	(fresh/< N2>NP)
    <- plus-left-cancels-gt S+1+N2=N1 S+1+NP=N nat`eq/ N1>N N2>NP.

- : shift-preserves-fresh-converse* 
	(fresh/> F NX+1+N2=N) (shift/+ S+1+N1=N2) S+1+NP=N
        (fresh/> F NX+1+N1=NP)
    <- plus-commutative S+1+N1=N2 N1+S+1=N2
    <- plus-associative-converse N1+S+1=N2 NX+1+N2=N NPP NX+1+N1=NPP NPP+S+1=N
    <- plus-commutative NPP+S+1=N S+1+NPP=N
    <- plus-left-cancels S+1+NPP=N S+1+NP=N nat`eq/ nat`eq/ NPP=NP
    <- plus-respects-eq NX+1+N1=NPP nat`eq/ nat`eq/ NPP=NP NX+1+N1=NP.

%worlds () (shift-preserves-fresh-converse* _ _ _ _).
%total { } (shift-preserves-fresh-converse* _ _ _ _).


%theorem shift-preserves-lookup :
        forall* {M1} {N1} {D} {N0} {M2}
	forall {L1:lookup M1 N1 D} {S:shift N0 M1 M2}
        exists {N2} {P:plus (s N0) N1 N2} {L2:lookup M2 N2 D}
	true.

- : shift-preserves-lookup (lookup/= nat`eq/) (shift/+ N0+1+N1=N2) _
                           N0+1+N1=N2 (lookup/= nat`eq/).

- : shift-preserves-lookup (lookup/> L N3+1+N1=N4) (shift/+ N0+1+N1=N2) _
                           N0+1+N4=N5 (lookup/> L N3+1+N2=N5)
    <- plus-total N0+1+N4=N5
    <- plus-commutative N3+1+N1=N4 N1+N3+1=N4
    <- plus-associative-converse* N1+N3+1=N4 N0+1+N4=N5 N0+1+N1=N2 N2+N3+1=N5
    <- plus-commutative N2+N3+1=N5 N3+1+N2=N5.

%worlds () (shift-preserves-lookup _ _ _ _ _).
%total { } (shift-preserves-lookup _ _ _ _ _).


%theorem shift-preserves-lookup* :
        forall* {M1} {N1} {D} {N0} {M2} {N2}
	forall {L1:lookup M1 N1 D} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2} 
        exists {L2:lookup M2 N2 D}
	true.

- : shift-preserves-lookup* L1 S P L2
    <- shift-preserves-lookup L1 S _ PP L2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- lookup-respects-eq L2P eq/ N2P=N2 canonical`eq/ L2.

%worlds () (shift-preserves-lookup* _ _ _ _).
%total { } (shift-preserves-lookup* _ _ _ _).


%theorem shift-preserves-lookup-converse :
        forall* {M1} {N0} {D} {N2} {M2}
	forall {L2:lookup M2 N2 D} {S:shift N0 M1 M2}
        exists {N1} {P:plus (s N0) N1 N2} {L1:lookup M1 N1 D}
	true.

- : shift-preserves-lookup-converse (lookup/= nat`eq/) (shift/+ N0+1+N1=N2) _
                                    N0+1+N1=N2 (lookup/= nat`eq/).

- : shift-preserves-lookup-converse (lookup/> L N3+1+N2=N5) (shift/+ N0+1+N1=N2)
                                    _ N0+1+N4=N5 (lookup/> L N3+1+N1=N4)
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse N1+N0+1=N2 N3+1+N2=N5 N4 N3+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.

%worlds () (shift-preserves-lookup-converse _ _ _ _ _).
%total { } (shift-preserves-lookup-converse _ _ _ _ _).


%theorem shift-preserves-lookup-converse* :
        forall* {M1} {N1} {D} {N2} {M2} {N0}
	forall {L2:lookup M2 N2 D} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2} 
        exists {L1:lookup M1 N1 D}
	true.

- : shift-preserves-lookup-converse* L2 S P L1
    <- shift-preserves-lookup-converse L2 S _ PP L1P
    <- plus-left-cancels PP P nat`eq/ nat`eq/ N1P=N1
    <- lookup-respects-eq L1P eq/ N1P=N1 canonical`eq/ L1.

%worlds () (shift-preserves-lookup-converse* _ _ _ _).
%total { } (shift-preserves-lookup-converse* _ _ _ _).


%theorem shift-implies-fresh* :
	forall* {M} {N1} {N} {NM}
	forall	{SH:shift N M NM}
		{GE:nat`ge N N1}
	exists	{F:fresh NM N1}
	true.

- : shift-implies-fresh* shift/0 _ fresh/0.

- : shift-implies-fresh* 
     (shift/+ SN+N1=N1P) N>=NP
     (fresh/< N1P>NP)
    <- plus-commutative SN+N1=N1P N1+SN=N1P
    <- plus-implies-ge N1+SN=N1P N1P>=SN
    <- ge-succ-implies-gt N1P>=SN N1P>N
    <- gt-transitive-ge N1P>N N>=NP N1P>NP.

%worlds () (shift-implies-fresh* _ _ _).
%total { } (shift-implies-fresh* _ _ _).


%theorem shift-implies-fresh :
	forall* {M} {N} {NM}
	forall	{SH:shift N M NM}
	exists	{F:fresh NM N}
	true.

- : shift-implies-fresh SH F
    <- shift-implies-fresh* SH (nat`ge/= nat`eq/) F.

%worlds () (shift-implies-fresh _ _).
%total { } (shift-implies-fresh _ _).


%theorem removal-preserves-fresh :
	forall*	{N1} {D} {M1} {N2} {M2}
	forall	{F1: fresh (map/+ N1 D M1) N2}
		{S: shift N1 M1 M2}
	exists	{F2: fresh M2 N2}
	true.

- : removal-preserves-fresh _ _ fresh/0.

- : removal-preserves-fresh (fresh/< GT1) (shift/+ P) (fresh/< GT2)
    <- plus-swap-succ P PS
    <- plus-commutative PS PSC
    <- plus-implies-gt PSC nat`eq/ GT3
    <- gt-transitive GT3 GT1 GT2.

- : removal-preserves-fresh (fresh/> F1 P1) (shift/+ P2) F2
    <- plus-swap-succ P1 PS1
    <- plus-commutative PS1 PSC1
    <- shift-preserves-fresh* F1 PSC1 
	(shift/+ P2) F2.

%worlds () (removal-preserves-fresh _ _ _).
%total { } (removal-preserves-fresh _ _ _).


%theorem shift-preserves-size :
	forall* {M} {N1} {N2} {S2M}
	forall {SZ:size M N1} {SH:shift N2 M S2M}
	exists {SHSZ:size S2M N1}
	true.

- : shift-preserves-size size/0 shift/0 size/0.

- : shift-preserves-size (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size _ _ _).
%total { } (shift-preserves-size _ _ _).



%%% Theorems about disjoint?


%theorem disjoint?-total* :
	forall {M1} {M2}
	exists {B} {D:disjoint? M1 M2 B}
	true.

- : disjoint?-total* _ _ _ (disjoint?/yes disjoint/L).

- : disjoint?-total* _ _ _ (disjoint?/yes disjoint/R).

%theorem disjoint?-total*/+ :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {C}
	forall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2} {CMP:nat`compare N1 N2 C}
	exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

%theorem disjoint?-total*/< :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0} {B1}
	forall {P:plus (s N0) N1 N2}
               {D?1:disjoint? M1 (map/+ N0 D2 M2) B1}
	exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

%theorem disjoint?-total*/> :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {B1}
	forall {P:plus (s N3) N2 N1}
               {D?1:disjoint? (map/+ N3 D1 M1) M2 B1}
	exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

- : disjoint?-total* _ _ _ D?
    <- size-total SZ1
    <- size-total SZ2
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?.

- : disjoint?-total*/+ _ _ _ _ (nat`compare/=) _ 
                       (disjoint?/no (lookup/= nat`eq/) (lookup/= nat`eq/)).

- : disjoint?-total*/+ _ _ _ _ (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- disjoint?-total*/< N0+1+N1=N2 (disjoint?/yes disjoint/L) _ D?.

- : disjoint?-total*/+ _ _ (size/+ SZ1) SZ2 (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- disjoint?-total*/< N0+1+N1=N2 D?1 _ D?.

- : disjoint?-total*/< N0+1+N1=N2 (disjoint?/yes M1*M022) _
                       (disjoint?/yes (disjoint/< M1*M022 N0+1+N1=N2)).

- : disjoint?-total*/< N0+1+N1=N2 (disjoint?/no M1^N3=D1 M022^N3=D2) _
                       (disjoint?/no (lookup/> M1^N3=D1 N3+1+N1=N4) M222^N4=D2)
    <- plus-total N3+1+N1=N4
    <- plus-swap-succ N3+1+N1=N4 N3+N1+1=N4
    <- plus-commutative N3+N1+1=N4 N1+1+N3=N4
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-preserves-lookup* M022^N3=D2 (shift/+ N1+1+N0=N2) N1+1+N3=N4
                               M222^N4=D2.

%worlds () (disjoint?-total*/< _ _ _ _).
%total { } (disjoint?-total*/< _ _ _ _).

- : disjoint?-total*/+ _ _ _ _ (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- disjoint?-total*/> N3+1+N2=N1 (disjoint?/yes disjoint/R) _ D?.

- : disjoint?-total*/+ _ _ SZ1 (size/+ SZ2) (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- disjoint?-total*/> N3+1+N2=N1 D?1 _ D?.

- : disjoint?-total*/> P (disjoint?/yes D) _ (disjoint?/yes (disjoint/> D P)).

- : disjoint?-total*/> N3+1+N2=N1 (disjoint?/no M311^N4=D1 M2^N4=D2) _
                       (disjoint?/no M111^N5=D1 (lookup/> M2^N4=D2 N4+1+N2=N5))
    <- plus-total N4+1+N2=N5
    <- plus-swap-succ N4+1+N2=N5 N4+N2+1=N5
    <- plus-commutative N4+N2+1=N5 N2+1+N4=N5
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- shift-preserves-lookup* M311^N4=D1 (shift/+ N2+1+N3=N1) N2+1+N4=N5
                               M111^N5=D1.

%worlds () (disjoint?-total*/> _ _ _ _).
%total { } (disjoint?-total*/> _ _ _ _).

%worlds () (disjoint?-total*/+ _ _ _ _ _ _ _).
%total [S1 S2] (disjoint?-total*/+ S1 S2 _ _ _ _ _).

%worlds () (disjoint?-total* _ _ _ _).
%total { } (disjoint?-total* _ _ _ _).

%abbrev disjoint?-total = disjoint?-total* _ _ _.



%%% Theorems about update


%theorem false-implies-update :
	forall* {M} {N} {D} {MP} 
	forall {F:void} 
	exists {U:update M N D MP} 
	true.
%worlds () (false-implies-update _ %{=>}% M^N=D->MP).
%total {} (false-implies-update _ _).


%theorem update-respects-eq :
	forall* {M1} {N} {D} {M2} {M1P} {NP} {DP} {M2P}
	forall {U:update M1 N D M2} {EM1:eq M1 M1P} 
               {EN:nat`eq N NP} {ED:canonical`eq D DP} {EM2:eq M2 M2P}
	exists {UP:update M1P NP DP M2P} 
	true.
- : update-respects-eq U eq/ nat`eq/ canonical`eq/ eq/ U.
%worlds () (update-respects-eq M1^N=D->M2 M1=M1P N=NP D=DP M2=M2P 
                        %{=>}% M1P^NP=DP->M2P).
%total {} (update-respects-eq _ _ _ _ _ _).
%reduces U = UP (update-respects-eq U _ _ _ _ UP).


%% a technical lemma to help prove reduction arguments

%theorem meta-reduces-update :
	forall*	{M1} {M2} {N1} {N2} {D1} {D2} {M1P} {M2P}
	forall	{F: void}
		{L1: update M1 N1 D1 M1P}
		{L2: update M2 N2 D2 M2P}
	true.

%worlds () (meta-reduces-update _ _ _).
%total { } (meta-reduces-update _ _ _).
%reduces X < Y (meta-reduces-update _ X Y).


%theorem update/=-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2}
	forall {U:update (map/+ N1 D1 M1) N2 D2 M2} {E:nat`eq N1 N2}
        exists {EM:eq (map/+ N2 D2 M1) M2}
	true.

- : update/=-inversion (update/= nat`eq/) nat`eq/ eq/.

- : update/=-inversion (update/< N3+1+N=N) nat`eq/ E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update/=-inversion (update/> U1022 N3+1+N=N) nat`eq/ E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

%worlds () (update/=-inversion _ _ _).
%total { } (update/=-inversion _ _ _).


%theorem update/<-inversion:
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
	forall {U:update (map/+ N1 D1 M1) N2 D2 M2} {P:plus (s N3) N2 N1}
	exists {E:eq (map/+ N2 D2 (map/+ N3 D1 M1)) M2}
	true.

- : update/<-inversion (update/= nat`eq/) N3+1+N=N E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update/<-inversion (update/< N3+1+N2=N1) N3P+1+N2=N1 E
    <- nat`plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- nat`succ-cancels N3P+1=N3+1 N3P=N3
    <- map/+-preserves-eq N3P=N3 canonical`eq/ eq/ M311P=M311
    <- map/+-preserves-eq nat`eq/ canonical`eq/ M311P=M311 E.

- : update/<-inversion (update/> _ N0+1+N1=N2) N3+1+N2=N1 E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (update/<-inversion _ _ _).
%total { } (update/<-inversion _ _ _).


%theorem update/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M} {N0}
	forall {U:update (map/+ N1 D1 M1) N2 D2 M} {P:plus (s N0) N1 N2}
	exists {M2} {UP:update M1 N0 D2 M2} {E:eq (map/+ N1 D1 M2) M}
	true.

% a little more complex than might be expected
% because we want to prove reduction
- : update/>-inversion (U: update (map/+ N D1 M1) N D2 (map/+ N D2 M1))
                       N0+1+N=N M1 UP E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E
    <- false-implies-update F UP
    <- meta-reduces-update F UP U.

- : update/>-inversion 
	(update/< N3+1+N2=N1: update (map/+ N1 D1 M1) N2 D2 _) 
        N0+1+N1=N2 M1 UP E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-update F UP
    <- false-implies-eq F E
    <- meta-reduces-update 
	F UP (update/< N3+1+N2=N1: update (map/+ N1 D1 M1) N2 D2 _).

- : update/>-inversion (update/> U N0+1+N1=N2) N0P+1+N1=N2 _ UP eq/ 
    <- nat`plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- nat`succ-cancels N0+1=N0P+1 N0=N0P
    <- update-respects-eq U eq/ N0=N0P canonical`eq/ eq/ UP.

%worlds () (update/>-inversion _ _ _ _ _).
%total { } (update/>-inversion _ _ _ _ _).
%reduces UP < U (update/>-inversion U _ _ UP _).


%theorem update-contradiction :
	forall* {M} {N} {D}
	forall	{U: update M N D map/0}
	exists	{F: void}
	true.

%worlds () (update-contradiction _ _).
%total { } (update-contradiction _ _).


%theorem update-deterministic :
	forall* {M1} {N1} {D1} {M1P} {M2} {N2} {D2} {M2P}
	forall {U1:update M1 N1 D1 M1P} {U2:update M2 N2 D2 M2P}
	       {EM:eq M1 M2} {EN:nat`eq N1 N2} {ED:canonical`eq D1 D2}
	exists {EMP:eq M1P M2P}
	true.

%abbrev update-unique = update-deterministic.

- : update-deterministic update/0 update/0 eq/ nat`eq/ canonical`eq/ eq/.

- : update-deterministic (update/= nat`eq/) (update/= nat`eq/) eq/ nat`eq/ canonical`eq/ eq/.

- : update-deterministic (update/< N3+1+N2=N1) (update/< N3P+1+N2=N1)
                         eq/ nat`eq/ canonical`eq/ M1P=M2P
    <- plus-right-cancels N3+1+N2=N1 N3P+1+N2=N1 nat`eq/ nat`eq/ SN3=SN3P
    <- succ-cancels SN3=SN3P N3E
    <- map/+-preserves-eq N3E canonical`eq/ eq/ MM1=MM2
    <- map/+-preserves-eq nat`eq/ canonical`eq/ MM1=MM2 M1P=M2P.

- : update-deterministic (update/> F1^N0=D2->F2 N0+1+N1=N2)
                         (update/> F1^N0P=D2->F2P N0P+1+N1=N2)
                         eq/ nat`eq/ canonical`eq/ M1P=M2P
    <- plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- update-deterministic F1^N0=D2->F2 F1^N0P=D2->F2P eq/ N0=N0P 
                            canonical`eq/ F2=F2P
    <- map/+-preserves-eq nat`eq/ canonical`eq/ F2=F2P M1P=M2P.

%% contradiction cases:
- : update-deterministic (update/= nat`eq/) (update/< N3+1+N=N) eq/ nat`eq/ canonical`eq/ E
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/= nat`eq/) (update/> _ N0+1+N=N) eq/ nat`eq/ canonical`eq/ E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/< N3+1+N=N) (update/= nat`eq/) eq/ nat`eq/ canonical`eq/ E
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/< N3+1+N2=N1) (update/> _ N0+1+N1=N2)
                         eq/ nat`eq/ canonical`eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

- : update-deterministic (update/> _ N0+1+N=N) (update/= nat`eq/) eq/ nat`eq/ canonical`eq/ E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/> _ N0+1+N1=N2) (update/< N3+1+N2=N1)
                         eq/ nat`eq/ canonical`eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (update-deterministic M1^N1=D1->M1P M2^N2=D2->M2P M1=M2 N1=N2 D1=D2
                          %{=>}% M1P=M2P).
%total (U) (update-deterministic U _ _ _ _ _).


%theorem update-total* :
	forall {M} {N} {D}
	exists {MP} {U:update M N D MP}
	true.

%% we need a mutually recursive lemma
%theorem update-map/+-total :
	forall {N1} {D1} {M1} {N2} {D2} {C} {CMP:nat`compare N1 N2 C}
	exists {M2} {U:update (map/+ N1 D1 M1) N2 D2 M2}
	true.

- : update-total* map/0 N D (map/+ N D map/0) update/0.

- : update-total* (map/+ N1 D1 M1) N2 D2 M2 U
    <- nat`compare-total* N1 N2 C CMP
    <- update-map/+-total N1 D1 M1 N2 D2 C CMP M2 U.

- : update-map/+-total N1 D1 M1 N2 D2 equal CMP (map/+ N2 D2 M1) (update/= N1=N2)
    <- equal-implies-eq CMP N1=N2.

- : update-map/+-total N1 D1 M1 N2 D2 less CMP (map/+ N1 D1 M1P)
                       (update/> U1 N0+1+N1=N2)
    <- less-implies-lt CMP N2>N1
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- update-total* M1 N0 D2 M1P U1.

- : update-map/+-total N1 D1 M1 N2 D2 greater CMP (map/+ N2 D2 (map/+ N3 D1 M1))
                       (update/< N3+1+N2=N1)
    <- greater-implies-gt CMP N1>N2
    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1.

%worlds () (update-total* M N D %{=>}% MP M^N=D->MP)
           (update-map/+-total _ _ _ _ _ _ _ _ _).
%total (M1 M2) (update-total* M1 _ _ _ _) (update-map/+-total _ _ M2 _ _ _ _ _ _).

%abbrev update-total = update-total* _ _ _ _.


%theorem lookup-implies-update :
        forall* {F} {N} {D}
        forall {L:lookup F N D}
        exists {U:update F N D F} 
        true.
        
- : lookup-implies-update (lookup/= nat`eq/) (update/= nat`eq/).

- : lookup-implies-update (lookup/> L P) (update/> U P)
    <- lookup-implies-update L U.

%worlds () (lookup-implies-update _ _).
%total (L) (lookup-implies-update L _).


%theorem lookup-implies-fresh-update :
        forall* {M2} {N} {D}
        forall	{L:lookup M2 N D}
	exists	{M1}
		{F: fresh M1 N} 
        	{U:update M1 N D M2} 
        true.

- : lookup-implies-fresh-update (lookup/= nat`eq/) _ fresh/0 update/0.

- : lookup-implies-fresh-update (lookup/= nat`eq/) _ (fresh/< GT) (update/< P)
    <- plus-total P
    <- plus-implies-gt P nat`eq/ GT.

- : lookup-implies-fresh-update (lookup/> L P) _ (fresh/> F P) (update/> U P)
    <- lookup-implies-fresh-update L _ F U.

%worlds () (lookup-implies-fresh-update _ _ _ _).
%total (L) (lookup-implies-fresh-update L _ _ _).


%theorem update-implies-lookup :
	forall* {F} {N} {D} {FP}
	forall {U:update F N D FP} 
	exists {L:lookup FP N D}
	true.

- : update-implies-lookup update/0 (lookup/= nat`eq/).

- : update-implies-lookup (update/= nat`eq/) (lookup/= nat`eq/).

- : update-implies-lookup (update/< _) (lookup/= nat`eq/).

- : update-implies-lookup (update/> F^N0=D2->FP N0+1+N1=N2)
                          (lookup/> FP^N0=D2    N0+1+N1=N2)
    <- update-implies-lookup F^N0=D2->FP FP^N0=D2.

%worlds () (update-implies-lookup F^N=D->FP %{=>}% FP^N=D).
%total (U) (update-implies-lookup U _).


%theorem update-preserves-lookup :
	forall* {F} {N1} {D1} {FP} {N2} {D2}
	forall {L:lookup F N2 D2} {U:update F N1 D1 FP} {X:nat`ne N2 N1}
        exists {LP:lookup FP N2 D2}
	true.

%% update/0 is impossible

- : update-preserves-lookup (lookup/= nat`eq/) (update/= nat`eq/) N<>N LP
    <- nat`ne-anti-reflexive N<>N FALSE
    <- false-implies-lookup FALSE LP.

- : update-preserves-lookup (lookup/> L1 P1) (update/= nat`eq/) _ (lookup/> L1 P1).

- : update-preserves-lookup (lookup/= nat`eq/) (update/< N3+1+N2=N1) _ 
                            (lookup/> (lookup/= nat`eq/) N3+1+N2=N1).

- : update-preserves-lookup (lookup/> L N0+1+N1=N2P) (update/< N3+1+N2=N1) _
			    (lookup/> (lookup/> L N0+1+N3=N4)
			              N4+1+N2=N2P)
    <- plus-left-decrease N3+1+N2=N1 N1-1 N1=N1-1+1 N3+N2=N1-1
    <- plus-right-increase N3+N2=N1-1 N3+N2+1=N1-1+1
    <- nat`eq-symmetric N1=N1-1+1 N1-1+1=N1
    <- plus-respects-eq N3+N2+1=N1-1+1 nat`eq/ nat`eq/ N1-1+1=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N0+1+N1=N2P N4 N0+1+N3=N4
                                N4+N2+1=N2P
    <- plus-swap-succ-converse N4+N2+1=N2P N4+1+N2=N2P.

- : update-preserves-lookup (lookup/= nat`eq/) (update/> _ _) _ (lookup/= nat`eq/).

- : update-preserves-lookup (lookup/> L N0+1+N1=N2) 
                            ((update/> U N0P+1+N1=N2P) 
                             : update (map/+ N1 D1 M1) N2P DP 
                                      (map/+ N1 D1 M1P))
                            N2<>N2P 
                            ((lookup/> LP N0+1+N1=N2) 
                             : lookup (map/+ N1 D1 M1P) N2 D)
    <- plus-right-cancels-ne N0+1+N1=N2 N0P+1+N1=N2P nat`eq/ N2<>N2P N0+1<>N0P+1
    <- succ-preserves-ne-converse N0+1<>N0P+1 N0<>N0P
    <- update-preserves-lookup L U N0<>N0P LP.

%worlds () (update-preserves-lookup F^N2=D2 F^N1=D1->FP N1<>N2 FP^N2=D2).
%total (L) (update-preserves-lookup L _ _ _).


%theorem update-preserves-lookup-converse :
	forall* {F1} {N1} {D1} {F2} {N2} {D2}
	forall {L2:lookup F2 N2 D2} {U:update F1 N1 D1 F2} {X:nat`ne N2 N1}
        exists {L1:lookup F1 N2 D2}
	true.

- : update-preserves-lookup-converse (lookup/= nat`eq/) update/0 N<>N L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/= nat`eq/) N<>N
                                     L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/< N3+1+N2=N1)
                                     N<>N L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/> _ _) _
                                     (lookup/= nat`eq/).

- : update-preserves-lookup-converse (lookup/> L1 P) (update/= nat`eq/) _
                                     (lookup/> L1 P).

- : update-preserves-lookup-converse (lookup/> (lookup/= nat`eq/) N3+1+N2=N4)
                                     (update/< N3+1+N2=N1) _
                                     (lookup/= N1=N4)
    <- plus-deterministic N3+1+N2=N1 N3+1+N2=N4 nat`eq/ nat`eq/ N1=N4.

- : update-preserves-lookup-converse (lookup/> (lookup/> L1 N6+1+N3=N5) 
                                               N5+1+N2=N4)
                                     (update/< N3+1+N2=N1) _
                                     (lookup/> L1 N6+1+N1=N4)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-swap-succ N5+1+N2=N4 N5+N2+1=N4
    <- plus-associative* N6+1+N3=N5 N5+N2+1=N4 N3+N2+1=N1 N6+1+N1=N4.

- : update-preserves-lookup-converse (lookup/> L2 N5+1+N1=N4)
                                     (update/> U1 N0+1+N1=N2) N4<>N2
                                     (lookup/> L1 N5+1+N1=N4)
    <- plus-right-cancels-ne N5+1+N1=N4 N0+1+N1=N2 nat`eq/ N4<>N2 N5+1<>N0+1
    <- succ-preserves-ne-converse N5+1<>N0+1 N5<>N0
    <- update-preserves-lookup-converse L2 U1 N5<>N0 L1.

%worlds () (update-preserves-lookup-converse _ _ _ _).
%total (L) (update-preserves-lookup-converse L _ _ _).


%theorem update-preserves-fresh :
	forall* {M1} {N1} {N2} {D} {M2}
	forall {F1:fresh M1 N1} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
	exists {F2:fresh M2 N1}
	true.

- : update-preserves-fresh fresh/0 update/0 (nat`ne/< N>M) (fresh/< N>M).

- : update-preserves-fresh fresh/0 update/0 (nat`ne/> M>N) 
                           (fresh/> fresh/0 M1+1+N=M)
    <- gt-implies-plus M>N M1 M1+1+N=M.

- : update-preserves-fresh (fresh/< N>M) (update/= nat`eq/) _ (fresh/< N>M).

- : update-preserves-fresh (fresh/< N1>M) (update/< N3+1+N2=N1) (nat`ne/< N2>M)
                           (fresh/< N2>M).

- : update-preserves-fresh (fresh/< N1>M) (update/< N3+1+N2=N1) (nat`ne/> M>N2)
                           (fresh/> (fresh/< N3>M1) M1+1+N2=M)
    <- gt-implies-plus M>N2 M1 M1+1+N2=M
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-swap-succ M1+1+N2=M  M1+N2+1=M
    <- plus-right-cancels-gt N3+N2+1=N1 M1+N2+1=M nat`eq/ N1>M N3>M1.

- : update-preserves-fresh (fresh/< N1>M) (update/> _ _) _ (fresh/< N1>M).

- : update-preserves-fresh (fresh/> F P) (update/= nat`eq/) _ (fresh/> F P).

- : update-preserves-fresh (fresh/> F M1+1+N1=M) (update/< N3+1+N2=N1) _
                           (fresh/> (fresh/> F M1+1+N3=MM) MM+1+N2=M)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 M1+1+N1=M MM M1+1+N3=MM
                                 MM+N2+1=M
    <- plus-swap-succ-converse MM+N2+1=M MM+1+N2=M.

- : update-preserves-fresh (fresh/> F M1+1+N1=M) (update/> U N0+1+N1=N2) M<>N2
                           (fresh/> FP M1+1+N1=M)
    <- plus-right-cancels-ne M1+1+N1=M N0+1+N1=N2 nat`eq/ M<>N2 M1+1<>N0+1
    <- succ-preserves-ne-converse M1+1<>N0+1 M1<>N0
    <- update-preserves-fresh F U M1<>N0 FP.

%worlds () (update-preserves-fresh N1-fresh-M1 M1^N2=D->M2 N1<>N2 N1-fresh-M2).
%total (F) (update-preserves-fresh F _ _ _).


%theorem update-preserves-fresh-converse :
	forall* {M1} {N1} {N2} {D} {M2}
	forall {F1:fresh M2 N1} {U:update M1 N2 D M2}
	exists {F2:fresh M1 N1}
	true.

%theorem update-preserves-fresh-converse-helper :
	forall* {M1} {N1} {N2} {D} {M2} {B} {B2}
	forall {F1:fresh M2 N1} {U:update M1 N2 D M2}
               {D:domain? M1 N1 B} {E:nat`eq? N1 N2 B2}
	exists {F2:fresh M1 N1}
	true.

- : update-preserves-fresh-converse-helper _ _ (domain?/out F) _ F.

- : update-preserves-fresh-converse-helper F2 U (domain?/in L1) (nat`eq?/no N) F1
    <- update-preserves-lookup L1 U N L2
    <- fresh-lookup-not-equal F2 L2 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-fresh F F1.

- : update-preserves-fresh-converse-helper F2 U _ nat`eq?/yes F1
    <- update-implies-lookup U L2
    <- fresh-lookup-not-equal F2 L2 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-fresh F F1.

%worlds () (update-preserves-fresh-converse-helper _ _ _ _ _).
%total { } (update-preserves-fresh-converse-helper _ _ _ _ _).

- : update-preserves-fresh-converse F2 U F1
    <- domain?-total D
    <- nat`eq?-total E
    <- update-preserves-fresh-converse-helper F2 U D E F1.

%worlds () (update-preserves-fresh-converse _ _ _).
%total { } (update-preserves-fresh-converse _ _ _).


%theorem update-is-cause-of-change :
	forall* {M1} {N1} {N2} {M2} {D1} {D2}
	forall {F:fresh M1 N1}
	       {U:update M1 N2 D2 M2}
	       {L:lookup M2 N1 D1}
	exists {EN:nat`eq N1 N2} {ED:canonical`eq D1 D2}
	true.

%theorem update-is-cause-of-change/L :
	forall* {M1} {N1} {N2} {M2} {D1} {D2} {B}
	forall {F:fresh M1 N1}
	       {U:update M1 N2 D2 M2}
	       {L:lookup M2 N1 D1}
	       {E:nat`eq? N1 N2 B}
	exists {EN:nat`eq N1 N2} {ED:canonical`eq D1 D2}
	true.

- : update-is-cause-of-change F U L EN ED
     <- nat`eq?-total E?
     <- update-is-cause-of-change/L F U L E? EN ED.

- : update-is-cause-of-change/L F U L (nat`eq?/yes) nat`eq/ ED
    <- update-implies-lookup U LP
    <- lookup-deterministic L LP eq/ nat`eq/ ED.

- : update-is-cause-of-change/L F U L (nat`eq?/no N1<>N2) EN ED
    <- update-preserves-fresh F U N1<>N2 FP
    <- fresh-lookup-not-equal FP L N1<>N1
    <- nat`ne-anti-reflexive N1<>N1 V
    <- nat`false-implies-eq V EN
    <- canonical`false-implies-eq V ED.
    
%worlds () (update-is-cause-of-change/L _ _ _ _ _ _).
%total { } (update-is-cause-of-change/L _ _ _ _ _ _).

%worlds () (update-is-cause-of-change _ _ _ _ _).
%total { } (update-is-cause-of-change _ _ _ _ _).


%theorem update-preserves-membership :
	forall* {M1} {N1} {B} {N2} {D} {M2}
	forall {MD1:domain? M1 N1 B} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
	exists {MD2:domain? M2 N1 B}
	true.

- : update-preserves-membership (domain?/in L) U NE (domain?/in LP)
    <- update-preserves-lookup L U NE LP.

- : update-preserves-membership (domain?/out F) U NE (domain?/out FP)
    <- update-preserves-fresh F U NE FP.

%worlds () (update-preserves-membership _ _ _ _).
%total {} (update-preserves-membership _ _ _ _).


%theorem update-preserves-membership-converse :
	forall* {M1} {N1} {B} {N2} {D} {M2}
	forall {MD2:domain? M2 N1 B} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
	exists {MD1:domain? M1 N1 B}
	true.

- : update-preserves-membership-converse (domain?/in L2) U NE (domain?/in L1)
    <- update-preserves-lookup-converse L2 U NE L1.

- : update-preserves-membership-converse (domain?/out F2) U NE (domain?/out F1)
    <- update-preserves-fresh-converse F2 U F1.

%worlds () (update-preserves-membership-converse _ _ _ _).
%total { } (update-preserves-membership-converse _ _ _ _).


%theorem lookup-update-preserves-membership :
	forall* {M1} {N1} {B} {N2} {D1} {D2} {M2}
	forall {MD1:domain? M1 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
	exists {MD2:domain? M2 N1 B}
	true.

%theorem lookup-update-preserves-membership/L :
	forall* {M1} {N1} {B} {N2} {D1} {D2} {M2} {B2}
	forall {MD1:domain? M1 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
	       {EQ?:nat`eq? N1 N2 B2}
	exists {MD2:domain? M2 N1 B}
	true.

- : lookup-update-preserves-membership/L MD1 _ Ux1 (nat`eq?/no N1<>N2) MD2 
    <- update-preserves-membership MD1 Ux1 N1<>N2 MD2.

- : lookup-update-preserves-membership/L
	(domain?/in _) _ U (nat`eq?/yes) (domain?/in L2)
    <- update-implies-lookup U L2.

- : lookup-update-preserves-membership/L
	(domain?/out F1) L1 _ nat`eq?/yes (domain?/out F2)
    <- fresh-lookup-not-equal F1 L1 NE
    <- nat`ne-anti-reflexive NE F
    <- false-implies-fresh F F2.

%worlds () (lookup-update-preserves-membership/L _ _ _ _ _).
%total { } (lookup-update-preserves-membership/L _ _ _ _ _).

- : lookup-update-preserves-membership MD1 L1 U MD2
    <- nat`eq?-total EQUAL?
    <- lookup-update-preserves-membership/L MD1 L1 U EQUAL? MD2.

%worlds () (lookup-update-preserves-membership _ _ _ _).
%total { } (lookup-update-preserves-membership _ _ _ _).


%theorem lookup-update-preserves-membership-converse :
	forall* {M1} {N1} {B} {N2} {D1} {D2} {M2}
	forall {MD1:domain? M2 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
	exists {MD2:domain? M1 N1 B}
	true.

- : lookup-update-preserves-membership-converse MD2 ML MU MD1
    <- domain?-total MD1P
    <- lookup-update-preserves-membership MD1P ML MU MD2P
    <- domain?-deterministic MD2P MD2 eq/ nat`eq/ BP=B
    <- domain?-respects-eq MD1P eq/ nat`eq/ BP=B MD1.

%worlds () (lookup-update-preserves-membership-converse _ _ _ _).
%total { } (lookup-update-preserves-membership-converse _ _ _ _).


%theorem update-preserves-in-domain :
	forall* {M1} {N1} {N2} {D} {M2}
	forall {MD1:domain? M1 N1 true} {U:update M1 N2 D M2}
	exists {MD2:domain? M2 N1 true}
	true.

%theorem update-preserves-in-domain/L :
	forall* {M1} {N1} {N2} {D} {M2} {B}
	forall {MD1:domain? M1 N1 true} {U:update M1 N2 D M2}
	       {E: nat`eq? N1 N2 B}
	exists {MD2:domain? M2 N1 true}
	true.

- : update-preserves-in-domain/L
	(domain?/in ML1) U (nat`eq?/no N1<>N2) (domain?/in ML2)
    <- update-preserves-lookup ML1 U N1<>N2 ML2.

- : update-preserves-in-domain/L _ U (nat`eq?/yes) (domain?/in ML)
    <- update-implies-lookup U ML.

%worlds () (update-preserves-in-domain/L _ _ _ _).
%total { } (update-preserves-in-domain/L _ _ _ _).

- : update-preserves-in-domain MD1 U MD2
    <- nat`eq?-total E
    <- update-preserves-in-domain/L MD1 U E MD2.

%worlds () (update-preserves-in-domain _ _ _).
%total { } (update-preserves-in-domain _ _ _).


%theorem shift-preserves-update :
	forall* {M1} {N1} {D} {M1P} {N0} {M2}
	forall {U1:update M1 N1 D M1P}
               {S:shift N0 M1 M2}
        exists {N2} {M2P} 
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
               {U2:update M2 N2 D M2P}
	true.

- : shift-preserves-update update/0 shift/0 _ _ P (shift/+ P) update/0
    <- plus-total P.

- : shift-preserves-update (update/= nat`eq/) (shift/+ P) _ _ P (shift/+ P)
                           (update/= nat`eq/).

- : shift-preserves-update (update/< N4+1+N1=N3) (shift/+ N0+1+N3=N5) _ _
                           N0+1+N1=N2 (shift/+ N0+1+N1=N2) 
                           (update/< N4+1+N2=N5)
    <- plus-commutative N4+1+N1=N3 N1+N4+1=N3
    <- plus-associative-converse N1+N4+1=N3 N0+1+N3=N5 _ N0+1+N1=N2 N2+N4+1=N5
    <- plus-commutative N2+N4+1=N5 N4+1+N2=N5.

- : shift-preserves-update (update/> U N4+1+N3=N1) (shift/+ N0+1+N3=N5) _ _
                           N0+1+N1=N2 (shift/+ N0+1+N3=N5)
                           (update/> U N4+1+N5=N2)
   <- plus-total N0+1+N1=N2
   <- plus-commutative N4+1+N3=N1 N3+N4+1=N1
   <- plus-associative-converse* N3+N4+1=N1 N0+1+N1=N2 N0+1+N3=N5 N5+N4+1=N2
   <- plus-commutative N5+N4+1=N2 N4+1+N5=N2.

%worlds () (shift-preserves-update _ _ _ _ _ _ _).
%total { } (shift-preserves-update _ _ _ _ _ _ _).


%theorem shift-preserves-update* :
	forall* {M1} {N1} {D} {M1P} {N0} {M2} {N2} {M2P}
	forall {U1:update M1 N1 D M1P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
        exists {U2:update M2 N2 D M2P}
	true.

- : shift-preserves-update* U1 S P SS U2
    <- shift-preserves-update U1 S _ _ PP SSP U2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- shift-deterministic SSP SS nat`eq/ eq/ M2P=M2
    <- update-respects-eq U2P eq/ N2P=N2 canonical`eq/ M2P=M2 U2.

%worlds () (shift-preserves-update* _ _ _ _ _).
%total { } (shift-preserves-update* _ _ _ _ _).


%theorem shift-preserves-update-converse :
	forall* {M1} {N1} {D} {N0} {M2} {N2} {M2P}
        forall {U2:update M2 N2 D M2P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
        exists {M1P} {SS:shift N0 M1P M2P}
	       {U1:update M1 N1 D M1P}
	true.

- : shift-preserves-update-converse U2 S P _ SS U1
    <- update-total U1
    <- shift-preserves-update U1 S _ _ PP SSP U2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- update-deterministic U2P U2 eq/ N2P=N2 canonical`eq/ M2P=M2
    <- shift-respects-eq SSP nat`eq/ eq/ M2P=M2 SS.

%worlds () (shift-preserves-update-converse _ _ _ _ _ _).
%total { } (shift-preserves-update-converse _ _ _ _ _ _).


%theorem shift-preserves-update-converse* :
	forall* {M1} {N1} {D} {N0} {M2} {N2} {M2P} {M1P}
        forall {U2:update M2 N2 D M2P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
	exists {U1:update M1 N1 D M1P}
	true.

- : shift-preserves-update-converse* U2 S P SS U1
    <- shift-preserves-update-converse U2 S P _ SSP U1P
    <- shift-cancels SSP SS nat`eq/ eq/ E
    <- update-respects-eq U1P eq/ nat`eq/ canonical`eq/ E U1.

%worlds () (shift-preserves-update-converse* _ _ _ _ _).
%total { } (shift-preserves-update-converse* _ _ _ _ _).

%theorem update-commutes-shift-converse :
	forall* {M2} {N2} {D} {M2P} {N0} {M1P}
        forall {U2:update M2 N2 D M2P}
               {SS:shift N0 M1P M2P}
        exists {N1} {M1}
               {P:plus (s N0) N1 N2}
               {S:shift N0 M1 M2}
	       {U1:update M1 N1 D M1P}
	true.

- : update-commutes-shift-converse
	update/0 (shift/+ P) _ _ P shift/0 update/0.

- : update-commutes-shift-converse
	(update/= nat`eq/) (shift/+ P) _ _ P (shift/+ P)
	(update/= nat`eq/).

- : update-commutes-shift-converse
	(update/< D1+1+N=N1) (shift/+ D2+1+N2=N) _ _ D2+1+N2=N 
	(shift/+ D2+1+N0=N1) (update/< D1+1+N2=N0)
    <- plus-commutative D2+1+N2=N N2+D2+1=N
    <- plus-associative-converse N2+D2+1=N D1+1+N=N1 N0 D1+1+N2=N0 N0+D2+1=N1
    <- plus-commutative N0+D2+1=N1 D2+1+N0=N1.

- : update-commutes-shift-converse
	(update/> U D1+1+N=N1) (shift/+ D2+1+N2=N) _ _ D2+1+N0=N1
	(shift/+ D2+1+N2=N) (update/> U D1+1+N2=N0)
    <- plus-commutative D2+1+N2=N N2+D2+1=N
    <- plus-associative-converse N2+D2+1=N D1+1+N=N1 N0 D1+1+N2=N0 N0+D2+1=N1
    <- plus-commutative N0+D2+1=N1 D2+1+N0=N1.

%worlds () (update-commutes-shift-converse _ _ _ _ _ _ _).
%total { } (update-commutes-shift-converse _ _ _ _ _ _ _).


%theorem fresh-update-preserves-lookup :
	forall* {M} {N1} {D1} {MP} {N2} {D2}
	forall {L:lookup M N2 D2} {F: fresh M N1} {U:update M N1 D1 MP}
        exists {LP:lookup MP N2 D2}
	true.

- : fresh-update-preserves-lookup L F U LP
    <- fresh-lookup-not-equal F L NE
    <- nat`ne-symmetric NE NEs
    <- update-preserves-lookup L U NEs LP.

%worlds () (fresh-update-preserves-lookup _ _ _ _).
%total { } (fresh-update-preserves-lookup _ _ _ _).


%theorem fresh-update-increases-size :
	forall* {M1} {S} {N} {D} {M2}
	forall	{S1: size M1 S}
		{F: fresh M1 N}
		{U: update M1 N D M2}
	exists	{S2: size M2 (s S)}
	true.

- : fresh-update-increases-size size/0 fresh/0 update/0 (size/+ size/0).

- : fresh-update-increases-size (size/+ S) (fresh/< G) U SP
    <- gt-implies-plus G _ P
    <- update/<-inversion U P E
    <- size-respects-eq (size/+ (size/+ S)) E nat`eq/ SP.

- : fresh-update-increases-size (size/+ S) (fresh/> F P) U SPP
    <- update/>-inversion U P _ UP E
    <- fresh-update-increases-size S F UP SP
    <- size-respects-eq (size/+ SP) E nat`eq/ SPP.

%worlds () (fresh-update-increases-size _ _ _ _).
%total (F) (fresh-update-increases-size F _ _ _).

				       
%theorem fresh-update-increases-size-converse :
	forall* {M1} {S} {N} {D} {M2}
	forall	{S2: size M2 (s S)}
		{F: fresh M1 N}
		{U: update M1 N D M2}
	exists	{S1: size M1 S}
	true.

- : fresh-update-increases-size-converse S2 F U S1
    <- size-total S1P
    <- fresh-update-increases-size S1P F U S2P
    <- size-deterministic S2P S2 eq/ SNP=SN
    <- succ-cancels SNP=SN NP=N 
    <- size-respects-eq S1P eq/ NP=N S1.

%worlds () (fresh-update-increases-size-converse _ _ _ _).
%total { } (fresh-update-increases-size-converse _ _ _ _).


%theorem fresh-update-preserves-disjoint :
	forall* {M1} {M2} {N} {D} {M2P}
	forall	{I: disjoint M1 M2}
		{F: fresh M1 N}
		{U: update M2 N D M2P}
	exists	{DP: disjoint M1 M2P}
	true.

%theorem fresh-update-preserves-disjoint/L :
	forall* {M1} {M2} {N} {D} {M2P} {B}
	forall	{I: disjoint M1 M2}
		{F: fresh M1 N}
		{U: update M2 N D M2P}
		{D?: disjoint? M1 M2P B}
	exists	{DP: disjoint M1 M2P}
	true.

- : fresh-update-preserves-disjoint/L _ _ _ (disjoint?/yes DJ) DJ.

- : fresh-update-preserves-disjoint/L D FR U (disjoint?/no L1 L2P) DP
    <- fresh-lookup-not-equal FR L1 NE
    <- nat`ne-symmetric NE NEs
    <- update-preserves-lookup-converse L2P U NEs L2
    <- disjoint-lookup-contradiction D L1 L2 F
    <- false-implies-disjoint F DP.

%worlds () (fresh-update-preserves-disjoint/L _ _ _ _ _).
%total { } (fresh-update-preserves-disjoint/L _ _ _ _ _).

- : fresh-update-preserves-disjoint D F U DP
    <- disjoint?-total D?
    <- fresh-update-preserves-disjoint/L D F U D? DP.

%worlds () (fresh-update-preserves-disjoint _ _ _ _).
%total { } (fresh-update-preserves-disjoint _ _ _ _).


%theorem update-preserves-disjoint-converse :
	forall* {M1} {M2} {N} {D} {M2P}
	forall	{I: disjoint M1 M2P}
		{U: update M2 N D M2P}
	exists	{DP: disjoint M1 M2}
	true.

%theorem update-preserves-disjoint-converse/L :
	forall* {M1} {M2} {N} {D} {M2P} {B}
	forall	{I: disjoint M1 M2P}
		{U: update M2 N D M2P}
		{D: disjoint? M1 M2 B}
	exists	{DP: disjoint M1 M2}
	true.

- : update-preserves-disjoint-converse/L _ _ (disjoint?/yes DJ) DJ.

- : update-preserves-disjoint-converse/L DJP U (disjoint?/no L1 L2) DJ
    <- update-preserves-in-domain (domain?/in L2) U (domain?/in L2P)
    <- disjoint-lookup-contradiction DJP L1 L2P F
    <- false-implies-disjoint F DJ.

%worlds () (update-preserves-disjoint-converse/L _ _ _ _).
%total { } (update-preserves-disjoint-converse/L _ _ _ _).

- : update-preserves-disjoint-converse DP U D
    <- disjoint?-total D?
    <- update-preserves-disjoint-converse/L DP U D? D.

%worlds () (update-preserves-disjoint-converse _ _ _).
%total { } (update-preserves-disjoint-converse _ _ _).


%theorem update-preserves-bound:
	forall* {M1} {N1} {N2} {D} {M2}
	forall {F1:bound M1 N1} {U:update M1 N2 D M2} {N:nat`gt N1 N2}
	exists {F2:bound M2 N1}
	true.

- : update-preserves-bound (bound/+ P B) (update/= nat`eq/) _ (bound/+ P B).

- : update-preserves-bound (bound/+ I+1+J=K B) (update/< L+1+M=I) _ 
	(bound/+ M+1+N=K (bound/+ L+1+J=N B))
    <- plus-swap-succ I+1+J=K I+J+1=K
    <- plus-swap-succ L+1+M=I L+M+1=I
    <- plus-commutative L+M+1=I M+1+L=I
    <- plus-associative M+1+L=I I+J+1=K N L+J+1=N M+1+N=K
    <- plus-swap-succ-converse L+J+1=N L+1+J=N.

- : update-preserves-bound (bound/+ I+1+J=K B) (update/> U L+1+I=M) K>M
	(bound/+ I+1+J=K BP)
    <- plus-swap-succ L+1+I=M L+I+1=M
    <- plus-commutative L+I+1=M I+1+L=M
    <- plus-left-cancels-gt I+1+J=K I+1+L=M nat`eq/ K>M J>L
    <- update-preserves-bound B U J>L BP.

%worlds () (update-preserves-bound _ _ _ _).
%total (U) (update-preserves-bound _ U _ _).


%theorem update-preserves-bound-converse:
	forall* {M1} {N1} {N2} {D} {M2}
	forall {F1:bound M2 N1} {U:update M1 N2 D M2} {N:nat`ne N1 (s N2)}
	exists {F2:bound M1 N1}
	true.

- : update-preserves-bound-converse (bound/+ I+1+0=J bound/0) update/0 J<>I+1 B
    <- plus-right-identity (s I) I+1+0=I+1
    <- plus-unique I+1+0=J I+1+0=I+1 nat`eq/ nat`eq/ J=I+1
    <- nat`eq-ne-implies-false J=I+1 J<>I+1 F
    <- false-implies-bound F B.

- : update-preserves-bound-converse (bound/+ P B) (update/= nat`eq/) _ 
	(bound/+ P B).

- : update-preserves-bound-converse
	(bound/+ M+1+N=K (bound/+ L+1+J=N B))
	(update/< L+1+M=I) _ 
	(bound/+ I+1+J=K B) 
    <- plus-swap-succ L+1+J=N L+J+1=N 
    <- plus-swap-succ L+1+M=I L+M+1=I
    <- plus-commutative L+M+1=I M+1+L=I
    <- plus-associative-converse* L+J+1=N M+1+N=K M+1+L=I I+J+1=K
    <- plus-swap-succ-converse I+J+1=K I+1+J=K.

- : update-preserves-bound-converse 
	(bound/+ I+1+J=K BP) (update/> U L+1+I=M) K<>M+1
	(bound/+ I+1+J=K B)
    <- plus-swap-succ L+1+I=M L+I+1=M
    <- plus-commutative L+I+1=M I+1+L=M
    <- plus-right-increase I+1+L=M I+1+L+1=M+1
    <- plus-left-cancels-ne I+1+J=K I+1+L+1=M+1 nat`eq/ K<>M+1 J<>L+1
    <- update-preserves-bound-converse BP U J<>L+1 B.

%worlds () (update-preserves-bound-converse _ _ _ _).
%total (U) (update-preserves-bound-converse _ U _ _).



%theorem update-overwrites :
	forall* {M1} {N1} {D1} {M2} {N2} {D2} {M3}
	forall {U1:update M1 N1 D1 M2} {U2:update M2 N2 D2 M3}
	       {E:nat`eq N1 N2}
	exists {U12:update M1 N1 D2 M3}
	true.

- : update-overwrites (update/0) (update/= nat`eq/) nat`eq/ (update/0).

- : update-overwrites (update/= nat`eq/) (update/= nat`eq/) nat`eq/ (update/= nat`eq/).

- : update-overwrites (update/< P) (update/= nat`eq/) nat`eq/ (update/< P).

- : update-overwrites (update/> U1 P) (update/> U2 PP) nat`eq/ (update/> U3 P)
    <- plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- update-overwrites U1 U2 N0=N0P U3.

%% contradiction cases
- : update-overwrites (update/0) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/0) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/= nat`eq/) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/= nat`eq/) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/< _) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/< _) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/> _ N0+1+N=N) (update/= nat`eq/) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/> _ N0+1+N1=N2) (update/< N3+1+N2=N1) nat`eq/ U
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-update F U.

%worlds () (update-overwrites M1^N1=D1->M2 M2^N2=D2->M3 N1=N2 
                       %{=>}% M1^N1=D2->M3).
%total (U) (update-overwrites U _ _ _).


%theorem update-overwrites-converse :
	forall* {M1} {N1} {D1} {M2} {D2} {M3}
	forall {U12:update M1 N1 D1 M3} {U1:update M1 N1 D2 M2}
	exists {U2:update M2 N1 D1 M3}
	true.

- : update-overwrites-converse U12 U1 U2
    <- update-total U2P 
    <- update-overwrites U1 U2P nat`eq/ U12P
    <- update-deterministic U12P U12 eq/ nat`eq/ canonical`eq/ M2P=M2
    <- update-respects-eq U2P eq/ nat`eq/ canonical`eq/ M2P=M2 U2.

%worlds () (update-overwrites-converse _ _ _).
%total { } (update-overwrites-converse _ _ _).


%theorem update-may-have-no-effect :
	forall* {M1} {N} {D} {M2}
	forall {L:lookup M1 N D} {U:update M1 N D M2}
	exists {E:eq M1 M2}
	true.

- : update-may-have-no-effect (lookup/= nat`eq/) U E
    <- update/=-inversion U nat`eq/ E.

- : update-may-have-no-effect (lookup/> L1 N0+1+N1=N2) U E
    <- update/>-inversion U N0+1+N1=N2 _ U1 M112=M2
    <- update-may-have-no-effect L1 U1 M1=M2
    <- map/+-preserves-eq nat`eq/ canonical`eq/ M1=M2 M111=M112
    <- eq-transitive M111=M112 M112=M2 E.

%worlds () (update-may-have-no-effect _ _ _).
%total (L) (update-may-have-no-effect L _ _).


%theorem update-idempotent :
	forall* {M1} {N1} {D1} {M2} {N2} {D2} {M3}
	forall {U1:update M1 N1 D1 M2} {U2:update M2 N2 D2 M3}
	       {EN:nat`eq N1 N2} {ED:canonical`eq D1 D2}
	exists {EM:eq M2 M3}
	true.

- : update-idempotent U1 U2 nat`eq/ canonical`eq/ M2=M3
    <- update-overwrites U1 U2 nat`eq/ M1^N=D->M3
    <- update-deterministic U1 M1^N=D->M3 eq/ nat`eq/ canonical`eq/ M2=M3.

%worlds () (update-idempotent M1^N1=D1->M2 M2^N2=D2->M3 N1=N2 D1=D2
                       %{=>}% M2=M3).
%total {} (update-idempotent _ _ _ _ _).


%theorem update-commutes :
	forall* {M} {N1} {D1} {M1} {N2} {D2} {M12}
	forall {U1:update M N1 D1 M1} {U12:update M1 N2 D2 M12}
               {NE:nat`ne N1 N2}
        exists {M2} {U2:update M N2 D2 M2} {U21:update M2 N1 D1 M12}
	true.

- : update-commutes update/0 (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes update/0 (update/< NP+1+N2=N1) _ _ update/0
                    (update/> update/0 NP+1+N2=N1).

- : update-commutes update/0 (update/> update/0 NP+1+N1=N2) _ _ update/0
                    (update/< NP+1+N1=N2).

- : update-commutes (update/= nat`eq/) (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes (update/= nat`eq/) (update/< NP+1+N2=N1) _ _ 
                    (update/< NP+1+N2=N1) (update/> (update/= nat`eq/) NP+1+N2=N1).

- : update-commutes (update/= nat`eq/) (update/> U NP+1+N1=N2) _ _ 
                    (update/> U NP+1+N1=N2) (update/= nat`eq/).

- : update-commutes (update/< _) (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes (update/< N1P+1+N1=N) (update/< N2P+1+N2=N1) _ _ 
                    (update/< N2PP+1+N2=N) 
                    (update/> (update/< N1P+1+N2P=N2PP) N2P+1+N2=N1)
    <- plus-swap-succ N2P+1+N2=N1 N2P+N2+1=N1
    <- plus-associative-converse N2P+N2+1=N1 N1P+1+N1=N 
                                 N2PP N1P+1+N2P=N2PP N2PP+N2+1=N
    <- plus-swap-succ-converse N2PP+N2+1=N N2PP+1+N2=N.

- : update-commutes ((update/< N11+1+N1=N):update (map/+ N D M) _ _ _)
                  (update/> (update/= nat`eq/) N11+1+N1=N2) _
                    (map/+ N2 D2 M)
                    (update/= N=N2)
                    ((update/< N11+1+N1=N2):update _ N1 D1 _)
    <- plus-deterministic N11+1+N1=N N11+1+N1=N2 nat`eq/ nat`eq/ N=N2.

- : update-commutes (update/< N11+1+N1=N) 
                    (update/> (update/< N2PP+1+N2P=N11) N2P+1+N1=N2) _ _
                    (update/< N2PP+1+N2=N) (update/< N2P+1+N1=N2)
    <- plus-swap-succ N11+1+N1=N N11+N1+1=N
    <- plus-swap-succ N2P+1+N1=N2 N2P+N1+1=N2
    <- plus-associative* N2PP+1+N2P=N11 N11+N1+1=N N2P+N1+1=N2
                         N2PP+1+N2=N.

- : update-commutes (update/< N11+1+N1=N) 
                    (update/> (update/> U N2PP+1+N11=N2P) N2P+1+N1=N2) _ _
                    (update/> U N2PP+1+N=N2) (update/< N11+1+N1=N)
    <- plus-swap-succ N11+1+N1=N N11+N1+1=N
    <- plus-swap-succ N2P+1+N1=N2 N2P+N1+1=N2
    <- plus-associative* N2PP+1+N11=N2P N2P+N1+1=N2 N11+N1+1=N N2PP+1+N=N2.

- : update-commutes (update/> U N11+1+N=N1) (update/= nat`eq/) _ _
                    (update/= nat`eq/) (update/> U N11+1+N=N1).

- : update-commutes (update/> U N11+1+N=N1) (update/< N2P+1+N2=N) _ _
                    (update/< N2P+1+N2=N)
		    (update/> (update/> U N11+1+N2P=N11P) N11P+1+N2=N1)
    <- plus-swap-succ N2P+1+N2=N N2P+N2+1=N
    <- plus-associative-converse N2P+N2+1=N N11+1+N=N1 
                                 N11P N11+1+N2P=N11P N11P+N2+1=N1
    <- plus-swap-succ-converse N11P+N2+1=N1 N11P+1+N2=N1.

- : update-commutes (update/> U1 N11+1+N=N1) (update/> U12 N2P+1+N=N2) N1<>N2
                    (map/+ N D M2) 
     		    (update/> U2 N2P+1+N=N2) (update/> U21 N11+1+N=N1)
    <- plus-right-cancels-ne N11+1+N=N1 N2P+1+N=N2 nat`eq/ N1<>N2 N11+1<>N2P+1
    <- succ-preserves-ne-converse N11+1<>N2P+1 N11<>N2P
    <- update-commutes U1 U12 N11<>N2P M2 U2 U21.

%worlds () (update-commutes M^N1=D1->M1 M1^D2=N2->M12 N1<>N2
                     %{=>}% M2 M^N2=D2->M2 M2^N1=D1->M12).
%total (U1) (update-commutes U1 _ _ _ _ _).


%theorem update-commutes* :
	forall* {M} {N1} {D1} {M1} {N2} {D2} {M12} {M2}
	forall {U1:update M N1 D1 M1} {U12:update M1 N2 D2 M12}
               {NE:nat`ne N1 N2} {U2:update M N2 D2 M2} 
        exists {U21:update M2 N1 D1 M12}
	true.

- : update-commutes* M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 M^N2=D2->M2 M2^N1=D1->M12
    <- update-commutes M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 
                       M2P M^N2=D2->M2P M2P^N1=D1->M12
    <- update-deterministic M^N2=D2->M2P M^N2=D2->M2 eq/ nat`eq/ 
                            canonical`eq/ M2P=M2
    <- update-respects-eq M2P^N1=D1->M12 M2P=M2 nat`eq/ 
                            canonical`eq/ eq/ M2^N1=D1->M12.

%worlds () (update-commutes* M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 M^N2=D2->M2
                      %{=>}% M2^N1=D1->M12).
%total {} (update-commutes* _ _ _ _ _). 


%theorem fresh-update-cancels :
	forall* {M1} {N1} {D1} {M1P}
		{M2} {N2} {D2} {M2P}
	forall	{F1: fresh M1 N1}
		{U1: update M1 N1 D1 M1P}
		{F2: fresh M2 N2}
		{U2: update M2 N2 D2 M2P}
		{NE: nat`eq N1 N2}
		{EQP: eq M1P M2P}
	exists	{DE: canonical`eq D1 D2}
		{EQ: eq M1 M2}
	true.

% can never be update/=
- : fresh-update-cancels _ _ FR (update/= nat`eq/) _ eq/ DE E
    <- fresh-contradiction FR F
    <- canonical`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels FR (update/= nat`eq/) _ _ _ eq/ DE E
    <- fresh-contradiction FR F
    <- canonical`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels fresh/0 update/0 _ update/0 nat`eq/ eq/ canonical`eq/ eq/.

- : fresh-update-cancels fresh/0 update/0 
	FR (update/> _ P) nat`eq/ eq/ DE E
    <- plus-implies-gt P nat`eq/ GT
    <- gt-anti-reflexive GT F
    <- canonical`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels 
     (fresh/< GT1) U1 (fresh/< GT2) U2 nat`eq/ eq/ DEX E
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 _ DEX EQ12R
    <- map/+-preserves-eq-converse EQ12R NP1=NP2 DE RE
    <- succ-deterministic NP1=NP2 SNP1=SNP2
    <- plus-deterministic P1 P2 SNP1=SNP2 nat`eq/ N1=N2
    <- map/+-preserves-eq N1=N2 DE RE E.
    
- : fresh-update-cancels 
     (fresh/< GT1) U1 (fresh/> _ P2) U2 nat`eq/ eq/ DE E
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- update/>-inversion U2 P2 _ _ EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 _ _
    <- plus-implies-gt P2 nat`eq/ NP1>NP2
    <- gt-respects-eq NP1>NP2 NP1=NP2 nat`eq/ NP2>NP2
    <- gt-anti-reflexive NP2>NP2 F
    <- canonical`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels 
	(fresh/> F1 P1) UP1 (fresh/> F2 P2) UP2 nat`eq/ eq/ DE E
    <- update/>-inversion UP1 P1 _ U1 EQ1
    <- update/>-inversion UP2 P2 _ U2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 D1=D2 MP1=MP2
    <- plus-right-cancels P1 P2 NP1=NP2 nat`eq/ SN1=SN2
    <- succ-cancels SN1=SN2 N1=N2
    <- fresh-update-cancels F1 U1 F2 U2 N1=N2 MP1=MP2 DE M1=M2
    <- map/+-preserves-eq NP1=NP2 D1=D2 M1=M2 E.

- :  fresh-update-cancels 
	(fresh/> F1 P1) UP1 (fresh/< GT2) UP2 nat`eq/ eq/ DE E
    <- update/>-inversion UP1 P1 _ _ EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion UP2 P2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 _ _
    <- plus-implies-gt P1 nat`eq/ NP2>NP1
    <- gt-respects-eq NP2>NP1 nat`eq/ NP1=NP2 NP2>NP2
    <- gt-anti-reflexive NP2>NP2 F
    <- canonical`false-implies-eq F DE
    <- false-implies-eq F E.

%worlds () (fresh-update-cancels _ _ _ _ _ _ _ _).
%total (F) (fresh-update-cancels F _ _ _ _ _ _ _).


% not exactly a converse, but very useful nonetheless
%theorem update-commutes-converse :
	forall* {M2} {N1} {D1} {M1} {N2} {D2} {M3}
	forall	{U1:update M2 N1 D1 M3} {U2:update M1 N2 D2 M3}
        	{NE:nat`ne N1 N2}
        exists	{M0} 
		{UX1:update M0 N2 D2 M2} {UX2:update M0 N1 D1 M1}
	true.

%theorem update-commutes-converse/L :
	forall* {M2} {N1} {D1} {M1} {N2} {D2} {M3} {B}
	forall	{U1:update M2 N1 D1 M3} {U2:update M1 N2 D2 M3}
        	{NE:nat`ne N1 N2}
		{MD?: domain? M2 N1 B}
        exists	{M0} 
		{UX1:update M0 N2 D2 M2} {UX2:update M0 N1 D1 M1}
	true.

- : update-commutes-converse/L U23 U13 N1<>N2 (domain?/out F2) _ U02 U01
    <- update-implies-lookup U23 L31
    <- update-preserves-lookup-converse L31 U13 N1<>N2 L11
    <- lookup-implies-fresh-update L11 M0 F01 U01
    <- update-commutes U01 U13 N1<>N2 M2X U02X U2X3
    <- update-preserves-fresh F01 U02X N1<>N2 F2X
    <- fresh-update-cancels F2X U2X3 F2 U23 nat`eq/ eq/ _ M2X=M2
    <- update-respects-eq U02X eq/ nat`eq/ canonical`eq/ M2X=M2 U02.

- : update-commutes-converse/L U23 U13 N1<>N2 (domain?/in L2) _ U02 U01
    <- update-implies-lookup U23 L31
    <- update-preserves-lookup-converse L31 U13 N1<>N2 L11
    <- lookup-implies-fresh-update L11 M0X F0X1 U0X1
    <- update-commutes U0X1 U13 N1<>N2 M2X U0X2X U2X3
    <- lookup-implies-update L2 U22
    <- update-overwrites-converse U22 U23 U32
    <- update-overwrites U2X3 U32 nat`eq/ U2X2
    <- nat`ne-symmetric N1<>N2 N2<>N1
    <- update-commutes U0X2X U2X2 N2<>N1 M0 U0X0 U02
    <- update-overwrites-converse U0X1 U0X0 U01.

%worlds () (update-commutes-converse/L _ _ _ _ _ _ _).
%total { } (update-commutes-converse/L _ _ _ _ _ _ _).

- : update-commutes-converse U23 U13 N1<>N2 M0 U02 U01
    <- domain?-total D?
    <- update-commutes-converse/L U23 U13 N1<>N2 D? M0 U02 U01.

%worlds () (update-commutes-converse _ _ _ _ _ _).
%total { } (update-commutes-converse _ _ _ _ _ _).


%% NB: update-commutes-converse* (the obvious * variant) is NOT true.


%theorem fresh-update-commutes-converse* :
	forall* {M0} {M2} {N1} {D1} {M1} {N2} {D2} {M3}
	forall	{F0: fresh M0 N1}
		{U01:update M0 N1 D1 M1}
		{U13:update M1 N2 D2 M3}
        	{NE:nat`ne N1 N2}
		{F2: fresh M2 N1}
		{U23:update M2 N1 D1 M3} 
	exists	{U02:update M0 N2 D2 M2} 
	true.

- : fresh-update-commutes-converse* F0 U01 U13 NE F2 U23 U02
    <- update-commutes-converse U23 U13 NE M0X U02X U01X
    <- update-preserves-fresh-converse F2 U02X F0X
    <- fresh-update-cancels F0X U01X F0 U01 nat`eq/ eq/ DE M0X=M0
    <- update-respects-eq U02X M0X=M0 nat`eq/ canonical`eq/ eq/ U02.

%worlds () (fresh-update-commutes-converse* _ _ _ _ _ _ _).
%total { } (fresh-update-commutes-converse* _ _ _ _ _ _ _).


%% The following theorem is needed if you want to iteratively
%% do something with a set.  It says that you can take out an element 
%% and (using the update-preserves-X-converse theorems) get a smaller set
%% that differs only for this element:

%theorem can-remove :
        forall* {M} {S} {N} {D}
	forall {SZ:size M S} {L:lookup M N D}
	exists {M-} {S-} {SZ-:size M- S-} {E:nat`eq (s S-) S}
               {U:update M- N D M} {F:fresh M- N}
	true.

- : can-remove (size/+ _) (lookup/= _) _ _ size/0 nat`eq/ update/0 fresh/0.

- : can-remove (size/+ (size/+ SZ)) (lookup/= nat`eq/) _ _ (size/+ SZ) nat`eq/
               (update/< N3+1+N2=N1) (fresh/< N1>N2)
    <- plus-total N3+1+N2=N1
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2.

- : can-remove (size/+ SZ) (lookup/> LK N0+1+N1=N2) _ _
               (size/+ SZ2) E
               (update/> U2 N0+1+N1=N2) (fresh/> F2 N0+1+N1=N2)
    <- can-remove SZ LK M- S- SZ2 E2 U2 F2
    <- succ-deterministic E2 E.

%worlds () (can-remove _ _ _ _ _ _ _ _).
%total (L) (can-remove _ L _ _ _ _ _ _).


% another version, which requires that you "know" the set is non-empty

%theorem can-remove* :
        forall* {M} {S}
	forall	{SZ:size M (s S)}
	exists	{MP} {N} {D}
		{SZP:size MP S} 
                {U:update MP N D M} 
		{F:fresh MP N}
	true.

- : can-remove* (size/+ SZ) MP N D SZP U F
    <- can-remove (size/+ SZ) (lookup/= nat`eq/) MP NP SZPP EQ U F
    <- succ-cancels EQ EQP
    <- size-respects-eq SZPP eq/ EQP SZP.

%worlds () (can-remove* _ _ _ _ _ _ _).
%total { } (can-remove* _ _ _ _ _ _ _).


%theorem shift-implies-update :
	forall*	{M1} {N} {M2} {D}
	forall	{SH: shift N M1 M2}
	exists	{U: update M2 N D (map/+ N D M1)}
	true.

- : shift-implies-update shift/0 update/0.

- : shift-implies-update (shift/+ P) (update/< PSC)
    <- plus-swap-succ P PS
    <- plus-commutative PS PSC.

%worlds () (shift-implies-update _ _).
%total { } (shift-implies-update _ _).


%theorem fresh-update-implies-shift:
	forall* {M} {N} {D} {M1}
	forall	{F: fresh M N}
		{U: update M N D (map/+ N D M1)}
	exists	{S: shift N M1 M}
	true.

- : fresh-update-implies-shift F U S
    <- shift-total SP
    <- shift-implies-update SP UP
    <- shift-implies-fresh SP FP
    <- fresh-update-cancels FP UP F U nat`eq/ eq/ canonical`eq/ MEQ
    <- shift-respects-eq SP nat`eq/ eq/ MEQ S.

%worlds () (fresh-update-implies-shift _ _ _).
%total { } (fresh-update-implies-shift _ _ _).







%%%% Map comparison



%%% Definition of leq

%{%
We always define leq? and nle even if we do not have these things in canonical.
This is simply for uniformity.  The relations are crippled if
canonical does not have the required relation.
%}%


leq? : map -> map -> bool -> type.

%abbrev leq : map -> map -> type = [M1] [M2] leq? M1 M2 true.

%abbrev nle : map -> map -> type = [M1] [M2] leq? M1 M2 false.


leq/0 : leq map/0 M.

leq/= : leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`eq N1 N2
    <- canonical`leq D1 D2
    <- leq M1 M2.

leq/> : leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N3) N2 N1
    <- leq (map/+ N3 D1 M1) M2.


nle/< : lookup M1 N D1 -> fresh M2 N -> nle M1 M2.


%abbrev leq?/yes : leq M1 M2 -> leq? M1 M2 true = [x] x.

%abbrev leq?/no : nle M1 M2 -> leq? M1 M2 false = [x] x.



%%% Theorems about leq


%theorem false-implies-leq? :
	forall* {M1} {M2} {B}
	forall {F:void}
	exists {L:leq? M1 M2 B}
	true.

%worlds () (false-implies-leq? _ _).
%total {} (false-implies-leq? _ _).

%abbrev false-implies-leq : void -> leq M1 M2 -> type = false-implies-leq?.

%abbrev false-implies-nle : void -> nle M1 M2 -> type = false-implies-leq?.


%theorem leq?-respects-eq :
	forall* {M1} {M2} {M1P} {M2P} {B}
	forall {L:leq? M1 M2 B} {E1:eq M1 M1P} {E2:eq M2 M2P}
	exists {LP:leq? M1P M2P B}
	true.

- : leq?-respects-eq L eq/ eq/ L.

%worlds () (leq?-respects-eq _ _ _ _).
%total { } (leq?-respects-eq _ _ _ _).
%reduces L1 = L2 (leq?-respects-eq L1 _ _ L2).

%abbrev leq-respects-eq = leq?-respects-eq.

%abbrev nle-respects-eq = leq?-respects-eq.


%theorem leq/0-inversion :
	forall* {M1} {M2}
	forall {L:leq M1 M2} {E2:eq M2 map/0}
	exists {E1:eq M1 map/0}
	true.

- : leq/0-inversion leq/0 eq/ eq/.

%worlds () (leq/0-inversion _ _ _).
%total { } (leq/0-inversion _ _ _).


%theorem leq/=-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2}
	forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} {EN:nat`eq N1 N2}
	exists {ED:canonical`leq D1 D2} {EM:leq M1 M2}
	true.

- : leq/=-inversion (leq/= M1<=M2 D1<=D2 nat`eq/) nat`eq/ D1<=D2 M1<=M2.

- : leq/=-inversion (leq/> M311<=M2 N3+1+N=N) nat`eq/ ED M1<=M2
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- canonical`false-implies-leq F ED
    <- false-implies-eq F M311=M1
    <- leq-respects-eq M311<=M2 M311=M1 eq/ M1<=M2.

%worlds () (leq/=-inversion _ _ _ _).
%total { } (leq/=-inversion _ _ _ _).
%reduces L1 < L (leq/=-inversion L _ _ L1).


%theorem leq/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
	forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} 
               {P:plus (s N3) N2 N1}
	exists {EM:leq (map/+ N3 D1 M1) M2}
	true.

- : leq/>-inversion (leq/= M1<=M2 D1<=D2 nat`eq/) N3+1+N=N M311<=M2
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M1=M311
    <- leq-respects-eq M1<=M2 M1=M311 eq/ M311<=M2.

- : leq/>-inversion (leq/> M311P<=M2 N3P+1+N2=N1) N3+1+N2=N1 M311<=M2
    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- succ-cancels N3P+1=N3+1 N3P=N3
    <- map/+-preserves-eq N3P=N3 canonical`eq/ eq/ M311P=M311
    <- leq-respects-eq M311P<=M2 M311P=M311 eq/ M311<=M2.

%worlds () (leq/>-inversion _ _ _).
%total { } (leq/>-inversion _ _ _).
%reduces LP < L (leq/>-inversion L _ LP).


%theorem leq-contradiction :
	forall*	{N} {D} {M}
	forall	{L: leq (map/+ N D M) map/0}
	exists	{F: void}
	true.

%worlds () (leq-contradiction _ _).
%total { } (leq-contradiction _ _).


%theorem leq/<-contradiction :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}
	forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} 
               {P:plus (s N0) N1 N2}
	exists {F:void}
	true.

- : leq/<-contradiction (leq/= _ _ nat`eq/) N0+1+N=N F
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : leq/<-contradiction (leq/> _ N3+1+N2=N1) N0+1+N1=N2 F
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F.

%worlds () (leq/<-contradiction _ _ _).
%total { } (leq/<-contradiction _ _ _).


%theorem leq-reflexive :
	forall {M}
	exists {L:leq M M}
	true.

- : leq-reflexive map/0 leq/0.

- : leq-reflexive (map/+ N D M) (leq/= M<=M D<=D nat`eq/)
    <- canonical`leq-reflexive D D<=D
    <- leq-reflexive M M<=M.

%worlds () (leq-reflexive _ _).
%total (M) (leq-reflexive M _).


%theorem leq-anti-symmetric :
	forall* {M1} {M2}
	forall {L1: leq M1 M2} {L2:leq M2 M1}
	exists {E: eq M1 M2}
	true.

- : leq-anti-symmetric leq/0 leq/0 eq/.

- : leq-anti-symmetric (leq/= M1<=M2 D1<=D2 nat`eq/) 
                       (leq/= M2<=M1 D2<=D1 nat`eq/) E
    <- canonical`leq-anti-symmetric D1<=D2 D2<=D1 D1=D2
    <- leq-anti-symmetric M1<=M2 M2<=M1 M1=M2
    <- map/+-preserves-eq nat`eq/ D1=D2 M1=M2 E.

- : leq-anti-symmetric (leq/= _ _ nat`eq/) (leq/> _ N3+1+N=N) E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : leq-anti-symmetric (leq/> _ N3+1+N=N) (leq/= _ _ nat`eq/) E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : leq-anti-symmetric (leq/> _ N3+1+N2=N1) (leq/> _ N0+1+N1=N2) E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (leq-anti-symmetric _ _ _).
%total (L) (leq-anti-symmetric L _ _).


%theorem leq-transitive :
	forall* {M1} {M2} {M3}
	forall {L1:leq M1 M2} {L2:leq M2 M3}
	exists {L3:leq M1 M3}
	true.

- : leq-transitive leq/0 _ leq/0.

- : leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) (leq/= M2<=M3 D2<=D3 nat`eq/)
                   (leq/= M1<=M3 D1<=D3 nat`eq/)
    <- canonical`leq-transitive D1<=D2 D2<=D3 D1<=D3
    <- leq-transitive M1<=M2 M2<=M3 M1<=M3.

- : leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) (leq/> M522<=M3 N5+1+N3=N2)
                   (leq/> M511<=M3 N5+1+N3=N2)
    <- leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) M522<=M3 M511<=M3.

- : leq-transitive (leq/> M011<=M2 N0+1+N=N1) (leq/= M2<=M3 D2<=D3 nat`eq/)
                   (leq/> M011<=M3 N0+1+N=N1)
    <- leq-transitive M011<=M2 M2<=M3 M011<=M3.

- : leq-transitive (leq/> M011<=M2 N0+1+N2=N1) (leq/> M522<=M3 N5+1+N3=N2)
                   (leq/> M411<=M3 N4+1+N3=N1)
    <- nat`plus-swap-succ N5+1+N3=N2 N5+N3+1=N2 
    <- nat`plus-associative-converse N5+N3+1=N2 N0+1+N2=N1 N4 N0+1+N5=N4
                                     N4+N3+1=N1
    <- nat`plus-swap-succ-converse N4+N3+1=N1 N4+1+N3=N1
    <- leq-transitive (leq/> M011<=M2 N0+1+N5=N4) M522<=M3 M411<=M3.

%worlds () (leq-transitive _ _ _).
%total (L) (leq-transitive _ L _).


%theorem map/+-preserves-leq? :
	forall* {N1} {N2} {D1} {D2} {M1} {M2} {B}
	forall {E:nat`eq N1 N2} {LD:canonical`leq D1 D2} {LM:leq? M1 M2 B}
        exists {L:leq? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

- : map/+-preserves-leq? N1=N2 D1<=D2 M1<=M2 (leq/= M1<=M2 D1<=D2 N1=N2).

- : map/+-preserves-leq? nat`eq/ _ (nle/< L1 F2)
	(nle/< (lookup/> L1 P) (fresh/> F2 P))
    <- plus-total P.


%worlds () (map/+-preserves-leq? _ _ _ _).
%total { } (map/+-preserves-leq? _ _ _ _).

%abbrev map/+-preserves-leq = map/+-preserves-leq?.

%abbrev map/+-preserves-nle = map/+-preserves-leq?.


%theorem lookup-respects-leq :
	forall* {M} {N} {D} {MP}
	forall {L:lookup M N D} {ME:leq M MP}
        exists {DP} {L:lookup MP N DP} {DE:canonical`leq D DP}
	true.

- : lookup-respects-leq (lookup/= nat`eq/) (leq/= _ D1<=D2 nat`eq/) 
                         _ (lookup/= nat`eq/) D1<=D2.

- : lookup-respects-leq (lookup/= nat`eq/) (leq/> M311<=M2 N3+1+N2=N1)
                         D2 (lookup/> L13 N3+1+N2=N1) D1<=D2
    <- lookup-respects-leq (lookup/= nat`eq/) M311<=M2 D2 L13 D1<=D2.

- : lookup-respects-leq (lookup/> L13 N3+1+N2=N1) (leq/= M1<=M2 _ nat`eq/)
                        D2 (lookup/> L13P N3+1+N2=N1) D1<=D2
    <- lookup-respects-leq L13 M1<=M2 D2 L13P D1<=D2.

- : lookup-respects-leq (lookup/> L10 N0+1+N1=N) (leq/> M311<=M2 N3+1+N2=N1)
                        D2 (lookup/> L14P N4+1+N2=N) D1<=D2
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- nat`plus-associative-converse N3+N2+1=N1 N0+1+N1=N 
                                     N4 N0+1+N3=N4 N4+N2+1=N
    <- nat`plus-swap-succ-converse N4+N2+1=N N4+1+N2=N
    <- lookup-respects-leq (lookup/> L10 N0+1+N3=N4) M311<=M2 D2 L14P D1<=D2.

%worlds () (lookup-respects-leq _ _ _ _ _).
%total (L) (lookup-respects-leq _ L _ _ _).


%theorem lookup-respects-leq* :
	forall* {M} {N} {D} {MP} {DP}
	forall {L:lookup M N D} {ME:leq M MP}
               {LP:lookup MP N DP} 
	exists {DE:canonical`leq D DP}
	true.

- : lookup-respects-leq* L ME LP DL
    <- lookup-respects-leq L ME _ LPP DLP
    <- lookup-unique LPP LP eq/ nat`eq/ DE
    <- canonical`leq-respects-eq DLP canonical`eq/ DE DL.

%worlds () (lookup-respects-leq* _ _ _ _).
%total { } (lookup-respects-leq* _ _ _ _).


%theorem lookup-implies-unit-leq :
	forall*	{M} {N} {D}
	forall	{L: lookup M N D}
	exists	{L: leq (map/+ N D map/0) M}
	true.

- : lookup-implies-unit-leq (lookup/= nat`eq/) (leq/= leq/0 D<=D nat`eq/)
    <- canonical`leq-reflexive _ D<=D.

- : lookup-implies-unit-leq (lookup/> LO P) (leq/> LE P)
    <- lookup-implies-unit-leq LO LE.

%worlds () (lookup-implies-unit-leq _ _).
%total (L) (lookup-implies-unit-leq L _).


%theorem fresh-respects-geq :
	forall* {M} {MP} {N}
	forall {FP:fresh MP N} {L:leq M MP}
	exists {F:fresh M N}
	true.

- : fresh-respects-geq F leq/0 fresh/0.

- : fresh-respects-geq (fresh/< R) (leq/= _ _ nat`eq/) (fresh/< R).

- : fresh-respects-geq (fresh/< N2>N) (leq/> _ N3+1+N2=N1) (fresh/< N1>N)
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- gt-transitive N1>N2 N2>N N1>N.

- : fresh-respects-geq (fresh/> F20 N0+1+N2=N) (leq/= M1<=M2 _ nat`eq/)
                       (fresh/> F10 N0+1+N2=N) 
    <- fresh-respects-geq F20 M1<=M2 F10.

- : {F3110:fresh (map/+ N3 D1 M1) N0}
    {N0+1+N2=N:plus (s N0) N2 N}
    {N3+1+N2=N1:plus (s N3) N2 N1}
    fresh-respects-geq 
       (fresh/> F20 N0+1+N2=N: fresh (map/+ N2 D2 M2) N) 
       (leq/> M311<=M2 N3+1+N2=N1) FP
    <- fresh-respects-geq F20 M311<=M2 F3110
    <- nat`plus-swap-succ N0+1+N2=N N0+N2+1=N
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-right-preserves-fresh* F3110 N3+N2+1=N1 N0+N2+1=N FP.

%worlds () (fresh-respects-geq _ _ _).
%total (F) (fresh-respects-geq F _ _).


%theorem leq-implies-size-le:
	forall* {M1} {M2} {N1} {N2}
	forall {L:leq M1 M2} {SZ1:size M1 N1} {SZ2:size M2 N2}
	exists {G:ge N2 N1}
	true.

- : leq-implies-size-le leq/0 size/0 N2=|M2| N2>=0
    <- plus-commutative (plus/z:plus z N2 N2) N2+0=N2    
    <- plus-implies-ge N2+0=N2 N2>=0.

- : leq-implies-size-le (leq/= M1<=M2 _ _) (size/+ N1=|M1|) (size/+ N2=|M2|)
                        N2+1>=N1+1
    <- leq-implies-size-le M1<=M2 N1=|M1| N2=|M2| N2>=N1
    <- succ-preserves-ge N2>=N1 N2+1>=N1+1.

- : leq-implies-size-le (leq/> M311<=M2 _) (size/+ N1=|M1|) (size/+ N2=|M2|)
                        (ge/> N2+1>N1+1)
    <- leq-implies-size-le M311<=M2 (size/+ N1=|M1|) N2=|M2| N2>=N1+1
    <- succ-implies-gt nat`eq/ N2+1>N2
    <- gt-transitive-ge N2+1>N2 N2>=N1+1 N2+1>N1+1.

%worlds () (leq-implies-size-le _ _ _ _).
%total (L) (leq-implies-size-le L _ _ _).


%theorem leq-implies-bound-le:
	forall* {M1} {M2} {N1} {N2}
	forall {L:leq M1 M2} {BD1:bound M1 N1} {BD2:bound M2 N2}
	exists {G:ge N2 N1}
	true.

- : leq-implies-bound-le leq/0 bound/0 _ N2>=0
    <- plus-commutative plus/z N2+0=N2    
    <- plus-implies-ge N2+0=N2 N2>=0.

- : leq-implies-bound-le (leq/= M1<=M2 _ nat`eq/) 
                         (bound/+ N+1+N1=N3 DM1<N1) 
                         (bound/+ N+1+N2=N4 DM2<N2)
                         N4>=N3
    <- leq-implies-bound-le M1<=M2 DM1<N1 DM2<N2 N2>=N1
    <- plus-left-preserves-ge* N2>=N1 N+1+N2=N4 N+1+N1=N3 N4>=N3.

- : leq-implies-bound-le (leq/> M311<=M2 N3+1+N2=N1) 
                         (bound/+ N1+1+N10=N11 DM1<N10) 
                         (bound/+ N2+1+N20=N22 DM2<N20)
                         N22>=N11
    <- plus-total N3+1+N10=N13
    <- leq-implies-bound-le M311<=M2 (bound/+ N3+1+N10=N13 DM1<N10) DM2<N20
                            N20>=N13 
    <- plus-swap-succ N1+1+N10=N11 N1+N10+1=N11
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- plus-swap-succ N3+1+N10=N13 N3+N10+1=N13
    <- plus-associative* N2+1+N3=N1 N1+N10+1=N11 N3+N10+1=N13 N2+1+N13=N11
    <- plus-left-preserves-ge* N20>=N13 N2+1+N20=N22 N2+1+N13=N11 N22>=N11.

%worlds () (leq-implies-bound-le _ _ _ _).
%total (L) (leq-implies-bound-le L _ _ _).


%theorem shift-left-preserves-leq*:
	forall* {M1} {M2} {N} {SM1} {D}
	forall {L:leq M1 M2}
	       {S1:shift N M1 SM1}
	exists {SL:leq SM1 (map/+ N D M2)}
	true.

- : shift-left-preserves-leq* _ shift/0 leq/0.

- : shift-left-preserves-leq* M111<=M2 (shift/+ N+1+N1=N1P) 
                              (leq/> M111<=M2 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-leq* _ _ _).
%total { } (shift-left-preserves-leq* _ _ _).


%theorem shift-preserves-leq*:
	forall* {M1} {M2} {N} {SM1} {SM2} 
	forall {L:leq M1 M2}
               {S1:shift N M1 SM1}
	       {S1:shift N M2 SM2}
	exists {SL:leq SM1 SM2}
	true.

- : shift-preserves-leq* _ shift/0 _ leq/0.

- : shift-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                         (shift/+ N+1+N1=N1P) 
                         (shift/+ N+1+N1=N2P)
                         (leq/= M1<=M2 D1<=D2 N1P=N2P)
    <- plus-deterministic N+1+N1=N1P N+1+N1=N2P nat`eq/ nat`eq/ N1P=N2P.

- : shift-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                         (shift/+ N+1+N1=N1P) 
                         (shift/+ N+1+N2=N2P)
                         (leq/> M311<=M2 N3+1+N2P=N1P)
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N1P N+1+N2=N2P N2P+N3+1=N1P
    <- plus-commutative N2P+N3+1=N1P N3+1+N2P=N1P.

%worlds () (shift-preserves-leq* _ _ _ _).
%total { } (shift-preserves-leq* _ _ _ _).

%abbrev shift-preserves-leq = shift-preserves-leq*.

%theorem shift-preserves-leq-converse:
	forall* {M1} {M2} {N} {SM1} {SM2} 
	forall {L:leq SM1 SM2}
               {S1:shift N M1 SM1}
	       {S1:shift N M2 SM2}
	exists {SL:leq M1 M2}
	true.

- : shift-preserves-leq-converse _ shift/0 _ leq/0.

- : shift-preserves-leq-converse (leq/= M1<=M2 D1<=D2 nat`eq/)
     				 (shift/+ N+1+N1P=N1) 
                         	 (shift/+ N+1+N2P=N1)
                         	 (leq/= M1<=M2 D1<=D2 N1P=N2P)
    <- plus-left-cancels N+1+N1P=N1 N+1+N2P=N1 nat`eq/ nat`eq/ N1P=N2P.

- : shift-preserves-leq-converse (leq/> M311<=M2 N3+1+N2P=N1P)
                         	 (shift/+ N+1+N1=N1P) 
                        	 (shift/+ N+1+N2=N2P)
                        	 (leq/> M311<=M2 N3+1+N2=N1)
    <- plus-commutative N3+1+N2P=N1P N2P+N3+1=N1P
    <- plus-associative N+1+N2=N2P N2P+N3+1=N1P M1 N2+N3+1=M1 N+1+M1=N1P
    <- plus-left-cancels N+1+M1=N1P N+1+N1=N1P nat`eq/ nat`eq/ M1=N1
    <- plus-respects-eq N2+N3+1=M1 nat`eq/ nat`eq/ M1=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1.

%worlds () (shift-preserves-leq-converse _ _ _ _).
%total { } (shift-preserves-leq-converse _ _ _ _).


%theorem disjoint-respects-geq* :
	forall* {M1} {M2} {M1P}
	forall {A:disjoint M1 M2} {E1:leq M1P M1}
	exists {AP:disjoint M1P M2}
	true.

- : disjoint-respects-geq* _ leq/0 disjoint/L.
	
- : disjoint-respects-geq* disjoint/R _ disjoint/R.

- : disjoint-respects-geq* 
	(disjoint/< D1 P) (leq/= L _ nat`eq/)
	(disjoint/< D1P P)
    <- disjoint-respects-geq* D1 L D1P.

- : disjoint-respects-geq*
	(disjoint/> D1 P) (leq/= L DL nat`eq/)
	(disjoint/> D1P P)
    <- disjoint-respects-geq* D1 (leq/= L DL nat`eq/) D1P.

- : disjoint-respects-geq*
	(disjoint/< D1 P1) (leq/> L P2) DP
    <- disjoint-respects-geq* D1 L D1P
    <- plus-swap-succ P1 P1S
    <- plus-swap-succ P2 P2S
    <- plus-commutative P1S P1SC
    <- plus-commutative P2S P2SC
    <- shift-preserves-disjoint D1P (shift/+ P2SC) (shift/+ P1SC) DP.

- : disjoint-respects-geq*
	(disjoint/> D1 N0+1+N1=N2) (leq/> L N3+1+N2=N4) DP
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N3+1+N2=N4 N5 N3+1+N0=N5 N5+N1+1=N4
    <- disjoint-respects-geq* D1 (leq/> L N3+1+N0=N5) D1P
    <- plus-commutative N5+N1+1=N4 N1+1+N5=N4
    <- shift-left-preserves-disjoint D1P (shift/+ N1+1+N5=N4) DP.

%worlds () (disjoint-respects-geq* _ _ _).
%total (D) (disjoint-respects-geq* D _ _).


%theorem disjoint-respects-geq :
	forall* {M1} {M2} {M1P} {M2P}
	forall {A:disjoint M1 M2} {E1:leq M1P M1} {E2:leq M2P M2} 
	exists {AP:disjoint M1P M2P}
	true.

- : disjoint-respects-geq M1^M2 M1P<=M1 M2P<=M2 M1P^M2P
    <- disjoint-respects-geq* M1^M2 M1P<=M1 M1P^M2
    <- disjoint-symmetric M1P^M2 M2^M1P
    <- disjoint-respects-geq* M2^M1P M2P<=M2 M2P^M1P
    <- disjoint-symmetric M2P^M1P M1P^M2P.

%worlds () (disjoint-respects-geq _ _ _ _).
%total { } (disjoint-respects-geq _ _ _ _).


%theorem disjoint-leq-implies-empty :
        forall* {M1} {M2}
        forall  {D: disjoint M1 M2}
                {L: leq M1 M2}
        exists  {E: eq map/0 M1}
        true.


- : disjoint-leq-implies-empty D L E
    <- leq-reflexive _ M<=M
    <- disjoint-respects-geq D M<=M L DD
    <- disjoint-anti-reflexive DD E.

%worlds () (disjoint-leq-implies-empty _ _ _).
%total { } (disjoint-leq-implies-empty _ _ _).


%theorem update-left-preserves-leq*:
	forall* {M1} {M2} {N} {D} {M1P} {M2P}
	forall {L:leq M1 M2} 
               {U1:update M1 N D M1P}
	       {U2:update M2 N D M2P}
	exists {LP:leq M1P M2P}
	true.

- : update-left-preserves-leq* leq/0 update/0 update/0 (leq/= leq/0 D<=D nat`eq/)
    <- canonical`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/= nat`eq/) 
                          (leq/= leq/0 D<=D nat`eq/)
    <- canonical`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/< _)
                          (leq/= leq/0 D<=D nat`eq/)
    <- canonical`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/> U2505 N5+1+N2=N)
                          (leq/> M500<=M5 N5+1+N2=N)
    <- update-left-preserves-leq* leq/0 update/0 U2505 M500<=M5.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/= nat`eq/) 
                          (U2:update (map/+ N D2 M2) N D M)
                          M001<=M
    <- update/=-inversion U2 nat`eq/ M002=M
    <- canonical`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= M1<=M2 D<=D nat`eq/) eq/ M002=M M001<=M.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/< N3+1+N=N1)
                          (U2:update (map/+ N1 D2 M2) N D M)
                          M00M311<=M
    <- update/<-inversion U2 N3+1+N=N1 M00M322=M
    <- canonical`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= (leq/= M1<=M2 D1<=D2 nat`eq/) D<=D nat`eq/) eq/ 
                       M00M322=M M00M311<=M.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/> U1303 N3+1+N1=N)
                          (U2:update (map/+ N1 D2 M2) N D M)
                          M113<=M
    <- update/>-inversion U2 N3+1+N1=N M4 U2304 M124=M
    <- update-left-preserves-leq* M1<=M2 U1303 U2304 M3<=M4
    <- leq-respects-eq (leq/= M3<=M4 D1<=D2 nat`eq/) eq/ M124=M M113<=M.

- : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                          (update/= nat`eq/)
			  (U2:update (map/+ N2 D2 M2) N1 D M)
                          M101<=M
    <- update/>-inversion U2 N3+1+N2=N1 M4 U2304 M224=M
    <- update-left-preserves-leq* M311<=M2 (update/= nat`eq/) U2304 M301<=M4
    <- leq-respects-eq (leq/> M301<=M4 N3+1+N2=N1) eq/ M224=M M101<=M.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N=N1)
                           (update/< N4+1+N=N1)   
                           (update/= nat`eq/) %% hence N=N2
                           (leq/= M411<=M2 D<=D nat`eq/)
     <- nat`plus-right-cancels N3+1+N=N1 N4+1+N=N1 nat`eq/ nat`eq/ N3+1=N4+1
     <- nat`succ-cancels N3+1=N4+1 N3=N4
     <- map/+-preserves-eq N3=N4 canonical`eq/ eq/ M311=M411
     <- leq-respects-eq M311<=M2 M311=M411 eq/ M411<=M2
     <- canonical`leq-reflexive _ D<=D.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                           (update/< N4+1+N=N1)
                           (update/< N5+1+N=N2)
                           (leq/= (leq/> M311<=M2 N3+1+N5=N4) D<=D nat`eq/)
     <- nat`plus-swap-succ N5+1+N=N2 N5+N+1=N2
     <- nat`plus-associative-converse N5+N+1=N2 N3+1+N2=N1 
                                      N4P N3+1+N5=N4P N4P+N+1=N1
     <- nat`plus-swap-succ N4+1+N=N1 N4+N+1=N1
     <- nat`plus-right-cancels N4P+N+1=N1 N4+N+1=N1 nat`eq/ nat`eq/ N4P=N4
     <- nat`plus-respects-eq N3+1+N5=N4P nat`eq/ nat`eq/ N4P=N4 N3+1+N5=N4
     <- canonical`leq-reflexive _ D<=D.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                           (update/< N4+1+N=N1)   
                           (update/> U2505 N5+1+N2=N)
                           (leq/> M50M411<=M5 N5+1+N2=N)
     <- nat`plus-swap-succ N5+1+N2=N N5+N2+1=N
     <- nat`plus-associative-converse N5+N2+1=N N4+1+N=N1
                                      N3P N4+1+N5=N3P N3P+N2+1=N1
     <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
     <- nat`plus-right-cancels N3P+N2+1=N1 N3+N2+1=N1 nat`eq/ nat`eq/ N3P=N3
     <- nat`plus-respects-eq N4+1+N5=N3P nat`eq/ nat`eq/ N3P=N3 N4+1+N5=N3
     <- update-left-preserves-leq* M311<=M2 (update/< N4+1+N5=N3) U2505 
                              M50M411<=M5.

- : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                          (update/> U1404 N4+1+N1=N)
                          (U2:update (map/+ N2 D2 M2) N D M)
                          M114<=M
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- nat`plus-associative-converse N3+N2+1=N1 N4+1+N1=N 
                                     N5 N4+1+N3=N5 N5+N2+1=N
    <- nat`plus-swap-succ-converse N5+N2+1=N N5+1+N2=N
    <- update/>-inversion U2 N5+1+N2=N M5 U2505 M225=M
    <- update-left-preserves-leq* M311<=M2 (update/> U1404 N4+1+N3=N5) U2505
                             M314<=M5
    <- leq-respects-eq (leq/> M314<=M5 N3+1+N2=N1) eq/ M225=M M114<=M.

%worlds () (update-left-preserves-leq* _ _ _ _).
%total (U) (update-left-preserves-leq* _ _ U _).


%theorem update-right-preserves-leq*:
	forall* {M} {N} {D1} {D2} {M1P} {M2P}
	forall {L:canonical`leq D1 D2} 
               {U1:update M N D1 M1P}
	       {U2:update M N D2 M2P}
	exists {LP:leq M1P M2P}
	true.

- : update-right-preserves-leq* D1<=D2 update/0 update/0 
                                (leq/= leq/0 D1<=D2 nat`eq/).

- : update-right-preserves-leq* D1<=D2 (update/= nat`eq/) U2 L
    <- update/=-inversion U2 nat`eq/ M221=M2P
    <- leq-reflexive _ M1<=M1
    <- leq-respects-eq (leq/= M1<=M1 D1<=D2 nat`eq/) eq/ M221=M2P L.

- : update-right-preserves-leq* D1<=D2 (update/< P) U2 L
    <- update/<-inversion U2 P M22311=M2P
    <- leq-reflexive _ M311<=M311
    <- leq-respects-eq (leq/= M311<=M311 D1<=D2 nat`eq/) eq/ M22311=M2P L.

- : update-right-preserves-leq* D1<=D2 (update/> U1 P) U22 L
    <- update/>-inversion U22 P M2P U2 M112=M
    <- update-right-preserves-leq* D1<=D2 U1 U2 M1P<=M2P
    <- canonical`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= M1P<=M2P D<=D nat`eq/) eq/ M112=M L.

%worlds () (update-right-preserves-leq* _ _ _ _).
%total (U) (update-right-preserves-leq* _ U _ _).


%theorem update-preserves-leq* :
	forall* {M1} {M2} {N} {D1} {D2} {M1P} {M2P}
	forall {L:leq M1 M2} {L:canonical`leq D1 D2} 
               {U1:update M1 N D1 M1P}
	       {U2:update M2 N D2 M2P}
	exists {LP:leq M1P M2P}
	true.

- : update-preserves-leq* M1<=M2 D1<=D2 M1^N=D1->M1P M2^N=D2->M2P M1P<=M2P
    <- update-total M2^N=D1->MM
    <- update-left-preserves-leq* M1<=M2 M1^N=D1->M1P M2^N=D1->MM M1P<=MM
    <- update-right-preserves-leq* D1<=D2 M2^N=D1->MM M2^N=D2->M2P MM<=M2P
    <- leq-transitive M1P<=MM MM<=M2P M1P<=M2P.

%worlds () (update-preserves-leq* _ _ _ _ _).
%total { } (update-preserves-leq* _ _ _ _ _).


%theorem fresh-update-preserves-leq-converse :
	forall* {M1} {M2} {N} {D1} {D2} {M1P} {M2P}
	forall	{LP:leq M1P M2P}
		{F1:fresh M1 N}
        	{U1:update M1 N D1 M1P}
		{F2:fresh M2 N}
		{U2:update M2 N D2 M2P}
	exists	{L:leq M1 M2} 
		{L:canonical`leq D1 D2} 
	true.

- : fresh-update-preserves-leq-converse
	_ _ _ FR (update/= nat`eq/) L DL
    <- fresh-contradiction FR F
    <- false-implies-leq F L
    <- canonical`false-implies-leq F DL.

- : fresh-update-preserves-leq-converse 
	M1P<=M2P fresh/0 update/0 _ U2 leq/0 D1<=D2
    <- update-implies-lookup U2 L2
    <- lookup-respects-leq* (lookup/= nat`eq/) M1P<=M2P L2 D1<=D2.

- : fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/< GT1) U1 (fresh/< GT2) U2 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U1 P1 EQ1
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1P<=M2Px
    <- leq/=-inversion M1P<=M2Px nat`eq/ D1<=D2 M1s<=M2s
    <- plus-swap-succ P1 P1s
    <- plus-swap-succ P2 P2s
    <- plus-commutative P1s P1sc
    <- plus-commutative P2s P2sc
    <- shift-preserves-leq* M1s<=M2s (shift/+ P1sc) (shift/+ P2sc) M1<=M2.

- : fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/< GT1) U1 fresh/0 update/0 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- eq-symmetric EQ1 EQ1s
    <- leq-respects-eq M1P<=M2P EQ1s eq/ M1Px<=M2P
    <- leq/=-inversion M1Px<=M2P nat`eq/ D1<=D2 M1s<=M2s
    <- leq-contradiction M1s<=M2s F
    <- false-implies-leq F M1<=M2.

- : fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/< GT1) U1 (fresh/> F2R P2) U2 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- update/>-inversion U2 P2 _ U2R EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1P<=M2Px
    <- leq/>-inversion M1P<=M2Px P2 M1PR<=M2PR
    <- plus-swap-succ P2 P2s
    <- plus-associative-converse P2s P1 _ P1R P2Rc
    <- plus-commutative P2Rc P2R
    <- plus-implies-gt P1R nat`eq/ GT1R
    <- fresh-update-preserves-leq-converse
	M1PR<=M2PR (fresh/< GT1R) (update/< P1R) F2R U2R M1R<=M2R D1<=D2
    <- shift-left-preserves-leq* M1R<=M2R (shift/+ P2R) M1<=M2.

%theorem fresh-update-preserves-leq-converse/> :
	forall*	{N1} {X1} {M1} {C1} {R1} {D1} {N}
		{N2} {X2} {M2} {C2} {R2} {D2} {CC}
	forall	{LP: leq (map/+ N1 X1 M1) (map/+ N2 X2 M2)}
		{P1: plus (s C1) N1 N}
		{F1: fresh R1 C1}
		{U1: update R1 C1 D1 M1}
		{P2: plus (s C2) N2 N}
		{F2: fresh R2 C2}
		{U2: update R2 C2 D2 M2}
		{C12: nat`compare C1 C2 CC}
	exists	{L: leq (map/+ N1 X1 R1) (map/+ N2 X2 R2)}
		{DL: canonical`leq D1 D2}
	true.

- : fresh-update-preserves-leq-converse/> 
	LP P1 F1 U1 P2 F2 U2 nat`compare/= 
	(leq/= LR XL N1=N2) DL
    <- plus-left-cancels P1 P2 nat`eq/ nat`eq/ N1=N2
    <- leq/=-inversion LP N1=N2 XL LRP
    <- fresh-update-preserves-leq-converse LRP F1 U1 F2 U2 LR DL.

- : fresh-update-preserves-leq-converse/>
	LP C1+1+N1=N F1 U1 C2+1+N2=N F2 U2 (nat`compare/< C2>C1)
	(leq/> LR D+1+N2=N1) DL
    <- gt-implies-plus C2>C1 D D+1+C1=C2
    <- plus-swap-succ C2+1+N2=N C2+N2+1=N
    <- plus-swap-succ D+1+C1=C2 D+C1+1=C2
    <- plus-commutative D+C1+1=C2 C1+1+D=C2
    <- plus-associative C1+1+D=C2 C2+N2+1=N X D+N2+1=X C1+1+X=N
    <- plus-left-cancels C1+1+X=N C1+1+N1=N nat`eq/ nat`eq/ X=N1
    <- plus-swap-succ-converse D+N2+1=X D+1+N2=X
    <- plus-respects-eq D+1+N2=X nat`eq/ nat`eq/ X=N1 D+1+N2=N1
    <- leq/>-inversion LP D+1+N2=N1 LRP
    <- fresh-update-preserves-leq-converse 
	LRP (fresh/> F1 C1+1+D=C2) (update/> U1 C1+1+D=C2) F2 U2 LR DL.

- : fresh-update-preserves-leq-converse/>
	LP P1 F1 U1 P2 F2 U2 (nat`compare/> C1>C2) L DL
    <- succ-preserves-gt C1>C2 SC1>SC2
    <- plus-left-reverses-gt P1 P2 SC1>SC2 nat`eq/ N2>N1
    <- gt-implies-plus N2>N1 _ P
    <- leq/<-contradiction LP P F
    <- false-implies-leq F L
    <- canonical`false-implies-leq F DL.

- : {U1R: update R1 C1 D1 M1} fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/> F1R P1) U1 (fresh/> F2R P2) U2 M1<=M2 D1<=D2
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- update/>-inversion U2 P2 _ U2R EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1PR<=M2PR
    <- nat`compare-total C
    <- fresh-update-preserves-leq-converse/>
	M1PR<=M2PR P1 F1R U1R P2 F2R U2R C M1<=M2 D1<=D2.

- : fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/> F1R P1) U1 fresh/0 update/0 L DL
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- eq-symmetric EQ1 EQ1s
    <- leq-respects-eq M1P<=M2P EQ1s eq/ M1Px<=M2P
    <- leq/<-contradiction M1Px<=M2P P1 F
    <- false-implies-leq F L
    <- canonical`false-implies-leq F DL.

- : fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/> F1R P1) U1 (fresh/< GT2) U2 L DL
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1PR<=M2PR
    <- leq/<-contradiction M1PR<=M2PR P1 F
    <- false-implies-leq F L
    <- canonical`false-implies-leq F DL.

%worlds () (fresh-update-preserves-leq-converse _ _ _ _ _ _ _)
                 (fresh-update-preserves-leq-converse/> _ _ _ _ _ _ _ _ _ _).
%total (F2a F2b)
 	(fresh-update-preserves-leq-converse _ F1a _ F2a _ _ _)
        (fresh-update-preserves-leq-converse/> _ _ F1b _ _ F2b _ _ _ _).


%theorem fresh-update2-preserves-leq-converse :
	forall* {M1} {M2} {N} {D2} {M2P}
	forall	{LP:leq M1 M2P}
		{F1:fresh M1 N}
		{F2:fresh M2 N}
		{U2:update M2 N D2 M2P}
	exists	{L:leq M1 M2} 
	true.

- : fresh-update2-preserves-leq-converse M1<=M2P F1 F2 U2 M1<=M2
    <- update-total U1
    <- update-implies-lookup U2 L2
    <- lookup-implies-update L2 U2U
    <- update-left-preserves-leq* M1<=M2P U1 U2U M1P<=M2P
    <- fresh-update-preserves-leq-converse M1P<=M2P F1 U1 F2 U2 M1<=M2 _.

%worlds () (fresh-update2-preserves-leq-converse _ _ _ _ _).
%total { } (fresh-update2-preserves-leq-converse _ _ _ _ _).


%theorem fresh-update-implies-leq :
	forall* {M1} {N} {D} {M2}
	forall {F:fresh M1 N} {U:update M1 N D M2}
	exists {L:leq M1 M2}
	true.

- : fresh-update-implies-leq fresh/0 U leq/0.

- : fresh-update-implies-leq (fresh/< N2<N1) U L
    <- gt-implies-plus N2<N1 _ N3+1+N2=N1
    <- update/<-inversion U N3+1+N2=N1 M22311=M2
    <- leq-reflexive _ M311<=M311
    <- leq-respects-eq (leq/> M311<=M311 N3+1+N2=N1) eq/ M22311=M2 L.

- : fresh-update-implies-leq (fresh/> F1 N0+1+N1=N2) U L
    <- update/>-inversion U N0+1+N1=N2 _ U1 M112=M
    <- fresh-update-implies-leq F1 U1 L1
    <- canonical`leq-reflexive _ DL
    <- leq-respects-eq (leq/= L1 DL nat`eq/) eq/ M112=M L.

%worlds () (fresh-update-implies-leq _ _ _).
%total (F) (fresh-update-implies-leq F _ _).


%theorem lookup-update-preserves-leq :
	forall* {M1} {N} {D1} {D2} {M2}
	forall {L:lookup M1 N D1} {U:update M1 N D2 M2}
               {L:canonical`leq D1 D2}
	exists {L:leq M1 M2}
	true.

- : lookup-update-preserves-leq (lookup/= nat`eq/) U D1<=D2 L
    <- update/=-inversion U nat`eq/ M221=M2
    <- leq-reflexive _ M1<=M1
    <- leq-respects-eq (leq/= M1<=M1 D1<=D2 nat`eq/) eq/ M221=M2 L.

- : lookup-update-preserves-leq (lookup/> L1 N0+1+N1=N2) U D1<=D2 L
    <- update/>-inversion U N0+1+N1=N2 M2 U1 M112=M
    <- lookup-update-preserves-leq L1 U1 D1<=D2 L1P
    <- canonical`leq-reflexive _ D1<=D1
    <- leq-respects-eq (leq/= L1P D1<=D1 nat`eq/) eq/ M112=M L.

%worlds () (lookup-update-preserves-leq _ _ _ _).
%total (L) (lookup-update-preserves-leq L _ _ _).



%%% Theorems about nle


%theorem nle-anti-reflexive :
	forall* {M}
	forall {N:nle M M}
	exists {F:void}
	true.

- : nle-anti-reflexive (nle/< L F) FALSE
    <- fresh-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N FALSE.


%worlds () (nle-anti-reflexive _ _).
%total { } (nle-anti-reflexive _ _).


%theorem nle-implies-ne :
	forall* {M1} {M2}
	forall {N1:nle M1 M2}
	exists {N2:ne M1 M2}
	true.

- : nle-implies-ne (nle/< L F) (ne/< L F).


%worlds () (nle-implies-ne _ _).
%total (N) (nle-implies-ne N _).


%theorem leq-nle-contradiction :
	forall* {M1} {M2}
	forall {L:leq M1 M2} {N1:nle M1 M2}
	exists {F:void}
	true.

- : leq-nle-contradiction M1<=M2 (nle/< L1 F2) FALSE
    <- lookup-respects-leq L1 M1<=M2 _ L2 _
    <- fresh-lookup-not-equal F2 L2 N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N FALSE.


%worlds () (leq-nle-contradiction _ _ _).
%total { } (leq-nle-contradiction _ _ _).





%%%% Map addition



%%% Definition of add


add : map -> map -> map -> type.


add/L : add map/0 M M.

add/R : add M map/0 M.

add/= : add (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N1 D3 M3)
    <- nat`eq N1 N2
    <- canonical`add D1 D2 D3
    <- add M1 M2 M3.

add/< : add (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N1 D1 M3)
    <- nat`plus (s N0) N1 N2
    <- add M1 (map/+ N0 D2 M2) M3.

add/> : add (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N2 D2 M3)
    <- nat`plus (s N3) N2 N1
    <- add (map/+ N3 D1 M1) M2 M3.



%%% Theorems about add


%theorem false-implies-add :
	forall* {M1} {M2} {M3}
	forall {F:void}
	exists {D:add M1 M2 M3}
	true.

%worlds () (false-implies-add _ _).
%total {} (false-implies-add _ _).


%theorem add-respects-eq :
	forall* {M1} {M2} {M3} {M1P} {M2P} {M3P}
	forall {A:add M1 M2 M3} {E1:eq M1 M1P} {E2:eq M2 M2P} {E3:eq M3 M3P}
	exists {AP:add M1P M2P M3P}
	true.

- : add-respects-eq A eq/ eq/ eq/ A.

%worlds () (add-respects-eq _ _ _ _ _).
%total {} (add-respects-eq _ _ _ _ _).
%reduces A = AP (add-respects-eq A _ _ _ AP).


%% A way to get a add fact.

%theorem can-construct-unit-add:
	forall*	{N} {D} {M1} {M}
	forall	{S: shift N M1 M}
	exists	{A: add M (map/+ N D map/0) (map/+ N D M1)}
	true.

- : can-construct-unit-add shift/0 add/L.

- : can-construct-unit-add (shift/+ P) (add/> add/R PPP)
    <- plus-swap-succ P PP
    <- plus-commutative PP PPP.

%worlds () (can-construct-unit-add _ _).
%total { } (can-construct-unit-add _ _).


%% Inversion lemmas for add

%theorem add/=-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {M} 
	forall {A:add (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
	       {G:nat`eq N1 N2}
	exists {D3} {M3} 
	       {D:canonical`add D1 D2 D3}
               {AP:add M1 M2 M3}
               {E:eq M (map/+ N1 D3 M3)}
	true.

- : add/=-inversion (add/= MM DD nat`eq/) _ _ _ DD MM eq/.

- : add/=-inversion (add/< (JP:add _ (map/+ N0 D2 M2) M3) N0+1+N=N) nat`eq/ 
                     D2 M3 DJ MJ ME
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- canonical`false-implies-add F DJ
    <- false-implies-eq F (M022=M2:eq (map/+ N0 D2 M2) M2)
    <- add-respects-eq JP eq/ M022=M2 eq/ MJ
    <- false-implies-eq F ME.

- : add/=-inversion (add/> (JP:add (map/+ _ D1 M1) M2 M3) N3+1+N=N) nat`eq/
                     D1 M3 DJ MJ ME
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- canonical`false-implies-add F DJ
    <- false-implies-eq F (M311=M1:eq (map/+ N3 D1 M1) M1)
    <- add-respects-eq JP M311=M1 eq/ eq/ MJ
    <- false-implies-eq F ME.

%worlds () (add/=-inversion _ _ _ _ _ _ _).
%total {} (add/=-inversion _ _ _ _ _ _ _).
%reduces JP < J (add/=-inversion J _ _ _ _ JP _).


%theorem add/<-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {M} {N0}
	forall {A:add (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
               {P:plus (s N0) N1 N2} 	       
	exists {M3} 
               {AP:add M1 (map/+ N0 D2 M2) M3}
               {E:eq M (map/+ N1 D1 M3)}
	true.

- : add/<-inversion (add/< J P) PP _ JP eq/
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P canonical`eq/ eq/ M022=M022P
    <- add-respects-eq J eq/ M022=M022P eq/ JP.

- : add/<-inversion (add/= JP _ nat`eq/) N0+1+N=N M3 J E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M2=M022
    <- add-respects-eq JP eq/ M2=M022 eq/ J
    <- false-implies-eq F E.

- : add/<-inversion (add/> JP N3+1+N2=N1) N0+1+N1=N2 M3 J E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M311=M1
    <- false-implies-eq F M2=M022
    <- add-respects-eq JP M311=M1 M2=M022 eq/ J
    <- false-implies-eq F E.

%worlds () (add/<-inversion _ _ _ _ _).
%total {}  (add/<-inversion _ _ _ _ _).
%reduces JP < J (add/<-inversion J _ _ JP _).


%theorem add/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {M} 
	forall {A:add (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
	       {P:plus (s N3) N2 N1}
	exists {M3} 
               {AP:add (map/+ N3 D1 M1) M2 M3}
               {E:eq M (map/+ N2 D2 M3)}
	true.

- : add/>-inversion (add/> J P) PP _ JP eq/
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P canonical`eq/ eq/ M311=M311P
    <- add-respects-eq J M311=M311P eq/ eq/ JP.

- : add/>-inversion (add/= JP _ nat`eq/) N3+1+N=N M3 J E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M1=M311
    <- add-respects-eq JP M1=M311 eq/ eq/ J
    <- false-implies-eq F E.

- : add/>-inversion (add/< JP N0+1+N1=N2) N3+1+N2=N1 M3 J E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M1=M311
    <- false-implies-eq F M022=M2
    <- add-respects-eq JP M1=M311 M022=M2 eq/ J
    <- false-implies-eq F E.

%worlds () (add/>-inversion _ _ _ _ _).
%total {} (add/>-inversion _ _ _ _ _).
%reduces JP < J (add/>-inversion J _ _ JP _).


%theorem add-deterministic :
	forall* {M1} {M2} {M3} {M1P} {M2P} {M3P}
	forall {A:add M1 M2 M3} {AP:add M1P M2P M3P}
               {E1:eq M1 M1P} {E2:eq M2 M2P}
	exists {E3:eq M3 M3P}
	true.

%abbrev add-unique = add-deterministic.

- : add-deterministic add/L add/L eq/ eq/ eq/.

- : add-deterministic add/L add/R eq/ eq/ eq/.

- : add-deterministic add/R add/L eq/ eq/ eq/.

- : add-deterministic add/R add/R eq/ eq/ eq/.

- : add-deterministic (add/= M1+M2=M3 D1+D2=D3 nat`eq/)
                      (add/= M1+M2=M3P D1+D2=D3P nat`eq/) 
		      eq/ eq/ M=MP
    <- canonical`add-deterministic D1+D2=D3 D1+D2=D3P canonical`eq/ canonical`eq/ D3=D3P
    <- add-deterministic M1+M2=M3 M1+M2=M3P eq/ eq/ M3=M3P
    <- map/+-preserves-eq nat`eq/ D3=D3P M3=M3P M=MP.

- : add-deterministic (add/< M1+MT=M3 N0+1+N1=N2)
                      (add/< M1+MTP=M3P N0P+1+N1=N2)
		      eq/ eq/ M=MP
    <- plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P canonical`eq/ eq/ MT=MTP
    <- add-deterministic M1+MT=M3 M1+MTP=M3P eq/ MT=MTP M3=M3P
    <- map/+-preserves-eq nat`eq/ canonical`eq/ M3=M3P M=MP.

- : add-deterministic (add/> MT+M2=M3 N3+1+N2=N1)
                      (add/> MTP+M2=M3P N3P+1+N2=N1) eq/ eq/ E
    <- plus-right-cancels N3+1+N2=N1 N3P+1+N2=N1 nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P canonical`eq/ eq/ MT=MTP
    <- add-deterministic MT+M2=M3 MTP+M2=M3P MT=MTP eq/ M3=M3P
    <- map/+-preserves-eq nat`eq/ canonical`eq/ M3=M3P E.

%% contradiction cases:

- : add-deterministic (add/= _ _ nat`eq/) (add/< _ NP+1+N=N) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : add-deterministic (add/= _ _ nat`eq/) (add/> _ NP+1+N=N) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : add-deterministic (add/< _ NP+1+N=N) (add/= _ _ nat`eq/) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : add-deterministic (add/< _ N0+1+N1=N2) (add/> _ N3+1+N2=N1) eq/ eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

- : add-deterministic (add/> _ NP+1+N=N) (add/= _ _ nat`eq/) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : add-deterministic (add/> _ N3+1+N2=N1) (add/< _ N0+1+N1=N2) eq/ eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (add-deterministic _ _ _ _ _).
%total (A) (add-deterministic A _ _ _ _).




%theorem add-total* :
	forall {M1} {M2}
	exists {M3} {A:add M1 M2 M3}
	true.

%% we need some lemmas
%% We need them to ensure termination because
%% add substitutes new maps on recursive calls which
%% makes it hard to prove the arguments get smaller.

%theorem add-map/+-M-total* :
	forall {N1} {D1} {M1} {M2}
        exists {M3} {A:add (map/+ N1 D1 M1) M2 M3}
	true.

%theorem add-M-map/+-total* :
	forall {M1} {N2} {D2} {M2}
        exists {M3} {A:add M1 (map/+ N2 D2 M2) M3}
	true.

%theorem add-map/+-map/+-total* :
	forall {N1} {D1} {M1} {N2} {D2} {M2} {C} {CMP:nat`compare N1 N2 C}
        exists {M3} 
               {A:add (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3}
	true.

- : add-total* map/0 M M add/L.

- : add-total* M map/0 M add/R.

- : add-total* (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3 A
    <- nat`compare-total* N1 N2 C CMP
    <- add-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.               

- : add-map/+-map/+-total* N1 D1 M1 N2 D2 M2 equal CMP (map/+ N1 D3 M3)
                           (add/= M1+M2=M3 D1+D2=D3 N1=N2)
    <- equal-implies-eq CMP N1=N2
    <- canonical`add-total* D1 D2 D3 D1+D2=D3
    <- add-total* M1 M2 M3 M1+M2=M3.

- : add-map/+-map/+-total* N1 D1 M1 N2 D2 M2 less CMP (map/+ N1 D1 M3)
                           (add/< M1+T=M3 N0+1+N1=N2)
    <- less-implies-lt CMP N2>N1
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- add-M-map/+-total* M1 N0 D2 M2 M3 M1+T=M3.

- : add-map/+-map/+-total* N1 D1 M1 N2 D2 M2 greater CMP (map/+ N2 D2 M3)
                           (add/> T+M2=M3 N3+1+N2=N1)
    <- greater-implies-gt CMP N1>N2
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- add-map/+-M-total* N3 D1 M1 M2 M3 T+M2=M3.

- : add-M-map/+-total* map/0 N2 D2 M2 (map/+ N2 D2 M2) add/L.

- : add-M-map/+-total* (map/+ N1 D1 M1) N2 D2 M2 M3 A
    <- nat`compare-total* N1 N2 C CMP
    <- add-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.

- : add-map/+-M-total* N1 D1 M1 map/0 (map/+ N1 D1 M1) add/R.

- : add-map/+-M-total* N1 D1 M1 (map/+ N2 D2 M2) M3 A
    <- nat`compare-total* N1 N2 C CMP
    <- add-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.

%worlds () (add-total* _ _ _ _)
           (add-M-map/+-total* _ _ _ _ _ _)
           (add-map/+-M-total* _ _ _ _ _ _)
           (add-map/+-map/+-total* _ _ _ _ _ _ _ _ _ _).

%total [ (M1a M1b M1c M1d) (M2a M2b M2c M2d) ]
        (add-total* M1d M2d _ _)
        (add-M-map/+-total* M1c _ _ M2c _ _)
        (add-map/+-M-total* _ _ M1b M2b _ _)
	(add-map/+-map/+-total* _ _ M1a _ _ M2a _ _ _ _).
               
%abbrev add-total = add-total* _ _ _.


%theorem disjoint-add-total :
	forall* {M1} {M2} 
	forall {D:disjoint M1 M2}
	exists {M3} {A:add M1 M2 M3}
	true.

- : disjoint-add-total disjoint/L _ add/L. 

- : disjoint-add-total disjoint/R _ add/R.

- : disjoint-add-total (disjoint/< D P) _ (add/< J P)
    <- disjoint-add-total D _ J.

- : disjoint-add-total (disjoint/> D P) _ (add/> J P)
    <- disjoint-add-total D _ J.

%worlds () (disjoint-add-total _ _ _).
%total (D) (disjoint-add-total D _ _).


%theorem disjoint-add-commutative :
        forall* {M1} {M2} {M3}
        forall  {D: disjoint M1 M2}
                {J: add M1 M2 M3}
        exists  {J: add M2 M1 M3}
        true.

- : disjoint-add-commutative _ add/L add/R.

- : disjoint-add-commutative _ add/R add/L.

- : disjoint-add-commutative D (add/= _ _ nat`eq/) J
    <- disjoint/=-contradiction D nat`eq/ F
    <- false-implies-add F J.

- : disjoint-add-commutative D (add/< J1 P) (add/> J1P P)
    <- disjoint/<-inversion D P D1
    <- disjoint-add-commutative D1 J1 J1P.

- : disjoint-add-commutative D (add/> J1 P) (add/< J1P P)
    <- disjoint/>-inversion D P D1
    <- disjoint-add-commutative D1 J1 J1P.

%worlds () (disjoint-add-commutative _ _ _).
%total (J) (disjoint-add-commutative _ J _).


%theorem add-empty-implies-empty :
	forall* {M1} {M2}
	forall {A:add M1 M2 map/0}
	exists {E1:eq M1 map/0} {E2:eq M2 map/0}
	true.

- : add-empty-implies-empty add/L eq/ eq/.

- : add-empty-implies-empty add/R eq/ eq/.

%worlds () (add-empty-implies-empty _ _ _).
%total { } (add-empty-implies-empty _ _ _).


%theorem add-preserves-disjoint* :
	forall* {M1} {M2} {M3} {M4}
	forall {D1:disjoint M1 M4} {D2:disjoint M2 M4}
	       {A:add M1 M2 M3}
	exists {D3:disjoint M3 M4}
	true.

% a lemma that counts the size of maps to help prove termination
%theorem add-preserves-disjoint*/L :
	forall* {M1} {M2} {M3} {M4}
	forall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2}
               {D1:disjoint M1 M4} {D2:disjoint M2 M4}
	       {A:add M1 M2 M3}
	exists {D3:disjoint M3 M4}
	true.

- : add-preserves-disjoint* D1 D2 J D3
    <- size-total SZ1
    <- size-total SZ2
    <- add-preserves-disjoint*/L _ _ SZ1 SZ2 D1 D2 J D3.

- : add-preserves-disjoint*/L _ _ _ _ disjoint/R _ _ disjoint/R.

- : add-preserves-disjoint*/L _ _ _ _ _ disjoint/R _ disjoint/R.

- : add-preserves-disjoint*/L _ _ _ _ _ D add/L D.

- : add-preserves-disjoint*/L _ _ _ _ D _ add/R D.

- : add-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/< D1 N5+1+N1=N4) D2X 
                               (add/= J _ nat`eq/)
                               (disjoint/< D3 N5+1+N1=N4)
    <- disjoint/<-inversion D2X N5+1+N1=N4 D2
    <- add-preserves-disjoint*/L S1 S2 SZ1 SZ2 D1 D2 J D3.

- : add-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/< D1 N5+1+N1=N4) D2X
                               (add/> J N3+1+N2=N1)
                               (disjoint/< D3 N6+1+N2=N4)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N5+1+N1=N4 N6 N5+1+N3=N6 N6+N2+1=N4
    <- plus-swap-succ-converse N6+N2+1=N4 N6+1+N2=N4
    <- disjoint/<-inversion D2X N6+1+N2=N4 D2
    <- plus-swap-succ N5+1+N3=N6 N5+N3+1=N6
    <- plus-commutative N5+N3+1=N6 N3+1+N5=N6
    <- shift-right-preserves-disjoint D1 (shift/+ N3+1+N5=N6) D1<<N3
    <- add-preserves-disjoint*/L (s S1) S2 (size/+ SZ1) SZ2 D1<<N3 D2 J D3.

- : add-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/> D1 N5+1+N4=N1) D2X 
                               (add/= J DJ nat`eq/)
                               (disjoint/> D3 N5+1+N4=N1)
    <- disjoint/>-inversion D2X N5+1+N4=N1 D2
    <- add-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2) 
                                  D1 D2 (add/= J DJ nat`eq/) D3.

- : add-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/> D1 N5+1+N4=N1) D2X
                               (add/< J N0+1+N1=N2)
                               (disjoint/> D3 N5+1+N4=N1)
    <- plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 N6 N0+1+N5=N6 N6+N4+1=N2
    <- plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2
    <- disjoint/>-inversion D2X N6+1+N4=N2 D2
    <- add-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2) 
                                  D1 D2 (add/< J N0+1+N5=N6) D3.

- : add-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               D1X (disjoint/< D2 N6+1+N2=N4) 
                               (add/< J N0+1+N1=N2)
                               (disjoint/< D3 N5+1+N1=N4)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N6+1+N2=N4 N5 N6+1+N0=N5 N5+N1+1=N4
    <- plus-swap-succ-converse N5+N1+1=N4 N5+1+N1=N4
    <- disjoint/<-inversion D1X N5+1+N1=N4 D1
    <- plus-swap-succ N6+1+N0=N5 N6+N0+1=N5
    <- plus-commutative N6+N0+1=N5 N0+1+N6=N5
    <- shift-right-preserves-disjoint D2 (shift/+ N0+1+N6=N5) D2<<N0
    <- add-preserves-disjoint*/L S1 (s S2) SZ1 (size/+ SZ2) D1 D2<<N0 J D3.

- : add-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               D1X (disjoint/> D2 N6+1+N4=N2)
                               (add/> J N3+1+N2=N1)
                               (disjoint/> D3 N6+1+N4=N2)
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 N5 N3+1+N6=N5 N5+N4+1=N1
    <- plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1
    <- disjoint/>-inversion D1X N5+1+N4=N1 D1
    <- add-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2) 
                                  D1 D2 (add/> J N3+1+N6=N5) D3.

- : add-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/< D1 N5+1+N1=N4)
                               (disjoint/> D2 N6+1+N4=N2) JX D3X
    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 N0 N6+1+N5=N0 N0+N1+1=N2
    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2
    <- add/<-inversion JX N0+1+N1=N2 _ J M=M113
    <- eq-symmetric M=M113 M113=M
    <- add-preserves-disjoint*/L S1 (s S2) SZ1 (size/+ SZ2)
                                  D1 (disjoint/> D2 N6+1+N5=N0) J D3
    <- disjoint-respects-eq (disjoint/< D3 N5+1+N1=N4) M113=M eq/ D3X.

- : add-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/> D1 N5+1+N4=N1)
                               (disjoint/< D2 N6+1+N2=N4) JX D3X
    <- plus-swap-succ N6+1+N2=N4 N6+N2+1=N4
    <- plus-associative-converse N6+N2+1=N4 N5+1+N4=N1 N3 N5+1+N6=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- add/>-inversion JX N3+1+N2=N1 _ J M=M223
    <- eq-symmetric M=M223 M223=M
    <- add-preserves-disjoint*/L _ _ (size/+ SZ1) SZ2
                                  (disjoint/> D1 N5+1+N6=N3) D2 J D3
    <- disjoint-respects-eq (disjoint/< D3 N6+1+N2=N4) M223=M eq/ D3X.

%worlds () (add-preserves-disjoint*/L _ _ _ _ _ _ _ _).
%total {S1 S2 D1} (add-preserves-disjoint*/L S1 S2 _ _ D1 _ _ _).

%worlds () (add-preserves-disjoint* _ _ _ _).
%total { } (add-preserves-disjoint* _ _ _ _).


%abbrev add-left-preserves-disjoint* = add-preserves-disjoint*.

%theorem add-right-preserves-disjoint* :
	forall* {M1} {M2} {M3} {M0}
	forall {D1:disjoint M0 M1} {D2:disjoint M0 M2}
	       {A:add M1 M2 M3}
	exists {D3:disjoint M0 M3}
	true.

- : add-right-preserves-disjoint* D1 D2 U D3
    <- disjoint-symmetric D1 D1s
    <- disjoint-symmetric D2 D2s
    <- add-left-preserves-disjoint* D1s D2s U D3s
    <- disjoint-symmetric D3s D3.

%worlds () (add-right-preserves-disjoint* _ _ _ _).
%total { } (add-right-preserves-disjoint* _ _ _ _).


%theorem add-preserves-disjoint-converse:
	forall* {M1} {M2} {M3} {M4}
	forall {D3:disjoint M3 M4}
	       {A:add M1 M2 M3}
	exists {D1:disjoint M1 M4} {D2:disjoint M2 M4}
	true.

- : add-preserves-disjoint-converse
	D add/L disjoint/L D.

- : add-preserves-disjoint-converse
	D add/R D disjoint/L.

- : add-preserves-disjoint-converse
	disjoint/R _
	disjoint/R disjoint/R.

- : add-preserves-disjoint-converse
	(disjoint/< D P)
	(add/= J _ nat`eq/)
	(disjoint/< D1 P) (disjoint/< D2 P)
    <- add-preserves-disjoint-converse D J D1 D2.

- : add-preserves-disjoint-converse
        (disjoint/< D P1)
        (add/< J P2)
	(disjoint/< D1 P1) D2S
    <- add-preserves-disjoint-converse D J D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-disjoint D2 (shift/+ P2sc) (shift/+ P1sc) D2S.

- : add-preserves-disjoint-converse
        (disjoint/< D P1)
        (add/> J P2)
	D1S (disjoint/< D2 P1)
    <- add-preserves-disjoint-converse D J D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-disjoint D1 (shift/+ P2sc) (shift/+ P1sc) D1S.

- : add-preserves-disjoint-converse
	(disjoint/> D P1)
	(add/= J DE nat`eq/)
	D1S D2S
    <- add-preserves-disjoint-converse D (add/= J DE nat`eq/) D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- shift-left-preserves-disjoint D1 (shift/+ P1sc) D1S
    <- shift-left-preserves-disjoint D2 (shift/+ P1sc) D2S.

- : add-preserves-disjoint-converse
	(disjoint/> D P1)
	(add/< J P2)
        D1S D2S
    <- plus-swap-succ P1 P1s
    <- plus-associative-converse P1s P2 _ P3 P4s
    <- add-preserves-disjoint-converse D (add/< J P3) D1 D2
    <- plus-commutative P1s P1sc
    <- plus-commutative P4s P4sc
    <- shift-left-preserves-disjoint D1 (shift/+ P1sc) D1S
    <- shift-left-preserves-disjoint D2 (shift/+ P4sc) D2S.

- : add-preserves-disjoint-converse
	(disjoint/> D P1)
	(add/> J P2)
	D1S D2S
    <- plus-swap-succ P1 P1s
    <- plus-associative-converse P1s P2 _ P3 P4s
    <- add-preserves-disjoint-converse D (add/> J P3) D1 D2
    <- plus-commutative P1s P1sc
    <- plus-commutative P4s P4sc
    <- shift-left-preserves-disjoint D1 (shift/+ P4sc) D1S
    <- shift-left-preserves-disjoint D2 (shift/+ P1sc) D2S.

%worlds () (add-preserves-disjoint-converse _ _ _ _).
%total (D) (add-preserves-disjoint-converse D _ _ _).


%theorem disjoint-add-right-cancels :
        forall* {A1} {B1} {C1} {A2} {B2} {C2}
        forall  {D1: disjoint A1 B1}
                {J1: add A1 B1 C1}
                {D2: disjoint A2 B2}
                {J2: add A2 B2 C2}
                {EB: eq B1 B2}
                {EC: eq C1 C2}
        exists  {EA: eq A1 A2}
        true.

%theorem disjoint-add-right-cancels/L :
	forall*	{A} {B} {C}
	forall	{D: disjoint A B}
		{J: add A B C}
		{E: eq B C}
	exists	{E: eq map/0 A}
	true.

- : disjoint-add-right-cancels/L A^B A+B=B eq/ Z=A
    <- disjoint-symmetric A^B B^A
    <- add-preserves-disjoint-converse B^A A+B=B A^A _
    <- disjoint-anti-reflexive A^A Z=A.

%worlds () (disjoint-add-right-cancels/L _ _ _ _).
%total { } (disjoint-add-right-cancels/L _ _ _ _).

- : disjoint-add-right-cancels
        disjoint/L J1 A2^B J2 eq/ eq/ Z=A2
    <- add-deterministic J1 add/L eq/ eq/ C=B
    <- disjoint-add-right-cancels/L A2^B J2 C=B Z=A2.

- : disjoint-add-right-cancels
        A1^B J1 disjoint/L J2 eq/ eq/ A1=Z
    <- add-deterministic J2 add/L eq/ eq/ C=B
    <- disjoint-add-right-cancels/L A1^B J1 C=B Z=A1
    <- eq-symmetric Z=A1 A1=Z.

- : disjoint-add-right-cancels
        disjoint/R J1 _ J2 eq/ eq/ A1=A2
    <- add-deterministic J1 add/R eq/ eq/ A1=C
    <- add-deterministic add/R J2 eq/ eq/ C=A2
    <- eq-transitive A1=C C=A2 A1=A2.

- : disjoint-add-right-cancels
        (disjoint/< D1P P1) J1 (disjoint/< D2P P2) J2 
        eq/ eq/ A111=A222
    <- add/<-inversion J1 P1 _ J1P EQ1
    <- add/<-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C225
    <- map/+-preserves-eq-converse C114=C225 N1=N2 D1=D2 C4=C5
    <- plus-right-cancels P1 P2 N1=N2 nat`eq/ SN4=SN5
    <- succ-cancels SN4=SN5 N4=N5
    <- map/+-preserves-eq N4=N5 canonical`eq/ eq/ B4=B5
    <- disjoint-add-right-cancels D1P J1P D2P J2P B4=B5 C4=C5 A1=A2
    <- map/+-preserves-eq N1=N2 D1=D2 A1=A2 A111=A222.

- : disjoint-add-right-cancels
        (disjoint/< D1P P1) J1 (disjoint/> D2P P2) J2 
        eq/ eq/ EQ
    <- add/<-inversion J1 P1 _ J1P EQ1
    <- add/>-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C225
    <- map/+-preserves-eq-converse C114=C225 N1=N2 _ _
    <- plus-implies-gt P1 nat`eq/ N2>N1
    <- gt-respects-eq N2>N1 nat`eq/ N1=N2 N2>N2
    <- gt-anti-reflexive N2>N2 F
    <- false-implies-eq F EQ.

- : disjoint-add-right-cancels
        (disjoint/> D1P P1) J1 (disjoint/< D2P P2) J2 
        eq/ eq/ EQ
    <- add/>-inversion J1 P1 _ J1P EQ1
    <- add/<-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C225
    <- map/+-preserves-eq-converse C114=C225 N1=N2 _ _
    <- plus-implies-gt P2 nat`eq/ N1>N2
    <- gt-respects-eq N1>N2 N1=N2 nat`eq/ N2>N2
    <- gt-anti-reflexive N2>N2 F
    <- false-implies-eq F EQ.

- : disjoint-add-right-cancels
        (disjoint/> D1P P1) J1 (disjoint/> D2P P2) J2 
        eq/ eq/ A111=A222
    <- add/>-inversion J1 P1 _ J1P EQ1
    <- add/>-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C115
    <- map/+-preserves-eq-converse C114=C115 _ _ C4=C5
    <- disjoint-add-right-cancels D1P J1P D2P J2P eq/ C4=C5 A411=A511
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-deterministic 
        (shift/+ P1sc) (shift/+ P2sc) nat`eq/ A411=A511 A111=A222.

%worlds () (disjoint-add-right-cancels _ _ _ _ _ _ _).
%total (D) (disjoint-add-right-cancels D _ _ _ _ _ _).


%theorem disjoint-add-left-cancels :
        forall* {A1} {B1} {C1} {A2} {B2} {C2}
        forall  {D1: disjoint A1 B1}
                {J1: add A1 B1 C1}
                {D2: disjoint A2 B2}
                {J2: add A2 B2 C2}
                {EB: eq A1 A2}
                {EC: eq C1 C2}
        exists  {EA: eq B1 B2}
        true.

- : disjoint-add-left-cancels D1 J1 D2 J2 EB EC EA
    <- disjoint-add-commutative D1 J1 J1c
    <- disjoint-add-commutative D2 J2 J2c
    <- disjoint-symmetric D1 D1s
    <- disjoint-symmetric D2 D2s
    <- disjoint-add-right-cancels D1s J1c D2s J2c EB EC EA.

%worlds () (disjoint-add-left-cancels _ _ _ _ _ _ _).
%total { } (disjoint-add-left-cancels _ _ _ _ _ _ _).


%theorem shift-left-preserves-add :
	forall* {N} {D} {M1} {M2} {M3} {SM1}
	forall {A:add M1 M2 M3} {S1:shift N M1 SM1}
        exists {SA:add SM1 (map/+ N D M2) (map/+ N D M3)}
        true.

- : shift-left-preserves-add add/L shift/0 add/L.

- : shift-left-preserves-add add/R shift/0 add/L.

- : shift-left-preserves-add M111+M2=M3 (shift/+ N+1+N1=N1P)
                              (add/> M111+M2=M3 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-add _ _ _).
%total { } (shift-left-preserves-add _ _ _).


%theorem shift-left-preserves-add-converse :
	forall* {N} {D} {M1} {M2} {SM1} {SM3}
	forall {SA:add SM1 (map/+ N D M2) SM3} {S1:shift N M1 SM1}
        exists {M3} {A:add M1 M2 M3} {E:eq (map/+ N D M3) SM3}
	true.

- : shift-left-preserves-add-converse add/L shift/0 _ add/L eq/.

- : shift-left-preserves-add-converse M111+M222=SM3 (shift/+ N2+1+N3=N1) M3
                                       M311+M2=M3 M223=SM3
    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1
    <- add/>-inversion M111+M222=SM3 N3+1+N2=N1 M3 M311+M2=M3 SM3=M223
    <- eq-symmetric SM3=M223 M223=SM3.

%worlds () (shift-left-preserves-add-converse _ _ _ _ _).
%total { } (shift-left-preserves-add-converse _ _ _ _ _).


%theorem shift-right-preserves-add :
	forall* {N} {D} {M1} {M2} {M3} {SM2}
	forall {A:add M1 M2 M3} {S2:shift N M2 SM2}
        exists {SA:add (map/+ N D M1) SM2 (map/+ N D M3)}
	true.

- : shift-right-preserves-add add/L shift/0 add/R.

- : shift-right-preserves-add add/R shift/0 add/R.

- : shift-right-preserves-add M1+M222=M3 (shift/+ N+1+N2=N2P) 
                               (add/< M1+M222=M3 N2+1+N=N2P)
    <- plus-swap-succ N+1+N2=N2P N+N2+1=N2P
    <- plus-commutative N+N2+1=N2P N2+1+N=N2P.

%worlds () (shift-right-preserves-add _ _ _).
%total { } (shift-right-preserves-add _ _ _).


%theorem shift-right-preserves-add-converse :
	forall* {N} {D} {M1} {M2} {SM2} {SM3}
	forall {SA:add (map/+ N D M1) SM2 SM3} {S2:shift N M2 SM2}
        exists {M3} {A:add M1 M2 M3} {E:eq (map/+ N D M3) SM3}
	true.

- : shift-right-preserves-add-converse add/R shift/0 _ add/R eq/.

- : shift-right-preserves-add-converse M111+M322=SM3 (shift/+ N1+1+N2=N3)
                                        M3 M1+M222=M3 M133=SM3
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- add/<-inversion M111+M322=SM3 N2+1+N1=N3 M3 M1+M222=M3 SM3=M133
    <- eq-symmetric SM3=M133 M133=SM3.

%worlds () (shift-right-preserves-add-converse _ _ _ _ _).
%total { } (shift-right-preserves-add-converse _ _ _ _ _).


%theorem shift-preserves-add* :
	forall* {N} {M1} {M2} {M3} {SM1} {SM2} {SM3}
	forall {A:add M1 M2 M3} 
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} {S3:shift N M3 SM3}
	exists {SA:add SM1 SM2 SM3}
	true.

- : shift-preserves-add* add/L shift/0 M2<<N=SM2 M2<<N=SM3 Z+SM2=SM3
    <- shift-deterministic M2<<N=SM2 M2<<N=SM3 nat`eq/ eq/ SM2=SM3
    <- add-respects-eq add/L eq/ eq/ SM2=SM3 Z+SM2=SM3.

- : shift-preserves-add* add/R M1<<N=SM1 shift/0 M1<<N=SM3 SM1+0=SM3
    <- shift-deterministic M1<<N=SM1 M1<<N=SM3 nat`eq/ eq/ SM1=SM3
    <- add-respects-eq add/R eq/ eq/ SM1=SM3 SM1+0=SM3.

- : shift-preserves-add* (add/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N1=N5) 
                          (shift/+ N+1+N1=N6)
                          M411+M522=M633
    <- plus-deterministic N+1+N1=N4 N+1+N1=N5 nat`eq/ nat`eq/ N4=N5
    <- plus-deterministic N+1+N1=N4 N+1+N1=N6 nat`eq/ nat`eq/ N4=N6
    <- map/+-preserves-eq N4=N6 canonical`eq/ eq/ M433=M633
    <- add-respects-eq (add/= M1+M2=M3 D1+D2=D3 N4=N5) eq/ eq/ M433=M633
                        M411+M522=M633.

- : shift-preserves-add* (add/< M1+M022=M3 N0+1+N1=N2)
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) 
                          (shift/+ N+1+N1=N6) M411+M522=M613
    <- plus-deterministic N+1+N1=N4 N+1+N1=N6 nat`eq/ nat`eq/ N4=N6
    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4
    <- plus-commutative N+N1+1=N4 N1+1+N=N4
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5
    <- map/+-preserves-eq N4=N6 canonical`eq/ eq/ M433=M613
    <- add-respects-eq (add/< M1+M022=M3 N0+1+N4=N5) eq/ eq/ M433=M613
                        M411+M522=M613.

- : shift-preserves-add* (add/> M311+M2=M3 N3+1+N2=N1)
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) 
                          (shift/+ N+1+N2=N6) M411+M522=M623
    <- plus-deterministic N+1+N2=N5 N+1+N2=N6 nat`eq/ nat`eq/ N5=N6
    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5
    <- plus-commutative N+N2+1=N5 N2+1+N=N5
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- map/+-preserves-eq N5=N6 canonical`eq/ eq/ M523=M623
    <- add-respects-eq (add/> M311+M2=M3 N3+1+N5=N4) eq/ eq/ M523=M623
                        M411+M522=M623.

%worlds () (shift-preserves-add* _ _ _ _ _).
%total { } (shift-preserves-add* _ _ _ _ _).


%theorem shift-preserves-add :
	forall* {N} {M1} {M2} {M3} {SM1} {SM2}
	forall  {A:add M1 M2 M3} 
                {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	exists	{SM3} 
		{S3:shift N M3 SM3}
		{SA:add SM1 SM2 SM3}
	true.

- : shift-preserves-add J S1 S2 _ S3 JP
    <- shift-total S3
    <- shift-preserves-add* J S1 S2 S3 JP.

%worlds () (shift-preserves-add _ _ _ _ _ _).
%total { } (shift-preserves-add _ _ _ _ _ _).


%theorem shift-preserves-add-converse :
	forall* {N} {M1} {M2} {SM1} {SM2} {SM3}
	forall {SA:add SM1 SM2 SM3}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	exists {M3} {A:add M1 M2 M3} {S3:shift N M3 SM3}
	true.

- : shift-preserves-add-converse add/L shift/0 M2<<N=SM2 _ add/L M2<<N=SM2.

- : shift-preserves-add-converse add/R M1<<N=SM1 shift/0 _ add/R M1<<N=SM1.

- : shift-preserves-add-converse (add/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N1P=N4)
                                  (map/+ N1 D3 M3) M111+M122P=M133
                                  (shift/+ N+1+N1=N4)
    <- plus-left-cancels N+1+N1=N4 N+1+N1P=N4 nat`eq/ nat`eq/ N1=N1P
    <- map/+-preserves-eq N1=N1P canonical`eq/ eq/ M122=M122P
    <- add-respects-eq (add/= M1+M2=M3 D1+D2=D3 nat`eq/) eq/ M122=M122P eq/
                        M111+M122P=M133.

- : shift-preserves-add-converse (add/< M1+M055=M3 N0+1+N4=N5)
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) _
				  (add/< M1+M055=M3 N0+1+N1=N2)
				  (shift/+ N+1+N1=N4)
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4
    <- plus-associative-converse N1+N+1=N4 N0+1+N4=N5 N2P N0+1+N1=N2P N2P+N+1=N5
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-right-cancels N2P+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2P=N2
    <- plus-respects-eq N0+1+N1=N2P nat`eq/ nat`eq/ N2P=N2 N0+1+N1=N2.
                                  
- : shift-preserves-add-converse (add/> M611+M2=M3 N6+1+N5=N4)
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) _
                                  (add/> M611+M2=M3 N6+1+N2=N1)
                                  (shift/+ N+1+N2=N5)
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5
    <- plus-associative-converse N2+N+1=N5 N6+1+N5=N4 N1P N6+1+N2=N1P N1P+N+1=N4
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-right-cancels N1P+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1P=N1
    <- plus-respects-eq N6+1+N2=N1P nat`eq/ nat`eq/ N1P=N1 N6+1+N2=N1.

%worlds () (shift-preserves-add-converse _ _ _ _ _ _).
%total { } (shift-preserves-add-converse _ _ _ _ _ _).


% arguably: this should be the non-starred version
%theorem shift-preserves-add-converse* :
	forall* {N} {M3} {SM1} {SM2} {SM3}
	forall {SA:add SM1 SM2 SM3}  {S3:shift N M3 SM3}
	exists {M1} {M2}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	       {A:add M1 M2 M3}
	true.

- : shift-preserves-add-converse* U shift/0 _ _ shift/0 shift/0 add/L.

- : shift-preserves-add-converse* add/L S _ _ shift/0 S add/L.

- : shift-preserves-add-converse* add/R S _ _ S shift/0 add/R.

- : shift-preserves-add-converse* (add/= U DJ nat`eq/) (shift/+ P) _ _
	(shift/+ P) (shift/+ P) (add/= U DJ nat`eq/).

- : shift-preserves-add-converse* (add/< U D+1+A=B) 
	(shift/+ N+1+Y=A) _ _
	(shift/+ N+1+Y=A)
	(shift/+ N+1+Z=B)
	(add/< U D+1+Y=Z)
    <- plus-commutative N+1+Y=A Y+N+1=A
    <- plus-associative-converse Y+N+1=A D+1+A=B Z D+1+Y=Z Z+N+1=B
    <- plus-commutative Z+N+1=B N+1+Z=B.

- : shift-preserves-add-converse* (add/> U D+1+B=A)
	(shift/+ N+1+Y=B) _ _
	(shift/+ N+1+Z=A)
	(shift/+ N+1+Y=B)
	(add/> U D+1+Y=Z)
    <- plus-commutative N+1+Y=B Y+N+1=B
    <- plus-associative-converse Y+N+1=B D+1+B=A Z D+1+Y=Z Z+N+1=A
    <- plus-commutative Z+N+1=A N+1+Z=A.

%worlds () (shift-preserves-add-converse* _ _ _ _ _ _ _).
%total { } (shift-preserves-add-converse* _ _ _ _ _ _ _).


%theorem shift-preserves-add-converse** :
	forall* {N} {M1} {M2} {M3} {SM1} {SM2} {SM3}
	forall {SA:add SM1 SM2 SM3}  {S3:shift N M3 SM3}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	exists {A:add M1 M2 M3}
	true.

- : shift-preserves-add-converse** JP S3 S1 S2 J
    <- shift-preserves-add-converse JP S1 S2 _ JX S3X
    <- shift-cancels S3X S3 nat`eq/ eq/ M3X=M3
    <- add-respects-eq JX eq/ eq/ M3X=M3 J.

%worlds () (shift-preserves-add-converse** _ _ _ _ _).
%total { } (shift-preserves-add-converse** _ _ _ _ _).



%theorem add-commutative :
	forall* {M1} {M2} {M3}
	forall {A:add M1 M2 M3}
	exists {AP:add M2 M1 M3}
	true.

- : add-commutative add/L add/R.

- : add-commutative add/R add/L.

- : add-commutative (add/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                     (add/= M2+M1=M3 D2+D1=D3 nat`eq/)
    <- canonical`add-commutative D1+D2=D3 D2+D1=D3
    <- add-commutative M1+M2=M3 M2+M1=M3.

- : add-commutative (add/< M1+MT=M3 N0+1+N1=N2) (add/> MT+M1=M3 N0+1+N1=N2)
    <- add-commutative M1+MT=M3 MT+M1=M3.

- : add-commutative (add/> MT+M2=M3 N3+1+N2=N1) (add/< M2+MT=M3 N3+1+N2=N1)
    <- add-commutative MT+M2=M3 M2+MT=M3.

%worlds () (add-commutative _ _).
%total (A) (add-commutative A _).




%theorem add-associative :
	forall* {M1} {M2} {M3} {M4} {M7}
	forall {A12:add M1 M2 M3} {A34:add M3 M4 M7}
	exists {M6} {A24:add M2 M4 M6} {A16:add M1 M6 M7}
	true.

%% a lemma

%theorem add-associative-add/<-add/< :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0} {N5} {N4} {D4} {M4} {M6} {M7}
	forall {PLUS012:nat`plus (s N0) N1 N2}
               {PLUS514:nat`plus (s N5) N1 N4}
               {JOIN246:add (map/+ N0 D2 M2) (map/+ N5 D4 M4) M6}
               {JOIN167:add M1 M6 M7}
        exists {M} {JOIN24: add (map/+ N2 D2 M2) (map/+ N4 D4 M4) M}
               {JOIN:add (map/+ N1 D1 M1) M (map/+ N1 D1 M7)}
        true.
               
- : add-associative add/L A _ A add/L.

- : add-associative A add/R _ add/R A.

- : add-associative add/R A _ add/L A.

- : add-associative (add/= M1+M2=M3 D1+D2=D3 nat`eq/)
                    (add/= M3+M4=M7 D3+D4=D7 nat`eq/) (map/+ _ D6 M6)
                    (add/= M2+M4=M6 D2+D4=D6 nat`eq/)
		    (add/= M1+M6=M7 D1+D6=D7 nat`eq/)
    <- canonical`add-associative D1+D2=D3 D3+D4=D7 D6 D2+D4=D6 D1+D6=D7
    <- add-associative M1+M2=M3 M3+M4=M7 M6 M2+M4=M6 M1+M6=M7.

- : add-associative (add/= M1+M2=M3 D1+D2=D3 nat`eq/)
                    (add/< M3+M044=M7 N0+1+N3=N4) (map/+ _ _ M6) 
                    (add/< M2+M044=M6 N0+1+N3=N4) 
                    (add/= M1+M6=M7 D1+D2=D3 nat`eq/)
    <- add-associative M1+M2=M3 M3+M044=M7 M6 M2+M044=M6 M1+M6=M7.

- : add-associative (add/= M1+M2=M3 D1+D2=D3 nat`eq/)
	            (add/> M533+M4=M7 N5+1+N4=N3) (map/+ _ _ M6)
                    (add/> M522+M4=M6 N5+1+N4=N3)
                    (add/> M511+M6=M7 N5+1+N4=N3)
    <- add-associative (add/= M1+M2=M3 D1+D2=D3 nat`eq/) M533+M4=M7
                       M6 M522+M4=M6 M511+M6=M7.

- : add-associative (add/< M1+M022=M3 N0+1+N1=N2)
                     (add/= M3+M4=M7 D1+D4=D7 nat`eq/) (map/+ _ _ M6)
                     (add/> M022+M3=M6 N0+1+N1=N2)
                     (add/= M1+M6=M7 D1+D4=D7 nat`eq/)
    <- add-associative M1+M022=M3 M3+M4=M7 M6 M022+M3=M6 M1+M6=M7.

%% the hardest of all 11 cases!

- : {M111+M=M117: add (map/+ N1 D1 M1) M (map/+ N1 D1 M7)}
    {M3+M544=M7: add M3 (map/+ N5 D4 M4) M7}
    {M1+M022=M3: add M1 (map/+ N0 D2 M2) M3}
    {M1+M6=M7: add M1 M6 M7}
    add-associative (add/< M1+M022=M3 N0+1+N1=N2)
       		     (add/< M3+M544=M7 N5+1+N1=N4) 
		     M M222+M444=M M111+M=M117
    <- add-associative M1+M022=M3 M3+M544=M7 M6 M022+M544=M6 M1+M6=M7
    <- add-associative-add/<-add/< 
       		N0+1+N1=N2 N5+1+N1=N4 M022+M544=M6 M1+M6=M7 
       		M M222+M444=M M111+M=M117.

- : add-associative-add/<-add/< N+1+N1=N2 N+1+N1=N4
                                   (add/= M2+M4=M6 D2+D4=D6 nat`eq/) 
                                   M1+M066=M7 (map/+ N2 D6 M6)
                                   (add/= M2+M4=M6 D2+D4=D6 N2=N4)
                                   (add/< M1+M066=M7 N+1+N1=N2)
    <- nat`plus-deterministic N+1+N1=N2 N+1+N1=N4 nat`eq/ nat`eq/ N2=N4.

- : add-associative-add/<-add/< N0+1+N1=N2 N5+1+N1=N4
                                   (add/< M2+M744=M6 N7+1+N0=N5)
                                   M1+M026=M7 (map/+ N2 D2 M6)
     				   (add/< M2+M744=M6 N7+1+N2=N4)
                                   (add/< M1+M026=M7 N0+1+N1=N2)
    <- nat`plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- nat`plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- nat`plus-associative* N7+1+N0=N5 N5+N1+1=N4 N0+N1+1=N2 N7+1+N2=N4.

- : add-associative-add/<-add/< N0+1+N1=N2 N5+1+N1=N4
                                   (add/> M722+M4=M6 N7+1+N5=N0)
                                   M1+M546=M7 (map/+ N4 D4 M6)
                                   (add/> M722+M4=M6 N7+1+N4=N2)
                                   (add/< M1+M546=M7 N5+1+N1=N4)
    <- nat`plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- nat`plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- nat`plus-associative* N7+1+N5=N0 N0+N1+1=N2 N5+N1+1=N4 N7+1+N4=N2.

%% and now we return to the main theorem

- : add-associative (add/< M1+M022=M3 N0+1+N1=N2)
		    (add/> M513+M4=M7 N5+1+N3=N1) (map/+ _ _ M6)
                    (add/> M622+M4=M6 N6+1+N3=N2)
                    (add/> M511+M6=M7 N5+1+N3=N1)
    <- nat`plus-swap-succ N5+1+N3=N1 N5+N3+1=N1
    <- nat`plus-associative-converse N5+N3+1=N1 N0+1+N1=N2 N6
                                     N0+1+N5=N6 N6+N3+1=N2
    <- nat`plus-swap-succ-converse N6+N3+1=N2 N6+1+N3=N2
    <- add-associative (add/< M1+M022=M3 N0+1+N5=N6) M513+M4=M7 
                       M6 M622+M4=M6 M511+M6=M7.

- : add-associative (add/> M311+M2=M3 N3+1+N2=N1)
                    (add/= M3+M4=M7 D2+D4=D7 nat`eq/) (map/+ _ _ M6)
                    (add/= M2+M4=M6 D2+D4=D7 nat`eq/)
                    (add/> M311+M6=M7 N3+1+N2=N1)
    <- add-associative M311+M2=M3 M3+M4=M7 M6 M2+M4=M6 M311+M6=M7.

- : add-associative (add/> M311+M2=M3 N3+1+N2=N1)
                    (add/< M3+M044=M7 N0+1+N2=N4) (map/+ _ _ M6)
                    (add/< M2+M044=M6 N0+1+N2=N4)
                    (add/> M311+M6=M7 N3+1+N2=N1)
    <- add-associative M311+M2=M3 M3+M044=M7 M6 M2+M044=M6 M311+M6=M7.

- : add-associative (add/> M311+M2=M3 N3+1+N2=N1)
                    (add/> M523+M4=M7 N5+1+N4=N2) (map/+ _ _ M6)
		    (add/> M522+M4=M6 N5+1+N4=N2)
                    (add/> M711+M6=M7 N7+1+N4=N1)
    <- nat`plus-swap-succ N5+1+N4=N2 N5+N4+1=N2
    <- nat`plus-associative-converse N5+N4+1=N2 N3+1+N2=N1 
                                     N7 N3+1+N5=N7 N7+N4+1=N1
    <- nat`plus-swap-succ-converse N7+N4+1=N1 N7+1+N4=N1
    <- add-associative (add/> M311+M2=M3 N3+1+N5=N7) M523+M4=M7
                       M6 M522+M4=M6 M711+M6=M7.

%worlds () (add-associative-add/<-add/< _ _ _ _ _ _ _).
%total {} (add-associative-add/<-add/< _ _ _ _ _ _ _).

%worlds () (add-associative _ _ _ _ _).
%total (J) (add-associative _ J _ _ _).



%theorem add-associative* :
	forall* {X1} {X2} {X12} {X3} {X23} {X123}
        forall {OP12:add X1 X2 X12} {OP12-3:add X12 X3 X123} {OP23:add X2 X3 X23}
        exists {OP1-23:add X1 X23 X123}
        true.

- : add-associative* X1+X2=X3 X3+X4=X7 X2+X4=X6 X1+X6=X7
    <- add-associative X1+X2=X3 X3+X4=X7 Y6 X2+X4=Y6 X1+Y6=X7
    <- add-unique X2+X4=Y6 X2+X4=X6 eq/ eq/ Y6=X6
    <- add-respects-eq X1+Y6=X7 eq/ Y6=X6 eq/ X1+X6=X7.

%worlds () (add-associative* _ _ _ _).
%total {} (add-associative* _ _ _ _).


%theorem add-associative-converse :
	forall* {X1} {X2} {X4} {X6} {X7}
	forall {OP24:add X2 X4 X6} {OP16:add X1 X6 X7}
        exists {X3} {OP12:add X1 X2 X3} {OP34:add X3 X4 X7}
        true.

- : add-associative-converse X2+X4=X6 X1+X6=X7 _ X1+X2=X3 X3+X4=X7
    <- add-commutative X2+X4=X6 X4+X2=X6
    <- add-commutative X1+X6=X7 X6+X1=X7
    <- add-associative X4+X2=X6 X6+X1=X7 _ X2+X1=X3 X4+X3=X7
    <- add-commutative X2+X1=X3 X1+X2=X3
    <- add-commutative X4+X3=X7 X3+X4=X7.

%worlds () (add-associative-converse X2+X4=X6 X1+X6=X7 X3 X1+X2=X3 X3+X4=X7).
%total {} (add-associative-converse _ _ _ _ _).


%theorem add-associative-converse* :
	forall* {X1} {X2} {X3} {X4} {X6} {X7}
	forall {OP24:add X2 X4 X6} {OP16:add X1 X6 X7} {OP12:add X1 X2 X3} 
	exists {OP34:add X3 X4 X7}
        true.

- : add-associative-converse* X2+X4=X6 X1+X6=X7 X1+X2=X3 X3+X4=X7
    <- add-associative-converse X2+X4=X6 X1+X6=X7 X3P X1+X2=X3P X3P+X4=X7
    <- add-unique X1+X2=X3P X1+X2=X3 eq/ eq/ X3P=X3
    <- add-respects-eq X3P+X4=X7 X3P=X3 eq/ eq/ X3+X4=X7.

%worlds () (add-associative-converse* X2+X4=X6 X1+X6=X7 X1+X2=X3 %{=>}% X3+X4=X7).
%total {} (add-associative-converse* _ _ _ _).

%% The following two theorems are useful for reordering elements
%% is a left-associative sequence of operations.

%theorem add-assoc-commutative* :
	forall* {X1} {X2} {X3} {X4} {X5} {X7}
	forall {OP1:add X1 X2 X3} {OP2:add X3 X4 X7}
               {OP3:add X1 X4 X5} 
        exists {OP4:add X5 X2 X7}
	true.

- : add-assoc-commutative* X1+X2=X3 X3+X4=X7 X1+X4=X5 X5+X2=X7
    <- add-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7
    <- add-commutative X2+X4=X6 X4+X2=X6
    <- add-associative-converse* X4+X2=X6 X1+X6=X7 X1+X4=X5 X5+X2=X7.

%worlds () (add-assoc-commutative* X1+X2=X3 X3+X4=X7 X1+X4=X5 %{=>}% X5+X2=X7).
%total {} (add-assoc-commutative* _ _ _ _).


%theorem add-assoc-commutative :
	forall* {X1} {X2} {X3} {X4} {X7}
	forall {OP1:add X1 X2 X3} {OP2:add X3 X4 X7}
        exists {X5} {OP3:add X1 X4 X5} {OP4:add X5 X2 X7}
	true.

- : add-assoc-commutative X1+X2=X3 X3+X4=X7 X5 X1+X4=X5 X5+X2=X7
    <- add-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7
    <- add-commutative X2+X4=X6 X4+X2=X6
    <- add-associative-converse X4+X2=X6 X1+X6=X7 X5 X1+X4=X5 X5+X2=X7.

%worlds () (add-assoc-commutative X1+X2=X3 X3+X4=X7 %{=>}% X5 X1+X4=X5 X5+X2=X7).
%total {} (add-assoc-commutative _ _ _ _ _).

%% The following theorem is a useful shortcut to
%% re-associate (AB)(CD) to (AC)(BD):

%theorem add-double-associative* :
	forall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}
	forall {AB:add A B A+B} {CD:add C D C+D} {ABCD:add A+B C+D X}
	       {AC:add A C A+C} {BD:add B D B+D} 
        exists {ACBD:add A+C B+D X}
	true.

- : add-double-associative* X1+X2=X3 X4+X8=XC X3+XC=XF X1+X4=X5 X2+X8=XA X5+XA=XF
    <- add-associative X1+X2=X3 X3+XC=XF XE X2+XC=XE X1+XE=XF
    <- add-commutative X4+X8=XC X8+X4=XC
    <- add-associative-converse* X8+X4=XC X2+XC=XE X2+X8=XA XA+X4=XE
    <- add-commutative XA+X4=XE X4+XA=XE
    <- add-associative-converse* X4+XA=XE X1+XE=XF X1+X4=X5 X5+XA=XF.

%worlds () (add-double-associative* X1+X2=X3 X4+X8=XC X3+XC=XF X1+X4=X5 X2+X8=XA
                            %{=>}% X5+XA=XF).
%total {} (add-double-associative* _ _ _ _ _ _).


%theorem add-double-associative :
	forall* {A} {B} {C} {D} {A+B} {C+D} {X}
	forall {AB:add A B A+B} {CD:add C D C+D} {ABCD:add A+B C+D X}
	exists {A+C} {B+D} {AC:add A C A+C} {BD:add B D B+D} 
               {ACBD:add A+C B+D X}
	true.

- : add-double-associative X1+X2=X3 X4+X8=XC X3+XC=XF X5 XA X1+X4=X5 X2+X8=XA X5+XA=XF
    <- add-associative X1+X2=X3 X3+XC=XF XE X2+XC=XE X1+XE=XF
    <- add-commutative X4+X8=XC X8+X4=XC
    <- add-associative-converse X8+X4=XC X2+XC=XE XA X2+X8=XA XA+X4=XE
    <- add-commutative XA+X4=XE X4+XA=XE
    <- add-associative-converse X4+XA=XE X1+XE=XF X5 X1+X4=X5 X5+XA=XF.

%worlds () (add-double-associative _ _ _ _ _ _ _ _).
%total { } (add-double-associative _ _ _ _ _ _ _ _).



%theorem lookup-implies-add :
	forall* {M} {N} {D}
	forall {L:lookup M N D}
	exists {M-} {F:fresh M- N}
	       {A:add (map/+ N D map/0) M- M}
	true.

- : lookup-implies-add (lookup/= nat`eq/) _
                        (fresh/0) (add/R).

- : lookup-implies-add (lookup/= nat`eq/) _
                        (fresh/< N2>N1) 
                        (add/< add/L N0+1+N1=N2)
    <- nat`plus-total N0+1+N1=N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1.

- : lookup-implies-add (lookup/> L N0+1+N1=N2) _
                        (fresh/> F N0+1+N1=N2)
			(add/> A N0+1+N1=N2)
    <- lookup-implies-add  L _ F A.

%worlds () (lookup-implies-add _ _ _ _).
%total (L) (lookup-implies-add L _ _ _).


%theorem add-joins-lookup :
	forall* {M1} {M2} {M3} {N} {D1} {D2}
	forall {L1:lookup M1 N D1} {L2:lookup M2 N D2}
               {A:add M1 M2 M3}
	exists {D3} {J:canonical`add D1 D2 D3} {L3:lookup M3 N D3}
	true.

- : add-joins-lookup (lookup/= nat`eq/) (lookup/= nat`eq/) A
                           _ AD L3
    <- add/=-inversion A nat`eq/ _ _ AD _ M=M133
    <- eq-symmetric M=M133 M133=M
    <- lookup-respects-eq (lookup/= nat`eq/) M133=M nat`eq/ canonical`eq/ L3.

- : add-joins-lookup (lookup/> L1 N0+1+N1=N2)
                           (lookup/= nat`eq/) A _ AD L3P
    <- add/<-inversion A N0+1+N1=N2 M3 M1+M022=M3 M=M113
    <- add-joins-lookup L1 (lookup/= nat`eq/) M1+M022=M3 _ AD L3
    <- eq-symmetric M=M113 M113=M
    <- lookup-respects-eq (lookup/> L3 N0+1+N1=N2) M113=M  nat`eq/ canonical`eq/ L3P.

- : add-joins-lookup (lookup/= nat`eq/) 
                           (lookup/> L2 N3+1+N2=N1) A _ AD L3P
    <- add/>-inversion A N3+1+N2=N1 M3 M311+M2=M3 M=M223
    <- add-joins-lookup (lookup/= nat`eq/) L2 M311+M2=M3 _ AD L3
    <- eq-symmetric M=M223 M223=M
    <- lookup-respects-eq (lookup/> L3 N3+1+N2=N1) M223=M  nat`eq/ canonical`eq/ L3P.

- : add-joins-lookup (lookup/> L1P N4+1+N1=N)
                           (lookup/> L2 N5+1+N2=N)
                           (add/= M1+M2=M3 _ nat`eq/) _ AD
                           (lookup/> L N5+1+N2=N)
    <- plus-right-cancels N4+1+N1=N N5+1+N2=N nat`eq/ nat`eq/ N4+1=N5+1
    <- succ-cancels N4+1=N5+1 N4=N5
    <- lookup-respects-eq L1P eq/ N4=N5 canonical`eq/ L1
    <- add-joins-lookup L1 L2 M1+M2=M3 _ AD L.

- : add-joins-lookup (lookup/> L1 N4+1+N1=N)
                           (lookup/> L2 N5+1+N2=N)
                           (add/< M1+M022=M3 N0+1+N1=N2) _ AD
			   (lookup/> L3 N4+1+N1=N)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N5+1+N2=N N6 N5+1+N0=N6 N6+N1+1=N
    <- plus-swap-succ N4+1+N1=N N4+N1+1=N
    <- plus-right-cancels N6+N1+1=N N4+N1+1=N nat`eq/ nat`eq/ N6=N4
    <- plus-respects-eq N5+1+N0=N6 nat`eq/ nat`eq/ N6=N4 N5+1+N0=N4
    <- add-joins-lookup 
       L1 (lookup/> L2 N5+1+N0=N4) M1+M022=M3 _ AD L3.

- : add-joins-lookup (lookup/> L1 N4+1+N1=N)
                           (lookup/> L2 N5+1+N2=N)
                           (add/> M311+M2=M3 N3+1+N2=N1) _ AD
                           (lookup/> L3 N5+1+N2=N)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N4+1+N1=N N6 N4+1+N3=N6 N6+N2+1=N
    <- plus-swap-succ N5+1+N2=N N5+N2+1=N
    <- plus-right-cancels N6+N2+1=N N5+N2+1=N nat`eq/ nat`eq/ N6=N5
    <- plus-respects-eq N4+1+N3=N6 nat`eq/ nat`eq/ N6=N5 N4+1+N3=N5
    <- add-joins-lookup
       (lookup/> L1 N4+1+N3=N5) L2 M311+M2=M3 _ AD L3.

%worlds () (add-joins-lookup _ _ _ _ _ _).
%total (A) (add-joins-lookup _ _ A _ _ _).


%theorem add-joins-lookup* :
	forall* {M1} {M2} {M3} {N} {D1} {D2} {D3}
	forall {L1:lookup M1 N D1} {L2:lookup M2 N D2}
               {A:add M1 M2 M3}
	       {J:canonical`add D1 D2 D3} 
	exists {L3:lookup M3 N D3}
	true.

- : add-joins-lookup* L1 L2 A J L3
    <- add-joins-lookup L1 L2 A _ JP L3P
    <- canonical`add-deterministic JP J canonical`eq/ canonical`eq/ D3P=D3
    <- lookup-respects-eq L3P eq/ nat`eq/ D3P=D3 L3.

%worlds () (add-joins-lookup* _ _ _ _ _).
%total { } (add-joins-lookup* _ _ _ _ _).


%theorem add-commutes-lookup :
	forall* {M1} {M2} {M3} {N} {D1} {D2} {D3}
	forall {A:add M1 M2 M3}
	       {L1:lookup M1 N D1} {L2:lookup M2 N D2}
               {L3:lookup M3 N D3}	       
	exists {J:canonical`add D1 D2 D3} 
	true.

- : add-commutes-lookup M1+M2=M3 L1 L2 L3 D1+D2=D3
    <- add-joins-lookup L1 L2 M1+M2=M3 D3X D1+D2=D3X L3X
    <- lookup-unique L3X L3 eq/ nat`eq/ D3X=D3
    <- canonical`add-respects-eq D1+D2=D3X canonical`eq/ canonical`eq/ D3X=D3 D1+D2=D3.

%worlds () (add-commutes-lookup _ _ _ _ _).
%total { } (add-commutes-lookup _ _ _ _ _).


%theorem add-preserves-fresh* :
	forall* {M1} {M2} {M3} {N}
	forall {F1:fresh M1 N} {F2:fresh M2 N}
               {A:add M1 M2 M3}
	exists {F3:fresh M3 N}
	true.
	
- : add-preserves-fresh* _ F add/L F.

- : add-preserves-fresh* F _ add/R F.

- : add-preserves-fresh* (fresh/< N<N1) (fresh/< _) (add/= _ _ _) 
                          (fresh/< N<N1).

- : add-preserves-fresh* (fresh/< N<N1) (fresh/< _) (add/< _ _) 
                          (fresh/< N<N1).

- : add-preserves-fresh* (fresh/< _) (fresh/< N<N2) (add/> _ _) 
                          (fresh/< N<N2).

- : add-preserves-fresh* (fresh/< N<N1) (fresh/> F2 N4+1+N2=N) AX F3X
    <- gt-implies-plus N<N1 N0 N0+1+N=N1
    <- plus-swap-succ N4+1+N2=N N4+N2+1=N
    <- plus-associative-converse N4+N2+1=N N0+1+N=N1 N3 N0+1+N4=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- add/>-inversion AX N3+1+N2=N1 M3 A M=M223
    <- plus-implies-gt N0+1+N4=N3 nat`eq/ N4<N3
    <- add-preserves-fresh* (fresh/< N4<N3) F2 A F3
    <- eq-symmetric M=M223 M223=M
    <- fresh-respects-eq (fresh/> F3 N4+1+N2=N) M223=M nat`eq/ F3X.

- : add-preserves-fresh* (fresh/> F1 N3+1+N1=N) (fresh/< N<N2) AX F3X
    <- gt-implies-plus N<N2 N4 N4+1+N=N2
    <- plus-swap-succ N3+1+N1=N N2+N1+1=N
    <- plus-associative-converse N2+N1+1=N N4+1+N=N2 N0 N4+1+N2=N0 N0+N1+1=N2
    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2
    <- add/<-inversion AX N0+1+N1=N2 M3 A M=M113
    <- plus-implies-gt N4+1+N2=N0 nat`eq/ N2<N0
    <- add-preserves-fresh* F1 (fresh/< N2<N0) A F3
    <- eq-symmetric M=M113 M113=M
    <- fresh-respects-eq (fresh/> F3 N3+1+N1=N) M113=M nat`eq/ F3X.

- : add-preserves-fresh* (fresh/> F1 N3+1+N1=N) (fresh/> F2P N4+1+N2=N) 
                          (add/= A _ N1=N2) (fresh/> F3 N3+1+N1=N)
    <- plus-right-cancels N3+1+N1=N N4+1+N2=N N1=N2 nat`eq/ N3+1=N4+1
    <- succ-cancels N3+1=N4+1 N3=N4
    <- nat`eq-symmetric N3=N4 N4=N3
    <- fresh-respects-eq F2P eq/ N4=N3 F2
    <- add-preserves-fresh* F1 F2 A F3.

- : add-preserves-fresh* (fresh/> F1 N3+1+N1=N) (fresh/> F2 N4+1+N2=N) 
                          (add/< A N0+1+N1=N2) (fresh/> F3 N3+1+N1=N)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N4+1+N2=N N6 N4+1+N0=N6 N6+N1+1=N
    <- plus-swap-succ N3+1+N1=N N3+N1+1=N
    <- plus-right-cancels N6+N1+1=N N3+N1+1=N nat`eq/ nat`eq/ N6=N3
    <- plus-respects-eq N4+1+N0=N6 nat`eq/ nat`eq/ N6=N3 N4+1+N0=N3
    <- add-preserves-fresh* F1 (fresh/> F2 N4+1+N0=N3) A F3.

- : add-preserves-fresh* (fresh/> F1 N3+1+N1=N) (fresh/> F2 N4+1+N2=N) 
                          (add/> A N0+1+N2=N1) (fresh/> F3 N4+1+N2=N)
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-associative-converse N0+N2+1=N1 N3+1+N1=N N6 N3+1+N0=N6 N6+N2+1=N
    <- plus-swap-succ N4+1+N2=N N4+N2+1=N
    <- plus-right-cancels N6+N2+1=N N4+N2+1=N nat`eq/ nat`eq/ N6=N4
    <- plus-respects-eq N3+1+N0=N6 nat`eq/ nat`eq/ N6=N4 N3+1+N0=N4
    <- add-preserves-fresh* (fresh/> F1 N3+1+N0=N4) F2 A F3.

%worlds () (add-preserves-fresh* _ _ _ _).
%total (A) (add-preserves-fresh* _ _ A _).


%theorem fresh-add-left-preserves-lookup* :
	forall* {M1} {M2} {M3} {N} {D}
	forall {F1:fresh M1 N} {L2:lookup M2 N D} 
               {A:add M1 M2 M3}
	exists {L3:lookup M3 N D}
	true.

- : fresh-add-left-preserves-lookup* _ L add/L L.

- : fresh-add-left-preserves-lookup* (fresh/< N2<N1) (lookup/= nat`eq/) AX L3X
    <- gt-implies-plus N2<N1 N3 N3+1+N2=N1
    <- add/>-inversion AX N3+1+N2=N1 M3 A M=M223
    <- eq-symmetric M=M223 M223=M
    <- lookup-respects-eq (lookup/= nat`eq/) M223=M nat`eq/ canonical`eq/ L3X.

- : fresh-add-left-preserves-lookup* (fresh/< N<N1) (lookup/> L2 N4+1+N2=N)
                                      AX L3X
    <- gt-implies-plus N<N1 N0 N0+1+N=N1
    <- plus-swap-succ N4+1+N2=N N4+N2+1=N
    <- plus-associative-converse N4+N2+1=N N0+1+N=N1 N3 N0+1+N4=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- add/>-inversion AX N3+1+N2=N1 M3 A M=M223
    <- eq-symmetric M=M223 M223=M
    <- plus-implies-gt N0+1+N4=N3 nat`eq/ N3>N4
    <- fresh-add-left-preserves-lookup* (fresh/< N3>N4) L2 A L3
    <- lookup-respects-eq (lookup/> L3 N4+1+N2=N) M223=M nat`eq/ canonical`eq/ L3X.
 
- : fresh-add-left-preserves-lookup* (fresh/> F1 N0+1+N1=N2) 
                                      (lookup/= nat`eq/) AX L3X
    <- add/<-inversion AX N0+1+N1=N2 M3 A M=M113
    <- eq-symmetric M=M113 M113=M
    <- fresh-add-left-preserves-lookup* F1 (lookup/= nat`eq/) A L3
    <- lookup-respects-eq (lookup/> L3 N0+1+N1=N2) M113=M nat`eq/ canonical`eq/ L3X.

- : fresh-add-left-preserves-lookup* (fresh/> F1P N4+1+N1=N)
                                      (lookup/> L2 N5+1+N1=N)
                                      (add/= A _ nat`eq/) 
                                      (lookup/> L3 N5+1+N1=N)
    <- plus-right-cancels N4+1+N1=N N5+1+N1=N nat`eq/ nat`eq/ N4+1=N5+1
    <- succ-cancels N4+1=N5+1 N4=N5
    <- fresh-respects-eq F1P eq/ N4=N5 F1
    <- fresh-add-left-preserves-lookup* F1 L2 A L3.

- : fresh-add-left-preserves-lookup* (fresh/> F1 N4+1+N1=N)
                                      (lookup/> L2 N5+1+N2=N)
                                      (add/< A N0+1+N1=N2)
                                      (lookup/> L3 N4+1+N1=N)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N5+1+N2=N N3 N5+1+N0=N3 N3+N1+1=N
    <- plus-swap-succ N4+1+N1=N N4+N1+1=N
    <- plus-right-cancels N3+N1+1=N N4+N1+1=N nat`eq/ nat`eq/ N3=N4
    <- plus-respects-eq N5+1+N0=N3 nat`eq/ nat`eq/ N3=N4 N5+1+N0=N4
    <- fresh-add-left-preserves-lookup* F1 (lookup/> L2 N5+1+N0=N4) A L3.

- : fresh-add-left-preserves-lookup* (fresh/> F1 N4+1+N1=N)
                                      (lookup/> L2 N5+1+N2=N)
                                      (add/> A N3+1+N2=N1)
                                      (lookup/> L3 N5+1+N2=N)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N4+1+N1=N N6 N4+1+N3=N6 N6+N2+1=N
    <- plus-swap-succ N5+1+N2=N N5+N2+1=N
    <- plus-right-cancels N6+N2+1=N N5+N2+1=N nat`eq/ nat`eq/ N6=N5
    <- plus-respects-eq N4+1+N3=N6 nat`eq/ nat`eq/ N6=N5 N4+1+N3=N5
    <- fresh-add-left-preserves-lookup* (fresh/> F1 N4+1+N3=N5) L2 A L3.

%worlds () (fresh-add-left-preserves-lookup* _ _ _ _).
%total (A) (fresh-add-left-preserves-lookup* _ _ A _).


%theorem fresh-add-left-preserves-lookup-converse :
	forall* {M1} {M2} {M3} {N} {D}
	forall {F1:fresh M1 N} {L3:lookup M3 N D} 
               {A:add M1 M2 M3}
	exists {L2:lookup M2 N D}
	true.

%theorem fresh-add-left-preserves-lookup-converse/L :
	forall* {M1} {M2} {M3} {N} {D} {B}
	forall {F1:fresh M1 N} {L3:lookup M3 N D} 
               {A:add M1 M2 M3}
               {D?:domain? M2 N B}
	exists {L2:lookup M2 N D}
	true.

- : fresh-add-left-preserves-lookup-converse F1 L3 A L2
    <- domain?-total D?
    <- fresh-add-left-preserves-lookup-converse/L F1 L3 A D? L2.

- : fresh-add-left-preserves-lookup-converse/L 
     F1 L3 A (domain?/in L2P) L2
    <- fresh-add-left-preserves-lookup* F1 L2P A L3P
    <- lookup-deterministic L3P L3 eq/ nat`eq/ DP=D
    <- lookup-respects-eq L2P eq/ nat`eq/ DP=D L2.

- : fresh-add-left-preserves-lookup-converse/L
     F1 L3 A (domain?/out F2) L2
    <- add-preserves-fresh* F1 F2 A F3
    <- fresh-lookup-not-equal F3 L3 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L2.

%worlds () (fresh-add-left-preserves-lookup-converse/L _ _ _ _ _).
%total { } (fresh-add-left-preserves-lookup-converse/L _ _ _ _ _).

%worlds () (fresh-add-left-preserves-lookup-converse _ _ _ _).
%total { } (fresh-add-left-preserves-lookup-converse _ _ _ _).


%theorem add-left-affects-lookup :
	forall* {M1} {N} {D2} {M2} {M3}
	forall {L:lookup M2 N D2}
	       {A:add M1 M2 M3}
	exists {D3}
               {N:lookup M3 N D3}
	true.

%theorem add-left-affects-lookup/L :
	forall* {M1} {N} {D2} {M2} {M3} {B}
	forall {L:lookup M2 N D2}
	       {A:add M1 M2 M3}
	       {D:domain? M1 N B}
	exists {D3}
               {N:lookup M3 N D3}
	true.

- : add-left-affects-lookup/L L2 A (domain?/in L1) _ L3
    <- add-joins-lookup L1 L2 A _ _ L3.

- : add-left-affects-lookup/L L2 A (domain?/out F1) _ L3
    <- fresh-add-left-preserves-lookup* F1 L2 A L3.

%worlds () (add-left-affects-lookup/L _ _ _ _ _).
%total { } (add-left-affects-lookup/L _ _ _ _ _).

- : add-left-affects-lookup L2 A _ L3
    <- domain?-total D
    <- add-left-affects-lookup/L L2 A D _ L3.

%worlds () (add-left-affects-lookup _ _ _ _).
%total { } (add-left-affects-lookup _ _ _ _).


% TODO: "*" should be removed here.

%theorem fresh-add-right-preserves-lookup :
	forall* {M1} {M2} {M3} {N} {D}
	forall {L1:lookup M1 N D} {F2:fresh M2 N}
               {A:add M1 M2 M3}
	exists {L3:lookup M3 N D}
	true.

% deprecated
%abbrev fresh-add-right-preserves-lookup* = fresh-add-right-preserves-lookup.

- : fresh-add-right-preserves-lookup L _ add/R L.

- : fresh-add-right-preserves-lookup (lookup/= nat`eq/) (fresh/< N2<N1) AX L3X
    <- gt-implies-plus N2<N1 N3 N3+1+N2=N1
    <- add/<-inversion AX N3+1+N2=N1 M3 A M=M223
    <- eq-symmetric M=M223 M223=M
    <- lookup-respects-eq (lookup/= nat`eq/) M223=M nat`eq/ canonical`eq/ L3X.

- : fresh-add-right-preserves-lookup (lookup/> L2 N4+1+N2=N) (fresh/< N<N1)
                                      AX L3X
    <- gt-implies-plus N<N1 N0 N0+1+N=N1
    <- plus-swap-succ N4+1+N2=N N4+N2+1=N
    <- plus-associative-converse N4+N2+1=N N0+1+N=N1 N3 N0+1+N4=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- add/<-inversion AX N3+1+N2=N1 M3 A M=M223
    <- eq-symmetric M=M223 M223=M
    <- plus-implies-gt N0+1+N4=N3 nat`eq/ N3>N4
    <- fresh-add-right-preserves-lookup L2 (fresh/< N3>N4) A L3
    <- lookup-respects-eq (lookup/> L3 N4+1+N2=N) M223=M nat`eq/ canonical`eq/ L3X.
 
- : fresh-add-right-preserves-lookup
	(lookup/= nat`eq/) (fresh/> F1 N0+1+N1=N2) 
	AX L3X
    <- add/>-inversion AX N0+1+N1=N2 M3 A M=M113
    <- eq-symmetric M=M113 M113=M
    <- fresh-add-right-preserves-lookup (lookup/= nat`eq/) F1 A L3
    <- lookup-respects-eq (lookup/> L3 N0+1+N1=N2) M113=M nat`eq/ canonical`eq/ L3X.

- : fresh-add-right-preserves-lookup (lookup/> L2 N5+1+N1=N)
				      (fresh/> F1P N4+1+N1=N)
                                      (add/= A _ nat`eq/) 
                                      (lookup/> L3 N5+1+N1=N)
    <- plus-right-cancels N4+1+N1=N N5+1+N1=N nat`eq/ nat`eq/ N4+1=N5+1
    <- succ-cancels N4+1=N5+1 N4=N5
    <- fresh-respects-eq F1P eq/ N4=N5 F1
    <- fresh-add-right-preserves-lookup L2 F1 A L3.

- : fresh-add-right-preserves-lookup (lookup/> L2 N5+1+N2=N)
                                      (fresh/> F1 N4+1+N1=N)
                                      (add/> A N0+1+N1=N2)
                                      (lookup/> L3 N4+1+N1=N)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N5+1+N2=N N3 N5+1+N0=N3 N3+N1+1=N
    <- plus-swap-succ N4+1+N1=N N4+N1+1=N
    <- plus-right-cancels N3+N1+1=N N4+N1+1=N nat`eq/ nat`eq/ N3=N4
    <- plus-respects-eq N5+1+N0=N3 nat`eq/ nat`eq/ N3=N4 N5+1+N0=N4
    <- fresh-add-right-preserves-lookup (lookup/> L2 N5+1+N0=N4) F1 A L3.

- : fresh-add-right-preserves-lookup (lookup/> L2 N5+1+N2=N)
				      (fresh/> F1 N4+1+N1=N)
                                      (add/< A N3+1+N2=N1)
                                      (lookup/> L3 N5+1+N2=N)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N4+1+N1=N N6 N4+1+N3=N6 N6+N2+1=N
    <- plus-swap-succ N5+1+N2=N N5+N2+1=N
    <- plus-right-cancels N6+N2+1=N N5+N2+1=N nat`eq/ nat`eq/ N6=N5
    <- plus-respects-eq N4+1+N3=N6 nat`eq/ nat`eq/ N6=N5 N4+1+N3=N5
    <- fresh-add-right-preserves-lookup L2 (fresh/> F1 N4+1+N3=N5) A L3.

%worlds () (fresh-add-right-preserves-lookup _ _ _ _).
%total (A) (fresh-add-right-preserves-lookup _ _ A _).


%theorem fresh-add-right-preserves-lookup-converse :
	forall* {M1} {M2} {M3} {N} {D}
	forall {L3:lookup M3 N D} {F2:fresh M2 N}
               {A:add M1 M2 M3}
	exists {L1:lookup M1 N D}
	true.

%theorem fresh-add-right-preserves-lookup-converse/L :
	forall* {M1} {M2} {M3} {N} {D} {B}
	forall {L3:lookup M3 N D} {F2:fresh M2 N}
               {A:add M1 M2 M3}
	       {D?:domain? M1 N B}
	exists {L1:lookup M1 N D}
	true.

- : fresh-add-right-preserves-lookup-converse L3 F2 A L1
    <- domain?-total D?
    <- fresh-add-right-preserves-lookup-converse/L L3 F2 A D? L1.

- : fresh-add-right-preserves-lookup-converse/L 
     L3 F2 A (domain?/in L1P) L1
    <- fresh-add-right-preserves-lookup* L1P F2 A L3P
    <- lookup-deterministic L3P L3 eq/ nat`eq/ DP=D
    <- lookup-respects-eq L1P eq/ nat`eq/ DP=D L1.

- : fresh-add-right-preserves-lookup-converse/L
     L3 F2 A (domain?/out F1) L1
    <- add-preserves-fresh* F1 F2 A F3
    <- fresh-lookup-not-equal F3 L3 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

%worlds () (fresh-add-right-preserves-lookup-converse/L _ _ _ _ _).
%total { } (fresh-add-right-preserves-lookup-converse/L _ _ _ _ _).

%worlds () (fresh-add-right-preserves-lookup-converse _ _ _ _).
%total { } (fresh-add-right-preserves-lookup-converse _ _ _ _).


%theorem add-right-affects-lookup :
	forall* {M1} {N} {D1} {M2} {M3}
	forall {L:lookup M1 N D1}
	       {A:add M1 M2 M3}
	exists {D3}
               {N:lookup M3 N D3}
	true.

%theorem add-right-affects-lookup/L :
	forall* {M1} {N} {D1} {M2} {M3} {B}
	forall {L:lookup M1 N D1}
	       {A:add M1 M2 M3}
	       {D:domain? M2 N B}
	exists {D3}
               {N:lookup M3 N D3}
	true.

- : add-right-affects-lookup/L L1 A (domain?/in L2) _ L3
    <- add-joins-lookup L1 L2 A _ _ L3.

- : add-right-affects-lookup/L L1 A (domain?/out F2) _ L3
    <- fresh-add-right-preserves-lookup* L1 F2 A L3.

%worlds () (add-right-affects-lookup/L _ _ _ _ _).
%total { } (add-right-affects-lookup/L _ _ _ _ _).

- : add-right-affects-lookup L1 A _ L3
    <- domain?-total D
    <- add-right-affects-lookup/L L1 A D _ L3.

%worlds () (add-right-affects-lookup _ _ _ _).
%total { } (add-right-affects-lookup _ _ _ _).


% TODO deprecate *
%theorem add-preserves-fresh-converse* :
	forall* {M1} {M2} {M3} {N}
	forall {F3:fresh M3 N}
               {A:add M1 M2 M3}
	exists {F1:fresh M1 N} {F2:fresh M2 N}
	true.

%theorem add-preserves-fresh-converse/L :
	forall* {M1} {M2} {M3} {N} {B1} {B2}
	forall {F3:fresh M3 N}
               {A:add M1 M2 M3}
               {D1:domain? M1 N B1}
               {D2:domain? M2 N B2}
	exists {F1:fresh M1 N} {F2:fresh M2 N}
	true.

- : add-preserves-fresh-converse* F3 A F1 F2
    <- domain?-total D1
    <- domain?-total D2
    <- add-preserves-fresh-converse/L F3 A D1 D2 F1 F2.

- : add-preserves-fresh-converse/L _ _
     (domain?/out F1) (domain?/out F2) F1 F2.

- : add-preserves-fresh-converse/L F3 A
     (domain?/out F1) (domain?/in L2) F1 F2
    <- fresh-add-left-preserves-lookup* F1 L2 A L3
    <- fresh-lookup-not-equal F3 L3 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-fresh F F2.

- : add-preserves-fresh-converse/L F3 A
     (domain?/in L1) (domain?/out F2) F1 F2
    <- fresh-add-right-preserves-lookup* L1 F2 A L3
    <- fresh-lookup-not-equal F3 L3 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-fresh F F1.

- : add-preserves-fresh-converse/L F3 A
     (domain?/in L1) (domain?/in L2) F1 F2
    <- add-joins-lookup L1 L2 A _ _ L3
    <- fresh-lookup-not-equal F3 L3 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-fresh F F1
    <- false-implies-fresh F F2.

%worlds () (add-preserves-fresh-converse/L _ _ _ _ _ _).
%total { } (add-preserves-fresh-converse/L _ _ _ _ _ _).

%worlds () (add-preserves-fresh-converse* _ _ _ _).
%total { } (add-preserves-fresh-converse* _ _ _ _).


%theorem disjoint-add-cross-comparable :
	forall* {C} {C1} {C2} {C3} {C4}
	forall	{D12:disjoint C1 C2}
		{A12:add C1 C2 C} 
		{D34:disjoint C3 C4}
		{A34:add C3 C4 C}
	exists {C13} {C14} {C23} {C24}
	       {A1:add C13 C14 C1} {A2:add C23 C24 C2}
	       {A3:add C13 C23 C3} {A4:add C14 C24 C4}
	true.

%{%
NB: The client can easily prove all pieces are mutually disjoint.
For example C13 ^ C14 because C13 <= C3 and C14 <= C4 and C3^C4
            C13 ^ C23 because C13 <= C1 and C23 <= C2 and C1^C2
%}%

- : disjoint-add-cross-comparable _ add/L _ C3+C4=C2 _ _ _ _ add/L C3+C4=C2 add/L add/L.

- : disjoint-add-cross-comparable _ add/R _ C3+C4=C1 _ _ _ _ C3+C4=C1 add/R add/R add/R.

- : disjoint-add-cross-comparable _ C1+C2=C4 _ add/L _ _ _ _ add/L add/L add/L C1+C2=C4.

- : disjoint-add-cross-comparable _ C1+C2=C3 _ add/R _ _ _ _ add/R add/R C1+C2=C3 add/R.

- : disjoint-add-cross-comparable D (add/= _ _ nat`eq/) _ _ _ _ _ _
	add/L add/L J1 J2
    <- disjoint/=-contradiction D nat`eq/ F
    <- false-implies-add F J1
    <- false-implies-add F J2.

- : disjoint-add-cross-comparable _ _ D (add/= _ _ nat`eq/) _ _ _ _
	add/L add/L J1 J2
    <- disjoint/=-contradiction D nat`eq/ F
    <- false-implies-add F J1
    <- false-implies-add F J2.

- : disjoint-add-cross-comparable 
	D12 (add/< C1+CX2=C N0+1+N1=N2)
	D34 (add/< C3+CX4=C N5+1+N3=N4) _ _ _ _ % NB N1=N3=N
	CY1Y3+CY14=CY1 C2Y3+C24=C2
	CY1Y3+C2Y3=CY3 CY14+C24=C4
    <- disjoint/<-inversion D12 N0+1+N1=N2 D12P
    <- disjoint/<-inversion D34 N5+1+N3=N4 D34P
    <- disjoint-add-cross-comparable D12P C1+CX2=C D34P C3+CX4=C 
	C13 C1X4 CX23 CX2X4
	C13+C1X4=C1 CX23+CX2X4=CX2 C13+CX23=C3 C1X4+CX2X4=CX4
    <- shift-total C1X4<<N=CY14
    <- shift-total CX23<<N=C2Y3
    <- shift-total CX2X4<<N=C24
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-right-preserves-add C13+C1X4=C1 C1X4<<N=CY14 CY1Y3+CY14=CY1
    <- shift-preserves-add* CX23+CX2X4=CX2 
	CX23<<N=C2Y3 CX2X4<<N=C24 (shift/+ N1+1+N0=N2) C2Y3+C24=C2
    <- shift-right-preserves-add C13+CX23=C3 CX23<<N=C2Y3 CY1Y3+C2Y3=CY3
    <- plus-swap-succ N5+1+N3=N4 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- shift-preserves-add* C1X4+CX2X4=CX4
	C1X4<<N=CY14 CX2X4<<N=C24 (shift/+ N3+1+N5=N4) CY14+C24=C4.

- : disjoint-add-cross-comparable 
	D12 (add/< C1+CX2=C N0+1+N1=N2)
	D34 (add/> CX3+C4=C N5+1+N4=N3) _ _ _ _ % NB N1=N4=N
	CY13+CY1Y4=CY1 C23+C2Y4=C2 CY13+C23=C3 CY1Y4+C2Y4=CY4
    <- disjoint/<-inversion D12 N0+1+N1=N2 D12P
    <- disjoint/>-inversion D34 N5+1+N4=N3 D34P
    <- disjoint-add-cross-comparable D12P C1+CX2=C D34P CX3+C4=C 
	C1X3 C14 CX2X3 CX24
	C1X3+C14=C1 CX2X3+CX24=CX2 C1X3+CX2X3=CX3 C14+CX24=C4
    <- shift-total C1X3<<N=CY13
    <- shift-total CX2X3<<N=C23
    <- shift-total CX24<<N=C2Y4
    <- shift-left-preserves-add C1X3+C14=C1 C1X3<<N=CY13 CY13+CY1Y4=CY1
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-preserves-add* CX2X3+CX24=CX2 
	CX2X3<<N=C23 CX24<<N=C2Y4 (shift/+ N1+1+N0=N2) C23+C2Y4=C2
    <- plus-swap-succ N5+1+N4=N3 N5+N4+1=N3
    <- plus-commutative N5+N4+1=N3 N4+1+N5=N3
    <- shift-preserves-add* C1X3+CX2X3=CX3
	C1X3<<N=CY13 CX2X3<<N=C23 (shift/+ N4+1+N5=N3) CY13+C23=C3
    <- shift-right-preserves-add C14+CX24=C4 CX24<<N=C2Y4 CY1Y4+C2Y4=CY4.

- : disjoint-add-cross-comparable 
	D12 (add/> CX1+C2=C N0+1+N2=N1)
        D34 (add/< C3+CX4=C N5+1+N3=N4) _ _ _ _ % NB N2=N3=N
 	C1Y3+C14=C1 CY2Y3+CY24=CY2 C1Y3+CY2Y3=CY3 C14+CY24=C4
    <- disjoint/>-inversion D12 N0+1+N2=N1 D12P
    <- disjoint/<-inversion D34 N5+1+N3=N4 D34P
    <- disjoint-add-cross-comparable D12P CX1+C2=C D34P C3+CX4=C 
	CX13 CX1X4 C23 C2X4
	CX13+CX1X4=CX1 C23+C2X4=C2 CX13+C23=C3 CX1X4+C2X4=CX4
    <- shift-total CX13<<N=C1Y3
    <- shift-total CX1X4<<N=C14
    <- shift-total C2X4<<N=CY24
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-commutative N0+N2+1=N1 N2+1+N0=N1
    <- shift-preserves-add* CX13+CX1X4=CX1 
	CX13<<N=C1Y3 CX1X4<<N=C14 (shift/+ N2+1+N0=N1) C1Y3+C14=C1
    <- shift-right-preserves-add C23+C2X4=C2 C2X4<<N=CY24 CY2Y3+CY24=CY2
    <- shift-left-preserves-add CX13+C23=C3 CX13<<N=C1Y3 C1Y3+CY2Y3=CY3
    <- plus-swap-succ N5+1+N3=N4 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- shift-preserves-add* CX1X4+C2X4=CX4
	CX1X4<<N=C14 C2X4<<N=CY24 (shift/+ N3+1+N5=N4) C14+CY24=C4.

- : disjoint-add-cross-comparable 
	D12 (add/> CX1+C2=C N0+1+N2=N1)
	D34 (add/> CX3+C4=C N5+1+N4=N3) _ _ _ _ % NB N2=N4=N
	C13+C1Y4=C1 CY23+CY2Y4=CY2 C13+CY23=C3 C1Y4+CY2Y4=CY4
    <- disjoint/>-inversion D12 N0+1+N2=N1 D12P
    <- disjoint/>-inversion D34 N5+1+N4=N3 D34P
    <- disjoint-add-cross-comparable D12P CX1+C2=C D34P CX3+C4=C 
	CX1X3 CX14 C2X3 C2C4
	CX1X3+CX14=CX1 C2X3+C24=C2 CX1X3+C2X3=CX3 CX14+C24=C4
    <- shift-total CX1X3<<N=C13
    <- shift-total CX14<<N=C1Y4
    <- shift-total C2X3<<N=CY23
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-commutative N0+N2+1=N1 N2+1+N0=N1
    <- shift-preserves-add* CX1X3+CX14=CX1 
	CX1X3<<N=C13 CX14<<N=C1Y4 (shift/+ N2+1+N0=N1) C13+C1Y4=C1
    <- shift-left-preserves-add C2X3+C24=C2 C2X3<<N=CY23 CY23+CY2Y4=CY2
    <- plus-swap-succ N5+1+N4=N3 N5+N4+1=N3
    <- plus-commutative N5+N4+1=N3 N4+1+N5=N3
    <- shift-preserves-add* CX1X3+C2X3=CX3
	CX1X3<<N=C13 C2X3<<N=CY23 (shift/+ N4+1+N5=N3) C13+CY23=C3
    <- shift-left-preserves-add CX14+C24=C4 CX14<<N=C1Y4 C1Y4+CY2Y4=CY4.

%worlds () (disjoint-add-cross-comparable _ _ _ _ _ _ _ _ _ _ _ _).
%total (A) (disjoint-add-cross-comparable _ A _ _ _ _ _ _ _ _ _ _).


%theorem disjoint-add-left-preserves-lookup* :
	forall* {M1} {M2} {M3} {N} {D}
	forall {L2:lookup M2 N D}
               {X:disjoint M1 M2}
               {A:add M1 M2 M3}
	exists {L3:lookup M3 N D}
	true.

%theorem disjoint-add-left-preserves-lookup*/L :
	forall* {M1} {M2} {M3} {N} {D} {B}
	forall {L2:lookup M2 N D}
               {X:disjoint M1 M2}
               {A:add M1 M2 M3}
               {D?:domain? M1 N B}
	exists {L3:lookup M3 N D}
	true.

- : disjoint-add-left-preserves-lookup* L2 X A L3
    <- domain?-total D?
    <- disjoint-add-left-preserves-lookup*/L L2 X A D? L3.

- : disjoint-add-left-preserves-lookup*/L L2 X A (domain?/in L1) L3
    <- disjoint-lookup-contradiction X L1 L2 F
    <- false-implies-lookup F L3.

- : disjoint-add-left-preserves-lookup*/L L2 X A (domain?/out F1) L3
    <- fresh-add-left-preserves-lookup* F1 L2 A L3.

%worlds () (disjoint-add-left-preserves-lookup*/L _ _ _ _ _).
%total { } (disjoint-add-left-preserves-lookup*/L _ _ _ _ _).

%worlds () (disjoint-add-left-preserves-lookup* _ _ _ _).
%total { } (disjoint-add-left-preserves-lookup* _ _ _ _).


%theorem disjoint-add-right-preserves-lookup* :
	forall* {M1} {M2} {M3} {N} {D}
	forall {L1:lookup M1 N D}
               {X:disjoint M1 M2}
               {A:add M1 M2 M3}
	exists {L3:lookup M3 N D}
	true.

%theorem disjoint-add-right-preserves-lookup*/L :
	forall* {M1} {M2} {M3} {N} {D} {B}
	forall {L1:lookup M1 N D}
               {X:disjoint M1 M2}
               {A:add M1 M2 M3}
               {D?:domain? M2 N B}
	exists {L3:lookup M3 N D}
	true.

- : disjoint-add-right-preserves-lookup* L1 X A L3
    <- domain?-total D?
    <- disjoint-add-right-preserves-lookup*/L L1 X A D? L3.

- : disjoint-add-right-preserves-lookup*/L L1 X A (domain?/in L2) L3
    <- disjoint-lookup-contradiction X L1 L2 F
    <- false-implies-lookup F L3.

- : disjoint-add-right-preserves-lookup*/L L1 X A (domain?/out F2) L3
    <- fresh-add-right-preserves-lookup* L1 F2 A L3.

%worlds () (disjoint-add-right-preserves-lookup*/L _ _ _ _ _).
%total { } (disjoint-add-right-preserves-lookup*/L _ _ _ _ _).

%worlds () (disjoint-add-right-preserves-lookup* _ _ _ _).
%total { } (disjoint-add-right-preserves-lookup* _ _ _ _).


%theorem add-cross-comparable :
	forall* {C} {C1} {C2} {C3} {C4}
	forall {A12:add C1 C2 C} {A34:add C3 C4 C}
	exists {C13} {C14} {C23} {C24}
	       {A1:add C13 C14 C1} {A2:add C23 C24 C2}
	       {A3:add C13 C23 C3} {A4:add C14 C24 C4}
	true.

- : add-cross-comparable add/L C3+C4=C2 _ _ _ _ add/L C3+C4=C2 add/L add/L.

- : add-cross-comparable add/R C3+C4=C1 _ _ _ _ C3+C4=C1 add/R add/R add/R.

- : add-cross-comparable C1+C2=C4 add/L _ _ _ _ add/L add/L add/L C1+C2=C4.

- : add-cross-comparable C1+C2=C3 add/R _ _ _ _ add/R add/R C1+C2=C3 add/R.

- : add-cross-comparable (add/= C1+C2=C Q1+Q2=Q nat`eq/)
                         (add/= C3+C4=C Q3+Q4=Q nat`eq/) _ _ _ _
                         (add/= C13+C14=C1 Q13+Q14=Q1 nat`eq/)
                         (add/= C23+C24=C2 Q23+Q24=Q2 nat`eq/)
                         (add/= C13+C23=C3 Q13+Q23=Q3 nat`eq/)
                         (add/= C14+C24=C4 Q14+Q24=Q4 nat`eq/)
    <- add-cross-comparable C1+C2=C C3+C4=C _ _ _ _ 
                            C13+C14=C1 C23+C24=C2 C13+C23=C3 C14+C24=C4
    <- canonical`add-cross-comparable Q1+Q2=Q Q3+Q4=Q _ _ _ _ 
                                Q13+Q14=Q1 Q23+Q24=Q2 Q13+Q23=Q3 Q14+Q24=Q4.

- : add-cross-comparable (add/= C1+C2=C Q1+Q2=Q nat`eq/)
                         (add/< C3+CX4=C N5+1+N3=N4) _ _ _ _
                         CY1Y3+CY14=CY1
                         CY2Y3+CY24=CY2
			 (add/= C13+C23=C3 Q1+Q2=Q nat`eq/)
			 CY14+CY24=C4
    <- add-cross-comparable C1+C2=C C3+CX4=C C13 C1X4 C23 C2X4 
                            C13+C1X4=C1 C23+C2X4=C2 C13+C23=C3 C1X4+C2X4=CX4
    <- shift-total C1X4<<N=CY14
    <- shift-total C2X4<<N=CY24
    <- plus-swap-succ N5+1+N3=N4 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- shift-right-preserves-add C13+C1X4=C1 C1X4<<N=CY14 CY1Y3+CY14=CY1
    <- shift-right-preserves-add C23+C2X4=C2 C2X4<<N=CY24 CY2Y3+CY24=CY2
    <- shift-preserves-add* C1X4+C2X4=CX4 C1X4<<N=CY14 C2X4<<N=CY24 
                             (shift/+ N3+1+N5=N4) CY14+CY24=C4.

- : add-cross-comparable (add/= C1+C2=C Q1+Q2=Q nat`eq/)
                         (add/> CX3+C4=C N5+1+N4=N3) _ _ _ _
                         CY13+CY1Y4=CY1
                         CY23+CY2Y4=CY2
			 CY13+CY23=C3
			 (add/= C14+C24=C4 Q1+Q2=Q nat`eq/)
    <- add-cross-comparable C1+C2=C CX3+C4=C C1X3 C14 C2X3 C24 
                            C1X3+C14=C1 C2X3+C24=C2 C1X3+C2X3=CX3 C14+C24=C4
    <- shift-total C1X3<<N=CY13
    <- shift-total C2X3<<N=CY23
    <- plus-swap-succ N5+1+N4=N3 N5+N4+1=N3
    <- plus-commutative N5+N4+1=N3 N4+1+N5=N3
    <- shift-left-preserves-add C1X3+C14=C1 C1X3<<N=CY13 CY13+CY1Y4=CY1
    <- shift-left-preserves-add C2X3+C24=C2 C2X3<<N=CY23 CY23+CY2Y4=CY2
    <- shift-preserves-add* C1X3+C2X3=CX3 C1X3<<N=CY13 C2X3<<N=CY23 
                             (shift/+ N4+1+N5=N3) CY13+CY23=C3.


- : add-cross-comparable (add/< C1+CX2=C N0+1+N1=N2)
			 (add/= C3+C4=C Q3+Q4=Q nat`eq/) _ _ _ _
			 (add/= C13+C14=C1 Q3+Q4=Q nat`eq/)
                         C23+C24=C2
                         CY1Y3+C2Y3=CY3
                         CY1Y4+C2Y4=CY4
    <- add-cross-comparable C1+CX2=C C3+C4=C C13 C14 CX23 CX24 
                            C13+C14=C1 CX23+CX24=CX2 C13+CX23=C3 C14+CX24=C4
    <- shift-total CX23<<N=C2Y3
    <- shift-total CX24<<N=C2Y4
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-right-preserves-add C13+CX23=C3 CX23<<N=C2Y3 CY1Y3+C2Y3=CY3
    <- shift-right-preserves-add C14+CX24=C4 CX24<<N=C2Y4 CY1Y4+C2Y4=CY4
    <- shift-preserves-add* CX23+CX24=CX2 CX23<<N=C2Y3 CX24<<N=C2Y4 
			     (shift/+ N1+1+N0=N2) C23+C24=C2.

- : add-cross-comparable (add/> CX1+C2=C N0+1+N2=N1)
			 (add/= C3+C4=C Q3+Q4=Q nat`eq/) _ _ _ _
                         C13+C14=C1
			 (add/= C23+C24=C2 Q3+Q4=Q nat`eq/)
			 C1Y3+CY2Y3=CY3
                         C1Y4+CY2Y4=CY4
    <- add-cross-comparable CX1+C2=C C3+C4=C _ _ _ _ 
                            CX13+CX14=CX1 C23+C24=C2 CX13+C23=C3 CX14+C24=C4
    <- shift-total CX13<<N=C1Y3
    <- shift-total CX14<<N=C1Y4
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-commutative N0+N2+1=N1 N2+1+N0=N1
    <- shift-left-preserves-add CX13+C23=C3 CX13<<N=C1Y3 C1Y3+CY2Y3=CY3
    <- shift-left-preserves-add CX14+C24=C4 CX14<<N=C1Y4 C1Y4+CY2Y4=CY4
    <- shift-preserves-add* CX13+CX14=CX1 CX13<<N=C1Y3 CX14<<N=C1Y4 
			     (shift/+ N2+1+N0=N1) C13+C14=C1.

- : add-cross-comparable (add/< C1+CX2=C N0+1+N1=N2)
                         (add/< C3+CX4=C N5+1+N3=N4) _ _ _ _ % NB N1=N3=N
                         CY1Y3+CY14=CY1
			 C2Y3+C24=C2
			 CY1Y3+C2Y3=CY3
			 CY14+C24=C4
    <- add-cross-comparable C1+CX2=C C3+CX4=C C13 C1X4 CX23 CX2X4
	C13+C1X4=C1 CX23+CX2X4=CX2 C13+CX23=C3 C1X4+CX2X4=CX4
    <- shift-total C1X4<<N=CY14
    <- shift-total CX23<<N=C2Y3
    <- shift-total CX2X4<<N=C24
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-right-preserves-add C13+C1X4=C1 C1X4<<N=CY14 CY1Y3+CY14=CY1
    <- shift-preserves-add* CX23+CX2X4=CX2 
	CX23<<N=C2Y3 CX2X4<<N=C24 (shift/+ N1+1+N0=N2) C2Y3+C24=C2
    <- shift-right-preserves-add C13+CX23=C3 CX23<<N=C2Y3 CY1Y3+C2Y3=CY3
    <- plus-swap-succ N5+1+N3=N4 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- shift-preserves-add* C1X4+CX2X4=CX4
	C1X4<<N=CY14 CX2X4<<N=C24 (shift/+ N3+1+N5=N4) CY14+C24=C4.

- : add-cross-comparable (add/< C1+CX2=C N0+1+N1=N2)
                         (add/> CX3+C4=C N5+1+N4=N3) _ _ _ _ % NB N1=N4=N
                         CY13+CY1Y4=CY1
			 C23+C2Y4=C2
			 CY13+C23=C3
			 CY1Y4+C2Y4=CY4
    <- add-cross-comparable C1+CX2=C CX3+C4=C C1X3 C14 CX2X3 CX24
	C1X3+C14=C1 CX2X3+CX24=CX2 C1X3+CX2X3=CX3 C14+CX24=C4
    <- shift-total C1X3<<N=CY13
    <- shift-total CX2X3<<N=C23
    <- shift-total CX24<<N=C2Y4
    <- shift-left-preserves-add C1X3+C14=C1 C1X3<<N=CY13 CY13+CY1Y4=CY1
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-preserves-add* CX2X3+CX24=CX2 
	CX2X3<<N=C23 CX24<<N=C2Y4 (shift/+ N1+1+N0=N2) C23+C2Y4=C2
    <- plus-swap-succ N5+1+N4=N3 N5+N4+1=N3
    <- plus-commutative N5+N4+1=N3 N4+1+N5=N3
    <- shift-preserves-add* C1X3+CX2X3=CX3
	C1X3<<N=CY13 CX2X3<<N=C23 (shift/+ N4+1+N5=N3) CY13+C23=C3
    <- shift-right-preserves-add C14+CX24=C4 CX24<<N=C2Y4 CY1Y4+C2Y4=CY4.


- : add-cross-comparable (add/> CX1+C2=C N0+1+N2=N1)
                         (add/< C3+CX4=C N5+1+N3=N4) _ _ _ _ % NB N2=N3=N
			 C1Y3+C14=C1
                         CY2Y3+CY24=CY2
			 C1Y3+CY2Y3=CY3
			 C14+CY24=C4
    <- add-cross-comparable CX1+C2=C C3+CX4=C CX13 CX1X4 C23 C2X4
	CX13+CX1X4=CX1 C23+C2X4=C2 CX13+C23=C3 CX1X4+C2X4=CX4
    <- shift-total CX13<<N=C1Y3
    <- shift-total CX1X4<<N=C14
    <- shift-total C2X4<<N=CY24
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-commutative N0+N2+1=N1 N2+1+N0=N1
    <- shift-preserves-add* CX13+CX1X4=CX1 
	CX13<<N=C1Y3 CX1X4<<N=C14 (shift/+ N2+1+N0=N1) C1Y3+C14=C1
    <- shift-right-preserves-add C23+C2X4=C2 C2X4<<N=CY24 CY2Y3+CY24=CY2
    <- shift-left-preserves-add CX13+C23=C3 CX13<<N=C1Y3 C1Y3+CY2Y3=CY3
    <- plus-swap-succ N5+1+N3=N4 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- shift-preserves-add* CX1X4+C2X4=CX4
	CX1X4<<N=C14 C2X4<<N=CY24 (shift/+ N3+1+N5=N4) C14+CY24=C4.

- : add-cross-comparable (add/> CX1+C2=C N0+1+N2=N1)
                         (add/> CX3+C4=C N5+1+N4=N3) _ _ _ _ % NB N2=N4=N
			 C13+C1Y4=C1
                         CY23+CY2Y4=CY2
			 C13+CY23=C3
			 C1Y4+CY2Y4=CY4
    <- add-cross-comparable CX1+C2=C CX3+C4=C CX1X3 CX14 C2X3 C2C4
	CX1X3+CX14=CX1 C2X3+C24=C2 CX1X3+C2X3=CX3 CX14+C24=C4
    <- shift-total CX1X3<<N=C13
    <- shift-total CX14<<N=C1Y4
    <- shift-total C2X3<<N=CY23
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-commutative N0+N2+1=N1 N2+1+N0=N1
    <- shift-preserves-add* CX1X3+CX14=CX1 
	CX1X3<<N=C13 CX14<<N=C1Y4 (shift/+ N2+1+N0=N1) C13+C1Y4=C1
    <- shift-left-preserves-add C2X3+C24=C2 C2X3<<N=CY23 CY23+CY2Y4=CY2
    <- plus-swap-succ N5+1+N4=N3 N5+N4+1=N3
    <- plus-commutative N5+N4+1=N3 N4+1+N5=N3
    <- shift-preserves-add* CX1X3+C2X3=CX3
	CX1X3<<N=C13 C2X3<<N=CY23 (shift/+ N4+1+N5=N3) C13+CY23=C3
    <- shift-left-preserves-add CX14+C24=C4 CX14<<N=C1Y4 C1Y4+CY2Y4=CY4.

%worlds () (add-cross-comparable _ _ _ _ _ _ _ _ _ _).
%total (A) (add-cross-comparable A _ _ _ _ _ _ _ _ _).


%theorem fresh-update-implies-unit-add:
	forall*	{M} {N} {D} {MP}
	forall	{F: fresh M N}
		{U: update M N D MP}
	exists	{J: add M (map/+ N D map/0) MP}
	true.

- : fresh-update-implies-unit-add
	fresh/0 update/0 add/L.

- : fresh-update-implies-unit-add
	(fresh/< N1>N2) U J
    <- nat`gt-implies-plus N1>N2 N3 SN3+N2=N1
    <- update/<-inversion U SN3+N2=N1 EQ
    <- add-respects-eq  (add/> add/R SN3+N2=N1) eq/ eq/ EQ J.

- : fresh-update-implies-unit-add
	(fresh/> F SN0+N1=N2) U J
    <- update/>-inversion U SN0+N1=N2 M1 U1 EQ
    <- fresh-update-implies-unit-add F U1 JP
    <- add-respects-eq (add/< JP SN0+N1=N2) eq/ eq/ EQ J.

%worlds () (fresh-update-implies-unit-add _ _ _).
%total (F) (fresh-update-implies-unit-add F _ _).


%theorem fresh-unit-add-implies-update:
	forall*	{M} {N} {D} {MP}
	forall	{F: fresh M N}
		{J: add M (map/+ N D map/0) MP}
	exists	{U: update M N D MP}
	true.

- : fresh-unit-add-implies-update _ add/L update/0.

- : fresh-unit-add-implies-update
	FR (add/= _ _ nat`eq/) U
    <- fresh-contradiction FR F
    <- false-implies-update F U.

- : fresh-unit-add-implies-update
	F (add/< J1 P) (update/> U1 P)
    <- fresh/>-inversion F P F1
    <- fresh-unit-add-implies-update F1 J1 U1.

- : fresh-unit-add-implies-update
	F (add/> J1 P) U
    <- add-deterministic add/R J1 eq/ eq/ ME
    <- map/+-preserves-eq nat`eq/ canonical`eq/ ME ME2
    <- update-respects-eq (update/< P) eq/ nat`eq/ canonical`eq/ ME2 U.

%worlds () (fresh-unit-add-implies-update _ _ _).
%total (J) (fresh-unit-add-implies-update _ J _).


%theorem fresh-update-left-preserves-add-converse
  : forall* {M1} {M1P} {M2} {M} {N} {D} 
    forall {F1: fresh M1P N}
    {U1: update M1P N D M1}
    {F2: fresh M2 N}
    {J: add M1 M2 M}
    exists {MP} {F: fresh MP N}
    {U: update MP N D M}
    {J: add M1P M2 MP}
    true.

- : fresh-update-left-preserves-add-converse
    N!<M1P M1P+N+D=M1 N!<M2 M1+M2=M MP N!<MP MP+N+D=M M1P+M2=MP
    <- fresh-update-implies-unit-add N!<M1P M1P+N+D=M1 M1P+D=M1
    <- add-associative M1P+D=M1 M1+M2=M DM2 D+M2=DM2 M1P+DM2=M
    <- fresh-implies-unit-disjoint N!<M2 M2^D
    <- disjoint-symmetric M2^D D^M2
    <- disjoint-add-commutative D^M2 D+M2=DM2 M2+D=DM2
    <- add-associative-converse M2+D=DM2 M1P+DM2=M MP M1P+M2=MP MP+D=M
    <- add-preserves-fresh* N!<M1P N!<M2 M1P+M2=MP N!<MP
    <- fresh-unit-add-implies-update N!<MP MP+D=M MP+N+D=M.

%worlds () (fresh-update-left-preserves-add-converse _ _ _ _ _ _ _ _).
%total {} (fresh-update-left-preserves-add-converse _ _ _ _ _ _ _ _).


%theorem fresh-update-left-preserves-add-converse*
  : forall* {M1} {M1P} {M2} {M} {MP} {N} {D} 
    forall {F1: fresh M1P N}
    {U1: update M1P N D M1}
    {F2: fresh M2 N}
    {J: add M1 M2 M}
    {F: fresh MP N}
    {U: update MP N D M}
    exists {J: add M1P M2 MP}
    true.

- : fresh-update-left-preserves-add-converse*
    N!<M1P M1P+N+D=M1 N!<M2 M1+M2=M N!<MP MP+N+D=M M1P+M2=MP
    <- fresh-update-left-preserves-add-converse
      N!<M1P M1P+N+D=M1 N!<M2 M1+M2=M MQ N!<MQ MQ+N+D=M M1P+M2=MQ
    <- fresh-update-cancels N!<MQ MQ+N+D=M N!<MP MP+N+D=M nat`eq/ eq/ _ ME
    <- add-respects-eq M1P+M2=MQ eq/ eq/ ME M1P+M2=MP.

%worlds () (fresh-update-left-preserves-add-converse* _ _ _ _ _ _ _).
%total {} (fresh-update-left-preserves-add-converse* _ _ _ _ _ _ _).


%theorem fresh-update-right-preserves-add-converse
  : forall* {M1} {M2} {M2P} {M} {N} {D} 
    forall {F1: fresh M1 N}
    {F2: fresh M2P N}
    {U2: update M2P N D M2}
    {J: add M1 M2 M}
    exists {MP} {F: fresh MP N}
    {U: update MP N D M}
    {J: add M1 M2P MP}
    true.

- : fresh-update-right-preserves-add-converse
    N!<M1 N!<M2P M2P+N+D=M1 M1+M2=M MP N!<MP MP+N+D=M M1+M2P=MP
    <- fresh-update-implies-unit-add N!<M2P M2P+N+D=M1 M2P+D=M2
    <- add-associative-converse M2P+D=M2 M1+M2=M MP M1+M2P=MP MP+D=M
    <- add-preserves-fresh* N!<M1 N!<M2P M1+M2P=MP N!<MP
    <- fresh-unit-add-implies-update N!<MP MP+D=M MP+N+D=M.

%worlds () (fresh-update-right-preserves-add-converse _ _ _ _ _ _ _ _).
%total {} (fresh-update-right-preserves-add-converse _ _ _ _ _ _ _ _).


%theorem fresh-update-right-preserves-add-converse*
  : forall* {M1} {M2} {M2P} {M} {MP} {N} {D} 
    forall {F1: fresh M1 N}
    {F2: fresh M2P N}
    {F2: update M2P N D M2}
    {J: add M1 M2 M}
    {F: fresh MP N}
    {U: update MP N D M}
    exists {J: add M1 M2P MP}
    true.

- : fresh-update-right-preserves-add-converse*
    N!<M1 N!<M2P M2P+N+D=M1 M1+M2=M N!<MP MP+N+D=M M1+M2P=MP
    <- fresh-update-right-preserves-add-converse
      N!<M1 N!<M2P M2P+N+D=M1 M1+M2=M MQ N!<MQ MQ+N+D=M M1+M2P=MQ
    <- fresh-update-cancels N!<MQ MQ+N+D=M N!<MP MP+N+D=M nat`eq/ eq/ _ ME
    <- add-respects-eq M1+M2P=MQ eq/ eq/ ME M1+M2P=MP.

%worlds () (fresh-update-right-preserves-add-converse* _ _ _ _ _ _ _).
%total {} (fresh-update-right-preserves-add-converse* _ _ _ _ _ _ _).


%theorem fresh-update-preserves-add-converse
  : forall* {M1P} {M2P} {N} {D1} {D2} {M1} {M2} {M}
    forall {F1: fresh M1P N}
    {U1: update M1P N D1 M1}
    {F2: fresh M2P N}
    {U2: update M2P N D2 M2}
    {J: add M1 M2 M}
    exists {MP} {D}
    {F: fresh MP N}
    {U: update MP N D M}
    {DJ: canonical`add D1 D2 D}
    {JP: add M1P M2P MP}
    true.

- : fresh-update-preserves-add-converse 
    N!<M1P M1P+N+D1=M1 N!<M2P M2P+N+D2=M2 M1+M2=M MP D N!<MP MP+N+D=M D1+D2=D M1P+M2P=MP 
    <- fresh-update-implies-unit-add N!<M1P M1P+N+D1=M1 M1P+D1=M1
    <- fresh-update-implies-unit-add N!<M2P M2P+N+D2=M2 M2P+D2=M2
    <- add-associative M1P+D1=M1 M1+M2=M D1M2 D1+M2=D1M2 M1P+D1M2=M
    <- fresh-implies-unit-disjoint N!<M2P M2P^D2
    <- disjoint-add-commutative M2P^D2 M2P+D2=M2 D2+M2P=M2
    <- add-associative-converse D2+M2P=M2 D1+M2=D1M2 D1D2 D1+D2=D1D2 D1D2+M2P=D1M2
    <- add/=-inversion D1+D2=D1D2 nat`eq/ _ _ D1+D2=D _ D1D2=D
    <- eq-symmetric D1D2=D D=D1D2
    <- fresh-implies-unit-disjoint N!<M2P M2P^D
    <- disjoint-respects-eq M2P^D eq/ D=D1D2 M2P^D1D2
    <- disjoint-symmetric M2P^D1D2 D1D2^M2P
    <- disjoint-add-commutative D1D2^M2P D1D2+M2P=D1M2 M2P+D1D2=D1M2
    <- add-associative-converse M2P+D1D2=D1M2 M1P+D1M2=M MP M1P+M2P=MP MP+D1D2=M
    <- add-respects-eq MP+D1D2=M eq/ D1D2=D eq/ MP+D=M
    <- add-preserves-fresh* N!<M1P N!<M2P M1P+M2P=MP N!<MP
    <- fresh-unit-add-implies-update N!<MP MP+D=M MP+N+D=M.

%worlds () (fresh-update-preserves-add-converse _ _ _ _ _ _ _ _ _ _ _).
%total {} (fresh-update-preserves-add-converse _ _ _ _ _ _ _ _ _ _ _).


%theorem fresh-update-preserves-add-converse*
  : forall* {M1P} {M2P} {N} {D1} {D2} {M1} {M2} {M} {MP} {D}
    forall {F1: fresh M1P N}
    {U1: update M1P N D1 M1}
    {F2: fresh M2P N}
    {U2: update M2P N D2 M2}
    {J: add M1 M2 M}
    {F: fresh MP N}
    {U: update MP N D M}
    {DJ: canonical`add D1 D2 D}
    exists {JP: add M1P M2P MP}
    true.

- : fresh-update-preserves-add-converse* F1 U1 F2 U2 J F U DJ JP
    <- fresh-update-preserves-add-converse F1 U1 F2 U2 J _ _ FP UP DJP JPP
    <- fresh-update-cancels FP UP F U nat`eq/ eq/ DE E
    <- add-respects-eq JPP eq/ eq/ E JP.

%worlds () (fresh-update-preserves-add-converse* _ _ _ _ _ _ _ _ _).
%total {} (fresh-update-preserves-add-converse* _ _ _ _ _ _ _ _ _).


%theorem add-preserves-fresh-update-left
  : forall* {M1} {M1S} {M2S} {MS} {N} {D} 
    forall {J: add M1S M2S MS}
    {F1: fresh M1S N}
    {U1: update M1S N D M1}
    {F2: fresh M2S N}
    exists {M} {F: fresh MS N}
    {U: update MS N D M}
    {J: add M1 M2S M}
    true.

- : add-preserves-fresh-update-left
    M1S+M2S=MS N!<M1S M1S+N+D=M1 N!<M2S M N!<MS MS+N+D=M M1+M2S=M
    <- fresh-update-implies-unit-add N!<M1S M1S+N+D=M1 M1S+D=M1
    <- add-preserves-fresh* N!<M1S N!<M2S M1S+M2S=MS N!<MS
    <- update-total MS+N+D=M
    <- fresh-update-implies-unit-add N!<MS MS+N+D=M MS+D=M
    <- fresh-implies-unit-disjoint N!<MS MS^M
    <- disjoint-add-commutative MS^M MS+D=M M+MS=M
    <- add-associative  M1S+M2S=MS MS+D=M MK M2S+D=MK M1S+MK=M
    <- fresh-implies-unit-disjoint N!<M2S M2S^M
    <- disjoint-add-commutative M2S^M M2S+D=MK M+M2S=MK
    <- add-associative-converse M+M2S=MK M1S+MK=M MQ M1S+D=MQ MQ+M2S=M
    <- fresh-unit-add-implies-update N!<M1S M1S+D=MQ M1S+N+D=MQ
    <- update-unique M1S+N+D=MQ M1S+N+D=M1 eq/ nat`eq/ canonical`eq/ MQ=M1
    <- add-respects-eq MQ+M2S=M MQ=M1 eq/ eq/ M1+M2S=M.

%worlds () (add-preserves-fresh-update-left _ _ _ _ _ _ _ _).
%total {} (add-preserves-fresh-update-left _ _ _ _ _ _ _ _).


%theorem bound-commute-add* :
	forall* {M1} {M2} {M3} {N1} {N2} {N3}
	forall	{B1: bound M1 N1}
		{B2: bound M2 N2}
		{B3: bound M3 N3}
		{J: add M1 M2 M3}
	exists	{MX: nat`max N1 N2 N3}
	true.

- : bound-commute-add* (bound/0) B2 B3 add/L M
    <- bound-unique B2 B3 eq/ N2=N3
    <- ge-zero-always _ N2>=0
    <- nat`le-implies-max N2>=0 MP
    <- nat`max-respects-eq MP nat`eq/ nat`eq/ N2=N3 M.

- : bound-commute-add* B1 (bound/0) B3 add/R M
    <- bound-unique B1 B3 eq/ N1=N3
    <- ge-zero-always _ N1>=0
    <- nat`ge-implies-max N1>=0 MP
    <- nat`max-respects-eq MP nat`eq/ nat`eq/ N1=N3 M.

- : bound-commute-add* 
	(bound/+ P1 B1) (bound/+ P2 B2) (bound/+ P3 B3)
	(add/= J _ nat`eq/) MP
    <- bound-commute-add* B1 B2 B3 J M
    <- plus-left-preserves-max M P1 P2 P3 MP.

- : bound-commute-add*
	(bound/+ P1 B1) (bound/+ P2 B2) (bound/+ P3 B3)
	(add/< J P) MP
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- plus-swap-succ P2 P2s
    <- plus-associative Psc P2s _ P2Ps PP2
    <- plus-swap-succ-converse P2Ps P2P
    <- bound-commute-add* B1 (bound/+ P2P B2) B3 J M
    <- plus-left-preserves-max M P1 PP2 P3 MP.

- : bound-commute-add*
	(bound/+ P1 B1) (bound/+ P2 B2) (bound/+ P3 B3)
	(add/> J P) MP
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- plus-swap-succ P1 P1s
    <- plus-associative Psc P1s _ P1Ps PP1
    <- plus-swap-succ-converse P1Ps P1P
    <- bound-commute-add* (bound/+ P1P B1) B2 B3 J M
    <- plus-left-preserves-max M PP1 P2 P3 MP.

%worlds () (bound-commute-add* _ _ _ _ _).
%total (J) (bound-commute-add* _ _ _ J _).


%theorem size-commute-disjoint-add*:
	forall* {M1} {M2} {M3} {N1} {N2} {N3}
	forall	{B1: size M1 N1}
		{B2: size M2 N2}
		{B3: size M3 N3}
		{DJ: disjoint M1 M2}
		{J: add M1 M2 M3}
	exists	{MX: nat`plus N1 N2 N3}
	true.

- : size-commute-disjoint-add* (size/0) B2 B3 _ add/L P
    <- size-unique B2 B3 eq/ N2=N3
    <- nat`plus-respects-eq plus/z nat`eq/ nat`eq/ N2=N3 P.

- : size-commute-disjoint-add* B1 (size/0) B3 _ add/R P
    <- size-unique B1 B3 eq/ N1=N3
    <- plus-right-identity N1 N1+0=N1
    <- nat`plus-respects-eq N1+0=N1 nat`eq/ nat`eq/ N1=N3 P.

- : size-commute-disjoint-add* _ _ _ DSJ
	(add/= J _ nat`eq/) P
    <- disjoint/=-contradiction DSJ nat`eq/ F
    <- nat`false-implies-plus F P.

- : size-commute-disjoint-add*
	(size/+ S1) (size/+ S2) (size/+ S3) DSJ
	(add/< J1 P1) (plus/s PP1)
    <- disjoint/<-inversion DSJ P1 DSJ1
    <- size-commute-disjoint-add* S1 (size/+ S2) S3 DSJ1 J1 PP1.

- : size-commute-disjoint-add*
	(size/+ S1) (size/+ S2) (size/+ S3) DSJ
	(add/> J1 P1) PP
    <- disjoint/>-inversion DSJ P1 DSJ1
    <- size-commute-disjoint-add* (size/+ S1) S2 S3 DSJ1 J1 PP1
    <- plus-right-increase PP1 PP.

%worlds () (size-commute-disjoint-add* _ _ _ _ _ _).
%total (J) (size-commute-disjoint-add* _ _ _ _ J _).


%theorem add-implies-leq* :
	forall* {M1} {M2} {M3}
	forall {J:add M1 M2 M3}
        exists {L:leq M1 M3}
	true.

- : add-implies-leq* add/L leq/0.

- : add-implies-leq* add/R M2=M2
    <- leq-reflexive _ M2=M2.

- : add-implies-leq* (add/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                      (leq/= M1<=M3 D1<=D3 nat`eq/)
    <- canonical`add-implies-leq* D1+D2=D3 D1<=D3
    <- add-implies-leq* M1+M2=M3 M1<=M3.

- : add-implies-leq* (add/< M1+_=M3 _) (leq/= M1<=M3 D1<=D1 nat`eq/)
    <- canonical`leq-reflexive _ D1<=D1
    <- add-implies-leq* M1+_=M3 M1<=M3.	

- : add-implies-leq* (add/> M311+M2=M3 P) (leq/> M311<=M3 P)
    <- add-implies-leq* M311+M2=M3 M311<=M3.

%worlds () (add-implies-leq* _ _).
%total (J) (add-implies-leq* J _).


%theorem add-implies-leq :
	forall* {M1} {M2} {M3}
	forall {A:add M1 M2 M3}
        exists {L1:leq M1 M3} {L2:leq M2 M3}
	true.

- : add-implies-leq M1*M2=M3 M1<=M3 M2<=M3
    <- add-implies-leq* M1*M2=M3 M1<=M3
    <- add-commutative M1*M2=M3 M2*M1=M3
    <- add-implies-leq* M2*M1=M3 M2<=M3.

%worlds () (add-implies-leq _ _ _).
%total { } (add-implies-leq _ _ _).


%theorem disjoint-leq-implies-add-leq* :
	forall* {C1} {C2} {C} {C3}
	forall	{D:disjoint C1 C2}
		{L1:leq C1 C}
		{L2:leq C2 C}
		{J:add C1 C2 C3}
	exists	{L3:leq C3 C}
	true.

- : disjoint-leq-implies-add-leq* disjoint/L _ C2<=C Z+C2=C3 C3<=C
    <- add-deterministic add/L Z+C2=C3 eq/ eq/ C2=C3
    <- leq-respects-eq C2<=C C2=C3 eq/ C3<=C.

- : disjoint-leq-implies-add-leq* disjoint/R C1<=C _ C1+0=C3 C3<=C
    <- add-deterministic add/R C1+0=C3 eq/ eq/ C1=C3
    <- leq-respects-eq C1<=C C1=C3 eq/ C3<=C.

- : disjoint-leq-implies-add-leq* 
	(disjoint/< C1^C022 P) 
	(leq/= C1<=C4 D1<=D4 nat`eq/) 
	C222<=C444 C111+C222=C333 C333<=C444
    <- add/<-inversion C111+C222=C333 P _ C1+C022=C5 C333=C115
    <- leq/>-inversion C222<=C444 P C022<=C4
    <- disjoint-leq-implies-add-leq* 
	C1^C022 C1<=C4 C022<=C4 C1+C022=C5 C5<=C4
    <- eq-symmetric C333=C115 C115=C333
    <- leq-respects-eq 
	(leq/= C5<=C4 D1<=D4 nat`eq/) C115=C333 eq/ C333<=C444.

- : disjoint-leq-implies-add-leq* (disjoint/< C1^C022 N0+1+N1=N2) (leq/> C611<=C4 N6+1+N4=N1) C222<=C444 C111+C222=C333 C333<=C444
    <- add/<-inversion C111+C222=C333 N0+1+N1=N2 _ C1+C022=C5 C333=C115
    <- plus-swap-succ N6+1+N4=N1 N6+N4+1=N1
    <- plus-associative-converse 
	N6+N4+1=N1 N0+1+N1=N2 N7 N0+1+N6=N7 N7+N4+1=N2
    <- plus-swap-succ-converse N7+N4+1=N2 N7+1+N4=N2
    <- leq/>-inversion C222<=C444 N7+1+N4=N2 C722<=C4
    <- disjoint-leq-implies-add-leq* 
	(disjoint/< C1^C022 N0+1+N6=N7) 
	C611<=C4 C722<=C4 
	(add/< C1+C022=C5 N0+1+N6=N7) C615<=C4
    <- eq-symmetric C333=C115 C115=C333
    <- leq-respects-eq 
	(leq/> C615<=C4 N6+1+N4=N1) C115=C333 eq/ C333<=C444.

- : disjoint-leq-implies-add-leq* 
	(disjoint/> C011^C2 P) 
	C111<=C444 (leq/= C2<=C4 D2<=D4 nat`eq/) 
	C111+C222=C333 C333<=C444
    <- add/>-inversion C111+C222=C333 P _ C011+C2=C5 C333=C225
    <- leq/>-inversion C111<=C444 P C011<=C4
    <- disjoint-leq-implies-add-leq* 
	C011^C2 C011<=C4 C2<=C4 C011+C2=C5 C5<=C4
    <- eq-symmetric C333=C225 C225=C333
    <- leq-respects-eq 
	(leq/= C5<=C4 D2<=D4 nat`eq/) C225=C333 eq/ C333<=C444.

- : disjoint-leq-implies-add-leq* 
	(disjoint/> C011^C2 N0+1+N2=N1) 
	C111<=C444 (leq/> C622<=C4 N6+1+N4=N2)
	C111+C222=C333 C333<=C444
    <- add/>-inversion C111+C222=C333 N0+1+N2=N1 _ C011+C2=C5 C333=C225
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-associative-converse 
	N6+N4+1=N2 N0+1+N2=N1 N7 N0+1+N6=N7 N7+N4+1=N1
    <- plus-swap-succ-converse N7+N4+1=N1 N7+1+N4=N1
    <- leq/>-inversion C111<=C444 N7+1+N4=N1 C711<=C4
    <- disjoint-leq-implies-add-leq* 
	(disjoint/> C011^C2 N0+1+N6=N7) 
	C711<=C4 C622<=C4 
	(add/> C011+C2=C5 N0+1+N6=N7) C625<=C4
    <- eq-symmetric C333=C225 C225=C333
    <- leq-respects-eq 
	(leq/> C625<=C4 N6+1+N4=N2) C225=C333 eq/ C333<=C444.

%worlds () (disjoint-leq-implies-add-leq* _ _ _ _ _).
%total (L) (disjoint-leq-implies-add-leq* _ L _ _ _).


%theorem add-left-preserves-leq* :
	forall* {M1} {M2} {M3} {M4} {M5}
	forall {L1:leq M2 M4}
               {J:add M1 M2 M3} {JP:add M1 M4 M5}
	exists {L3:leq M3 M5}
	true.

- : add-left-preserves-leq* L add/L add/L L.

- : add-left-preserves-leq* _ add/L add/R leq/0.

- : add-left-preserves-leq* leq/0 add/R M1+M4=M5 M1<=M5
    <- add-implies-leq* M1+M4=M5 M1<=M5.

- : add-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (add/= M1+M2=M3 D1+D2=D3 nat`eq/)
                             M111+M144=M M133<=M
    <- add/=-inversion M111+M144=M nat`eq/ D5 M5 D1+D4=D5 M1+M4=M5 M=M155
    <- eq-symmetric M=M155 M155=M
    <- meta-eq (map/+ N1 D5 M5) M M155=M
    <- canonical`add-left-preserves-leq* D2<=D4 D1+D2=D3 D1+D4=D5 D3<=D5
    <- add-left-preserves-leq* M2<=M4 M1+M2=M3 M1+M4=M5 M3<=M5
    <- leq-respects-eq (leq/= M3<=M5 D3<=D5 nat`eq/) eq/ M155=M M133<=M.

- : {M1+M044=M5:add M1 (map/+ N0 D4 M4) M5}
    {M115=M: eq (map/+ N1 D1 M5) M}
    add-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (add/< M1+M022=M3 N0+1+N1=N2)
                             M111+M244=M M113<=M
    <- add/<-inversion M111+M244=M N0+1+N1=N2 M5 M1+M044=M5 M=M115
    <- eq-symmetric M=M115 M115=M
    <- meta-eq (map/+ N1 D1 M5) M M115=M
    <- add-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/) 
                                M1+M022=M3 M1+M044=M5 M3<=M5
    <- canonical`leq-reflexive _ D1<=D1
    <- leq-respects-eq (leq/= M3<=M5 D1<=D1 nat`eq/) eq/ M115=M M113<=M.

- : add-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (add/> M311+M2=M3 N3+1+N2=N1)
                             M111+M244=M M223<=M
    <- add/>-inversion M111+M244=M N3+1+N2=N1 M5 M311+M4=M5 M=M245
    <- eq-symmetric M=M245 M245=M
    <- meta-eq (map/+ N2 D4 M5) M M245=M
    <- add-left-preserves-leq* M2<=M4 M311+M2=M3 M311+M4=M5 M3<=M5
    <- leq-respects-eq (leq/= M3<=M5 D2<=D4 nat`eq/) eq/ M245=M M223<=M.

- : add-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (add/= M1+M2=M3 D1+D2=D3 nat`eq/)   % N1=N2
                             M211+M444=M M233<=M
    <- add/>-inversion M211+M444=M N6+1+N4=N2 M5 M611+M4=M5 M=M445
    <- eq-symmetric M=M445 M445=M
    <- meta-eq (map/+ N4 D4 M5) M M445=M
    <- add-left-preserves-leq* M622<=M4 (add/= M1+M2=M3 D1+D2=D3 nat`eq/)
                                M611+M4=M5 M633<=M5
    <- leq-respects-eq (leq/> M633<=M5 N6+1+N4=N2) eq/ M445=M M233<=M.

- : add-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (add/< M1+M022=M3 N0+1+N4=N2)
                             (add/= M1+M4=M5 D1+D4=D5 nat`eq/)
                             (leq/= M3<=M5 D1<=D5 nat`eq/)
    <- nat`plus-right-cancels N6+1+N4=N2 N0+1+N4=N2 nat`eq/ nat`eq/ N6+1=N0+1
    <- nat`succ-cancels N6+1=N0+1 N6=N0
    <- map/+-preserves-eq N6=N0 canonical`eq/ eq/ M622=M022
    <- leq-respects-eq M622<=M4 M622=M022 eq/ M022<=M4
    <- add-left-preserves-leq* M022<=M4 M1+M022=M3 M1+M4=M5 M3<=M5
    <- canonical`add-implies-leq* D1+D4=D5 D1<=D5.

- : add-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (add/< M1+M022=M3 N0+1+N1=N2)
                             (add/< M1+M544=M5 N5+1+N1=N4)
                             (leq/= M3<=M5 D1<=D1 nat`eq/)
    <- nat`plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- nat`plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 
                                     N0P N6+1+N5=N0P N0P+N1+1=N2
    <- nat`plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- nat`plus-right-cancels N0P+N1+1=N2 N0+N1+1=N2 nat`eq/ nat`eq/ N0P=N0
    <- nat`plus-respects-eq N6+1+N5=N0P nat`eq/ nat`eq/ N0P=N0 N6+1+N5=N0
    <- add-left-preserves-leq* (leq/> M622<=M4 N6+1+N5=N0) 
                                M1+M022=M3 M1+M544=M5 M3<=M5
    <- canonical`leq-reflexive _ D1<=D1.
       

% for some reason, twelf needs a lot of help inferring types here:
- : add-left-preserves-leq* ((leq/> M622<=M4 N6+1+N4=N2):leq (map/+ N2 D2 M2) (map/+ N4 D4 M4))
                             (add/< M1+M022=M3 N0+1+N1=N2)
                             (add/> M511+M4=M5 N5+1+N4=N1)
                             (leq/> M513<=M5 N5+1+N4=N1)
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 
                                     N6P N0+1+N5=N6P N6P+N4+1=N2
    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- nat`plus-right-cancels N6P+N4+1=N2 N6+N4+1=N2 nat`eq/ nat`eq/ N6P=N6
    <- nat`plus-respects-eq N0+1+N5=N6P nat`eq/ nat`eq/ N6P=N6 N0+1+N5=N6
    <- add-left-preserves-leq* M622<=M4 
       ((add/< M1+M022=M3 N0+1+N5=N6):add (map/+ N5 D1 M1) (map/+ N6 D2 M2)
                                            (map/+ N5 D1 M3))
                                M511+M4=M5 M513<=M5.

- : add-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (add/> M311+M2=M3 N3+1+N2=N1) 
                             M111+M444=M M223<=M
    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- nat`plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 
                                     N5 N3+1+N6=N5 N5+N4+1=N1
    <- nat`plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1 
    <- add/>-inversion M111+M444=M N5+1+N4=N1 M5 M511+M4=M5 M=M445
    <- eq-symmetric M=M445 M445=M
    <- meta-eq _ _ M445=M
    <- add-left-preserves-leq* M622<=M4 (add/> M311+M2=M3 N3+1+N6=N5)
                                M511+M4=M5 M623<=M5
    <- leq-respects-eq (leq/> M623<=M5 N6+1+N4=N2) eq/ M445=M M223<=M.
  
%worlds () (add-left-preserves-leq* _ _ _ _).
%total (J) (add-left-preserves-leq* _ _ J _).




%theorem add-left-preserves-leq :
	forall* {X1} {X2} {X4}
      	forall {G:leq X2 X4}
	exists {X3} {X5}
               {O1:add X1 X2 X3} {O2:add X1 X4 X5}
      	       {G2:leq X3 X5}
	true.

- : add-left-preserves-leq X2<=X4 X3 X5 X1+X2=A3 X1+X4=X5 X3<=X5
    <- add-total X1+X2=A3 
    <- add-total X1+X4=X5
    <- add-left-preserves-leq* X2<=X4 X1+X2=A3 X1+X4=X5 X3<=X5.

%worlds () (add-left-preserves-leq X2<=X4 %{=>}% X3 X5 X1+X2=A3 X1+X4=X5 X3<=X5).
%total {} (add-left-preserves-leq _ _ _ _ _ _).


%theorem add-right-preserves-leq* :
	forall* {X1} {X2} {X3} {X4} {X5}
	forall {G1:leq X1 X2} {O1:add X1 X3 X4} {O2:add X2 X3 X5}
	exists {G2:leq X4 X5}
	true.

- : add-right-preserves-leq* X1<=X2 X1+X3=X4 X2+X3=X5 X4<=X5
    <- add-commutative X1+X3=X4 X3+X1=X4
    <- add-commutative X2+X3=X5 X3+X2=X5
    <- add-left-preserves-leq* X1<=X2 X3+X1=X4 X3+X2=X5 X4<=X5.

%worlds () (add-right-preserves-leq* X1<=X2 X1+X3=X4 X2+X3=X5 %{=>}% X4<=X5).
%total {} (add-right-preserves-leq* _ _ _ _).


%theorem add-right-preserves-leq :
	forall* {X1} {X2} {X3}
	forall {G1:leq X1 X2} 
	exists {X4} {X5} {O1:add X1 X3 X4} {O2:add X2 X3 X5} {G2:leq X4 X5}
	true.

- : add-right-preserves-leq X1<=X2 X4 X5 X1+X3=X4 X2+X3=X5 X4<=X5
    <- add-total X1+X3=X4 
    <- add-total X2+X3=X5
    <- add-right-preserves-leq* X1<=X2 X1+X3=X4 X2+X3=X5 X4<=X5.
%worlds () (add-right-preserves-leq X1<=X2 %{=>}% X4 X5 X1+X3=X4 X2+X3=X5 X4<=X5).
%total {} (add-right-preserves-leq _ _ _ _ _ _).


%theorem add-preserves-leq* :
	forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
	forall {G1:leq X1 Y1} {G2:leq X2 Y2}
               {MX:add X1 X2 X3} {MY:add Y1 Y2 Y3}
        exists {G3:leq X3 Y3}
	true.

- : add-preserves-leq* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3 X3<=Y3
    <- add-total Y1+X2=X
    <- add-right-preserves-leq* X1<=Y1 X1+X2=X3 Y1+X2=X X3<=X
    <- add-left-preserves-leq* X2<=Y2 Y1+X2=X Y1+Y2=Y3 X<=Y3
    <- leq-transitive X3<=X X<=Y3 X3<=Y3.

%worlds () (add-preserves-leq* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3 %{=>}% X3<=Y3).
%total {} (add-preserves-leq* _ _ _ _ _).


%theorem add-preserves-leq :
	forall* {X1} {X2} {Y1} {Y2}
	forall {G1:leq X1 Y1} {G2:leq X2 Y2}
	exists {X3} {Y3} {MX:add X1 X2 X3} {MY:add Y1 Y2 Y3} {G3:leq X3 Y3}
	true.

- : add-preserves-leq X1<=Y1 X2<=Y2 X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<=Y3
    <- add-total X1+X2=X3
    <- add-total Y1+Y2=Y3
    <- add-preserves-leq* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3 X3<=Y3.

%worlds () (add-preserves-leq X1<=Y1 X2<=Y2 %{=>}% X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<=Y3).
%total {} (add-preserves-leq _ _ _ _ _ _ _).




%theorem add-disjoint-right-leq-implies-leq
  : forall* {M1} {M2} {M3} {M}
    forall {M1UM2=M: add M1 M2 M}
    {M2^M3: disjoint M2 M3}
    {M3<=M: leq M3 M}
    exists {M3<=M1: leq M3 M1}
    true.

% if we have leq?-total then things will be much easier.

%theorem add-disjoint-right-leq-implies-leq/L
  : forall* {M1} {M2} {M3} {M}
    forall {N1} {Z: size M1 N1} 
    {N2} {Z: size M2 N2}
    {M1+M2=M: add M1 M2 M}
    {M2^M3: disjoint M2 M3}
    {M3<=M: leq M3 M}
    exists {M3<=M1: leq M3 M1}
    true.

- : add-disjoint-right-leq-implies-leq/L _ _ _ _ add/L D LE LE2
    <- disjoint-symmetric D DP
    <- disjoint-leq-implies-empty DP LE EE
    <- eq-symmetric EE E
    <- leq-reflexive _ LE3
    <- leq-respects-eq LE3 eq/ E LE2.

- : add-disjoint-right-leq-implies-leq/L _ _ _ _ add/R _ LE LE.

- : add-disjoint-right-leq-implies-leq/L _ _ _ _ _ disjoint/R _ leq/0.

- : add-disjoint-right-leq-implies-leq/L _ _ _ _
    (add/< _ P1) (disjoint/< _ P2) (leq/= _ _ nat`eq/) LE
    <- plus-implies-gt P1 nat`eq/ GT1
    <- plus-implies-gt P2 nat`eq/ GT2
    <- gt-anti-symmetric GT1 GT2 F
    <- false-implies-leq F LE.

% SHP and SH2 unified.
- : add-disjoint-right-leq-implies-leq/L _ (size/+ Z) _ (size/+ Z2)
    (add/< J P1) D (leq/> LE P2) (leq/> LE3P P2)
    <- plus-swap-succ P1 P1P
    <- plus-commutative P1P P1S
    <- shift-total SH
    <- shift-preserves-add J SH (shift/+ P1S) _ SHP JP
    <- plus-swap-succ P2 P2P
    <- plus-commutative P2P P2S
    <- shift-preserves-leq LE (shift/+ P2S) SHP LE2
    <- shift-preserves-size Z SH ZK
    <- add-disjoint-right-leq-implies-leq/L _ ZK _ (size/+ Z2) JP D LE2 LE3
    <- shift-preserves-leq-converse LE3 (shift/+ P2S) SH LE3P.

- : add-disjoint-right-leq-implies-leq/L _ (size/+ Z) _ (size/+ Z2)
    (add/< J P1) (disjoint/> D P2) (leq/= LE M-LE nat`eq/) (leq/= LEE M-LE nat`eq/)
    <- plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- succ-cancels EQ1 EQ
    <- map/+-preserves-eq EQ canonical`eq/ eq/ MEQ
    <- add-respects-eq J eq/ MEQ eq/ JP
    <- add-disjoint-right-leq-implies-leq/L _ Z _ (size/+ Z2) JP D LE LEE.

- : add-disjoint-right-leq-implies-leq/L _ (size/+ Z) _ (size/+ Z2)
    (add/> J P1) (disjoint/< D P2) (leq/> LE P3) LEE2
    <- plus-right-cancels P2 P3 nat`eq/ nat`eq/ EQ1
    <- succ-cancels EQ1 EQ
    <- map/+-preserves-eq EQ canonical`eq/ eq/ MEQ
    <- disjoint-respects-eq D eq/ MEQ DP
    <- add-disjoint-right-leq-implies-leq/L  _ (size/+ Z) _ Z2 J DP LE LEE
    <- plus-swap-succ P3 P3S
    <- plus-commutative P3S P3P
    <- plus-swap-succ P1 P1S
    <- plus-commutative P1S P1P
    <- shift-preserves-leq LEE (shift/+ P3P) (shift/+ P1P) LEE2.

% contradiction cases

- : add-disjoint-right-leq-implies-leq/L _ _ _ _
    (add/= _ _ nat`eq/) (disjoint/< _ P) (leq/= _ _ nat`eq/) LE
    <- plus-implies-gt P nat`eq/ GT
    <- gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : add-disjoint-right-leq-implies-leq/L _ _ _ _
    (add/= _ _ nat`eq/) (disjoint/> _ P) (leq/= _ _ nat`eq/) LE
    <- plus-implies-gt P nat`eq/ GT
    <- gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : add-disjoint-right-leq-implies-leq/L _ _ _ _
    (add/> _ _) (disjoint/< _ P) (leq/= _ _ nat`eq/) LE
    <- plus-implies-gt P nat`eq/ GT
    <- gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : add-disjoint-right-leq-implies-leq/L _ _ _ _
    (add/> _ _) (disjoint/> _ P) (leq/= _ _ nat`eq/) LE
    <- plus-implies-gt P nat`eq/ GT
    <- gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : add-disjoint-right-leq-implies-leq/L _ _ _ _
    (add/= _ _ nat`eq/) (disjoint/> _ P1) (leq/> _ P2) LE
    <- plus-implies-gt P1 nat`eq/ GT1
    <- plus-implies-gt P2 nat`eq/ GT2
    <- gt-anti-symmetric GT1 GT2 F
    <- false-implies-leq F LE.

- : add-disjoint-right-leq-implies-leq/L _ (size/+ Z) _ (size/+ Z2)
    (add/= J M-J nat`eq/) (disjoint/< D P1) (leq/> LE P2) (leq/> LEP P2)
    <- plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- succ-cancels EQ1 EQ
    <- map/+-preserves-eq EQ canonical`eq/ eq/ MEQ
    <- disjoint-respects-eq D eq/ MEQ DP
    <- add-disjoint-right-leq-implies-leq/L _ Z _ Z2 J DP LE LEP.

- : add-disjoint-right-leq-implies-leq/L _ _ _ _
    (add/> _ _) (disjoint/> _ P1) (leq/> _ P2) LE
    <- plus-implies-gt P1 nat`eq/ GT1
    <- plus-implies-gt P2 nat`eq/ GT2
    <- gt-anti-symmetric GT1 GT2 F
    <- false-implies-leq F LE.


- : add-disjoint-right-leq-implies-leq U D LE LE2
    <- size-total Z1
    <- size-total Z2
    <- add-disjoint-right-leq-implies-leq/L _ Z1 _ Z2 U D LE LE2.

%worlds () (add-disjoint-right-leq-implies-leq/L _ _ _ _ _ _ _ _).
%total {N1 N2} (add-disjoint-right-leq-implies-leq/L N1 _ N2 _ _ _ _ _).
%worlds () (add-disjoint-right-leq-implies-leq _ _ _ _).
%total {} (add-disjoint-right-leq-implies-leq _ _ _ _).




%%% Specialized theorems

 
%theorem add-left-increases-lookup:
        forall* {M1} {N} {D2} {M2} {M3}
        forall {L:lookup M2 N D2}
               {A:add M1 M2 M3}
        exists {D3}
               {N:lookup M3 N D3}
               {C:canonical`leq D2 D3}
        true.

%theorem add-left-increases-lookup/L :
        forall* {M1} {N} {D2} {M2} {M3} {B}
        forall {L:lookup M2 N D2}
               {A:add M1 M2 M3}
               {D:domain? M1 N B}
        exists {D3}
               {N:lookup M3 N D3}
               {C:canonical`leq D2 D3}
        true.

- : add-left-increases-lookup/L L2 A (domain?/in L1) _ L3 LE
    <- add-joins-lookup L1 L2 A _ CA L3
    <- canonical`add-implies-leq CA _ LE.

- : add-left-increases-lookup/L L2 A (domain?/out F1) _ L3 LE
    <- fresh-add-left-preserves-lookup* F1 L2 A L3
    <- canonical`leq-reflexive _ LE.

%worlds () (add-left-increases-lookup/L _ _ _ _ _ _).
%total { } (add-left-increases-lookup/L _ _ _ _ _ _).

- : add-left-increases-lookup L2 A _ L3 LE
    <- domain?-total D
    <- add-left-increases-lookup/L L2 A D _ L3 LE.

%worlds () (add-left-increases-lookup _ _ _ _ _).
%total { } (add-left-increases-lookup _ _ _ _ _).


%theorem add-right-increases-lookup:
        forall* {M1} {N} {D1} {M2} {M3}
        forall {L:lookup M1 N D1}
               {A:add M1 M2 M3}
        exists {D3}
               {N:lookup M3 N D3}
               {C:canonical`leq D1 D3}
        true.

- : add-right-increases-lookup L A _ N C
    <- add-commutative A AP
    <- add-left-increases-lookup L AP _ N C.

%worlds () (add-right-increases-lookup _ _ _ _ _).
%total { } (add-right-increases-lookup _ _ _ _ _).




%%%% Renamings

%abbrev nesting = map.
%abbrev nesting`0 = map/0.

%abbrev nesting`map = map.
%abbrev nesting`map/0 = map/0.
%abbrev nesting`map/+ = map/+.
%abbrev nesting`map/1 = map/1.
%abbrev nesting`eq? = eq?.
%abbrev nesting`eq = eq.
%abbrev nesting`ne = ne.
%abbrev nesting`eq?/yes = eq?/yes.
%abbrev nesting`eq/ = eq/.
%abbrev nesting`eq?/no = eq?/no.
%abbrev nesting`lookup = lookup.
%abbrev nesting`lookup/= = lookup/=.
%abbrev nesting`lookup/> = lookup/>.
%abbrev nesting`fresh = fresh.
%abbrev nesting`fresh/0 = fresh/0.
%abbrev nesting`fresh/< = fresh/<.
%abbrev nesting`fresh/> = fresh/>.
%abbrev nesting`ne/< = ne/<.
%abbrev nesting`ne/> = ne/>.
%abbrev nesting`domain? = domain?.
%abbrev nesting`domain?/in = domain?/in.
%abbrev nesting`domain?/out = domain?/out.
%abbrev nesting`disjoint = disjoint.
%abbrev nesting`disjoint/L = disjoint/L.
%abbrev nesting`disjoint/R = disjoint/R.
%abbrev nesting`disjoint/< = disjoint/<.
%abbrev nesting`disjoint/> = disjoint/>.
%abbrev nesting`disjoint? = disjoint?.
%abbrev nesting`disjoint?/yes = disjoint?/yes.
%abbrev nesting`disjoint?/no = disjoint?/no.
%abbrev nesting`size = size.
%abbrev nesting`size/0 = size/0.
%abbrev nesting`size/+ = size/+.
%abbrev nesting`bound = bound.
%abbrev nesting`bound/0 = bound/0.
%abbrev nesting`bound/+ = bound/+.
%abbrev nesting`shift = shift.
%abbrev nesting`shift/0 = shift/0.
%abbrev nesting`shift/+ = shift/+.
%abbrev nesting`update = update.
%abbrev nesting`update/0 = update/0.
%abbrev nesting`update/= = update/=.
%abbrev nesting`update/< = update/<.
%abbrev nesting`update/> = update/>.
%abbrev nesting`meta-eq = meta-eq.
%abbrev nesting`false-implies-eq? = false-implies-eq?.
%abbrev nesting`false-implies-eq = false-implies-eq.
%abbrev nesting`false-implies-ne = false-implies-ne.
%abbrev nesting`eq-reflexive = eq-reflexive.
%abbrev nesting`eq?-symmetric = eq?-symmetric.
%abbrev nesting`eq-symmetric = eq-symmetric.
%abbrev nesting`ne-symmetric = ne-symmetric.
%abbrev nesting`eq-transitive = eq-transitive.
%abbrev nesting`map/+-preserves-eq? = map/+-preserves-eq?.
%abbrev nesting`map/+-preserves-eq = map/+-preserves-eq.
%abbrev nesting`map/+-preserves-ne = map/+-preserves-ne.
%abbrev nesting`map/+-preserves-eq-converse = map/+-preserves-eq-converse.
%abbrev nesting`eq-no-occur = eq-no-occur.
%abbrev nesting`eq-contradiction = eq-contradiction.
%abbrev nesting`false-implies-lookup = false-implies-lookup.
%abbrev nesting`lookup-respects-eq = lookup-respects-eq.
%abbrev nesting`meta-reduces-lookup = meta-reduces-lookup.
%abbrev nesting`lookup/>-inversion = lookup/>-inversion.
%abbrev nesting`lookup-deterministic = lookup-deterministic.
%abbrev nesting`lookup-unique = lookup-unique.
%abbrev nesting`lookup-contradiction = lookup-contradiction.
%abbrev nesting`lookup-one-choice = lookup-one-choice.
%abbrev nesting`lookup-implies-ge = lookup-implies-ge.
%abbrev nesting`false-implies-fresh = false-implies-fresh.
%abbrev nesting`fresh-respects-eq = fresh-respects-eq.
%abbrev nesting`fresh/>-inversion = fresh/>-inversion.
%abbrev nesting`fresh-total* = fresh-total*.
%abbrev nesting`fresh-total = fresh-total.
%abbrev nesting`fresh-lookup-not-equal = fresh-lookup-not-equal.
%abbrev nesting`fresh-contradiction = fresh-contradiction.
%abbrev nesting`ne-implies-unit-map-fresh = ne-implies-unit-map-fresh.
%abbrev nesting`plus-right-preserves-fresh* = plus-right-preserves-fresh*.
%abbrev nesting`fresh-lookup-implies-ne = fresh-lookup-implies-ne.
%abbrev nesting`eq?-respects-eq = eq?-respects-eq.
%abbrev nesting`ne-respects-eq = ne-respects-eq.
%abbrev nesting`ne-anti-reflexive = ne-anti-reflexive.
%abbrev nesting`eq-ne-implies-false = eq-ne-implies-false.
%abbrev nesting`false-implies-domain? = false-implies-domain?.
%abbrev nesting`domain?-respects-eq = domain?-respects-eq.
%abbrev nesting`domain?-deterministic = domain?-deterministic.
%abbrev nesting`domain?-unique = domain?-unique.
%abbrev nesting`domain?-total* = domain?-total*.
%abbrev nesting`domain?-map/+-total = domain?-map/+-total.
%abbrev nesting`domain?-map/+-complete = domain?-map/+-complete.
%abbrev nesting`domain?-total = domain?-total.
%abbrev nesting`in-implies-lookup = in-implies-lookup.
%abbrev nesting`out-implies-fresh = out-implies-fresh.
%abbrev nesting`false-implies-disjoint = false-implies-disjoint.
%abbrev nesting`disjoint-respects-eq = disjoint-respects-eq.
%abbrev nesting`disjoint/=-contradiction = disjoint/=-contradiction.
%abbrev nesting`disjoint/<-inversion = disjoint/<-inversion.
%abbrev nesting`disjoint/>-inversion = disjoint/>-inversion.
%abbrev nesting`disjoint-anti-reflexive = disjoint-anti-reflexive.
%abbrev nesting`disjoint-symmetric = disjoint-symmetric.
%abbrev nesting`disjoint-lookup-contradiction = disjoint-lookup-contradiction.
%abbrev nesting`disjoint-lookup-implies-fresh = disjoint-lookup-implies-fresh.
%abbrev nesting`disjoint-lookup-implies-fresh/L = disjoint-lookup-implies-fresh/L.
%abbrev nesting`shift-left-preserves-disjoint = shift-left-preserves-disjoint.
%abbrev nesting`shift-left-preserves-disjoint-converse = shift-left-preserves-disjoint-converse.
%abbrev nesting`shift-right-preserves-disjoint = shift-right-preserves-disjoint.
%abbrev nesting`shift-right-preserves-disjoint-converse = shift-right-preserves-disjoint-converse.
%abbrev nesting`shift-preserves-disjoint = shift-preserves-disjoint.
%abbrev nesting`shift-preserves-disjoint-converse = shift-preserves-disjoint-converse.
%abbrev nesting`can-construct-unit-disjoint = can-construct-unit-disjoint.
%abbrev nesting`ne-implies-disjoint = ne-implies-disjoint.
%abbrev nesting`fresh-implies-unit-disjoint = fresh-implies-unit-disjoint.
%abbrev nesting`false-implies-size = false-implies-size.
%abbrev nesting`size-total* = size-total*.
%abbrev nesting`size-total = size-total.
%abbrev nesting`size-respects-eq = size-respects-eq.
%abbrev nesting`size-deterministic = size-deterministic.
%abbrev nesting`size-unique = size-unique.
%abbrev nesting`shift-preserves-size = shift-preserves-size.
%abbrev nesting`shift-preserves-size-converse = shift-preserves-size-converse.
%abbrev nesting`false-implies-bound = false-implies-bound.
%abbrev nesting`bound-respects-eq = bound-respects-eq.
%abbrev nesting`bound-unique = bound-unique.
%abbrev nesting`bound-deterministic = bound-deterministic.
%abbrev nesting`bound-total* = bound-total*.
%abbrev nesting`bound-total = bound-total.
%abbrev nesting`bound-lookup-implies-gt = bound-lookup-implies-gt.
%abbrev nesting`ge-bound-implies-fresh = ge-bound-implies-fresh.
%abbrev nesting`false-implies-shift = false-implies-shift.
%abbrev nesting`shift-respects-eq = shift-respects-eq.
%abbrev nesting`shift-total* = shift-total*.
%abbrev nesting`shift-total = shift-total.
%abbrev nesting`shift-deterministic = shift-deterministic.
%abbrev nesting`shift-unique = shift-unique.
%abbrev nesting`shift-cancels = shift-cancels.
%abbrev nesting`shifts-add = shifts-add.
%abbrev nesting`shifts-add-converse = shifts-add-converse.
%abbrev nesting`shift-preserves-fresh = shift-preserves-fresh.
%abbrev nesting`shift-preserves-fresh* = shift-preserves-fresh*.
%abbrev nesting`shift-preserves-fresh-converse* = shift-preserves-fresh-converse*.
%abbrev nesting`shift-preserves-lookup = shift-preserves-lookup.
%abbrev nesting`shift-preserves-lookup* = shift-preserves-lookup*.
%abbrev nesting`shift-preserves-lookup-converse = shift-preserves-lookup-converse.
%abbrev nesting`shift-preserves-lookup-converse* = shift-preserves-lookup-converse*.
%abbrev nesting`shift-implies-fresh* = shift-implies-fresh*.
%abbrev nesting`shift-implies-fresh = shift-implies-fresh.
%abbrev nesting`removal-preserves-fresh = removal-preserves-fresh.
%abbrev nesting`shift-preserves-size = shift-preserves-size.
%abbrev nesting`disjoint?-total* = disjoint?-total*.
%abbrev nesting`disjoint?-total*/+ = disjoint?-total*/+.
%abbrev nesting`disjoint?-total*/< = disjoint?-total*/<.
%abbrev nesting`disjoint?-total*/> = disjoint?-total*/>.
%abbrev nesting`disjoint?-total = disjoint?-total.
%abbrev nesting`false-implies-update = false-implies-update.
%abbrev nesting`update-respects-eq = update-respects-eq.
%abbrev nesting`meta-reduces-update = meta-reduces-update.
%abbrev nesting`update/=-inversion = update/=-inversion.
%abbrev nesting`update/<-inversion = update/<-inversion.
%abbrev nesting`update/>-inversion = update/>-inversion.
%abbrev nesting`update-contradiction = update-contradiction.
%abbrev nesting`update-deterministic = update-deterministic.
%abbrev nesting`update-unique = update-unique.
%abbrev nesting`update-total* = update-total*.
%abbrev nesting`update-map/+-total = update-map/+-total.
%abbrev nesting`update-total = update-total.
%abbrev nesting`lookup-implies-update = lookup-implies-update.
%abbrev nesting`lookup-implies-fresh-update = lookup-implies-fresh-update.
%abbrev nesting`update-implies-lookup = update-implies-lookup.
%abbrev nesting`update-preserves-lookup = update-preserves-lookup.
%abbrev nesting`update-preserves-lookup-converse = update-preserves-lookup-converse.
%abbrev nesting`update-preserves-fresh = update-preserves-fresh.
%abbrev nesting`update-preserves-fresh-converse = update-preserves-fresh-converse.
%abbrev nesting`update-preserves-fresh-converse-helper = update-preserves-fresh-converse-helper.
%abbrev nesting`update-is-cause-of-change = update-is-cause-of-change.
%abbrev nesting`update-is-cause-of-change/L = update-is-cause-of-change/L.
%abbrev nesting`update-preserves-membership = update-preserves-membership.
%abbrev nesting`update-preserves-membership-converse = update-preserves-membership-converse.
%abbrev nesting`lookup-update-preserves-membership = lookup-update-preserves-membership.
%abbrev nesting`lookup-update-preserves-membership/L = lookup-update-preserves-membership/L.
%abbrev nesting`lookup-update-preserves-membership-converse = lookup-update-preserves-membership-converse.
%abbrev nesting`update-preserves-in-domain = update-preserves-in-domain.
%abbrev nesting`update-preserves-in-domain/L = update-preserves-in-domain/L.
%abbrev nesting`shift-preserves-update = shift-preserves-update.
%abbrev nesting`shift-preserves-update* = shift-preserves-update*.
%abbrev nesting`shift-preserves-update-converse = shift-preserves-update-converse.
%abbrev nesting`shift-preserves-update-converse* = shift-preserves-update-converse*.
%abbrev nesting`update-commutes-shift-converse = update-commutes-shift-converse.
%abbrev nesting`fresh-update-preserves-lookup = fresh-update-preserves-lookup.
%abbrev nesting`fresh-update-increases-size = fresh-update-increases-size.
%abbrev nesting`fresh-update-increases-size-converse = fresh-update-increases-size-converse.
%abbrev nesting`fresh-update-preserves-disjoint = fresh-update-preserves-disjoint.
%abbrev nesting`fresh-update-preserves-disjoint/L = fresh-update-preserves-disjoint/L.
%abbrev nesting`update-preserves-disjoint-converse = update-preserves-disjoint-converse.
%abbrev nesting`update-preserves-disjoint-converse/L = update-preserves-disjoint-converse/L.
%abbrev nesting`update-preserves-bound = update-preserves-bound.
%abbrev nesting`update-preserves-bound-converse = update-preserves-bound-converse.
%abbrev nesting`update-overwrites = update-overwrites.
%abbrev nesting`update-overwrites-converse = update-overwrites-converse.
%abbrev nesting`update-may-have-no-effect = update-may-have-no-effect.
%abbrev nesting`update-idempotent = update-idempotent.
%abbrev nesting`update-commutes = update-commutes.
%abbrev nesting`update-commutes* = update-commutes*.
%abbrev nesting`fresh-update-cancels = fresh-update-cancels.
%abbrev nesting`update-commutes-converse = update-commutes-converse.
%abbrev nesting`update-commutes-converse/L = update-commutes-converse/L.
%abbrev nesting`fresh-update-commutes-converse* = fresh-update-commutes-converse*.
%abbrev nesting`can-remove = can-remove.
%abbrev nesting`can-remove* = can-remove*.
%abbrev nesting`shift-implies-update = shift-implies-update.
%abbrev nesting`fresh-update-implies-shift = fresh-update-implies-shift.
%abbrev nesting`leq? = leq?.
%abbrev nesting`leq = leq.
%abbrev nesting`nle = nle.
%abbrev nesting`leq/0 = leq/0.
%abbrev nesting`leq/= = leq/=.
%abbrev nesting`leq/> = leq/>.
%abbrev nesting`nle/< = nle/<.
%abbrev nesting`leq?/yes = leq?/yes.
%abbrev nesting`leq?/no = leq?/no.
%abbrev nesting`false-implies-leq? = false-implies-leq?.
%abbrev nesting`false-implies-leq = false-implies-leq.
%abbrev nesting`false-implies-nle = false-implies-nle.
%abbrev nesting`leq?-respects-eq = leq?-respects-eq.
%abbrev nesting`leq-respects-eq = leq-respects-eq.
%abbrev nesting`nle-respects-eq = nle-respects-eq.
%abbrev nesting`leq/0-inversion = leq/0-inversion.
%abbrev nesting`leq/=-inversion = leq/=-inversion.
%abbrev nesting`leq/>-inversion = leq/>-inversion.
%abbrev nesting`leq-contradiction = leq-contradiction.
%abbrev nesting`leq/<-contradiction = leq/<-contradiction.
%abbrev nesting`leq-reflexive = leq-reflexive.
%abbrev nesting`leq-anti-symmetric = leq-anti-symmetric.
%abbrev nesting`leq-transitive = leq-transitive.
%abbrev nesting`map/+-preserves-leq? = map/+-preserves-leq?.
%abbrev nesting`map/+-preserves-leq = map/+-preserves-leq.
%abbrev nesting`map/+-preserves-nle = map/+-preserves-nle.
%abbrev nesting`lookup-respects-leq = lookup-respects-leq.
%abbrev nesting`lookup-respects-leq* = lookup-respects-leq*.
%abbrev nesting`lookup-implies-unit-leq = lookup-implies-unit-leq.
%abbrev nesting`fresh-respects-geq = fresh-respects-geq.
%abbrev nesting`leq-implies-size-le = leq-implies-size-le.
%abbrev nesting`leq-implies-bound-le = leq-implies-bound-le.
%abbrev nesting`shift-left-preserves-leq* = shift-left-preserves-leq*.
%abbrev nesting`shift-preserves-leq* = shift-preserves-leq*.
%abbrev nesting`shift-preserves-leq = shift-preserves-leq.
%abbrev nesting`shift-preserves-leq-converse = shift-preserves-leq-converse.
%abbrev nesting`disjoint-respects-geq* = disjoint-respects-geq*.
%abbrev nesting`disjoint-respects-geq = disjoint-respects-geq.
%abbrev nesting`disjoint-leq-implies-empty = disjoint-leq-implies-empty.
%abbrev nesting`update-left-preserves-leq* = update-left-preserves-leq*.
%abbrev nesting`update-right-preserves-leq* = update-right-preserves-leq*.
%abbrev nesting`update-preserves-leq* = update-preserves-leq*.
%abbrev nesting`fresh-update-preserves-leq-converse = fresh-update-preserves-leq-converse.
%abbrev nesting`fresh-update-preserves-leq-converse/> = fresh-update-preserves-leq-converse/>.
%abbrev nesting`fresh-update2-preserves-leq-converse = fresh-update2-preserves-leq-converse.
%abbrev nesting`fresh-update-implies-leq = fresh-update-implies-leq.
%abbrev nesting`lookup-update-preserves-leq = lookup-update-preserves-leq.
%abbrev nesting`nle-anti-reflexive = nle-anti-reflexive.
%abbrev nesting`nle-implies-ne = nle-implies-ne.
%abbrev nesting`leq-nle-contradiction = leq-nle-contradiction.
%abbrev nesting`add = add.
%abbrev nesting`add/L = add/L.
%abbrev nesting`add/R = add/R.
%abbrev nesting`add/= = add/=.
%abbrev nesting`add/< = add/<.
%abbrev nesting`add/> = add/>.
%abbrev nesting`false-implies-add = false-implies-add.
%abbrev nesting`add-respects-eq = add-respects-eq.
%abbrev nesting`can-construct-unit-add = can-construct-unit-add.
%abbrev nesting`add/=-inversion = add/=-inversion.
%abbrev nesting`add/<-inversion = add/<-inversion.
%abbrev nesting`add/>-inversion = add/>-inversion.
%abbrev nesting`add-deterministic = add-deterministic.
%abbrev nesting`add-unique = add-unique.
%abbrev nesting`add-total* = add-total*.
%abbrev nesting`add-map/+-M-total* = add-map/+-M-total*.
%abbrev nesting`add-M-map/+-total* = add-M-map/+-total*.
%abbrev nesting`add-map/+-map/+-total* = add-map/+-map/+-total*.
%abbrev nesting`add-total = add-total.
%abbrev nesting`disjoint-add-total = disjoint-add-total.
%abbrev nesting`disjoint-add-commutative = disjoint-add-commutative.
%abbrev nesting`add-empty-implies-empty = add-empty-implies-empty.
%abbrev nesting`add-preserves-disjoint* = add-preserves-disjoint*.
%abbrev nesting`add-preserves-disjoint*/L = add-preserves-disjoint*/L.
%abbrev nesting`add-left-preserves-disjoint* = add-left-preserves-disjoint*.
%abbrev nesting`add-right-preserves-disjoint* = add-right-preserves-disjoint*.
%abbrev nesting`add-preserves-disjoint-converse = add-preserves-disjoint-converse.
%abbrev nesting`disjoint-add-right-cancels = disjoint-add-right-cancels.
%abbrev nesting`disjoint-add-right-cancels/L = disjoint-add-right-cancels/L.
%abbrev nesting`disjoint-add-left-cancels = disjoint-add-left-cancels.
%abbrev nesting`shift-left-preserves-add = shift-left-preserves-add.
%abbrev nesting`shift-left-preserves-add-converse = shift-left-preserves-add-converse.
%abbrev nesting`shift-right-preserves-add = shift-right-preserves-add.
%abbrev nesting`shift-right-preserves-add-converse = shift-right-preserves-add-converse.
%abbrev nesting`shift-preserves-add* = shift-preserves-add*.
%abbrev nesting`shift-preserves-add = shift-preserves-add.
%abbrev nesting`shift-preserves-add-converse = shift-preserves-add-converse.
%abbrev nesting`shift-preserves-add-converse* = shift-preserves-add-converse*.
%abbrev nesting`shift-preserves-add-converse** = shift-preserves-add-converse**.
%abbrev nesting`add-commutative = add-commutative.
%abbrev nesting`add-associative = add-associative.
%abbrev nesting`add-associative-add/<-add/< = add-associative-add/<-add/<.
%abbrev nesting`add-associative* = add-associative*.
%abbrev nesting`add-associative-converse = add-associative-converse.
%abbrev nesting`add-associative-converse* = add-associative-converse*.
%abbrev nesting`add-assoc-commutative* = add-assoc-commutative*.
%abbrev nesting`add-assoc-commutative = add-assoc-commutative.
%abbrev nesting`add-double-associative* = add-double-associative*.
%abbrev nesting`add-double-associative = add-double-associative.
%abbrev nesting`lookup-implies-add = lookup-implies-add.
%abbrev nesting`add-joins-lookup = add-joins-lookup.
%abbrev nesting`add-joins-lookup* = add-joins-lookup*.
%abbrev nesting`add-commutes-lookup = add-commutes-lookup.
%abbrev nesting`add-preserves-fresh* = add-preserves-fresh*.
%abbrev nesting`fresh-add-left-preserves-lookup* = fresh-add-left-preserves-lookup*.
%abbrev nesting`fresh-add-left-preserves-lookup-converse = fresh-add-left-preserves-lookup-converse.
%abbrev nesting`fresh-add-left-preserves-lookup-converse/L = fresh-add-left-preserves-lookup-converse/L.
%abbrev nesting`add-left-affects-lookup = add-left-affects-lookup.
%abbrev nesting`add-left-affects-lookup/L = add-left-affects-lookup/L.
%abbrev nesting`fresh-add-right-preserves-lookup = fresh-add-right-preserves-lookup.
%abbrev nesting`fresh-add-right-preserves-lookup* = fresh-add-right-preserves-lookup*.
%abbrev nesting`fresh-add-right-preserves-lookup-converse = fresh-add-right-preserves-lookup-converse.
%abbrev nesting`fresh-add-right-preserves-lookup-converse/L = fresh-add-right-preserves-lookup-converse/L.
%abbrev nesting`add-right-affects-lookup = add-right-affects-lookup.
%abbrev nesting`add-right-affects-lookup/L = add-right-affects-lookup/L.
%abbrev nesting`add-preserves-fresh-converse* = add-preserves-fresh-converse*.
%abbrev nesting`add-preserves-fresh-converse/L = add-preserves-fresh-converse/L.
%abbrev nesting`disjoint-add-cross-comparable = disjoint-add-cross-comparable.
%abbrev nesting`disjoint-add-left-preserves-lookup* = disjoint-add-left-preserves-lookup*.
%abbrev nesting`disjoint-add-left-preserves-lookup*/L = disjoint-add-left-preserves-lookup*/L.
%abbrev nesting`disjoint-add-right-preserves-lookup* = disjoint-add-right-preserves-lookup*.
%abbrev nesting`disjoint-add-right-preserves-lookup*/L = disjoint-add-right-preserves-lookup*/L.
%abbrev nesting`add-cross-comparable = add-cross-comparable.
%abbrev nesting`fresh-update-implies-unit-add = fresh-update-implies-unit-add.
%abbrev nesting`fresh-unit-add-implies-update = fresh-unit-add-implies-update.
%abbrev nesting`fresh-update-left-preserves-add-converse = fresh-update-left-preserves-add-converse.
%abbrev nesting`fresh-update-left-preserves-add-converse* = fresh-update-left-preserves-add-converse*.
%abbrev nesting`fresh-update-right-preserves-add-converse = fresh-update-right-preserves-add-converse.
%abbrev nesting`fresh-update-right-preserves-add-converse* = fresh-update-right-preserves-add-converse*.
%abbrev nesting`fresh-update-preserves-add-converse = fresh-update-preserves-add-converse.
%abbrev nesting`fresh-update-preserves-add-converse* = fresh-update-preserves-add-converse*.
%abbrev nesting`add-preserves-fresh-update-left = add-preserves-fresh-update-left.
%abbrev nesting`bound-commute-add* = bound-commute-add*.
%abbrev nesting`size-commute-disjoint-add* = size-commute-disjoint-add*.
%abbrev nesting`add-implies-leq* = add-implies-leq*.
%abbrev nesting`add-implies-leq = add-implies-leq.
%abbrev nesting`disjoint-leq-implies-add-leq* = disjoint-leq-implies-add-leq*.
%abbrev nesting`add-left-preserves-leq* = add-left-preserves-leq*.
%abbrev nesting`add-left-preserves-leq = add-left-preserves-leq.
%abbrev nesting`add-right-preserves-leq* = add-right-preserves-leq*.
%abbrev nesting`add-right-preserves-leq = add-right-preserves-leq.
%abbrev nesting`add-preserves-leq* = add-preserves-leq*.
%abbrev nesting`add-preserves-leq = add-preserves-leq.
%abbrev nesting`add-disjoint-right-leq-implies-leq = add-disjoint-right-leq-implies-leq.
%abbrev nesting`add-disjoint-right-leq-implies-leq/L = add-disjoint-right-leq-implies-leq/L.
%abbrev nesting`add-left-increases-lookup = add-left-increases-lookup.
%abbrev nesting`add-left-increases-lookup/L = add-left-increases-lookup/L.
%abbrev nesting`add-right-increases-lookup = add-right-increases-lookup.
%abbrev nesting`nesting = nesting.
