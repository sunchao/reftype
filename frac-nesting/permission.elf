%%%%% permission.elf
%%%%% John Boyland
%%%%% June, 2007

%{%
Permissions as defined in "Semantics of Fractional Permissions with Nesting"
%}%

%%%% Definitions


%%% syntactic kinds

vark : type.

objectk : vark.

fractionk : vark.

kind : type.

permissionk : kind.

upermk : kind.

formulak : kind.

termk : kind -> vark.

gterm : vark -> type.

%abbrev term : kind -> type = [K] (gterm (termk K)).

%abbrev permission = term permissionk.

%abbrev uperm = term upermk.

%abbrev formula = term formulak.

%abbrev object = gterm objectk.

%abbrev fraction = gterm fractionk.

%{%
Predicates are typed by the kinds of arguments they take.
Thus we make sure only legal predicate calls occur.
%}%

predtype : type.

predtype/0 : predtype.

predtype/+ : vark -> predtype -> predtype.

predicate : predtype -> type.

predargs : predtype -> type.

%abbrev field : type = nat.

%abbrev value : type = object.



%%% Permissions


empty : permission.

scale :  fraction -> permission -> permission.

combine : permission -> permission -> permission.
 %abbrev , = combine.  %infix left 10 , .

%% unit permissions

unitperm : uperm -> permission.

nonlinear : formula -> uperm.

conditional : formula -> permission -> permission -> uperm.

encumbered : permission -> permission -> uperm.

%% precise-exists : {O: object} {F:field} {B: value -> permission}
%%                 ([v: value] ( basic O F v , B v )) -> permission.

precise-exists : object -> field -> (value -> permission) -> uperm.

basic : object -> field -> value -> uperm.


object/ : nat -> object.

fraction/ : rat -> fraction.



%%% Formulae


t : formula.

neg : formula -> formula.

conj : formula -> formula -> formula.

objequal : object -> object -> formula.

exists* : {K} ((gterm K) -> formula) -> formula.

%abbrev exists = exists* _.

nested : permission -> object -> field -> formula.

predcall* : {N} predicate N -> predargs N -> formula.

%abbrev predcall = predcall* _.

%abbrev f = (neg t).

%abbrev disj = [G1] [G2] (neg (conj (neg G1) (neg G2))).

%abbrev impl = [G1] [G2] (neg (conj G1 (neg G2))).

%abbrev ifthenelse = [G1] [G2] [G3] (conj (impl G1 G2) (disj G1 G3)).

% EXTEND formulae



%%% Predicates and arguments


%{%
The code to generate the mapping (see permission-map.elf)
can't handle a non-uniform indexed type: one with different
cardinalities depending on theindex, so I stick an useless
integer into predargs/0.
%}%

predargs/0* : nat -> predargs (predtype/0).

%abbrev predargs/0 = predargs/0* _.

predargs/+ : gterm K -> predargs N -> predargs (predtype/+ K N).


predicate/0 : formula -> predicate (predtype/0).

predicate/+ : (gterm K -> predicate N) -> predicate (predtype/+ K N).

predicate/Y : (predicate N -> predicate N) -> predicate N.



%%% equality


eq : gterm K -> gterm K -> type.

%abbrev object`eq = eq.


eq/ : eq T T.

%abbrev object`eq/ = eq/.


%% equality for predicates too

 predicate`eq : predicate T1 -> predicate T2 -> type.

 predicate`eq/ : predicate`eq P P.


%% equality for predargs

  predargs`eq : predargs T1 -> predargs T2 -> type.

  predargs`eq/ : predargs`eq A A.



%%% equivalence


equiv : permission -> permission -> type.


equiv/identity : equiv (Pi , empty) Pi.

equiv/commute : equiv (Pi1 , Pi2) (Pi2 , Pi1).

equiv/associate : equiv (Pi1 , (Pi2 , Pi3)) ((Pi1 , Pi2), Pi3).

equiv/combine : (equiv Pi1 Pi1') -> (equiv Pi2 Pi2') -> 
	(equiv (Pi1 , Pi2) (Pi1' , Pi2')).

equiv/zero : equiv (scale Q empty) empty.

equiv/one : equiv (scale (fraction/ rat`one) Pi) Pi.

equiv/distribute : equiv (scale Q (Pi1 , Pi2)) ((scale Q Pi1) , (scale Q Pi2)).

equiv/mul : (rat`mul Q1 Q2 Q3) -> 
    equiv (scale (fraction/ Q1) (scale (fraction/ Q2) Pi)) 
          (scale (fraction/ Q3) Pi).

equiv/add : (rat`add Q1 Q2 Q3) -> 
	equiv (scale (fraction/ Q1) Pi , scale (fraction/ Q2) Pi) 
              (scale (fraction/ Q3) Pi).


equiv/reflexive : equiv Pi Pi.

equiv/symmetric : equiv Pi1 Pi2 -> equiv Pi2 Pi1.

equiv/transitive : equiv Pi1 Pi2 -> equiv Pi2 Pi3 -> equiv Pi1 Pi3.


%%% Abbrevations/shortcuts for standard equivalences

%abbrev equiv/transitive2 = equiv/transitive.

%abbrev equiv/transitive3 = 
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] [EQ34:equiv Pi3 Pi4]
	(equiv/transitive EQ12 (equiv/transitive EQ23 EQ34)).

%abbrev equiv/transitive4 = 
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] 
        [EQ34:equiv Pi3 Pi4] [EQ45:equiv Pi4 Pi5]
	(equiv/transitive (equiv/transitive EQ12 EQ23)
                          (equiv/transitive EQ34 EQ45)).

%abbrev equiv/transitive5 =
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] 
        [EQ34:equiv Pi3 Pi4] [EQ45:equiv Pi4 Pi5] [EQ56:equiv Pi5 Pi6]
	(equiv/transitive (equiv/transitive2 EQ12 EQ23)
                          (equiv/transitive3 EQ34 EQ45 EQ56)).

%abbrev equiv/transitive6 =
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] [EQ34:equiv Pi3 Pi4] 
	[EQ45:equiv Pi4 Pi5] [EQ56:equiv Pi5 Pi6] [EQ67:equiv Pi6 Pi7]
	(equiv/transitive (equiv/transitive3 EQ12 EQ23 EQ34)
                          (equiv/transitive3 EQ45 EQ56 EQ67)).

%abbrev equiv/transitive7 =
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] [EQ34:equiv Pi3 Pi4] 
	[EQ45:equiv Pi4 Pi5] [EQ56:equiv Pi5 Pi6] [EQ67:equiv Pi6 Pi7]
        [EQ78:equiv Pi7 Pi8]
	(equiv/transitive (equiv/transitive3 EQ12 EQ23 EQ34)
                          (equiv/transitive4 EQ45 EQ56 EQ67 EQ78)).

%abbrev equiv/transitive8 =
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] [EQ34:equiv Pi3 Pi4] 
	[EQ45:equiv Pi4 Pi5] [EQ56:equiv Pi5 Pi6] [EQ67:equiv Pi6 Pi7]
        [EQ78:equiv Pi7 Pi8] [EQ89:equiv Pi8 Pi9]
	(equiv/transitive (equiv/transitive4 EQ12 EQ23 EQ34 EQ45)
                          (equiv/transitive4 EQ56 EQ67 EQ78 EQ89)).

%abbrev equiv/reorder :
	equiv (A , (B , REST)) (B , (A , REST)) =
	(equiv/transitive3
	   equiv/associate
	   (equiv/combine equiv/commute equiv/reflexive)
	   (equiv/symmetric equiv/associate)).

%abbrev equiv/double-associate 
	: equiv ((Pi1 , Pi2), (Pi3 , Pi4))
                ((Pi1 , Pi3), (Pi2 , Pi4))
        = (equiv/transitive5
	     (equiv/combine equiv/commute equiv/reflexive)
	     equiv/associate
	     (equiv/combine (equiv/symmetric equiv/associate) equiv/reflexive)
	     (equiv/combine equiv/commute equiv/reflexive)
	     (equiv/symmetric equiv/associate)).

%abbrev equiv/roll2 : equiv (A1 , (A2 , C)) (A2 , (A1 , C))		   
	= equiv/reorder.

%abbrev equiv/roll3 : equiv (A1 , (A2 , (A3 , C))) (A3 , (A1 , (A2 , C)))
	= (equiv/transitive
	     (equiv/combine equiv/reflexive equiv/roll2)
	     equiv/roll2).

%abbrev equiv/roll4 : equiv (A1 , (A2 , (A3 , (A4 , C)))) 
                            (A4 , (A1 , (A2 , (A3 , C))))
	= (equiv/transitive
	     (equiv/combine equiv/reflexive equiv/roll3)
	     equiv/roll2).

%abbrev equiv/roll5 : equiv (A1 , (A2 , (A3 , (A4 , (A5 , C)))))
                            (A5 , (A1 , (A2 , (A3 , (A4 , C)))))
	= (equiv/transitive
	     (equiv/combine equiv/reflexive equiv/roll4)
	     equiv/roll2).

%abbrev equiv/roll6 : equiv (A1 , (A2 , (A3 , (A4 , (A5 , (A6 , C))))))
                            (A6 , (A1 , (A2 , (A3 , (A4 , (A5 , C))))))
	= (equiv/transitive
	     (equiv/combine equiv/reflexive equiv/roll5)
	     equiv/roll2).

%abbrev equiv/roll7 : equiv (A1 , (A2 , (A3 , (A4 , (A5 , (A6 , (A7 , C)))))))
                            (A7 , (A1 , (A2 , (A3 , (A4 , (A5 , (A6 , C)))))))
	= (equiv/transitive
	     (equiv/combine equiv/reflexive equiv/roll6)
	     equiv/roll2).



%%% Special case for equivalence to the empty permission


null : permission -> type.


null/0 : null empty.

null/* : null Pi -> null (scale Q Pi).

null/+ : null Pi1 -> null Pi2 -> null (Pi1 , Pi2).



nonnull : permission -> rat -> type.


nonnull/scale : 
	nonnull Pi Q2 ->
	rat`mul Q1 Q2 Q3 ->
    nonnull (scale (fraction/ Q1) Pi) Q3.

nonnull/combine/1 : 
	nonnull Pi1 Q ->
	null Pi2 ->
    nonnull (Pi1 , Pi2) Q.

nonnull/combine/2 :
	null Pi1 ->
	nonnull Pi2 Q ->
    nonnull (Pi1 , Pi2) Q.

nonnull/combine/1+2 :
	nonnull Pi1 Q1 ->
	nonnull Pi2 Q2 ->
	rat`add Q1 Q2 Q3 ->
    nonnull (Pi1 , Pi2) Q3.

nonnull/unit : nonnull (unitperm _) rat`one.



null? : permission -> bool -> type.


null?/yes : null Pi -> null? Pi true.

null?/no : nonnull Pi Q -> null? Pi false.



%%% containment


leq : permission -> permission -> type.


leq/ : equiv (Pi1 , Pi2) Pi3 -> leq Pi1 Pi3.




%%%% Blocks



%abbrev clspred = predicate (predtype/+ objectk predtype/0).

%block gtermvar : some {K} block {x:gterm K}.

%block predvar : some {PT} block {f:predicate PT}.

%block objvar : block {o:object}.

%block fracvar : block {f:fraction}.



%%%% Theorems



%%% Theorems about gterm


%theorem gterm-inhabited :
    forall* {V:vark}
    exists {G:gterm V}
    true.

%% object
- : gterm-inhabited (object/ nat`z).

%% fraction
- : gterm-inhabited (fraction/ rat`one).

%% permission
- : gterm-inhabited empty.

%% formula
- : gterm-inhabited t.

%% uperm
- : gterm-inhabited (nonlinear t).

%worlds (gtermvar) (gterm-inhabited _).
%total { } (gterm-inhabited _).



%%% Theorems about eq


%theorem meta-eq : forall* {K} forall {P1:term K} {P2} {E:eq P1 P2} true.

- : meta-eq P P eq/.

%worlds () (meta-eq _ _ _).
%total { } (meta-eq _ _ _).
%reduces X = Y (meta-eq X Y _).


%theorem false-implies-eq :
	forall* {K} {P1:term K} {P2}
	forall {P:void}
        exists {Q:eq P1 P2}
	true.

%worlds (gtermvar) (false-implies-eq _ _).
%total { } (false-implies-eq _ _).


%theorem eq-reflexive :
	forall* {K}
	forall {P: term K}
	exists {D:eq P P}
	true.

- : eq-reflexive _ eq/.

%worlds (gtermvar) (eq-reflexive _ _).
%total { } (eq-reflexive _ _).

		    
%theorem eq-symmetric : 
	forall* {K} {P1:term K} {P2}
	forall {E:eq P1 P2}
	exists {F:eq P2 P1}
	true.

- : eq-symmetric (eq/) (eq/).

%worlds (gtermvar) (eq-symmetric _ _).
%total { } (eq-symmetric _ _).


%theorem eq-transitive : 
	forall* {K} {P1:term K} {P2} {P3}
	forall {E1:eq P1 P2} {E2:eq P2 P3}
	exists {F:eq P1 P3}
	true.

- : eq-transitive (eq/) (eq/) (eq/).

%worlds (gtermvar) (eq-transitive _ _ _).
%total { } (eq-transitive _ _ _).


%theorem object-eq-implies-eq :
        forall* {N1} {N2}
        forall {OE:eq (object/ N1) (object/ N2)}
        exists {E:nat`eq N1 N2}
        true.

- : object-eq-implies-eq eq/ nat`eq/.

%worlds () (object-eq-implies-eq _ _).
%total { } (object-eq-implies-eq _ _).


%theorem object-preserves-eq :
        forall* {N1} {N2}
        forall {E:nat`eq N1 N2}
        exists {OE:eq (object/ N1) (object/ N2)}
        true.
        
- : object-preserves-eq nat`eq/ eq/.

%worlds () (object-preserves-eq _ _).
%total { } (object-preserves-eq _ _).


%theorem unit-eq-implies-eq :
	forall* {U1} {U2}
	forall {EU:eq U1 U2}
	exists {PU:eq (unitperm U1) (unitperm U2)}
	true.

- : unit-eq-implies-eq eq/ eq/.

%worlds () (unit-eq-implies-eq _ _).
%total { } (unit-eq-implies-eq _ _).



%%% Theorems about predicate`eq


%theorem predicate`meta-eq : 
	forall* {K} {K2}
	forall	{P1:predicate K} {P2:predicate K2} 
		{E:predicate`eq P1 P2} 
	true.

- : predicate`meta-eq P P predicate`eq/.

%worlds () (predicate`meta-eq _ _ _).
%total { } (predicate`meta-eq _ _ _).
%reduces X = Y (predicate`meta-eq X Y _).


%theorem predicate`false-implies-eq :
	forall* {K} {K2} {P1:predicate K} {P2: predicate K2}
	forall {P:void}
        exists {Q:predicate`eq P1 P2}
	true.

%worlds (gtermvar | predvar) (predicate`false-implies-eq _ _).
%total { } (predicate`false-implies-eq _ _).


%theorem predicate`eq-reflexive :
	forall* {K}
	forall {P: predicate K}
	exists {D:predicate`eq P P}
	true.

- : predicate`eq-reflexive _ predicate`eq/.

%worlds (gtermvar | predvar) (predicate`eq-reflexive _ _).
%total { } (predicate`eq-reflexive _ _).

		    
%theorem predicate`eq-symmetric : 
	forall* {K} {P1:predicate K} {K2} {P2: predicate K2}
	forall {E:predicate`eq P1 P2}
	exists {F:predicate`eq P2 P1}
	true.

- : predicate`eq-symmetric (predicate`eq/) (predicate`eq/).

%worlds (gtermvar | predvar) (predicate`eq-symmetric _ _).
%total { } (predicate`eq-symmetric _ _).


%theorem predicate`eq-transitive : 
	forall* {K} {P1:predicate K} 
		{K2} {P2:predicate K2} {K3} {P3:predicate K3}
	forall {E1:predicate`eq P1 P2} {E2:predicate`eq P2 P3}
	exists {F:predicate`eq P1 P3}
	true.

- : predicate`eq-transitive (predicate`eq/) (predicate`eq/) (predicate`eq/).

%worlds (gtermvar | predvar) (predicate`eq-transitive _ _ _).
%total { } (predicate`eq-transitive _ _ _).



%%% Theorems about predargs`eq


%theorem predargs`meta-eq : 
	forall* {K} {K2}
	forall	{P1:predargs K} {P2:predargs K2} 
		{E:predargs`eq P1 P2} 
	true.

- : predargs`meta-eq P P predargs`eq/.

%worlds () (predargs`meta-eq _ _ _).
%total { } (predargs`meta-eq _ _ _).
%reduces X = Y (predargs`meta-eq X Y _).


%theorem predargs`false-implies-eq :
	forall* {K} {K2} {P1:predargs K} {P2: predargs K2}
	forall {P:void}
        exists {Q:predargs`eq P1 P2}
	true.

%worlds () (predargs`false-implies-eq _ _).
%total { } (predargs`false-implies-eq _ _).


%theorem predargs`eq-reflexive :
	forall* {K}
	forall {P: predargs K}
	exists {D:predargs`eq P P}
	true.

- : predargs`eq-reflexive _ predargs`eq/.

%worlds () (predargs`eq-reflexive _ _).
%total { } (predargs`eq-reflexive _ _).

		    
%theorem predargs`eq-symmetric : 
	forall* {K} {P1:predargs K} {K2} {P2: predargs K2}
	forall {E:predargs`eq P1 P2}
	exists {F:predargs`eq P2 P1}
	true.

- : predargs`eq-symmetric (predargs`eq/) (predargs`eq/).

%worlds () (predargs`eq-symmetric _ _).
%total { } (predargs`eq-symmetric _ _).


%theorem predargs`eq-transitive : 
	forall* {K} {P1:predargs K} 
		{K2} {P2:predargs K2} {K3} {P3:predargs K3}
	forall {E1:predargs`eq P1 P2} {E2:predargs`eq P2 P3}
	exists {F:predargs`eq P1 P3}
	true.

- : predargs`eq-transitive (predargs`eq/) (predargs`eq/) (predargs`eq/).

%worlds () (predargs`eq-transitive _ _ _).
%total { } (predargs`eq-transitive _ _ _).



%%% Theorems about equiv


%theorem false-implies-equiv :
	forall* {Pi1} {Pi2}
	forall {F:void}
	exists {EQ:equiv Pi1 Pi2}
	true.

%worlds (gtermvar) (false-implies-equiv _ _).
%total { } (false-implies-equiv _ _).


%theorem equiv-respects-eq :
	forall* {Pi1} {Pi1'} {Pi2} {Pi2'}
	forall {E1:equiv Pi1 Pi1'} {E:eq Pi1 Pi2} {E':eq Pi1' Pi2'}
	exists {E2:equiv Pi2 Pi2'}
	true.

- : equiv-respects-eq EQ eq/ eq/ EQ.

%worlds (gtermvar) (equiv-respects-eq _ _ _ _).
%total { } (equiv-respects-eq _ _ _ _).


%% The following three theorems are included for completeness.

%theorem equiv-reflexive :
	forall {Pi}
	exists {EQ:equiv Pi Pi}
	true.

- : equiv-reflexive _ equiv/reflexive.

%worlds () (equiv-reflexive _ _).
%total { } (equiv-reflexive _ _).


%theorem equiv-symmetric :
	forall* {Pi1} {Pi2}
	forall {E12:equiv Pi1 Pi2}
	exists {E21:equiv Pi2 Pi1}
	true.

- : equiv-symmetric E12 (equiv/symmetric E12).

%worlds (gtermvar) (equiv-symmetric _ _).
%total { } (equiv-symmetric _ _).


%theorem equiv-transitive :
	forall* {Pi1} {Pi2} {Pi3}
	forall {E12:equiv Pi1 Pi2} {E23:equiv Pi2 Pi3}
	exists {E23:equiv Pi1 Pi3}
	true.

- : equiv-transitive E12 E23 (equiv/transitive E12 E23).

%worlds (gtermvar) (equiv-transitive _ _ _).
%total { } (equiv-transitive _ _ _).


%theorem equiv/frac-admissible :
	forall* {Pi1} {Pi2} {F}
	forall {EQ: equiv Pi1 Pi2}
	exists {EQF: equiv (scale F Pi1) (scale F Pi2)}
	true.

- : equiv/frac-admissible equiv/identity
	(equiv/transitive3
	  equiv/distribute
          (equiv/combine equiv/reflexive equiv/zero)
          equiv/identity).

- : equiv/frac-admissible equiv/commute
	(equiv/transitive3
	  equiv/distribute 
          equiv/commute
	  (equiv/symmetric equiv/distribute)).

- : equiv/frac-admissible equiv/associate
	(equiv/transitive5
	  equiv/distribute 
          (equiv/combine equiv/reflexive equiv/distribute)
          equiv/associate
	  (equiv/combine (equiv/symmetric equiv/distribute) equiv/reflexive)
          (equiv/symmetric equiv/distribute)).

- : equiv/frac-admissible (equiv/combine Pi1->Pi1' Pi2->Pi2')
	(equiv/transitive3
	  equiv/distribute 
          (equiv/combine QPi1->QPi1' QPi2->QPi2')
          (equiv/symmetric equiv/distribute))
    <- equiv/frac-admissible Pi1->Pi1' QPi1->QPi1'
    <- equiv/frac-admissible Pi2->Pi2' QPi2->QPi2'.

- : equiv/frac-admissible equiv/zero
	(equiv/transitive3
	  (equiv/mul Q1*Q2=Q3)
          equiv/zero
          (equiv/symmetric equiv/zero))
    <- rat`mul-total Q1*Q2=Q3.

- : equiv/frac-admissible equiv/one (equiv/mul Q*1=Q)
    <- rat`mul-right-identity _ Q*1=Q.

- : equiv/frac-admissible equiv/distribute
	(equiv/transitive4
	  (equiv/mul Q1*Q2=Q3)
	  equiv/distribute
          (equiv/combine (equiv/symmetric (equiv/mul Q1*Q2=Q3))
                         (equiv/symmetric (equiv/mul Q1*Q2=Q3)))
          (equiv/symmetric equiv/distribute))
    <- rat`mul-total Q1*Q2=Q3.

- : equiv/frac-admissible (equiv/mul Q2*Q4=Q6)
	(equiv/transitive3
	  (equiv/mul Q1*Q2=Q3)
	  (equiv/mul Q3*Q4=Q7)
	  (equiv/symmetric (equiv/mul Q1*Q6=Q7)))
    <- rat`mul-total Q1*Q2=Q3
    <- rat`mul-total Q3*Q4=Q7
    <- rat`mul-associative* Q1*Q2=Q3 Q3*Q4=Q7 Q2*Q4=Q6 Q1*Q6=Q7.

- : equiv/frac-admissible (equiv/add Q2+Q4=Q6)
	(equiv/transitive4
	  equiv/distribute
	  (equiv/combine (equiv/mul Q1*Q2=Q3) (equiv/mul Q1*Q4=Q5))
	  (equiv/add Q3+Q5=Q7)
          (equiv/symmetric (equiv/mul Q1*Q6=Q7)))
    <- rat`mul-total Q1*Q2=Q3
    <- rat`mul-total Q1*Q4=Q5
    <- rat`add-total Q3+Q5=Q7
    <- rat`mul-left-factors-over-add* Q1*Q2=Q3 Q1*Q4=Q5 Q3+Q5=Q7 Q2+Q4=Q6 
                                      Q1*Q6=Q7.

- : equiv/frac-admissible equiv/reflexive equiv/reflexive.

- : equiv/frac-admissible (equiv/symmetric Pi1->Pi2) 
	(equiv/symmetric QPi1->QPi2)
    <- equiv/frac-admissible Pi1->Pi2 QPi1->QPi2.

- : equiv/frac-admissible (equiv/transitive Pi1->Pi2 Pi2->Pi3)
	(equiv/transitive QPi1->QPi2 QPi2->QPi3)
    <- equiv/frac-admissible Pi1->Pi2 QPi1->QPi2
    <- equiv/frac-admissible Pi2->Pi3 QPi2->QPi3.

%worlds () (equiv/frac-admissible _ _).
%total (E) (equiv/frac-admissible E _).
   

%%% Theorems about null


%theorem false-implies-null :
	forall* {Pi}
	forall {F:void}
	exists {N:null Pi}
	true.

%worlds () (false-implies-null _ _).
%total { } (false-implies-null _ _).


%theorem null-implies-equiv-empty :
	forall* {Pi}
	forall {EE:null Pi} 
	exists {E:equiv Pi empty}
	true.

- : null-implies-equiv-empty null/0 equiv/reflexive.

- : null-implies-equiv-empty (null/* EE) QPi=0
    <- null-implies-equiv-empty EE Pi=0
    <- equiv/frac-admissible Pi=0 QPi=Q0
    <- equiv-transitive QPi=Q0 equiv/zero QPi=0.

- : null-implies-equiv-empty (null/+ E1 E2) 
	(equiv/transitive (equiv/combine Pi1=0 Pi2=0) equiv/identity)
    <- null-implies-equiv-empty E1 Pi1=0
    <- null-implies-equiv-empty E2 Pi2=0.

%worlds () (null-implies-equiv-empty _ _).
%total (E) (null-implies-equiv-empty E _).


%theorem equiv-preserves-null :
	forall* {Pi1} {Pi2}
	forall {N1:null Pi1} {E:equiv Pi1 Pi2} 
	exists {N2:null Pi2}
	true.

%theorem equiv-preserves-null-converse :
	forall* {Pi1} {Pi2}
	forall {N2:null Pi2} {E:equiv Pi1 Pi2} 
	exists {N1:null Pi1}
	true.

- : equiv-preserves-null (null/+ Pi=0 _) equiv/identity Pi=0.

- : equiv-preserves-null (null/+ Pi1=0 Pi2=0) equiv/commute 
                         (null/+ Pi2=0 Pi1=0).

- : equiv-preserves-null (null/+ Pi1=0 (null/+ Pi2=0 Pi3=0)) equiv/associate
			 (null/+ (null/+ Pi1=0 Pi2=0) Pi3=0).

- : equiv-preserves-null (null/+ Pi1=0 Pi2=0) (equiv/combine E1 E2)
                         (null/+ Pi1'=0 Pi2'=0)
    <- equiv-preserves-null Pi1=0 E1 Pi1'=0
    <- equiv-preserves-null Pi2=0 E2 Pi2'=0.

- : equiv-preserves-null (null/* _) equiv/zero null/0.

- : equiv-preserves-null (null/* Pi=0) equiv/one Pi=0.

- : equiv-preserves-null (null/* (null/+ Pi1=0 Pi2=0)) equiv/distribute
			 (null/+ (null/* Pi1=0) (null/* Pi2=0)).

- : equiv-preserves-null (null/* (null/* Pi=0)) (equiv/mul _)
			 (null/* Pi=0).

- : equiv-preserves-null (null/+ (null/* Pi=0) (null/* _)) (equiv/add _)
			 (null/* Pi=0).

- : equiv-preserves-null Pi=0 equiv/reflexive Pi=0.

- : equiv-preserves-null Pi1=0 (equiv/symmetric Pi2=Pi1) Pi2=0
    <- equiv-preserves-null-converse Pi1=0 Pi2=Pi1 Pi2=0.

- : equiv-preserves-null Pi1=0 (equiv/transitive Pi1=Pi2 Pi2=Pi3) Pi3=0
    <- equiv-preserves-null Pi1=0 Pi1=Pi2 Pi2=0
    <- equiv-preserves-null Pi2=0 Pi2=Pi3 Pi3=0.

- : equiv-preserves-null-converse Pi=0 equiv/identity (null/+ Pi=0 null/0).

- : equiv-preserves-null-converse (null/+ Pi2=0 Pi1=0) equiv/commute 
                                  (null/+ Pi1=0 Pi2=0).

- : equiv-preserves-null-converse 
	(null/+ (null/+ Pi1=0 Pi2=0) Pi3=0) equiv/associate
	(null/+ Pi1=0 (null/+ Pi2=0 Pi3=0)).

- : equiv-preserves-null-converse (null/+ Pi1'=0 Pi2'=0) (equiv/combine E1 E2)
                                  (null/+ Pi1=0 Pi2=0)
    <- equiv-preserves-null-converse Pi1'=0 E1 Pi1=0
    <- equiv-preserves-null-converse Pi2'=0 E2 Pi2=0.

- : equiv-preserves-null-converse null/0 equiv/zero (null/* null/0).

- : equiv-preserves-null-converse Pi=0 equiv/one (null/* Pi=0).

- : equiv-preserves-null-converse 
	(null/+ (null/* Pi1=0) (null/* Pi2=0)) equiv/distribute
	(null/* (null/+ Pi1=0 Pi2=0)).

- : equiv-preserves-null-converse (null/* Pi=0) (equiv/mul _) 
			          (null/* (null/* Pi=0)) .

- : equiv-preserves-null-converse (null/* Pi=0) (equiv/add _) 
			          (null/+ (null/* Pi=0) (null/* Pi=0)).

- : equiv-preserves-null-converse Pi=0 equiv/reflexive Pi=0.

- : equiv-preserves-null-converse Pi1=0 (equiv/symmetric Pi2=Pi1) Pi2=0
    <- equiv-preserves-null Pi1=0 Pi2=Pi1 Pi2=0.

- : equiv-preserves-null-converse Pi3=0 (equiv/transitive Pi1=Pi2 Pi2=Pi3) Pi1=0
    <- equiv-preserves-null-converse Pi3=0 Pi2=Pi3 Pi2=0
    <- equiv-preserves-null-converse Pi2=0 Pi1=Pi2 Pi1=0.


%worlds () (equiv-preserves-null _ _ _) 
	   (equiv-preserves-null-converse _ _ _).

%total (E ER) (equiv-preserves-null _ E _) 
	      (equiv-preserves-null-converse _ ER _).


%theorem equiv-empty-implies-null :
	forall* {Pi}
	forall {E:equiv Pi empty}
	exists {EE:null Pi} 
	true.

- : equiv-empty-implies-null Pi=0 N
    <- equiv-preserves-null-converse null/0 Pi=0 N.

%worlds () (equiv-empty-implies-null _ _).
%total { } (equiv-empty-implies-null _ _).



%%% theorems for nonnull


%theorem false-implies-nonnull :
	forall* {Pi} {Q}
	forall {F:void}
	exists {N:nonnull Pi Q}
	true.

%worlds () (false-implies-nonnull _ _).
%total { } (false-implies-nonnull _ _).


%theorem nonnull-respects-equ :
	forall* {Pi} {Q1} {Q2}
	forall {N1:nonnull Pi Q1} {E:equ Q1 Q2}
	exists {N2:nonnull Pi Q2}
	true.

- : nonnull-respects-equ N equ/ N.

%worlds () (nonnull-respects-equ _ _ _).
%total { } (nonnull-respects-equ _ _ _).


%theorem null-nonnull-contradiction :
	forall* {Pi} {Q}
	forall {N:null Pi} {NN:nonnull Pi Q}
	exists {F:void}
	true.

- : null-nonnull-contradiction (null/* Pi#0) (nonnull/scale Pi#Q _) F
    <- null-nonnull-contradiction Pi#0 Pi#Q F.

- : null-nonnull-contradiction (null/+ Pi#0 _) (nonnull/combine/1 Pi#Q _) F
    <- null-nonnull-contradiction Pi#0 Pi#Q F.

- : null-nonnull-contradiction (null/+ _ Pi#0) (nonnull/combine/2 _ Pi#Q) F
    <- null-nonnull-contradiction Pi#0 Pi#Q F.

- : null-nonnull-contradiction (null/+ Pi#0 _) (nonnull/combine/1+2 Pi#Q _ _) F
    <- null-nonnull-contradiction Pi#0 Pi#Q F.

%worlds () (null-nonnull-contradiction _ _ _).
%total (N) (null-nonnull-contradiction N _ _).


%theorem nonnull-deterministic :
	forall* {Pi} {Q1} {Q2}
	forall {NN1:nonnull Pi Q1}
	       {NN2:nonnull Pi Q2}
	exists {E:equ Q1 Q2}
	true.

- : nonnull-deterministic (nonnull/combine/1 Pi#Q _)
			  (nonnull/combine/1 Pi#Q' _) Q=Q'
    <- nonnull-deterministic Pi#Q Pi#Q' Q=Q'.

- : nonnull-deterministic (nonnull/combine/1 Pi#Q _) 
			  (nonnull/combine/2 Pi#0 _) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/1 _ Pi#0) 
			  (nonnull/combine/1+2 _ Pi#Q _) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/2 Pi#0 _) 
			  (nonnull/combine/1 Pi#Q _) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/2 _ Pi#Q)
			  (nonnull/combine/2 _ Pi#Q') Q=Q'
    <- nonnull-deterministic Pi#Q Pi#Q' Q=Q'.

- : nonnull-deterministic (nonnull/combine/2 Pi#0 _) 
			  (nonnull/combine/1+2 Pi#Q _ _) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/1+2 _ Pi#Q _)
			  (nonnull/combine/1 _ Pi#0) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/1+2 Pi#Q _ _)
			  (nonnull/combine/2 Pi#0 _) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3)
                          (nonnull/combine/1+2 Pi1#Q4 Pi2#Q5 Q4+Q5=Q6) Q3=Q6
    <- nonnull-deterministic Pi1#Q1 Pi1#Q4 Q1=Q4
    <- nonnull-deterministic Pi2#Q2 Pi2#Q5 Q2=Q5
    <- rat`add-deterministic Q1+Q2=Q3 Q4+Q5=Q6 Q1=Q4 Q2=Q5 Q3=Q6.

- : nonnull-deterministic (nonnull/scale Pi#Q2 Q1*Q2=Q3) 
                          (nonnull/scale Pi#Q4 Q1*Q4=Q5) Q3=Q5
    <- nonnull-deterministic Pi#Q2 Pi#Q4 Q2=Q4
    <- rat`mul-deterministic Q1*Q2=Q3 Q1*Q4=Q5 equ/ Q2=Q4 Q3=Q5.

- : nonnull-deterministic nonnull/unit nonnull/unit equ/.

%worlds () (nonnull-deterministic _ _ _).
%total (N) (nonnull-deterministic N _ _).


%theorem equiv-preserves-nonnull :
	forall* {Pi1} {Q} {Pi2}
	forall {N:nonnull Pi1 Q} {E:equiv Pi1 Pi2}
	exists {N:nonnull Pi2 Q}
	true.

%theorem equiv-preserves-nonnull-converse :
	forall* {Pi1} {Q} {Pi2}
	forall {N:nonnull Pi2 Q} {E:equiv Pi1 Pi2}
	exists {N:nonnull Pi1 Q}
	true.

- : equiv-preserves-nonnull (nonnull/combine/1 Pi#Q null/0) equiv/identity Pi#Q.

- : equiv-preserves-nonnull (nonnull/combine/1 Pi1#Q Pi2#0) equiv/commute
                            (nonnull/combine/2 Pi2#0 Pi1#Q).

- : equiv-preserves-nonnull (nonnull/combine/2 Pi1#0 Pi2#Q) equiv/commute
			    (nonnull/combine/1 Pi2#Q Pi1#0).

- : equiv-preserves-nonnull (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) 
                            equiv/commute
			    (nonnull/combine/1+2 Pi2#Q2 Pi1#Q1 Q2+Q1=Q3)
    <- rat`add-commutative Q1+Q2=Q3 Q2+Q1=Q3.

- : equiv-preserves-nonnull 
	(nonnull/combine/1 Pi1#Q (null/+ Pi2#0 Pi3#0)) equiv/associate
	(nonnull/combine/1 (nonnull/combine/1 Pi1#Q Pi2#0) Pi3#0).

- : equiv-preserves-nonnull 
	(nonnull/combine/2 Pi1#0 (nonnull/combine/1 Pi2#Q Pi3#0)) 
        equiv/associate 
	(nonnull/combine/1 (nonnull/combine/2 Pi1#0 Pi2#Q) Pi3#0).

- : equiv-preserves-nonnull
	(nonnull/combine/2 Pi1#0 (nonnull/combine/2 Pi2#0 Pi3#Q)) 
        equiv/associate 
	(nonnull/combine/2 (null/+ Pi1#0 Pi2#0) Pi3#Q).

- : equiv-preserves-nonnull
	(nonnull/combine/2 Pi1#0 (nonnull/combine/1+2 Pi2#Q2 Pi3#Q3 Q2+Q3=Q5)) 
	equiv/associate
	(nonnull/combine/1+2 (nonnull/combine/2 Pi1#0 Pi2#Q2) Pi3#Q3 Q2+Q3=Q5).

- : equiv-preserves-nonnull
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/1 Pi2#Q2 Pi4#0) Q1+Q2=Q3)
        equiv/associate
	(nonnull/combine/1 (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) Pi4#0).

- : equiv-preserves-nonnull
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/2 Pi2#0 Pi4#Q4) Q1+Q4=Q5)
        equiv/associate
	(nonnull/combine/1+2 (nonnull/combine/1 Pi1#Q1 Pi2#0) Pi4#Q4 Q1+Q4=Q5).

- : equiv-preserves-nonnull
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/1+2 Pi2#Q2 Pi4#Q4 Q2+Q4=Q6)
                             Q1+Q6=Q7) equiv/associate
        (nonnull/combine/1+2 (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3)
			     Pi4#Q4 Q3+Q4=Q7)
    <- rat`add-total Q1+Q2=Q3
    <- rat`add-associative-converse* Q2+Q4=Q6 Q1+Q6=Q7 Q1+Q2=Q3 Q3+Q4=Q7.

- : equiv-preserves-nonnull (nonnull/combine/1 Pi1#Q Pi2#0) 
			    (equiv/combine Pi1->Pi1' Pi2->Pi2')
			    (nonnull/combine/1 Pi1'#Q Pi2'#0)
    <- equiv-preserves-nonnull Pi1#Q Pi1->Pi1' Pi1'#Q
    <- equiv-preserves-null Pi2#0 Pi2->Pi2' Pi2'#0.

- : equiv-preserves-nonnull (nonnull/combine/2 Pi1#0 Pi2#Q) 
			    (equiv/combine Pi1->Pi1' Pi2->Pi2')
			    (nonnull/combine/2 Pi1'#0 Pi2'#Q)
    <- equiv-preserves-null Pi1#0 Pi1->Pi1' Pi1'#0
    <- equiv-preserves-nonnull Pi2#Q Pi2->Pi2' Pi2'#Q.

- : equiv-preserves-nonnull (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) 
			    (equiv/combine Pi1->Pi1' Pi2->Pi2')
			    (nonnull/combine/1+2 Pi1'#Q1 Pi2'#Q2 Q1+Q2=Q3)
    <- equiv-preserves-nonnull Pi1#Q1 Pi1->Pi1' Pi1'#Q1
    <- equiv-preserves-nonnull Pi2#Q2 Pi2->Pi2' Pi2'#Q2.

- : equiv-preserves-nonnull (nonnull/scale Pi#Q _) equiv/zero NN
    <- null-nonnull-contradiction null/0 Pi#Q F
    <- false-implies-nonnull F NN.

- : equiv-preserves-nonnull (nonnull/scale Pi#Q2 ONE*Q2=Q3) equiv/one Pi#Q3
    <- rat`mul-left-identity _ ONE*Q2=Q2
    <- rat`mul-deterministic ONE*Q2=Q2 ONE*Q2=Q3 equ/ equ/ Q2=Q3
    <- nonnull-respects-equ Pi#Q2 Q2=Q3 Pi#Q3.

- : equiv-preserves-nonnull 
	(nonnull/scale (nonnull/combine/1 Pi1#Q2 Pi2#0) Q1*Q2=Q3)
	equiv/distribute
	(nonnull/combine/1 (nonnull/scale Pi1#Q2 Q1*Q2=Q3) (null/* Pi2#0)).

- : equiv-preserves-nonnull 
	(nonnull/scale (nonnull/combine/2 Pi1#0 Pi2#Q4) Q1*Q4=Q5)
	equiv/distribute
	(nonnull/combine/2 (null/* Pi1#0) (nonnull/scale Pi2#Q4 Q1*Q4=Q5)).

- : equiv-preserves-nonnull
	(nonnull/scale (nonnull/combine/1+2 Pi1#Q2 Pi2#Q4 Q2+Q4=Q6) Q1*Q6=Q7)
	equiv/distribute
	(nonnull/combine/1+2 (nonnull/scale Pi1#Q2 Q1*Q2=Q3)
			     (nonnull/scale Pi2#Q4 Q1*Q4=Q5) Q3+Q5=Q7)
    <- rat`mul-left-distributes-over-add Q2+Q4=Q6 Q1*Q6=Q7 _ _ 
					 Q1*Q2=Q3 Q1*Q4=Q5 Q3+Q5=Q7.

- : equiv-preserves-nonnull
	(nonnull/scale (nonnull/scale Pi#Q4 Q2*Q4=Q6) Q1*Q6=Q7)
	(equiv/mul Q1*Q2=Q3)
	(nonnull/scale Pi#Q4 Q3*Q4=Q7)
    <- rat`mul-associative-converse* Q2*Q4=Q6 Q1*Q6=Q7 Q1*Q2=Q3 Q3*Q4=Q7.

- : equiv-preserves-nonnull 
	(nonnull/combine/1 (nonnull/scale Pi#Q _) (null/* Pi#0)) (equiv/add _) N
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-nonnull F N.

- : equiv-preserves-nonnull 
	(nonnull/combine/2 (null/* Pi#0) (nonnull/scale Pi#Q _)) (equiv/add _) N
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-nonnull F N.

- : equiv-preserves-nonnull
	(nonnull/combine/1+2 (nonnull/scale Pi#Q4 Q1*Q4=Q5)
                             (nonnull/scale Pi#Q4' Q2*Q4'=Q6)
		 	     Q5+Q6=Q7)
	(equiv/add Q1+Q2=Q3)
	(nonnull/scale Pi#Q4 Q3*Q4=Q7)
    <- nonnull-deterministic Pi#Q4' Pi#Q4 Q4'=Q4
    <- rat`mul-respects-equ Q2*Q4'=Q6 equ/ Q4'=Q4 equ/ Q2*Q4=Q6
    <- rat`mul-right-factors-over-add* Q1*Q4=Q5 Q2*Q4=Q6 Q5+Q6=Q7 Q1+Q2=Q3
				       Q3*Q4=Q7.

- : equiv-preserves-nonnull Pi#Q equiv/reflexive Pi#Q.

- : equiv-preserves-nonnull Pi1#Q (equiv/symmetric Pi2->Pi1) Pi2#Q
    <- equiv-preserves-nonnull-converse Pi1#Q Pi2->Pi1 Pi2#Q.

- : equiv-preserves-nonnull Pi1#Q (equiv/transitive Pi1->Pi2 Pi2->Pi3) Pi3#Q
    <- equiv-preserves-nonnull Pi1#Q Pi1->Pi2 Pi2#Q
    <- equiv-preserves-nonnull Pi2#Q Pi2->Pi3 Pi3#Q.

%% now the converse rules

- : equiv-preserves-nonnull-converse 
	Pi#Q equiv/identity (nonnull/combine/1 Pi#Q null/0).

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1 Pi1#Q Pi2#0) equiv/commute
        (nonnull/combine/2 Pi2#0 Pi1#Q).

- : equiv-preserves-nonnull-converse
	(nonnull/combine/2 Pi1#0 Pi2#Q) equiv/commute
	(nonnull/combine/1 Pi2#Q Pi1#0).

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) 
        equiv/commute
	(nonnull/combine/1+2 Pi2#Q2 Pi1#Q1 Q2+Q1=Q3)
    <- rat`add-commutative Q1+Q2=Q3 Q2+Q1=Q3.

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1 (nonnull/combine/1 Pi1#Q Pi2#0) Pi3#0)
	equiv/associate
	(nonnull/combine/1 Pi1#Q (null/+ Pi2#0 Pi3#0)).

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1 (nonnull/combine/2 Pi1#0 Pi2#Q) Pi3#0)
        equiv/associate 
	(nonnull/combine/2 Pi1#0 (nonnull/combine/1 Pi2#Q Pi3#0)). 

- : equiv-preserves-nonnull-converse
	(nonnull/combine/2 (null/+ Pi1#0 Pi2#0) Pi3#Q)
        equiv/associate 
	(nonnull/combine/2 Pi1#0 (nonnull/combine/2 Pi2#0 Pi3#Q)).

- : equiv-preserves-nonnull-converse
	(nonnull/combine/1+2 (nonnull/combine/2 Pi1#0 Pi2#Q2) Pi3#Q3 Q2+Q3=Q5)
	equiv/associate
	(nonnull/combine/2 Pi1#0 (nonnull/combine/1+2 Pi2#Q2 Pi3#Q3 Q2+Q3=Q5)). 

- : equiv-preserves-nonnull-converse
	(nonnull/combine/1 (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) Pi4#0)
        equiv/associate
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/1 Pi2#Q2 Pi4#0) Q1+Q2=Q3).

- : equiv-preserves-nonnull-converse
	(nonnull/combine/1+2 (nonnull/combine/1 Pi1#Q1 Pi2#0) Pi4#Q4 Q1+Q4=Q5)
        equiv/associate
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/2 Pi2#0 Pi4#Q4) Q1+Q4=Q5).

- : equiv-preserves-nonnull-converse
        (nonnull/combine/1+2 (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3)
			     Pi4#Q4 Q3+Q4=Q7)
        equiv/associate
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/1+2 Pi2#Q2 Pi4#Q4 Q2+Q4=Q6)
                             Q1+Q6=Q7) 
    <- rat`add-associative Q1+Q2=Q3 Q3+Q4=Q7 _ Q2+Q4=Q6 Q1+Q6=Q7.

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1 Pi1'#Q Pi2'#0) 
	(equiv/combine Pi1->Pi1' Pi2->Pi2')
	(nonnull/combine/1 Pi1#Q Pi2#0)
    <- equiv-preserves-nonnull-converse Pi1'#Q Pi1->Pi1' Pi1#Q
    <- equiv-preserves-null-converse Pi2'#0 Pi2->Pi2' Pi2#0.

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/2 Pi1'#0 Pi2'#Q)
	(equiv/combine Pi1->Pi1' Pi2->Pi2')
	(nonnull/combine/2 Pi1#0 Pi2#Q) 
    <- equiv-preserves-null-converse Pi1'#0 Pi1->Pi1' Pi1#0
    <- equiv-preserves-nonnull-converse Pi2'#Q Pi2->Pi2' Pi2#Q.

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1+2 Pi1'#Q1 Pi2'#Q2 Q1+Q2=Q3)
	(equiv/combine Pi1->Pi1' Pi2->Pi2')
	(nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) 
    <- equiv-preserves-nonnull-converse Pi1'#Q1 Pi1->Pi1' Pi1#Q1
    <- equiv-preserves-nonnull-converse Pi2'#Q2 Pi2->Pi2' Pi2#Q2.

- : equiv-preserves-nonnull-converse 
	Pi#Q2 equiv/one (nonnull/scale Pi#Q2 ONE*Q2=Q2)
    <- rat`mul-left-identity _ ONE*Q2=Q2.

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1 (nonnull/scale Pi1#Q2 Q1*Q2=Q3) (null/* Pi2#0))
	equiv/distribute
	(nonnull/scale (nonnull/combine/1 Pi1#Q2 Pi2#0) Q1*Q2=Q3).

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/2 (null/* Pi1#0) (nonnull/scale Pi2#Q4 Q1*Q4=Q5))
	equiv/distribute
	(nonnull/scale (nonnull/combine/2 Pi1#0 Pi2#Q4) Q1*Q4=Q5).

- : equiv-preserves-nonnull-converse
	(nonnull/combine/1+2 (nonnull/scale Pi1#Q2 Q1*Q2=Q3)
			     (nonnull/scale Pi2#Q4 Q1*Q4=Q5) Q3+Q5=Q7)
	equiv/distribute
	(nonnull/scale (nonnull/combine/1+2 Pi1#Q2 Pi2#Q4 Q2+Q4=Q6) Q1*Q6=Q7)
    <- rat`mul-left-factors-over-add Q1*Q2=Q3 Q1*Q4=Q5 Q3+Q5=Q7
                                     _ Q2+Q4=Q6 Q1*Q6=Q7.
					 
- : equiv-preserves-nonnull-converse
	(nonnull/scale Pi#Q4 Q3*Q4=Q7)
	(equiv/mul Q1*Q2=Q3)
	(nonnull/scale (nonnull/scale Pi#Q4 Q2*Q4=Q6) Q1*Q6=Q7)
    <- rat`mul-associative Q1*Q2=Q3 Q3*Q4=Q7 _ Q2*Q4=Q6 Q1*Q6=Q7.

- : equiv-preserves-nonnull-converse
	(nonnull/scale Pi#Q4 Q3*Q4=Q7)
	(equiv/add Q1+Q2=Q3)
	(nonnull/combine/1+2 (nonnull/scale Pi#Q4 Q1*Q4=Q5)
                             (nonnull/scale Pi#Q4 Q2*Q4=Q6)
		 	     Q5+Q6=Q7)
    <- rat`mul-right-distributes-over-add Q1+Q2=Q3 Q3*Q4=Q7 _ _ 
                                          Q1*Q4=Q5 Q2*Q4=Q6 Q5+Q6=Q7.

- : equiv-preserves-nonnull-converse Pi#Q equiv/reflexive Pi#Q.

- : equiv-preserves-nonnull-converse Pi1#Q (equiv/symmetric Pi2->Pi1) Pi2#Q
    <- equiv-preserves-nonnull Pi1#Q Pi2->Pi1 Pi2#Q.

- : equiv-preserves-nonnull-converse Pi3#Q (equiv/transitive Pi1->Pi2 Pi2->Pi3) Pi1#Q
    <- equiv-preserves-nonnull-converse Pi3#Q Pi2->Pi3 Pi2#Q
    <- equiv-preserves-nonnull-converse Pi2#Q Pi1->Pi2 Pi1#Q.

%worlds () (equiv-preserves-nonnull _ _ _)
           (equiv-preserves-nonnull-converse _ _ _).

%total (E ER) (equiv-preserves-nonnull _ E _)
              (equiv-preserves-nonnull-converse _ ER _).



%%% theorems for null?


%theorem null?-total* :
	forall {Pi}
	exists {B} {N?:null? Pi B}
	true.

%theorem null?-total*/combine :
	forall* {Pi1} {Pi2} {B1} {B2}
        forall {N1:null? Pi1 B1}
               {N2:null? Pi2 B2}
	exists {B} {N?:null? (Pi1 , Pi2) B}
	true.

- : null?-total*/combine (null?/yes Pi1#0) (null?/yes Pi2#0) _
                         (null?/yes (null/+ Pi1#0 Pi2#0)).

- : null?-total*/combine (null?/yes Pi1#0) (null?/no Pi2#Q) _
			 (null?/no (nonnull/combine/2 Pi1#0 Pi2#Q)).

- : null?-total*/combine (null?/no Pi1#Q) (null?/yes Pi2#0) _
			 (null?/no (nonnull/combine/1 Pi1#Q Pi2#0)).

- : null?-total*/combine (null?/no Pi1#Q1) (null?/no Pi2#Q2) _
			 (null?/no (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3))
    <- rat`add-total Q1+Q2=Q3.

%worlds () (null?-total*/combine _ _ _ _).
%total { } (null?-total*/combine _ _ _ _).

%theorem null?-total*/scale :
	forall* {Pi1} {B1} {F}
        forall {N1:null? Pi1 B1}
	exists {B} {N?:null? (scale F Pi1) B}
	true.

- : null?-total*/scale (null?/yes Pi#0) _ (null?/yes (null/* Pi#0)).

- : null?-total*/scale (null?/no Pi#Q2) _ 
                       (null?/no (nonnull/scale Pi#Q2 Q1*Q2=Q3))
    <- rat`mul-total Q1*Q2=Q3.

%worlds () (null?-total*/scale _ _ _).
%total { } (null?-total*/scale _ _ _).

- : null?-total* _ _ (null?/yes null/0).

- : null?-total* (Pi1 , Pi2) _ N?
    <- null?-total* _ _ Pi1#?
    <- null?-total* _ _ Pi2#?
    <- null?-total*/combine Pi1#? Pi2#? _ N?.

- : null?-total* (scale _ _) _ N?
    <- null?-total* _ _ Pi#?
    <- null?-total*/scale Pi#? _ N?.

- : null?-total* _ _ (null?/no nonnull/unit).

%worlds () (null?-total* _ _ _).
%total (P) (null?-total* P _ _).

%abbrev null?-total = null?-total* _ _.


%theorem combine-right-identity-null :
	forall* {Pi1} {Pi2} {Pi1'}
	forall {EQC:equiv (Pi1 , Pi2) Pi1'}
               {EQ1:equiv Pi1 Pi1'}
	exists {N2:null Pi2}
	true.

%theorem combine-right-identity-null/L :
	forall* {Pi1} {Pi2} {B1} {B2}
	forall {EQC:equiv (Pi1 , Pi2) Pi1}
               {N1?:null? Pi1 B1}
               {N2?:null? Pi2 B2}
	exists {N2:null Pi2}
	true.

- : combine-right-identity-null EQC EQ1 N2
    <- null?-total N1?
    <- null?-total N2?
    <- combine-right-identity-null/L 
	(equiv/transitive EQC (equiv/symmetric EQ1)) N1? N2? N2.

- : combine-right-identity-null/L _ _ (null?/yes N2) N2.

- : combine-right-identity-null/L EQC (null?/yes Pi1#0) (null?/no Pi2#Q) N2
    <- equiv-preserves-nonnull (nonnull/combine/2 Pi1#0 Pi2#Q) EQC Pi1#Q
    <- null-nonnull-contradiction Pi1#0 Pi1#Q F
    <- false-implies-null F N2.

- : combine-right-identity-null/L EQC (null?/no Pi1#Q1) (null?/no Pi2#Q2) N2
    <- rat`add-total Q1+Q2=Q3
    <- equiv-preserves-nonnull (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) 
                               EQC Pi1#Q3
    <- nonnull-deterministic Pi1#Q1 Pi1#Q3 Q1=Q3
    <- rat`add-implies-grt Q1+Q2=Q3 Q3>Q1 _
    <- rat`grt-respects-equ Q3>Q1 equ/ Q1=Q3 Q3>Q3
    <- rat`grt-anti-reflexive Q3>Q3 F
    <- false-implies-null F N2.

%worlds () (combine-right-identity-null/L _ _ _ _).
%total { } (combine-right-identity-null/L _ _ _ _).

%worlds () (combine-right-identity-null _ _ _).
%total { } (combine-right-identity-null _ _ _).


%{%
%% too difficult now: see canonical.elf
%theorem combine-left-cancels :
	forall* {Pi1} {Pi2} {Pi1'} {Pi2'}
	forall {EQC:equiv (Pi1 , Pi2) (Pi1' , Pi2')}
               {EQ1:equiv Pi1 Pi1'}
	exists {EQ2:equiv Pi2 Pi2'}
	true.
%}%



%%% Theorems about leq


%theorem false-implies-leq :
	forall* {Pi1} {Pi2}
	forall {F:void}
	exists {L:leq Pi1 Pi2}
	true.

%worlds () (false-implies-leq _ _).
%total { } (false-implies-leq _ _).


%theorem leq-respects-eq :
	forall* {Pi1} {Pi2} {Pi3} {Pi4}
	forall {L12:leq Pi1 Pi2} {E13:eq Pi1 Pi3} {E24:eq Pi2 Pi4}
	exists {L34:leq Pi3 Pi4}
	true.

- : leq-respects-eq L eq/ eq/ L.

%worlds () (leq-respects-eq _ _ _ _).
%total { } (leq-respects-eq _ _ _ _).


%theorem leq-reflexive :
	forall {Pi}
	exists {L:leq Pi Pi}
	true.

- : leq-reflexive _ (leq/ equiv/identity).

%worlds () (leq-reflexive _ _).
%total { } (leq-reflexive _ _).


%theorem leq-anti-symmetric :
	forall* {Pi1} {Pi2}
	forall {L1:leq Pi1 Pi2}
	       {L2:leq Pi2 Pi1}
	exists {EQ:equiv Pi1 Pi2}
	true.

- : leq-anti-symmetric (leq/ (Pi1,X=Pi2 : equiv (Pi1 , X) Pi2))
                       (leq/ (Pi2,Y=Pi1 : equiv (Pi2 , Y) Pi1))
                       (equiv/transitive3
			 (equiv/symmetric equiv/identity)
		         (equiv/combine equiv/reflexive (equiv/symmetric X->0))
                         Pi1,X=Pi2)
    <- combine-right-identity-null
       (equiv/transitive3
         equiv/associate
         (equiv/combine Pi1,X=Pi2 equiv/reflexive)
         Pi2,Y=Pi1)
       (equiv/reflexive) (null/+ X#0 Y#0)
    <- null-implies-equiv-empty X#0 X->0.
    
%worlds () (leq-anti-symmetric _ _ _).
%total { } (leq-anti-symmetric _ _ _).


%theorem leq-transitive :
	forall* {Pi1} {Pi2} {Pi3}
	forall {L12:leq Pi1 Pi2}
	       {L23:leq Pi2 Pi3}
	exists {L13:leq Pi1 Pi3}
	true.

- : leq-transitive (leq/ (Pi1,X=Pi2 : equiv (Pi1 , X) Pi2))
                   (leq/ (Pi2,Y=Pi3 : equiv (Pi2 , Y) Pi3))
                   (leq/ (equiv/transitive
                           (equiv/associate :
                            equiv (Pi1 , (X , Y)) ((Pi1 , X), Y)) 
                           (equiv/transitive 
                             (equiv/combine Pi1,X=Pi2 equiv/reflexive :
                              equiv ((Pi1 , X), Y) (Pi2 , Y))
                             Pi2,Y=Pi3))).

%worlds () (leq-transitive _ _ _).
%total { } (leq-transitive _ _ _).
%%%%% Generated by TwelfMapNatural Version 0.4
%%%% Abbreviations



%abbrev nat#eq : nat -> nat -> type = nat`eq .
%abbrev nat#eq/ : nat`eq N N = nat`eq/ .
%abbrev nat#ne : nat -> nat -> type = nat`ne .
%abbrev nat#eq? : nat -> nat -> bool -> type = nat`eq? .
%abbrev nat#eq?/yes : nat`eq? N N true = nat`eq?/yes .
%abbrev nat#eq?/no : nat`ne N1 N2 -> nat`eq? N1 N2 false = nat`eq?/no .
%abbrev nat#eq?-total : nat`eq? N1 N2 B -> type = nat`eq?-total .
%abbrev nat#eq-ne-implies-false : nat`eq N1 N2 -> nat`ne N1 N2 -> void -> type = nat`eq-ne-implies-false .
%abbrev 0 : nat = z .
%abbrev 1 : nat = s 0 .
%abbrev 2 : nat = s 1 .
%abbrev 3 : nat = s 2 .
%abbrev 4 : nat = s 3 .
%abbrev 5 : nat = s 4 .
%abbrev 6 : nat = s 5 .
%abbrev 0+N=N : plus 0 N N = nat`plus/z .
%abbrev 0+0=0 : plus 0 0 0 = nat`plus/z .
%abbrev 1+N=sN : plus 1 N (s N) = nat`plus/s 0+N=N .
%abbrev 1>0 : gt 1 0 = nat`gt/1 .
%abbrev 2>0 : gt 2 0 = nat`gt/> 1>0 .
%abbrev 3>0 : gt 3 0 = nat`gt/> 2>0 .
%abbrev 1+0=1 : plus 1 0 1 = nat`plus/s 0+0=0 .
%abbrev 0+1=1 : plus 0 1 1 = nat`plus/z .
%abbrev 2>1 : gt 2 1 = nat`gt/1 .
%abbrev 3>1 : gt 3 1 = nat`gt/> 2>1 .
%abbrev 2+0=2 : plus 2 0 2 = nat`plus/s 1+0=1 .
%abbrev 0+2=2 : plus 0 2 2 = nat`plus/z .
%abbrev 3>2 : gt 3 2 = nat`gt/1 .
%abbrev 4>0 : gt 4 0 = nat`gt/> 3>0 .
%abbrev 5>0 : gt 5 0 = nat`gt/> 4>0 .
%abbrev 4>1 : gt 4 1 = nat`gt/> 3>1 .
%abbrev 5>1 : gt 5 1 = nat`gt/> 4>1 .
%abbrev 0+3=3 : plus 0 3 3 = nat`plus/z .
%abbrev 1+2=3 : plus 1 2 3 = nat`plus/s 0+2=2 .
%abbrev 2+2=4 : plus 2 2 4 = nat`plus/s 1+2=3 .
%abbrev 3+2=5 : plus 3 2 5 = nat`plus/s 2+2=4 .
%abbrev 2+N=ssN : plus 2 N (s (s N)) = nat`plus/s 1+N=sN .
%abbrev 3+N=sssN : plus 3 N (s (s (s N))) = nat`plus/s 2+N=ssN .
%abbrev 4+N=ssssN : plus 4 N (s (s (s (s N)))) = nat`plus/s 3+N=sssN .
%abbrev 0+5=5 : plus 0 5 5 = nat`plus/z .
%abbrev 5+N=sssssN : plus 5 N (s (s (s (s (s N))))) = nat`plus/s 4+N=ssssN .
%abbrev 0*0=0 : times 0 0 0 = nat`times/z .
%abbrev 1*0=0 : times 1 0 0 = nat`times/s 0*0=0 0+0=0 .
%abbrev 2*0=0 : times 2 0 0 = nat`times/s 1*0=0 0+0=0 .
%abbrev 3+0=3 : plus 3 0 3 = nat`plus/s 2+0=2 .
%abbrev 0*1=0 : times 0 1 0 = nat`times/z .
%abbrev 1*1=1 : times 1 1 1 = nat`times/s 0*1=0 0+1=1 .
%abbrev 0*2=0 : times 0 2 0 = nat`times/z .
%abbrev 1*2=2 : times 1 2 2 = nat`times/s 0*2=0 0+2=2 .
%abbrev 4>2 : gt 4 2 = nat`gt/> 3>2 .
%abbrev 5>2 : gt 5 2 = nat`gt/> 4>2 .
%abbrev 4>3 : gt 4 3 = nat`gt/1 .
%abbrev 5>3 : gt 5 3 = nat`gt/> 4>3 .
%abbrev 5>4 : gt 5 4 = nat`gt/1 .
%abbrev 4+0=4 : plus 4 0 4 = nat`plus/s 3+0=3 .
%abbrev 5+0=5 : plus 5 0 5 = nat`plus/s 4+0=4 .
%abbrev 0$0=0 : natpair`pair2nat (natpair/ 0 0) 0 = pair2nat/00 .
%abbrev 3*0=0 : times 3 0 0 = nat`times/s 2*0=0 0+0=0 .
%abbrev 4*0=0 : times 4 0 0 = nat`times/s 3*0=0 0+0=0 .
%abbrev 5*0=0 : times 5 0 0 = nat`times/s 4*0=0 0+0=0 .
%abbrev 6>0 : gt 6 0 = nat`gt/> 5>0 .
%abbrev 6>1 : gt 6 1 = nat`gt/> 5>1 .
%abbrev 6>2 : gt 6 2 = nat`gt/> 5>2 .
%abbrev 6>3 : gt 6 3 = nat`gt/> 5>3 .
%abbrev 6>4 : gt 6 4 = nat`gt/> 5>4 .
%abbrev 6>5 : gt 6 5 = nat`gt/1 .
%abbrev 0*4=0 : times 0 4 0 = nat`times/z .
%abbrev 1/2=0,1 : divrem 1 2 0 1 = nat`divrem/z 2>1 .
%abbrev 0/2=0,0 : divrem 0 2 0 0 = nat`divrem/z 2>0 .
%abbrev 0$1=1 : natpair`pair2nat (natpair/ 0 1) 1 = pair2nat/XX 0+1=1 0+0=0 0*2=0 0*4=0 0$0=0 1/2=0,1 0/2=0,0 .
%abbrev sN>N : gt (s N) N = nat`gt/1 .
%abbrev ssN>N : gt (s (s N)) N = nat`gt/> sN>N .




%%%% Definitions



%%% Definition of mapping


rat#map : rat -> nat -> type .

kind#map : kind -> nat -> type .

vark#map : vark -> nat -> type .

predtype#map : predtype -> nat -> type .



%% Cases

rat#map/whole : nat`eq 0 N0 -> nat`eq A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> nat`eq 0 NV -> times 2 N1 TN -> plus 0 TN PN -> plus 0 NV NA -> plus PN NA N -> rat#map (whole A0) N .

rat#map/frac : nat`eq 0 N0 -> nat`eq A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> rat#map A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> nat`eq 0 NV -> times 2 N2 TN -> plus 1 TN PN -> plus 0 NV NA -> plus PN NA N -> rat#map (frac A0 A1) N .

kind#map/permissionk : nat`eq 0 N0 -> nat`eq 0 NV -> nat`eq N0 PN -> plus 0 NV NA -> plus PN NA N -> kind#map permissionk N .

kind#map/upermk : nat`eq 0 N0 -> nat`eq 0 NV -> nat`eq N0 PN -> plus 1 NV NA -> plus PN NA N -> kind#map upermk N .

kind#map/formulak : nat`eq 0 N0 -> nat`eq 0 NV -> nat`eq N0 PN -> plus 2 NV NA -> plus PN NA N -> kind#map formulak N .

vark#map/objectk : nat`eq 0 N0 -> nat`eq 0 NV -> nat`eq N0 PN -> plus 0 NV NA -> plus PN NA N -> vark#map objectk N .

vark#map/fractionk : nat`eq 0 N0 -> nat`eq 0 NV -> nat`eq N0 PN -> plus 1 NV NA -> plus PN NA N -> vark#map fractionk N .

vark#map/termk : nat`eq 0 N0 -> kind#map A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> nat`eq 0 NV -> nat`eq N1 PN -> plus 2 NV NA -> plus PN NA N -> vark#map (termk A0) N .

predtype#map/predtype/0 : nat`eq 0 N0 -> nat`eq 0 NV -> nat`eq N0 PN -> plus 0 NV NA -> plus PN NA N -> predtype#map predtype/0 N .

predtype#map/predtype/+ : nat`eq 0 N0 -> vark#map A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> predtype#map A1 NA1 -> times 5 NA1 NT1 -> plus N1 NT1 N2 -> nat`eq 0 NV -> times 1 N2 TN -> plus 0 TN PN -> plus 1 NV NA -> plus PN NA N -> predtype#map (predtype/+ A0 A1) N .







%%% Definitions for inequality and equality testing


rat#eq : rat -> rat -> type .

rat#ne : rat -> rat -> type .

rat#eq? : rat -> rat -> bool -> type .

kind#eq : kind -> kind -> type .

kind#ne : kind -> kind -> type .

kind#eq? : kind -> kind -> bool -> type .

vark#eq : vark -> vark -> type .

vark#ne : vark -> vark -> type .

vark#eq? : vark -> vark -> bool -> type .

predtype#eq : predtype -> predtype -> type .

predtype#ne : predtype -> predtype -> type .

predtype#eq? : predtype -> predtype -> bool -> type .



%% Cases

rat#eq/ : rat#eq X X .

rat#ne/ : rat#map X1 N1 -> rat#map X2 N2 -> nat`ne N1 N2 -> rat#ne X1 X2 .

rat#eq?/yes : rat#eq? X X true .

rat#eq?/no : rat#ne X1 X2 -> rat#eq? X1 X2 false .

kind#eq/ : kind#eq X X .

kind#ne/ : kind#map X1 N1 -> kind#map X2 N2 -> nat`ne N1 N2 -> kind#ne X1 X2 .

kind#eq?/yes : kind#eq? X X true .

kind#eq?/no : kind#ne X1 X2 -> kind#eq? X1 X2 false .

vark#eq/ : vark#eq X X .

vark#ne/ : vark#map X1 N1 -> vark#map X2 N2 -> nat`ne N1 N2 -> vark#ne X1 X2 .

vark#eq?/yes : vark#eq? X X true .

vark#eq?/no : vark#ne X1 X2 -> vark#eq? X1 X2 false .

predtype#eq/ : predtype#eq X X .

predtype#ne/ : predtype#map X1 N1 -> predtype#map X2 N2 -> nat`ne N1 N2 -> predtype#ne X1 X2 .

predtype#eq?/yes : predtype#eq? X X true .

predtype#eq?/no : predtype#ne X1 X2 -> predtype#eq? X1 X2 false .








%%%% Theorems



%%%   Auxiliary theorems about mapping


%theorem false-implies-rat#:
	forall
		{F:void}
	exists
		{X:rat}
	true.

%theorem false-implies-rat#map:
	forall*
		{X:rat}
		{N:nat}
	forall
		{F:void}
	exists
		{M:rat#map X N}
	true.

%theorem false-implies-rat#eq:
	forall*
		{X:rat}
		{X':rat}
	forall
		{F:void}
	exists
		{E:rat#eq X X'}
	true.

%theorem rat#map-respects-eq:
	forall*
		{X:rat}
		{X':rat}
		{N:nat}
		{N2:nat}
	forall
		{M1:rat#map X N}
		{EQ:rat#eq X X'}
		{EQ:nat`eq N N2}
	exists
		{M2:rat#map X' N2}
	true.

%theorem false-implies-kind#:
	forall
		{F:void}
	exists
		{X:kind}
	true.

%theorem false-implies-kind#map:
	forall*
		{X:kind}
		{N:nat}
	forall
		{F:void}
	exists
		{M:kind#map X N}
	true.

%theorem false-implies-kind#eq:
	forall*
		{X:kind}
		{X':kind}
	forall
		{F:void}
	exists
		{E:kind#eq X X'}
	true.

%theorem kind#map-respects-eq:
	forall*
		{X:kind}
		{X':kind}
		{N:nat}
		{N2:nat}
	forall
		{M1:kind#map X N}
		{EQ:kind#eq X X'}
		{EQ:nat`eq N N2}
	exists
		{M2:kind#map X' N2}
	true.

%theorem false-implies-vark#:
	forall
		{F:void}
	exists
		{X:vark}
	true.

%theorem false-implies-vark#map:
	forall*
		{X:vark}
		{N:nat}
	forall
		{F:void}
	exists
		{M:vark#map X N}
	true.

%theorem false-implies-vark#eq:
	forall*
		{X:vark}
		{X':vark}
	forall
		{F:void}
	exists
		{E:vark#eq X X'}
	true.

%theorem vark#map-respects-eq:
	forall*
		{X:vark}
		{X':vark}
		{N:nat}
		{N2:nat}
	forall
		{M1:vark#map X N}
		{EQ:vark#eq X X'}
		{EQ:nat`eq N N2}
	exists
		{M2:vark#map X' N2}
	true.

%theorem false-implies-predtype#:
	forall
		{F:void}
	exists
		{X:predtype}
	true.

%theorem false-implies-predtype#map:
	forall*
		{X:predtype}
		{N:nat}
	forall
		{F:void}
	exists
		{M:predtype#map X N}
	true.

%theorem false-implies-predtype#eq:
	forall*
		{X:predtype}
		{X':predtype}
	forall
		{F:void}
	exists
		{E:predtype#eq X X'}
	true.

%theorem predtype#map-respects-eq:
	forall*
		{X:predtype}
		{X':predtype}
		{N:nat}
		{N2:nat}
	forall
		{M1:predtype#map X N}
		{EQ:predtype#eq X X'}
		{EQ:nat`eq N N2}
	exists
		{M2:predtype#map X' N2}
	true.



%% Cases

- : rat#map-respects-eq M rat#eq/ nat`eq/ M.

- : kind#map-respects-eq M kind#eq/ nat`eq/ M.

- : vark#map-respects-eq M vark#eq/ nat`eq/ M.

- : predtype#map-respects-eq M predtype#eq/ nat`eq/ M.


%worlds () (false-implies-rat# F _) (false-implies-rat#map F _) (false-implies-rat#eq F _) (rat#map-respects-eq M _ _ _) (false-implies-kind# F _) (false-implies-kind#map F _) (false-implies-kind#eq F _) (kind#map-respects-eq M _ _ _) (false-implies-vark# F _) (false-implies-vark#map F _) (false-implies-vark#eq F _) (vark#map-respects-eq M _ _ _) (false-implies-predtype# F _) (false-implies-predtype#map F _) (false-implies-predtype#eq F _) (predtype#map-respects-eq M _ _ _).
%total (F#849 F#850 F#851 M#852 F#853 F#854 F#855 M#856 F#857 F#858 F#859 M#860 F#865 F#866 F#867 M#868 ) (false-implies-rat# F#849 _) (false-implies-rat#map F#850 _) (false-implies-rat#eq F#851 _) (rat#map-respects-eq M#852 _ _ _) (false-implies-kind# F#853 _) (false-implies-kind#map F#854 _) (false-implies-kind#eq F#855 _) (kind#map-respects-eq M#856 _ _ _) (false-implies-vark# F#857 _) (false-implies-vark#map F#858 _) (false-implies-vark#eq F#859 _) (vark#map-respects-eq M#860 _ _ _) (false-implies-predtype# F#865 _) (false-implies-predtype#map F#866 _) (false-implies-predtype#eq F#867 _) (predtype#map-respects-eq M#868 _ _ _).



%%% Theorems about totality of simple mappings


%theorem rat#map-total*:
	forall
		{T:rat}
	exists
		{N:nat}
		{M:rat#map T N}
	true.

%theorem kind#map-total*:
	forall
		{T:kind}
	exists
		{N:nat}
		{M:kind#map T N}
		{G:gt 3 N}
	true.

%theorem vark#map-total*:
	forall
		{T:vark}
	exists
		{N:nat}
		{M:vark#map T N}
		{G:gt 5 N}
	true.

%theorem predtype#map-total*:
	forall
		{T:predtype}
	exists
		{N:nat}
		{M:predtype#map T N}
	true.

%abbrev rat#map-total : rat#map T N -> type = [m:rat#map T N] (rat#map-total* T N m) .

%abbrev kind#map-total : kind#map T N -> type = [m:kind#map T N] (kind#map-total* T N m G) .

%abbrev vark#map-total : vark#map T N -> type = [m:vark#map T N] (vark#map-total* T N m G) .

%abbrev predtype#map-total : predtype#map T N -> type = [m:predtype#map T N] (predtype#map-total* T N m) .



%% Cases

- : rat#map-total* _ _ (rat#map/whole nat`eq/ nat`eq/ D0 0+N=N nat`eq/ D1 0+N=N 0+0=0 D2)
    <- nat`times-left-identity _ D0
    <- nat`times-total D1
    <- nat`plus-total D2.

- : rat#map-total* _ _ (rat#map/frac nat`eq/ nat`eq/ D0 0+N=N D1 D2 nat`eq/ D3 1+N=sN 0+0=0 D4)
    <- nat`times-left-identity _ D0
    <- rat#map-total* _ _ D1
    <- natpair`pair2nat-total D2
    <- nat`times-total D3
    <- nat`plus-total D4.

- : kind#map-total* _ _ (kind#map/permissionk nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+0=0) 3>0.

- : kind#map-total* _ _ (kind#map/upermk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+1=1) 3>1.

- : kind#map-total* _ _ (kind#map/formulak nat`eq/ nat`eq/ nat`eq/ 2+0=2 0+2=2) 3>2.

- : vark#map-total* _ _ (vark#map/objectk nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+0=0) 5>0.

- : vark#map-total* _ _ (vark#map/fractionk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+1=1) 5>1.

- : vark#map-total* _ _ (vark#map/termk nat`eq/ D0 D1 0+N=N nat`eq/ nat`eq/ 2+0=2 D3) G3
    <- kind#map-total* _ _ D0 G0
    <- nat`times-left-identity _ D1
    <- plus-left-preserves-gt* G0 0+3=3 0+N=N G2
    <- nat`plus-total D3
    <- plus-right-preserves-gt* G2 3+2=5 D3 G3.

- : predtype#map-total* _ _ (predtype#map/predtype/0 nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+0=0).

- : predtype#map-total* _ _ (predtype#map/predtype/+ nat`eq/ D0 D1 0+N=N D3 D4 D5 nat`eq/ D6 0+N=N 1+0=1 D7)
    <- vark#map-total* _ _ D0 G0
    <- nat`times-left-identity _ D1
    <- plus-left-preserves-gt* G0 0+5=5 0+N=N G2
    <- predtype#map-total* _ _ D3
    <- nat`times-total D4
    <- nat`plus-total D5
    <- nat`times-left-identity _ D6
    <- nat`plus-total D7.


%worlds () (rat#map-total* N _ _) (kind#map-total* N _ _ _) (vark#map-total* N _ _ _) (predtype#map-total* N _ _).
%total (N#877 N#878 N#879 N#883 ) (rat#map-total* N#877 _ _) (kind#map-total* N#878 _ _ _) (vark#map-total* N#879 _ _ _) (predtype#map-total* N#883 _ _).



%%% A trivial theorem that enables us to treat nat`eq as a function:


%theorem nat-eq-nop:
	forall*
		{N1:nat}
		{N2:nat}
		{N3:nat}
		{N4:nat}
	forall
		{E12:nat`eq N1 N2}
		{E34:nat`eq N3 N4}
		{E13:nat`eq N1 N3}
	exists
		{E24:nat`eq N2 N4}
	true.



%% Cases

- : nat-eq-nop nat`eq/ nat`eq/ nat`eq/ nat`eq/.


%worlds () (nat-eq-nop _ _ _ _).
%total { } (nat-eq-nop _ _ _ _).



%%% Theorems about the determinism of mappings without variables


%theorem rat#map-deterministic*:
	forall*
		{N1:nat}
		{N2:nat}
	forall
		{T1:rat}
		{T2:rat}
		{M1:rat#map T1 N1}
		{M2:rat#map T2 N2}
		{ET:rat#eq T1 T2}
	exists
		{EN:nat`eq N1 N2}
	true.

%theorem kind#map-deterministic*:
	forall*
		{N1:nat}
		{N2:nat}
	forall
		{T1:kind}
		{T2:kind}
		{M1:kind#map T1 N1}
		{M2:kind#map T2 N2}
		{ET:kind#eq T1 T2}
	exists
		{EN:nat`eq N1 N2}
	true.

%theorem vark#map-deterministic*:
	forall*
		{N1:nat}
		{N2:nat}
	forall
		{T1:vark}
		{T2:vark}
		{M1:vark#map T1 N1}
		{M2:vark#map T2 N2}
		{ET:vark#eq T1 T2}
	exists
		{EN:nat`eq N1 N2}
	true.

%theorem predtype#map-deterministic*:
	forall*
		{N1:nat}
		{N2:nat}
	forall
		{T1:predtype}
		{T2:predtype}
		{M1:predtype#map T1 N1}
		{M2:predtype#map T2 N2}
		{ET:predtype#eq T1 T2}
	exists
		{EN:nat`eq N1 N2}
	true.

%abbrev rat#map-deterministic : rat#map T1 N1 -> rat#map T2 N2 -> rat#eq T1 T2 -> nat`eq N1 N2 -> type = rat#map-deterministic* _ _ .

%abbrev kind#map-deterministic : kind#map T1 N1 -> kind#map T2 N2 -> kind#eq T1 T2 -> nat`eq N1 N2 -> type = kind#map-deterministic* _ _ .

%abbrev vark#map-deterministic : vark#map T1 N1 -> vark#map T2 N2 -> vark#eq T1 T2 -> nat`eq N1 N2 -> type = vark#map-deterministic* _ _ .

%abbrev predtype#map-deterministic : predtype#map T1 N1 -> predtype#map T2 N2 -> predtype#eq T1 T2 -> nat`eq N1 N2 -> type = predtype#map-deterministic* _ _ .



%% Cases

- : rat#map-deterministic (rat#map/whole X0 X1 X2 X3 X4 X5 X6 X7 X8) (rat#map/whole Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8) rat#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- nat-eq-nop X1 Y1 nat`eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- nat-eq-nop X4 Y4 nat`eq/ ENV
    <- nat`times-deterministic X5 Y5 nat`eq/ EN1 ETN
    <- nat`plus-deterministic X6 Y6 nat`eq/ ETN EPN
    <- nat`plus-deterministic X7 Y7 nat`eq/ ENV ENA
    <- nat`plus-deterministic X8 Y8 EPN ENA EN.

- : rat#map-deterministic (rat#map/frac X0 X1 X2 X3 X4 X5 X7 X8 X9 X10 X11) (rat#map/frac Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y8 Y9 Y10 Y11) rat#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- nat-eq-nop X1 Y1 nat`eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- rat#map-deterministic X4 Y4 rat#eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- nat-eq-nop X7 Y7 nat`eq/ ENV
    <- nat`times-deterministic X8 Y8 nat`eq/ EN2 ETN
    <- nat`plus-deterministic X9 Y9 nat`eq/ ETN EPN
    <- nat`plus-deterministic X10 Y10 nat`eq/ ENV ENA
    <- nat`plus-deterministic X11 Y11 EPN ENA EN.

- : kind#map-deterministic (kind#map/permissionk X0 X1 X2 X3 X4) (kind#map/permissionk Y0 Y1 Y2 Y3 Y4) kind#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- nat-eq-nop X1 Y1 nat`eq/ ENV
    <- nat-eq-nop X2 Y2 EN0 EPN
    <- nat`plus-deterministic X3 Y3 nat`eq/ ENV ENA
    <- nat`plus-deterministic X4 Y4 EPN ENA EN.

- : kind#map-deterministic (kind#map/upermk X0 X1 X2 X3 X4) (kind#map/upermk Y0 Y1 Y2 Y3 Y4) kind#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- nat-eq-nop X1 Y1 nat`eq/ ENV
    <- nat-eq-nop X2 Y2 EN0 EPN
    <- nat`plus-deterministic X3 Y3 nat`eq/ ENV ENA
    <- nat`plus-deterministic X4 Y4 EPN ENA EN.

- : kind#map-deterministic (kind#map/formulak X0 X1 X2 X3 X4) (kind#map/formulak Y0 Y1 Y2 Y3 Y4) kind#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- nat-eq-nop X1 Y1 nat`eq/ ENV
    <- nat-eq-nop X2 Y2 EN0 EPN
    <- nat`plus-deterministic X3 Y3 nat`eq/ ENV ENA
    <- nat`plus-deterministic X4 Y4 EPN ENA EN.

- : vark#map-deterministic (vark#map/objectk X0 X1 X2 X3 X4) (vark#map/objectk Y0 Y1 Y2 Y3 Y4) vark#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- nat-eq-nop X1 Y1 nat`eq/ ENV
    <- nat-eq-nop X2 Y2 EN0 EPN
    <- nat`plus-deterministic X3 Y3 nat`eq/ ENV ENA
    <- nat`plus-deterministic X4 Y4 EPN ENA EN.

- : vark#map-deterministic (vark#map/fractionk X0 X1 X2 X3 X4) (vark#map/fractionk Y0 Y1 Y2 Y3 Y4) vark#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- nat-eq-nop X1 Y1 nat`eq/ ENV
    <- nat-eq-nop X2 Y2 EN0 EPN
    <- nat`plus-deterministic X3 Y3 nat`eq/ ENV ENA
    <- nat`plus-deterministic X4 Y4 EPN ENA EN.

- : vark#map-deterministic (vark#map/termk X0 X1 X2 X3 X4 X5 X6 X7) (vark#map/termk Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7) vark#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- kind#map-deterministic X1 Y1 kind#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- nat-eq-nop X4 Y4 nat`eq/ ENV
    <- nat-eq-nop X5 Y5 EN1 EPN
    <- nat`plus-deterministic X6 Y6 nat`eq/ ENV ENA
    <- nat`plus-deterministic X7 Y7 EPN ENA EN.

- : predtype#map-deterministic (predtype#map/predtype/0 X0 X1 X2 X3 X4) (predtype#map/predtype/0 Y0 Y1 Y2 Y3 Y4) predtype#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- nat-eq-nop X1 Y1 nat`eq/ ENV
    <- nat-eq-nop X2 Y2 EN0 EPN
    <- nat`plus-deterministic X3 Y3 nat`eq/ ENV ENA
    <- nat`plus-deterministic X4 Y4 EPN ENA EN.

- : predtype#map-deterministic (predtype#map/predtype/+ X0 X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11) (predtype#map/predtype/+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11) predtype#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- vark#map-deterministic X1 Y1 vark#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- predtype#map-deterministic X4 Y4 predtype#eq/ ENA1
    <- nat`times-deterministic X5 Y5 nat`eq/ ENA1 ENT1
    <- nat`plus-deterministic X6 Y6 EN1 ENT1 EN2
    <- nat-eq-nop X7 Y7 nat`eq/ ENV
    <- nat`times-deterministic X8 Y8 nat`eq/ EN2 ETN
    <- nat`plus-deterministic X9 Y9 nat`eq/ ETN EPN
    <- nat`plus-deterministic X10 Y10 nat`eq/ ENV ENA
    <- nat`plus-deterministic X11 Y11 EPN ENA EN.


%worlds () (rat#map-deterministic* T1 _ _ _ _ _) (kind#map-deterministic* T1 _ _ _ _ _) (vark#map-deterministic* T1 _ _ _ _ _) (predtype#map-deterministic* T1 _ _ _ _ _).
%total (T1#900 T1#901 T1#902 T1#905 ) (rat#map-deterministic* T1#900 _ _ _ _ _) (kind#map-deterministic* T1#901 _ _ _ _ _) (vark#map-deterministic* T1#902 _ _ _ _ _) (predtype#map-deterministic* T1#905 _ _ _ _ _).



%%% Definition of classify# helper relation


classify# : nat -> nat -> nat -> nat -> type .



%% Cases

classify#/low : gt L N -> classify# L B M N .

classify#/mid : plus NP L N -> gt B NP -> classify# L B M N .

classify#/high : plus B L H -> plus H NP N -> times Q M QM -> plus QM R NP -> gt M R -> classify# L B M N .







%%% Theorems about classify#


%theorem classify#-total:
	forall*
		{L:nat}
		{B:nat}
		{M:nat}
		{N:nat}
	exists
		{C:classify# L B (s M) N}
	true.



%% Cases


%theorem false-implies-classify#:
        forall* {L} {B} {M} {N}
        forall  {F:void}
        exists  {C:classify# L B M N}
        true.

%worlds () (false-implies-classify# _ _).
%total { } (false-implies-classify# _ _).

%theorem classify#-total/L :
	forall* {N} {L} {B} {H} {C1} {C2} {M}
	forall	{CM1:nat`compare N L C1}
		{P: plus B L H}
		{CM2:nat`compare N H C2}
	exists	{C:classify# L B (s M) N}
	true.

- : classify#-total/L (nat`compare/< G) _ _ (classify#/low G).

- : classify#-total/L (nat`compare/=) plus/z _
	(classify#/high plus/z P2 times/z plus/z G)
    <- plus-right-identity _ P2
    <- succ-implies-gt-zero _ G.

- : classify#-total/L (nat`compare/=) (plus/s P) _ (classify#/mid plus/z G)
    <- succ-implies-gt-zero _ G.

- : classify#-total/L (nat`compare/> GL) P (nat`compare/< GH) (classify#/mid PL G)
    <- gt-implies-plus GL _ PL
    <- plus-right-cancels-gt P PL nat`eq/ GH G.

- : classify#-total/L _ (P:plus B L H) (nat`compare/=) (classify#/high P P2 times/z plus/z G)
    <- plus-right-identity _ P2
    <- succ-implies-gt-zero _ G.

- : classify#-total/L _ P (nat`compare/> G) (classify#/high P P2 T P3 M>R)
    <- gt-implies-plus G _ P1
    <- plus-commutative P1 P2
    <- divrem-total DR
    <- divrem-can-be-inverted DR _ T P3
    <- divrem-implies-gt DR M>R.

%worlds () (classify#-total/L _ _ _ _).
%total { } (classify#-total/L _ _ _ _).

- : classify#-total C
    <- plus-total P
    <- nat`compare-total C1
    <- nat`compare-total C2
    <- classify#-total/L C1 P C2 C.
%theorem false-implies-classify#:
	forall*	{L} {B} {M} {N}
	forall	{F:void}
	exists	{C:classify# L B M N}
	true.

%worlds () (false-implies-classify# _ _).
%total { } (false-implies-classify# _ _).


%theorem classify#-total:
	forall* {L} {B} {M} {N}
	exists	{C:classify# L B (s M) N}
	true.

%theorem classify#-total/L :
	forall* {N} {L} {B} {H} {C1} {C2} {M}
	forall	{CM1:nat`compare N L C1}
		{P: plus B L H}
		{CM2:nat`compare N H C2}
	exists	{C:classify# L B (s M) N}
	true.

- : classify#-total/L (nat`compare/< G) _ _ (classify#/low G).

- : classify#-total/L (nat`compare/=) plus/z _
	(classify#/high plus/z P2 times/z plus/z G)
    <- plus-right-identity _ P2
    <- succ-implies-gt-zero _ G.

- : classify#-total/L (nat`compare/=) (plus/s P) _ (classify#/mid plus/z G)
    <- succ-implies-gt-zero _ G.

- : classify#-total/L (nat`compare/> GL) P (nat`compare/< GH) (classify#/mid PL G)
    <- gt-implies-plus GL _ PL
    <- plus-right-cancels-gt P PL nat`eq/ GH G.

- : classify#-total/L _ (P:plus B L H) (nat`compare/=) (classify#/high P P2 times/z plus/z G)
    <- plus-right-identity _ P2
    <- succ-implies-gt-zero _ G.

- : classify#-total/L _ P (nat`compare/> G) (classify#/high P P2 T P3 M>R)
    <- gt-implies-plus G _ P1
    <- plus-commutative P1 P2
    <- divrem-total DR
    <- divrem-can-be-inverted DR _ T P3
    <- divrem-implies-gt DR M>R.

%worlds () (classify#-total/L _ _ _ _).
%total { } (classify#-total/L _ _ _ _).

- : classify#-total C
    <- plus-total P
    <- nat`compare-total C1
    <- nat`compare-total C2
    <- classify#-total/L C1 P C2 C.


%worlds () (classify#-total _).
%total { } (classify#-total _).



%%% Theorems about mapping onto particular small integers


%theorem rat#map-onto/0/rat:
	exists
		{T:rat}
		{M:rat#map T 0}
	true.

%theorem rat#map-onto/1/rat:
	exists
		{T:rat}
		{M:rat#map T 1}
	true.



%% Cases

- : rat#map-onto/0/rat _ (rat#map/whole nat`eq/ nat`eq/ 1*0=0 0+0=0 nat`eq/ 2*0=0 0+0=0 0+0=0 0+0=0).

- : rat#map-onto/1/rat _ (rat#map/frac nat`eq/ nat`eq/ 1*0=0 0+0=0 M4 0$0=0 nat`eq/ 2*0=0 1+0=1 0+0=0 1+0=1)
    <- rat#map-onto/0/rat _ M4.

%worlds () (rat#map-onto/0/rat _ _).

%total { } (rat#map-onto/0/rat _ _).

%worlds () (rat#map-onto/1/rat _ _).

%total { } (rat#map-onto/1/rat _ _).








%%%  Theorems about 'onto' for mapping without variables


%theorem rat#map-onto/L:
	forall
		{N:nat}
		{CL:classify# z 0 2 N}
	exists
		{T:rat}
		{M:rat#map T N}
	true.

%theorem rat#map-onto:
	forall
		{N:nat}
	exists
		{T:rat}
		{M:rat#map T N}
	true.

%theorem kind#map-onto/L:
	forall
		{N:nat}
		{G:gt 3 N}
		{CL:classify# z 3 1 N}
	exists
		{T:kind}
		{M:kind#map T N}
	true.

%theorem kind#map-onto:
	forall
		{N:nat}
		{G:gt 3 N}
	exists
		{T:kind}
		{M:kind#map T N}
	true.

%theorem vark#map-onto/L:
	forall
		{N:nat}
		{G:gt 5 N}
		{CL:classify# z 5 1 N}
	exists
		{T:vark}
		{M:vark#map T N}
	true.

%theorem vark#map-onto:
	forall
		{N:nat}
		{G:gt 5 N}
	exists
		{T:vark}
		{M:vark#map T N}
	true.

%theorem predtype#map-onto/L:
	forall
		{N:nat}
		{CL:classify# z 1 1 N}
	exists
		{T:predtype}
		{M:predtype#map T N}
	true.

%theorem predtype#map-onto:
	forall
		{N:nat}
	exists
		{T:predtype}
		{M:predtype#map T N}
	true.



%% Cases

- : rat#map-onto N T M
    <- classify#-total CL
    <- rat#map-onto/L N CL T M.

- : kind#map-onto N G T M
    <- classify#-total CL
    <- kind#map-onto/L N G CL T M.

- : vark#map-onto N G T M
    <- classify#-total CL
    <- vark#map-onto/L N G CL T M.

- : predtype#map-onto N T M
    <- classify#-total CL
    <- predtype#map-onto/L N CL T M.

- : rat#map-onto/L _ (classify#/low G) T M
    <- nat`gt-contradiction G F
    <- false-implies-rat# F T
    <- false-implies-rat#map F M.

- : rat#map-onto/L _ (classify#/high plus/z plus/z times/z plus/z 2>0) _ (rat#map/whole nat`eq/ nat`eq/ 1*0=0 0+0=0 nat`eq/ 2*0=0 0+0=0 0+0=0 0+0=0).

- : rat#map-onto/L _ (classify#/high 0+0=0 Sub T Pmod 2>0) _ (rat#map/whole nat`eq/ nat`eq/ (times/s times/z plus/z) plus/z nat`eq/ T'4 P'4 0+0=0 S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 2>0 DR4
    <- plus-implies-ge Sub GE4
    <- meta-ge _ _ GE4
    <- quotient-of-nonzero-is-smaller DR4 nat`eq/ G4
    <- meta-gt _ _ G4.

- : rat#map-onto/L _ (classify#/high 0+0=0 Sub T Pmod 2>1) _ (rat#map/frac nat`eq/ nat`eq/ (times/s times/z plus/z) plus/z M4 NP5 nat`eq/ T'6 P'6 0+0=0 S'6)
    <- plus-commutative Sub S'6
    <- times-commutative T T'6
    <- plus-commutative Pmod P'6
    <- divrem-can-be-constructed T Pmod 2>1 DR6
    <- plus-implies-ge Sub GE6
    <- meta-ge _ _ GE6
    <- remainder-implies-gt-quotient DR6 G6
    <- meta-gt _ _ G6
    <- nat2pair-total NP5
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- rat#map-onto _ _ M4.

- : kind#map-onto/L _ GF (classify#/low G) T M
    <- nat`gt-contradiction G F
    <- false-implies-kind# F T
    <- false-implies-kind#map F M.

- : kind#map-onto/L _ GF (classify#/mid 0+N=N 3>0) _ (kind#map/permissionk nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+0=0).

- : kind#map-onto/L _ GF (classify#/mid 1+N=sN 3>1) _ (kind#map/upermk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+1=1).

- : kind#map-onto/L _ GF (classify#/mid 2+N=ssN 3>2) _ (kind#map/formulak nat`eq/ nat`eq/ nat`eq/ 2+0=2 0+2=2).

- : kind#map-onto/L _ GF (classify#/high 3+0=3 Sub _ _ GG) T M
    <- plus-commutative Sub Pmod
    <- plus-implies-ge Pmod GE
    <- ge-transitive-gt GE GF G
    <- gt-anti-reflexive G F
    <- false-implies-kind# F T
    <- false-implies-kind#map F M.

- : vark#map-onto/L _ GF (classify#/low G) T M
    <- nat`gt-contradiction G F
    <- false-implies-vark# F T
    <- false-implies-vark#map F M.

- : vark#map-onto/L _ GF (classify#/mid 0+N=N 5>0) _ (vark#map/objectk nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+0=0).

- : vark#map-onto/L _ GF (classify#/mid 1+N=sN 5>1) _ (vark#map/fractionk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+1=1).

- : vark#map-onto/L _ GF (classify#/mid 2+N=ssN 5>2) _ (vark#map/termk nat`eq/ (kind#map/permissionk nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+0=0) 1*0=0 0+0=0 nat`eq/ nat`eq/ 2+0=2 0+2=2).

- : vark#map-onto/L _ GF (classify#/mid 3+N=sssN 5>3) _ (vark#map/termk nat`eq/ (kind#map/upermk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+1=1) 1*1=1 0+1=1 nat`eq/ nat`eq/ 2+0=2 1+2=3).

- : vark#map-onto/L _ GF (classify#/mid 4+N=ssssN 5>4) _ (vark#map/termk nat`eq/ (kind#map/formulak nat`eq/ nat`eq/ nat`eq/ 2+0=2 0+2=2) 1*2=2 0+2=2 nat`eq/ nat`eq/ 2+0=2 2+2=4).

- : vark#map-onto/L _ GF (classify#/high 5+0=5 Sub _ _ GG) T M
    <- plus-commutative Sub Pmod
    <- plus-implies-ge Pmod GE
    <- ge-transitive-gt GE GF G
    <- gt-anti-reflexive G F
    <- false-implies-vark# F T
    <- false-implies-vark#map F M.

- : predtype#map-onto/L _ (classify#/low G) T M
    <- nat`gt-contradiction G F
    <- false-implies-predtype# F T
    <- false-implies-predtype#map F M.

- : predtype#map-onto/L _ (classify#/mid 0+N=N 1>0) _ (predtype#map/predtype/0 nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+0=0).

- : predtype#map-onto/L _ (classify#/high 1+0=1 Sub T Pmod 1>0) _ (predtype#map/predtype/+ nat`eq/ M1 (times/s times/z plus/z) plus/z M4 T5 P5 nat`eq/ T'7 P'7 1+0=1 S'7)
    <- plus-commutative Sub S'7
    <- times-commutative T T'7
    <- plus-commutative Pmod P'7
    <- divrem-can-be-constructed T Pmod 1>0 DR7
    <- plus-right-preserves-gt* 1>0 1+0=1 plus/z GA7
    <- gt-implies-positive GA7 _ EN7
    <- plus-implies-gt Sub EN7 G7
    <- meta-gt _ _ G7
    <- quotient-is-no-greater DR7 GE7
    <- meta-ge _ _ GE7
    <- divrem-total DR5
    <- divrem-can-be-inverted DR5 _ T'5 P'5
    <- divrem-implies-gt DR5 G5
    <- times-commutative T'5 T5
    <- plus-commutative P'5 P5
    <- quotient-is-no-greater DR5 GE5
    <- meta-ge _ _ GE5
    <- plus-implies-ge P'5 GE'5
    <- meta-ge _ _ GE'5
    <- vark#map-onto _ G5 _ M1
    <- predtype#map-onto _ _ M4.


%worlds () (rat#map-onto/L X _ _ _) (rat#map-onto X _ _) (kind#map-onto/L X _ _ _ _) (kind#map-onto X _ _ _) (vark#map-onto/L X _ _ _ _) (vark#map-onto X _ _ _) (predtype#map-onto/L X _ _ _) (predtype#map-onto X _ _).
%total (X#911 X#912 X#916 X#917 X#921 X#922 X#957 X#958 ) (rat#map-onto/L X#911 _ _ _) (rat#map-onto X#912 _ _) (kind#map-onto/L X#916 _ _ _ _) (kind#map-onto X#917 _ _ _) (vark#map-onto/L X#921 _ _ _ _) (vark#map-onto X#922 _ _ _) (predtype#map-onto/L X#957 _ _ _) (predtype#map-onto X#958 _ _).



%%%   Theorems about equality preservation


%theorem whole-respects-rat#eq:
	forall*
		{A0:nat}
		{B0:nat}
	forall
		{EQ0:nat`eq A0 B0}
	exists
		{EQ1:rat#eq (whole A0) (whole B0)}
	true.

%theorem frac-respects-rat#eq:
	forall*
		{A0:nat}
		{B0:nat}
		{A1:rat}
		{B1:rat}
	forall
		{EQ0:nat`eq A0 B0}
		{EQ1:rat#eq A1 B1}
	exists
		{EQ2:rat#eq (frac A0 A1) (frac B0 B1)}
	true.

%theorem kind#map-implies-gt:
	forall*
		{T:kind}
		{N:nat}
	forall
		{M:kind#map T N}
	exists
		{G:gt 3 N}
	true.

%theorem permissionk-respects-kind#eq:
	exists
		{EQ0:kind#eq permissionk permissionk}
	true.

%theorem upermk-respects-kind#eq:
	exists
		{EQ0:kind#eq upermk upermk}
	true.

%theorem formulak-respects-kind#eq:
	exists
		{EQ0:kind#eq formulak formulak}
	true.

%theorem vark#map-implies-gt:
	forall*
		{T:vark}
		{N:nat}
	forall
		{M:vark#map T N}
	exists
		{G:gt 5 N}
	true.

%theorem objectk-respects-vark#eq:
	exists
		{EQ0:vark#eq objectk objectk}
	true.

%theorem fractionk-respects-vark#eq:
	exists
		{EQ0:vark#eq fractionk fractionk}
	true.

%theorem termk-respects-vark#eq:
	forall*
		{A0:kind}
		{B0:kind}
	forall
		{EQ0:kind#eq A0 B0}
	exists
		{EQ1:vark#eq (termk A0) (termk B0)}
	true.

%theorem predtype/0-respects-predtype#eq:
	exists
		{EQ0:predtype#eq predtype/0 predtype/0}
	true.

%theorem predtype/+-respects-predtype#eq:
	forall*
		{A0:vark}
		{B0:vark}
		{A1:predtype}
		{B1:predtype}
	forall
		{EQ0:vark#eq A0 B0}
		{EQ1:predtype#eq A1 B1}
	exists
		{EQ2:predtype#eq (predtype/+ A0 A1) (predtype/+ B0 B1)}
	true.



%% Cases

- : whole-respects-rat#eq nat`eq/ rat#eq/.

- : frac-respects-rat#eq nat`eq/ rat#eq/ rat#eq/.

- : kind#map-implies-gt M G
    <- kind#map-total* _ _ M' G'
    <- kind#map-deterministic M' M kind#eq/ EQ
    <- nat`gt-respects-eq G' nat`eq/ EQ G.

- : permissionk-respects-kind#eq kind#eq/.

- : upermk-respects-kind#eq kind#eq/.

- : formulak-respects-kind#eq kind#eq/.

- : vark#map-implies-gt M G
    <- vark#map-total* _ _ M' G'
    <- vark#map-deterministic M' M vark#eq/ EQ
    <- nat`gt-respects-eq G' nat`eq/ EQ G.

- : objectk-respects-vark#eq vark#eq/.

- : fractionk-respects-vark#eq vark#eq/.

- : termk-respects-vark#eq kind#eq/ vark#eq/.

- : predtype/0-respects-predtype#eq predtype#eq/.

- : predtype/+-respects-predtype#eq vark#eq/ predtype#eq/ predtype#eq/.


%worlds () (whole-respects-rat#eq _ _) (frac-respects-rat#eq _ _ _) (kind#map-implies-gt _ _) (permissionk-respects-kind#eq _) (upermk-respects-kind#eq _) (formulak-respects-kind#eq _) (vark#map-implies-gt _ _) (objectk-respects-vark#eq _) (fractionk-respects-vark#eq _) (termk-respects-vark#eq _ _) (predtype/0-respects-predtype#eq _) (predtype/+-respects-predtype#eq _ _ _).
%total { } (whole-respects-rat#eq _ _) (frac-respects-rat#eq _ _ _) (kind#map-implies-gt _ _) (permissionk-respects-kind#eq _) (upermk-respects-kind#eq _) (formulak-respects-kind#eq _) (vark#map-implies-gt _ _) (objectk-respects-vark#eq _) (fractionk-respects-vark#eq _) (termk-respects-vark#eq _ _) (predtype/0-respects-predtype#eq _) (predtype/+-respects-predtype#eq _ _ _).



%%%   Theorem about 'one2one' for mapping without variables


%theorem rat#map-one2one:
	forall*
		{T1:rat}
		{T2:rat}
		{N1:nat}
		{N2:nat}
	forall
		{M1:rat#map T1 N1}
		{M2:rat#map T2 N2}
		{EN:nat`eq N1 N2}
	exists
		{ET:rat#eq T1 T2}
	true.

%theorem kind#map-one2one:
	forall*
		{T1:kind}
		{T2:kind}
		{N1:nat}
		{N2:nat}
	forall
		{M1:kind#map T1 N1}
		{M2:kind#map T2 N2}
		{EN:nat`eq N1 N2}
	exists
		{ET:kind#eq T1 T2}
	true.

%theorem vark#map-one2one:
	forall*
		{T1:vark}
		{T2:vark}
		{N1:nat}
		{N2:nat}
	forall
		{M1:vark#map T1 N1}
		{M2:vark#map T2 N2}
		{EN:nat`eq N1 N2}
	exists
		{ET:vark#eq T1 T2}
	true.

%theorem predtype#map-one2one:
	forall*
		{T1:predtype}
		{T2:predtype}
		{N1:nat}
		{N2:nat}
	forall
		{M1:predtype#map T1 N1}
		{M2:predtype#map T2 N2}
		{EN:nat`eq N1 N2}
	exists
		{ET:predtype#eq T1 T2}
	true.



%% Cases

- : rat#map-one2one (rat#map/whole nat`eq/ nat`eq/ (times/s times/z plus/z) 0+N=N nat`eq/ T5 P5 0+N=N P7) (rat#map/whole nat`eq/ nat`eq/ (times/s times/z plus/z) 0+N=N nat`eq/ T'5 P'5 0+N=N P'7) nat`eq/ E
    <- plus-right-cancels P7 P'7 nat`eq/ nat`eq/ EPN
    <- nat`times-commutative T5 TC5
    <- nat`times-commutative T'5 TC'5
    <- nat`plus-commutative P5 PC5
    <- nat`plus-commutative P'5 PC'5
    <- divrem-can-be-constructed TC5 PC5 2>0 D5
    <- divrem-can-be-constructed TC'5 PC'5 2>0 D'5
    <- divrem-deterministic D5 D'5 EPN nat`eq/ EA0 _
    <- whole-respects-rat#eq EA0 E.

- : rat#map-one2one (rat#map/whole _ _ _ _ C T P1 P2 P3) (rat#map/frac _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 2>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 2>1 DR'
    <- nat-eq-nop C C' nat`eq/ ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 1>0) F
    <- false-implies-rat#eq F E.

- : rat#map-one2one (rat#map/frac _ _ _ _ _ _ C T P1 P2 P3) (rat#map/whole _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 2>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 2>0 DR'
    <- nat-eq-nop C C' nat`eq/ ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 1>0) F
    <- false-implies-rat#eq F E.

- : rat#map-one2one (rat#map/frac nat`eq/ nat`eq/ (times/s times/z plus/z) 0+N=N M4 D5 nat`eq/ T7 P7 0+N=N P9) (rat#map/frac nat`eq/ nat`eq/ (times/s times/z plus/z) 0+N=N M'4 D'5 nat`eq/ T'7 P'7 0+N=N P'9) nat`eq/ E
    <- plus-right-cancels P9 P'9 nat`eq/ nat`eq/ EPN
    <- nat`times-commutative T7 TC7
    <- nat`times-commutative T'7 TC'7
    <- nat`plus-commutative P7 PC7
    <- nat`plus-commutative P'7 PC'7
    <- divrem-can-be-constructed TC7 PC7 2>1 D7
    <- divrem-can-be-constructed TC'7 PC'7 2>1 D'7
    <- divrem-deterministic D7 D'7 EPN nat`eq/ EN2 _
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 EA0 ENA1
    <- rat#map-one2one M4 M'4 ENA1 EN4-1
    <- frac-respects-rat#eq EA0 EN4-1 E.

- : kind#map-one2one (kind#map/permissionk nat`eq/ nat`eq/ nat`eq/ 0+N=N 0+N=N) (kind#map/permissionk nat`eq/ nat`eq/ nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- permissionk-respects-kind#eq E.

- : kind#map-one2one (kind#map/permissionk nat`eq/ nat`eq/ nat`eq/ 0+0=0 P) (kind#map/upermk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+N=N) nat`eq/ E
    <- nat`plus-deterministic 0+N=N P nat`eq/ nat`eq/ EQ
    <- nat`eq-ne-implies-false EQ (nat`ne/< 1>0) F
    <- false-implies-kind#eq F E.

- : kind#map-one2one (kind#map/permissionk nat`eq/ nat`eq/ nat`eq/ 0+0=0 P) (kind#map/formulak nat`eq/ nat`eq/ nat`eq/ 2+0=2 0+N=N) nat`eq/ E
    <- nat`plus-deterministic 0+N=N P nat`eq/ nat`eq/ EQ
    <- nat`eq-ne-implies-false EQ (nat`ne/< 2>0) F
    <- false-implies-kind#eq F E.

- : kind#map-one2one (kind#map/upermk nat`eq/ nat`eq/ nat`eq/ 1+0=1 P) (kind#map/permissionk nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+N=N) nat`eq/ E
    <- nat`plus-deterministic 0+N=N P nat`eq/ nat`eq/ EQ
    <- nat`eq-ne-implies-false EQ (nat`ne/> 1>0) F
    <- false-implies-kind#eq F E.

- : kind#map-one2one (kind#map/upermk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+N=N) (kind#map/upermk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+N=N) nat`eq/ E
    <- upermk-respects-kind#eq E.

- : kind#map-one2one (kind#map/upermk nat`eq/ nat`eq/ nat`eq/ 1+0=1 P) (kind#map/formulak nat`eq/ nat`eq/ nat`eq/ 2+0=2 0+N=N) nat`eq/ E
    <- nat`plus-deterministic 0+N=N P nat`eq/ nat`eq/ EQ
    <- nat`eq-ne-implies-false EQ (nat`ne/< 2>1) F
    <- false-implies-kind#eq F E.

- : kind#map-one2one (kind#map/formulak nat`eq/ nat`eq/ nat`eq/ 2+0=2 P) (kind#map/permissionk nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+N=N) nat`eq/ E
    <- nat`plus-deterministic 0+N=N P nat`eq/ nat`eq/ EQ
    <- nat`eq-ne-implies-false EQ (nat`ne/> 2>0) F
    <- false-implies-kind#eq F E.

- : kind#map-one2one (kind#map/formulak nat`eq/ nat`eq/ nat`eq/ 2+0=2 P) (kind#map/upermk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+N=N) nat`eq/ E
    <- nat`plus-deterministic 0+N=N P nat`eq/ nat`eq/ EQ
    <- nat`eq-ne-implies-false EQ (nat`ne/> 2>1) F
    <- false-implies-kind#eq F E.

- : kind#map-one2one (kind#map/formulak nat`eq/ nat`eq/ nat`eq/ 2+0=2 0+N=N) (kind#map/formulak nat`eq/ nat`eq/ nat`eq/ 2+0=2 0+N=N) nat`eq/ E
    <- formulak-respects-kind#eq E.

- : vark#map-one2one (vark#map/objectk nat`eq/ nat`eq/ nat`eq/ 0+N=N 0+N=N) (vark#map/objectk nat`eq/ nat`eq/ nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- objectk-respects-vark#eq E.

- : vark#map-one2one (vark#map/objectk nat`eq/ nat`eq/ nat`eq/ 0+0=0 P) (vark#map/fractionk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+N=N) nat`eq/ E
    <- nat`plus-deterministic 0+N=N P nat`eq/ nat`eq/ EQ
    <- nat`eq-ne-implies-false EQ (nat`ne/< 1>0) F
    <- false-implies-vark#eq F E.

- : vark#map-one2one (vark#map/objectk nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+N=N) (vark#map/termk nat`eq/ M'1 T'2 P'3 nat`eq/ nat`eq/ 2+0=2 P'7) nat`eq/ E
    <- kind#map-implies-gt M'1 GT'1
    <- succ-gt-implies-ge GT'1 GE'NA0
    <- times-left-preserves-ge* GE'NA0 1*2=2 T'2 GE'NT0
    <- plus-left-preserves-ge* GE'NT0 0+2=2 P'3 GE'N1
    <- plus-implies-ge P'7 GE'7
    <- ge-implies-succ-gt GE'N1 GT'N1
    <- plus-right-preserves-gt* GT'N1 3+N=sssN P'7 GT'7
    <- nat`gt-transitive-ge ssN>N GE'7 G
    <- nat`gt-anti-reflexive G F
    <- false-implies-vark#eq F E.

- : vark#map-one2one (vark#map/fractionk nat`eq/ nat`eq/ nat`eq/ 1+0=1 P) (vark#map/objectk nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+N=N) nat`eq/ E
    <- nat`plus-deterministic 0+N=N P nat`eq/ nat`eq/ EQ
    <- nat`eq-ne-implies-false EQ (nat`ne/> 1>0) F
    <- false-implies-vark#eq F E.

- : vark#map-one2one (vark#map/fractionk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+N=N) (vark#map/fractionk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+N=N) nat`eq/ E
    <- fractionk-respects-vark#eq E.

- : vark#map-one2one (vark#map/fractionk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+N=N) (vark#map/termk nat`eq/ M'1 T'2 P'3 nat`eq/ nat`eq/ 2+0=2 P'7) nat`eq/ E
    <- kind#map-implies-gt M'1 GT'1
    <- succ-gt-implies-ge GT'1 GE'NA0
    <- times-left-preserves-ge* GE'NA0 1*2=2 T'2 GE'NT0
    <- plus-left-preserves-ge* GE'NT0 0+2=2 P'3 GE'N1
    <- plus-implies-ge P'7 GE'7
    <- ge-implies-succ-gt GE'N1 GT'N1
    <- plus-right-preserves-gt* GT'N1 3+N=sssN P'7 GT'7
    <- nat`gt-transitive-ge sN>N GE'7 G
    <- nat`gt-anti-reflexive G F
    <- false-implies-vark#eq F E.

- : vark#map-one2one (vark#map/termk nat`eq/ M1 T2 P3 nat`eq/ nat`eq/ 2+0=2 P7) (vark#map/objectk nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+N=N) nat`eq/ E
    <- kind#map-implies-gt M1 GT1
    <- succ-gt-implies-ge GT1 GENA0
    <- times-left-preserves-ge* GENA0 1*2=2 T2 GENT0
    <- plus-left-preserves-ge* GENT0 0+2=2 P3 GEN1
    <- plus-implies-ge P7 GE7
    <- ge-implies-succ-gt GEN1 GTN1
    <- plus-right-preserves-gt* GTN1 3+N=sssN P7 GT7
    <- nat`gt-transitive-ge ssN>N GE7 G
    <- nat`gt-anti-reflexive G F
    <- false-implies-vark#eq F E.

- : vark#map-one2one (vark#map/termk nat`eq/ M1 T2 P3 nat`eq/ nat`eq/ 2+0=2 P7) (vark#map/fractionk nat`eq/ nat`eq/ nat`eq/ 1+0=1 0+N=N) nat`eq/ E
    <- kind#map-implies-gt M1 GT1
    <- succ-gt-implies-ge GT1 GENA0
    <- times-left-preserves-ge* GENA0 1*2=2 T2 GENT0
    <- plus-left-preserves-ge* GENT0 0+2=2 P3 GEN1
    <- plus-implies-ge P7 GE7
    <- ge-implies-succ-gt GEN1 GTN1
    <- plus-right-preserves-gt* GTN1 3+N=sssN P7 GT7
    <- nat`gt-transitive-ge sN>N GE7 G
    <- nat`gt-anti-reflexive G F
    <- false-implies-vark#eq F E.

- : vark#map-one2one (vark#map/termk nat`eq/ M1 (times/s times/z plus/z) 0+N=N nat`eq/ nat`eq/ 2+0=2 P7) (vark#map/termk nat`eq/ M'1 (times/s times/z plus/z) 0+N=N nat`eq/ nat`eq/ 2+0=2 P'7) nat`eq/ E
    <- kind#map-implies-gt M1 GNA0
    <- kind#map-implies-gt M'1 G'NA0
    <- plus-right-cancels P7 P'7 nat`eq/ nat`eq/ ENA0
    <- kind#map-one2one M1 M'1 ENA0 EN1-1
    <- termk-respects-vark#eq EN1-1 E.

- : predtype#map-one2one (predtype#map/predtype/0 nat`eq/ nat`eq/ nat`eq/ 0+N=N 0+N=N) (predtype#map/predtype/0 nat`eq/ nat`eq/ nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- predtype/0-respects-predtype#eq E.

- : predtype#map-one2one (predtype#map/predtype/0 nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+N=N) (predtype#map/predtype/+ _ _ _ _ _ _ _ C' T' P1' 1+N=sN P3') nat`eq/ E
    <- nat`plus-implies-ge P3' GE'
    <- nat`gt-transitive-ge sN>N GE' G
    <- nat`gt-anti-reflexive G F
    <- false-implies-predtype#eq F E.

- : predtype#map-one2one (predtype#map/predtype/+ _ _ _ _ _ _ _ C T P1 1+N=sN P3) (predtype#map/predtype/0 nat`eq/ nat`eq/ nat`eq/ 0+0=0 0+N=N) nat`eq/ E
    <- nat`plus-implies-ge P3 GE
    <- nat`gt-transitive-ge sN>N GE G
    <- nat`gt-anti-reflexive G F
    <- false-implies-predtype#eq F E.

- : predtype#map-one2one (predtype#map/predtype/+ nat`eq/ M1 (times/s times/z plus/z) 0+N=N M4 T5 P5 nat`eq/ (times/s times/z plus/z) 0+N=N 1+0=1 P10) (predtype#map/predtype/+ nat`eq/ M'1 (times/s times/z plus/z) 0+N=N M'4 T'5 P'5 nat`eq/ (times/s times/z plus/z) 0+N=N 1+0=1 P'10) nat`eq/ E
    <- vark#map-implies-gt M1 GNA0
    <- vark#map-implies-gt M'1 G'NA0
    <- plus-right-cancels P10 P'10 nat`eq/ nat`eq/ EN2
    <- nat`times-commutative T5 TC5
    <- nat`times-commutative T'5 TC'5
    <- nat`plus-commutative P5 PC5
    <- nat`plus-commutative P'5 PC'5
    <- divrem-can-be-constructed TC5 PC5 GNA0 D5
    <- divrem-can-be-constructed TC'5 PC'5 G'NA0 D'5
    <- divrem-deterministic D5 D'5 EN2 nat`eq/ ENA1 ENA0
    <- vark#map-one2one M1 M'1 ENA0 EN1-1
    <- predtype#map-one2one M4 M'4 ENA1 EN4-1
    <- predtype/+-respects-predtype#eq EN1-1 EN4-1 E.


%worlds () (rat#map-one2one M1 _ _ _) (kind#map-one2one M1 _ _ _) (vark#map-one2one M1 _ _ _) (predtype#map-one2one M1 _ _ _).
%total (M1#1444 M1#1445 M1#1446 M1#1448 ) (rat#map-one2one M1#1444 _ _ _) (kind#map-one2one M1#1445 _ _ _) (vark#map-one2one M1#1446 _ _ _) (predtype#map-one2one M1#1448 _ _ _).



%%%   Theorems about inequality and equality testing


%theorem rat#eq?-total*:
	forall
		{X1:rat}
		{X2:rat}
	exists
		{B:bool}
		{EQ?:rat#eq? X1 X2 B}
	true.

%theorem rat#eq-ne-implies-false:
	forall*
		{X1:rat}
		{X2:rat}
	forall
		{EQ:rat#eq X1 X2}
		{NE:rat#ne X1 X2}
	exists
		{F:void}
	true.

%theorem kind#eq?-total*:
	forall
		{X1:kind}
		{X2:kind}
	exists
		{B:bool}
		{EQ?:kind#eq? X1 X2 B}
	true.

%theorem kind#eq-ne-implies-false:
	forall*
		{X1:kind}
		{X2:kind}
	forall
		{EQ:kind#eq X1 X2}
		{NE:kind#ne X1 X2}
	exists
		{F:void}
	true.

%theorem vark#eq?-total*:
	forall
		{X1:vark}
		{X2:vark}
	exists
		{B:bool}
		{EQ?:vark#eq? X1 X2 B}
	true.

%theorem vark#eq-ne-implies-false:
	forall*
		{X1:vark}
		{X2:vark}
	forall
		{EQ:vark#eq X1 X2}
		{NE:vark#ne X1 X2}
	exists
		{F:void}
	true.

%theorem predtype#eq?-total*:
	forall
		{X1:predtype}
		{X2:predtype}
	exists
		{B:bool}
		{EQ?:predtype#eq? X1 X2 B}
	true.

%theorem predtype#eq-ne-implies-false:
	forall*
		{X1:predtype}
		{X2:predtype}
	forall
		{EQ:predtype#eq X1 X2}
		{NE:predtype#ne X1 X2}
	exists
		{F:void}
	true.

%abbrev rat#eq?-total : rat#eq? X1 X2 B -> type = rat#eq?-total* _ _ _ .

%abbrev kind#eq?-total : kind#eq? X1 X2 B -> type = kind#eq?-total* _ _ _ .

%abbrev vark#eq?-total : vark#eq? X1 X2 B -> type = vark#eq?-total* _ _ _ .

%abbrev predtype#eq?-total : predtype#eq? X1 X2 B -> type = predtype#eq?-total* _ _ _ .



%% Cases


%theorem rat#eq?-total/L1 :
	forall*	{X1} {X2} {N1} {N2} {B}
	forall	{M1: rat#map X1 N1}
		{M2: rat#map X2 N2}
		{EQ?: nat`eq? N1 N2 B}
	exists	{EQ?: rat#eq? X1 X2 B}
	true.

%theorem rat#eq?-total/L2 :
	forall*	{X1} {X2}
	forall  {EQ: rat#eq X1 X2}
	exists	{EQ?: rat#eq? X1 X2 true}
	true.

- : rat#eq?-total/L2 rat#eq/ rat#eq?/yes.

%worlds () (rat#eq?-total/L2 _ _).
%total { } (rat#eq?-total/L2 _ _).

- : rat#eq?-total/L1 M1 M2 nat`eq?/yes EQ?
    <- rat#map-one2one  M1 M2 nat`eq/ EQ
    <- rat#eq?-total/L2 EQ EQ?.

- : rat#eq?-total/L1 M1 M2 (nat`eq?/no NE) (rat#eq?/no (rat#ne/ M1 M2 NE)).

%worlds () (rat#eq?-total/L1 _ _ _ _).
%total { } (rat#eq?-total/L1 _ _ _ _).

- : rat#eq?-total EQ?
    <- rat#map-total M1
    <- rat#map-total M2
    <- nat`eq?-total NEQ?
    <- rat#eq?-total/L1 M1 M2 NEQ? EQ?.



- : rat#eq-ne-implies-false rat#eq/ (rat#ne/ M1 M2 NE) F
    <- rat#map-deterministic M1 M2 rat#eq/ EQ
    <- nat`eq-ne-implies-false EQ NE F.



%theorem kind#eq?-total/L1 :
	forall*	{X1} {X2} {N1} {N2} {B}
	forall	{M1: kind#map X1 N1}
		{M2: kind#map X2 N2}
		{EQ?: nat`eq? N1 N2 B}
	exists	{EQ?: kind#eq? X1 X2 B}
	true.

%theorem kind#eq?-total/L2 :
	forall*	{X1} {X2}
	forall  {EQ: kind#eq X1 X2}
	exists	{EQ?: kind#eq? X1 X2 true}
	true.

- : kind#eq?-total/L2 kind#eq/ kind#eq?/yes.

%worlds () (kind#eq?-total/L2 _ _).
%total { } (kind#eq?-total/L2 _ _).

- : kind#eq?-total/L1 M1 M2 nat`eq?/yes EQ?
    <- kind#map-one2one  M1 M2 nat`eq/ EQ
    <- kind#eq?-total/L2 EQ EQ?.

- : kind#eq?-total/L1 M1 M2 (nat`eq?/no NE) (kind#eq?/no (kind#ne/ M1 M2 NE)).

%worlds () (kind#eq?-total/L1 _ _ _ _).
%total { } (kind#eq?-total/L1 _ _ _ _).

- : kind#eq?-total EQ?
    <- kind#map-total M1
    <- kind#map-total M2
    <- nat`eq?-total NEQ?
    <- kind#eq?-total/L1 M1 M2 NEQ? EQ?.



- : kind#eq-ne-implies-false kind#eq/ (kind#ne/ M1 M2 NE) F
    <- kind#map-deterministic M1 M2 kind#eq/ EQ
    <- nat`eq-ne-implies-false EQ NE F.



%theorem vark#eq?-total/L1 :
	forall*	{X1} {X2} {N1} {N2} {B}
	forall	{M1: vark#map X1 N1}
		{M2: vark#map X2 N2}
		{EQ?: nat`eq? N1 N2 B}
	exists	{EQ?: vark#eq? X1 X2 B}
	true.

%theorem vark#eq?-total/L2 :
	forall*	{X1} {X2}
	forall  {EQ: vark#eq X1 X2}
	exists	{EQ?: vark#eq? X1 X2 true}
	true.

- : vark#eq?-total/L2 vark#eq/ vark#eq?/yes.

%worlds () (vark#eq?-total/L2 _ _).
%total { } (vark#eq?-total/L2 _ _).

- : vark#eq?-total/L1 M1 M2 nat`eq?/yes EQ?
    <- vark#map-one2one  M1 M2 nat`eq/ EQ
    <- vark#eq?-total/L2 EQ EQ?.

- : vark#eq?-total/L1 M1 M2 (nat`eq?/no NE) (vark#eq?/no (vark#ne/ M1 M2 NE)).

%worlds () (vark#eq?-total/L1 _ _ _ _).
%total { } (vark#eq?-total/L1 _ _ _ _).

- : vark#eq?-total EQ?
    <- vark#map-total M1
    <- vark#map-total M2
    <- nat`eq?-total NEQ?
    <- vark#eq?-total/L1 M1 M2 NEQ? EQ?.



- : vark#eq-ne-implies-false vark#eq/ (vark#ne/ M1 M2 NE) F
    <- vark#map-deterministic M1 M2 vark#eq/ EQ
    <- nat`eq-ne-implies-false EQ NE F.



%theorem predtype#eq?-total/L1 :
	forall*	{X1} {X2} {N1} {N2} {B}
	forall	{M1: predtype#map X1 N1}
		{M2: predtype#map X2 N2}
		{EQ?: nat`eq? N1 N2 B}
	exists	{EQ?: predtype#eq? X1 X2 B}
	true.

%theorem predtype#eq?-total/L2 :
	forall*	{X1} {X2}
	forall  {EQ: predtype#eq X1 X2}
	exists	{EQ?: predtype#eq? X1 X2 true}
	true.

- : predtype#eq?-total/L2 predtype#eq/ predtype#eq?/yes.

%worlds () (predtype#eq?-total/L2 _ _).
%total { } (predtype#eq?-total/L2 _ _).

- : predtype#eq?-total/L1 M1 M2 nat`eq?/yes EQ?
    <- predtype#map-one2one  M1 M2 nat`eq/ EQ
    <- predtype#eq?-total/L2 EQ EQ?.

- : predtype#eq?-total/L1 M1 M2 (nat`eq?/no NE) (predtype#eq?/no (predtype#ne/ M1 M2 NE)).

%worlds () (predtype#eq?-total/L1 _ _ _ _).
%total { } (predtype#eq?-total/L1 _ _ _ _).

- : predtype#eq?-total EQ?
    <- predtype#map-total M1
    <- predtype#map-total M2
    <- nat`eq?-total NEQ?
    <- predtype#eq?-total/L1 M1 M2 NEQ? EQ?.



- : predtype#eq-ne-implies-false predtype#eq/ (predtype#ne/ M1 M2 NE) F
    <- predtype#map-deterministic M1 M2 predtype#eq/ EQ
    <- nat`eq-ne-implies-false EQ NE F.



%worlds () (rat#eq?-total* _ _ _ _) (rat#eq-ne-implies-false _ _ _) (kind#eq?-total* _ _ _ _) (kind#eq-ne-implies-false _ _ _) (vark#eq?-total* _ _ _ _) (vark#eq-ne-implies-false _ _ _) (predtype#eq?-total* _ _ _ _) (predtype#eq-ne-implies-false _ _ _).
%total { } (rat#eq?-total* _ _ _ _) (rat#eq-ne-implies-false _ _ _) (kind#eq?-total* _ _ _ _) (kind#eq-ne-implies-false _ _ _) (vark#eq?-total* _ _ _ _) (vark#eq-ne-implies-false _ _ _) (predtype#eq?-total* _ _ _ _) (predtype#eq-ne-implies-false _ _ _).




%%%% Definitions (with variables)



%%% Definition for variables and level and non-levels


predicate#var : predicate K -> type .

predicate#level : predicate K -> nat -> type .

predicate#nolevel : predicate K -> type .

gterm#var : gterm K -> type .

gterm#level : gterm K -> nat -> type .

gterm#nolevel : gterm K -> type .

%block block#predicate#var : some {k:predtype} block {x:predicate k} {v:predicate#var x}.

%block block#predicate#level : some {k:predtype} {l:nat} block {x:predicate k} {v:predicate#var x} {vl:predicate#level x l}.

%block block#predicate#nolevel : some {k:predtype} block {x:predicate k} {v:predicate#var x} {nl:predicate#nolevel x}.

%block block#gterm#var : some {k:vark} block {x:gterm k} {v:gterm#var x}.

%block block#gterm#level : some {k:vark} {l:nat} block {x:gterm k} {v:gterm#var x} {vl:gterm#level x l}.

%block block#gterm#nolevel : some {k:vark} block {x:gterm k} {v:gterm#var x} {nl:gterm#nolevel x}.



%% Cases

 
% fake dependency to avoid autofreezing bug
fake : type.
- : (predicate#var X -> predicate#var X') -> fake.


 
% fake dependency to avoid autofreezing bug
fake : type.
- : (gterm#var X -> gterm#var X') -> fake.








%%% Definition for variable lists


predicate#list : type .

gterm#list : type .



%% Cases

predicate#list/0 : predicate#list .

predicate#list/+ : {k:predtype} ({x:predicate k} ({v:predicate#var x} (predicate#list -> predicate#list))) .

gterm#list/0 : gterm#list .

gterm#list/+ : {k:vark} ({x:gterm k} ({v:gterm#var x} (gterm#list -> gterm#list))) .







%%% Definition for variable list operations


predicate#split : predicate#list -> predicate K -> predicate#list -> predicate#list -> type .

predicate#count : predtype -> predicate#list -> nat -> type .

gterm#split : gterm#list -> gterm K -> gterm#list -> gterm#list -> type .

gterm#count : vark -> gterm#list -> nat -> type .



%% Cases

predicate#split/here : predicate#split (predicate#list/+ _ X _ L) X predicate#list/0 L .

predicate#split/there : predicate#split L X L1 L2 -> predicate#split (predicate#list/+ _ _ V L) X (predicate#list/+ _ _ V L1) L2 .

predicate#count/0 : predicate#count _ predicate#list/0 z .

predicate#count/= : predicate#count K L N -> predicate#count K (predicate#list/+ K _ _ L) (s N) .

predicate#count/!= : predicate#count K L N -> predtype#ne K' K -> predicate#count K (predicate#list/+ K' _ _ L) N .

gterm#split/here : gterm#split (gterm#list/+ _ X _ L) X gterm#list/0 L .

gterm#split/there : gterm#split L X L1 L2 -> gterm#split (gterm#list/+ _ _ V L) X (gterm#list/+ _ _ V L1) L2 .

gterm#count/0 : gterm#count _ gterm#list/0 z .

gterm#count/= : gterm#count K L N -> gterm#count K (gterm#list/+ K _ _ L) (s N) .

gterm#count/!= : gterm#count K L N -> vark#ne K' K -> gterm#count K (gterm#list/+ K' _ _ L) N .







%%% Definition of mapping with variables


gterm#map : {K:vark} ({Hgterm:gterm#list} ({Hpredicate:predicate#list} (gterm K -> nat -> type))) .

predicate#map : {K:predtype} ({Hgterm:gterm#list} ({Hpredicate:predicate#list} (predicate K -> nat -> type))) .

predargs#map : {K:predtype} ({Hgterm:gterm#list} ({Hpredicate:predicate#list} (predargs K -> nat -> type))) .



%% Cases

gterm#map/#level : gterm#level X N -> gterm#map K Hgterm Hpredicate X N .

gterm#map/#nolevel : gterm#nolevel X -> gterm#split Hgterm X _ L -> gterm#count K L N -> gterm#map K Hgterm Hpredicate X N .

predicate#map/#level : predicate#level X N -> predicate#map K Hgterm Hpredicate X N .

predicate#map/#nolevel : predicate#nolevel X -> predicate#split Hpredicate X _ L -> predicate#count K L N -> predicate#map K Hgterm Hpredicate X N .

gterm#map/object/ : nat`eq 0 N0 -> nat`eq A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#count objectk Hgterm NV -> times 1 N1 TN -> plus 0 TN PN -> plus 0 NV NA -> plus PN NA N -> gterm#map objectk Hgterm Hpredicate (object/ A0) N .

gterm#map/fraction/ : nat`eq 0 N0 -> rat#map A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#count fractionk Hgterm NV -> times 1 N1 TN -> plus 0 TN PN -> plus 0 NV NA -> plus PN NA N -> gterm#map fractionk Hgterm Hpredicate (fraction/ A0) N .

gterm#map/empty : nat`eq 0 N0 -> gterm#count (termk permissionk) Hgterm NV -> nat`eq N0 PN -> plus 0 NV NA -> plus PN NA N -> gterm#map (termk permissionk) Hgterm Hpredicate empty N .

gterm#map/scale : nat`eq 0 N0 -> gterm#map fractionk Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#map (termk permissionk) Hgterm Hpredicate A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> gterm#count (termk permissionk) Hgterm NV -> times 3 N2 TN -> plus 0 TN PN -> plus 1 NV NA -> plus PN NA N -> gterm#map (termk permissionk) Hgterm Hpredicate (scale A0 A1) N .

gterm#map/combine : nat`eq 0 N0 -> gterm#map (termk permissionk) Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#map (termk permissionk) Hgterm Hpredicate A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> gterm#count (termk permissionk) Hgterm NV -> times 3 N2 TN -> plus 1 TN PN -> plus 1 NV NA -> plus PN NA N -> gterm#map (termk permissionk) Hgterm Hpredicate (combine A0 A1) N .

gterm#map/unitperm : nat`eq 0 N0 -> gterm#map (termk upermk) Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#count (termk permissionk) Hgterm NV -> times 3 N1 TN -> plus 2 TN PN -> plus 1 NV NA -> plus PN NA N -> gterm#map (termk permissionk) Hgterm Hpredicate (unitperm A0) N .

gterm#map/nonlinear : nat`eq 0 N0 -> gterm#map (termk formulak) Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#count (termk upermk) Hgterm NV -> times 5 N1 TN -> plus 0 TN PN -> plus 0 NV NA -> plus PN NA N -> gterm#map (termk upermk) Hgterm Hpredicate (nonlinear A0) N .

gterm#map/conditional : nat`eq 0 N0 -> gterm#map (termk formulak) Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#map (termk permissionk) Hgterm Hpredicate A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> gterm#map (termk permissionk) Hgterm Hpredicate A2 NA2 -> natpair`pair2nat (natpair/ N2 NA2) N3 -> gterm#count (termk upermk) Hgterm NV -> times 5 N3 TN -> plus 1 TN PN -> plus 0 NV NA -> plus PN NA N -> gterm#map (termk upermk) Hgterm Hpredicate (conditional A0 A1 A2) N .

gterm#map/encumbered : nat`eq 0 N0 -> gterm#map (termk permissionk) Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#map (termk permissionk) Hgterm Hpredicate A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> gterm#count (termk upermk) Hgterm NV -> times 5 N2 TN -> plus 2 TN PN -> plus 0 NV NA -> plus PN NA N -> gterm#map (termk upermk) Hgterm Hpredicate (encumbered A0 A1) N .

gterm#map/precise-exists : nat`eq 0 N0 -> gterm#map objectk Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> nat`eq A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> ({x0:gterm objectk} ({v0:gterm#var x0} (gterm#nolevel x0 -> gterm#map (termk permissionk) (gterm#list/+ objectk x0 v0 Hgterm) Hpredicate (A2 x0) NA2))) -> natpair`pair2nat (natpair/ N2 NA2) N3 -> gterm#count (termk upermk) Hgterm NV -> times 5 N3 TN -> plus 3 TN PN -> plus 0 NV NA -> plus PN NA N -> gterm#map (termk upermk) Hgterm Hpredicate (precise-exists A0 A1 A2) N .

gterm#map/basic : nat`eq 0 N0 -> gterm#map objectk Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> nat`eq A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> gterm#map objectk Hgterm Hpredicate A2 NA2 -> natpair`pair2nat (natpair/ N2 NA2) N3 -> gterm#count (termk upermk) Hgterm NV -> times 5 N3 TN -> plus 4 TN PN -> plus 0 NV NA -> plus PN NA N -> gterm#map (termk upermk) Hgterm Hpredicate (basic A0 A1 A2) N .

gterm#map/t : nat`eq 0 N0 -> gterm#count (termk formulak) Hgterm NV -> nat`eq N0 PN -> plus 0 NV NA -> plus PN NA N -> gterm#map (termk formulak) Hgterm Hpredicate t N .

gterm#map/neg : nat`eq 0 N0 -> gterm#map (termk formulak) Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#count (termk formulak) Hgterm NV -> times 6 N1 TN -> plus 0 TN PN -> plus 1 NV NA -> plus PN NA N -> gterm#map (termk formulak) Hgterm Hpredicate (neg A0) N .

gterm#map/conj : nat`eq 0 N0 -> gterm#map (termk formulak) Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#map (termk formulak) Hgterm Hpredicate A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> gterm#count (termk formulak) Hgterm NV -> times 6 N2 TN -> plus 1 TN PN -> plus 1 NV NA -> plus PN NA N -> gterm#map (termk formulak) Hgterm Hpredicate (conj A0 A1) N .

gterm#map/objequal : nat`eq 0 N0 -> gterm#map objectk Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#map objectk Hgterm Hpredicate A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> gterm#count (termk formulak) Hgterm NV -> times 6 N2 TN -> plus 2 TN PN -> plus 1 NV NA -> plus PN NA N -> gterm#map (termk formulak) Hgterm Hpredicate (objequal A0 A1) N .

gterm#map/exists* : nat`eq 0 N0 -> vark#map A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> ({x0:gterm A0} ({v0:gterm#var x0} (gterm#nolevel x0 -> gterm#map (termk formulak) (gterm#list/+ A0 x0 v0 Hgterm) Hpredicate (A1 x0) NA1))) -> times 5 NA1 NT1 -> plus N1 NT1 N2 -> gterm#count (termk formulak) Hgterm NV -> times 6 N2 TN -> plus 3 TN PN -> plus 1 NV NA -> plus PN NA N -> gterm#map (termk formulak) Hgterm Hpredicate (exists* A0 A1) N .

gterm#map/nested : nat`eq 0 N0 -> gterm#map (termk permissionk) Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> gterm#map objectk Hgterm Hpredicate A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> nat`eq A2 NA2 -> natpair`pair2nat (natpair/ N2 NA2) N3 -> gterm#count (termk formulak) Hgterm NV -> times 6 N3 TN -> plus 4 TN PN -> plus 1 NV NA -> plus PN NA N -> gterm#map (termk formulak) Hgterm Hpredicate (nested A0 A1 A2) N .

gterm#map/predcall* : nat`eq 0 N0 -> predtype#map A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> predicate#map A0 Hgterm Hpredicate A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> predargs#map A0 Hgterm Hpredicate A2 NA2 -> natpair`pair2nat (natpair/ N2 NA2) N3 -> gterm#count (termk formulak) Hgterm NV -> times 6 N3 TN -> plus 5 TN PN -> plus 1 NV NA -> plus PN NA N -> gterm#map (termk formulak) Hgterm Hpredicate (predcall* A0 A1 A2) N .

predicate#map/predicate/0 : nat`eq 0 N0 -> gterm#map (termk formulak) Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> predicate#count predtype/0 Hpredicate NV -> times 2 N1 TN -> plus 0 TN PN -> plus 0 NV NA -> plus PN NA N -> predicate#map predtype/0 Hgterm Hpredicate (predicate/0 A0) N .

predicate#map/predicate/Y : nat`eq 0 N0 -> ({x0:predicate predtype/0} ({v0:predicate#var x0} (predicate#nolevel x0 -> predicate#map predtype/0 Hgterm (predicate#list/+ predtype/0 x0 v0 Hpredicate) (A0 x0) NA0))) -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> predicate#count predtype/0 Hpredicate NV -> times 2 N1 TN -> plus 1 TN PN -> plus 0 NV NA -> plus PN NA N -> predicate#map predtype/0 Hgterm Hpredicate (predicate/Y A0) N .

predicate#map/predicate/+ : nat`eq 0 N0 -> ({x0:gterm K#695} ({v0:gterm#var x0} (gterm#nolevel x0 -> predicate#map N#695 (gterm#list/+ K#695 x0 v0 Hgterm) Hpredicate (A0 x0) NA0))) -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> predicate#count (predtype/+ K#695 N#695) Hpredicate NV -> times 2 N1 TN -> plus 0 TN PN -> plus 0 NV NA -> plus PN NA N -> predicate#map (predtype/+ K#695 N#695) Hgterm Hpredicate (predicate/+ A0) N .

predicate#map/predicate/Y1 : nat`eq 0 N0 -> ({x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)} ({v0:predicate#var x0} (predicate#nolevel x0 -> predicate#map (predtype/+ Vpredtype/+ Wpredtype/+) Hgterm (predicate#list/+ (predtype/+ Vpredtype/+ Wpredtype/+) x0 v0 Hpredicate) (A0 x0) NA0))) -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> predicate#count (predtype/+ Vpredtype/+ Wpredtype/+) Hpredicate NV -> times 2 N1 TN -> plus 1 TN PN -> plus 0 NV NA -> plus PN NA N -> predicate#map (predtype/+ Vpredtype/+ Wpredtype/+) Hgterm Hpredicate (predicate/Y A0) N .

predargs#map/predargs/0* : nat`eq 0 N0 -> nat`eq A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> nat`eq 0 NV -> times 1 N1 TN -> plus 0 TN PN -> plus 0 NV NA -> plus PN NA N -> predargs#map predtype/0 Hgterm Hpredicate (predargs/0* A0) N .

predargs#map/predargs/+ : nat`eq 0 N0 -> gterm#map K#810 Hgterm Hpredicate A0 NA0 -> times 1 NA0 NT0 -> plus N0 NT0 N1 -> predargs#map N#810 Hgterm Hpredicate A1 NA1 -> natpair`pair2nat (natpair/ N1 NA1) N2 -> nat`eq 0 NV -> times 1 N2 TN -> plus 0 TN PN -> plus 0 NV NA -> plus PN NA N -> predargs#map (predtype/+ K#810 N#810) Hgterm Hpredicate (predargs/+ A0 A1) N .







%%% Definitions for inequality and equality testing with variables


gterm#eq : gterm K1 -> gterm K2 -> type .

gterm#ne : gterm K -> gterm K -> type .

gterm#eq? : gterm K -> gterm K -> bool -> type .

predicate#eq : predicate K1 -> predicate K2 -> type .

predicate#ne : predicate K -> predicate K -> type .

predicate#eq? : predicate K -> predicate K -> bool -> type .

predargs#eq : predargs K1 -> predargs K2 -> type .

predargs#ne : predargs K -> predargs K -> type .

predargs#eq? : predargs K -> predargs K -> bool -> type .



%% Cases

gterm#eq/ : gterm#eq X X .

gterm#ne/ : gterm#map _ gterm#list/0 predicate#list/0 X1 N1 -> gterm#map _ gterm#list/0 predicate#list/0 X2 N2 -> nat`ne N1 N2 -> gterm#ne X1 X2 .

gterm#eq?/yes : gterm#eq? X X true .

gterm#eq?/no : gterm#ne X1 X2 -> gterm#eq? X1 X2 false .

predicate#eq/ : predicate#eq X X .

predicate#ne/ : predicate#map _ gterm#list/0 predicate#list/0 X1 N1 -> predicate#map _ gterm#list/0 predicate#list/0 X2 N2 -> nat`ne N1 N2 -> predicate#ne X1 X2 .

predicate#eq?/yes : predicate#eq? X X true .

predicate#eq?/no : predicate#ne X1 X2 -> predicate#eq? X1 X2 false .

predargs#eq/ : predargs#eq X X .

predargs#ne/ : predargs#map _ gterm#list/0 predicate#list/0 X1 N1 -> predargs#map _ gterm#list/0 predicate#list/0 X2 N2 -> nat`ne N1 N2 -> predargs#ne X1 X2 .

predargs#eq?/yes : predargs#eq? X X true .

predargs#eq?/no : predargs#ne X1 X2 -> predargs#eq? X1 X2 false .








%%%% Theorems (with variables)



%%% Theorems about XXX#eq


%theorem false-implies-gterm#eq:
	forall*
		{K:vark}
		{K':vark}
		{X:gterm K}
		{X':gterm K'}
	forall
		{F:void}
	exists
		{E:gterm#eq X X'}
	true.

%theorem false-implies-predicate#eq:
	forall*
		{K:predtype}
		{K':predtype}
		{X:predicate K}
		{X':predicate K'}
	forall
		{F:void}
	exists
		{E:predicate#eq X X'}
	true.


%worlds (block#gterm#var | block#predicate#var) (false-implies-gterm#eq F _) (false-implies-predicate#eq F _).
%total (F#863 F#871 ) (false-implies-gterm#eq F#863 _) (false-implies-predicate#eq F#871 _).



%%% Theorems about XXX#count and split


%theorem false-implies-predicate#count:
	forall*
		{k:predtype}
		{L:predicate#list}
		{M:nat}
	forall
		{F:void}
	exists
		{C:predicate#count k L M}
	true.

%theorem predicate#count-deterministic:
	forall*
		{k:predtype}
		{L:predicate#list}
		{M:nat}
		{M':nat}
	forall
		{C:predicate#count k L M}
		{C':predicate#count k L M'}
	exists
		{EQ:nat`eq M M'}
	true.

%theorem predicate#count-total*:
	forall
		{k:predtype}
		{L:predicate#list}
	exists
		{M:nat}
		{C:predicate#count k L M}
	true.

%theorem predicate#count-total/L:
	forall*
		{K:predtype}
		{K':predtype}
		{X:predicate K}
		{V:predicate#var X}
		{M:nat}
		{B:bool}
	forall
		{L:predicate#list}
		{C:predicate#count K' L M}
		{EQ?:predtype#eq? K K' B}
	exists
		{M':nat}
		{C':predicate#count K' (predicate#list/+ K X V L) M'}
	true.

%theorem predicate#split-contradiction:
	forall*
		{k:predtype}
		{L:predicate#list}
		{FL1:{x:predicate k} ({v:predicate#var x} predicate#list)}
		{FL2:{x:predicate k} ({v:predicate#var x} predicate#list)}
	forall
		{FS:{x:predicate k} ({v:predicate#var x} (predicate#split L x (FL1 x v) (FL2 x v)))}
	exists
		{F:void}
	true.

%theorem predicate#split-decreases-count:
	forall*
		{k:predtype}
		{L:predicate#list}
		{X:predicate k}
		{L1:predicate#list}
		{L2:predicate#list}
		{M:nat}
		{M':nat}
	forall
		{C1:predicate#count k L M}
		{S:predicate#split L X L1 L2}
		{C1:predicate#count k L2 M'}
	exists
		{G:gt M M'}
	true.

%theorem predicate#lookup-onto:
	forall*
		{k:predtype}
		{L:predicate#list}
		{M:nat}
		{N:nat}
	forall
		{C:predicate#count k L M}
		{G:gt M N}
	exists
		{X:predicate k}
		{V:predicate#var X}
		{L1:predicate#list}
		{L2:predicate#list}
		{S:predicate#split L X L1 L2}
		{C:predicate#count k L2 N}
	true.

%theorem false-implies-gterm#count:
	forall*
		{k:vark}
		{L:gterm#list}
		{M:nat}
	forall
		{F:void}
	exists
		{C:gterm#count k L M}
	true.

%theorem gterm#count-deterministic:
	forall*
		{k:vark}
		{L:gterm#list}
		{M:nat}
		{M':nat}
	forall
		{C:gterm#count k L M}
		{C':gterm#count k L M'}
	exists
		{EQ:nat`eq M M'}
	true.

%theorem gterm#count-total*:
	forall
		{k:vark}
		{L:gterm#list}
	exists
		{M:nat}
		{C:gterm#count k L M}
	true.

%theorem gterm#count-total/L:
	forall*
		{K:vark}
		{K':vark}
		{X:gterm K}
		{V:gterm#var X}
		{M:nat}
		{B:bool}
	forall
		{L:gterm#list}
		{C:gterm#count K' L M}
		{EQ?:vark#eq? K K' B}
	exists
		{M':nat}
		{C':gterm#count K' (gterm#list/+ K X V L) M'}
	true.

%theorem gterm#split-contradiction:
	forall*
		{k:vark}
		{L:gterm#list}
		{FL1:{x:gterm k} ({v:gterm#var x} gterm#list)}
		{FL2:{x:gterm k} ({v:gterm#var x} gterm#list)}
	forall
		{FS:{x:gterm k} ({v:gterm#var x} (gterm#split L x (FL1 x v) (FL2 x v)))}
	exists
		{F:void}
	true.

%theorem gterm#split-decreases-count:
	forall*
		{k:vark}
		{L:gterm#list}
		{X:gterm k}
		{L1:gterm#list}
		{L2:gterm#list}
		{M:nat}
		{M':nat}
	forall
		{C1:gterm#count k L M}
		{S:gterm#split L X L1 L2}
		{C1:gterm#count k L2 M'}
	exists
		{G:gt M M'}
	true.

%theorem gterm#lookup-onto:
	forall*
		{k:vark}
		{L:gterm#list}
		{M:nat}
		{N:nat}
	forall
		{C:gterm#count k L M}
		{G:gt M N}
	exists
		{X:gterm k}
		{V:gterm#var X}
		{L1:gterm#list}
		{L2:gterm#list}
		{S:gterm#split L X L1 L2}
		{C:gterm#count k L2 N}
	true.

%abbrev predicate#count-total : predicate#count K L M -> type = predicate#count-total* K _ _ .

%abbrev gterm#count-total : gterm#count K L M -> type = gterm#count-total* K _ _ .



%% Cases

- : predicate#count-deterministic predicate#count/0 predicate#count/0 nat`eq/.

- : predicate#count-total predicate#count/0.

- : predicate#split-contradiction ([x:predicate K] ([v:predicate#var x] (predicate#split/there (FS x v)))) F
    <- predicate#split-contradiction FS F.

- : gterm#count-deterministic gterm#count/0 gterm#count/0 nat`eq/.

- : gterm#count-total gterm#count/0.

- : gterm#split-contradiction ([x:gterm K] ([v:gterm#var x] (gterm#split/there (FS x v)))) F
    <- gterm#split-contradiction FS F.


- : predicate#count-deterministic (predicate#count/= C) (predicate#count/= C') SN=SN'
    <- predicate#count-deterministic C C' N=N'
    <- succ-deterministic N=N' SN=SN'.

- : predicate#count-deterministic (predicate#count/= _) (predicate#count/!= _ NE) EQ
    <- predtype#eq-ne-implies-false predtype#eq/ NE F
    <- nat`false-implies-eq F EQ.

- : predicate#count-deterministic (predicate#count/!= _ NE) (predicate#count/= _) EQ
    <- predtype#eq-ne-implies-false predtype#eq/ NE F
    <- nat`false-implies-eq F EQ.

- : predicate#count-deterministic (predicate#count/!= C _) (predicate#count/!= C' _) EQ
    <- predicate#count-deterministic C C' EQ.



- : predicate#count-total/L _ C (predtype#eq?/yes) (s M) (predicate#count/= C).

- : predicate#count-total/L _ C (predtype#eq?/no NE) M (predicate#count/!= C NE).

- : predicate#count-total C'
    <- predtype#eq?-total EQ?
    <- predicate#count-total C
    <- predicate#count-total/L _ C EQ? _ C'.



- : predicate#split-decreases-count (predicate#count/= C1) (predicate#split/here) C2 G
    <- predicate#count-deterministic C1 C2 EQ
    <- nat`gt-respects-eq gt/1 nat`eq/ EQ G.

- : predicate#split-decreases-count (predicate#count/= C1) (predicate#split/there L) C2 (gt/> G)
    <- predicate#split-decreases-count C1 L C2 G.

- : predicate#split-decreases-count (predicate#count/!= C1 NE) (predicate#split/here) _ G
    <- predtype#eq-ne-implies-false predtype#eq/ NE F
    <- nat`false-implies-gt F G.

- : predicate#split-decreases-count (predicate#count/!= C1 _) (predicate#split/there L) C2 G
    <- predicate#split-decreases-count C1 L C2 G.



- : predicate#lookup-onto (predicate#count/= C) (gt/1) _ I _ _
    (predicate#split/here: predicate#split (predicate#list/+ _ _ I _) _ _ _) C.

- : predicate#lookup-onto (predicate#count/= C1) (gt/> G) _ I _ _ (predicate#split/there S) C2
    <- predicate#lookup-onto C1 G _ I _ _ S C2.

- : predicate#lookup-onto (predicate#count/!= C1 _) G _ I _ _ (predicate#split/there S) C2
    <- predicate#lookup-onto C1 G _ I _ _ S C2.



- : gterm#count-deterministic (gterm#count/= C) (gterm#count/= C') SN=SN'
    <- gterm#count-deterministic C C' N=N'
    <- succ-deterministic N=N' SN=SN'.

- : gterm#count-deterministic (gterm#count/= _) (gterm#count/!= _ NE) EQ
    <- vark#eq-ne-implies-false vark#eq/ NE F
    <- nat`false-implies-eq F EQ.

- : gterm#count-deterministic (gterm#count/!= _ NE) (gterm#count/= _) EQ
    <- vark#eq-ne-implies-false vark#eq/ NE F
    <- nat`false-implies-eq F EQ.

- : gterm#count-deterministic (gterm#count/!= C _) (gterm#count/!= C' _) EQ
    <- gterm#count-deterministic C C' EQ.



- : gterm#count-total/L _ C (vark#eq?/yes) (s M) (gterm#count/= C).

- : gterm#count-total/L _ C (vark#eq?/no NE) M (gterm#count/!= C NE).

- : gterm#count-total C'
    <- vark#eq?-total EQ?
    <- gterm#count-total C
    <- gterm#count-total/L _ C EQ? _ C'.



- : gterm#split-decreases-count (gterm#count/= C1) (gterm#split/here) C2 G
    <- gterm#count-deterministic C1 C2 EQ
    <- nat`gt-respects-eq gt/1 nat`eq/ EQ G.

- : gterm#split-decreases-count (gterm#count/= C1) (gterm#split/there L) C2 (gt/> G)
    <- gterm#split-decreases-count C1 L C2 G.

- : gterm#split-decreases-count (gterm#count/!= C1 NE) (gterm#split/here) _ G
    <- vark#eq-ne-implies-false vark#eq/ NE F
    <- nat`false-implies-gt F G.

- : gterm#split-decreases-count (gterm#count/!= C1 _) (gterm#split/there L) C2 G
    <- gterm#split-decreases-count C1 L C2 G.



- : gterm#lookup-onto (gterm#count/= C) (gt/1) _ I _ _
    (gterm#split/here: gterm#split (gterm#list/+ _ _ I _) _ _ _) C.

- : gterm#lookup-onto (gterm#count/= C1) (gt/> G) _ I _ _ (gterm#split/there S) C2
    <- gterm#lookup-onto C1 G _ I _ _ S C2.

- : gterm#lookup-onto (gterm#count/!= C1 _) G _ I _ _ (gterm#split/there S) C2
    <- gterm#lookup-onto C1 G _ I _ _ S C2.



%worlds (block#predicate#var | block#gterm#var) (false-implies-predicate#count F _) (predicate#count-deterministic C _ _) (predicate#count-total/L Z _ _ _ _) (predicate#count-total* _ L _ _) (predicate#split-contradiction FS _) (predicate#split-decreases-count C _ _ _) (predicate#lookup-onto C _ _ _ _ _ _ _) (false-implies-gterm#count F _) (gterm#count-deterministic C _ _) (gterm#count-total/L Z _ _ _ _) (gterm#count-total* _ L _ _) (gterm#split-contradiction FS _) (gterm#split-decreases-count C _ _ _) (gterm#lookup-onto C _ _ _ _ _ _ _).
%total (F#383 C#384 Z#385 L#386 FS#387 C#388 C#389 F#392 C#393 Z#394 L#395 FS#396 C#397 C#398 ) (false-implies-predicate#count F#383 _) (predicate#count-deterministic C#384 _ _) (predicate#count-total/L Z#385 _ _ _ _) (predicate#count-total* _ L#386 _ _) (predicate#split-contradiction FS#387 _) (predicate#split-decreases-count C#388 _ _ _) (predicate#lookup-onto C#389 _ _ _ _ _ _ _) (false-implies-gterm#count F#392 _) (gterm#count-deterministic C#393 _ _) (gterm#count-total/L Z#394 _ _ _ _) (gterm#count-total* _ L#395 _ _) (gterm#split-contradiction FS#396 _) (gterm#split-decreases-count C#397 _ _ _) (gterm#lookup-onto C#398 _ _ _ _ _ _ _).



%%% Theorem that lookup is deterministic and one-to-one


%theorem predicate#lookup-deterministic:
	forall*
		{K:predtype}
		{FL:{x:predicate K} ({v:predicate#var x} predicate#list)}
		{FL1':{x:predicate K} ({v:predicate#var x} predicate#list)}
		{FL2':{x:predicate K} ({v:predicate#var x} predicate#list)}
		{M:nat}
		{L1:predicate#list}
		{L2:predicate#list}
		{N':nat}
	forall
		{FS:{x:predicate K} ({v:predicate#var x} (predicate#split (FL x v) x L1 L2))}
		{C:predicate#count K L2 M}
		{FS':{x:predicate K} ({v:predicate#var x} (predicate#split (FL x v) x (FL1' x v) (FL2' x v)))}
		{FC':{x:predicate K} ({v:predicate#var x} (predicate#count K (FL2' x v) N'))}
	exists
		{E:nat`eq M N'}
	true.

%theorem predicate#lookup-one2one:
	forall*
		{k:predtype}
		{X1:predicate k}
		{X2:predicate k}
		{L:predicate#list}
		{L1:predicate#list}
		{L2:predicate#list}
		{L1':predicate#list}
		{L2':predicate#list}
		{M:nat}
		{N':nat}
	forall
		{S:predicate#split L X1 L1 L2}
		{C:predicate#count k L2 M}
		{S:predicate#split L X2 L1' L2'}
		{C:predicate#count k L2' N'}
		{E:nat`eq M N'}
	exists
		{E:predicate#eq X1 X2}
	true.

%theorem gterm#lookup-deterministic:
	forall*
		{K:vark}
		{FL:{x:gterm K} ({v:gterm#var x} gterm#list)}
		{FL1':{x:gterm K} ({v:gterm#var x} gterm#list)}
		{FL2':{x:gterm K} ({v:gterm#var x} gterm#list)}
		{M:nat}
		{L1:gterm#list}
		{L2:gterm#list}
		{N':nat}
	forall
		{FS:{x:gterm K} ({v:gterm#var x} (gterm#split (FL x v) x L1 L2))}
		{C:gterm#count K L2 M}
		{FS':{x:gterm K} ({v:gterm#var x} (gterm#split (FL x v) x (FL1' x v) (FL2' x v)))}
		{FC':{x:gterm K} ({v:gterm#var x} (gterm#count K (FL2' x v) N'))}
	exists
		{E:nat`eq M N'}
	true.

%theorem gterm#lookup-one2one:
	forall*
		{k:vark}
		{X1:gterm k}
		{X2:gterm k}
		{L:gterm#list}
		{L1:gterm#list}
		{L2:gterm#list}
		{L1':gterm#list}
		{L2':gterm#list}
		{M:nat}
		{N':nat}
	forall
		{S:gterm#split L X1 L1 L2}
		{C:gterm#count k L2 M}
		{S:gterm#split L X2 L1' L2'}
		{C:gterm#count k L2' N'}
		{E:nat`eq M N'}
	exists
		{E:gterm#eq X1 X2}
	true.



%% Cases


- : predicate#lookup-deterministic ([x] [v] predicate#split/here) C ([x] [v] predicate#split/here) FC' E
    <- ({x} {v} predicate#count-deterministic C (FC' x v) E).

- : predicate#lookup-deterministic ([x] [v] predicate#split/here) _ ([x] [v] predicate#split/there (FS' x v)) _ E
    <- predicate#split-contradiction FS' F
    <- nat`false-implies-eq F E.

- : predicate#lookup-deterministic 
	([x] [v] predicate#split/there (FS x v)) C
	([x] [v] predicate#split/there (FS' x v)) FC' E
    <- predicate#lookup-deterministic FS C FS' FC' E.



- : predicate#lookup-one2one predicate#split/here C1 predicate#split/here C2 nat`eq/ predicate#eq/.

- : predicate#lookup-one2one (predicate#split/there S1) C1 (predicate#split/there S2) C2 nat`eq/ EQ
    <- predicate#lookup-one2one S1 C1 S2 C2 nat`eq/ EQ.

- : predicate#lookup-one2one predicate#split/here C1 (predicate#split/there S2) C2 nat`eq/ EQ
    <- predicate#split-decreases-count C1 S2 C2 G
    <- nat`gt-anti-reflexive G F
    <- false-implies-predicate#eq F EQ.

- : predicate#lookup-one2one (predicate#split/there S1) C1 predicate#split/here C2 nat`eq/ EQ
    <- predicate#split-decreases-count C2 S1 C1 G
    <- nat`gt-anti-reflexive G F
    <- false-implies-predicate#eq F EQ.



- : gterm#lookup-deterministic ([x] [v] gterm#split/here) C ([x] [v] gterm#split/here) FC' E
    <- ({x} {v} gterm#count-deterministic C (FC' x v) E).

- : gterm#lookup-deterministic ([x] [v] gterm#split/here) _ ([x] [v] gterm#split/there (FS' x v)) _ E
    <- gterm#split-contradiction FS' F
    <- nat`false-implies-eq F E.

- : gterm#lookup-deterministic 
	([x] [v] gterm#split/there (FS x v)) C
	([x] [v] gterm#split/there (FS' x v)) FC' E
    <- gterm#lookup-deterministic FS C FS' FC' E.



- : gterm#lookup-one2one gterm#split/here C1 gterm#split/here C2 nat`eq/ gterm#eq/.

- : gterm#lookup-one2one (gterm#split/there S1) C1 (gterm#split/there S2) C2 nat`eq/ EQ
    <- gterm#lookup-one2one S1 C1 S2 C2 nat`eq/ EQ.

- : gterm#lookup-one2one gterm#split/here C1 (gterm#split/there S2) C2 nat`eq/ EQ
    <- gterm#split-decreases-count C1 S2 C2 G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F EQ.

- : gterm#lookup-one2one (gterm#split/there S1) C1 gterm#split/here C2 nat`eq/ EQ
    <- gterm#split-decreases-count C2 S1 C1 G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F EQ.



%worlds (block#predicate#var | block#gterm#var) (predicate#lookup-deterministic FS _ _ _ _) (predicate#lookup-one2one S _ _ _ _ _) (gterm#lookup-deterministic FS _ _ _ _) (gterm#lookup-one2one S _ _ _ _ _).
%total (FS#390 S#391 FS#399 S#400 ) (predicate#lookup-deterministic FS#390 _ _ _ _) (predicate#lookup-one2one S#391 _ _ _ _ _) (gterm#lookup-deterministic FS#399 _ _ _ _) (gterm#lookup-one2one S#400 _ _ _ _ _).



%%%   Auxiliary theorems about mapping (with variables)


%theorem false-implies-gterm#:
	forall*
		{K:vark}
	forall
		{F:void}
	exists
		{X:gterm K}
	true.

%theorem false-implies-gterm#map:
	forall*
		{K:vark}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{X:gterm K}
		{N:nat}
	forall
		{F:void}
	exists
		{M:gterm#map K Hgterm Hpredicate X N}
	true.

%theorem gterm#map-respects-eq:
	forall*
		{K:vark}
		{K':vark}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{X:gterm K}
		{X':gterm K'}
		{N:nat}
		{N2:nat}
	forall
		{M1:gterm#map K Hgterm Hpredicate X N}
		{EQ:gterm#eq X X'}
		{EQ:nat`eq N N2}
	exists
		{M2:gterm#map K' Hgterm Hpredicate X' N2}
	true.

%theorem false-implies-predicate#:
	forall*
		{K:predtype}
	forall
		{F:void}
	exists
		{X:predicate K}
	true.

%theorem false-implies-predicate#map:
	forall*
		{K:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{X:predicate K}
		{N:nat}
	forall
		{F:void}
	exists
		{M:predicate#map K Hgterm Hpredicate X N}
	true.

%theorem predicate#map-respects-eq:
	forall*
		{K:predtype}
		{K':predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{X:predicate K}
		{X':predicate K'}
		{N:nat}
		{N2:nat}
	forall
		{M1:predicate#map K Hgterm Hpredicate X N}
		{EQ:predicate#eq X X'}
		{EQ:nat`eq N N2}
	exists
		{M2:predicate#map K' Hgterm Hpredicate X' N2}
	true.

%theorem false-implies-predargs#:
	forall*
		{K:predtype}
	forall
		{F:void}
	exists
		{X:predargs K}
	true.

%theorem false-implies-predargs#map:
	forall*
		{K:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{X:predargs K}
		{N:nat}
	forall
		{F:void}
	exists
		{M:predargs#map K Hgterm Hpredicate X N}
	true.

%theorem false-implies-predargs#eq:
	forall*
		{K:predtype}
		{K':predtype}
		{X:predargs K}
		{X':predargs K'}
	forall
		{F:void}
	exists
		{E:predargs#eq X X'}
	true.

%theorem predargs#map-respects-eq:
	forall*
		{K:predtype}
		{K':predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{X:predargs K}
		{X':predargs K'}
		{N:nat}
		{N2:nat}
	forall
		{M1:predargs#map K Hgterm Hpredicate X N}
		{EQ:predargs#eq X X'}
		{EQ:nat`eq N N2}
	exists
		{M2:predargs#map K' Hgterm Hpredicate X' N2}
	true.



%% Cases

- : gterm#map-respects-eq M gterm#eq/ nat`eq/ M.

- : predicate#map-respects-eq M predicate#eq/ nat`eq/ M.

- : predargs#map-respects-eq M predargs#eq/ nat`eq/ M.


%worlds (block#gterm#var | block#gterm#level | block#gterm#nolevel | block#predicate#var | block#predicate#level | block#predicate#nolevel) (false-implies-gterm# F _) (false-implies-gterm#map F _) (gterm#map-respects-eq M _ _ _) (false-implies-predicate# F _) (false-implies-predicate#map F _) (predicate#map-respects-eq M _ _ _) (false-implies-predargs# F _) (false-implies-predargs#map F _) (false-implies-predargs#eq F _) (predargs#map-respects-eq M _ _ _).
%total (F#861 F#862 M#864 F#869 F#870 M#872 F#873 F#874 F#875 M#876 ) (false-implies-gterm# F#861 _) (false-implies-gterm#map F#862 _) (gterm#map-respects-eq M#864 _ _ _) (false-implies-predicate# F#869 _) (false-implies-predicate#map F#870 _) (predicate#map-respects-eq M#872 _ _ _) (false-implies-predargs# F#873 _) (false-implies-predargs#map F#874 _) (false-implies-predargs#eq F#875 _) (predargs#map-respects-eq M#876 _ _ _).



%%% Theorems for switching from level to nolevel


%theorem gterm#map-remove-gterm-level:
	forall*
		{K:vark}
		{Kgterm:vark}
		{FH:{x:gterm Kgterm} ({v:gterm#var x} gterm#list)}
		{Hpredicate:predicate#list}
		{F:gterm Kgterm -> gterm K}
		{L:nat}
		{N:nat}
		{HI:gterm#list}
		{H':gterm#list}
	forall
		{FM:{x:gterm Kgterm} ({v:gterm#var x} (gterm#level x L -> gterm#map K (FH x v) Hpredicate (F x) N))}
		{FS:{x:gterm Kgterm} ({v:gterm#var x} (gterm#split (FH x v) x HI H'))}
		{C:gterm#count Kgterm H' L}
	exists
		{FM':{x:gterm Kgterm} ({v:gterm#var x} (gterm#nolevel x -> gterm#map K (FH x v) Hpredicate (F x) N))}
	true.

%theorem predicate#map-remove-gterm-level:
	forall*
		{K:predtype}
		{Kgterm:vark}
		{FH:{x:gterm Kgterm} ({v:gterm#var x} gterm#list)}
		{Hpredicate:predicate#list}
		{F:gterm Kgterm -> predicate K}
		{L:nat}
		{N:nat}
		{HI:gterm#list}
		{H':gterm#list}
	forall
		{FM:{x:gterm Kgterm} ({v:gterm#var x} (gterm#level x L -> predicate#map K (FH x v) Hpredicate (F x) N))}
		{FS:{x:gterm Kgterm} ({v:gterm#var x} (gterm#split (FH x v) x HI H'))}
		{C:gterm#count Kgterm H' L}
	exists
		{FM':{x:gterm Kgterm} ({v:gterm#var x} (gterm#nolevel x -> predicate#map K (FH x v) Hpredicate (F x) N))}
	true.

%theorem predargs#map-remove-gterm-level:
	forall*
		{K:predtype}
		{Kgterm:vark}
		{FH:{x:gterm Kgterm} ({v:gterm#var x} gterm#list)}
		{Hpredicate:predicate#list}
		{F:gterm Kgterm -> predargs K}
		{L:nat}
		{N:nat}
		{HI:gterm#list}
		{H':gterm#list}
	forall
		{FM:{x:gterm Kgterm} ({v:gterm#var x} (gterm#level x L -> predargs#map K (FH x v) Hpredicate (F x) N))}
		{FS:{x:gterm Kgterm} ({v:gterm#var x} (gterm#split (FH x v) x HI H'))}
		{C:gterm#count Kgterm H' L}
	exists
		{FM':{x:gterm Kgterm} ({v:gterm#var x} (gterm#nolevel x -> predargs#map K (FH x v) Hpredicate (F x) N))}
	true.

%theorem predicate#map-remove-predicate-level:
	forall*
		{K:predtype}
		{Kpredicate:predtype}
		{Hgterm:gterm#list}
		{FH:{x:predicate Kpredicate} ({v:predicate#var x} predicate#list)}
		{F:predicate Kpredicate -> predicate K}
		{L:nat}
		{N:nat}
		{HI:predicate#list}
		{H':predicate#list}
	forall
		{FM:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#level x L -> predicate#map K Hgterm (FH x v) (F x) N))}
		{FS:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#split (FH x v) x HI H'))}
		{C:predicate#count Kpredicate H' L}
	exists
		{FM':{x:predicate Kpredicate} ({v:predicate#var x} (predicate#nolevel x -> predicate#map K Hgterm (FH x v) (F x) N))}
	true.

%theorem gterm#map-remove-predicate-level:
	forall*
		{K:vark}
		{Kpredicate:predtype}
		{Hgterm:gterm#list}
		{FH:{x:predicate Kpredicate} ({v:predicate#var x} predicate#list)}
		{F:predicate Kpredicate -> gterm K}
		{L:nat}
		{N:nat}
		{HI:predicate#list}
		{H':predicate#list}
	forall
		{FM:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#level x L -> gterm#map K Hgterm (FH x v) (F x) N))}
		{FS:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#split (FH x v) x HI H'))}
		{C:predicate#count Kpredicate H' L}
	exists
		{FM':{x:predicate Kpredicate} ({v:predicate#var x} (predicate#nolevel x -> gterm#map K Hgterm (FH x v) (F x) N))}
	true.

%theorem predargs#map-remove-predicate-level:
	forall*
		{K:predtype}
		{Kpredicate:predtype}
		{Hgterm:gterm#list}
		{FH:{x:predicate Kpredicate} ({v:predicate#var x} predicate#list)}
		{F:predicate Kpredicate -> predargs K}
		{L:nat}
		{N:nat}
		{HI:predicate#list}
		{H':predicate#list}
	forall
		{FM:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#level x L -> predargs#map K Hgterm (FH x v) (F x) N))}
		{FS:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#split (FH x v) x HI H'))}
		{C:predicate#count Kpredicate H' L}
	exists
		{FM':{x:predicate Kpredicate} ({v:predicate#var x} (predicate#nolevel x -> predargs#map K Hgterm (FH x v) (F x) N))}
	true.



%% Cases

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/object/ D0 D1 D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/object/ D0 D1 D2 D3 (FC4 x v) D5 D6 D7 D8)))).

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/fraction/ D0 FF1 D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/fraction/ D0 FF1 D2 D3 (FC4 x v) D5 D6 D7 D8)))).

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/empty D0 (FC1 x v) D2 D3 D4)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/empty D0 (FC1 x v) D2 D3 D4)))).

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/scale D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x v) D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/scale D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x v) D7 D8 D9 D10))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1
    <- gterm#map-remove-gterm-level FF4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'4.

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/combine D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x v) D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/combine D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x v) D7 D8 D9 D10))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1
    <- gterm#map-remove-gterm-level FF4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'4.

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/unitperm D0 (FF1 x v l) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/unitperm D0 (FF'1 x v nl) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1.

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/nonlinear D0 (FF1 x v l) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/nonlinear D0 (FF'1 x v nl) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1.

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/conditional D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FF6 x v l) D7 (FC8 x v) D9 D10 D11 D12)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/conditional D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FF'6 x v nl) D7 (FC8 x v) D9 D10 D11 D12))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1
    <- gterm#map-remove-gterm-level FF4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'4
    <- gterm#map-remove-gterm-level FF6 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'6.

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/encumbered D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x v) D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/encumbered D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x v) D7 D8 D9 D10))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1
    <- gterm#map-remove-gterm-level FF4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'4.

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/precise-exists D0 (FF1 x v l) D2 D3 D4 D5 ([x0:gterm objectk] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF6 x0 v0 nl0 x v l)))) D7 (FC8 x v) D9 D10 D11 D12)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/precise-exists D0 (FF'1 x v nl) D2 D3 D4 D5 ([x0:gterm objectk] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'6 x0 v0 nl0 x v nl)))) D7 (FC8 x v) D9 D10 D11 D12))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1
    <- ({x0:gterm objectk} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (gterm#map-remove-gterm-level (FF6 x0 v0 nl0) ([x:gterm Kgterm] ([v:gterm#var x] (gterm#split/there (FS x v)))) C (FF'6 x0 v0 nl0))))).

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/basic D0 (FF1 x v l) D2 D3 D4 D5 (FF6 x v l) D7 (FC8 x v) D9 D10 D11 D12)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/basic D0 (FF'1 x v nl) D2 D3 D4 D5 (FF'6 x v nl) D7 (FC8 x v) D9 D10 D11 D12))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1
    <- gterm#map-remove-gterm-level FF6 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'6.

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/t D0 (FC1 x v) D2 D3 D4)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/t D0 (FC1 x v) D2 D3 D4)))).

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/neg D0 (FF1 x v l) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/neg D0 (FF'1 x v nl) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1.

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/conj D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x v) D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/conj D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x v) D7 D8 D9 D10))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1
    <- gterm#map-remove-gterm-level FF4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'4.

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/objequal D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x v) D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/objequal D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x v) D7 D8 D9 D10))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1
    <- gterm#map-remove-gterm-level FF4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'4.

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/exists* D0 FF1 D2 D3 ([x0:gterm A0] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF4 x0 v0 nl0 x v l)))) D5 D6 (FC7 x v) D8 D9 D10 D11)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/exists* D0 FF1 D2 D3 ([x0:gterm A0] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'4 x0 v0 nl0 x v nl)))) D5 D6 (FC7 x v) D8 D9 D10 D11))))
    <- ({x0:gterm A0} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (gterm#map-remove-gterm-level (FF4 x0 v0 nl0) ([x:gterm Kgterm] ([v:gterm#var x] (gterm#split/there (FS x v)))) C (FF'4 x0 v0 nl0))))).

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/nested D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 D6 D7 (FC8 x v) D9 D10 D11 D12)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/nested D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 D6 D7 (FC8 x v) D9 D10 D11 D12))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1
    <- gterm#map-remove-gterm-level FF4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'4.

- : predicate#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predicate#map/predicate/0 D0 (FF1 x v l) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predicate#map/predicate/0 D0 (FF'1 x v nl) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1.

- : predicate#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predicate#map/predicate/Y D0 ([x0:predicate predtype/0] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predicate#map/predicate/Y D0 ([x0:predicate predtype/0] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- ({x0:predicate predtype/0} ({v0:predicate#var x0} ({nl0:predicate#nolevel x0} (predicate#map-remove-gterm-level (FF1 x0 v0 nl0) ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C (FF'1 x0 v0 nl0))))).

- : predicate#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predicate#map/predicate/+ D0 ([x0:gterm K#695] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predicate#map/predicate/+ D0 ([x0:gterm K#695] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- ({x0:gterm K#695} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (predicate#map-remove-gterm-level (FF1 x0 v0 nl0) ([x:gterm Kgterm] ([v:gterm#var x] (gterm#split/there (FS x v)))) C (FF'1 x0 v0 nl0))))).

- : predicate#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predicate#map/predicate/Y1 D0 ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predicate#map/predicate/Y1 D0 ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- ({x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)} ({v0:predicate#var x0} ({nl0:predicate#nolevel x0} (predicate#map-remove-gterm-level (FF1 x0 v0 nl0) ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C (FF'1 x0 v0 nl0))))).

- : predargs#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predargs#map/predargs/0* D0 D1 D2 D3 D4 D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predargs#map/predargs/0* D0 D1 D2 D3 D4 D5 D6 D7 D8)))).

- : predargs#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predargs#map/predargs/+ D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 D6 D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predargs#map/predargs/+ D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 D6 D7 D8 D9 D10))))
    <- gterm#map-remove-gterm-level FF1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'1
    <- predargs#map-remove-gterm-level FF4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'4.

- : gterm#map-remove-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/predcall* D0 FF1 D2 D3 (FF4 x v l) D5 (FF6 x v l) D7 (FC8 x v) D9 D10 D11 D12)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/predcall* D0 FF1 D2 D3 (FF'4 x v nl) D5 (FF'6 x v nl) D7 (FC8 x v) D9 D10 D11 D12))))
    <- predicate#map-remove-gterm-level FF4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'4
    <- predargs#map-remove-gterm-level FF6 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF'6.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/object/ D0 D1 D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/object/ D0 D1 D2 D3 (FC4 x) D5 D6 D7 D8)))).

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/fraction/ D0 FF1 D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/fraction/ D0 FF1 D2 D3 (FC4 x) D5 D6 D7 D8)))).

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/empty D0 (FC1 x) D2 D3 D4)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/empty D0 (FC1 x) D2 D3 D4)))).

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/scale D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x) D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/scale D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x) D7 D8 D9 D10))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1
    <- gterm#map-remove-predicate-level FF4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'4.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/combine D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x) D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/combine D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x) D7 D8 D9 D10))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1
    <- gterm#map-remove-predicate-level FF4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'4.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/unitperm D0 (FF1 x v l) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/unitperm D0 (FF'1 x v nl) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/nonlinear D0 (FF1 x v l) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/nonlinear D0 (FF'1 x v nl) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/conditional D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FF6 x v l) D7 (FC8 x) D9 D10 D11 D12)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/conditional D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FF'6 x v nl) D7 (FC8 x) D9 D10 D11 D12))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1
    <- gterm#map-remove-predicate-level FF4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'4
    <- gterm#map-remove-predicate-level FF6 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'6.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/encumbered D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x) D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/encumbered D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x) D7 D8 D9 D10))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1
    <- gterm#map-remove-predicate-level FF4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'4.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/precise-exists D0 (FF1 x v l) D2 D3 D4 D5 ([x0:gterm objectk] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF6 x0 v0 nl0 x v l)))) D7 (FC8 x) D9 D10 D11 D12)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/precise-exists D0 (FF'1 x v nl) D2 D3 D4 D5 ([x0:gterm objectk] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'6 x0 v0 nl0 x v nl)))) D7 (FC8 x) D9 D10 D11 D12))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1
    <- ({x0:gterm objectk} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (gterm#map-remove-predicate-level (FF6 x0 v0 nl0) ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C (FF'6 x0 v0 nl0))))).

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/basic D0 (FF1 x v l) D2 D3 D4 D5 (FF6 x v l) D7 (FC8 x) D9 D10 D11 D12)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/basic D0 (FF'1 x v nl) D2 D3 D4 D5 (FF'6 x v nl) D7 (FC8 x) D9 D10 D11 D12))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1
    <- gterm#map-remove-predicate-level FF6 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'6.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/t D0 (FC1 x) D2 D3 D4)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/t D0 (FC1 x) D2 D3 D4)))).

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/neg D0 (FF1 x v l) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/neg D0 (FF'1 x v nl) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/conj D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x) D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/conj D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x) D7 D8 D9 D10))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1
    <- gterm#map-remove-predicate-level FF4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'4.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/objequal D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x) D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/objequal D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x) D7 D8 D9 D10))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1
    <- gterm#map-remove-predicate-level FF4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'4.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/exists* D0 FF1 D2 D3 ([x0:gterm A0] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF4 x0 v0 nl0 x v l)))) D5 D6 (FC7 x) D8 D9 D10 D11)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/exists* D0 FF1 D2 D3 ([x0:gterm A0] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'4 x0 v0 nl0 x v nl)))) D5 D6 (FC7 x) D8 D9 D10 D11))))
    <- ({x0:gterm A0} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (gterm#map-remove-predicate-level (FF4 x0 v0 nl0) ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C (FF'4 x0 v0 nl0))))).

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/nested D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 D6 D7 (FC8 x) D9 D10 D11 D12)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/nested D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 D6 D7 (FC8 x) D9 D10 D11 D12))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1
    <- gterm#map-remove-predicate-level FF4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'4.

- : predargs#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predargs#map/predargs/0* D0 D1 D2 D3 D4 D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predargs#map/predargs/0* D0 D1 D2 D3 D4 D5 D6 D7 D8)))).

- : predargs#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predargs#map/predargs/+ D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 D6 D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predargs#map/predargs/+ D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 D6 D7 D8 D9 D10))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1
    <- predargs#map-remove-predicate-level FF4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'4.

- : gterm#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/predcall* D0 FF1 D2 D3 (FF4 x v l) D5 (FF6 x v l) D7 (FC8 x) D9 D10 D11 D12)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/predcall* D0 FF1 D2 D3 (FF'4 x v nl) D5 (FF'6 x v nl) D7 (FC8 x) D9 D10 D11 D12))))
    <- predicate#map-remove-predicate-level FF4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'4
    <- predargs#map-remove-predicate-level FF6 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'6.

- : predicate#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predicate#map/predicate/0 D0 (FF1 x v l) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predicate#map/predicate/0 D0 (FF'1 x v nl) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- gterm#map-remove-predicate-level FF1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF'1.

- : predicate#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predicate#map/predicate/Y D0 ([x0:predicate predtype/0] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predicate#map/predicate/Y D0 ([x0:predicate predtype/0] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- ({x0:predicate predtype/0} ({v0:predicate#var x0} ({nl0:predicate#nolevel x0} (predicate#map-remove-predicate-level (FF1 x0 v0 nl0) ([x:predicate Kpredicate] ([v:predicate#var x] (predicate#split/there (FS x v)))) C (FF'1 x0 v0 nl0))))).

- : predicate#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predicate#map/predicate/+ D0 ([x0:gterm K#695] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predicate#map/predicate/+ D0 ([x0:gterm K#695] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- ({x0:gterm K#695} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (predicate#map-remove-predicate-level (FF1 x0 v0 nl0) ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C (FF'1 x0 v0 nl0))))).

- : predicate#map-remove-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predicate#map/predicate/Y1 D0 ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predicate#map/predicate/Y1 D0 ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- ({x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)} ({v0:predicate#var x0} ({nl0:predicate#nolevel x0} (predicate#map-remove-predicate-level (FF1 x0 v0 nl0) ([x:predicate Kpredicate] ([v:predicate#var x] (predicate#split/there (FS x v)))) C (FF'1 x0 v0 nl0))))).


- : gterm#map-remove-gterm-level ([x] [v] [l] gterm#map/#level VL) _ _
                           ([x] [v] [nl] gterm#map/#level VL).



- : gterm#map-remove-gterm-level ([x] [v] [l] gterm#map/#level l) FS C
                           ([x] [v] [nl] gterm#map/#nolevel nl (FS x v) C).



- : gterm#map-remove-gterm-level ([x] [v] [l] gterm#map/#nolevel NL (FS x v) (FC x v)) _ _
                           ([x] [v] [nl] gterm#map/#nolevel NL (FS x v) (FC x v)).



- : predicate#map-remove-gterm-level ([x] [v] [l] predicate#map/#level VL) _ _
                           ([x] [v] [nl] predicate#map/#level VL).



- : predicate#map-remove-gterm-level ([x] [v] [l] predicate#map/#nolevel NL (FS x) (FC x)) _ _
                           ([x] [v] [nl] predicate#map/#nolevel NL (FS x) (FC x)).



- : predicate#map-remove-predicate-level ([x] [v] [l] predicate#map/#level VL) _ _
                           ([x] [v] [nl] predicate#map/#level VL).



- : predicate#map-remove-predicate-level ([x] [v] [l] predicate#map/#level l) FS C
                           ([x] [v] [nl] predicate#map/#nolevel nl (FS x v) C).



- : predicate#map-remove-predicate-level ([x] [v] [l] predicate#map/#nolevel NL (FS x v) (FC x v)) _ _
                           ([x] [v] [nl] predicate#map/#nolevel NL (FS x v) (FC x v)).



- : gterm#map-remove-predicate-level ([x] [v] [l] gterm#map/#level VL) _ _
                           ([x] [v] [nl] gterm#map/#level VL).



- : gterm#map-remove-predicate-level ([x] [v] [l] gterm#map/#nolevel NL (FS x) (FC x)) _ _
                           ([x] [v] [nl] gterm#map/#nolevel NL (FS x) (FC x)).



%worlds (block#gterm#var | block#gterm#level | block#gterm#nolevel | block#predicate#var | block#predicate#level | block#predicate#nolevel) (predicate#map-remove-gterm-level F _ _ _) (predargs#map-remove-gterm-level F _ _ _) (gterm#map-remove-gterm-level F _ _ _) (predargs#map-remove-predicate-level F _ _ _) (gterm#map-remove-predicate-level F _ _ _) (predicate#map-remove-predicate-level F _ _ _).
%total (F#888 F#890 F#892 F#894 F#896 F#898 ) (predicate#map-remove-gterm-level F#888 _ _ _) (predargs#map-remove-gterm-level F#890 _ _ _) (gterm#map-remove-gterm-level F#892 _ _ _) (predargs#map-remove-predicate-level F#894 _ _ _) (gterm#map-remove-predicate-level F#896 _ _ _) (predicate#map-remove-predicate-level F#898 _ _ _).



%%% Theorems for switching from nolevel back to level


%theorem gterm#map-add-gterm-level:
	forall*
		{K:vark}
		{Kgterm:vark}
		{FH:{x:gterm Kgterm} ({v:gterm#var x} gterm#list)}
		{Hpredicate:predicate#list}
		{F:gterm Kgterm -> gterm K}
		{L:nat}
		{N:nat}
		{HI:gterm#list}
		{H':gterm#list}
	forall
		{FM':{x:gterm Kgterm} ({v:gterm#var x} (gterm#nolevel x -> gterm#map K (FH x v) Hpredicate (F x) N))}
		{FS:{x:gterm Kgterm} ({v:gterm#var x} (gterm#split (FH x v) x HI H'))}
		{C:gterm#count Kgterm H' L}
	exists
		{FM:{x:gterm Kgterm} ({v:gterm#var x} (gterm#level x L -> gterm#map K (FH x v) Hpredicate (F x) N))}
	true.

%theorem predicate#map-add-gterm-level:
	forall*
		{K:predtype}
		{Kgterm:vark}
		{FH:{x:gterm Kgterm} ({v:gterm#var x} gterm#list)}
		{Hpredicate:predicate#list}
		{F:gterm Kgterm -> predicate K}
		{L:nat}
		{N:nat}
		{HI:gterm#list}
		{H':gterm#list}
	forall
		{FM':{x:gterm Kgterm} ({v:gterm#var x} (gterm#nolevel x -> predicate#map K (FH x v) Hpredicate (F x) N))}
		{FS:{x:gterm Kgterm} ({v:gterm#var x} (gterm#split (FH x v) x HI H'))}
		{C:gterm#count Kgterm H' L}
	exists
		{FM:{x:gterm Kgterm} ({v:gterm#var x} (gterm#level x L -> predicate#map K (FH x v) Hpredicate (F x) N))}
	true.

%theorem predargs#map-add-gterm-level:
	forall*
		{K:predtype}
		{Kgterm:vark}
		{FH:{x:gterm Kgterm} ({v:gterm#var x} gterm#list)}
		{Hpredicate:predicate#list}
		{F:gterm Kgterm -> predargs K}
		{L:nat}
		{N:nat}
		{HI:gterm#list}
		{H':gterm#list}
	forall
		{FM':{x:gterm Kgterm} ({v:gterm#var x} (gterm#nolevel x -> predargs#map K (FH x v) Hpredicate (F x) N))}
		{FS:{x:gterm Kgterm} ({v:gterm#var x} (gterm#split (FH x v) x HI H'))}
		{C:gterm#count Kgterm H' L}
	exists
		{FM:{x:gterm Kgterm} ({v:gterm#var x} (gterm#level x L -> predargs#map K (FH x v) Hpredicate (F x) N))}
	true.

%theorem predicate#map-add-predicate-level:
	forall*
		{K:predtype}
		{Kpredicate:predtype}
		{Hgterm:gterm#list}
		{FH:{x:predicate Kpredicate} ({v:predicate#var x} predicate#list)}
		{F:predicate Kpredicate -> predicate K}
		{L:nat}
		{N:nat}
		{HI:predicate#list}
		{H':predicate#list}
	forall
		{FM':{x:predicate Kpredicate} ({v:predicate#var x} (predicate#nolevel x -> predicate#map K Hgterm (FH x v) (F x) N))}
		{FS:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#split (FH x v) x HI H'))}
		{C:predicate#count Kpredicate H' L}
	exists
		{FM:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#level x L -> predicate#map K Hgterm (FH x v) (F x) N))}
	true.

%theorem gterm#map-add-predicate-level:
	forall*
		{K:vark}
		{Kpredicate:predtype}
		{Hgterm:gterm#list}
		{FH:{x:predicate Kpredicate} ({v:predicate#var x} predicate#list)}
		{F:predicate Kpredicate -> gterm K}
		{L:nat}
		{N:nat}
		{HI:predicate#list}
		{H':predicate#list}
	forall
		{FM':{x:predicate Kpredicate} ({v:predicate#var x} (predicate#nolevel x -> gterm#map K Hgterm (FH x v) (F x) N))}
		{FS:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#split (FH x v) x HI H'))}
		{C:predicate#count Kpredicate H' L}
	exists
		{FM:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#level x L -> gterm#map K Hgterm (FH x v) (F x) N))}
	true.

%theorem predargs#map-add-predicate-level:
	forall*
		{K:predtype}
		{Kpredicate:predtype}
		{Hgterm:gterm#list}
		{FH:{x:predicate Kpredicate} ({v:predicate#var x} predicate#list)}
		{F:predicate Kpredicate -> predargs K}
		{L:nat}
		{N:nat}
		{HI:predicate#list}
		{H':predicate#list}
	forall
		{FM':{x:predicate Kpredicate} ({v:predicate#var x} (predicate#nolevel x -> predargs#map K Hgterm (FH x v) (F x) N))}
		{FS:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#split (FH x v) x HI H'))}
		{C:predicate#count Kpredicate H' L}
	exists
		{FM:{x:predicate Kpredicate} ({v:predicate#var x} (predicate#level x L -> predargs#map K Hgterm (FH x v) (F x) N))}
	true.



%% Cases

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/object/ D0 D1 D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/object/ D0 D1 D2 D3 (FC4 x v) D5 D6 D7 D8)))).

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/fraction/ D0 FF1 D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/fraction/ D0 FF1 D2 D3 (FC4 x v) D5 D6 D7 D8)))).

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/empty D0 (FC1 x v) D2 D3 D4)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/empty D0 (FC1 x v) D2 D3 D4)))).

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/scale D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x v) D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/scale D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x v) D7 D8 D9 D10))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1
    <- gterm#map-add-gterm-level FF'4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF4.

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/combine D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x v) D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/combine D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x v) D7 D8 D9 D10))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1
    <- gterm#map-add-gterm-level FF'4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF4.

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/unitperm D0 (FF'1 x v nl) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/unitperm D0 (FF1 x v l) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1.

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/nonlinear D0 (FF'1 x v nl) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/nonlinear D0 (FF1 x v l) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1.

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/conditional D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FF'6 x v nl) D7 (FC8 x v) D9 D10 D11 D12)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/conditional D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FF6 x v l) D7 (FC8 x v) D9 D10 D11 D12))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1
    <- gterm#map-add-gterm-level FF'4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF4
    <- gterm#map-add-gterm-level FF'6 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF6.

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/encumbered D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x v) D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/encumbered D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x v) D7 D8 D9 D10))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1
    <- gterm#map-add-gterm-level FF'4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF4.

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/precise-exists D0 (FF'1 x v nl) D2 D3 D4 D5 ([x0:gterm objectk] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'6 x0 v0 nl0 x v nl)))) D7 (FC8 x v) D9 D10 D11 D12)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/precise-exists D0 (FF1 x v l) D2 D3 D4 D5 ([x0:gterm objectk] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF6 x0 v0 nl0 x v l)))) D7 (FC8 x v) D9 D10 D11 D12))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1
    <- ({x0:gterm objectk} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (gterm#map-add-gterm-level (FF'6 x0 v0 nl0) ([x:gterm Kgterm] ([v:gterm#var x] (gterm#split/there (FS x v)))) C (FF6 x0 v0 nl0))))).

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/basic D0 (FF'1 x v nl) D2 D3 D4 D5 (FF'6 x v nl) D7 (FC8 x v) D9 D10 D11 D12)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/basic D0 (FF1 x v l) D2 D3 D4 D5 (FF6 x v l) D7 (FC8 x v) D9 D10 D11 D12))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1
    <- gterm#map-add-gterm-level FF'6 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF6.

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/t D0 (FC1 x v) D2 D3 D4)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/t D0 (FC1 x v) D2 D3 D4)))).

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/neg D0 (FF'1 x v nl) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/neg D0 (FF1 x v l) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1.

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/conj D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x v) D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/conj D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x v) D7 D8 D9 D10))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1
    <- gterm#map-add-gterm-level FF'4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF4.

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/objequal D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x v) D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/objequal D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x v) D7 D8 D9 D10))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1
    <- gterm#map-add-gterm-level FF'4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF4.

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/exists* D0 FF1 D2 D3 ([x0:gterm A0] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'4 x0 v0 nl0 x v nl)))) D5 D6 (FC7 x v) D8 D9 D10 D11)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/exists* D0 FF1 D2 D3 ([x0:gterm A0] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF4 x0 v0 nl0 x v l)))) D5 D6 (FC7 x v) D8 D9 D10 D11))))
    <- ({x0:gterm A0} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (gterm#map-add-gterm-level (FF'4 x0 v0 nl0) ([x:gterm Kgterm] ([v:gterm#var x] (gterm#split/there (FS x v)))) C (FF4 x0 v0 nl0))))).

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/nested D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 D6 D7 (FC8 x v) D9 D10 D11 D12)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/nested D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 D6 D7 (FC8 x v) D9 D10 D11 D12))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1
    <- gterm#map-add-gterm-level FF'4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF4.

- : predicate#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predicate#map/predicate/0 D0 (FF'1 x v nl) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predicate#map/predicate/0 D0 (FF1 x v l) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1.

- : predicate#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predicate#map/predicate/Y D0 ([x0:predicate predtype/0] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predicate#map/predicate/Y D0 ([x0:predicate predtype/0] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- ({x0:predicate predtype/0} ({v0:predicate#var x0} ({nl0:predicate#nolevel x0} (predicate#map-add-gterm-level (FF'1 x0 v0 nl0) ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C (FF1 x0 v0 nl0))))).

- : predicate#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predicate#map/predicate/+ D0 ([x0:gterm K#695] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predicate#map/predicate/+ D0 ([x0:gterm K#695] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- ({x0:gterm K#695} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (predicate#map-add-gterm-level (FF'1 x0 v0 nl0) ([x:gterm Kgterm] ([v:gterm#var x] (gterm#split/there (FS x v)))) C (FF1 x0 v0 nl0))))).

- : predicate#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predicate#map/predicate/Y1 D0 ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predicate#map/predicate/Y1 D0 ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- ({x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)} ({v0:predicate#var x0} ({nl0:predicate#nolevel x0} (predicate#map-add-gterm-level (FF'1 x0 v0 nl0) ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C (FF1 x0 v0 nl0))))).

- : predargs#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predargs#map/predargs/0* D0 D1 D2 D3 D4 D5 D6 D7 D8)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predargs#map/predargs/0* D0 D1 D2 D3 D4 D5 D6 D7 D8)))).

- : predargs#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (predargs#map/predargs/+ D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 D6 D7 D8 D9 D10)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (predargs#map/predargs/+ D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 D6 D7 D8 D9 D10))))
    <- gterm#map-add-gterm-level FF'1 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF1
    <- predargs#map-add-gterm-level FF'4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF4.

- : gterm#map-add-gterm-level ([x:gterm Kgterm] ([v:gterm#var x] ([nl:gterm#nolevel x] (gterm#map/predcall* D0 FF1 D2 D3 (FF'4 x v nl) D5 (FF'6 x v nl) D7 (FC8 x v) D9 D10 D11 D12)))) FS C ([x:gterm Kgterm] ([v:gterm#var x] ([l:gterm#level x _] (gterm#map/predcall* D0 FF1 D2 D3 (FF4 x v l) D5 (FF6 x v l) D7 (FC8 x v) D9 D10 D11 D12))))
    <- predicate#map-add-gterm-level FF'4 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF4
    <- predargs#map-add-gterm-level FF'6 ([x:gterm Kgterm] ([v:gterm#var x] (FS x v))) C FF6.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/object/ D0 D1 D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/object/ D0 D1 D2 D3 (FC4 x) D5 D6 D7 D8)))).

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/fraction/ D0 FF1 D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/fraction/ D0 FF1 D2 D3 (FC4 x) D5 D6 D7 D8)))).

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/empty D0 (FC1 x) D2 D3 D4)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/empty D0 (FC1 x) D2 D3 D4)))).

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/scale D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x) D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/scale D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x) D7 D8 D9 D10))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1
    <- gterm#map-add-predicate-level FF'4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF4.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/combine D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x) D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/combine D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x) D7 D8 D9 D10))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1
    <- gterm#map-add-predicate-level FF'4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF4.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/unitperm D0 (FF'1 x v nl) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/unitperm D0 (FF1 x v l) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/nonlinear D0 (FF'1 x v nl) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/nonlinear D0 (FF1 x v l) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/conditional D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FF'6 x v nl) D7 (FC8 x) D9 D10 D11 D12)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/conditional D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FF6 x v l) D7 (FC8 x) D9 D10 D11 D12))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1
    <- gterm#map-add-predicate-level FF'4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF4
    <- gterm#map-add-predicate-level FF'6 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF6.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/encumbered D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x) D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/encumbered D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x) D7 D8 D9 D10))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1
    <- gterm#map-add-predicate-level FF'4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF4.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/precise-exists D0 (FF'1 x v nl) D2 D3 D4 D5 ([x0:gterm objectk] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'6 x0 v0 nl0 x v nl)))) D7 (FC8 x) D9 D10 D11 D12)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/precise-exists D0 (FF1 x v l) D2 D3 D4 D5 ([x0:gterm objectk] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF6 x0 v0 nl0 x v l)))) D7 (FC8 x) D9 D10 D11 D12))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1
    <- ({x0:gterm objectk} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (gterm#map-add-predicate-level (FF'6 x0 v0 nl0) ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C (FF6 x0 v0 nl0))))).

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/basic D0 (FF'1 x v nl) D2 D3 D4 D5 (FF'6 x v nl) D7 (FC8 x) D9 D10 D11 D12)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/basic D0 (FF1 x v l) D2 D3 D4 D5 (FF6 x v l) D7 (FC8 x) D9 D10 D11 D12))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1
    <- gterm#map-add-predicate-level FF'6 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF6.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/t D0 (FC1 x) D2 D3 D4)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/t D0 (FC1 x) D2 D3 D4)))).

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/neg D0 (FF'1 x v nl) D2 D3 (FC4 x) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/neg D0 (FF1 x v l) D2 D3 (FC4 x) D5 D6 D7 D8))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/conj D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x) D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/conj D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x) D7 D8 D9 D10))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1
    <- gterm#map-add-predicate-level FF'4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF4.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/objequal D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 (FC6 x) D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/objequal D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 (FC6 x) D7 D8 D9 D10))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1
    <- gterm#map-add-predicate-level FF'4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF4.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/exists* D0 FF1 D2 D3 ([x0:gterm A0] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'4 x0 v0 nl0 x v nl)))) D5 D6 (FC7 x) D8 D9 D10 D11)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/exists* D0 FF1 D2 D3 ([x0:gterm A0] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF4 x0 v0 nl0 x v l)))) D5 D6 (FC7 x) D8 D9 D10 D11))))
    <- ({x0:gterm A0} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (gterm#map-add-predicate-level (FF'4 x0 v0 nl0) ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C (FF4 x0 v0 nl0))))).

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/nested D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 D6 D7 (FC8 x) D9 D10 D11 D12)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/nested D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 D6 D7 (FC8 x) D9 D10 D11 D12))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1
    <- gterm#map-add-predicate-level FF'4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF4.

- : predargs#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predargs#map/predargs/0* D0 D1 D2 D3 D4 D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predargs#map/predargs/0* D0 D1 D2 D3 D4 D5 D6 D7 D8)))).

- : predargs#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predargs#map/predargs/+ D0 (FF'1 x v nl) D2 D3 (FF'4 x v nl) D5 D6 D7 D8 D9 D10)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predargs#map/predargs/+ D0 (FF1 x v l) D2 D3 (FF4 x v l) D5 D6 D7 D8 D9 D10))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1
    <- predargs#map-add-predicate-level FF'4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF4.

- : gterm#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (gterm#map/predcall* D0 FF1 D2 D3 (FF'4 x v nl) D5 (FF'6 x v nl) D7 (FC8 x) D9 D10 D11 D12)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (gterm#map/predcall* D0 FF1 D2 D3 (FF4 x v l) D5 (FF6 x v l) D7 (FC8 x) D9 D10 D11 D12))))
    <- predicate#map-add-predicate-level FF'4 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF4
    <- predargs#map-add-predicate-level FF'6 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF6.

- : predicate#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predicate#map/predicate/0 D0 (FF'1 x v nl) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predicate#map/predicate/0 D0 (FF1 x v l) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- gterm#map-add-predicate-level FF'1 ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C FF1.

- : predicate#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predicate#map/predicate/Y D0 ([x0:predicate predtype/0] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predicate#map/predicate/Y D0 ([x0:predicate predtype/0] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- ({x0:predicate predtype/0} ({v0:predicate#var x0} ({nl0:predicate#nolevel x0} (predicate#map-add-predicate-level (FF'1 x0 v0 nl0) ([x:predicate Kpredicate] ([v:predicate#var x] (predicate#split/there (FS x v)))) C (FF1 x0 v0 nl0))))).

- : predicate#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predicate#map/predicate/+ D0 ([x0:gterm K#695] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predicate#map/predicate/+ D0 ([x0:gterm K#695] ([v0:gterm#var x0] ([nl0:gterm#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- ({x0:gterm K#695} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (predicate#map-add-predicate-level (FF'1 x0 v0 nl0) ([x:predicate Kpredicate] ([v:predicate#var x] (FS x v))) C (FF1 x0 v0 nl0))))).

- : predicate#map-add-predicate-level ([x:predicate Kpredicate] ([v:predicate#var x] ([nl:predicate#nolevel x] (predicate#map/predicate/Y1 D0 ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF'1 x0 v0 nl0 x v nl)))) D2 D3 (FC4 x v) D5 D6 D7 D8)))) FS C ([x:predicate Kpredicate] ([v:predicate#var x] ([l:predicate#level x _] (predicate#map/predicate/Y1 D0 ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([nl0:predicate#nolevel x0] (FF1 x0 v0 nl0 x v l)))) D2 D3 (FC4 x v) D5 D6 D7 D8))))
    <- ({x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)} ({v0:predicate#var x0} ({nl0:predicate#nolevel x0} (predicate#map-add-predicate-level (FF'1 x0 v0 nl0) ([x:predicate Kpredicate] ([v:predicate#var x] (predicate#split/there (FS x v)))) C (FF1 x0 v0 nl0))))).


- : gterm#map-add-gterm-level ([x] [v] [nl] gterm#map/#level VL) _ _
                        ([x] [v] [l] gterm#map/#level VL).



- : gterm#map-add-gterm-level ([x] [v] [nl] gterm#map/#nolevel NL (FS x v) (FC x v)) _ _
                        ([x] [v] [l] gterm#map/#nolevel NL (FS x v) (FC x v)).



- : gterm#map-add-gterm-level ([x] [v] [nl] gterm#map/#nolevel nl (FS1 x v) (FC1 x v)) 
                        FS2 C2 FM
    <- gterm#lookup-deterministic FS2 C2 FS1 FC1 E
    <- ({x} {v} {l}  gterm#map-respects-eq (gterm#map/#level l) gterm#eq/ E (FM x v l)).



- : predicate#map-add-gterm-level ([x] [v] [nl] predicate#map/#level VL) _ _
                        ([x] [v] [l] predicate#map/#level VL).



- : predicate#map-add-gterm-level ([x] [v] [nl] predicate#map/#nolevel NL (FS x) (FC x)) _ _
                        ([x] [v] [l] predicate#map/#nolevel NL (FS x) (FC x)).



- : predicate#map-add-predicate-level ([x] [v] [nl] predicate#map/#level VL) _ _
                        ([x] [v] [l] predicate#map/#level VL).



- : predicate#map-add-predicate-level ([x] [v] [nl] predicate#map/#nolevel NL (FS x v) (FC x v)) _ _
                        ([x] [v] [l] predicate#map/#nolevel NL (FS x v) (FC x v)).



- : predicate#map-add-predicate-level ([x] [v] [nl] predicate#map/#nolevel nl (FS1 x v) (FC1 x v)) 
                        FS2 C2 FM
    <- predicate#lookup-deterministic FS2 C2 FS1 FC1 E
    <- ({x} {v} {l}  predicate#map-respects-eq (predicate#map/#level l) predicate#eq/ E (FM x v l)).



- : gterm#map-add-predicate-level ([x] [v] [nl] gterm#map/#level VL) _ _
                        ([x] [v] [l] gterm#map/#level VL).



- : gterm#map-add-predicate-level ([x] [v] [nl] gterm#map/#nolevel NL (FS x) (FC x)) _ _
                        ([x] [v] [l] gterm#map/#nolevel NL (FS x) (FC x)).



%worlds (block#gterm#var | block#gterm#level | block#gterm#nolevel | block#predicate#var | block#predicate#level | block#predicate#nolevel) (predicate#map-add-gterm-level F _ _ _) (predargs#map-add-gterm-level F _ _ _) (gterm#map-add-gterm-level F _ _ _) (predargs#map-add-predicate-level F _ _ _) (gterm#map-add-predicate-level F _ _ _) (predicate#map-add-predicate-level F _ _ _).
%total (F#889 F#891 F#893 F#895 F#897 F#899 ) (predicate#map-add-gterm-level F#889 _ _ _) (predargs#map-add-gterm-level F#891 _ _ _) (gterm#map-add-gterm-level F#893 _ _ _) (predargs#map-add-predicate-level F#895 _ _ _) (gterm#map-add-predicate-level F#897 _ _ _) (predicate#map-add-predicate-level F#899 _ _ _).



%%% Helper definition for dealing with variables


gterm#case : gterm K -> type .

predicate#case : predicate K -> type .



%% Cases

gterm#case/#level : gterm#level X _ -> gterm#case X .

gterm#case/#nolevel : gterm#nolevel X -> gterm#case X .

gterm#case/empty : gterm#case empty .

gterm#case/scale : gterm#case (scale _ _) .

gterm#case/combine : gterm#case (combine _ _) .

gterm#case/unitperm : gterm#case (unitperm _) .

gterm#case/nonlinear : gterm#case (nonlinear _) .

gterm#case/conditional : gterm#case (conditional _ _ _) .

gterm#case/encumbered : gterm#case (encumbered _ _) .

gterm#case/precise-exists : gterm#case (precise-exists _ _ _) .

gterm#case/basic : gterm#case (basic _ _ _) .

gterm#case/object/ : gterm#case (object/ _) .

gterm#case/fraction/ : gterm#case (fraction/ _) .

gterm#case/t : gterm#case t .

gterm#case/neg : gterm#case (neg _) .

gterm#case/conj : gterm#case (conj _ _) .

gterm#case/objequal : gterm#case (objequal _ _) .

gterm#case/exists* : gterm#case (exists* _ _) .

gterm#case/nested : gterm#case (nested _ _ _) .

gterm#case/predcall* : gterm#case (predcall* _ _ _) .

predicate#case/#level : predicate#level X _ -> predicate#case X .

predicate#case/#nolevel : predicate#nolevel X -> predicate#case X .

predicate#case/predicate/0 : predicate#case (predicate/0 _) .

predicate#case/predicate/+ : predicate#case (predicate/+ _) .

predicate#case/predicate/Y : predicate#case (predicate/Y _) .







%%% Theorems about case


%theorem gterm#case-total:
	forall*
		{K:vark}
	forall
		{T:gterm K}
	exists
		{C:gterm#case T}
	true.

fake : type .

- : (gterm#case-total T C -> gterm#case-total X Y) -> fake .

%theorem predicate#case-total:
	forall*
		{K:predtype}
	forall
		{T:predicate K}
	exists
		{C:predicate#case T}
	true.

fake : type .

- : (predicate#case-total T C -> predicate#case-total X Y) -> fake .

%block block#gterm#case/level : some {K:vark} {N:nat} block {x:gterm K} {v:gterm#var x} {l:gterm#level x N} {vc:gterm#case-total x (gterm#case/#level l)}.

%block block#gterm#case/nolevel : some {K:vark} block {x:gterm K} {v:gterm#var x} {nl:gterm#nolevel x} {vc:gterm#case-total x (gterm#case/#nolevel nl)}.

%block block#predicate#case/level : some {K:predtype} {N:nat} block {x:predicate K} {v:predicate#var x} {l:predicate#level x N} {vc:predicate#case-total x (predicate#case/#level l)}.

%block block#predicate#case/nolevel : some {K:predtype} block {x:predicate K} {v:predicate#var x} {nl:predicate#nolevel x} {vc:predicate#case-total x (predicate#case/#nolevel nl)}.



%% Cases

- : gterm#case-total _ gterm#case/empty.

- : gterm#case-total _ gterm#case/scale.

- : gterm#case-total _ gterm#case/combine.

- : gterm#case-total _ gterm#case/unitperm.

- : gterm#case-total _ gterm#case/nonlinear.

- : gterm#case-total _ gterm#case/conditional.

- : gterm#case-total _ gterm#case/encumbered.

- : gterm#case-total _ gterm#case/precise-exists.

- : gterm#case-total _ gterm#case/basic.

- : gterm#case-total _ gterm#case/object/.

- : gterm#case-total _ gterm#case/fraction/.

- : gterm#case-total _ gterm#case/t.

- : gterm#case-total _ gterm#case/neg.

- : gterm#case-total _ gterm#case/conj.

- : gterm#case-total _ gterm#case/objequal.

- : gterm#case-total _ gterm#case/exists*.

- : gterm#case-total _ gterm#case/nested.

- : gterm#case-total _ gterm#case/predcall*.

- : predicate#case-total _ predicate#case/predicate/0.

- : predicate#case-total _ predicate#case/predicate/+.

- : predicate#case-total _ predicate#case/predicate/Y.


%worlds (block#gterm#case/level | block#gterm#case/nolevel | block#predicate#case/level | block#predicate#case/nolevel) (gterm#case-total N _) (predicate#case-total N _).
%total (N#880 N#884 ) (gterm#case-total N#880 _) (predicate#case-total N#884 _).



%%% Theorems about totality of mappings with variables


%theorem gterm#map-total*:
	forall*
		{K:vark}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{T:gterm K}
	exists
		{N:nat}
		{M:gterm#map K Hgterm Hpredicate T N}
	true.

%theorem gterm#map-total/L:
	forall*
		{K:vark}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{T:gterm K}
		{C:gterm#case T}
	exists
		{N:nat}
		{M:gterm#map K Hgterm Hpredicate T N}
	true.

%theorem predicate#map-total*:
	forall*
		{K:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{T:predicate K}
	exists
		{N:nat}
		{M:predicate#map K Hgterm Hpredicate T N}
	true.

%theorem predicate#map-total/L:
	forall*
		{K:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{T:predicate K}
		{C:predicate#case T}
	exists
		{N:nat}
		{M:predicate#map K Hgterm Hpredicate T N}
	true.

%theorem predargs#map-total*:
	forall*
		{K:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{T:predargs K}
	exists
		{N:nat}
		{M:predargs#map K Hgterm Hpredicate T N}
	true.

%abbrev gterm#map-total : gterm#map K Hgterm Hpredicate T N -> type = [m:gterm#map K Hgterm Hpredicate T N] (gterm#map-total* T N m) .

%abbrev predicate#map-total : predicate#map K Hgterm Hpredicate T N -> type = [m:predicate#map K Hgterm Hpredicate T N] (predicate#map-total* T N m) .

%abbrev predargs#map-total : predargs#map K Hgterm Hpredicate T N -> type = [m:predargs#map K Hgterm Hpredicate T N] (predargs#map-total* T N m) .



%% Cases

- : gterm#map-total* T N M
    <- gterm#case-total T C
    <- gterm#map-total/L T C N M.

- : gterm#map-total/L V (gterm#case/#level L) _ (gterm#map/#level L).

- : predicate#map-total* T N M
    <- predicate#case-total T C
    <- predicate#map-total/L T C N M.

- : predicate#map-total/L V (predicate#case/#level L) _ (predicate#map/#level L).

- : gterm#map-total/L _ _ _ (gterm#map/object/ nat`eq/ nat`eq/ D0 0+N=N D1 D2 0+N=N 0+N=N D3)
    <- nat`times-left-identity _ D0
    <- gterm#count-total D1
    <- nat`times-left-identity _ D2
    <- nat`plus-total D3.

- : gterm#map-total/L _ _ _ (gterm#map/fraction/ nat`eq/ D0 D1 0+N=N D2 D3 0+N=N 0+N=N D4)
    <- rat#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- gterm#count-total D2
    <- nat`times-left-identity _ D3
    <- nat`plus-total D4.

- : gterm#map-total/L _ _ _ (gterm#map/empty nat`eq/ D0 nat`eq/ 0+N=N 0+N=N)
    <- gterm#count-total D0.

- : gterm#map-total/L _ _ _ (gterm#map/scale nat`eq/ D0 D1 0+N=N D2 D3 D4 D5 0+N=N 1+N=sN D6)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- gterm#map-total* _ _ D2
    <- natpair`pair2nat-total D3
    <- gterm#count-total D4
    <- nat`times-total D5
    <- nat`plus-total D6.

- : gterm#map-total/L _ _ _ (gterm#map/combine nat`eq/ D0 D1 0+N=N D2 D3 D4 D5 1+N=sN 1+N=sN D6)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- gterm#map-total* _ _ D2
    <- natpair`pair2nat-total D3
    <- gterm#count-total D4
    <- nat`times-total D5
    <- nat`plus-total D6.

- : gterm#map-total/L _ _ _ (gterm#map/unitperm nat`eq/ D0 D1 0+N=N D2 D3 2+N=ssN 1+N=sN D4)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- gterm#count-total D2
    <- nat`times-total D3
    <- nat`plus-total D4.

- : gterm#map-total/L _ _ _ (gterm#map/nonlinear nat`eq/ D0 D1 0+N=N D2 D3 0+N=N 0+N=N D4)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- gterm#count-total D2
    <- nat`times-total D3
    <- nat`plus-total D4.

- : gterm#map-total/L _ _ _ (gterm#map/conditional nat`eq/ D0 D1 0+N=N D2 D3 D4 D5 D6 D7 1+N=sN 0+N=N D8)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- gterm#map-total* _ _ D2
    <- natpair`pair2nat-total D3
    <- gterm#map-total* _ _ D4
    <- natpair`pair2nat-total D5
    <- gterm#count-total D6
    <- nat`times-total D7
    <- nat`plus-total D8.

- : gterm#map-total/L _ _ _ (gterm#map/encumbered nat`eq/ D0 D1 0+N=N D2 D3 D4 D5 2+N=ssN 0+N=N D6)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- gterm#map-total* _ _ D2
    <- natpair`pair2nat-total D3
    <- gterm#count-total D4
    <- nat`times-total D5
    <- nat`plus-total D6.

- : gterm#map-total/L _ _ _ (gterm#map/precise-exists nat`eq/ D0 D1 0+N=N nat`eq/ D2 D3 D6 D7 D8 3+N=sssN 0+N=N D9)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- natpair`pair2nat-total D2
    <- gterm#count-total Cgterm
    <- ({x0:gterm objectk} ({v0:gterm#var x0} ({x0l:gterm#level x0 _} (gterm#case-total x0 (gterm#case/#level x0l) -> gterm#map-total* _ _ (D3' x0 v0 x0l)))))
    <- gterm#map-remove-gterm-level ([x0:gterm objectk] ([v0:gterm#var x0] ([x0l:gterm#level x0 _] (D3' x0 v0 x0l)))) ([x0:gterm objectk] ([v0:gterm#var x0] gterm#split/here)) Cgterm ([x0:gterm objectk] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (D3 x0 v0 x0nl))))
    <- natpair`pair2nat-total D6
    <- gterm#count-total D7
    <- nat`times-total D8
    <- nat`plus-total D9.

- : gterm#map-total/L _ _ _ (gterm#map/basic nat`eq/ D0 D1 0+N=N nat`eq/ D2 D3 D4 D5 D6 4+N=ssssN 0+N=N D7)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- natpair`pair2nat-total D2
    <- gterm#map-total* _ _ D3
    <- natpair`pair2nat-total D4
    <- gterm#count-total D5
    <- nat`times-total D6
    <- nat`plus-total D7.

- : gterm#map-total/L _ _ _ (gterm#map/t nat`eq/ D0 nat`eq/ 0+N=N 0+N=N)
    <- gterm#count-total D0.

- : gterm#map-total/L _ _ _ (gterm#map/neg nat`eq/ D0 D1 0+N=N D2 D3 0+N=N 1+N=sN D4)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- gterm#count-total D2
    <- nat`times-total D3
    <- nat`plus-total D4.

- : gterm#map-total/L _ _ _ (gterm#map/conj nat`eq/ D0 D1 0+N=N D2 D3 D4 D5 1+N=sN 1+N=sN D6)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- gterm#map-total* _ _ D2
    <- natpair`pair2nat-total D3
    <- gterm#count-total D4
    <- nat`times-total D5
    <- nat`plus-total D6.

- : gterm#map-total/L _ _ _ (gterm#map/objequal nat`eq/ D0 D1 0+N=N D2 D3 D4 D5 2+N=ssN 1+N=sN D6)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- gterm#map-total* _ _ D2
    <- natpair`pair2nat-total D3
    <- gterm#count-total D4
    <- nat`times-total D5
    <- nat`plus-total D6.

- : gterm#map-total/L _ _ _ (gterm#map/exists* nat`eq/ D0 D1 0+N=N D3 D6 D7 D8 D9 3+N=sssN 1+N=sN D10)
    <- vark#map-total* _ _ D0 G0
    <- nat`times-left-identity _ D1
    <- plus-left-preserves-gt* G0 0+5=5 0+N=N G2
    <- gterm#count-total Cgterm
    <- ({x0:gterm A0} ({v0:gterm#var x0} ({x0l:gterm#level x0 _} (gterm#case-total x0 (gterm#case/#level x0l) -> gterm#map-total* _ _ (D3' x0 v0 x0l)))))
    <- gterm#map-remove-gterm-level ([x0:gterm A0] ([v0:gterm#var x0] ([x0l:gterm#level x0 _] (D3' x0 v0 x0l)))) ([x0:gterm A0] ([v0:gterm#var x0] gterm#split/here)) Cgterm ([x0:gterm A0] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (D3 x0 v0 x0nl))))
    <- nat`times-total D6
    <- nat`plus-total D7
    <- gterm#count-total D8
    <- nat`times-total D9
    <- nat`plus-total D10.

- : gterm#map-total/L _ _ _ (gterm#map/nested nat`eq/ D0 D1 0+N=N D2 D3 nat`eq/ D4 D5 D6 4+N=ssssN 1+N=sN D7)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- gterm#map-total* _ _ D2
    <- natpair`pair2nat-total D3
    <- natpair`pair2nat-total D4
    <- gterm#count-total D5
    <- nat`times-total D6
    <- nat`plus-total D7.

- : gterm#map-total/L _ _ _ (gterm#map/predcall* nat`eq/ D0 D1 0+N=N D2 D3 D4 D5 D6 D7 5+N=sssssN 1+N=sN D8)
    <- predtype#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- predicate#map-total* _ _ D2
    <- natpair`pair2nat-total D3
    <- predargs#map-total* _ _ D4
    <- natpair`pair2nat-total D5
    <- gterm#count-total D6
    <- nat`times-total D7
    <- nat`plus-total D8.

- : predicate#map-total/L _ _ _ (predicate#map/predicate/0 nat`eq/ D0 D1 0+N=N D2 D3 0+N=N 0+N=N D4)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- predicate#count-total D2
    <- nat`times-total D3
    <- nat`plus-total D4.

- : predicate#map-total/L _ _ _ (predicate#map/predicate/Y nat`eq/ D0 D3 0+N=N D4 D5 1+N=sN 0+N=N D6)
    <- predicate#count-total Cpredicate
    <- ({x0:predicate predtype/0} ({v0:predicate#var x0} ({x0l:predicate#level x0 _} (predicate#case-total x0 (predicate#case/#level x0l) -> predicate#map-total* _ _ (D0' x0 v0 x0l)))))
    <- predicate#map-remove-predicate-level ([x0:predicate predtype/0] ([v0:predicate#var x0] ([x0l:predicate#level x0 _] (D0' x0 v0 x0l)))) ([x0:predicate predtype/0] ([v0:predicate#var x0] predicate#split/here)) Cpredicate ([x0:predicate predtype/0] ([v0:predicate#var x0] ([x0nl:predicate#nolevel x0] (D0 x0 v0 x0nl))))
    <- nat`times-left-identity _ D3
    <- predicate#count-total D4
    <- nat`times-total D5
    <- nat`plus-total D6.

- : predicate#map-total/L _ _ _ (predicate#map/predicate/+ nat`eq/ D0 D3 0+N=N D4 D5 0+N=N 0+N=N D6)
    <- gterm#count-total Cgterm
    <- ({x0:gterm K#695} ({v0:gterm#var x0} ({x0l:gterm#level x0 _} (gterm#case-total x0 (gterm#case/#level x0l) -> predicate#map-total* _ _ (D0' x0 v0 x0l)))))
    <- predicate#map-remove-gterm-level ([x0:gterm K#695] ([v0:gterm#var x0] ([x0l:gterm#level x0 _] (D0' x0 v0 x0l)))) ([x0:gterm K#695] ([v0:gterm#var x0] gterm#split/here)) Cgterm ([x0:gterm K#695] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (D0 x0 v0 x0nl))))
    <- nat`times-left-identity _ D3
    <- predicate#count-total D4
    <- nat`times-total D5
    <- nat`plus-total D6.

- : predicate#map-total/L _ _ _ (predicate#map/predicate/Y1 nat`eq/ D0 D3 0+N=N D4 D5 1+N=sN 0+N=N D6)
    <- predicate#count-total Cpredicate
    <- ({x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)} ({v0:predicate#var x0} ({x0l:predicate#level x0 _} (predicate#case-total x0 (predicate#case/#level x0l) -> predicate#map-total* _ _ (D0' x0 v0 x0l)))))
    <- predicate#map-remove-predicate-level ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([x0l:predicate#level x0 _] (D0' x0 v0 x0l)))) ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] predicate#split/here)) Cpredicate ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([x0nl:predicate#nolevel x0] (D0 x0 v0 x0nl))))
    <- nat`times-left-identity _ D3
    <- predicate#count-total D4
    <- nat`times-total D5
    <- nat`plus-total D6.

- : predargs#map-total* _ _ (predargs#map/predargs/0* nat`eq/ nat`eq/ D0 0+N=N nat`eq/ D1 0+N=N 0+0=0 D2)
    <- nat`times-left-identity _ D0
    <- nat`times-left-identity _ D1
    <- nat`plus-total D2.

- : predargs#map-total* _ _ (predargs#map/predargs/+ nat`eq/ D0 D1 0+N=N D2 D3 nat`eq/ D4 0+N=N 0+0=0 D5)
    <- gterm#map-total* _ _ D0
    <- nat`times-left-identity _ D1
    <- predargs#map-total* _ _ D2
    <- natpair`pair2nat-total D3
    <- nat`times-left-identity _ D4
    <- nat`plus-total D5.


%worlds (block#gterm#case/level | block#predicate#case/level) (gterm#map-total/L T _ _ _) (gterm#map-total* N _ _) (predicate#map-total/L T _ _ _) (predicate#map-total* N _ _) (predargs#map-total* N _ _).
%total (T#881 N#882 T#885 N#886 N#887 ) (gterm#map-total/L T#881 _ _ _) (gterm#map-total* N#882 _ _) (predicate#map-total/L T#885 _ _ _) (predicate#map-total* N#886 _ _) (predargs#map-total* N#887 _ _).



%%% Lemmas to help prove determinism of mapping


%theorem gterm#level-deterministic:
	forall*
		{K:vark}
		{T1:gterm K}
		{N1:nat}
		{N2:nat}
	forall
		{L1:gterm#level T1 N1}
		{L2:gterm#level T1 N2}
	exists
		{EN:nat`eq N1 N2}
	true.

%theorem predicate#level-deterministic:
	forall*
		{K:predtype}
		{T1:predicate K}
		{N1:nat}
		{N2:nat}
	forall
		{L1:predicate#level T1 N1}
		{L2:predicate#level T1 N2}
	exists
		{EN:nat`eq N1 N2}
	true.



%% Cases

- : gterm#level-deterministic _ _ nat`eq/.

- : predicate#level-deterministic _ _ nat`eq/.


%worlds (block#gterm#var | block#gterm#level | block#predicate#var | block#predicate#level) (gterm#level-deterministic L1 _ _) (predicate#level-deterministic L1 _ _).
%total (L1#904 L1#907 ) (gterm#level-deterministic L1#904 _ _) (predicate#level-deterministic L1#907 _ _).



%%% Theorems about determinism of mapping with variables


%theorem gterm#map-deterministic*:
	forall*
		{K:vark}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{N1:nat}
		{N2:nat}
	forall
		{T1:gterm K}
		{T2:gterm K}
		{M1:gterm#map K Hgterm Hpredicate T1 N1}
		{M2:gterm#map K Hgterm Hpredicate T2 N2}
		{ET:gterm#eq T1 T2}
	exists
		{EN:nat`eq N1 N2}
	true.

%theorem predicate#map-deterministic*:
	forall*
		{K:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{N1:nat}
		{N2:nat}
	forall
		{T1:predicate K}
		{T2:predicate K}
		{M1:predicate#map K Hgterm Hpredicate T1 N1}
		{M2:predicate#map K Hgterm Hpredicate T2 N2}
		{ET:predicate#eq T1 T2}
	exists
		{EN:nat`eq N1 N2}
	true.

%theorem predargs#map-deterministic*:
	forall*
		{K:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{N1:nat}
		{N2:nat}
	forall
		{T1:predargs K}
		{T2:predargs K}
		{M1:predargs#map K Hgterm Hpredicate T1 N1}
		{M2:predargs#map K Hgterm Hpredicate T2 N2}
		{ET:predargs#eq T1 T2}
	exists
		{EN:nat`eq N1 N2}
	true.

%abbrev gterm#map-deterministic : gterm#map K Hgterm Hpredicate T1 N1 -> gterm#map K Hgterm Hpredicate T2 N2 -> gterm#eq T1 T2 -> nat`eq N1 N2 -> type = gterm#map-deterministic* _ _ .

%abbrev predicate#map-deterministic : predicate#map K Hgterm Hpredicate T1 N1 -> predicate#map K Hgterm Hpredicate T2 N2 -> predicate#eq T1 T2 -> nat`eq N1 N2 -> type = predicate#map-deterministic* _ _ .

%abbrev predargs#map-deterministic : predargs#map K Hgterm Hpredicate T1 N1 -> predargs#map K Hgterm Hpredicate T2 N2 -> predargs#eq T1 T2 -> nat`eq N1 N2 -> type = predargs#map-deterministic* _ _ .



%% Cases

- : gterm#map-deterministic (gterm#map/#level VL1) (gterm#map/#level VL2) gterm#eq/ EQ
    <- gterm#level-deterministic VL1 VL2 EQ.

- : predicate#map-deterministic (predicate#map/#level VL1) (predicate#map/#level VL2) predicate#eq/ EQ
    <- predicate#level-deterministic VL1 VL2 EQ.

- : gterm#map-deterministic (gterm#map/object/ X0 X1 X2 X3 X4 X5 X6 X7 X8) (gterm#map/object/ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- nat-eq-nop X1 Y1 nat`eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#count-deterministic X4 Y4 ENV
    <- nat`times-deterministic X5 Y5 nat`eq/ EN1 ETN
    <- nat`plus-deterministic X6 Y6 nat`eq/ ETN EPN
    <- nat`plus-deterministic X7 Y7 nat`eq/ ENV ENA
    <- nat`plus-deterministic X8 Y8 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/fraction/ X0 X1 X2 X3 X4 X5 X6 X7 X8) (gterm#map/fraction/ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- rat#map-deterministic X1 Y1 rat#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#count-deterministic X4 Y4 ENV
    <- nat`times-deterministic X5 Y5 nat`eq/ EN1 ETN
    <- nat`plus-deterministic X6 Y6 nat`eq/ ETN EPN
    <- nat`plus-deterministic X7 Y7 nat`eq/ ENV ENA
    <- nat`plus-deterministic X8 Y8 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/empty X0 X1 X2 X3 X4) (gterm#map/empty Y0 Y1 Y2 Y3 Y4) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#count-deterministic X1 Y1 ENV
    <- nat-eq-nop X2 Y2 EN0 EPN
    <- nat`plus-deterministic X3 Y3 nat`eq/ ENV ENA
    <- nat`plus-deterministic X4 Y4 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/scale X0 X1 X2 X3 X4 X5 X7 X8 X9 X10 X11) (gterm#map/scale Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y8 Y9 Y10 Y11) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#map-deterministic X4 Y4 gterm#eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- gterm#count-deterministic X7 Y7 ENV
    <- nat`times-deterministic X8 Y8 nat`eq/ EN2 ETN
    <- nat`plus-deterministic X9 Y9 nat`eq/ ETN EPN
    <- nat`plus-deterministic X10 Y10 nat`eq/ ENV ENA
    <- nat`plus-deterministic X11 Y11 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/combine X0 X1 X2 X3 X4 X5 X7 X8 X9 X10 X11) (gterm#map/combine Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y8 Y9 Y10 Y11) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#map-deterministic X4 Y4 gterm#eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- gterm#count-deterministic X7 Y7 ENV
    <- nat`times-deterministic X8 Y8 nat`eq/ EN2 ETN
    <- nat`plus-deterministic X9 Y9 nat`eq/ ETN EPN
    <- nat`plus-deterministic X10 Y10 nat`eq/ ENV ENA
    <- nat`plus-deterministic X11 Y11 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/unitperm X0 X1 X2 X3 X4 X5 X6 X7 X8) (gterm#map/unitperm Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#count-deterministic X4 Y4 ENV
    <- nat`times-deterministic X5 Y5 nat`eq/ EN1 ETN
    <- nat`plus-deterministic X6 Y6 nat`eq/ ETN EPN
    <- nat`plus-deterministic X7 Y7 nat`eq/ ENV ENA
    <- nat`plus-deterministic X8 Y8 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/nonlinear X0 X1 X2 X3 X4 X5 X6 X7 X8) (gterm#map/nonlinear Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#count-deterministic X4 Y4 ENV
    <- nat`times-deterministic X5 Y5 nat`eq/ EN1 ETN
    <- nat`plus-deterministic X6 Y6 nat`eq/ ETN EPN
    <- nat`plus-deterministic X7 Y7 nat`eq/ ENV ENA
    <- nat`plus-deterministic X8 Y8 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/conditional X0 X1 X2 X3 X4 X5 X7 X8 X10 X11 X12 X13 X14) (gterm#map/conditional Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y8 Y10 Y11 Y12 Y13 Y14) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#map-deterministic X4 Y4 gterm#eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- gterm#map-deterministic X7 Y7 gterm#eq/ ENA2
    <- natpair`pair-preserves-eq EN2 ENA2 EP8
    <- natpair`pair2nat-deterministic X8 Y8 EP8 EN3
    <- gterm#count-deterministic X10 Y10 ENV
    <- nat`times-deterministic X11 Y11 nat`eq/ EN3 ETN
    <- nat`plus-deterministic X12 Y12 nat`eq/ ETN EPN
    <- nat`plus-deterministic X13 Y13 nat`eq/ ENV ENA
    <- nat`plus-deterministic X14 Y14 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/encumbered X0 X1 X2 X3 X4 X5 X7 X8 X9 X10 X11) (gterm#map/encumbered Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y8 Y9 Y10 Y11) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#map-deterministic X4 Y4 gterm#eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- gterm#count-deterministic X7 Y7 ENV
    <- nat`times-deterministic X8 Y8 nat`eq/ EN2 ETN
    <- nat`plus-deterministic X9 Y9 nat`eq/ ETN EPN
    <- nat`plus-deterministic X10 Y10 nat`eq/ ENV ENA
    <- nat`plus-deterministic X11 Y11 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/precise-exists X0 X1 X2 X3 X4 X5 X7 X11 X13 X14 X15 X16 X17) (gterm#map/precise-exists Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y11 Y13 Y14 Y15 Y16 Y17) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- nat-eq-nop X4 Y4 nat`eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- gterm#count-total Cgterm
    <- gterm#map-add-gterm-level ([x0:gterm objectk] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (X7 x0 v0 x0nl)))) ([x0:gterm objectk] ([v0:gterm#var x0] gterm#split/here)) Cgterm ([x0:gterm objectk] ([v0:gterm#var x0] ([x0l:gterm#level x0 _] (X7' x0 v0 x0l))))
    <- gterm#map-add-gterm-level ([x0:gterm objectk] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (Y7 x0 v0 x0nl)))) ([x0:gterm objectk] ([v0:gterm#var x0] gterm#split/here)) Cgterm ([x0:gterm objectk] ([v0:gterm#var x0] ([x0l:gterm#level x0 _] (Y7' x0 v0 x0l))))
    <- ({x0:gterm objectk} ({v0:gterm#var x0} ({x0l:gterm#level x0 _} (gterm#map-deterministic (X7' x0 v0 x0l) (Y7' x0 v0 x0l) gterm#eq/ ENA2))))
    <- natpair`pair-preserves-eq EN2 ENA2 EP11
    <- natpair`pair2nat-deterministic X11 Y11 EP11 EN3
    <- gterm#count-deterministic X13 Y13 ENV
    <- nat`times-deterministic X14 Y14 nat`eq/ EN3 ETN
    <- nat`plus-deterministic X15 Y15 nat`eq/ ETN EPN
    <- nat`plus-deterministic X16 Y16 nat`eq/ ENV ENA
    <- nat`plus-deterministic X17 Y17 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/basic X0 X1 X2 X3 X4 X5 X7 X8 X10 X11 X12 X13 X14) (gterm#map/basic Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y8 Y10 Y11 Y12 Y13 Y14) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- nat-eq-nop X4 Y4 nat`eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- gterm#map-deterministic X7 Y7 gterm#eq/ ENA2
    <- natpair`pair-preserves-eq EN2 ENA2 EP8
    <- natpair`pair2nat-deterministic X8 Y8 EP8 EN3
    <- gterm#count-deterministic X10 Y10 ENV
    <- nat`times-deterministic X11 Y11 nat`eq/ EN3 ETN
    <- nat`plus-deterministic X12 Y12 nat`eq/ ETN EPN
    <- nat`plus-deterministic X13 Y13 nat`eq/ ENV ENA
    <- nat`plus-deterministic X14 Y14 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/t X0 X1 X2 X3 X4) (gterm#map/t Y0 Y1 Y2 Y3 Y4) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#count-deterministic X1 Y1 ENV
    <- nat-eq-nop X2 Y2 EN0 EPN
    <- nat`plus-deterministic X3 Y3 nat`eq/ ENV ENA
    <- nat`plus-deterministic X4 Y4 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/neg X0 X1 X2 X3 X4 X5 X6 X7 X8) (gterm#map/neg Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#count-deterministic X4 Y4 ENV
    <- nat`times-deterministic X5 Y5 nat`eq/ EN1 ETN
    <- nat`plus-deterministic X6 Y6 nat`eq/ ETN EPN
    <- nat`plus-deterministic X7 Y7 nat`eq/ ENV ENA
    <- nat`plus-deterministic X8 Y8 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/conj X0 X1 X2 X3 X4 X5 X7 X8 X9 X10 X11) (gterm#map/conj Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y8 Y9 Y10 Y11) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#map-deterministic X4 Y4 gterm#eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- gterm#count-deterministic X7 Y7 ENV
    <- nat`times-deterministic X8 Y8 nat`eq/ EN2 ETN
    <- nat`plus-deterministic X9 Y9 nat`eq/ ETN EPN
    <- nat`plus-deterministic X10 Y10 nat`eq/ ENV ENA
    <- nat`plus-deterministic X11 Y11 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/objequal X0 X1 X2 X3 X4 X5 X7 X8 X9 X10 X11) (gterm#map/objequal Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y8 Y9 Y10 Y11) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#map-deterministic X4 Y4 gterm#eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- gterm#count-deterministic X7 Y7 ENV
    <- nat`times-deterministic X8 Y8 nat`eq/ EN2 ETN
    <- nat`plus-deterministic X9 Y9 nat`eq/ ETN EPN
    <- nat`plus-deterministic X10 Y10 nat`eq/ ENV ENA
    <- nat`plus-deterministic X11 Y11 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/exists* X0 X1 X2 X3 X4 X8 X9 X10 X11 X12 X13 X14) (gterm#map/exists* Y0 Y1 Y2 Y3 Y4 Y8 Y9 Y10 Y11 Y12 Y13 Y14) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- vark#map-deterministic X1 Y1 vark#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#count-total Cgterm
    <- gterm#map-add-gterm-level ([x0:gterm A0] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (X4 x0 v0 x0nl)))) ([x0:gterm A0] ([v0:gterm#var x0] gterm#split/here)) Cgterm ([x0:gterm A0] ([v0:gterm#var x0] ([x0l:gterm#level x0 _] (X4' x0 v0 x0l))))
    <- gterm#map-add-gterm-level ([x0:gterm A0] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (Y4 x0 v0 x0nl)))) ([x0:gterm A0] ([v0:gterm#var x0] gterm#split/here)) Cgterm ([x0:gterm A0] ([v0:gterm#var x0] ([x0l:gterm#level x0 _] (Y4' x0 v0 x0l))))
    <- ({x0:gterm A0} ({v0:gterm#var x0} ({x0l:gterm#level x0 _} (gterm#map-deterministic (X4' x0 v0 x0l) (Y4' x0 v0 x0l) gterm#eq/ ENA1))))
    <- nat`times-deterministic X8 Y8 nat`eq/ ENA1 ENT1
    <- nat`plus-deterministic X9 Y9 EN1 ENT1 EN2
    <- gterm#count-deterministic X10 Y10 ENV
    <- nat`times-deterministic X11 Y11 nat`eq/ EN2 ETN
    <- nat`plus-deterministic X12 Y12 nat`eq/ ETN EPN
    <- nat`plus-deterministic X13 Y13 nat`eq/ ENV ENA
    <- nat`plus-deterministic X14 Y14 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/nested X0 X1 X2 X3 X4 X5 X7 X8 X10 X11 X12 X13 X14) (gterm#map/nested Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y8 Y10 Y11 Y12 Y13 Y14) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- gterm#map-deterministic X4 Y4 gterm#eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- nat-eq-nop X7 Y7 nat`eq/ ENA2
    <- natpair`pair-preserves-eq EN2 ENA2 EP8
    <- natpair`pair2nat-deterministic X8 Y8 EP8 EN3
    <- gterm#count-deterministic X10 Y10 ENV
    <- nat`times-deterministic X11 Y11 nat`eq/ EN3 ETN
    <- nat`plus-deterministic X12 Y12 nat`eq/ ETN EPN
    <- nat`plus-deterministic X13 Y13 nat`eq/ ENV ENA
    <- nat`plus-deterministic X14 Y14 EPN ENA EN.

- : gterm#map-deterministic (gterm#map/predcall* X0 X1 X2 X3 X4 X5 X7 X8 X10 X11 X12 X13 X14) (gterm#map/predcall* Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y8 Y10 Y11 Y12 Y13 Y14) gterm#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- predtype#map-deterministic X1 Y1 predtype#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- predicate#map-deterministic X4 Y4 predicate#eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- predargs#map-deterministic X7 Y7 predargs#eq/ ENA2
    <- natpair`pair-preserves-eq EN2 ENA2 EP8
    <- natpair`pair2nat-deterministic X8 Y8 EP8 EN3
    <- gterm#count-deterministic X10 Y10 ENV
    <- nat`times-deterministic X11 Y11 nat`eq/ EN3 ETN
    <- nat`plus-deterministic X12 Y12 nat`eq/ ETN EPN
    <- nat`plus-deterministic X13 Y13 nat`eq/ ENV ENA
    <- nat`plus-deterministic X14 Y14 EPN ENA EN.

- : predicate#map-deterministic (predicate#map/predicate/0 X0 X1 X2 X3 X4 X5 X6 X7 X8) (predicate#map/predicate/0 Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8) predicate#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- predicate#count-deterministic X4 Y4 ENV
    <- nat`times-deterministic X5 Y5 nat`eq/ EN1 ETN
    <- nat`plus-deterministic X6 Y6 nat`eq/ ETN EPN
    <- nat`plus-deterministic X7 Y7 nat`eq/ ENV ENA
    <- nat`plus-deterministic X8 Y8 EPN ENA EN.

- : predicate#map-deterministic (predicate#map/predicate/Y X0 X1 X5 X6 X7 X8 X9 X10 X11) (predicate#map/predicate/Y Y0 Y1 Y5 Y6 Y7 Y8 Y9 Y10 Y11) predicate#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- predicate#count-total Cpredicate
    <- predicate#map-add-predicate-level ([x0:predicate predtype/0] ([v0:predicate#var x0] ([x0nl:predicate#nolevel x0] (X1 x0 v0 x0nl)))) ([x0:predicate predtype/0] ([v0:predicate#var x0] predicate#split/here)) Cpredicate ([x0:predicate predtype/0] ([v0:predicate#var x0] ([x0l:predicate#level x0 _] (X1' x0 v0 x0l))))
    <- predicate#map-add-predicate-level ([x0:predicate predtype/0] ([v0:predicate#var x0] ([x0nl:predicate#nolevel x0] (Y1 x0 v0 x0nl)))) ([x0:predicate predtype/0] ([v0:predicate#var x0] predicate#split/here)) Cpredicate ([x0:predicate predtype/0] ([v0:predicate#var x0] ([x0l:predicate#level x0 _] (Y1' x0 v0 x0l))))
    <- ({x0:predicate predtype/0} ({v0:predicate#var x0} ({x0l:predicate#level x0 _} (predicate#map-deterministic (X1' x0 v0 x0l) (Y1' x0 v0 x0l) predicate#eq/ ENA0))))
    <- nat`times-deterministic X5 Y5 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X6 Y6 EN0 ENT0 EN1
    <- predicate#count-deterministic X7 Y7 ENV
    <- nat`times-deterministic X8 Y8 nat`eq/ EN1 ETN
    <- nat`plus-deterministic X9 Y9 nat`eq/ ETN EPN
    <- nat`plus-deterministic X10 Y10 nat`eq/ ENV ENA
    <- nat`plus-deterministic X11 Y11 EPN ENA EN.

- : predicate#map-deterministic (predicate#map/predicate/+ X0 X1 X5 X6 X7 X8 X9 X10 X11) (predicate#map/predicate/+ Y0 Y1 Y5 Y6 Y7 Y8 Y9 Y10 Y11) predicate#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#count-total Cgterm
    <- predicate#map-add-gterm-level ([x0:gterm K#695] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (X1 x0 v0 x0nl)))) ([x0:gterm K#695] ([v0:gterm#var x0] gterm#split/here)) Cgterm ([x0:gterm K#695] ([v0:gterm#var x0] ([x0l:gterm#level x0 _] (X1' x0 v0 x0l))))
    <- predicate#map-add-gterm-level ([x0:gterm K#695] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (Y1 x0 v0 x0nl)))) ([x0:gterm K#695] ([v0:gterm#var x0] gterm#split/here)) Cgterm ([x0:gterm K#695] ([v0:gterm#var x0] ([x0l:gterm#level x0 _] (Y1' x0 v0 x0l))))
    <- ({x0:gterm K#695} ({v0:gterm#var x0} ({x0l:gterm#level x0 _} (predicate#map-deterministic (X1' x0 v0 x0l) (Y1' x0 v0 x0l) predicate#eq/ ENA0))))
    <- nat`times-deterministic X5 Y5 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X6 Y6 EN0 ENT0 EN1
    <- predicate#count-deterministic X7 Y7 ENV
    <- nat`times-deterministic X8 Y8 nat`eq/ EN1 ETN
    <- nat`plus-deterministic X9 Y9 nat`eq/ ETN EPN
    <- nat`plus-deterministic X10 Y10 nat`eq/ ENV ENA
    <- nat`plus-deterministic X11 Y11 EPN ENA EN.

- : predicate#map-deterministic (predicate#map/predicate/Y1 X0 X1 X5 X6 X7 X8 X9 X10 X11) (predicate#map/predicate/Y1 Y0 Y1 Y5 Y6 Y7 Y8 Y9 Y10 Y11) predicate#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- predicate#count-total Cpredicate
    <- predicate#map-add-predicate-level ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([x0nl:predicate#nolevel x0] (X1 x0 v0 x0nl)))) ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] predicate#split/here)) Cpredicate ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([x0l:predicate#level x0 _] (X1' x0 v0 x0l))))
    <- predicate#map-add-predicate-level ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([x0nl:predicate#nolevel x0] (Y1 x0 v0 x0nl)))) ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] predicate#split/here)) Cpredicate ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([x0l:predicate#level x0 _] (Y1' x0 v0 x0l))))
    <- ({x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)} ({v0:predicate#var x0} ({x0l:predicate#level x0 _} (predicate#map-deterministic (X1' x0 v0 x0l) (Y1' x0 v0 x0l) predicate#eq/ ENA0))))
    <- nat`times-deterministic X5 Y5 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X6 Y6 EN0 ENT0 EN1
    <- predicate#count-deterministic X7 Y7 ENV
    <- nat`times-deterministic X8 Y8 nat`eq/ EN1 ETN
    <- nat`plus-deterministic X9 Y9 nat`eq/ ETN EPN
    <- nat`plus-deterministic X10 Y10 nat`eq/ ENV ENA
    <- nat`plus-deterministic X11 Y11 EPN ENA EN.

- : predargs#map-deterministic (predargs#map/predargs/0* X0 X1 X2 X3 X4 X5 X6 X7 X8) (predargs#map/predargs/0* Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8) predargs#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- nat-eq-nop X1 Y1 nat`eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- nat-eq-nop X4 Y4 nat`eq/ ENV
    <- nat`times-deterministic X5 Y5 nat`eq/ EN1 ETN
    <- nat`plus-deterministic X6 Y6 nat`eq/ ETN EPN
    <- nat`plus-deterministic X7 Y7 nat`eq/ ENV ENA
    <- nat`plus-deterministic X8 Y8 EPN ENA EN.

- : predargs#map-deterministic (predargs#map/predargs/+ X0 X1 X2 X3 X4 X5 X7 X8 X9 X10 X11) (predargs#map/predargs/+ Y0 Y1 Y2 Y3 Y4 Y5 Y7 Y8 Y9 Y10 Y11) predargs#eq/ EN
    <- nat-eq-nop X0 Y0 nat`eq/ EN0
    <- gterm#map-deterministic X1 Y1 gterm#eq/ ENA0
    <- nat`times-deterministic X2 Y2 nat`eq/ ENA0 ENT0
    <- nat`plus-deterministic X3 Y3 EN0 ENT0 EN1
    <- predargs#map-deterministic X4 Y4 predargs#eq/ ENA1
    <- natpair`pair-preserves-eq EN1 ENA1 EP5
    <- natpair`pair2nat-deterministic X5 Y5 EP5 EN2
    <- nat-eq-nop X7 Y7 nat`eq/ ENV
    <- nat`times-deterministic X8 Y8 nat`eq/ EN2 ETN
    <- nat`plus-deterministic X9 Y9 nat`eq/ ETN EPN
    <- nat`plus-deterministic X10 Y10 nat`eq/ ENV ENA
    <- nat`plus-deterministic X11 Y11 EPN ENA EN.


%worlds (block#gterm#var | block#gterm#level | block#predicate#var | block#predicate#level) (gterm#map-deterministic* T1 _ _ _ _ _) (predicate#map-deterministic* T1 _ _ _ _ _) (predargs#map-deterministic* T1 _ _ _ _ _).
%total (T1#903 T1#906 T1#908 ) (gterm#map-deterministic* T1#903 _ _ _ _ _) (predicate#map-deterministic* T1#906 _ _ _ _ _) (predargs#map-deterministic* T1#908 _ _ _ _ _).




%%%  Helper Lemma for 'onto' for mapping


%theorem gterm#var-implies-nolevel:
	forall*
		{K:vark}
		{T:gterm K}
	forall
		{V:gterm#var T}
	exists
		{NL:gterm#nolevel T}
	true.

%theorem gterm#var-implies-nolevel/L:
	forall*
		{K:vark}
		{T:gterm K}
	forall
		{V:gterm#var T}
		{C:gterm#case T}
	exists
		{NL:gterm#nolevel T}
	true.

%theorem predicate#var-implies-nolevel:
	forall*
		{K:predtype}
		{T:predicate K}
	forall
		{V:predicate#var T}
	exists
		{NL:predicate#nolevel T}
	true.

%theorem predicate#var-implies-nolevel/L:
	forall*
		{K:predtype}
		{T:predicate K}
	forall
		{V:predicate#var T}
		{C:predicate#case T}
	exists
		{NL:predicate#nolevel T}
	true.



%% Cases


- : gterm#var-implies-nolevel/L V (gterm#case/#nolevel NL) NL.

- : gterm#var-implies-nolevel V NL
    <- gterm#case-total _ C
    <- gterm#var-implies-nolevel/L V C NL.



- : predicate#var-implies-nolevel/L V (predicate#case/#nolevel NL) NL.

- : predicate#var-implies-nolevel V NL
    <- predicate#case-total _ C
    <- predicate#var-implies-nolevel/L V C NL.



%worlds (block#gterm#case/nolevel | block#predicate#case/nolevel) (gterm#var-implies-nolevel/L V _ _) (gterm#var-implies-nolevel V _) (predicate#var-implies-nolevel/L V _ _) (predicate#var-implies-nolevel V _).
%total (V#923 V#924 V#959 V#960 ) (gterm#var-implies-nolevel/L V#923 _ _) (gterm#var-implies-nolevel V#924 _) (predicate#var-implies-nolevel/L V#959 _ _) (predicate#var-implies-nolevel V#960 _).



%%% Theorems about maping onto small constants with variables


%theorem gterm#map-onto/0/gterm/termk/formulak:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{N:nat}
	forall
		{C:gterm#count (termk formulak) Hgterm N}
	exists
		{T:gterm (termk formulak)}
		{M:gterm#map (termk formulak) Hgterm Hpredicate T 0}
	true.

%theorem predicate#map-onto/0:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{N:nat}
	forall
		{K:predtype}
		{C:predicate#count K Hpredicate N}
	exists
		{T:predicate K}
		{M:predicate#map K Hgterm Hpredicate T 0}
	true.

%theorem gterm#map-onto/0:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{N:nat}
	forall
		{K:vark}
		{C:gterm#count K Hgterm N}
	exists
		{T:gterm K}
		{M:gterm#map K Hgterm Hpredicate T 0}
	true.

%theorem gterm#map-onto/0/gterm/objectk:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{N:nat}
	forall
		{C:gterm#count objectk Hgterm N}
	exists
		{T:gterm objectk}
		{M:gterm#map objectk Hgterm Hpredicate T 0}
	true.

%theorem gterm#map-onto/0/gterm/fractionk:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{N:nat}
	forall
		{C:gterm#count fractionk Hgterm N}
	exists
		{T:gterm fractionk}
		{M:gterm#map fractionk Hgterm Hpredicate T 0}
	true.

%theorem gterm#map-onto/0/gterm/termk/permissionk:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{N:nat}
	forall
		{C:gterm#count (termk permissionk) Hgterm N}
	exists
		{T:gterm (termk permissionk)}
		{M:gterm#map (termk permissionk) Hgterm Hpredicate T 0}
	true.

%theorem gterm#map-onto/0/gterm/termk/upermk:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{N:nat}
	forall
		{C:gterm#count (termk upermk) Hgterm N}
	exists
		{T:gterm (termk upermk)}
		{M:gterm#map (termk upermk) Hgterm Hpredicate T 0}
	true.

%theorem predargs#map-onto/0:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{K:predtype}
	exists
		{T:predargs K}
		{M:predargs#map K Hgterm Hpredicate T 0}
	true.

%theorem predargs#map-onto/1:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{K:predtype}
	exists
		{T:predargs K}
		{M:predargs#map K Hgterm Hpredicate T 1}
	true.



%% Cases

- : gterm#map-onto/0/gterm/termk/formulak C _ (gterm#map/t nat`eq/ C nat`eq/ 0+0=0 0+0=0).

- : predicate#map-onto/0 _ C _ (predicate#map/predicate/0 nat`eq/ M1 1*0=0 0+0=0 C 2*0=0 0+0=0 0+0=0 0+0=0)
    <- gterm#count-total C1
    <- gterm#map-onto/0/gterm/termk/formulak C1 _ M1.

- : predicate#map-onto/0 _ C _ (predicate#map/predicate/+ nat`eq/ ([x0:gterm K#695] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (FM1 x0 v0 x0nl)))) 1*0=0 0+0=0 C 2*0=0 0+0=0 0+0=0 0+0=0)
    <- predicate#count-total C1
    <- ({x0:gterm K#695} ({v0:gterm#var x0} ({x0nl:gterm#nolevel x0} (gterm#case-total x0 (gterm#case/#nolevel x0nl) -> predicate#map-onto/0 N#695 C1 _ (FM1 x0 v0 x0nl))))).

- : gterm#map-onto/0/gterm/objectk C _ (gterm#map/object/ nat`eq/ nat`eq/ 1*0=0 0+0=0 C 1*0=0 0+0=0 0+0=0 0+0=0).

- : gterm#map-onto/0 objectk C _ N
    <- gterm#map-onto/0/gterm/objectk C _ N.

- : gterm#map-onto/0/gterm/fractionk C _ (gterm#map/fraction/ nat`eq/ M1 1*0=0 0+0=0 C 1*0=0 0+0=0 0+0=0 0+0=0)
    <- rat#map-onto/0/rat _ M1.

- : gterm#map-onto/0 fractionk C _ N
    <- gterm#map-onto/0/gterm/fractionk C _ N.

- : gterm#map-onto/0/gterm/termk/permissionk C _ (gterm#map/empty nat`eq/ C nat`eq/ 0+0=0 0+0=0).

- : gterm#map-onto/0 (termk permissionk) C _ N
    <- gterm#map-onto/0/gterm/termk/permissionk C _ N.

- : gterm#map-onto/0/gterm/termk/upermk C _ (gterm#map/nonlinear nat`eq/ M1 1*0=0 0+0=0 C 5*0=0 0+0=0 0+0=0 0+0=0)
    <- gterm#count-total C1
    <- gterm#map-onto/0/gterm/termk/formulak C1 _ M1.

- : gterm#map-onto/0 (termk upermk) C _ N
    <- gterm#map-onto/0/gterm/termk/upermk C _ N.

- : gterm#map-onto/0 (termk formulak) C _ N
    <- gterm#map-onto/0/gterm/termk/formulak C _ N.

- : predargs#map-onto/0 _ _ (predargs#map/predargs/0* nat`eq/ nat`eq/ 1*0=0 0+0=0 nat`eq/ 1*0=0 0+0=0 0+0=0 0+0=0).

- : predargs#map-onto/0 _ _ (predargs#map/predargs/+ nat`eq/ M1 1*0=0 0+0=0 M4 0$0=0 nat`eq/ 1*0=0 0+0=0 0+0=0 0+0=0)
    <- gterm#count-total C1
    <- gterm#map-onto/0 K#810 C1 _ M1
    <- predargs#map-onto/0 N#810 _ M4.

- : predargs#map-onto/1 _ _ (predargs#map/predargs/0* nat`eq/ nat`eq/ 1*1=1 0+1=1 nat`eq/ 1*1=1 0+1=1 0+0=0 1+0=1).

- : predargs#map-onto/1 _ _ (predargs#map/predargs/+ nat`eq/ M1 1*0=0 0+0=0 M4 0$1=1 nat`eq/ 1*1=1 0+1=1 0+0=0 1+0=1)
    <- gterm#count-total C1
    <- gterm#map-onto/0 K#810 C1 _ M1
    <- predargs#map-onto/1 N#810 _ M4.


- : gterm#map-onto/0/gterm/termk/formulak  C _ (gterm#map/#nolevel NL S C')
    <- succ-implies-gt-zero _ GT0
    <- plus-left-preserves-gt* GT0 0+N=N 0+0=0 GT
    <- gterm#lookup-onto C GT _ V _ _ S C'
    <- gterm#var-implies-nolevel V NL.


%worlds (block#gterm#case/nolevel | block#predicate#case/nolevel) (gterm#map-onto/0/gterm/termk/formulak C _ _).

%total (C#1145 ) (gterm#map-onto/0/gterm/termk/formulak C#1145 _ _).


- : predicate#map-onto/0 _ C _ (predicate#map/#nolevel NL S C')
    <- succ-implies-gt-zero _ GT0
    <- plus-left-preserves-gt* GT0 0+N=N 0+0=0 GT
    <- predicate#lookup-onto C GT _ V _ _ S C'
    <- predicate#var-implies-nolevel V NL.


%worlds (block#gterm#case/nolevel | block#predicate#case/nolevel) (predicate#map-onto/0 K _ _ _).

%total (K#1301 ) (predicate#map-onto/0 K#1301 _ _ _).


- : gterm#map-onto/0/gterm/objectk  C _ (gterm#map/#nolevel NL S C')
    <- succ-implies-gt-zero _ GT0
    <- plus-left-preserves-gt* GT0 0+N=N 0+0=0 GT
    <- gterm#lookup-onto C GT _ V _ _ S C'
    <- gterm#var-implies-nolevel V NL.


%worlds (block#gterm#case/nolevel | block#predicate#case/nolevel) (gterm#map-onto/0/gterm/objectk C _ _).

%total (C#1355 ) (gterm#map-onto/0/gterm/objectk C#1355 _ _).


- : gterm#map-onto/0/gterm/fractionk  C _ (gterm#map/#nolevel NL S C')
    <- succ-implies-gt-zero _ GT0
    <- plus-left-preserves-gt* GT0 0+N=N 0+0=0 GT
    <- gterm#lookup-onto C GT _ V _ _ S C'
    <- gterm#var-implies-nolevel V NL.


%worlds (block#gterm#case/nolevel | block#predicate#case/nolevel) (gterm#map-onto/0/gterm/fractionk C _ _).

%total (C#1357 ) (gterm#map-onto/0/gterm/fractionk C#1357 _ _).


- : gterm#map-onto/0/gterm/termk/permissionk  C _ (gterm#map/#nolevel NL S C')
    <- succ-implies-gt-zero _ GT0
    <- plus-left-preserves-gt* GT0 0+N=N 0+0=0 GT
    <- gterm#lookup-onto C GT _ V _ _ S C'
    <- gterm#var-implies-nolevel V NL.


%worlds (block#gterm#case/nolevel | block#predicate#case/nolevel) (gterm#map-onto/0/gterm/termk/permissionk C _ _).

%total (C#1359 ) (gterm#map-onto/0/gterm/termk/permissionk C#1359 _ _).


- : gterm#map-onto/0/gterm/termk/upermk  C _ (gterm#map/#nolevel NL S C')
    <- succ-implies-gt-zero _ GT0
    <- plus-left-preserves-gt* GT0 0+N=N 0+0=0 GT
    <- gterm#lookup-onto C GT _ V _ _ S C'
    <- gterm#var-implies-nolevel V NL.


%worlds (block#gterm#case/nolevel | block#predicate#case/nolevel) (gterm#map-onto/0/gterm/termk/upermk C _ _).

%total (C#1361 ) (gterm#map-onto/0/gterm/termk/upermk C#1361 _ _).

%worlds (block#gterm#case/nolevel | block#predicate#case/nolevel) (gterm#map-onto/0 _ _ _ _).

%total { } (gterm#map-onto/0 _ _ _ _).

%worlds (block#gterm#case/nolevel | block#predicate#case/nolevel) (predargs#map-onto/0 K _ _).

%total (K#1402 ) (predargs#map-onto/0 K#1402 _ _).

%worlds (block#gterm#case/nolevel | block#predicate#case/nolevel) (predargs#map-onto/1 K _ _).

%total (K#1443 ) (predargs#map-onto/1 K#1443 _ _).








%%%  Theorems about 'onto' for mapping


%theorem gterm/objectk#map-onto/L:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{VC:nat}
	forall
		{N:nat}
		{HC:gterm#count objectk Hgterm VC}
		{CL:classify# VC 0 1 N}
	exists
		{T:gterm objectk}
		{M:gterm#map objectk Hgterm Hpredicate T N}
	true.

%theorem gterm/fractionk#map-onto/L:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{VC:nat}
	forall
		{N:nat}
		{HC:gterm#count fractionk Hgterm VC}
		{CL:classify# VC 0 1 N}
	exists
		{T:gterm fractionk}
		{M:gterm#map fractionk Hgterm Hpredicate T N}
	true.

%theorem gterm/termk/permissionk#map-onto/L:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{VC:nat}
	forall
		{N:nat}
		{HC:gterm#count (termk permissionk) Hgterm VC}
		{CL:classify# VC 1 3 N}
	exists
		{T:gterm (termk permissionk)}
		{M:gterm#map (termk permissionk) Hgterm Hpredicate T N}
	true.

%theorem gterm/termk/upermk#map-onto/L:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{VC:nat}
	forall
		{N:nat}
		{HC:gterm#count (termk upermk) Hgterm VC}
		{CL:classify# VC 0 5 N}
	exists
		{T:gterm (termk upermk)}
		{M:gterm#map (termk upermk) Hgterm Hpredicate T N}
	true.

%theorem gterm/termk/formulak#map-onto/L:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{VC:nat}
	forall
		{N:nat}
		{HC:gterm#count (termk formulak) Hgterm VC}
		{CL:classify# VC 1 6 N}
	exists
		{T:gterm (termk formulak)}
		{M:gterm#map (termk formulak) Hgterm Hpredicate T N}
	true.

%theorem gterm#map-onto:
	forall*
		{K:vark}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{N:nat}
	exists
		{T:gterm K}
		{M:gterm#map K Hgterm Hpredicate T N}
	true.

%theorem predicate/predtype/0#map-onto/L:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{VC:nat}
	forall
		{N:nat}
		{HC:predicate#count predtype/0 Hpredicate VC}
		{CL:classify# VC 0 2 N}
	exists
		{T:predicate predtype/0}
		{M:predicate#map predtype/0 Hgterm Hpredicate T N}
	true.

%theorem predicate/predtype/+#map-onto/L:
	forall*
		{Vpredtype/+:vark}
		{Wpredtype/+:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{VC:nat}
	forall
		{N:nat}
		{HC:predicate#count (predtype/+ Vpredtype/+ Wpredtype/+) Hpredicate VC}
		{CL:classify# VC 0 2 N}
	exists
		{T:predicate (predtype/+ Vpredtype/+ Wpredtype/+)}
		{M:predicate#map (predtype/+ Vpredtype/+ Wpredtype/+) Hgterm Hpredicate T N}
	true.

%theorem predicate#map-onto:
	forall*
		{K:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{N:nat}
	exists
		{T:predicate K}
		{M:predicate#map K Hgterm Hpredicate T N}
	true.

%theorem predargs/predtype/0#map-onto/L:
	forall*
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{N:nat}
		{CL:classify# z 0 1 N}
	exists
		{T:predargs predtype/0}
		{M:predargs#map predtype/0 Hgterm Hpredicate T N}
	true.

%theorem predargs/predtype/+#map-onto/L:
	forall*
		{Vpredtype/+:vark}
		{Wpredtype/+:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{N:nat}
		{CL:classify# z 0 1 N}
	exists
		{T:predargs (predtype/+ Vpredtype/+ Wpredtype/+)}
		{M:predargs#map (predtype/+ Vpredtype/+ Wpredtype/+) Hgterm Hpredicate T N}
	true.

%theorem predargs#map-onto:
	forall*
		{K:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
	forall
		{N:nat}
	exists
		{T:predargs K}
		{M:predargs#map K Hgterm Hpredicate T N}
	true.



%% Cases

- : gterm#map-onto N T M
    <- gterm#count-total C
    <- classify#-total CL
    <- gterm/objectk#map-onto/L N C CL T M.

- : gterm#map-onto N T M
    <- gterm#count-total C
    <- classify#-total CL
    <- gterm/fractionk#map-onto/L N C CL T M.

- : gterm#map-onto N T M
    <- gterm#count-total C
    <- classify#-total CL
    <- gterm/termk/permissionk#map-onto/L N C CL T M.

- : gterm#map-onto N T M
    <- gterm#count-total C
    <- classify#-total CL
    <- gterm/termk/upermk#map-onto/L N C CL T M.

- : gterm#map-onto N T M
    <- gterm#count-total C
    <- classify#-total CL
    <- gterm/termk/formulak#map-onto/L N C CL T M.

- : predicate#map-onto N T M
    <- predicate#count-total C
    <- classify#-total CL
    <- predicate/predtype/0#map-onto/L N C CL T M.

- : predicate#map-onto N T M
    <- predicate#count-total C
    <- classify#-total CL
    <- predicate/predtype/+#map-onto/L N C CL T M.

- : predargs#map-onto N T M
    <- classify#-total CL
    <- predargs/predtype/0#map-onto/L N CL T M.

- : predargs#map-onto N T M
    <- classify#-total CL
    <- predargs/predtype/+#map-onto/L N CL T M.

- : gterm/objectk#map-onto/L _ C (classify#/low G) _ (gterm#map/#nolevel NL S C')
    <- gterm#lookup-onto C G _ V _ _ S C'
    <- gterm#var-implies-nolevel V NL.

- : gterm/objectk#map-onto/L _ C (classify#/high plus/z plus/z times/z plus/z 1>0) _ (gterm#map/object/ nat`eq/ nat`eq/ 1*0=0 0+0=0 C 1*0=0 0+0=0 0+0=0 0+0=0).

- : gterm/objectk#map-onto/L _ C (classify#/high 0+0=0 0+1=1 1*1=1 1+0=1 1>0) _ (gterm#map/object/ nat`eq/ nat`eq/ 1*1=1 0+1=1 C 1*1=1 0+1=1 0+0=0 1+0=1).

- : gterm/objectk#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 1>0) _ (gterm#map/object/ nat`eq/ nat`eq/ (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 1>0 DR4
    <- plus-implies-ge Sub GE4
    <- meta-ge _ _ GE4
    <- quotient-is-no-greater DR4 G4
    <- meta-ge _ _ G4.

- : gterm/objectk#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 1>0) _ (gterm#map/object/ nat`eq/ nat`eq/ (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 1>0 DR4
    <- plus-implies-gt Sub nat`eq/ G4
    <- meta-gt _ _ G4
    <- quotient-is-no-greater DR4 GE4
    <- meta-ge _ _ GE4.

- : gterm/fractionk#map-onto/L _ C (classify#/low G) _ (gterm#map/#nolevel NL S C')
    <- gterm#lookup-onto C G _ V _ _ S C'
    <- gterm#var-implies-nolevel V NL.

- : gterm/fractionk#map-onto/L _ C (classify#/high plus/z plus/z times/z plus/z 1>0) _ (gterm#map/fraction/ nat`eq/ M1 1*0=0 0+0=0 C 1*0=0 0+0=0 0+0=0 0+0=0)
    <- rat#map-onto/0/rat _ M1.

- : gterm/fractionk#map-onto/L _ C (classify#/high 0+0=0 0+1=1 1*1=1 1+0=1 1>0) _ (gterm#map/fraction/ nat`eq/ M1 1*1=1 0+1=1 C 1*1=1 0+1=1 0+0=0 1+0=1)
    <- rat#map-onto/1/rat _ M1.

- : gterm/fractionk#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 1>0) _ (gterm#map/fraction/ nat`eq/ M1 (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 1>0 DR4
    <- plus-implies-ge Sub GE4
    <- meta-ge _ _ GE4
    <- quotient-is-no-greater DR4 G4
    <- meta-ge _ _ G4
    <- rat#map-onto _ _ M1.

- : gterm/fractionk#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 1>0) _ (gterm#map/fraction/ nat`eq/ M1 (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 1>0 DR4
    <- plus-implies-gt Sub nat`eq/ G4
    <- meta-gt _ _ G4
    <- quotient-is-no-greater DR4 GE4
    <- meta-ge _ _ GE4
    <- rat#map-onto _ _ M1.

- : gterm/termk/permissionk#map-onto/L _ C (classify#/low G) _ (gterm#map/#nolevel NL S C')
    <- gterm#lookup-onto C G _ V _ _ S C'
    <- gterm#var-implies-nolevel V NL.

- : gterm/termk/permissionk#map-onto/L _ C (classify#/mid 0+N=N 1>0) _ (gterm#map/empty nat`eq/ C nat`eq/ 0+N=N 0+N=N).

- : gterm/termk/permissionk#map-onto/L _ C (classify#/high 1+N=sN Sub T Pmod 3>0) _ (gterm#map/scale nat`eq/ M1 (times/s times/z plus/z) plus/z M4 NP5 C T'6 P'6 1+N=sN S'6)
    <- plus-commutative Sub S'6
    <- times-commutative T T'6
    <- plus-commutative Pmod P'6
    <- divrem-can-be-constructed T Pmod 3>0 DR6
    <- plus-right-preserves-gt* 1>0 1+N=sN plus/z GA6
    <- gt-implies-positive GA6 _ EN6
    <- plus-implies-gt Sub EN6 G6
    <- meta-gt _ _ G6
    <- quotient-is-no-greater DR6 GE6
    <- meta-ge _ _ GE6
    <- nat2pair-total NP5
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- gterm#map-onto _ _ M1
    <- gterm#map-onto _ _ M4.

- : gterm/termk/permissionk#map-onto/L _ C (classify#/high 1+N=sN Sub T Pmod 3>1) _ (gterm#map/combine nat`eq/ M1 (times/s times/z plus/z) plus/z M4 NP5 C T'6 P'6 1+N=sN S'6)
    <- plus-commutative Sub S'6
    <- times-commutative T T'6
    <- plus-commutative Pmod P'6
    <- divrem-can-be-constructed T Pmod 3>1 DR6
    <- plus-implies-ge Sub GE6
    <- meta-ge _ _ GE6
    <- remainder-implies-gt-quotient DR6 G6
    <- meta-gt _ _ G6
    <- nat2pair-total NP5
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- gterm#map-onto _ _ M1
    <- gterm#map-onto _ _ M4.

- : gterm/termk/permissionk#map-onto/L _ C (classify#/high 1+N=sN Sub T Pmod 3>2) _ (gterm#map/unitperm nat`eq/ M1 (times/s times/z plus/z) plus/z C T'4 P'4 1+N=sN S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 3>2 DR4
    <- plus-implies-ge Sub GE4
    <- meta-ge _ _ GE4
    <- remainder-implies-gt-quotient DR4 G4
    <- meta-gt _ _ G4
    <- gterm#map-onto _ _ M1.

- : gterm/termk/upermk#map-onto/L _ C (classify#/low G) _ (gterm#map/#nolevel NL S C')
    <- gterm#lookup-onto C G _ V _ _ S C'
    <- gterm#var-implies-nolevel V NL.

- : gterm/termk/upermk#map-onto/L _ C (classify#/high plus/z plus/z times/z plus/z 5>0) _ (gterm#map/nonlinear nat`eq/ M1 1*0=0 0+0=0 C 5*0=0 0+0=0 0+0=0 0+0=0)
    <- gterm#count-total C1
    <- gterm#map-onto/0/gterm/termk/formulak C1 _ M1.

- : gterm/termk/upermk#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 5>0) _ (gterm#map/nonlinear nat`eq/ M1 (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 5>0 DR4
    <- plus-implies-ge Sub GE4
    <- meta-ge _ _ GE4
    <- quotient-of-nonzero-is-smaller DR4 nat`eq/ G4
    <- meta-gt _ _ G4
    <- gterm#map-onto _ _ M1.

- : gterm/termk/upermk#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 5>0) _ (gterm#map/nonlinear nat`eq/ M1 (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 5>0 DR4
    <- plus-implies-gt Sub nat`eq/ G4
    <- meta-gt _ _ G4
    <- quotient-is-no-greater DR4 GE4
    <- meta-ge _ _ GE4
    <- gterm#map-onto _ _ M1.

- : gterm/termk/upermk#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 5>1) _ (gterm#map/conditional nat`eq/ M1 (times/s times/z plus/z) plus/z M4 NP5 M6 NP7 C T'8 P'8 0+N=N S'8)
    <- plus-commutative Sub S'8
    <- times-commutative T T'8
    <- plus-commutative Pmod P'8
    <- divrem-can-be-constructed T Pmod 5>1 DR8
    <- plus-implies-ge Sub GE8
    <- meta-ge _ _ GE8
    <- remainder-implies-gt-quotient DR8 G8
    <- meta-gt _ _ G8
    <- nat2pair-total NP7
    <- nat2pair-implies-ge NP7 GE7 GEP7
    <- meta-ge _ _ GE7
    <- meta-ge _ _ GEP7
    <- nat2pair-total NP5
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- gterm#map-onto _ _ M1
    <- gterm#map-onto _ _ M4
    <- gterm#map-onto _ _ M6.

- : gterm/termk/upermk#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 5>2) _ (gterm#map/encumbered nat`eq/ M1 (times/s times/z plus/z) plus/z M4 NP5 C T'6 P'6 0+N=N S'6)
    <- plus-commutative Sub S'6
    <- times-commutative T T'6
    <- plus-commutative Pmod P'6
    <- divrem-can-be-constructed T Pmod 5>2 DR6
    <- plus-implies-ge Sub GE6
    <- meta-ge _ _ GE6
    <- remainder-implies-gt-quotient DR6 G6
    <- meta-gt _ _ G6
    <- nat2pair-total NP5
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- gterm#map-onto _ _ M1
    <- gterm#map-onto _ _ M4.

- : gterm/termk/upermk#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 5>3) _ (gterm#map/precise-exists nat`eq/ M1 (times/s times/z plus/z) plus/z nat`eq/ NP5 ([x0:gterm objectk] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (M6 x0 v0 x0nl)))) NP7 C T'8 P'8 0+N=N S'8)
    <- plus-commutative Sub S'8
    <- times-commutative T T'8
    <- plus-commutative Pmod P'8
    <- divrem-can-be-constructed T Pmod 5>3 DR8
    <- plus-implies-ge Sub GE8
    <- meta-ge _ _ GE8
    <- remainder-implies-gt-quotient DR8 G8
    <- meta-gt _ _ G8
    <- nat2pair-total NP7
    <- nat2pair-implies-ge NP7 GE7 GEP7
    <- meta-ge _ _ GE7
    <- meta-ge _ _ GEP7
    <- nat2pair-total NP5
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- gterm#map-onto _ _ M1
    <- ({x0:gterm objectk} ({v0:gterm#var x0} ({x0nl:gterm#nolevel x0} (gterm#case-total x0 (gterm#case/#nolevel x0nl) -> gterm#map-onto _ _ (M6 x0 v0 x0nl))))).

- : gterm/termk/upermk#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 5>4) _ (gterm#map/basic nat`eq/ M1 (times/s times/z plus/z) plus/z nat`eq/ NP5 M6 NP7 C T'8 P'8 0+N=N S'8)
    <- plus-commutative Sub S'8
    <- times-commutative T T'8
    <- plus-commutative Pmod P'8
    <- divrem-can-be-constructed T Pmod 5>4 DR8
    <- plus-implies-ge Sub GE8
    <- meta-ge _ _ GE8
    <- remainder-implies-gt-quotient DR8 G8
    <- meta-gt _ _ G8
    <- nat2pair-total NP7
    <- nat2pair-implies-ge NP7 GE7 GEP7
    <- meta-ge _ _ GE7
    <- meta-ge _ _ GEP7
    <- nat2pair-total NP5
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- gterm#map-onto _ _ M1
    <- gterm#map-onto _ _ M6.

- : gterm/termk/formulak#map-onto/L _ C (classify#/low G) _ (gterm#map/#nolevel NL S C')
    <- gterm#lookup-onto C G _ V _ _ S C'
    <- gterm#var-implies-nolevel V NL.

- : gterm/termk/formulak#map-onto/L _ C (classify#/mid 0+N=N 1>0) _ (gterm#map/t nat`eq/ C nat`eq/ 0+N=N 0+N=N).

- : gterm/termk/formulak#map-onto/L _ C (classify#/high 1+N=sN Sub T Pmod 6>0) _ (gterm#map/neg nat`eq/ M1 (times/s times/z plus/z) plus/z C T'4 P'4 1+N=sN S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 6>0 DR4
    <- plus-right-preserves-gt* 1>0 1+N=sN plus/z GA4
    <- gt-implies-positive GA4 _ EN4
    <- plus-implies-gt Sub EN4 G4
    <- meta-gt _ _ G4
    <- quotient-is-no-greater DR4 GE4
    <- meta-ge _ _ GE4
    <- gterm#map-onto _ _ M1.

- : gterm/termk/formulak#map-onto/L _ C (classify#/high 1+N=sN Sub T Pmod 6>1) _ (gterm#map/conj nat`eq/ M1 (times/s times/z plus/z) plus/z M4 NP5 C T'6 P'6 1+N=sN S'6)
    <- plus-commutative Sub S'6
    <- times-commutative T T'6
    <- plus-commutative Pmod P'6
    <- divrem-can-be-constructed T Pmod 6>1 DR6
    <- plus-implies-ge Sub GE6
    <- meta-ge _ _ GE6
    <- remainder-implies-gt-quotient DR6 G6
    <- meta-gt _ _ G6
    <- nat2pair-total NP5
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- gterm#map-onto _ _ M1
    <- gterm#map-onto _ _ M4.

- : gterm/termk/formulak#map-onto/L _ C (classify#/high 1+N=sN Sub T Pmod 6>2) _ (gterm#map/objequal nat`eq/ M1 (times/s times/z plus/z) plus/z M4 NP5 C T'6 P'6 1+N=sN S'6)
    <- plus-commutative Sub S'6
    <- times-commutative T T'6
    <- plus-commutative Pmod P'6
    <- divrem-can-be-constructed T Pmod 6>2 DR6
    <- plus-implies-ge Sub GE6
    <- meta-ge _ _ GE6
    <- remainder-implies-gt-quotient DR6 G6
    <- meta-gt _ _ G6
    <- nat2pair-total NP5
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- gterm#map-onto _ _ M1
    <- gterm#map-onto _ _ M4.

- : gterm/termk/formulak#map-onto/L _ C (classify#/high 1+N=sN Sub T Pmod 6>3) _ (gterm#map/exists* nat`eq/ M1 (times/s times/z plus/z) plus/z ([x0:gterm A0] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (M4 x0 v0 x0nl)))) T5 P5 C T'7 P'7 1+N=sN S'7)
    <- plus-commutative Sub S'7
    <- times-commutative T T'7
    <- plus-commutative Pmod P'7
    <- divrem-can-be-constructed T Pmod 6>3 DR7
    <- plus-implies-ge Sub GE7
    <- meta-ge _ _ GE7
    <- remainder-implies-gt-quotient DR7 G7
    <- meta-gt _ _ G7
    <- divrem-total DR5
    <- divrem-can-be-inverted DR5 _ T'5 P'5
    <- divrem-implies-gt DR5 G5
    <- times-commutative T'5 T5
    <- plus-commutative P'5 P5
    <- quotient-is-no-greater DR5 GE5
    <- meta-ge _ _ GE5
    <- plus-implies-ge P'5 GE'5
    <- meta-ge _ _ GE'5
    <- vark#map-onto _ G5 _ M1
    <- ({x0:gterm A0} ({v0:gterm#var x0} ({x0nl:gterm#nolevel x0} (gterm#case-total x0 (gterm#case/#nolevel x0nl) -> gterm#map-onto _ _ (M4 x0 v0 x0nl))))).

- : gterm/termk/formulak#map-onto/L _ C (classify#/high 1+N=sN Sub T Pmod 6>4) _ (gterm#map/nested nat`eq/ M1 (times/s times/z plus/z) plus/z M4 NP5 nat`eq/ NP7 C T'8 P'8 1+N=sN S'8)
    <- plus-commutative Sub S'8
    <- times-commutative T T'8
    <- plus-commutative Pmod P'8
    <- divrem-can-be-constructed T Pmod 6>4 DR8
    <- plus-implies-ge Sub GE8
    <- meta-ge _ _ GE8
    <- remainder-implies-gt-quotient DR8 G8
    <- meta-gt _ _ G8
    <- nat2pair-total NP7
    <- nat2pair-implies-ge NP7 GE7 GEP7
    <- meta-ge _ _ GE7
    <- meta-ge _ _ GEP7
    <- nat2pair-total NP5
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- gterm#map-onto _ _ M1
    <- gterm#map-onto _ _ M4.

- : gterm/termk/formulak#map-onto/L _ C (classify#/high 1+N=sN Sub T Pmod 6>5) _ (gterm#map/predcall* nat`eq/ M1 (times/s times/z plus/z) plus/z M4 NP5 M6 NP7 C T'8 P'8 1+N=sN S'8)
    <- plus-commutative Sub S'8
    <- times-commutative T T'8
    <- plus-commutative Pmod P'8
    <- divrem-can-be-constructed T Pmod 6>5 DR8
    <- plus-implies-ge Sub GE8
    <- meta-ge _ _ GE8
    <- remainder-implies-gt-quotient DR8 G8
    <- meta-gt _ _ G8
    <- nat2pair-total NP7
    <- nat2pair-implies-ge NP7 GE7 GEP7
    <- meta-ge _ _ GE7
    <- meta-ge _ _ GEP7
    <- nat2pair-total NP5
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- predtype#map-onto _ _ M1
    <- predicate#map-onto _ _ M4
    <- predargs#map-onto _ _ M6.

- : predicate/predtype/0#map-onto/L _ C (classify#/low G) _ (predicate#map/#nolevel NL S C')
    <- predicate#lookup-onto C G _ V _ _ S C'
    <- predicate#var-implies-nolevel V NL.

- : predicate/predtype/0#map-onto/L _ C (classify#/high plus/z plus/z times/z plus/z 2>0) _ (predicate#map/predicate/0 nat`eq/ M1 1*0=0 0+0=0 C 2*0=0 0+0=0 0+0=0 0+0=0)
    <- gterm#count-total C1
    <- gterm#map-onto/0/gterm/termk/formulak C1 _ M1.

- : predicate/predtype/0#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 2>0) _ (predicate#map/predicate/0 nat`eq/ M1 (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 2>0 DR4
    <- plus-implies-ge Sub GE4
    <- meta-ge _ _ GE4
    <- quotient-of-nonzero-is-smaller DR4 nat`eq/ G4
    <- meta-gt _ _ G4
    <- gterm#map-onto _ _ M1.

- : predicate/predtype/0#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 2>0) _ (predicate#map/predicate/0 nat`eq/ M1 (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 2>0 DR4
    <- plus-implies-gt Sub nat`eq/ G4
    <- meta-gt _ _ G4
    <- quotient-is-no-greater DR4 GE4
    <- meta-ge _ _ GE4
    <- gterm#map-onto _ _ M1.

- : predicate/predtype/0#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 2>1) _ (predicate#map/predicate/Y nat`eq/ ([x0:predicate predtype/0] ([v0:predicate#var x0] ([x0nl:predicate#nolevel x0] (M1 x0 v0 x0nl)))) (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 2>1 DR4
    <- plus-implies-ge Sub GE4
    <- meta-ge _ _ GE4
    <- remainder-implies-gt-quotient DR4 G4
    <- meta-gt _ _ G4
    <- ({x0:predicate predtype/0} ({v0:predicate#var x0} ({x0nl:predicate#nolevel x0} (predicate#case-total x0 (predicate#case/#nolevel x0nl) -> predicate#map-onto _ _ (M1 x0 v0 x0nl))))).

- : predicate/predtype/+#map-onto/L _ C (classify#/low G) _ (predicate#map/#nolevel NL S C')
    <- predicate#lookup-onto C G _ V _ _ S C'
    <- predicate#var-implies-nolevel V NL.

- : predicate/predtype/+#map-onto/L _ C (classify#/high plus/z plus/z times/z plus/z 2>0) _ (predicate#map/predicate/+ nat`eq/ ([x0:gterm K#695] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (FM1 x0 v0 x0nl)))) 1*0=0 0+0=0 C 2*0=0 0+0=0 0+0=0 0+0=0)
    <- predicate#count-total C1
    <- ({x0:gterm K#695} ({v0:gterm#var x0} ({x0nl:gterm#nolevel x0} (gterm#case-total x0 (gterm#case/#nolevel x0nl) -> predicate#map-onto/0 N#695 C1 _ (FM1 x0 v0 x0nl))))).

- : predicate/predtype/+#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 2>0) _ (predicate#map/predicate/+ nat`eq/ ([x0:gterm K#695] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (M1 x0 v0 x0nl)))) (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 2>0 DR4
    <- plus-implies-ge Sub GE4
    <- meta-ge _ _ GE4
    <- quotient-of-nonzero-is-smaller DR4 nat`eq/ G4
    <- meta-gt _ _ G4
    <- ({x0:gterm K#695} ({v0:gterm#var x0} ({x0nl:gterm#nolevel x0} (gterm#case-total x0 (gterm#case/#nolevel x0nl) -> predicate#map-onto _ _ (M1 x0 v0 x0nl))))).

- : predicate/predtype/+#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 2>0) _ (predicate#map/predicate/+ nat`eq/ ([x0:gterm K#695] ([v0:gterm#var x0] ([x0nl:gterm#nolevel x0] (M1 x0 v0 x0nl)))) (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 2>0 DR4
    <- plus-implies-gt Sub nat`eq/ G4
    <- meta-gt _ _ G4
    <- quotient-is-no-greater DR4 GE4
    <- meta-ge _ _ GE4
    <- ({x0:gterm K#695} ({v0:gterm#var x0} ({x0nl:gterm#nolevel x0} (gterm#case-total x0 (gterm#case/#nolevel x0nl) -> predicate#map-onto _ _ (M1 x0 v0 x0nl))))).

- : predicate/predtype/+#map-onto/L _ C (classify#/high 0+N=N Sub T Pmod 2>1) _ (predicate#map/predicate/Y1 nat`eq/ ([x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)] ([v0:predicate#var x0] ([x0nl:predicate#nolevel x0] (M1 x0 v0 x0nl)))) (times/s times/z plus/z) plus/z C T'4 P'4 0+N=N S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 2>1 DR4
    <- plus-implies-ge Sub GE4
    <- meta-ge _ _ GE4
    <- remainder-implies-gt-quotient DR4 G4
    <- meta-gt _ _ G4
    <- ({x0:predicate (predtype/+ Vpredtype/+ Wpredtype/+)} ({v0:predicate#var x0} ({x0nl:predicate#nolevel x0} (predicate#case-total x0 (predicate#case/#nolevel x0nl) -> predicate#map-onto _ _ (M1 x0 v0 x0nl))))).

- : predargs/predtype/0#map-onto/L _ (classify#/low G) T M
    <- nat`gt-contradiction G F
    <- false-implies-predargs# F T
    <- false-implies-predargs#map F M.

- : predargs/predtype/0#map-onto/L _ (classify#/high plus/z plus/z times/z plus/z 1>0) _ (predargs#map/predargs/0* nat`eq/ nat`eq/ 1*0=0 0+0=0 nat`eq/ 1*0=0 0+0=0 0+0=0 0+0=0).

- : predargs/predtype/0#map-onto/L _ (classify#/high 0+0=0 0+1=1 1*1=1 1+0=1 1>0) _ (predargs#map/predargs/0* nat`eq/ nat`eq/ 1*1=1 0+1=1 nat`eq/ 1*1=1 0+1=1 0+0=0 1+0=1).

- : predargs/predtype/0#map-onto/L _ (classify#/high 0+0=0 Sub T Pmod 1>0) _ (predargs#map/predargs/0* nat`eq/ nat`eq/ (times/s times/z plus/z) plus/z nat`eq/ T'4 P'4 0+0=0 S'4)
    <- plus-commutative Sub S'4
    <- times-commutative T T'4
    <- plus-commutative Pmod P'4
    <- divrem-can-be-constructed T Pmod 1>0 DR4
    <- plus-implies-ge Sub GE4
    <- meta-ge _ _ GE4
    <- quotient-is-no-greater DR4 G4
    <- meta-ge _ _ G4.

- : predargs/predtype/+#map-onto/L _ (classify#/low G) T M
    <- nat`gt-contradiction G F
    <- false-implies-predargs# F T
    <- false-implies-predargs#map F M.

- : predargs/predtype/+#map-onto/L _ (classify#/high plus/z plus/z times/z plus/z 1>0) _ (predargs#map/predargs/+ nat`eq/ M1 1*0=0 0+0=0 M4 0$0=0 nat`eq/ 1*0=0 0+0=0 0+0=0 0+0=0)
    <- gterm#count-total C1
    <- gterm#map-onto/0 K#810 C1 _ M1
    <- predargs#map-onto/0 N#810 _ M4.

- : predargs/predtype/+#map-onto/L _ (classify#/high 0+0=0 0+1=1 1*1=1 1+0=1 1>0) _ (predargs#map/predargs/+ nat`eq/ M1 1*0=0 0+0=0 M4 0$1=1 nat`eq/ 1*1=1 0+1=1 0+0=0 1+0=1)
    <- gterm#count-total C1
    <- gterm#map-onto/0 K#810 C1 _ M1
    <- predargs#map-onto/1 N#810 _ M4.

- : predargs/predtype/+#map-onto/L _ (classify#/high 0+0=0 Sub T Pmod 1>0) _ (predargs#map/predargs/+ nat`eq/ M1 (times/s times/z plus/z) plus/z M4 NP5 nat`eq/ T'6 P'6 0+0=0 S'6)
    <- plus-commutative Sub S'6
    <- times-commutative T T'6
    <- plus-commutative Pmod P'6
    <- divrem-can-be-constructed T Pmod 1>0 DR6
    <- plus-implies-ge Sub GE6
    <- meta-ge _ _ GE6
    <- quotient-is-no-greater DR6 G6
    <- meta-ge _ _ G6
    <- nat2pair-total NP5
    <- plus-right-identity _ PLA
    <- plus-deterministic PLA Pmod nat`eq/ nat`eq/ EQA
    <- times-commutative T TMA
    <- times-left-identity _ TMB
    <- times-left-cancels TMA TMB nat`eq/ EQA EQB
    <- pair2nat-respects-eq NP5 natpair`eq/ EQB NP5P
    <- large-nat2pair-implies-gt NP5P GTA GTB
    <- meta-gt _ _ GTA
    <- meta-gt _ _ GTB
    <- nat2pair-implies-ge NP5 GE5 GEP5
    <- meta-ge _ _ GE5
    <- meta-ge _ _ GEP5
    <- gterm#map-onto _ _ M1
    <- predargs#map-onto _ _ M4.


- : gterm/objectk#map-onto/L _ _ (classify#/high plus/z plus/z (times/s (times/s T1 P1) P2) (plus/s plus/z) gt/1) X M
    <- plus-right-cancels P2 plus/z nat`eq/ nat`eq/ N=0
    <- plus-is-zero-implies-zero P1 N=0 _ ONE=ZERO
    <- nat`eq-symmetric ONE=ZERO ZERO=ONE
    <- nat`eq-contradiction ZERO=ONE F
    <- false-implies-gterm# F X
    <- false-implies-gterm#map F M.
	  


- : gterm/fractionk#map-onto/L _ _ (classify#/high plus/z plus/z (times/s (times/s T1 P1) P2) (plus/s plus/z) gt/1) X M
    <- plus-right-cancels P2 plus/z nat`eq/ nat`eq/ N=0
    <- plus-is-zero-implies-zero P1 N=0 _ ONE=ZERO
    <- nat`eq-symmetric ONE=ZERO ZERO=ONE
    <- nat`eq-contradiction ZERO=ONE F
    <- false-implies-gterm# F X
    <- false-implies-gterm#map F M.
	  


- : predargs/predtype/0#map-onto/L _ (classify#/high plus/z plus/z (times/s (times/s T1 P1) P2) (plus/s plus/z) gt/1) X M
    <- plus-right-cancels P2 plus/z nat`eq/ nat`eq/ N=0
    <- plus-is-zero-implies-zero P1 N=0 _ ONE=ZERO
    <- nat`eq-symmetric ONE=ZERO ZERO=ONE
    <- nat`eq-contradiction ZERO=ONE F
    <- false-implies-predargs# F X
    <- false-implies-predargs#map F M.
	  


- : predargs/predtype/+#map-onto/L _ (classify#/high plus/z plus/z (times/s (times/s T1 P1) P2) (plus/s plus/z) gt/1) X M
    <- plus-right-cancels P2 plus/z nat`eq/ nat`eq/ N=0
    <- plus-is-zero-implies-zero P1 N=0 _ ONE=ZERO
    <- nat`eq-symmetric ONE=ZERO ZERO=ONE
    <- nat`eq-contradiction ZERO=ONE F
    <- false-implies-predargs# F X
    <- false-implies-predargs#map F M.
	  


%worlds (block#gterm#case/nolevel | block#predicate#case/nolevel) (gterm/objectk#map-onto/L X _ _ _ _) (gterm/fractionk#map-onto/L X _ _ _ _) (gterm/termk/permissionk#map-onto/L X _ _ _ _) (gterm/termk/upermk#map-onto/L X _ _ _ _) (gterm/termk/formulak#map-onto/L X _ _ _ _) (gterm#map-onto X _ _) (predicate/predtype/0#map-onto/L X _ _ _ _) (predicate/predtype/+#map-onto/L X _ _ _ _) (predicate#map-onto X _ _) (predargs/predtype/0#map-onto/L X _ _ _) (predargs/predtype/+#map-onto/L X _ _ _) (predargs#map-onto X _ _).
%total (X#949 X#950 X#951 X#952 X#953 X#954 X#1070 X#1071 X#1072 X#1113 X#1114 X#1115 ) (gterm/objectk#map-onto/L X#949 _ _ _ _) (gterm/fractionk#map-onto/L X#950 _ _ _ _) (gterm/termk/permissionk#map-onto/L X#951 _ _ _ _) (gterm/termk/upermk#map-onto/L X#952 _ _ _ _) (gterm/termk/formulak#map-onto/L X#953 _ _ _ _) (gterm#map-onto X#954 _ _) (predicate/predtype/0#map-onto/L X#1070 _ _ _ _) (predicate/predtype/+#map-onto/L X#1071 _ _ _ _) (predicate#map-onto X#1072 _ _) (predargs/predtype/0#map-onto/L X#1113 _ _ _) (predargs/predtype/+#map-onto/L X#1114 _ _ _) (predargs#map-onto X#1115 _ _).



%%%   Theorems about equality preservation with variables


%theorem empty-respects-gterm#eq:
	exists
		{EQ0:gterm#eq empty empty}
	true.

%theorem scale-respects-gterm#eq:
	forall*
		{A0:gterm fractionk}
		{B0:gterm fractionk}
		{A1:gterm (termk permissionk)}
		{B1:gterm (termk permissionk)}
	forall
		{EQ0:gterm#eq A0 B0}
		{EQ1:gterm#eq A1 B1}
	exists
		{EQ2:gterm#eq (scale A0 A1) (scale B0 B1)}
	true.

%theorem combine-respects-gterm#eq:
	forall*
		{A0:gterm (termk permissionk)}
		{B0:gterm (termk permissionk)}
		{A1:gterm (termk permissionk)}
		{B1:gterm (termk permissionk)}
	forall
		{EQ0:gterm#eq A0 B0}
		{EQ1:gterm#eq A1 B1}
	exists
		{EQ2:gterm#eq (combine A0 A1) (combine B0 B1)}
	true.

%theorem unitperm-respects-gterm#eq:
	forall*
		{A0:gterm (termk upermk)}
		{B0:gterm (termk upermk)}
	forall
		{EQ0:gterm#eq A0 B0}
	exists
		{EQ1:gterm#eq (unitperm A0) (unitperm B0)}
	true.

%theorem nonlinear-respects-gterm#eq:
	forall*
		{A0:gterm (termk formulak)}
		{B0:gterm (termk formulak)}
	forall
		{EQ0:gterm#eq A0 B0}
	exists
		{EQ1:gterm#eq (nonlinear A0) (nonlinear B0)}
	true.

%theorem conditional-respects-gterm#eq:
	forall*
		{A0:gterm (termk formulak)}
		{B0:gterm (termk formulak)}
		{A1:gterm (termk permissionk)}
		{B1:gterm (termk permissionk)}
		{A2:gterm (termk permissionk)}
		{B2:gterm (termk permissionk)}
	forall
		{EQ0:gterm#eq A0 B0}
		{EQ1:gterm#eq A1 B1}
		{EQ2:gterm#eq A2 B2}
	exists
		{EQ3:gterm#eq (conditional A0 A1 A2) (conditional B0 B1 B2)}
	true.

%theorem encumbered-respects-gterm#eq:
	forall*
		{A0:gterm (termk permissionk)}
		{B0:gterm (termk permissionk)}
		{A1:gterm (termk permissionk)}
		{B1:gterm (termk permissionk)}
	forall
		{EQ0:gterm#eq A0 B0}
		{EQ1:gterm#eq A1 B1}
	exists
		{EQ2:gterm#eq (encumbered A0 A1) (encumbered B0 B1)}
	true.

gterm#func-eq/gterm : (gterm K3 -> gterm K1) -> (gterm K4 -> gterm K2) -> type .

%theorem gterm#func-eq/gterm-respects-eq:
	forall*
		{K5:vark}
		{K6:vark}
		{F1:gterm K5 -> gterm K6}
		{F2:gterm K5 -> gterm K6}
	forall
		{EQ:{x0:gterm K5} (gterm#eq (F1 x0) (F2 x0))}
	exists
		{EF:gterm#func-eq/gterm F1 F2}
	true.

%theorem precise-exists-respects-gterm#eq:
	forall*
		{A0:gterm objectk}
		{B0:gterm objectk}
		{A1:nat}
		{B1:nat}
		{A2:gterm objectk -> gterm (termk permissionk)}
		{B2:gterm objectk -> gterm (termk permissionk)}
	forall
		{EQ0:gterm#eq A0 B0}
		{EQ1:nat`eq A1 B1}
		{EQ2:gterm#func-eq/gterm A2 B2}
	exists
		{EQ3:gterm#eq (precise-exists A0 A1 A2) (precise-exists B0 B1 B2)}
	true.

%theorem basic-respects-gterm#eq:
	forall*
		{A0:gterm objectk}
		{B0:gterm objectk}
		{A1:nat}
		{B1:nat}
		{A2:gterm objectk}
		{B2:gterm objectk}
	forall
		{EQ0:gterm#eq A0 B0}
		{EQ1:nat`eq A1 B1}
		{EQ2:gterm#eq A2 B2}
	exists
		{EQ3:gterm#eq (basic A0 A1 A2) (basic B0 B1 B2)}
	true.

%theorem object/-respects-gterm#eq:
	forall*
		{A0:nat}
		{B0:nat}
	forall
		{EQ0:nat`eq A0 B0}
	exists
		{EQ1:gterm#eq (object/ A0) (object/ B0)}
	true.

%theorem fraction/-respects-gterm#eq:
	forall*
		{A0:rat}
		{B0:rat}
	forall
		{EQ0:rat#eq A0 B0}
	exists
		{EQ1:gterm#eq (fraction/ A0) (fraction/ B0)}
	true.

%theorem t-respects-gterm#eq:
	exists
		{EQ0:gterm#eq t t}
	true.

%theorem neg-respects-gterm#eq:
	forall*
		{A0:gterm (termk formulak)}
		{B0:gterm (termk formulak)}
	forall
		{EQ0:gterm#eq A0 B0}
	exists
		{EQ1:gterm#eq (neg A0) (neg B0)}
	true.

%theorem conj-respects-gterm#eq:
	forall*
		{A0:gterm (termk formulak)}
		{B0:gterm (termk formulak)}
		{A1:gterm (termk formulak)}
		{B1:gterm (termk formulak)}
	forall
		{EQ0:gterm#eq A0 B0}
		{EQ1:gterm#eq A1 B1}
	exists
		{EQ2:gterm#eq (conj A0 A1) (conj B0 B1)}
	true.

%theorem objequal-respects-gterm#eq:
	forall*
		{A0:gterm objectk}
		{B0:gterm objectk}
		{A1:gterm objectk}
		{B1:gterm objectk}
	forall
		{EQ0:gterm#eq A0 B0}
		{EQ1:gterm#eq A1 B1}
	exists
		{EQ2:gterm#eq (objequal A0 A1) (objequal B0 B1)}
	true.

%theorem exists*-respects-gterm#eq:
	forall*
		{A0:vark}
		{B0:vark}
		{A1:gterm A0 -> gterm (termk formulak)}
		{B1:gterm B0 -> gterm (termk formulak)}
	forall
		{EQ0:vark#eq A0 B0}
		{EQ1:gterm#func-eq/gterm A1 B1}
	exists
		{EQ2:gterm#eq (exists* A0 A1) (exists* B0 B1)}
	true.

%theorem nested-respects-gterm#eq:
	forall*
		{A0:gterm (termk permissionk)}
		{B0:gterm (termk permissionk)}
		{A1:gterm objectk}
		{B1:gterm objectk}
		{A2:nat}
		{B2:nat}
	forall
		{EQ0:gterm#eq A0 B0}
		{EQ1:gterm#eq A1 B1}
		{EQ2:nat`eq A2 B2}
	exists
		{EQ3:gterm#eq (nested A0 A1 A2) (nested B0 B1 B2)}
	true.

%theorem predcall*-respects-gterm#eq:
	forall*
		{A0:predtype}
		{B0:predtype}
		{A1:predicate A0}
		{B1:predicate B0}
		{A2:predargs A0}
		{B2:predargs B0}
	forall
		{EQ0:predtype#eq A0 B0}
		{EQ1:predicate#eq A1 B1}
		{EQ2:predargs#eq A2 B2}
	exists
		{EQ3:gterm#eq (predcall* A0 A1 A2) (predcall* B0 B1 B2)}
	true.

%theorem predicate/0-respects-predicate#eq:
	forall*
		{A0:gterm (termk formulak)}
		{B0:gterm (termk formulak)}
	forall
		{EQ0:gterm#eq A0 B0}
	exists
		{EQ1:predicate#eq (predicate/0 A0) (predicate/0 B0)}
	true.

predicate#func-eq/gterm : (gterm K3 -> predicate K1) -> (gterm K4 -> predicate K2) -> type .

%theorem predicate#func-eq/gterm-respects-eq:
	forall*
		{K5:vark}
		{K6:predtype}
		{F1:gterm K5 -> predicate K6}
		{F2:gterm K5 -> predicate K6}
	forall
		{EQ:{x0:gterm K5} (predicate#eq (F1 x0) (F2 x0))}
	exists
		{EF:predicate#func-eq/gterm F1 F2}
	true.

%theorem predicate/+-respects-predicate#eq:
	forall*
		{K:vark}
		{N:predtype}
		{A0:gterm K -> predicate N}
		{B0:gterm K -> predicate N}
	forall
		{EQ0:predicate#func-eq/gterm A0 B0}
	exists
		{EQ1:predicate#eq (predicate/+ A0) (predicate/+ B0)}
	true.

predicate#func-eq/predicate : (predicate K3 -> predicate K1) -> (predicate K4 -> predicate K2) -> type .

%theorem predicate#func-eq/predicate-respects-eq:
	forall*
		{K5:predtype}
		{K6:predtype}
		{F1:predicate K5 -> predicate K6}
		{F2:predicate K5 -> predicate K6}
	forall
		{EQ:{x0:predicate K5} (predicate#eq (F1 x0) (F2 x0))}
	exists
		{EF:predicate#func-eq/predicate F1 F2}
	true.

%theorem predicate/Y-respects-predicate#eq:
	forall*
		{N:predtype}
		{A0:predicate N -> predicate N}
		{B0:predicate N -> predicate N}
	forall
		{EQ0:predicate#func-eq/predicate A0 B0}
	exists
		{EQ1:predicate#eq (predicate/Y A0) (predicate/Y B0)}
	true.

%theorem predargs/0*-respects-predargs#eq:
	forall*
		{A0:nat}
		{B0:nat}
	forall
		{EQ0:nat`eq A0 B0}
	exists
		{EQ1:predargs#eq (predargs/0* A0) (predargs/0* B0)}
	true.

%theorem predargs/+-respects-predargs#eq:
	forall*
		{K:vark}
		{N:predtype}
		{A0:gterm K}
		{B0:gterm K}
		{A1:predargs N}
		{B1:predargs N}
	forall
		{EQ0:gterm#eq A0 B0}
		{EQ1:predargs#eq A1 B1}
	exists
		{EQ2:predargs#eq (predargs/+ A0 A1) (predargs/+ B0 B1)}
	true.



%% Cases

- : empty-respects-gterm#eq gterm#eq/.

- : scale-respects-gterm#eq gterm#eq/ gterm#eq/ gterm#eq/.

- : combine-respects-gterm#eq gterm#eq/ gterm#eq/ gterm#eq/.

- : unitperm-respects-gterm#eq gterm#eq/ gterm#eq/.

- : nonlinear-respects-gterm#eq gterm#eq/ gterm#eq/.

- : conditional-respects-gterm#eq gterm#eq/ gterm#eq/ gterm#eq/ gterm#eq/.

- : encumbered-respects-gterm#eq gterm#eq/ gterm#eq/ gterm#eq/.

gterm#func-eq/gterm/ : gterm#func-eq/gterm F F .

- : gterm#func-eq/gterm-respects-eq ([x0:gterm K5] gterm#eq/) gterm#func-eq/gterm/.

- : precise-exists-respects-gterm#eq gterm#eq/ nat`eq/ gterm#func-eq/gterm/ gterm#eq/.

- : basic-respects-gterm#eq gterm#eq/ nat`eq/ gterm#eq/ gterm#eq/.

- : object/-respects-gterm#eq nat`eq/ gterm#eq/.

- : fraction/-respects-gterm#eq rat#eq/ gterm#eq/.

- : t-respects-gterm#eq gterm#eq/.

- : neg-respects-gterm#eq gterm#eq/ gterm#eq/.

- : conj-respects-gterm#eq gterm#eq/ gterm#eq/ gterm#eq/.

- : objequal-respects-gterm#eq gterm#eq/ gterm#eq/ gterm#eq/.

- : exists*-respects-gterm#eq vark#eq/ gterm#func-eq/gterm/ gterm#eq/.

- : nested-respects-gterm#eq gterm#eq/ gterm#eq/ nat`eq/ gterm#eq/.

- : predcall*-respects-gterm#eq predtype#eq/ predicate#eq/ predargs#eq/ gterm#eq/.

- : predicate/0-respects-predicate#eq gterm#eq/ predicate#eq/.

predicate#func-eq/gterm/ : predicate#func-eq/gterm F F .

- : predicate#func-eq/gterm-respects-eq ([x0:gterm K5] predicate#eq/) predicate#func-eq/gterm/.

- : predicate/+-respects-predicate#eq predicate#func-eq/gterm/ predicate#eq/.

predicate#func-eq/predicate/ : predicate#func-eq/predicate F F .

- : predicate#func-eq/predicate-respects-eq ([x0:predicate K5] predicate#eq/) predicate#func-eq/predicate/.

- : predicate/Y-respects-predicate#eq predicate#func-eq/predicate/ predicate#eq/.

- : predargs/0*-respects-predargs#eq nat`eq/ predargs#eq/.

- : predargs/+-respects-predargs#eq gterm#eq/ predargs#eq/ predargs#eq/.


%worlds (block#gterm#var | block#predicate#var) (empty-respects-gterm#eq _) (scale-respects-gterm#eq _ _ _) (combine-respects-gterm#eq _ _ _) (unitperm-respects-gterm#eq _ _) (nonlinear-respects-gterm#eq _ _) (conditional-respects-gterm#eq _ _ _ _) (encumbered-respects-gterm#eq _ _ _) (gterm#func-eq/gterm-respects-eq _ _) (precise-exists-respects-gterm#eq _ _ _ _) (basic-respects-gterm#eq _ _ _ _) (object/-respects-gterm#eq _ _) (fraction/-respects-gterm#eq _ _) (t-respects-gterm#eq _) (neg-respects-gterm#eq _ _) (conj-respects-gterm#eq _ _ _) (objequal-respects-gterm#eq _ _ _) (exists*-respects-gterm#eq _ _ _) (nested-respects-gterm#eq _ _ _ _) (predcall*-respects-gterm#eq _ _ _ _) (predicate/0-respects-predicate#eq _ _) (predicate#func-eq/gterm-respects-eq _ _) (predicate/+-respects-predicate#eq _ _) (predicate#func-eq/predicate-respects-eq _ _) (predicate/Y-respects-predicate#eq _ _) (predargs/0*-respects-predargs#eq _ _) (predargs/+-respects-predargs#eq _ _ _).
%total { } (empty-respects-gterm#eq _) (scale-respects-gterm#eq _ _ _) (combine-respects-gterm#eq _ _ _) (unitperm-respects-gterm#eq _ _) (nonlinear-respects-gterm#eq _ _) (conditional-respects-gterm#eq _ _ _ _) (encumbered-respects-gterm#eq _ _ _) (gterm#func-eq/gterm-respects-eq _ _) (precise-exists-respects-gterm#eq _ _ _ _) (basic-respects-gterm#eq _ _ _ _) (object/-respects-gterm#eq _ _) (fraction/-respects-gterm#eq _ _) (t-respects-gterm#eq _) (neg-respects-gterm#eq _ _) (conj-respects-gterm#eq _ _ _) (objequal-respects-gterm#eq _ _ _) (exists*-respects-gterm#eq _ _ _) (nested-respects-gterm#eq _ _ _ _) (predcall*-respects-gterm#eq _ _ _ _) (predicate/0-respects-predicate#eq _ _) (predicate#func-eq/gterm-respects-eq _ _) (predicate/+-respects-predicate#eq _ _) (predicate#func-eq/predicate-respects-eq _ _) (predicate/Y-respects-predicate#eq _ _) (predargs/0*-respects-predargs#eq _ _) (predargs/+-respects-predargs#eq _ _ _).



%%%   Theorem about 'one2one' for mapping with variables


%theorem gterm#map-one2one:
	forall*
		{K1:vark}
		{K2:vark}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{T1:gterm K1}
		{T2:gterm K2}
		{N1:nat}
		{N2:nat}
	forall
		{EK:vark#eq K1 K2}
		{M1:gterm#map K1 Hgterm Hpredicate T1 N1}
		{M2:gterm#map K2 Hgterm Hpredicate T2 N2}
		{EN:nat`eq N1 N2}
	exists
		{ET:gterm#eq T1 T2}
	true.

%theorem predicate#map-one2one:
	forall*
		{K1:predtype}
		{K2:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{T1:predicate K1}
		{T2:predicate K2}
		{N1:nat}
		{N2:nat}
	forall
		{EK:predtype#eq K1 K2}
		{M1:predicate#map K1 Hgterm Hpredicate T1 N1}
		{M2:predicate#map K2 Hgterm Hpredicate T2 N2}
		{EN:nat`eq N1 N2}
	exists
		{ET:predicate#eq T1 T2}
	true.

%theorem predargs#map-one2one:
	forall*
		{K1:predtype}
		{K2:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{T1:predargs K1}
		{T2:predargs K2}
		{N1:nat}
		{N2:nat}
	forall
		{EK:predtype#eq K1 K2}
		{M1:predargs#map K1 Hgterm Hpredicate T1 N1}
		{M2:predargs#map K2 Hgterm Hpredicate T2 N2}
		{EN:nat`eq N1 N2}
	exists
		{ET:predargs#eq T1 T2}
	true.

%theorem gterm#map-one2one/gterm#func-eq/gterm:
	forall*
		{K1:vark}
		{K'1:vark}
		{K2:vark}
		{K'2:vark}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{F1:gterm K1 -> gterm K2}
		{F2:gterm K'1 -> gterm K'2}
		{N1:nat}
		{N2:nat}
	forall
		{E1:vark#eq K1 K'1}
		{E2:vark#eq K2 K'2}
		{FM1:{x0:gterm K1} ({v0:gterm#var x0} (gterm#nolevel x0 -> gterm#map K2 (gterm#list/+ K1 x0 v0 Hgterm) Hpredicate (F1 x0) N1))}
		{FM2:{x0:gterm K'1} ({v0:gterm#var x0} (gterm#nolevel x0 -> gterm#map K'2 (gterm#list/+ K'1 x0 v0 Hgterm) Hpredicate (F2 x0) N2))}
		{EN:nat`eq N1 N2}
	exists
		{EF:gterm#func-eq/gterm F1 F2}
	true.

%theorem predicate#map-one2one/predicate#func-eq/predicate:
	forall*
		{K1:predtype}
		{K'1:predtype}
		{K2:predtype}
		{K'2:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{F1:predicate K1 -> predicate K2}
		{F2:predicate K'1 -> predicate K'2}
		{N1:nat}
		{N2:nat}
	forall
		{E1:predtype#eq K1 K'1}
		{E2:predtype#eq K2 K'2}
		{FM1:{x0:predicate K1} ({v0:predicate#var x0} (predicate#nolevel x0 -> predicate#map K2 Hgterm (predicate#list/+ K1 x0 v0 Hpredicate) (F1 x0) N1))}
		{FM2:{x0:predicate K'1} ({v0:predicate#var x0} (predicate#nolevel x0 -> predicate#map K'2 Hgterm (predicate#list/+ K'1 x0 v0 Hpredicate) (F2 x0) N2))}
		{EN:nat`eq N1 N2}
	exists
		{EF:predicate#func-eq/predicate F1 F2}
	true.

%theorem predicate#map-one2one/predicate#func-eq/gterm:
	forall*
		{K1:vark}
		{K'1:vark}
		{K2:predtype}
		{K'2:predtype}
		{Hgterm:gterm#list}
		{Hpredicate:predicate#list}
		{F1:gterm K1 -> predicate K2}
		{F2:gterm K'1 -> predicate K'2}
		{N1:nat}
		{N2:nat}
	forall
		{E1:vark#eq K1 K'1}
		{E2:predtype#eq K2 K'2}
		{FM1:{x0:gterm K1} ({v0:gterm#var x0} (gterm#nolevel x0 -> predicate#map K2 (gterm#list/+ K1 x0 v0 Hgterm) Hpredicate (F1 x0) N1))}
		{FM2:{x0:gterm K'1} ({v0:gterm#var x0} (gterm#nolevel x0 -> predicate#map K'2 (gterm#list/+ K'1 x0 v0 Hgterm) Hpredicate (F2 x0) N2))}
		{EN:nat`eq N1 N2}
	exists
		{EF:predicate#func-eq/gterm F1 F2}
	true.



%% Cases

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/#nolevel _ S2 C2) nat`eq/ E
    <- gterm#lookup-one2one S1 C1 S2 C2 nat`eq/ E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/object/ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/object/ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/fraction/ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/fraction/ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/empty _ C _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/empty _ C _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/scale _ _ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/scale _ _ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/combine _ _ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/combine _ _ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/unitperm _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/unitperm _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/nonlinear _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/nonlinear _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/conditional _ _ _ _ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conditional _ _ _ _ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/encumbered _ _ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/encumbered _ _ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/precise-exists _ _ _ _ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/precise-exists _ _ _ _ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/basic _ _ _ _ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/basic _ _ _ _ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/t _ C _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/t _ C _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/neg _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/neg _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/conj _ _ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conj _ _ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/objequal _ _ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/objequal _ _ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/exists* _ _ _ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/exists* _ _ _ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/nested _ _ _ _ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/nested _ _ _ _ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/#nolevel _ S1 C1) (gterm#map/predcall* _ _ _ _ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/predcall* _ _ _ _ _ _ _ _ C _ _ D0 D1) (gterm#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- gterm#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/object/ nat`eq/ nat`eq/ (times/s times/z plus/z) 0+N=N C (times/s times/z plus/z) 0+N=N 0+N=N P8) (gterm#map/object/ nat`eq/ nat`eq/ (times/s times/z plus/z) 0+N=N C' (times/s times/z plus/z) 0+N=N 0+N=N P'8) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- plus-right-cancels P8 P'8 ENV nat`eq/ EA0
    <- object/-respects-gterm#eq EA0 E.

- : gterm#map-one2one vark#eq/ (gterm#map/fraction/ nat`eq/ M1 (times/s times/z plus/z) 0+N=N C (times/s times/z plus/z) 0+N=N 0+N=N P8) (gterm#map/fraction/ nat`eq/ M'1 (times/s times/z plus/z) 0+N=N C' (times/s times/z plus/z) 0+N=N 0+N=N P'8) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- plus-right-cancels P8 P'8 ENV nat`eq/ ENA0
    <- rat#map-one2one M1 M'1 ENA0 EN1-1
    <- fraction/-respects-gterm#eq EN1-1 E.

- : gterm#map-one2one vark#eq/ (gterm#map/empty nat`eq/ C nat`eq/ 0+N=N 0+N=N) (gterm#map/empty nat`eq/ C' nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- empty-respects-gterm#eq E.

- : gterm#map-one2one vark#eq/ (gterm#map/empty nat`eq/ C nat`eq/ 0+N=N 0+N=N) (gterm#map/scale _ _ _ _ _ _ C' T' P1' 1+N=sN P3') nat`eq/ E
    <- nat`plus-implies-ge P3' GE'
    <- gterm#count-deterministic C' C ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE' G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/empty nat`eq/ C nat`eq/ 0+N=N 0+N=N) (gterm#map/combine _ _ _ _ _ _ C' T' P1' 1+N=sN P3') nat`eq/ E
    <- nat`plus-implies-ge P3' GE'
    <- gterm#count-deterministic C' C ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE' G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/empty nat`eq/ C nat`eq/ 0+N=N 0+N=N) (gterm#map/unitperm _ _ _ _ C' T' P1' 1+N=sN P3') nat`eq/ E
    <- nat`plus-implies-ge P3' GE'
    <- gterm#count-deterministic C' C ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE' G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/scale _ _ _ _ _ _ C T P1 1+N=sN P3) (gterm#map/empty nat`eq/ C' nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- nat`plus-implies-ge P3 GE
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/scale nat`eq/ M1 (times/s times/z plus/z) 0+N=N M4 D5 C T7 P7 P8 P9) (gterm#map/scale nat`eq/ M'1 (times/s times/z plus/z) 0+N=N M'4 D'5 C' T'7 P'7 P'8 P'9) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P8 P'8 nat`eq/ ENV ENA
    <- plus-right-cancels P9 P'9 ENA nat`eq/ EPN
    <- nat`times-commutative T7 TC7
    <- nat`times-commutative T'7 TC'7
    <- nat`plus-commutative P7 PC7
    <- nat`plus-commutative P'7 PC'7
    <- divrem-can-be-constructed TC7 PC7 3>0 D7
    <- divrem-can-be-constructed TC'7 PC'7 3>0 D'7
    <- divrem-deterministic D7 D'7 EPN nat`eq/ EN2 _
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 ENA0 ENA1
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- gterm#map-one2one vark#eq/ M4 M'4 ENA1 EN4-1
    <- scale-respects-gterm#eq EN1-1 EN4-1 E.

- : gterm#map-one2one vark#eq/ (gterm#map/scale _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/combine _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 3>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 3>1 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 1>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/scale _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/unitperm _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 3>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 3>2 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 2>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/combine _ _ _ _ _ _ C T P1 1+N=sN P3) (gterm#map/empty nat`eq/ C' nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- nat`plus-implies-ge P3 GE
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/combine _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/scale _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 3>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 3>0 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 1>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/combine nat`eq/ M1 (times/s times/z plus/z) 0+N=N M4 D5 C T7 P7 P8 P9) (gterm#map/combine nat`eq/ M'1 (times/s times/z plus/z) 0+N=N M'4 D'5 C' T'7 P'7 P'8 P'9) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P8 P'8 nat`eq/ ENV ENA
    <- plus-right-cancels P9 P'9 ENA nat`eq/ EPN
    <- nat`times-commutative T7 TC7
    <- nat`times-commutative T'7 TC'7
    <- nat`plus-commutative P7 PC7
    <- nat`plus-commutative P'7 PC'7
    <- divrem-can-be-constructed TC7 PC7 3>1 D7
    <- divrem-can-be-constructed TC'7 PC'7 3>1 D'7
    <- divrem-deterministic D7 D'7 EPN nat`eq/ EN2 _
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 ENA0 ENA1
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- gterm#map-one2one vark#eq/ M4 M'4 ENA1 EN4-1
    <- combine-respects-gterm#eq EN1-1 EN4-1 E.

- : gterm#map-one2one vark#eq/ (gterm#map/combine _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/unitperm _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 3>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 3>2 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 2>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/unitperm _ _ _ _ C T P1 1+N=sN P3) (gterm#map/empty nat`eq/ C' nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- nat`plus-implies-ge P3 GE
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/unitperm _ _ _ _ C T P1 P2 P3) (gterm#map/scale _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 3>2 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 3>0 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 2>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/unitperm _ _ _ _ C T P1 P2 P3) (gterm#map/combine _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 3>2 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 3>1 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 2>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/unitperm nat`eq/ M1 (times/s times/z plus/z) 0+N=N C T5 P5 P6 P7) (gterm#map/unitperm nat`eq/ M'1 (times/s times/z plus/z) 0+N=N C' T'5 P'5 P'6 P'7) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P6 P'6 nat`eq/ ENV ENA
    <- plus-right-cancels P7 P'7 ENA nat`eq/ EPN
    <- nat`times-commutative T5 TC5
    <- nat`times-commutative T'5 TC'5
    <- nat`plus-commutative P5 PC5
    <- nat`plus-commutative P'5 PC'5
    <- divrem-can-be-constructed TC5 PC5 3>2 D5
    <- divrem-can-be-constructed TC'5 PC'5 3>2 D'5
    <- divrem-deterministic D5 D'5 EPN nat`eq/ ENA0 _
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- unitperm-respects-gterm#eq EN1-1 E.

- : gterm#map-one2one vark#eq/ (gterm#map/nonlinear nat`eq/ M1 (times/s times/z plus/z) 0+N=N C T5 P5 0+N=N P7) (gterm#map/nonlinear nat`eq/ M'1 (times/s times/z plus/z) 0+N=N C' T'5 P'5 0+N=N P'7) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- plus-right-cancels P7 P'7 ENV nat`eq/ EPN
    <- nat`times-commutative T5 TC5
    <- nat`times-commutative T'5 TC'5
    <- nat`plus-commutative P5 PC5
    <- nat`plus-commutative P'5 PC'5
    <- divrem-can-be-constructed TC5 PC5 5>0 D5
    <- divrem-can-be-constructed TC'5 PC'5 5>0 D'5
    <- divrem-deterministic D5 D'5 EPN nat`eq/ ENA0 _
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- nonlinear-respects-gterm#eq EN1-1 E.

- : gterm#map-one2one vark#eq/ (gterm#map/nonlinear _ _ _ _ C T P1 P2 P3) (gterm#map/conditional _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>1 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 1>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/nonlinear _ _ _ _ C T P1 P2 P3) (gterm#map/encumbered _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>2 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 2>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/nonlinear _ _ _ _ C T P1 P2 P3) (gterm#map/precise-exists _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>3 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 3>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/nonlinear _ _ _ _ C T P1 P2 P3) (gterm#map/basic _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>4 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 4>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conditional _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/nonlinear _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>0 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 1>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conditional nat`eq/ M1 (times/s times/z plus/z) 0+N=N M4 D5 M6 D7 C T9 P9 0+N=N P11) (gterm#map/conditional nat`eq/ M'1 (times/s times/z plus/z) 0+N=N M'4 D'5 M'6 D'7 C' T'9 P'9 0+N=N P'11) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- plus-right-cancels P11 P'11 ENV nat`eq/ EPN
    <- nat`times-commutative T9 TC9
    <- nat`times-commutative T'9 TC'9
    <- nat`plus-commutative P9 PC9
    <- nat`plus-commutative P'9 PC'9
    <- divrem-can-be-constructed TC9 PC9 5>1 D9
    <- divrem-can-be-constructed TC'9 PC'9 5>1 D'9
    <- divrem-deterministic D9 D'9 EPN nat`eq/ EN3 _
    <- nat2pair-deterministic D7 D'7 EN3 E7
    <- natpair`pair-eq-implies-eq E7 EN2 ENA2
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 ENA0 ENA1
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- gterm#map-one2one vark#eq/ M4 M'4 ENA1 EN4-1
    <- gterm#map-one2one vark#eq/ M6 M'6 ENA2 EN6-1
    <- conditional-respects-gterm#eq EN1-1 EN4-1 EN6-1 E.

- : gterm#map-one2one vark#eq/ (gterm#map/conditional _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/encumbered _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>2 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 2>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conditional _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/precise-exists _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>3 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 3>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conditional _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/basic _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>4 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 4>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/encumbered _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/nonlinear _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>2 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>0 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 2>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/encumbered _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/conditional _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>2 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>1 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 2>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/encumbered nat`eq/ M1 (times/s times/z plus/z) 0+N=N M4 D5 C T7 P7 0+N=N P9) (gterm#map/encumbered nat`eq/ M'1 (times/s times/z plus/z) 0+N=N M'4 D'5 C' T'7 P'7 0+N=N P'9) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- plus-right-cancels P9 P'9 ENV nat`eq/ EPN
    <- nat`times-commutative T7 TC7
    <- nat`times-commutative T'7 TC'7
    <- nat`plus-commutative P7 PC7
    <- nat`plus-commutative P'7 PC'7
    <- divrem-can-be-constructed TC7 PC7 5>2 D7
    <- divrem-can-be-constructed TC'7 PC'7 5>2 D'7
    <- divrem-deterministic D7 D'7 EPN nat`eq/ EN2 _
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 ENA0 ENA1
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- gterm#map-one2one vark#eq/ M4 M'4 ENA1 EN4-1
    <- encumbered-respects-gterm#eq EN1-1 EN4-1 E.

- : gterm#map-one2one vark#eq/ (gterm#map/encumbered _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/precise-exists _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>2 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>3 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 3>2) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/encumbered _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/basic _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>2 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>4 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 4>2) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/precise-exists _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/nonlinear _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>3 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>0 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 3>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/precise-exists _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/conditional _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>3 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>1 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 3>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/precise-exists _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/encumbered _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>3 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>2 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 3>2) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one/gterm#func-eq/gterm vark#eq/ vark#eq/ M1 M2 EQ EF
    <- ({x0:gterm K1} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (gterm#map-one2one vark#eq/ (M1 x0 v0 nl0) (M2 x0 v0 nl0) EQ (FE x0)))))
    <- gterm#func-eq/gterm-respects-eq FE EF.

- : gterm#map-one2one vark#eq/ (gterm#map/precise-exists nat`eq/ M1 (times/s times/z plus/z) 0+N=N nat`eq/ D5 M6 D7 C T9 P9 0+N=N P11) (gterm#map/precise-exists nat`eq/ M'1 (times/s times/z plus/z) 0+N=N nat`eq/ D'5 M'6 D'7 C' T'9 P'9 0+N=N P'11) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- plus-right-cancels P11 P'11 ENV nat`eq/ EPN
    <- nat`times-commutative T9 TC9
    <- nat`times-commutative T'9 TC'9
    <- nat`plus-commutative P9 PC9
    <- nat`plus-commutative P'9 PC'9
    <- divrem-can-be-constructed TC9 PC9 5>3 D9
    <- divrem-can-be-constructed TC'9 PC'9 5>3 D'9
    <- divrem-deterministic D9 D'9 EPN nat`eq/ EN3 _
    <- nat2pair-deterministic D7 D'7 EN3 E7
    <- natpair`pair-eq-implies-eq E7 EN2 ENA2
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 ENA0 EA1
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- gterm#map-one2one/gterm#func-eq/gterm vark#eq/ vark#eq/ M6 M'6 ENA2 EN6-2
    <- precise-exists-respects-gterm#eq EN1-1 EA1 EN6-2 E.

- : gterm#map-one2one vark#eq/ (gterm#map/precise-exists _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/basic _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>3 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>4 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 4>3) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/basic _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/nonlinear _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>4 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>0 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 4>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/basic _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/conditional _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>4 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>1 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 4>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/basic _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/encumbered _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>4 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>2 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 4>2) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/basic _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/precise-exists _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 5>4 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 5>3 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 4>3) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/basic nat`eq/ M1 (times/s times/z plus/z) 0+N=N nat`eq/ D5 M6 D7 C T9 P9 0+N=N P11) (gterm#map/basic nat`eq/ M'1 (times/s times/z plus/z) 0+N=N nat`eq/ D'5 M'6 D'7 C' T'9 P'9 0+N=N P'11) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- plus-right-cancels P11 P'11 ENV nat`eq/ EPN
    <- nat`times-commutative T9 TC9
    <- nat`times-commutative T'9 TC'9
    <- nat`plus-commutative P9 PC9
    <- nat`plus-commutative P'9 PC'9
    <- divrem-can-be-constructed TC9 PC9 5>4 D9
    <- divrem-can-be-constructed TC'9 PC'9 5>4 D'9
    <- divrem-deterministic D9 D'9 EPN nat`eq/ EN3 _
    <- nat2pair-deterministic D7 D'7 EN3 E7
    <- natpair`pair-eq-implies-eq E7 EN2 ENA2
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 ENA0 EA1
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- gterm#map-one2one vark#eq/ M6 M'6 ENA2 EN6-1
    <- basic-respects-gterm#eq EN1-1 EA1 EN6-1 E.

- : gterm#map-one2one vark#eq/ (gterm#map/t nat`eq/ C nat`eq/ 0+N=N 0+N=N) (gterm#map/t nat`eq/ C' nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- t-respects-gterm#eq E.

- : gterm#map-one2one vark#eq/ (gterm#map/t nat`eq/ C nat`eq/ 0+N=N 0+N=N) (gterm#map/neg _ _ _ _ C' T' P1' 1+N=sN P3') nat`eq/ E
    <- nat`plus-implies-ge P3' GE'
    <- gterm#count-deterministic C' C ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE' G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/t nat`eq/ C nat`eq/ 0+N=N 0+N=N) (gterm#map/conj _ _ _ _ _ _ C' T' P1' 1+N=sN P3') nat`eq/ E
    <- nat`plus-implies-ge P3' GE'
    <- gterm#count-deterministic C' C ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE' G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/t nat`eq/ C nat`eq/ 0+N=N 0+N=N) (gterm#map/objequal _ _ _ _ _ _ C' T' P1' 1+N=sN P3') nat`eq/ E
    <- nat`plus-implies-ge P3' GE'
    <- gterm#count-deterministic C' C ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE' G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/t nat`eq/ C nat`eq/ 0+N=N 0+N=N) (gterm#map/exists* _ _ _ _ _ _ _ C' T' P1' 1+N=sN P3') nat`eq/ E
    <- nat`plus-implies-ge P3' GE'
    <- gterm#count-deterministic C' C ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE' G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/t nat`eq/ C nat`eq/ 0+N=N 0+N=N) (gterm#map/nested _ _ _ _ _ _ _ _ C' T' P1' 1+N=sN P3') nat`eq/ E
    <- nat`plus-implies-ge P3' GE'
    <- gterm#count-deterministic C' C ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE' G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/t nat`eq/ C nat`eq/ 0+N=N 0+N=N) (gterm#map/predcall* _ _ _ _ _ _ _ _ C' T' P1' 1+N=sN P3') nat`eq/ E
    <- nat`plus-implies-ge P3' GE'
    <- gterm#count-deterministic C' C ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE' G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/neg _ _ _ _ C T P1 1+N=sN P3) (gterm#map/t nat`eq/ C' nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- nat`plus-implies-ge P3 GE
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/neg nat`eq/ M1 (times/s times/z plus/z) 0+N=N C T5 P5 P6 P7) (gterm#map/neg nat`eq/ M'1 (times/s times/z plus/z) 0+N=N C' T'5 P'5 P'6 P'7) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P6 P'6 nat`eq/ ENV ENA
    <- plus-right-cancels P7 P'7 ENA nat`eq/ EPN
    <- nat`times-commutative T5 TC5
    <- nat`times-commutative T'5 TC'5
    <- nat`plus-commutative P5 PC5
    <- nat`plus-commutative P'5 PC'5
    <- divrem-can-be-constructed TC5 PC5 6>0 D5
    <- divrem-can-be-constructed TC'5 PC'5 6>0 D'5
    <- divrem-deterministic D5 D'5 EPN nat`eq/ ENA0 _
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- neg-respects-gterm#eq EN1-1 E.

- : gterm#map-one2one vark#eq/ (gterm#map/neg _ _ _ _ C T P1 P2 P3) (gterm#map/conj _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>1 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 1>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/neg _ _ _ _ C T P1 P2 P3) (gterm#map/objequal _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>2 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 2>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/neg _ _ _ _ C T P1 P2 P3) (gterm#map/exists* _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>3 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 3>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/neg _ _ _ _ C T P1 P2 P3) (gterm#map/nested _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>4 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 4>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/neg _ _ _ _ C T P1 P2 P3) (gterm#map/predcall* _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>5 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 5>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conj _ _ _ _ _ _ C T P1 1+N=sN P3) (gterm#map/t nat`eq/ C' nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- nat`plus-implies-ge P3 GE
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conj _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/neg _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>0 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 1>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conj nat`eq/ M1 (times/s times/z plus/z) 0+N=N M4 D5 C T7 P7 P8 P9) (gterm#map/conj nat`eq/ M'1 (times/s times/z plus/z) 0+N=N M'4 D'5 C' T'7 P'7 P'8 P'9) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P8 P'8 nat`eq/ ENV ENA
    <- plus-right-cancels P9 P'9 ENA nat`eq/ EPN
    <- nat`times-commutative T7 TC7
    <- nat`times-commutative T'7 TC'7
    <- nat`plus-commutative P7 PC7
    <- nat`plus-commutative P'7 PC'7
    <- divrem-can-be-constructed TC7 PC7 6>1 D7
    <- divrem-can-be-constructed TC'7 PC'7 6>1 D'7
    <- divrem-deterministic D7 D'7 EPN nat`eq/ EN2 _
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 ENA0 ENA1
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- gterm#map-one2one vark#eq/ M4 M'4 ENA1 EN4-1
    <- conj-respects-gterm#eq EN1-1 EN4-1 E.

- : gterm#map-one2one vark#eq/ (gterm#map/conj _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/objequal _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>2 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 2>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conj _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/exists* _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>3 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 3>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conj _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/nested _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>4 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 4>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/conj _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/predcall* _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>5 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 5>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/objequal _ _ _ _ _ _ C T P1 1+N=sN P3) (gterm#map/t nat`eq/ C' nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- nat`plus-implies-ge P3 GE
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/objequal _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/neg _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>2 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>0 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 2>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/objequal _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/conj _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>2 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>1 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 2>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/objequal nat`eq/ M1 (times/s times/z plus/z) 0+N=N M4 D5 C T7 P7 P8 P9) (gterm#map/objequal nat`eq/ M'1 (times/s times/z plus/z) 0+N=N M'4 D'5 C' T'7 P'7 P'8 P'9) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P8 P'8 nat`eq/ ENV ENA
    <- plus-right-cancels P9 P'9 ENA nat`eq/ EPN
    <- nat`times-commutative T7 TC7
    <- nat`times-commutative T'7 TC'7
    <- nat`plus-commutative P7 PC7
    <- nat`plus-commutative P'7 PC'7
    <- divrem-can-be-constructed TC7 PC7 6>2 D7
    <- divrem-can-be-constructed TC'7 PC'7 6>2 D'7
    <- divrem-deterministic D7 D'7 EPN nat`eq/ EN2 _
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 ENA0 ENA1
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- gterm#map-one2one vark#eq/ M4 M'4 ENA1 EN4-1
    <- objequal-respects-gterm#eq EN1-1 EN4-1 E.

- : gterm#map-one2one vark#eq/ (gterm#map/objequal _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/exists* _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>2 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>3 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 3>2) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/objequal _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/nested _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>2 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>4 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 4>2) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/objequal _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/predcall* _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>2 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>5 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 5>2) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/exists* _ _ _ _ _ _ _ C T P1 1+N=sN P3) (gterm#map/t nat`eq/ C' nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- nat`plus-implies-ge P3 GE
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/exists* _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/neg _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>3 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>0 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 3>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/exists* _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/conj _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>3 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>1 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 3>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/exists* _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/objequal _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>3 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>2 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 3>2) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/exists* nat`eq/ M1 (times/s times/z plus/z) 0+N=N M4 T5 P5 C T7 P7 P8 P9) (gterm#map/exists* nat`eq/ M'1 (times/s times/z plus/z) 0+N=N M'4 T'5 P'5 C' T'7 P'7 P'8 P'9) nat`eq/ E
    <- vark#map-implies-gt M1 GNA0
    <- vark#map-implies-gt M'1 G'NA0
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P8 P'8 nat`eq/ ENV ENA
    <- plus-right-cancels P9 P'9 ENA nat`eq/ EPN
    <- nat`times-commutative T7 TC7
    <- nat`times-commutative T'7 TC'7
    <- nat`plus-commutative P7 PC7
    <- nat`plus-commutative P'7 PC'7
    <- divrem-can-be-constructed TC7 PC7 6>3 D7
    <- divrem-can-be-constructed TC'7 PC'7 6>3 D'7
    <- divrem-deterministic D7 D'7 EPN nat`eq/ EN2 _
    <- nat`times-commutative T5 TC5
    <- nat`times-commutative T'5 TC'5
    <- nat`plus-commutative P5 PC5
    <- nat`plus-commutative P'5 PC'5
    <- divrem-can-be-constructed TC5 PC5 GNA0 D5
    <- divrem-can-be-constructed TC'5 PC'5 G'NA0 D'5
    <- divrem-deterministic D5 D'5 EN2 nat`eq/ ENA1 ENA0
    <- vark#map-one2one M1 M'1 ENA0 EN1-1
    <- gterm#map-one2one/gterm#func-eq/gterm EN1-1 vark#eq/ M4 M'4 ENA1 EN4-2
    <- exists*-respects-gterm#eq EN1-1 EN4-2 E.

- : gterm#map-one2one vark#eq/ (gterm#map/exists* _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/nested _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>3 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>4 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 4>3) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/exists* _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/predcall* _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>3 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>5 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 5>3) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/nested _ _ _ _ _ _ _ _ C T P1 1+N=sN P3) (gterm#map/t nat`eq/ C' nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- nat`plus-implies-ge P3 GE
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/nested _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/neg _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>4 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>0 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 4>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/nested _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/conj _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>4 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>1 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 4>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/nested _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/objequal _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>4 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>2 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 4>2) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/nested _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/exists* _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>4 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>3 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 4>3) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/nested nat`eq/ M1 (times/s times/z plus/z) 0+N=N M4 D5 nat`eq/ D7 C T9 P9 P10 P11) (gterm#map/nested nat`eq/ M'1 (times/s times/z plus/z) 0+N=N M'4 D'5 nat`eq/ D'7 C' T'9 P'9 P'10 P'11) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P10 P'10 nat`eq/ ENV ENA
    <- plus-right-cancels P11 P'11 ENA nat`eq/ EPN
    <- nat`times-commutative T9 TC9
    <- nat`times-commutative T'9 TC'9
    <- nat`plus-commutative P9 PC9
    <- nat`plus-commutative P'9 PC'9
    <- divrem-can-be-constructed TC9 PC9 6>4 D9
    <- divrem-can-be-constructed TC'9 PC'9 6>4 D'9
    <- divrem-deterministic D9 D'9 EPN nat`eq/ EN3 _
    <- nat2pair-deterministic D7 D'7 EN3 E7
    <- natpair`pair-eq-implies-eq E7 EN2 EA2
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 ENA0 ENA1
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- gterm#map-one2one vark#eq/ M4 M'4 ENA1 EN4-1
    <- nested-respects-gterm#eq EN1-1 EN4-1 EA2 E.

- : gterm#map-one2one vark#eq/ (gterm#map/nested _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/predcall* _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>4 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>5 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 5>4) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/predcall* _ _ _ _ _ _ _ _ C T P1 1+N=sN P3) (gterm#map/t nat`eq/ C' nat`eq/ 0+N=N 0+N=N) nat`eq/ E
    <- nat`plus-implies-ge P3 GE
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic 0+N=N 0+N=N nat`eq/ ENV EU
    <- nat`gt-respects-eq sN>N nat`eq/ EU TG
    <- nat`gt-transitive-ge TG GE G
    <- nat`gt-anti-reflexive G F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/predcall* _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/neg _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>5 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>0 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 5>0) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/predcall* _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/conj _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>5 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>1 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 5>1) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/predcall* _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/objequal _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>5 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>2 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 5>2) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/predcall* _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/exists* _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>5 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>3 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 5>3) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/predcall* _ _ _ _ _ _ _ _ C T P1 P2 P3) (gterm#map/nested _ _ _ _ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 6>5 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 6>4 DR'
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 5>4) F
    <- false-implies-gterm#eq F E.

- : gterm#map-one2one vark#eq/ (gterm#map/predcall* nat`eq/ M1 (times/s times/z plus/z) 0+N=N M4 D5 M6 D7 C T9 P9 P10 P11) (gterm#map/predcall* nat`eq/ M'1 (times/s times/z plus/z) 0+N=N M'4 D'5 M'6 D'7 C' T'9 P'9 P'10 P'11) nat`eq/ E
    <- gterm#count-deterministic C C' ENV
    <- nat`plus-deterministic P10 P'10 nat`eq/ ENV ENA
    <- plus-right-cancels P11 P'11 ENA nat`eq/ EPN
    <- nat`times-commutative T9 TC9
    <- nat`times-commutative T'9 TC'9
    <- nat`plus-commutative P9 PC9
    <- nat`plus-commutative P'9 PC'9
    <- divrem-can-be-constructed TC9 PC9 6>5 D9
    <- divrem-can-be-constructed TC'9 PC'9 6>5 D'9
    <- divrem-deterministic D9 D'9 EPN nat`eq/ EN3 _
    <- nat2pair-deterministic D7 D'7 EN3 E7
    <- natpair`pair-eq-implies-eq E7 EN2 ENA2
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 ENA0 ENA1
    <- predtype#map-one2one M1 M'1 ENA0 EN1-1
    <- predicate#map-one2one EN1-1 M4 M'4 ENA1 EN4-1
    <- predargs#map-one2one EN1-1 M6 M'6 ENA2 EN6-1
    <- predcall*-respects-gterm#eq EN1-1 EN4-1 EN6-1 E.

- : predicate#map-one2one predtype#eq/ (predicate#map/#nolevel _ S1 C1) (predicate#map/#nolevel _ S2 C2) nat`eq/ E
    <- predicate#lookup-one2one S1 C1 S2 C2 nat`eq/ E.

- : predicate#map-one2one predtype#eq/ (predicate#map/#nolevel _ S1 C1) (predicate#map/predicate/0 _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- predicate#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/0 _ _ _ _ C _ _ D0 D1) (predicate#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- predicate#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one predtype#eq/ (predicate#map/#nolevel _ S1 C1) (predicate#map/predicate/Y _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- predicate#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/Y _ _ _ _ C _ _ D0 D1) (predicate#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- predicate#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one predtype#eq/ (predicate#map/#nolevel _ S1 C1) (predicate#map/predicate/+ _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- predicate#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/+ _ _ _ _ C _ _ D0 D1) (predicate#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- predicate#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one predtype#eq/ (predicate#map/#nolevel _ S1 C1) (predicate#map/predicate/Y1 _ _ _ _ C _ _ D0 D1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- predicate#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/Y1 _ _ _ _ C _ _ D0 D1) (predicate#map/#nolevel _ S1 C1) nat`eq/ E
    <- nat`plus-implies-ge D0 TG0
    <- ge-transitive TG0 (nat`ge/= nat`eq/) GE0
    <- nat`plus-implies-ge D1 TG1
    <- ge-transitive TG1 GE0 GE1
    <- predicate#split-decreases-count C S1 C1 GT
    <- gt-transitive-ge GT GE1 N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/0 nat`eq/ M1 (times/s times/z plus/z) 0+N=N C T5 P5 0+N=N P7) (predicate#map/predicate/0 nat`eq/ M'1 (times/s times/z plus/z) 0+N=N C' T'5 P'5 0+N=N P'7) nat`eq/ E
    <- predicate#count-deterministic C C' ENV
    <- plus-right-cancels P7 P'7 ENV nat`eq/ EPN
    <- nat`times-commutative T5 TC5
    <- nat`times-commutative T'5 TC'5
    <- nat`plus-commutative P5 PC5
    <- nat`plus-commutative P'5 PC'5
    <- divrem-can-be-constructed TC5 PC5 2>0 D5
    <- divrem-can-be-constructed TC'5 PC'5 2>0 D'5
    <- divrem-deterministic D5 D'5 EPN nat`eq/ ENA0 _
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- predicate/0-respects-predicate#eq EN1-1 E.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/0 _ _ _ _ C T P1 P2 P3) (predicate#map/predicate/Y _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 2>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 2>1 DR'
    <- predicate#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 1>0) F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/Y _ _ _ _ C T P1 P2 P3) (predicate#map/predicate/0 _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 2>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 2>0 DR'
    <- predicate#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 1>0) F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one/predicate#func-eq/predicate predtype#eq/ predtype#eq/ M1 M2 EQ EF
    <- ({x0:predicate K1} ({v0:predicate#var x0} ({nl0:predicate#nolevel x0} (predicate#map-one2one predtype#eq/ (M1 x0 v0 nl0) (M2 x0 v0 nl0) EQ (FE x0)))))
    <- predicate#func-eq/predicate-respects-eq FE EF.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/Y nat`eq/ M1 (times/s times/z plus/z) 0+N=N C T5 P5 0+N=N P7) (predicate#map/predicate/Y nat`eq/ M'1 (times/s times/z plus/z) 0+N=N C' T'5 P'5 0+N=N P'7) nat`eq/ E
    <- predicate#count-deterministic C C' ENV
    <- plus-right-cancels P7 P'7 ENV nat`eq/ EPN
    <- nat`times-commutative T5 TC5
    <- nat`times-commutative T'5 TC'5
    <- nat`plus-commutative P5 PC5
    <- nat`plus-commutative P'5 PC'5
    <- divrem-can-be-constructed TC5 PC5 2>1 D5
    <- divrem-can-be-constructed TC'5 PC'5 2>1 D'5
    <- divrem-deterministic D5 D'5 EPN nat`eq/ ENA0 _
    <- predicate#map-one2one/predicate#func-eq/predicate predtype#eq/ predtype#eq/ M1 M'1 ENA0 EN1-2
    <- predicate/Y-respects-predicate#eq EN1-2 E.

- : predicate#map-one2one/predicate#func-eq/gterm vark#eq/ predtype#eq/ M1 M2 EQ EF
    <- ({x0:gterm K1} ({v0:gterm#var x0} ({nl0:gterm#nolevel x0} (predicate#map-one2one predtype#eq/ (M1 x0 v0 nl0) (M2 x0 v0 nl0) EQ (FE x0)))))
    <- predicate#func-eq/gterm-respects-eq FE EF.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/+ nat`eq/ M1 (times/s times/z plus/z) 0+N=N C T5 P5 0+N=N P7) (predicate#map/predicate/+ nat`eq/ M'1 (times/s times/z plus/z) 0+N=N C' T'5 P'5 0+N=N P'7) nat`eq/ E
    <- predicate#count-deterministic C C' ENV
    <- plus-right-cancels P7 P'7 ENV nat`eq/ EPN
    <- nat`times-commutative T5 TC5
    <- nat`times-commutative T'5 TC'5
    <- nat`plus-commutative P5 PC5
    <- nat`plus-commutative P'5 PC'5
    <- divrem-can-be-constructed TC5 PC5 2>0 D5
    <- divrem-can-be-constructed TC'5 PC'5 2>0 D'5
    <- divrem-deterministic D5 D'5 EPN nat`eq/ ENA0 _
    <- predicate#map-one2one/predicate#func-eq/gterm vark#eq/ predtype#eq/ M1 M'1 ENA0 EN1-2
    <- predicate/+-respects-predicate#eq EN1-2 E.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/+ _ _ _ _ C T P1 P2 P3) (predicate#map/predicate/Y1 _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 2>0 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 2>1 DR'
    <- predicate#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/< 1>0) F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/Y1 _ _ _ _ C T P1 P2 P3) (predicate#map/predicate/+ _ _ _ _ C' T' P1' P2' P3') nat`eq/ E
    <- nat`times-commutative T Tc
    <- nat`plus-commutative P1 P1c
    <- divrem-can-be-constructed Tc P1c 2>1 DR
    <- nat`times-commutative T' Tc'
    <- nat`plus-commutative P1' P1c'
    <- divrem-can-be-constructed Tc' P1c' 2>0 DR'
    <- predicate#count-deterministic C C' ENV
    <- nat`plus-deterministic P2 P2' nat`eq/ ENV ENA
    <- nat`plus-right-cancels P3 P3' ENA nat`eq/ EPN
    <- divrem-deterministic DR DR' EPN nat`eq/ _ ER
    <- nat`eq-ne-implies-false ER (nat`ne/> 1>0) F
    <- false-implies-predicate#eq F E.

- : predicate#map-one2one predtype#eq/ (predicate#map/predicate/Y1 nat`eq/ M1 (times/s times/z plus/z) 0+N=N C T5 P5 0+N=N P7) (predicate#map/predicate/Y1 nat`eq/ M'1 (times/s times/z plus/z) 0+N=N C' T'5 P'5 0+N=N P'7) nat`eq/ E
    <- predicate#count-deterministic C C' ENV
    <- plus-right-cancels P7 P'7 ENV nat`eq/ EPN
    <- nat`times-commutative T5 TC5
    <- nat`times-commutative T'5 TC'5
    <- nat`plus-commutative P5 PC5
    <- nat`plus-commutative P'5 PC'5
    <- divrem-can-be-constructed TC5 PC5 2>1 D5
    <- divrem-can-be-constructed TC'5 PC'5 2>1 D'5
    <- divrem-deterministic D5 D'5 EPN nat`eq/ ENA0 _
    <- predicate#map-one2one/predicate#func-eq/predicate predtype#eq/ predtype#eq/ M1 M'1 ENA0 EN1-2
    <- predicate/Y-respects-predicate#eq EN1-2 E.

- : predargs#map-one2one predtype#eq/ (predargs#map/predargs/0* nat`eq/ nat`eq/ (times/s times/z plus/z) 0+N=N nat`eq/ (times/s times/z plus/z) 0+N=N 0+N=N P8) (predargs#map/predargs/0* nat`eq/ nat`eq/ (times/s times/z plus/z) 0+N=N nat`eq/ (times/s times/z plus/z) 0+N=N 0+N=N P'8) nat`eq/ E
    <- plus-right-cancels P8 P'8 nat`eq/ nat`eq/ EA0
    <- predargs/0*-respects-predargs#eq EA0 E.

- : predargs#map-one2one predtype#eq/ (predargs#map/predargs/+ nat`eq/ M1 (times/s times/z plus/z) 0+N=N M4 D5 nat`eq/ (times/s times/z plus/z) 0+N=N 0+N=N P10) (predargs#map/predargs/+ nat`eq/ M'1 (times/s times/z plus/z) 0+N=N M'4 D'5 nat`eq/ (times/s times/z plus/z) 0+N=N 0+N=N P'10) nat`eq/ E
    <- plus-right-cancels P10 P'10 nat`eq/ nat`eq/ EN2
    <- nat2pair-deterministic D5 D'5 EN2 E5
    <- natpair`pair-eq-implies-eq E5 ENA0 ENA1
    <- gterm#map-one2one vark#eq/ M1 M'1 ENA0 EN1-1
    <- predargs#map-one2one predtype#eq/ M4 M'4 ENA1 EN4-1
    <- predargs/+-respects-predargs#eq EN1-1 EN4-1 E.


%worlds (block#gterm#var | block#gterm#nolevel | block#predicate#var | block#predicate#nolevel) (gterm#map-one2one _ M1 _ _ _) (predicate#map-one2one _ M1 _ _ _) (predargs#map-one2one _ M1 _ _ _) (gterm#map-one2one/gterm#func-eq/gterm _ _ M _ _ _) (predicate#map-one2one/predicate#func-eq/predicate _ _ M _ _ _) (predicate#map-one2one/predicate#func-eq/gterm _ _ M _ _ _).
%total (M1#1447 M1#1449 M1#1450 M#1510 M#1644 M#1681 ) (gterm#map-one2one _ M1#1447 _ _ _) (predicate#map-one2one _ M1#1449 _ _ _) (predargs#map-one2one _ M1#1450 _ _ _) (gterm#map-one2one/gterm#func-eq/gterm _ _ M#1510 _ _ _) (predicate#map-one2one/predicate#func-eq/predicate _ _ M#1644 _ _ _) (predicate#map-one2one/predicate#func-eq/gterm _ _ M#1681 _ _ _).



%%%   Theorems about inequality and equality testing (with variables)


%theorem gterm#eq?-total*:
	forall*
		{K:vark}
	forall
		{X1:gterm K}
		{X2:gterm K}
	exists
		{B:bool}
		{EQ?:gterm#eq? X1 X2 B}
	true.

%theorem gterm#eq-ne-implies-false:
	forall*
		{K:vark}
		{X1:gterm K}
		{X2:gterm K}
	forall
		{EQ:gterm#eq X1 X2}
		{NE:gterm#ne X1 X2}
	exists
		{F:void}
	true.

%theorem predicate#eq?-total*:
	forall*
		{K:predtype}
	forall
		{X1:predicate K}
		{X2:predicate K}
	exists
		{B:bool}
		{EQ?:predicate#eq? X1 X2 B}
	true.

%theorem predicate#eq-ne-implies-false:
	forall*
		{K:predtype}
		{X1:predicate K}
		{X2:predicate K}
	forall
		{EQ:predicate#eq X1 X2}
		{NE:predicate#ne X1 X2}
	exists
		{F:void}
	true.

%theorem predargs#eq?-total*:
	forall*
		{K:predtype}
	forall
		{X1:predargs K}
		{X2:predargs K}
	exists
		{B:bool}
		{EQ?:predargs#eq? X1 X2 B}
	true.

%theorem predargs#eq-ne-implies-false:
	forall*
		{K:predtype}
		{X1:predargs K}
		{X2:predargs K}
	forall
		{EQ:predargs#eq X1 X2}
		{NE:predargs#ne X1 X2}
	exists
		{F:void}
	true.

%abbrev gterm#eq?-total : gterm#eq? X1 X2 B -> type = gterm#eq?-total* _ _ _ .

%abbrev predicate#eq?-total : predicate#eq? X1 X2 B -> type = predicate#eq?-total* _ _ _ .

%abbrev predargs#eq?-total : predargs#eq? X1 X2 B -> type = predargs#eq?-total* _ _ _ .



%% Cases


%theorem gterm#eq?-total/L1 :
	forall*	{K} {X1: gterm K} {X2} {N1} {N2} {B}
	forall	{M1: gterm#map _ gterm#list/0 predicate#list/0 X1 N1}
		{M2: gterm#map _ gterm#list/0 predicate#list/0 X2 N2}
		{EQ?: nat`eq? N1 N2 B}
	exists	{EQ?: gterm#eq? X1 X2 B}
	true.

%theorem gterm#eq?-total/L2 :
	forall*	{K} {X1: gterm K} {X2}
	forall  {EQ: gterm#eq X1 X2}
	exists	{EQ?: gterm#eq? X1 X2 true}
	true.

- : gterm#eq?-total/L2 gterm#eq/ gterm#eq?/yes.

%worlds () (gterm#eq?-total/L2 _ _).
%total { } (gterm#eq?-total/L2 _ _).

- : gterm#eq?-total/L1 M1 M2 nat`eq?/yes EQ?
    <- gterm#map-one2one vark#eq/ M1 M2 nat`eq/ EQ
    <- gterm#eq?-total/L2 EQ EQ?.

- : gterm#eq?-total/L1 M1 M2 (nat`eq?/no NE) (gterm#eq?/no (gterm#ne/ M1 M2 NE)).

%worlds () (gterm#eq?-total/L1 _ _ _ _).
%total { } (gterm#eq?-total/L1 _ _ _ _).

- : gterm#eq?-total EQ?
    <- gterm#map-total M1
    <- gterm#map-total M2
    <- nat`eq?-total NEQ?
    <- gterm#eq?-total/L1 M1 M2 NEQ? EQ?.



- : gterm#eq-ne-implies-false gterm#eq/ (gterm#ne/ M1 M2 NE) F
    <- gterm#map-deterministic M1 M2 gterm#eq/ EQ
    <- nat`eq-ne-implies-false EQ NE F.



%theorem predicate#eq?-total/L1 :
	forall*	{K} {X1: predicate K} {X2} {N1} {N2} {B}
	forall	{M1: predicate#map _ gterm#list/0 predicate#list/0 X1 N1}
		{M2: predicate#map _ gterm#list/0 predicate#list/0 X2 N2}
		{EQ?: nat`eq? N1 N2 B}
	exists	{EQ?: predicate#eq? X1 X2 B}
	true.

%theorem predicate#eq?-total/L2 :
	forall*	{K} {X1: predicate K} {X2}
	forall  {EQ: predicate#eq X1 X2}
	exists	{EQ?: predicate#eq? X1 X2 true}
	true.

- : predicate#eq?-total/L2 predicate#eq/ predicate#eq?/yes.

%worlds () (predicate#eq?-total/L2 _ _).
%total { } (predicate#eq?-total/L2 _ _).

- : predicate#eq?-total/L1 M1 M2 nat`eq?/yes EQ?
    <- predicate#map-one2one predtype#eq/ M1 M2 nat`eq/ EQ
    <- predicate#eq?-total/L2 EQ EQ?.

- : predicate#eq?-total/L1 M1 M2 (nat`eq?/no NE) (predicate#eq?/no (predicate#ne/ M1 M2 NE)).

%worlds () (predicate#eq?-total/L1 _ _ _ _).
%total { } (predicate#eq?-total/L1 _ _ _ _).

- : predicate#eq?-total EQ?
    <- predicate#map-total M1
    <- predicate#map-total M2
    <- nat`eq?-total NEQ?
    <- predicate#eq?-total/L1 M1 M2 NEQ? EQ?.



- : predicate#eq-ne-implies-false predicate#eq/ (predicate#ne/ M1 M2 NE) F
    <- predicate#map-deterministic M1 M2 predicate#eq/ EQ
    <- nat`eq-ne-implies-false EQ NE F.



%theorem predargs#eq?-total/L1 :
	forall*	{K} {X1: predargs K} {X2} {N1} {N2} {B}
	forall	{M1: predargs#map _ gterm#list/0 predicate#list/0 X1 N1}
		{M2: predargs#map _ gterm#list/0 predicate#list/0 X2 N2}
		{EQ?: nat`eq? N1 N2 B}
	exists	{EQ?: predargs#eq? X1 X2 B}
	true.

%theorem predargs#eq?-total/L2 :
	forall*	{K} {X1: predargs K} {X2}
	forall  {EQ: predargs#eq X1 X2}
	exists	{EQ?: predargs#eq? X1 X2 true}
	true.

- : predargs#eq?-total/L2 predargs#eq/ predargs#eq?/yes.

%worlds () (predargs#eq?-total/L2 _ _).
%total { } (predargs#eq?-total/L2 _ _).

- : predargs#eq?-total/L1 M1 M2 nat`eq?/yes EQ?
    <- predargs#map-one2one predtype#eq/ M1 M2 nat`eq/ EQ
    <- predargs#eq?-total/L2 EQ EQ?.

- : predargs#eq?-total/L1 M1 M2 (nat`eq?/no NE) (predargs#eq?/no (predargs#ne/ M1 M2 NE)).

%worlds () (predargs#eq?-total/L1 _ _ _ _).
%total { } (predargs#eq?-total/L1 _ _ _ _).

- : predargs#eq?-total EQ?
    <- predargs#map-total M1
    <- predargs#map-total M2
    <- nat`eq?-total NEQ?
    <- predargs#eq?-total/L1 M1 M2 NEQ? EQ?.



- : predargs#eq-ne-implies-false predargs#eq/ (predargs#ne/ M1 M2 NE) F
    <- predargs#map-deterministic M1 M2 predargs#eq/ EQ
    <- nat`eq-ne-implies-false EQ NE F.



%worlds () (gterm#eq?-total* _ _ _ _) (gterm#eq-ne-implies-false _ _ _) (predicate#eq?-total* _ _ _ _) (predicate#eq-ne-implies-false _ _ _) (predargs#eq?-total* _ _ _ _) (predargs#eq-ne-implies-false _ _ _).
%total { } (gterm#eq?-total* _ _ _ _) (gterm#eq-ne-implies-false _ _ _) (predicate#eq?-total* _ _ _ _) (predicate#eq-ne-implies-false _ _ _) (predargs#eq?-total* _ _ _ _) (predargs#eq-ne-implies-false _ _ _).




%%%% End of generated text.

%%%%% Permission equality and inequality

%{%
This file mainly consists of exporting the generated equality 
and inequality predicates under new names.
%}%

%%%% Definitions



%%% equality


%abbrev eq : gterm K -> gterm K -> type = gterm#eq.

%abbrev object`eq = eq.

%abbrev eq/ : eq X X = gterm#eq/.

%abbrev object`eq/ = eq/.


%abbrev predicate`eq : predicate T1 -> predicate T2 -> type = predicate#eq.

%abbrev predicate`eq/ : predicate`eq P P = predicate#eq/.


%abbrev predargs`eq : predargs T1 -> predargs T2 -> type = predargs#eq.

%abbrev predargs`eq/ : predargs`eq P P = predargs#eq/.



%%% inequality


%abbrev ne : gterm K -> gterm K -> type = gterm#ne.


%abbrev eq? : gterm K -> gterm K -> bool -> type = gterm#eq?.

%abbrev eq?/yes : eq? P P bool`true = gterm#eq?/yes.

%abbrev eq?/no : ne P1 P2 -> eq? P1 P2 bool`false = gterm#eq?/no.




%%%% Theorems



%%% equality


%theorem meta-eq : forall* {K} forall {P1:gterm K} {P2} {E:eq P1 P2} true.

- : meta-eq P P eq/.

%worlds () (meta-eq _ _ _).
%total { } (meta-eq _ _ _).
%reduces X = Y (meta-eq X Y _).


%abbrev false-implies-eq = false-implies-gterm#eq.


%theorem eq-reflexive :
        forall* {K}
        forall {P: gterm K}
        exists {D:eq P P}
        true.

- : eq-reflexive _ eq/.

%worlds () (eq-reflexive _ _).
%total { } (eq-reflexive _ _).


%theorem eq-symmetric :
        forall* {K} {P1:gterm K} {P2}
        forall {E:eq P1 P2}
        exists {F:eq P2 P1}
        true.

- : eq-symmetric (eq/) (eq/).

%worlds () (eq-symmetric _ _).
%total { } (eq-symmetric _ _).


%theorem eq-transitive :
        forall* {K} {P1:gterm K} {P2} {P3}
        forall {E1:eq P1 P2} {E2:eq P2 P3}
        exists {F:eq P1 P3}
        true.

- : eq-transitive (eq/) (eq/) (eq/).

%worlds () (eq-transitive _ _ _).
%total { } (eq-transitive _ _ _).


%theorem object-eq-implies-eq :
        forall* {N1} {N2}
        forall {OE:eq (object/ N1) (object/ N2)}
        exists {E:nat`eq N1 N2}
        true.

- : object-eq-implies-eq eq/ nat`eq/.

%worlds () (object-eq-implies-eq _ _).
%total { } (object-eq-implies-eq _ _).


%theorem object-preserves-eq :
        forall* {N1} {N2}
        forall {E:nat`eq N1 N2}
        exists {OE:eq (object/ N1) (object/ N2)}
        true.

- : object-preserves-eq nat`eq/ eq/.

%worlds () (object-preserves-eq _ _).
%total { } (object-preserves-eq _ _).


%theorem unit-eq-implies-eq :
        forall* {U1} {U2}
        forall {EU:eq U1 U2}
        exists {PU:eq (unitperm U1) (unitperm U2)}
        true.

- : unit-eq-implies-eq eq/ eq/.

%worlds () (unit-eq-implies-eq _ _).
%total { } (unit-eq-implies-eq _ _).



%%% Theorems about predicate`eq


%theorem predicate`meta-eq :
        forall* {K} {K2}
        forall  {P1:predicate K} {P2:predicate K2}
                {E:predicate`eq P1 P2}
        true.

- : predicate`meta-eq P P predicate`eq/.

%worlds () (predicate`meta-eq _ _ _).
%total { } (predicate`meta-eq _ _ _).
%reduces X = Y (predicate`meta-eq X Y _).


%abbrev predicate`false-implies-eq = false-implies-predicate#eq.


%theorem predicate`eq-reflexive :
        forall* {K}
        forall {P: predicate K}
        exists {D:predicate`eq P P}
        true.

- : predicate`eq-reflexive _ predicate`eq/.

%worlds () (predicate`eq-reflexive _ _).
%total { } (predicate`eq-reflexive _ _).


%theorem predicate`eq-symmetric :
        forall* {K} {P1:predicate K} {K2} {P2: predicate K2}
        forall {E:predicate`eq P1 P2}
        exists {F:predicate`eq P2 P1}
        true.

- : predicate`eq-symmetric (predicate`eq/) (predicate`eq/).

%worlds () (predicate`eq-symmetric _ _).
%total { } (predicate`eq-symmetric _ _).


%theorem predicate`eq-transitive :
        forall* {K} {P1:predicate K}
                {K2} {P2:predicate K2} {K3} {P3:predicate K3}
        forall {E1:predicate`eq P1 P2} {E2:predicate`eq P2 P3}
        exists {F:predicate`eq P1 P3}
        true.

- : predicate`eq-transitive (predicate`eq/) (predicate`eq/) (predicate`eq/).

%worlds () (predicate`eq-transitive _ _ _).
%total { } (predicate`eq-transitive _ _ _).



%%% Theorems about predargs`eq


%theorem predargs`meta-eq :
        forall* {K} {K2}
        forall  {P1:predargs K} {P2:predargs K2}
                {E:predargs`eq P1 P2}
        true.

- : predargs`meta-eq P P predargs`eq/.

%worlds () (predargs`meta-eq _ _ _).
%total { } (predargs`meta-eq _ _ _).
%reduces X = Y (predargs`meta-eq X Y _).


%abbrev predargs`false-implies-eq = false-implies-predargs#eq.


%theorem predargs`eq-reflexive :
        forall* {K}
        forall {P: predargs K}
        exists {D:predargs`eq P P}
        true.

- : predargs`eq-reflexive _ predargs`eq/.

%worlds () (predargs`eq-reflexive _ _).
%total { } (predargs`eq-reflexive _ _).


%theorem predargs`eq-symmetric :
        forall* {K} {P1:predargs K} {K2} {P2: predargs K2}
        forall {E:predargs`eq P1 P2}
        exists {F:predargs`eq P2 P1}
        true.

- : predargs`eq-symmetric (predargs`eq/) (predargs`eq/).

%worlds () (predargs`eq-symmetric _ _).
%total { } (predargs`eq-symmetric _ _).


%theorem predargs`eq-transitive :
        forall* {K} {P1:predargs K}
                {K2} {P2:predargs K2} {K3} {P3:predargs K3}
        forall {E1:predargs`eq P1 P2} {E2:predargs`eq P2 P3}
        exists {F:predargs`eq P1 P3}
        true.

- : predargs`eq-transitive (predargs`eq/) (predargs`eq/) (predargs`eq/).

%worlds () (predargs`eq-transitive _ _ _).
%total { } (predargs`eq-transitive _ _ _).



%%% inequality


%theorem false-implies-ne :
	forall*	{K} {T1:gterm K} {T2:gterm K}
	forall	{F:void}
	exists	{N:ne T1 T2}
	true.

%worlds () (false-implies-ne _ _).
%total { } (false-implies-ne _ _).


%abbrev eq-ne-implies-false = gterm#eq-ne-implies-false.


%theorem ne-anti-reflexive :
	forall* {K} {T:gterm K}
	forall	{N: ne T T}
	exists	{F: void}
	true.

- : ne-anti-reflexive N F
    <- eq-ne-implies-false eq/ N F.

%worlds () (ne-anti-reflexive _ _).
%total { } (ne-anti-reflexive _ _).


%theorem ne-symmetric :
	forall*	{K} {T1: gterm K} {T2: gterm K}
	forall	{N1: ne T1 T2}
	exists	{N2: ne T2 T1}
	true.

- : ne-symmetric (gterm#ne/ M1 M2 NE) (gterm#ne/ M2 M1 NEs)
    <- nat`ne-symmetric NE NEs.

%worlds () (ne-symmetric _ _).
%total { } (ne-symmetric _ _).


%abbrev eq?-total* = gterm#eq?-total*.

%abbrev eq?-total = eq?-total* _ _ _.

%%%%% permission-order.elf
%%%%% John Boyland
%%%%% March 2010

%{%
Arbitrary total permission ordering:
We use the generated file permisison-map.elf and provide
a facade over it.
%}%


%%%% Definitions


%%% ordering


%abbrev term2nat
   : gterm K -> nat -> type
   = [t] [n] gterm#map _ gterm#list/0 predicate#list/0 t n.

%abbrev
nat2term : nat -> gterm K -> type = [N] [P] term2nat P N.



prec : gterm K -> gterm K -> type.

prec/ : term2nat T1 N1 -> term2nat T2 N2 -> nat`gt N1 N2 -> prec T1 T2.



compare : gterm K -> gterm K -> comp -> type.


compare/< : prec T1 T2 -> compare T1 T2 less.

compare/= : compare T T equal.

compare/> : prec T2 T1 -> compare T1 T2 greater.



%%%% Theorems



%%% Theorems about term2nat :



%theorem false-implies-term2nat :
	forall* {K} {T:gterm K} {N}
	forall {F:void}
	exists {T2N:term2nat T N}
	true.

%worlds () (false-implies-term2nat _ _).
%total { } (false-implies-term2nat _ _).


%abbrev false-implies-not2term = false-implies-term2nat.


%theorem term2nat-respects-eq :
	forall* {K} {T1:gterm K} {N1} {T2:gterm K} {N2}
	forall {D1:term2nat T1 N1} {EP:eq T1 T2} {EN:nat`eq N1 N2}
	exists {D2:term2nat T2 N2}
	true.

- : term2nat-respects-eq T2N eq/ nat`eq/ T2N.

%worlds () (term2nat-respects-eq _ _ _ _).
%total { } (term2nat-respects-eq _ _ _ _).
%reduces D1 = D2 (term2nat-respects-eq D1 _ _ D2).


%abbrev nat2term-respects-eq :
	  (nat2term N1 T1) -> (nat`eq N1 N2) -> (eq T1 T2) -> (nat2term N2 T2)
        -> type
	= [D1] [EN] [EP] [D2] term2nat-respects-eq D1 EP EN D2.


%theorem term2nat-total* :
	forall* {K}
	forall {T:gterm K}
	exists {N:nat} {P2N:term2nat T N}
	true.

- : term2nat-total* _ _ TN
    <- gterm#map-total TN.

%worlds () (term2nat-total* _ _ _).
%total { } (term2nat-total* _ _ _).


%abbrev term2nat-total = term2nat-total* _ _.


%theorem nat2term-total* :
	forall* {K}
	forall {N:nat}
	exists {T:gterm K} {N2T:nat2term N T}
	true.

- : nat2term-total* _ _ TN
    <- gterm#map-onto _ _ TN.

%worlds () (nat2term-total* _ _ _).
%total { } (nat2term-total* _ _ _).


%abbrev nat2term-total = nat2term-total* _ _.


%theorem term2nat-deterministic :
	forall* {K} {T1:gterm K} {T2:gterm K} {N1} {N2}
	forall {D1:term2nat T1 N1} {D2:term2nat T2 N2}
	       {EP:eq T1 T2}
	exists {EN:nat`eq N1 N2}
	true.

- : term2nat-deterministic TN1 TN2 eq/ E
    <- gterm#map-deterministic TN1 TN2 gterm#eq/ E.

%worlds () (term2nat-deterministic _ _ _ _).
%total (D) (term2nat-deterministic D _ _ _).


%theorem nat2term-deterministic :
	forall* {K} {T1:gterm K} {T2:gterm K} {N1} {N2}
	forall {D1:nat2term N1 T1} {D2:nat2term N2 T2}	{EN:nat`eq N1 N2}
	exists {EP:eq T1 T2}
	true.

%theorem nat2term-deterministic/L :
	forall*	{K} {T1:gterm K} {T2: gterm K}
	forall	{ME: gterm#eq T1 T2}
	exists	{E: eq T1 T2}
	true.
- : nat2term-deterministic/L gterm#eq/ eq/.

%worlds () (nat2term-deterministic/L _ _).
%total { } (nat2term-deterministic/L _ _).

- : nat2term-deterministic TN1 TN2 nat`eq/ E
    <- gterm#map-one2one vark#eq/ TN1 TN2 nat`eq/ ME
    <- nat2term-deterministic/L ME E.

%worlds () (nat2term-deterministic _ _ _ _).
%total (D) (nat2term-deterministic D _ _ _).


%theorem term2nat-preserves-ne :
	forall* {K} {T1:gterm K} {T2:gterm K} {N1} {N2}
	forall	{D1:term2nat T1 N1} 
		{D2:term2nat T2 N2}
		{EP:ne T1 T2}
	exists	{EN:nat`ne N1 N2}
	true.

%theorem term2nat-preserves-ne/L :
	forall* {K} {T1:gterm K} {T2:gterm K} {N1} {N2} {B}
	forall	{D1:term2nat T1 N1} 
		{D2:term2nat T2 N2}
		{EP:ne T1 T2}
		{QP:nat`eq? N1 N2 B}
	exists	{EN:nat`ne N1 N2}
	true.

- : term2nat-preserves-ne/L _ _ _ (nat`eq?/no NE) NE.

- : term2nat-preserves-ne/L D1 D2 NP (nat`eq?/yes) NE
    <- nat2term-deterministic D1 D2 nat`eq/ EP
    <- eq-ne-implies-false EP NP F
    <- nat`false-implies-ne F NE.

%worlds () (term2nat-preserves-ne/L _ _ _ _ _).
%total { } (term2nat-preserves-ne/L _ _ _ _ _).

- : term2nat-preserves-ne D1 D2 NP NE
    <- nat`eq?-total QP
    <- term2nat-preserves-ne/L D1 D2 NP QP NE.

%worlds () (term2nat-preserves-ne _ _ _ _).
%total { } (term2nat-preserves-ne _ _ _ _).


%theorem nat2term-preserves-ne :
	forall* {K} {T1:gterm K} {T2:gterm K} {N1} {N2}
	forall	{D1:nat2term N1 T1} 
		{D2:nat2term N2 T2}
		{EN:nat`ne N1 N2}
	exists	{EP:ne T1 T2}
	true.

%theorem nat2term-preserves-ne/L :
	forall* {K} {T1:gterm K} {T2:gterm K} {N1} {N2} {B}
	forall	{D1:nat2term N1 T1} 
		{D2:nat2term N2 T2}
		{EN:nat`ne N1 N2}
		{QP:eq? T1 T2 B}
	exists	{EP:ne T1 T2}
	true.

- : nat2term-preserves-ne/L _ _ _ (eq?/no NE) NE.

- : nat2term-preserves-ne/L D1 D2 NP (eq?/yes) NE
    <- term2nat-deterministic D1 D2 eq/ EP
    <- nat`eq-ne-implies-false EP NP F
    <- false-implies-ne F NE.

%worlds () (nat2term-preserves-ne/L _ _ _ _ _).
%total { } (nat2term-preserves-ne/L _ _ _ _ _).

- : nat2term-preserves-ne D1 D2 NP NE
    <- eq?-total QP
    <- nat2term-preserves-ne/L D1 D2 NP QP NE.

%worlds () (nat2term-preserves-ne _ _ _ _).
%total { } (nat2term-preserves-ne _ _ _ _).



%%% Theorems about prec


%theorem prec-anti-reflexive :
	forall* {K} {T:gterm K}
	forall {P: prec T T}
	exists {F:void}
	true.
	
- : prec-anti-reflexive (prec/ T->N1 T->N2 N1>N2) F
    <- term2nat-deterministic T->N1 T->N2 eq/ N1=N2
    <- nat`gt-respects-eq N1>N2 N1=N2 nat`eq/ N2>N2
    <- nat`gt-anti-reflexive N2>N2 F.

%worlds () (prec-anti-reflexive _ _).
%total { } (prec-anti-reflexive _ _).


%theorem prec-anti-symmetric :
	forall* {K} {T1:gterm K} {T2:gterm K}
	forall {P1:prec T1 T2} {P2:prec T2 T1}
	exists {F:void}
	true.

- : prec-anti-symmetric (prec/ T1->N1 T2->N2 N1>N2)
                        (prec/ T2->N2' T1->N1' N2'>N1') F
    <- term2nat-deterministic T1->N1' T1->N1 eq/ N1'=N1 
    <- term2nat-deterministic T2->N2' T2->N2 eq/ N2'=N2 
    <- nat`gt-respects-eq N2'>N1' N2'=N2 N1'=N1 N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F.

%worlds () (prec-anti-symmetric _ _ _).
%total { } (prec-anti-symmetric _ _ _).


%theorem prec-transitive :
	forall* {K} {T1:gterm K} {T2:gterm K} {T3:gterm K}
	forall {P12:prec T1 T2} {P23:prec T2 T3}
	exists {P13:prec T1 T3}
	true.

- : prec-transitive (prec/ T1->N1 T2->N2 N1>N2)
                    (prec/ T2->N2' T3->N3 N2'>N3)
                    (prec/ T1->N1 T3->N3 N1>N3)
    <- term2nat-deterministic T2->N2' T2->N2 eq/ N2'=N2 
    <- nat`gt-respects-eq N2'>N3 N2'=N2 nat`eq/ N2>N3
    <- nat`gt-transitive N1>N2 N2>N3 N1>N3.
    
%worlds () (prec-transitive _ _ _).
%total { } (prec-transitive _ _ _).



%%% Theorems about compare


%theorem compare-respects-eq :
	forall* {K} {T1:gterm K} {T2:gterm K} {T1':gterm K} {T2':gterm K} {C}
	forall {CMP:compare T1 T2 C} {E1:eq T1 T1'} {E2:eq T2 T2'}
	exists {CMP':compare T1' T2' C}
	true.

- : compare-respects-eq CMP eq/ eq/ CMP.

%worlds () (compare-respects-eq _ _ _ _).
%total { } (compare-respects-eq _ _ _ _).

	 
%theorem compare-total* :
	forall* {K} 
	forall {T1:gterm K} {T2:gterm K}
	exists {C} {CMP:compare T1 T2 C}
	true.

%theorem compare-total*/L :
	forall* {K} {T1:gterm K} {T2:gterm K} {N1} {N2} {C}
	forall {T1->N1:term2nat T1 N1} {T2->N2:term2nat T2 N2}
               {NCMP:nat`compare N2 N1 C}
	exists {CMP:compare T1 T2 C}
	true.

- : compare-total*/L T1->N1 T2->N2 (nat`compare/< N1>N2)
                     (compare/< (prec/ T1->N1 T2->N2 N1>N2)).

- : compare-total*/L T1->N1 T2->N2 (nat`compare/> N2>N1)
		     (compare/> (prec/ T2->N2 T1->N1 N2>N1)).

- : compare-total*/L T1->N T2->N (nat`compare/=) CMP
    <- nat2term-deterministic T1->N T2->N nat`eq/ T1=T2
    <- compare-respects-eq compare/= eq/ T1=T2 CMP.

- : compare-total* _ _ _ CMP
    <- term2nat-total T1->N1
    <- term2nat-total T2->N2
    <- nat`compare-total NCMP
    <- compare-total*/L T1->N1 T2->N2 NCMP CMP.

%worlds () (compare-total*/L _ _ _ _).
%total { } (compare-total*/L _ _ _ _).

%worlds () (compare-total* _ _ _ _).
%total { } (compare-total* _ _ _ _).


%abbrev compare-total = compare-total* _ _ _.

%%%% Equivalence



%%%% Definitions



%%% equivalence


equiv : permission -> permission -> type.


equiv/identity : equiv (Pi , empty) Pi.

equiv/commute : equiv (Pi1 , Pi2) (Pi2 , Pi1).

equiv/associate : equiv (Pi1 , (Pi2 , Pi3)) ((Pi1 , Pi2), Pi3).

equiv/combine : (equiv Pi1 Pi1') -> (equiv Pi2 Pi2') -> 
	(equiv (Pi1 , Pi2) (Pi1' , Pi2')).

equiv/zero : equiv (scale Q empty) empty.

equiv/one : equiv (scale (fraction/ rat`one) Pi) Pi.

equiv/distribute : equiv (scale Q (Pi1 , Pi2)) ((scale Q Pi1) , (scale Q Pi2)).

equiv/mul : (rat`mul Q1 Q2 Q3) -> 
    equiv (scale (fraction/ Q1) (scale (fraction/ Q2) Pi)) 
          (scale (fraction/ Q3) Pi).

equiv/add : (rat`add Q1 Q2 Q3) -> 
	equiv (scale (fraction/ Q1) Pi , scale (fraction/ Q2) Pi) 
              (scale (fraction/ Q3) Pi).


equiv/reflexive : equiv Pi Pi.

equiv/symmetric : equiv Pi1 Pi2 -> equiv Pi2 Pi1.

equiv/transitive : equiv Pi1 Pi2 -> equiv Pi2 Pi3 -> equiv Pi1 Pi3.


%%% Abbrevations/shortcuts for standard equivalences

%abbrev equiv/transitive2 = equiv/transitive.

%abbrev equiv/transitive3 = 
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] [EQ34:equiv Pi3 Pi4]
	(equiv/transitive EQ12 (equiv/transitive EQ23 EQ34)).

%abbrev equiv/transitive4 = 
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] 
        [EQ34:equiv Pi3 Pi4] [EQ45:equiv Pi4 Pi5]
	(equiv/transitive (equiv/transitive EQ12 EQ23)
                          (equiv/transitive EQ34 EQ45)).

%abbrev equiv/transitive5 =
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] 
        [EQ34:equiv Pi3 Pi4] [EQ45:equiv Pi4 Pi5] [EQ56:equiv Pi5 Pi6]
	(equiv/transitive (equiv/transitive2 EQ12 EQ23)
                          (equiv/transitive3 EQ34 EQ45 EQ56)).

%abbrev equiv/transitive6 =
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] [EQ34:equiv Pi3 Pi4] 
	[EQ45:equiv Pi4 Pi5] [EQ56:equiv Pi5 Pi6] [EQ67:equiv Pi6 Pi7]
	(equiv/transitive (equiv/transitive3 EQ12 EQ23 EQ34)
                          (equiv/transitive3 EQ45 EQ56 EQ67)).

%abbrev equiv/transitive7 =
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] [EQ34:equiv Pi3 Pi4] 
	[EQ45:equiv Pi4 Pi5] [EQ56:equiv Pi5 Pi6] [EQ67:equiv Pi6 Pi7]
        [EQ78:equiv Pi7 Pi8]
	(equiv/transitive (equiv/transitive3 EQ12 EQ23 EQ34)
                          (equiv/transitive4 EQ45 EQ56 EQ67 EQ78)).

%abbrev equiv/transitive8 =
	[EQ12:equiv Pi1 Pi2] [EQ23:equiv Pi2 Pi3] [EQ34:equiv Pi3 Pi4] 
	[EQ45:equiv Pi4 Pi5] [EQ56:equiv Pi5 Pi6] [EQ67:equiv Pi6 Pi7]
        [EQ78:equiv Pi7 Pi8] [EQ89:equiv Pi8 Pi9]
	(equiv/transitive (equiv/transitive4 EQ12 EQ23 EQ34 EQ45)
                          (equiv/transitive4 EQ56 EQ67 EQ78 EQ89)).

%abbrev equiv/reorder :
	equiv (A , (B , REST)) (B , (A , REST)) =
	(equiv/transitive3
	   equiv/associate
	   (equiv/combine equiv/commute equiv/reflexive)
	   (equiv/symmetric equiv/associate)).

%abbrev equiv/double-associate =
        (equiv/transitive5
	   (equiv/combine equiv/commute equiv/reflexive)
	   equiv/associate
	   (equiv/combine (equiv/symmetric equiv/associate) equiv/reflexive)
	   (equiv/combine equiv/commute equiv/reflexive)
	   (equiv/symmetric equiv/associate)).

%abbrev equiv/roll2 : equiv (A1 , (A2 , C)) (A2 , (A1 , C))		   
	= equiv/reorder.

%abbrev equiv/roll3 : equiv (A1 , (A2 , (A3 , C))) (A3 , (A1 , (A2 , C)))
	= (equiv/transitive
	     (equiv/combine equiv/reflexive equiv/roll2)
	     equiv/roll2).

%abbrev equiv/roll4 : equiv (A1 , (A2 , (A3 , (A4 , C)))) 
                            (A4 , (A1 , (A2 , (A3 , C))))
	= (equiv/transitive
	     (equiv/combine equiv/reflexive equiv/roll3)
	     equiv/roll2).

%abbrev equiv/roll5 : equiv (A1 , (A2 , (A3 , (A4 , (A5 , C)))))
                            (A5 , (A1 , (A2 , (A3 , (A4 , C)))))
	= (equiv/transitive
	     (equiv/combine equiv/reflexive equiv/roll4)
	     equiv/roll2).

%abbrev equiv/roll6 : equiv (A1 , (A2 , (A3 , (A4 , (A5 , (A6 , C))))))
                            (A6 , (A1 , (A2 , (A3 , (A4 , (A5 , C))))))
	= (equiv/transitive
	     (equiv/combine equiv/reflexive equiv/roll5)
	     equiv/roll2).

%abbrev equiv/roll7 : equiv (A1 , (A2 , (A3 , (A4 , (A5 , (A6 , (A7 , C)))))))
                            (A7 , (A1 , (A2 , (A3 , (A4 , (A5 , (A6 , C)))))))
	= (equiv/transitive
	     (equiv/combine equiv/reflexive equiv/roll6)
	     equiv/roll2).



%%% Special case for equivalence to the empty permission


null : permission -> type.


null/0 : null empty.

null/* : null Pi -> null (scale Q Pi).

null/+ : null Pi1 -> null Pi2 -> null (Pi1 , Pi2).



nonnull : permission -> rat -> type.


nonnull/scale : 
	nonnull Pi Q2 ->
	rat`mul Q1 Q2 Q3 ->
    nonnull (scale (fraction/ Q1) Pi) Q3.

nonnull/combine/1 : 
	nonnull Pi1 Q ->
	null Pi2 ->
    nonnull (Pi1 , Pi2) Q.

nonnull/combine/2 :
	null Pi1 ->
	nonnull Pi2 Q ->
    nonnull (Pi1 , Pi2) Q.

nonnull/combine/1+2 :
	nonnull Pi1 Q1 ->
	nonnull Pi2 Q2 ->
	rat`add Q1 Q2 Q3 ->
    nonnull (Pi1 , Pi2) Q3.

nonnull/unit : nonnull (unitperm _) rat`one.



null? : permission -> bool -> type.


null?/yes : null Pi -> null? Pi true.

null?/no : nonnull Pi Q -> null? Pi false.



%%% containment


leq : permission -> permission -> type.


leq/ : equiv (Pi1 , Pi2) Pi3 -> leq Pi1 Pi3.




%%%% Theorems



%%% Theorems about equiv


%theorem false-implies-equiv :
	forall* {Pi1} {Pi2}
	forall {F:void}
	exists {EQ:equiv Pi1 Pi2}
	true.

%worlds () (false-implies-equiv _ _).
%total { } (false-implies-equiv _ _).


%theorem equiv-respects-eq :
	forall* {Pi1} {Pi1'} {Pi2} {Pi2'}
	forall {E1:equiv Pi1 Pi1'} {E:eq Pi1 Pi2} {E':eq Pi1' Pi2'}
	exists {E2:equiv Pi2 Pi2'}
	true.

- : equiv-respects-eq EQ eq/ eq/ EQ.

%worlds () (equiv-respects-eq _ _ _ _).
%total { } (equiv-respects-eq _ _ _ _).


%% The following three theorems are included for completeness.

%theorem equiv-reflexive :
	forall {Pi}
	exists {EQ:equiv Pi Pi}
	true.

- : equiv-reflexive _ equiv/reflexive.

%worlds () (equiv-reflexive _ _).
%total { } (equiv-reflexive _ _).


%theorem equiv-symmetric :
	forall* {Pi1} {Pi2}
	forall {E12:equiv Pi1 Pi2}
	exists {E21:equiv Pi2 Pi1}
	true.

- : equiv-symmetric E12 (equiv/symmetric E12).

%worlds () (equiv-symmetric _ _).
%total { } (equiv-symmetric _ _).


%theorem equiv-transitive :
	forall* {Pi1} {Pi2} {Pi3}
	forall {E12:equiv Pi1 Pi2} {E23:equiv Pi2 Pi3}
	exists {E23:equiv Pi1 Pi3}
	true.

- : equiv-transitive E12 E23 (equiv/transitive E12 E23).

%worlds () (equiv-transitive _ _ _).
%total { } (equiv-transitive _ _ _).


%theorem equiv/frac-admissible :
	forall* {Pi1} {Pi2} {F}
	forall {EQ: equiv Pi1 Pi2}
	exists {EQF: equiv (scale F Pi1) (scale F Pi2)}
	true.

- : equiv/frac-admissible equiv/identity
	(equiv/transitive3
	  equiv/distribute
          (equiv/combine equiv/reflexive equiv/zero)
          equiv/identity).

- : equiv/frac-admissible equiv/commute
	(equiv/transitive3
	  equiv/distribute 
          equiv/commute
	  (equiv/symmetric equiv/distribute)).

- : equiv/frac-admissible equiv/associate
	(equiv/transitive5
	  equiv/distribute 
          (equiv/combine equiv/reflexive equiv/distribute)
          equiv/associate
	  (equiv/combine (equiv/symmetric equiv/distribute) equiv/reflexive)
          (equiv/symmetric equiv/distribute)).

- : equiv/frac-admissible (equiv/combine Pi1->Pi1' Pi2->Pi2')
	(equiv/transitive3
	  equiv/distribute 
          (equiv/combine QPi1->QPi1' QPi2->QPi2')
          (equiv/symmetric equiv/distribute))
    <- equiv/frac-admissible Pi1->Pi1' QPi1->QPi1'
    <- equiv/frac-admissible Pi2->Pi2' QPi2->QPi2'.

- : equiv/frac-admissible equiv/zero
	(equiv/transitive3
	  (equiv/mul Q1*Q2=Q3)
          equiv/zero
          (equiv/symmetric equiv/zero))
    <- rat`mul-total Q1*Q2=Q3.

- : equiv/frac-admissible equiv/one (equiv/mul Q*1=Q)
    <- rat`mul-right-identity _ Q*1=Q.

- : equiv/frac-admissible equiv/distribute
	(equiv/transitive4
	  (equiv/mul Q1*Q2=Q3)
	  equiv/distribute
          (equiv/combine (equiv/symmetric (equiv/mul Q1*Q2=Q3))
                         (equiv/symmetric (equiv/mul Q1*Q2=Q3)))
          (equiv/symmetric equiv/distribute))
    <- rat`mul-total Q1*Q2=Q3.

- : equiv/frac-admissible (equiv/mul Q2*Q4=Q6)
	(equiv/transitive3
	  (equiv/mul Q1*Q2=Q3)
	  (equiv/mul Q3*Q4=Q7)
	  (equiv/symmetric (equiv/mul Q1*Q6=Q7)))
    <- rat`mul-total Q1*Q2=Q3
    <- rat`mul-total Q3*Q4=Q7
    <- rat`mul-associative* Q1*Q2=Q3 Q3*Q4=Q7 Q2*Q4=Q6 Q1*Q6=Q7.

- : equiv/frac-admissible (equiv/add Q2+Q4=Q6)
	(equiv/transitive4
	  equiv/distribute
	  (equiv/combine (equiv/mul Q1*Q2=Q3) (equiv/mul Q1*Q4=Q5))
	  (equiv/add Q3+Q5=Q7)
          (equiv/symmetric (equiv/mul Q1*Q6=Q7)))
    <- rat`mul-total Q1*Q2=Q3
    <- rat`mul-total Q1*Q4=Q5
    <- rat`add-total Q3+Q5=Q7
    <- rat`mul-left-factors-over-add* Q1*Q2=Q3 Q1*Q4=Q5 Q3+Q5=Q7 Q2+Q4=Q6 
                                      Q1*Q6=Q7.

- : equiv/frac-admissible equiv/reflexive equiv/reflexive.

- : equiv/frac-admissible (equiv/symmetric Pi1->Pi2) 
	(equiv/symmetric QPi1->QPi2)
    <- equiv/frac-admissible Pi1->Pi2 QPi1->QPi2.

- : equiv/frac-admissible (equiv/transitive Pi1->Pi2 Pi2->Pi3)
	(equiv/transitive QPi1->QPi2 QPi2->QPi3)
    <- equiv/frac-admissible Pi1->Pi2 QPi1->QPi2
    <- equiv/frac-admissible Pi2->Pi3 QPi2->QPi3.

%worlds () (equiv/frac-admissible _ _).
%total (E) (equiv/frac-admissible E _).
   

%%% Theorems about null


%theorem false-implies-null :
	forall* {Pi}
	forall {F:void}
	exists {N:null Pi}
	true.

%worlds () (false-implies-null _ _).
%total { } (false-implies-null _ _).


%theorem null-implies-equiv-empty :
	forall* {Pi}
	forall {EE:null Pi} 
	exists {E:equiv Pi empty}
	true.

- : null-implies-equiv-empty null/0 equiv/reflexive.

- : null-implies-equiv-empty (null/* EE) QPi=0
    <- null-implies-equiv-empty EE Pi=0
    <- equiv/frac-admissible Pi=0 QPi=Q0
    <- equiv-transitive QPi=Q0 equiv/zero QPi=0.

- : null-implies-equiv-empty (null/+ E1 E2) 
	(equiv/transitive (equiv/combine Pi1=0 Pi2=0) equiv/identity)
    <- null-implies-equiv-empty E1 Pi1=0
    <- null-implies-equiv-empty E2 Pi2=0.

%worlds () (null-implies-equiv-empty _ _).
%total (E) (null-implies-equiv-empty E _).


%theorem equiv-preserves-null :
	forall* {Pi1} {Pi2}
	forall {N1:null Pi1} {E:equiv Pi1 Pi2} 
	exists {N2:null Pi2}
	true.

%theorem equiv-preserves-null-converse :
	forall* {Pi1} {Pi2}
	forall {N2:null Pi2} {E:equiv Pi1 Pi2} 
	exists {N1:null Pi1}
	true.

- : equiv-preserves-null (null/+ Pi=0 _) equiv/identity Pi=0.

- : equiv-preserves-null (null/+ Pi1=0 Pi2=0) equiv/commute 
                         (null/+ Pi2=0 Pi1=0).

- : equiv-preserves-null (null/+ Pi1=0 (null/+ Pi2=0 Pi3=0)) equiv/associate
			 (null/+ (null/+ Pi1=0 Pi2=0) Pi3=0).

- : equiv-preserves-null (null/+ Pi1=0 Pi2=0) (equiv/combine E1 E2)
                         (null/+ Pi1'=0 Pi2'=0)
    <- equiv-preserves-null Pi1=0 E1 Pi1'=0
    <- equiv-preserves-null Pi2=0 E2 Pi2'=0.

- : equiv-preserves-null (null/* _) equiv/zero null/0.

- : equiv-preserves-null (null/* Pi=0) equiv/one Pi=0.

- : equiv-preserves-null (null/* (null/+ Pi1=0 Pi2=0)) equiv/distribute
			 (null/+ (null/* Pi1=0) (null/* Pi2=0)).

- : equiv-preserves-null (null/* (null/* Pi=0)) (equiv/mul _)
			 (null/* Pi=0).

- : equiv-preserves-null (null/+ (null/* Pi=0) (null/* _)) (equiv/add _)
			 (null/* Pi=0).

- : equiv-preserves-null Pi=0 equiv/reflexive Pi=0.

- : equiv-preserves-null Pi1=0 (equiv/symmetric Pi2=Pi1) Pi2=0
    <- equiv-preserves-null-converse Pi1=0 Pi2=Pi1 Pi2=0.

- : equiv-preserves-null Pi1=0 (equiv/transitive Pi1=Pi2 Pi2=Pi3) Pi3=0
    <- equiv-preserves-null Pi1=0 Pi1=Pi2 Pi2=0
    <- equiv-preserves-null Pi2=0 Pi2=Pi3 Pi3=0.

- : equiv-preserves-null-converse Pi=0 equiv/identity (null/+ Pi=0 null/0).

- : equiv-preserves-null-converse (null/+ Pi2=0 Pi1=0) equiv/commute 
                                  (null/+ Pi1=0 Pi2=0).

- : equiv-preserves-null-converse 
	(null/+ (null/+ Pi1=0 Pi2=0) Pi3=0) equiv/associate
	(null/+ Pi1=0 (null/+ Pi2=0 Pi3=0)).

- : equiv-preserves-null-converse (null/+ Pi1'=0 Pi2'=0) (equiv/combine E1 E2)
                                  (null/+ Pi1=0 Pi2=0)
    <- equiv-preserves-null-converse Pi1'=0 E1 Pi1=0
    <- equiv-preserves-null-converse Pi2'=0 E2 Pi2=0.

- : equiv-preserves-null-converse null/0 equiv/zero (null/* null/0).

- : equiv-preserves-null-converse Pi=0 equiv/one (null/* Pi=0).

- : equiv-preserves-null-converse 
	(null/+ (null/* Pi1=0) (null/* Pi2=0)) equiv/distribute
	(null/* (null/+ Pi1=0 Pi2=0)).

- : equiv-preserves-null-converse (null/* Pi=0) (equiv/mul _) 
			          (null/* (null/* Pi=0)) .

- : equiv-preserves-null-converse (null/* Pi=0) (equiv/add _) 
			          (null/+ (null/* Pi=0) (null/* Pi=0)).

- : equiv-preserves-null-converse Pi=0 equiv/reflexive Pi=0.

- : equiv-preserves-null-converse Pi1=0 (equiv/symmetric Pi2=Pi1) Pi2=0
    <- equiv-preserves-null Pi1=0 Pi2=Pi1 Pi2=0.

- : equiv-preserves-null-converse Pi3=0 (equiv/transitive Pi1=Pi2 Pi2=Pi3) Pi1=0
    <- equiv-preserves-null-converse Pi3=0 Pi2=Pi3 Pi2=0
    <- equiv-preserves-null-converse Pi2=0 Pi1=Pi2 Pi1=0.


%worlds () (equiv-preserves-null _ _ _) 
	   (equiv-preserves-null-converse _ _ _).

%total (E ER) (equiv-preserves-null _ E _) 
	      (equiv-preserves-null-converse _ ER _).


%theorem equiv-empty-implies-null :
	forall* {Pi}
	forall {E:equiv Pi empty}
	exists {EE:null Pi} 
	true.

- : equiv-empty-implies-null Pi=0 N
    <- equiv-preserves-null-converse null/0 Pi=0 N.

%worlds () (equiv-empty-implies-null _ _).
%total { } (equiv-empty-implies-null _ _).



%%% theorems for nonnull


%theorem false-implies-nonnull :
	forall* {Pi} {Q}
	forall {F:void}
	exists {N:nonnull Pi Q}
	true.

%worlds () (false-implies-nonnull _ _).
%total { } (false-implies-nonnull _ _).


%theorem nonnull-respects-equ :
	forall* {Pi} {Q1} {Q2}
	forall {N1:nonnull Pi Q1} {E:equ Q1 Q2}
	exists {N2:nonnull Pi Q2}
	true.

- : nonnull-respects-equ N equ/ N.

%worlds () (nonnull-respects-equ _ _ _).
%total { } (nonnull-respects-equ _ _ _).


%theorem null-nonnull-contradiction :
	forall* {Pi} {Q}
	forall {N:null Pi} {NN:nonnull Pi Q}
	exists {F:void}
	true.

- : null-nonnull-contradiction (null/* Pi#0) (nonnull/scale Pi#Q _) F
    <- null-nonnull-contradiction Pi#0 Pi#Q F.

- : null-nonnull-contradiction (null/+ Pi#0 _) (nonnull/combine/1 Pi#Q _) F
    <- null-nonnull-contradiction Pi#0 Pi#Q F.

- : null-nonnull-contradiction (null/+ _ Pi#0) (nonnull/combine/2 _ Pi#Q) F
    <- null-nonnull-contradiction Pi#0 Pi#Q F.

- : null-nonnull-contradiction (null/+ Pi#0 _) (nonnull/combine/1+2 Pi#Q _ _) F
    <- null-nonnull-contradiction Pi#0 Pi#Q F.

%worlds () (null-nonnull-contradiction _ _ _).
%total (N) (null-nonnull-contradiction N _ _).


%theorem nonnull-deterministic :
	forall* {Pi} {Q1} {Q2}
	forall {NN1:nonnull Pi Q1}
	       {NN2:nonnull Pi Q2}
	exists {E:equ Q1 Q2}
	true.

- : nonnull-deterministic (nonnull/combine/1 Pi#Q _)
			  (nonnull/combine/1 Pi#Q' _) Q=Q'
    <- nonnull-deterministic Pi#Q Pi#Q' Q=Q'.

- : nonnull-deterministic (nonnull/combine/1 Pi#Q _) 
			  (nonnull/combine/2 Pi#0 _) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/1 _ Pi#0) 
			  (nonnull/combine/1+2 _ Pi#Q _) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/2 Pi#0 _) 
			  (nonnull/combine/1 Pi#Q _) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/2 _ Pi#Q)
			  (nonnull/combine/2 _ Pi#Q') Q=Q'
    <- nonnull-deterministic Pi#Q Pi#Q' Q=Q'.

- : nonnull-deterministic (nonnull/combine/2 Pi#0 _) 
			  (nonnull/combine/1+2 Pi#Q _ _) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/1+2 _ Pi#Q _)
			  (nonnull/combine/1 _ Pi#0) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/1+2 Pi#Q _ _)
			  (nonnull/combine/2 Pi#0 _) E
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-equ F E.

- : nonnull-deterministic (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3)
                          (nonnull/combine/1+2 Pi1#Q4 Pi2#Q5 Q4+Q5=Q6) Q3=Q6
    <- nonnull-deterministic Pi1#Q1 Pi1#Q4 Q1=Q4
    <- nonnull-deterministic Pi2#Q2 Pi2#Q5 Q2=Q5
    <- rat`add-deterministic Q1+Q2=Q3 Q4+Q5=Q6 Q1=Q4 Q2=Q5 Q3=Q6.

- : nonnull-deterministic (nonnull/scale Pi#Q2 Q1*Q2=Q3) 
                          (nonnull/scale Pi#Q4 Q1*Q4=Q5) Q3=Q5
    <- nonnull-deterministic Pi#Q2 Pi#Q4 Q2=Q4
    <- rat`mul-deterministic Q1*Q2=Q3 Q1*Q4=Q5 equ/ Q2=Q4 Q3=Q5.

- : nonnull-deterministic nonnull/unit nonnull/unit equ/.

%worlds () (nonnull-deterministic _ _ _).
%total (N) (nonnull-deterministic N _ _).


%theorem equiv-preserves-nonnull :
	forall* {Pi1} {Q} {Pi2}
	forall {N:nonnull Pi1 Q} {E:equiv Pi1 Pi2}
	exists {N:nonnull Pi2 Q}
	true.

%theorem equiv-preserves-nonnull-converse :
	forall* {Pi1} {Q} {Pi2}
	forall {N:nonnull Pi2 Q} {E:equiv Pi1 Pi2}
	exists {N:nonnull Pi1 Q}
	true.

- : equiv-preserves-nonnull (nonnull/combine/1 Pi#Q null/0) equiv/identity Pi#Q.

- : equiv-preserves-nonnull (nonnull/combine/1 Pi1#Q Pi2#0) equiv/commute
                            (nonnull/combine/2 Pi2#0 Pi1#Q).

- : equiv-preserves-nonnull (nonnull/combine/2 Pi1#0 Pi2#Q) equiv/commute
			    (nonnull/combine/1 Pi2#Q Pi1#0).

- : equiv-preserves-nonnull (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) 
                            equiv/commute
			    (nonnull/combine/1+2 Pi2#Q2 Pi1#Q1 Q2+Q1=Q3)
    <- rat`add-commutative Q1+Q2=Q3 Q2+Q1=Q3.

- : equiv-preserves-nonnull 
	(nonnull/combine/1 Pi1#Q (null/+ Pi2#0 Pi3#0)) equiv/associate
	(nonnull/combine/1 (nonnull/combine/1 Pi1#Q Pi2#0) Pi3#0).

- : equiv-preserves-nonnull 
	(nonnull/combine/2 Pi1#0 (nonnull/combine/1 Pi2#Q Pi3#0)) 
        equiv/associate 
	(nonnull/combine/1 (nonnull/combine/2 Pi1#0 Pi2#Q) Pi3#0).

- : equiv-preserves-nonnull
	(nonnull/combine/2 Pi1#0 (nonnull/combine/2 Pi2#0 Pi3#Q)) 
        equiv/associate 
	(nonnull/combine/2 (null/+ Pi1#0 Pi2#0) Pi3#Q).

- : equiv-preserves-nonnull
	(nonnull/combine/2 Pi1#0 (nonnull/combine/1+2 Pi2#Q2 Pi3#Q3 Q2+Q3=Q5)) 
	equiv/associate
	(nonnull/combine/1+2 (nonnull/combine/2 Pi1#0 Pi2#Q2) Pi3#Q3 Q2+Q3=Q5).

- : equiv-preserves-nonnull
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/1 Pi2#Q2 Pi4#0) Q1+Q2=Q3)
        equiv/associate
	(nonnull/combine/1 (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) Pi4#0).

- : equiv-preserves-nonnull
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/2 Pi2#0 Pi4#Q4) Q1+Q4=Q5)
        equiv/associate
	(nonnull/combine/1+2 (nonnull/combine/1 Pi1#Q1 Pi2#0) Pi4#Q4 Q1+Q4=Q5).

- : equiv-preserves-nonnull
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/1+2 Pi2#Q2 Pi4#Q4 Q2+Q4=Q6)
                             Q1+Q6=Q7) equiv/associate
        (nonnull/combine/1+2 (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3)
			     Pi4#Q4 Q3+Q4=Q7)
    <- rat`add-total Q1+Q2=Q3
    <- rat`add-associative-converse* Q2+Q4=Q6 Q1+Q6=Q7 Q1+Q2=Q3 Q3+Q4=Q7.

- : equiv-preserves-nonnull (nonnull/combine/1 Pi1#Q Pi2#0) 
			    (equiv/combine Pi1->Pi1' Pi2->Pi2')
			    (nonnull/combine/1 Pi1'#Q Pi2'#0)
    <- equiv-preserves-nonnull Pi1#Q Pi1->Pi1' Pi1'#Q
    <- equiv-preserves-null Pi2#0 Pi2->Pi2' Pi2'#0.

- : equiv-preserves-nonnull (nonnull/combine/2 Pi1#0 Pi2#Q) 
			    (equiv/combine Pi1->Pi1' Pi2->Pi2')
			    (nonnull/combine/2 Pi1'#0 Pi2'#Q)
    <- equiv-preserves-null Pi1#0 Pi1->Pi1' Pi1'#0
    <- equiv-preserves-nonnull Pi2#Q Pi2->Pi2' Pi2'#Q.

- : equiv-preserves-nonnull (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) 
			    (equiv/combine Pi1->Pi1' Pi2->Pi2')
			    (nonnull/combine/1+2 Pi1'#Q1 Pi2'#Q2 Q1+Q2=Q3)
    <- equiv-preserves-nonnull Pi1#Q1 Pi1->Pi1' Pi1'#Q1
    <- equiv-preserves-nonnull Pi2#Q2 Pi2->Pi2' Pi2'#Q2.

- : equiv-preserves-nonnull (nonnull/scale Pi#Q _) equiv/zero NN
    <- null-nonnull-contradiction null/0 Pi#Q F
    <- false-implies-nonnull F NN.

- : equiv-preserves-nonnull (nonnull/scale Pi#Q2 ONE*Q2=Q3) equiv/one Pi#Q3
    <- rat`mul-left-identity _ ONE*Q2=Q2
    <- rat`mul-deterministic ONE*Q2=Q2 ONE*Q2=Q3 equ/ equ/ Q2=Q3
    <- nonnull-respects-equ Pi#Q2 Q2=Q3 Pi#Q3.

- : equiv-preserves-nonnull 
	(nonnull/scale (nonnull/combine/1 Pi1#Q2 Pi2#0) Q1*Q2=Q3)
	equiv/distribute
	(nonnull/combine/1 (nonnull/scale Pi1#Q2 Q1*Q2=Q3) (null/* Pi2#0)).

- : equiv-preserves-nonnull 
	(nonnull/scale (nonnull/combine/2 Pi1#0 Pi2#Q4) Q1*Q4=Q5)
	equiv/distribute
	(nonnull/combine/2 (null/* Pi1#0) (nonnull/scale Pi2#Q4 Q1*Q4=Q5)).

- : equiv-preserves-nonnull
	(nonnull/scale (nonnull/combine/1+2 Pi1#Q2 Pi2#Q4 Q2+Q4=Q6) Q1*Q6=Q7)
	equiv/distribute
	(nonnull/combine/1+2 (nonnull/scale Pi1#Q2 Q1*Q2=Q3)
			     (nonnull/scale Pi2#Q4 Q1*Q4=Q5) Q3+Q5=Q7)
    <- rat`mul-left-distributes-over-add Q2+Q4=Q6 Q1*Q6=Q7 _ _ 
					 Q1*Q2=Q3 Q1*Q4=Q5 Q3+Q5=Q7.

- : equiv-preserves-nonnull
	(nonnull/scale (nonnull/scale Pi#Q4 Q2*Q4=Q6) Q1*Q6=Q7)
	(equiv/mul Q1*Q2=Q3)
	(nonnull/scale Pi#Q4 Q3*Q4=Q7)
    <- rat`mul-associative-converse* Q2*Q4=Q6 Q1*Q6=Q7 Q1*Q2=Q3 Q3*Q4=Q7.

- : equiv-preserves-nonnull 
	(nonnull/combine/1 (nonnull/scale Pi#Q _) (null/* Pi#0)) (equiv/add _) N
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-nonnull F N.

- : equiv-preserves-nonnull 
	(nonnull/combine/2 (null/* Pi#0) (nonnull/scale Pi#Q _)) (equiv/add _) N
    <- null-nonnull-contradiction Pi#0 Pi#Q F
    <- false-implies-nonnull F N.

- : equiv-preserves-nonnull
	(nonnull/combine/1+2 (nonnull/scale Pi#Q4 Q1*Q4=Q5)
                             (nonnull/scale Pi#Q4' Q2*Q4'=Q6)
		 	     Q5+Q6=Q7)
	(equiv/add Q1+Q2=Q3)
	(nonnull/scale Pi#Q4 Q3*Q4=Q7)
    <- nonnull-deterministic Pi#Q4' Pi#Q4 Q4'=Q4
    <- rat`mul-respects-equ Q2*Q4'=Q6 equ/ Q4'=Q4 equ/ Q2*Q4=Q6
    <- rat`mul-right-factors-over-add* Q1*Q4=Q5 Q2*Q4=Q6 Q5+Q6=Q7 Q1+Q2=Q3
				       Q3*Q4=Q7.

- : equiv-preserves-nonnull Pi#Q equiv/reflexive Pi#Q.

- : equiv-preserves-nonnull Pi1#Q (equiv/symmetric Pi2->Pi1) Pi2#Q
    <- equiv-preserves-nonnull-converse Pi1#Q Pi2->Pi1 Pi2#Q.

- : equiv-preserves-nonnull Pi1#Q (equiv/transitive Pi1->Pi2 Pi2->Pi3) Pi3#Q
    <- equiv-preserves-nonnull Pi1#Q Pi1->Pi2 Pi2#Q
    <- equiv-preserves-nonnull Pi2#Q Pi2->Pi3 Pi3#Q.

%% now the converse rules

- : equiv-preserves-nonnull-converse 
	Pi#Q equiv/identity (nonnull/combine/1 Pi#Q null/0).

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1 Pi1#Q Pi2#0) equiv/commute
        (nonnull/combine/2 Pi2#0 Pi1#Q).

- : equiv-preserves-nonnull-converse
	(nonnull/combine/2 Pi1#0 Pi2#Q) equiv/commute
	(nonnull/combine/1 Pi2#Q Pi1#0).

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) 
        equiv/commute
	(nonnull/combine/1+2 Pi2#Q2 Pi1#Q1 Q2+Q1=Q3)
    <- rat`add-commutative Q1+Q2=Q3 Q2+Q1=Q3.

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1 (nonnull/combine/1 Pi1#Q Pi2#0) Pi3#0)
	equiv/associate
	(nonnull/combine/1 Pi1#Q (null/+ Pi2#0 Pi3#0)).

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1 (nonnull/combine/2 Pi1#0 Pi2#Q) Pi3#0)
        equiv/associate 
	(nonnull/combine/2 Pi1#0 (nonnull/combine/1 Pi2#Q Pi3#0)). 

- : equiv-preserves-nonnull-converse
	(nonnull/combine/2 (null/+ Pi1#0 Pi2#0) Pi3#Q)
        equiv/associate 
	(nonnull/combine/2 Pi1#0 (nonnull/combine/2 Pi2#0 Pi3#Q)).

- : equiv-preserves-nonnull-converse
	(nonnull/combine/1+2 (nonnull/combine/2 Pi1#0 Pi2#Q2) Pi3#Q3 Q2+Q3=Q5)
	equiv/associate
	(nonnull/combine/2 Pi1#0 (nonnull/combine/1+2 Pi2#Q2 Pi3#Q3 Q2+Q3=Q5)). 

- : equiv-preserves-nonnull-converse
	(nonnull/combine/1 (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) Pi4#0)
        equiv/associate
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/1 Pi2#Q2 Pi4#0) Q1+Q2=Q3).

- : equiv-preserves-nonnull-converse
	(nonnull/combine/1+2 (nonnull/combine/1 Pi1#Q1 Pi2#0) Pi4#Q4 Q1+Q4=Q5)
        equiv/associate
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/2 Pi2#0 Pi4#Q4) Q1+Q4=Q5).

- : equiv-preserves-nonnull-converse
        (nonnull/combine/1+2 (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3)
			     Pi4#Q4 Q3+Q4=Q7)
        equiv/associate
	(nonnull/combine/1+2 Pi1#Q1 (nonnull/combine/1+2 Pi2#Q2 Pi4#Q4 Q2+Q4=Q6)
                             Q1+Q6=Q7) 
    <- rat`add-associative Q1+Q2=Q3 Q3+Q4=Q7 _ Q2+Q4=Q6 Q1+Q6=Q7.

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1 Pi1'#Q Pi2'#0) 
	(equiv/combine Pi1->Pi1' Pi2->Pi2')
	(nonnull/combine/1 Pi1#Q Pi2#0)
    <- equiv-preserves-nonnull-converse Pi1'#Q Pi1->Pi1' Pi1#Q
    <- equiv-preserves-null-converse Pi2'#0 Pi2->Pi2' Pi2#0.

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/2 Pi1'#0 Pi2'#Q)
	(equiv/combine Pi1->Pi1' Pi2->Pi2')
	(nonnull/combine/2 Pi1#0 Pi2#Q) 
    <- equiv-preserves-null-converse Pi1'#0 Pi1->Pi1' Pi1#0
    <- equiv-preserves-nonnull-converse Pi2'#Q Pi2->Pi2' Pi2#Q.

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1+2 Pi1'#Q1 Pi2'#Q2 Q1+Q2=Q3)
	(equiv/combine Pi1->Pi1' Pi2->Pi2')
	(nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) 
    <- equiv-preserves-nonnull-converse Pi1'#Q1 Pi1->Pi1' Pi1#Q1
    <- equiv-preserves-nonnull-converse Pi2'#Q2 Pi2->Pi2' Pi2#Q2.

- : equiv-preserves-nonnull-converse 
	Pi#Q2 equiv/one (nonnull/scale Pi#Q2 ONE*Q2=Q2)
    <- rat`mul-left-identity _ ONE*Q2=Q2.

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/1 (nonnull/scale Pi1#Q2 Q1*Q2=Q3) (null/* Pi2#0))
	equiv/distribute
	(nonnull/scale (nonnull/combine/1 Pi1#Q2 Pi2#0) Q1*Q2=Q3).

- : equiv-preserves-nonnull-converse 
	(nonnull/combine/2 (null/* Pi1#0) (nonnull/scale Pi2#Q4 Q1*Q4=Q5))
	equiv/distribute
	(nonnull/scale (nonnull/combine/2 Pi1#0 Pi2#Q4) Q1*Q4=Q5).

- : equiv-preserves-nonnull-converse
	(nonnull/combine/1+2 (nonnull/scale Pi1#Q2 Q1*Q2=Q3)
			     (nonnull/scale Pi2#Q4 Q1*Q4=Q5) Q3+Q5=Q7)
	equiv/distribute
	(nonnull/scale (nonnull/combine/1+2 Pi1#Q2 Pi2#Q4 Q2+Q4=Q6) Q1*Q6=Q7)
    <- rat`mul-left-factors-over-add Q1*Q2=Q3 Q1*Q4=Q5 Q3+Q5=Q7
                                     _ Q2+Q4=Q6 Q1*Q6=Q7.
					 
- : equiv-preserves-nonnull-converse
	(nonnull/scale Pi#Q4 Q3*Q4=Q7)
	(equiv/mul Q1*Q2=Q3)
	(nonnull/scale (nonnull/scale Pi#Q4 Q2*Q4=Q6) Q1*Q6=Q7)
    <- rat`mul-associative Q1*Q2=Q3 Q3*Q4=Q7 _ Q2*Q4=Q6 Q1*Q6=Q7.

- : equiv-preserves-nonnull-converse
	(nonnull/scale Pi#Q4 Q3*Q4=Q7)
	(equiv/add Q1+Q2=Q3)
	(nonnull/combine/1+2 (nonnull/scale Pi#Q4 Q1*Q4=Q5)
                             (nonnull/scale Pi#Q4 Q2*Q4=Q6)
		 	     Q5+Q6=Q7)
    <- rat`mul-right-distributes-over-add Q1+Q2=Q3 Q3*Q4=Q7 _ _ 
                                          Q1*Q4=Q5 Q2*Q4=Q6 Q5+Q6=Q7.

- : equiv-preserves-nonnull-converse Pi#Q equiv/reflexive Pi#Q.

- : equiv-preserves-nonnull-converse Pi1#Q (equiv/symmetric Pi2->Pi1) Pi2#Q
    <- equiv-preserves-nonnull Pi1#Q Pi2->Pi1 Pi2#Q.

- : equiv-preserves-nonnull-converse Pi3#Q (equiv/transitive Pi1->Pi2 Pi2->Pi3) Pi1#Q
    <- equiv-preserves-nonnull-converse Pi3#Q Pi2->Pi3 Pi2#Q
    <- equiv-preserves-nonnull-converse Pi2#Q Pi1->Pi2 Pi1#Q.

%worlds () (equiv-preserves-nonnull _ _ _)
           (equiv-preserves-nonnull-converse _ _ _).

%total (E ER) (equiv-preserves-nonnull _ E _)
              (equiv-preserves-nonnull-converse _ ER _).



%%% theorems for null?


%theorem null?-total* :
	forall {Pi}
	exists {B} {N?:null? Pi B}
	true.

%theorem null?-total*/combine :
	forall* {Pi1} {Pi2} {B1} {B2}
        forall {N1:null? Pi1 B1}
               {N2:null? Pi2 B2}
	exists {B} {N?:null? (Pi1 , Pi2) B}
	true.

- : null?-total*/combine (null?/yes Pi1#0) (null?/yes Pi2#0) _
                         (null?/yes (null/+ Pi1#0 Pi2#0)).

- : null?-total*/combine (null?/yes Pi1#0) (null?/no Pi2#Q) _
			 (null?/no (nonnull/combine/2 Pi1#0 Pi2#Q)).

- : null?-total*/combine (null?/no Pi1#Q) (null?/yes Pi2#0) _
			 (null?/no (nonnull/combine/1 Pi1#Q Pi2#0)).

- : null?-total*/combine (null?/no Pi1#Q1) (null?/no Pi2#Q2) _
			 (null?/no (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3))
    <- rat`add-total Q1+Q2=Q3.

%worlds () (null?-total*/combine _ _ _ _).
%total { } (null?-total*/combine _ _ _ _).

%theorem null?-total*/scale :
	forall* {Pi1} {B1} {F}
        forall {N1:null? Pi1 B1}
	exists {B} {N?:null? (scale F Pi1) B}
	true.

- : null?-total*/scale (null?/yes Pi#0) _ (null?/yes (null/* Pi#0)).

- : null?-total*/scale (null?/no Pi#Q2) _ 
                       (null?/no (nonnull/scale Pi#Q2 Q1*Q2=Q3))
    <- rat`mul-total Q1*Q2=Q3.

%worlds () (null?-total*/scale _ _ _).
%total { } (null?-total*/scale _ _ _).

- : null?-total* _ _ (null?/yes null/0).

- : null?-total* (Pi1 , Pi2) _ N?
    <- null?-total* _ _ Pi1#?
    <- null?-total* _ _ Pi2#?
    <- null?-total*/combine Pi1#? Pi2#? _ N?.

- : null?-total* (scale _ _) _ N?
    <- null?-total* _ _ Pi#?
    <- null?-total*/scale Pi#? _ N?.

- : null?-total* _ _ (null?/no nonnull/unit).

%worlds () (null?-total* _ _ _).
%total (P) (null?-total* P _ _).

%abbrev null?-total = null?-total* _ _.


%theorem combine-right-identity-null :
	forall* {Pi1} {Pi2} {Pi1'}
	forall {EQC:equiv (Pi1 , Pi2) Pi1'}
               {EQ1:equiv Pi1 Pi1'}
	exists {N2:null Pi2}
	true.

%theorem combine-right-identity-null/L :
	forall* {Pi1} {Pi2} {B1} {B2}
	forall {EQC:equiv (Pi1 , Pi2) Pi1}
               {N1?:null? Pi1 B1}
               {N2?:null? Pi2 B2}
	exists {N2:null Pi2}
	true.

- : combine-right-identity-null EQC EQ1 N2
    <- null?-total N1?
    <- null?-total N2?
    <- combine-right-identity-null/L 
	(equiv/transitive EQC (equiv/symmetric EQ1)) N1? N2? N2.

- : combine-right-identity-null/L _ _ (null?/yes N2) N2.

- : combine-right-identity-null/L EQC (null?/yes Pi1#0) (null?/no Pi2#Q) N2
    <- equiv-preserves-nonnull (nonnull/combine/2 Pi1#0 Pi2#Q) EQC Pi1#Q
    <- null-nonnull-contradiction Pi1#0 Pi1#Q F
    <- false-implies-null F N2.

- : combine-right-identity-null/L EQC (null?/no Pi1#Q1) (null?/no Pi2#Q2) N2
    <- rat`add-total Q1+Q2=Q3
    <- equiv-preserves-nonnull (nonnull/combine/1+2 Pi1#Q1 Pi2#Q2 Q1+Q2=Q3) 
                               EQC Pi1#Q3
    <- nonnull-deterministic Pi1#Q1 Pi1#Q3 Q1=Q3
    <- rat`add-implies-grt Q1+Q2=Q3 Q3>Q1 _
    <- rat`grt-respects-equ Q3>Q1 equ/ Q1=Q3 Q3>Q3
    <- rat`grt-anti-reflexive Q3>Q3 F
    <- false-implies-null F N2.

%worlds () (combine-right-identity-null/L _ _ _ _).
%total { } (combine-right-identity-null/L _ _ _ _).

%worlds () (combine-right-identity-null _ _ _).
%total { } (combine-right-identity-null _ _ _).


%{%
%% too difficult now: see canonical.elf
%theorem combine-left-cancels :
	forall* {Pi1} {Pi2} {Pi1'} {Pi2'}
	forall {EQC:equiv (Pi1 , Pi2) (Pi1' , Pi2')}
               {EQ1:equiv Pi1 Pi1'}
	exists {EQ2:equiv Pi2 Pi2'}
	true.
%}%



%%% Theorems about leq


%theorem false-implies-leq :
	forall* {Pi1} {Pi2}
	forall {F:void}
	exists {L:leq Pi1 Pi2}
	true.

%worlds () (false-implies-leq _ _).
%total { } (false-implies-leq _ _).


%theorem leq-respects-eq :
	forall* {Pi1} {Pi2} {Pi3} {Pi4}
	forall {L12:leq Pi1 Pi2} {E13:eq Pi1 Pi3} {E24:eq Pi2 Pi4}
	exists {L34:leq Pi3 Pi4}
	true.

- : leq-respects-eq L eq/ eq/ L.

%worlds () (leq-respects-eq _ _ _ _).
%total { } (leq-respects-eq _ _ _ _).


%theorem leq-reflexive :
	forall {Pi}
	exists {L:leq Pi Pi}
	true.

- : leq-reflexive _ (leq/ equiv/identity).

%worlds () (leq-reflexive _ _).
%total { } (leq-reflexive _ _).


%theorem leq-anti-symmetric :
	forall* {Pi1} {Pi2}
	forall {L1:leq Pi1 Pi2}
	       {L2:leq Pi2 Pi1}
	exists {EQ:equiv Pi1 Pi2}
	true.

- : leq-anti-symmetric (leq/ (Pi1,X=Pi2 : equiv (Pi1 , X) Pi2))
                       (leq/ (Pi2,Y=Pi1 : equiv (Pi2 , Y) Pi1))
                       (equiv/transitive3
			 (equiv/symmetric equiv/identity)
		         (equiv/combine equiv/reflexive (equiv/symmetric X->0))
                         Pi1,X=Pi2)
    <- combine-right-identity-null
       (equiv/transitive3
         equiv/associate
         (equiv/combine Pi1,X=Pi2 equiv/reflexive)
         Pi2,Y=Pi1)
       (equiv/reflexive) (null/+ X#0 Y#0)
    <- null-implies-equiv-empty X#0 X->0.
    
%worlds () (leq-anti-symmetric _ _ _).
%total { } (leq-anti-symmetric _ _ _).


%theorem leq-transitive :
	forall* {Pi1} {Pi2} {Pi3}
	forall {L12:leq Pi1 Pi2}
	       {L23:leq Pi2 Pi3}
	exists {L13:leq Pi1 Pi3}
	true.

- : leq-transitive (leq/ (Pi1,X=Pi2 : equiv (Pi1 , X) Pi2))
                   (leq/ (Pi2,Y=Pi3 : equiv (Pi2 , Y) Pi3))
                   (leq/ (equiv/transitive
                           (equiv/associate :
                            equiv (Pi1 , (X , Y)) ((Pi1 , X), Y)) 
                           (equiv/transitive 
                             (equiv/combine Pi1,X=Pi2 equiv/reflexive :
                              equiv ((Pi1 , X), Y) (Pi2 , Y))
                             Pi2,Y=Pi3))).

%worlds () (leq-transitive _ _ _).
%total { } (leq-transitive _ _ _).
%abbrev permission`vark = vark.
%abbrev permission`objectk = objectk.
%abbrev permission`fractionk = fractionk.
%abbrev permission`kind = kind.
%abbrev permission`permissionk = permissionk.
%abbrev permission`upermk = upermk.
%abbrev permission`formulak = formulak.
%abbrev permission`termk = termk.
%abbrev permission`gterm = gterm.
%abbrev permission`term = term.
%abbrev permission`permission = permission.
%abbrev permission`uperm = uperm.
%abbrev permission`formula = formula.
%abbrev permission`object = object.
%abbrev permission`fraction = fraction.
%abbrev permission`predtype = predtype.
%abbrev permission`predtype/0 = predtype/0.
%abbrev permission`predtype/+ = predtype/+.
%abbrev permission`predicate = predicate.
%abbrev permission`predargs = predargs.
%abbrev permission`field = field.
%abbrev permission`value = value.
%abbrev permission`empty = empty.
%abbrev permission`scale = scale.
%abbrev permission`combine = combine.
%abbrev permission`unitperm = unitperm.
%abbrev permission`nonlinear = nonlinear.
%abbrev permission`conditional = conditional.
%abbrev permission`encumbered = encumbered.
%abbrev permission`precise-exists = precise-exists.
%abbrev permission`basic = basic.
%abbrev permission`object/ = object/.
%abbrev permission`fraction/ = fraction/.
%abbrev permission`t = t.
%abbrev permission`neg = neg.
%abbrev permission`conj = conj.
%abbrev permission`objequal = objequal.
%abbrev permission`exists* = exists*.
%abbrev permission`exists = exists.
%abbrev permission`nested = nested.
%abbrev permission`predcall* = predcall*.
%abbrev permission`predcall = predcall.
%abbrev permission`f = f.
%abbrev permission`disj = disj.
%abbrev permission`impl = impl.
%abbrev permission`ifthenelse = ifthenelse.
%abbrev permission`predargs/0* = predargs/0*.
%abbrev permission`predargs/0 = predargs/0.
%abbrev permission`predargs/+ = predargs/+.
%abbrev permission`predicate/0 = predicate/0.
%abbrev permission`predicate/+ = predicate/+.
%abbrev permission`predicate/Y = predicate/Y.
%abbrev permission`eq = eq.
%abbrev permission`eq/ = eq/.
%abbrev permission`equiv = equiv.
%abbrev permission`equiv/identity = equiv/identity.
%abbrev permission`equiv/commute = equiv/commute.
%abbrev permission`equiv/associate = equiv/associate.
%abbrev permission`equiv/combine = equiv/combine.
%abbrev permission`equiv/zero = equiv/zero.
%abbrev permission`equiv/one = equiv/one.
%abbrev permission`equiv/distribute = equiv/distribute.
%abbrev permission`equiv/mul = equiv/mul.
%abbrev permission`equiv/add = equiv/add.
%abbrev permission`equiv/reflexive = equiv/reflexive.
%abbrev permission`equiv/symmetric = equiv/symmetric.
%abbrev permission`equiv/transitive = equiv/transitive.
%abbrev permission`equiv/transitive2 = equiv/transitive2.
%abbrev permission`equiv/transitive3 = equiv/transitive3.
%abbrev permission`equiv/transitive4 = equiv/transitive4.
%abbrev permission`equiv/transitive5 = equiv/transitive5.
%abbrev permission`equiv/transitive6 = equiv/transitive6.
%abbrev permission`equiv/transitive7 = equiv/transitive7.
%abbrev permission`equiv/transitive8 = equiv/transitive8.
%abbrev permission`equiv/reorder = equiv/reorder.
%abbrev permission`equiv/double-associate = equiv/double-associate.
%abbrev permission`equiv/roll2 = equiv/roll2.
%abbrev permission`equiv/roll3 = equiv/roll3.
%abbrev permission`equiv/roll4 = equiv/roll4.
%abbrev permission`equiv/roll5 = equiv/roll5.
%abbrev permission`equiv/roll6 = equiv/roll6.
%abbrev permission`equiv/roll7 = equiv/roll7.
%abbrev permission`null = null.
%abbrev permission`null/0 = null/0.
%abbrev permission`null/* = null/*.
%abbrev permission`null/+ = null/+.
%abbrev permission`nonnull = nonnull.
%abbrev permission`nonnull/scale = nonnull/scale.
%abbrev permission`nonnull/combine/1 = nonnull/combine/1.
%abbrev permission`nonnull/combine/2 = nonnull/combine/2.
%abbrev permission`nonnull/combine/1+2 = nonnull/combine/1+2.
%abbrev permission`nonnull/unit = nonnull/unit.
%abbrev permission`null? = null?.
%abbrev permission`null?/yes = null?/yes.
%abbrev permission`null?/no = null?/no.
%abbrev permission`leq = leq.
%abbrev permission`leq/ = leq/.
%abbrev permission`clspred = clspred.
%abbrev permission`gterm-inhabited = gterm-inhabited.
%abbrev permission`meta-eq = meta-eq.
%abbrev permission`false-implies-eq = false-implies-eq.
%abbrev permission`eq-reflexive = eq-reflexive.
%abbrev permission`eq-symmetric = eq-symmetric.
%abbrev permission`eq-transitive = eq-transitive.
%abbrev permission`object-eq-implies-eq = object-eq-implies-eq.
%abbrev permission`object-preserves-eq = object-preserves-eq.
%abbrev permission`unit-eq-implies-eq = unit-eq-implies-eq.
%abbrev permission`false-implies-equiv = false-implies-equiv.
%abbrev permission`equiv-respects-eq = equiv-respects-eq.
%abbrev permission`equiv-reflexive = equiv-reflexive.
%abbrev permission`equiv-symmetric = equiv-symmetric.
%abbrev permission`equiv-transitive = equiv-transitive.
%abbrev permission`equiv/frac-admissible = equiv/frac-admissible.
%abbrev permission`false-implies-null = false-implies-null.
%abbrev permission`null-implies-equiv-empty = null-implies-equiv-empty.
%abbrev permission`equiv-preserves-null = equiv-preserves-null.
%abbrev permission`equiv-preserves-null-converse = equiv-preserves-null-converse.
%abbrev permission`equiv-empty-implies-null = equiv-empty-implies-null.
%abbrev permission`false-implies-nonnull = false-implies-nonnull.
%abbrev permission`nonnull-respects-equ = nonnull-respects-equ.
%abbrev permission`null-nonnull-contradiction = null-nonnull-contradiction.
%abbrev permission`nonnull-deterministic = nonnull-deterministic.
%abbrev permission`equiv-preserves-nonnull = equiv-preserves-nonnull.
%abbrev permission`equiv-preserves-nonnull-converse = equiv-preserves-nonnull-converse.
%abbrev permission`null?-total* = null?-total*.
%abbrev permission`null?-total*/combine = null?-total*/combine.
%abbrev permission`null?-total*/scale = null?-total*/scale.
%abbrev permission`null?-total = null?-total.
%abbrev permission`combine-right-identity-null = combine-right-identity-null.
%abbrev permission`combine-right-identity-null/L = combine-right-identity-null/L.
%abbrev permission`false-implies-leq = false-implies-leq.
%abbrev permission`leq-respects-eq = leq-respects-eq.
%abbrev permission`leq-reflexive = leq-reflexive.
%abbrev permission`leq-anti-symmetric = leq-anti-symmetric.
%abbrev permission`leq-transitive = leq-transitive.
%abbrev permission`nat#eq = nat#eq.
%abbrev permission`nat#eq/ = nat#eq/.
%abbrev permission`nat#ne = nat#ne.
%abbrev permission`nat#eq? = nat#eq?.
%abbrev permission`nat#eq?/yes = nat#eq?/yes.
%abbrev permission`nat#eq?/no = nat#eq?/no.
%abbrev permission`nat#eq?-total = nat#eq?-total.
%abbrev permission`nat#eq-ne-implies-false = nat#eq-ne-implies-false.
%abbrev permission`0 = 0.
%abbrev permission`1 = 1.
%abbrev permission`2 = 2.
%abbrev permission`3 = 3.
%abbrev permission`4 = 4.
%abbrev permission`5 = 5.
%abbrev permission`6 = 6.
%abbrev permission`0+N=N = 0+N=N.
%abbrev permission`0+0=0 = 0+0=0.
%abbrev permission`1+N=sN = 1+N=sN.
%abbrev permission`1>0 = 1>0.
%abbrev permission`2>0 = 2>0.
%abbrev permission`3>0 = 3>0.
%abbrev permission`1+0=1 = 1+0=1.
%abbrev permission`0+1=1 = 0+1=1.
%abbrev permission`2>1 = 2>1.
%abbrev permission`3>1 = 3>1.
%abbrev permission`2+0=2 = 2+0=2.
%abbrev permission`0+2=2 = 0+2=2.
%abbrev permission`3>2 = 3>2.
%abbrev permission`4>0 = 4>0.
%abbrev permission`5>0 = 5>0.
%abbrev permission`4>1 = 4>1.
%abbrev permission`5>1 = 5>1.
%abbrev permission`0+3=3 = 0+3=3.
%abbrev permission`1+2=3 = 1+2=3.
%abbrev permission`2+2=4 = 2+2=4.
%abbrev permission`3+2=5 = 3+2=5.
%abbrev permission`2+N=ssN = 2+N=ssN.
%abbrev permission`3+N=sssN = 3+N=sssN.
%abbrev permission`4+N=ssssN = 4+N=ssssN.
%abbrev permission`0+5=5 = 0+5=5.
%abbrev permission`5+N=sssssN = 5+N=sssssN.
%abbrev permission`0*0=0 = 0*0=0.
%abbrev permission`1*0=0 = 1*0=0.
%abbrev permission`2*0=0 = 2*0=0.
%abbrev permission`3+0=3 = 3+0=3.
%abbrev permission`0*1=0 = 0*1=0.
%abbrev permission`1*1=1 = 1*1=1.
%abbrev permission`0*2=0 = 0*2=0.
%abbrev permission`1*2=2 = 1*2=2.
%abbrev permission`4>2 = 4>2.
%abbrev permission`5>2 = 5>2.
%abbrev permission`4>3 = 4>3.
%abbrev permission`5>3 = 5>3.
%abbrev permission`5>4 = 5>4.
%abbrev permission`4+0=4 = 4+0=4.
%abbrev permission`5+0=5 = 5+0=5.
%abbrev permission`0$0=0 = 0$0=0.
%abbrev permission`3*0=0 = 3*0=0.
%abbrev permission`4*0=0 = 4*0=0.
%abbrev permission`5*0=0 = 5*0=0.
%abbrev permission`6>0 = 6>0.
%abbrev permission`6>1 = 6>1.
%abbrev permission`6>2 = 6>2.
%abbrev permission`6>3 = 6>3.
%abbrev permission`6>4 = 6>4.
%abbrev permission`6>5 = 6>5.
%abbrev permission`0*4=0 = 0*4=0.
%abbrev permission`1/2=0,1 = 1/2=0,1.
%abbrev permission`0/2=0,0 = 0/2=0,0.
%abbrev permission`0$1=1 = 0$1=1.
%abbrev permission`sN>N = sN>N.
%abbrev permission`ssN>N = ssN>N.
%abbrev permission`rat#map = rat#map.
%abbrev permission`kind#map = kind#map.
%abbrev permission`vark#map = vark#map.
%abbrev permission`predtype#map = predtype#map.
%abbrev permission`rat#map/whole = rat#map/whole.
%abbrev permission`rat#map/frac = rat#map/frac.
%abbrev permission`kind#map/permissionk = kind#map/permissionk.
%abbrev permission`kind#map/upermk = kind#map/upermk.
%abbrev permission`kind#map/formulak = kind#map/formulak.
%abbrev permission`vark#map/objectk = vark#map/objectk.
%abbrev permission`vark#map/fractionk = vark#map/fractionk.
%abbrev permission`vark#map/termk = vark#map/termk.
%abbrev permission`predtype#map/predtype/0 = predtype#map/predtype/0.
%abbrev permission`predtype#map/predtype/+ = predtype#map/predtype/+.
%abbrev permission`rat#eq = rat#eq.
%abbrev permission`rat#ne = rat#ne.
%abbrev permission`rat#eq? = rat#eq?.
%abbrev permission`kind#eq = kind#eq.
%abbrev permission`kind#ne = kind#ne.
%abbrev permission`kind#eq? = kind#eq?.
%abbrev permission`vark#eq = vark#eq.
%abbrev permission`vark#ne = vark#ne.
%abbrev permission`vark#eq? = vark#eq?.
%abbrev permission`predtype#eq = predtype#eq.
%abbrev permission`predtype#ne = predtype#ne.
%abbrev permission`predtype#eq? = predtype#eq?.
%abbrev permission`rat#eq/ = rat#eq/.
%abbrev permission`rat#ne/ = rat#ne/.
%abbrev permission`rat#eq?/yes = rat#eq?/yes.
%abbrev permission`rat#eq?/no = rat#eq?/no.
%abbrev permission`kind#eq/ = kind#eq/.
%abbrev permission`kind#ne/ = kind#ne/.
%abbrev permission`kind#eq?/yes = kind#eq?/yes.
%abbrev permission`kind#eq?/no = kind#eq?/no.
%abbrev permission`vark#eq/ = vark#eq/.
%abbrev permission`vark#ne/ = vark#ne/.
%abbrev permission`vark#eq?/yes = vark#eq?/yes.
%abbrev permission`vark#eq?/no = vark#eq?/no.
%abbrev permission`predtype#eq/ = predtype#eq/.
%abbrev permission`predtype#ne/ = predtype#ne/.
%abbrev permission`predtype#eq?/yes = predtype#eq?/yes.
%abbrev permission`predtype#eq?/no = predtype#eq?/no.
%abbrev permission`false-implies-rat# = false-implies-rat#.
%abbrev permission`false-implies-rat#map = false-implies-rat#map.
%abbrev permission`false-implies-rat#eq = false-implies-rat#eq.
%abbrev permission`rat#map-respects-eq = rat#map-respects-eq.
%abbrev permission`false-implies-kind# = false-implies-kind#.
%abbrev permission`false-implies-kind#map = false-implies-kind#map.
%abbrev permission`false-implies-kind#eq = false-implies-kind#eq.
%abbrev permission`kind#map-respects-eq = kind#map-respects-eq.
%abbrev permission`false-implies-vark# = false-implies-vark#.
%abbrev permission`false-implies-vark#map = false-implies-vark#map.
%abbrev permission`false-implies-vark#eq = false-implies-vark#eq.
%abbrev permission`vark#map-respects-eq = vark#map-respects-eq.
%abbrev permission`false-implies-predtype# = false-implies-predtype#.
%abbrev permission`false-implies-predtype#map = false-implies-predtype#map.
%abbrev permission`false-implies-predtype#eq = false-implies-predtype#eq.
%abbrev permission`predtype#map-respects-eq = predtype#map-respects-eq.
%abbrev permission`rat#map-total* = rat#map-total*.
%abbrev permission`kind#map-total* = kind#map-total*.
%abbrev permission`vark#map-total* = vark#map-total*.
%abbrev permission`predtype#map-total* = predtype#map-total*.
%abbrev permission`rat#map-total = rat#map-total.
%abbrev permission`kind#map-total = kind#map-total.
%abbrev permission`vark#map-total = vark#map-total.
%abbrev permission`predtype#map-total = predtype#map-total.
%abbrev permission`nat-eq-nop = nat-eq-nop.
%abbrev permission`rat#map-deterministic* = rat#map-deterministic*.
%abbrev permission`kind#map-deterministic* = kind#map-deterministic*.
%abbrev permission`vark#map-deterministic* = vark#map-deterministic*.
%abbrev permission`predtype#map-deterministic* = predtype#map-deterministic*.
%abbrev permission`rat#map-deterministic = rat#map-deterministic.
%abbrev permission`kind#map-deterministic = kind#map-deterministic.
%abbrev permission`vark#map-deterministic = vark#map-deterministic.
%abbrev permission`predtype#map-deterministic = predtype#map-deterministic.
%abbrev permission`classify# = classify#.
%abbrev permission`classify#/low = classify#/low.
%abbrev permission`classify#/mid = classify#/mid.
%abbrev permission`classify#/high = classify#/high.
%abbrev permission`classify#-total = classify#-total.
%abbrev permission`false-implies-classify# = false-implies-classify#.
%abbrev permission`classify#-total/L = classify#-total/L.
%abbrev permission`false-implies-classify# = false-implies-classify#.
%abbrev permission`classify#-total = classify#-total.
%abbrev permission`classify#-total/L = classify#-total/L.
%abbrev permission`rat#map-onto/0/rat = rat#map-onto/0/rat.
%abbrev permission`rat#map-onto/1/rat = rat#map-onto/1/rat.
%abbrev permission`rat#map-onto/L = rat#map-onto/L.
%abbrev permission`rat#map-onto = rat#map-onto.
%abbrev permission`kind#map-onto/L = kind#map-onto/L.
%abbrev permission`kind#map-onto = kind#map-onto.
%abbrev permission`vark#map-onto/L = vark#map-onto/L.
%abbrev permission`vark#map-onto = vark#map-onto.
%abbrev permission`predtype#map-onto/L = predtype#map-onto/L.
%abbrev permission`predtype#map-onto = predtype#map-onto.
%abbrev permission`whole-respects-rat#eq = whole-respects-rat#eq.
%abbrev permission`frac-respects-rat#eq = frac-respects-rat#eq.
%abbrev permission`kind#map-implies-gt = kind#map-implies-gt.
%abbrev permission`permissionk-respects-kind#eq = permissionk-respects-kind#eq.
%abbrev permission`upermk-respects-kind#eq = upermk-respects-kind#eq.
%abbrev permission`formulak-respects-kind#eq = formulak-respects-kind#eq.
%abbrev permission`vark#map-implies-gt = vark#map-implies-gt.
%abbrev permission`objectk-respects-vark#eq = objectk-respects-vark#eq.
%abbrev permission`fractionk-respects-vark#eq = fractionk-respects-vark#eq.
%abbrev permission`termk-respects-vark#eq = termk-respects-vark#eq.
%abbrev permission`predtype/0-respects-predtype#eq = predtype/0-respects-predtype#eq.
%abbrev permission`predtype/+-respects-predtype#eq = predtype/+-respects-predtype#eq.
%abbrev permission`rat#map-one2one = rat#map-one2one.
%abbrev permission`kind#map-one2one = kind#map-one2one.
%abbrev permission`vark#map-one2one = vark#map-one2one.
%abbrev permission`predtype#map-one2one = predtype#map-one2one.
%abbrev permission`rat#eq?-total* = rat#eq?-total*.
%abbrev permission`rat#eq-ne-implies-false = rat#eq-ne-implies-false.
%abbrev permission`kind#eq?-total* = kind#eq?-total*.
%abbrev permission`kind#eq-ne-implies-false = kind#eq-ne-implies-false.
%abbrev permission`vark#eq?-total* = vark#eq?-total*.
%abbrev permission`vark#eq-ne-implies-false = vark#eq-ne-implies-false.
%abbrev permission`predtype#eq?-total* = predtype#eq?-total*.
%abbrev permission`predtype#eq-ne-implies-false = predtype#eq-ne-implies-false.
%abbrev permission`rat#eq?-total = rat#eq?-total.
%abbrev permission`kind#eq?-total = kind#eq?-total.
%abbrev permission`vark#eq?-total = vark#eq?-total.
%abbrev permission`predtype#eq?-total = predtype#eq?-total.
%abbrev permission`rat#eq?-total/L1 = rat#eq?-total/L1.
%abbrev permission`rat#eq?-total/L2 = rat#eq?-total/L2.
%abbrev permission`kind#eq?-total/L1 = kind#eq?-total/L1.
%abbrev permission`kind#eq?-total/L2 = kind#eq?-total/L2.
%abbrev permission`vark#eq?-total/L1 = vark#eq?-total/L1.
%abbrev permission`vark#eq?-total/L2 = vark#eq?-total/L2.
%abbrev permission`predtype#eq?-total/L1 = predtype#eq?-total/L1.
%abbrev permission`predtype#eq?-total/L2 = predtype#eq?-total/L2.
%abbrev permission`predicate#var = predicate#var.
%abbrev permission`predicate#level = predicate#level.
%abbrev permission`predicate#nolevel = predicate#nolevel.
%abbrev permission`gterm#var = gterm#var.
%abbrev permission`gterm#level = gterm#level.
%abbrev permission`gterm#nolevel = gterm#nolevel.
%abbrev permission`fake = fake.
%abbrev permission`fake = fake.
%abbrev permission`predicate#list = predicate#list.
%abbrev permission`gterm#list = gterm#list.
%abbrev permission`predicate#list/0 = predicate#list/0.
%abbrev permission`predicate#list/+ = predicate#list/+.
%abbrev permission`gterm#list/0 = gterm#list/0.
%abbrev permission`gterm#list/+ = gterm#list/+.
%abbrev permission`predicate#split = predicate#split.
%abbrev permission`predicate#count = predicate#count.
%abbrev permission`gterm#split = gterm#split.
%abbrev permission`gterm#count = gterm#count.
%abbrev permission`predicate#split/here = predicate#split/here.
%abbrev permission`predicate#split/there = predicate#split/there.
%abbrev permission`predicate#count/0 = predicate#count/0.
%abbrev permission`predicate#count/= = predicate#count/=.
%abbrev permission`predicate#count/!= = predicate#count/!=.
%abbrev permission`gterm#split/here = gterm#split/here.
%abbrev permission`gterm#split/there = gterm#split/there.
%abbrev permission`gterm#count/0 = gterm#count/0.
%abbrev permission`gterm#count/= = gterm#count/=.
%abbrev permission`gterm#count/!= = gterm#count/!=.
%abbrev permission`gterm#map = gterm#map.
%abbrev permission`predicate#map = predicate#map.
%abbrev permission`predargs#map = predargs#map.
%abbrev permission`gterm#map/#level = gterm#map/#level.
%abbrev permission`gterm#map/#nolevel = gterm#map/#nolevel.
%abbrev permission`predicate#map/#level = predicate#map/#level.
%abbrev permission`predicate#map/#nolevel = predicate#map/#nolevel.
%abbrev permission`gterm#map/object/ = gterm#map/object/.
%abbrev permission`gterm#map/fraction/ = gterm#map/fraction/.
%abbrev permission`gterm#map/empty = gterm#map/empty.
%abbrev permission`gterm#map/scale = gterm#map/scale.
%abbrev permission`gterm#map/combine = gterm#map/combine.
%abbrev permission`gterm#map/unitperm = gterm#map/unitperm.
%abbrev permission`gterm#map/nonlinear = gterm#map/nonlinear.
%abbrev permission`gterm#map/conditional = gterm#map/conditional.
%abbrev permission`gterm#map/encumbered = gterm#map/encumbered.
%abbrev permission`gterm#map/precise-exists = gterm#map/precise-exists.
%abbrev permission`gterm#map/basic = gterm#map/basic.
%abbrev permission`gterm#map/t = gterm#map/t.
%abbrev permission`gterm#map/neg = gterm#map/neg.
%abbrev permission`gterm#map/conj = gterm#map/conj.
%abbrev permission`gterm#map/objequal = gterm#map/objequal.
%abbrev permission`gterm#map/exists* = gterm#map/exists*.
%abbrev permission`gterm#map/nested = gterm#map/nested.
%abbrev permission`gterm#map/predcall* = gterm#map/predcall*.
%abbrev permission`predicate#map/predicate/0 = predicate#map/predicate/0.
%abbrev permission`predicate#map/predicate/Y = predicate#map/predicate/Y.
%abbrev permission`predicate#map/predicate/+ = predicate#map/predicate/+.
%abbrev permission`predicate#map/predicate/Y1 = predicate#map/predicate/Y1.
%abbrev permission`predargs#map/predargs/0* = predargs#map/predargs/0*.
%abbrev permission`predargs#map/predargs/+ = predargs#map/predargs/+.
%abbrev permission`gterm#eq = gterm#eq.
%abbrev permission`gterm#ne = gterm#ne.
%abbrev permission`gterm#eq? = gterm#eq?.
%abbrev permission`predicate#eq = predicate#eq.
%abbrev permission`predicate#ne = predicate#ne.
%abbrev permission`predicate#eq? = predicate#eq?.
%abbrev permission`predargs#eq = predargs#eq.
%abbrev permission`predargs#ne = predargs#ne.
%abbrev permission`predargs#eq? = predargs#eq?.
%abbrev permission`gterm#eq/ = gterm#eq/.
%abbrev permission`gterm#ne/ = gterm#ne/.
%abbrev permission`gterm#eq?/yes = gterm#eq?/yes.
%abbrev permission`gterm#eq?/no = gterm#eq?/no.
%abbrev permission`predicate#eq/ = predicate#eq/.
%abbrev permission`predicate#ne/ = predicate#ne/.
%abbrev permission`predicate#eq?/yes = predicate#eq?/yes.
%abbrev permission`predicate#eq?/no = predicate#eq?/no.
%abbrev permission`predargs#eq/ = predargs#eq/.
%abbrev permission`predargs#ne/ = predargs#ne/.
%abbrev permission`predargs#eq?/yes = predargs#eq?/yes.
%abbrev permission`predargs#eq?/no = predargs#eq?/no.
%abbrev permission`false-implies-gterm#eq = false-implies-gterm#eq.
%abbrev permission`false-implies-predicate#eq = false-implies-predicate#eq.
%abbrev permission`false-implies-predicate#count = false-implies-predicate#count.
%abbrev permission`predicate#count-deterministic = predicate#count-deterministic.
%abbrev permission`predicate#count-total* = predicate#count-total*.
%abbrev permission`predicate#count-total/L = predicate#count-total/L.
%abbrev permission`predicate#split-contradiction = predicate#split-contradiction.
%abbrev permission`predicate#split-decreases-count = predicate#split-decreases-count.
%abbrev permission`predicate#lookup-onto = predicate#lookup-onto.
%abbrev permission`false-implies-gterm#count = false-implies-gterm#count.
%abbrev permission`gterm#count-deterministic = gterm#count-deterministic.
%abbrev permission`gterm#count-total* = gterm#count-total*.
%abbrev permission`gterm#count-total/L = gterm#count-total/L.
%abbrev permission`gterm#split-contradiction = gterm#split-contradiction.
%abbrev permission`gterm#split-decreases-count = gterm#split-decreases-count.
%abbrev permission`gterm#lookup-onto = gterm#lookup-onto.
%abbrev permission`predicate#count-total = predicate#count-total.
%abbrev permission`gterm#count-total = gterm#count-total.
%abbrev permission`predicate#lookup-deterministic = predicate#lookup-deterministic.
%abbrev permission`predicate#lookup-one2one = predicate#lookup-one2one.
%abbrev permission`gterm#lookup-deterministic = gterm#lookup-deterministic.
%abbrev permission`gterm#lookup-one2one = gterm#lookup-one2one.
%abbrev permission`false-implies-gterm# = false-implies-gterm#.
%abbrev permission`false-implies-gterm#map = false-implies-gterm#map.
%abbrev permission`gterm#map-respects-eq = gterm#map-respects-eq.
%abbrev permission`false-implies-predicate# = false-implies-predicate#.
%abbrev permission`false-implies-predicate#map = false-implies-predicate#map.
%abbrev permission`predicate#map-respects-eq = predicate#map-respects-eq.
%abbrev permission`false-implies-predargs# = false-implies-predargs#.
%abbrev permission`false-implies-predargs#map = false-implies-predargs#map.
%abbrev permission`false-implies-predargs#eq = false-implies-predargs#eq.
%abbrev permission`predargs#map-respects-eq = predargs#map-respects-eq.
%abbrev permission`gterm#map-remove-gterm-level = gterm#map-remove-gterm-level.
%abbrev permission`predicate#map-remove-gterm-level = predicate#map-remove-gterm-level.
%abbrev permission`predargs#map-remove-gterm-level = predargs#map-remove-gterm-level.
%abbrev permission`predicate#map-remove-predicate-level = predicate#map-remove-predicate-level.
%abbrev permission`gterm#map-remove-predicate-level = gterm#map-remove-predicate-level.
%abbrev permission`predargs#map-remove-predicate-level = predargs#map-remove-predicate-level.
%abbrev permission`gterm#map-add-gterm-level = gterm#map-add-gterm-level.
%abbrev permission`predicate#map-add-gterm-level = predicate#map-add-gterm-level.
%abbrev permission`predargs#map-add-gterm-level = predargs#map-add-gterm-level.
%abbrev permission`predicate#map-add-predicate-level = predicate#map-add-predicate-level.
%abbrev permission`gterm#map-add-predicate-level = gterm#map-add-predicate-level.
%abbrev permission`predargs#map-add-predicate-level = predargs#map-add-predicate-level.
%abbrev permission`gterm#case = gterm#case.
%abbrev permission`predicate#case = predicate#case.
%abbrev permission`gterm#case/#level = gterm#case/#level.
%abbrev permission`gterm#case/#nolevel = gterm#case/#nolevel.
%abbrev permission`gterm#case/empty = gterm#case/empty.
%abbrev permission`gterm#case/scale = gterm#case/scale.
%abbrev permission`gterm#case/combine = gterm#case/combine.
%abbrev permission`gterm#case/unitperm = gterm#case/unitperm.
%abbrev permission`gterm#case/nonlinear = gterm#case/nonlinear.
%abbrev permission`gterm#case/conditional = gterm#case/conditional.
%abbrev permission`gterm#case/encumbered = gterm#case/encumbered.
%abbrev permission`gterm#case/precise-exists = gterm#case/precise-exists.
%abbrev permission`gterm#case/basic = gterm#case/basic.
%abbrev permission`gterm#case/object/ = gterm#case/object/.
%abbrev permission`gterm#case/fraction/ = gterm#case/fraction/.
%abbrev permission`gterm#case/t = gterm#case/t.
%abbrev permission`gterm#case/neg = gterm#case/neg.
%abbrev permission`gterm#case/conj = gterm#case/conj.
%abbrev permission`gterm#case/objequal = gterm#case/objequal.
%abbrev permission`gterm#case/exists* = gterm#case/exists*.
%abbrev permission`gterm#case/nested = gterm#case/nested.
%abbrev permission`gterm#case/predcall* = gterm#case/predcall*.
%abbrev permission`predicate#case/#level = predicate#case/#level.
%abbrev permission`predicate#case/#nolevel = predicate#case/#nolevel.
%abbrev permission`predicate#case/predicate/0 = predicate#case/predicate/0.
%abbrev permission`predicate#case/predicate/+ = predicate#case/predicate/+.
%abbrev permission`predicate#case/predicate/Y = predicate#case/predicate/Y.
%abbrev permission`gterm#case-total = gterm#case-total.
%abbrev permission`fake = fake.
%abbrev permission`predicate#case-total = predicate#case-total.
%abbrev permission`fake = fake.
%abbrev permission`gterm#map-total* = gterm#map-total*.
%abbrev permission`gterm#map-total/L = gterm#map-total/L.
%abbrev permission`predicate#map-total* = predicate#map-total*.
%abbrev permission`predicate#map-total/L = predicate#map-total/L.
%abbrev permission`predargs#map-total* = predargs#map-total*.
%abbrev permission`gterm#map-total = gterm#map-total.
%abbrev permission`predicate#map-total = predicate#map-total.
%abbrev permission`predargs#map-total = predargs#map-total.
%abbrev permission`gterm#level-deterministic = gterm#level-deterministic.
%abbrev permission`predicate#level-deterministic = predicate#level-deterministic.
%abbrev permission`gterm#map-deterministic* = gterm#map-deterministic*.
%abbrev permission`predicate#map-deterministic* = predicate#map-deterministic*.
%abbrev permission`predargs#map-deterministic* = predargs#map-deterministic*.
%abbrev permission`gterm#map-deterministic = gterm#map-deterministic.
%abbrev permission`predicate#map-deterministic = predicate#map-deterministic.
%abbrev permission`predargs#map-deterministic = predargs#map-deterministic.
%abbrev permission`gterm#var-implies-nolevel = gterm#var-implies-nolevel.
%abbrev permission`gterm#var-implies-nolevel/L = gterm#var-implies-nolevel/L.
%abbrev permission`predicate#var-implies-nolevel = predicate#var-implies-nolevel.
%abbrev permission`predicate#var-implies-nolevel/L = predicate#var-implies-nolevel/L.
%abbrev permission`gterm#map-onto/0/gterm/termk/formulak = gterm#map-onto/0/gterm/termk/formulak.
%abbrev permission`predicate#map-onto/0 = predicate#map-onto/0.
%abbrev permission`gterm#map-onto/0 = gterm#map-onto/0.
%abbrev permission`gterm#map-onto/0/gterm/objectk = gterm#map-onto/0/gterm/objectk.
%abbrev permission`gterm#map-onto/0/gterm/fractionk = gterm#map-onto/0/gterm/fractionk.
%abbrev permission`gterm#map-onto/0/gterm/termk/permissionk = gterm#map-onto/0/gterm/termk/permissionk.
%abbrev permission`gterm#map-onto/0/gterm/termk/upermk = gterm#map-onto/0/gterm/termk/upermk.
%abbrev permission`predargs#map-onto/0 = predargs#map-onto/0.
%abbrev permission`predargs#map-onto/1 = predargs#map-onto/1.
%abbrev permission`gterm/objectk#map-onto/L = gterm/objectk#map-onto/L.
%abbrev permission`gterm/fractionk#map-onto/L = gterm/fractionk#map-onto/L.
%abbrev permission`gterm/termk/permissionk#map-onto/L = gterm/termk/permissionk#map-onto/L.
%abbrev permission`gterm/termk/upermk#map-onto/L = gterm/termk/upermk#map-onto/L.
%abbrev permission`gterm/termk/formulak#map-onto/L = gterm/termk/formulak#map-onto/L.
%abbrev permission`gterm#map-onto = gterm#map-onto.
%abbrev permission`predicate/predtype/0#map-onto/L = predicate/predtype/0#map-onto/L.
%abbrev permission`predicate/predtype/+#map-onto/L = predicate/predtype/+#map-onto/L.
%abbrev permission`predicate#map-onto = predicate#map-onto.
%abbrev permission`predargs/predtype/0#map-onto/L = predargs/predtype/0#map-onto/L.
%abbrev permission`predargs/predtype/+#map-onto/L = predargs/predtype/+#map-onto/L.
%abbrev permission`predargs#map-onto = predargs#map-onto.
%abbrev permission`empty-respects-gterm#eq = empty-respects-gterm#eq.
%abbrev permission`scale-respects-gterm#eq = scale-respects-gterm#eq.
%abbrev permission`combine-respects-gterm#eq = combine-respects-gterm#eq.
%abbrev permission`unitperm-respects-gterm#eq = unitperm-respects-gterm#eq.
%abbrev permission`nonlinear-respects-gterm#eq = nonlinear-respects-gterm#eq.
%abbrev permission`conditional-respects-gterm#eq = conditional-respects-gterm#eq.
%abbrev permission`encumbered-respects-gterm#eq = encumbered-respects-gterm#eq.
%abbrev permission`gterm#func-eq/gterm = gterm#func-eq/gterm.
%abbrev permission`gterm#func-eq/gterm-respects-eq = gterm#func-eq/gterm-respects-eq.
%abbrev permission`precise-exists-respects-gterm#eq = precise-exists-respects-gterm#eq.
%abbrev permission`basic-respects-gterm#eq = basic-respects-gterm#eq.
%abbrev permission`object/-respects-gterm#eq = object/-respects-gterm#eq.
%abbrev permission`fraction/-respects-gterm#eq = fraction/-respects-gterm#eq.
%abbrev permission`t-respects-gterm#eq = t-respects-gterm#eq.
%abbrev permission`neg-respects-gterm#eq = neg-respects-gterm#eq.
%abbrev permission`conj-respects-gterm#eq = conj-respects-gterm#eq.
%abbrev permission`objequal-respects-gterm#eq = objequal-respects-gterm#eq.
%abbrev permission`exists*-respects-gterm#eq = exists*-respects-gterm#eq.
%abbrev permission`nested-respects-gterm#eq = nested-respects-gterm#eq.
%abbrev permission`predcall*-respects-gterm#eq = predcall*-respects-gterm#eq.
%abbrev permission`predicate/0-respects-predicate#eq = predicate/0-respects-predicate#eq.
%abbrev permission`predicate#func-eq/gterm = predicate#func-eq/gterm.
%abbrev permission`predicate#func-eq/gterm-respects-eq = predicate#func-eq/gterm-respects-eq.
%abbrev permission`predicate/+-respects-predicate#eq = predicate/+-respects-predicate#eq.
%abbrev permission`predicate#func-eq/predicate = predicate#func-eq/predicate.
%abbrev permission`predicate#func-eq/predicate-respects-eq = predicate#func-eq/predicate-respects-eq.
%abbrev permission`predicate/Y-respects-predicate#eq = predicate/Y-respects-predicate#eq.
%abbrev permission`predargs/0*-respects-predargs#eq = predargs/0*-respects-predargs#eq.
%abbrev permission`predargs/+-respects-predargs#eq = predargs/+-respects-predargs#eq.
%abbrev permission`gterm#func-eq/gterm/ = gterm#func-eq/gterm/.
%abbrev permission`predicate#func-eq/gterm/ = predicate#func-eq/gterm/.
%abbrev permission`predicate#func-eq/predicate/ = predicate#func-eq/predicate/.
%abbrev permission`gterm#map-one2one = gterm#map-one2one.
%abbrev permission`predicate#map-one2one = predicate#map-one2one.
%abbrev permission`predargs#map-one2one = predargs#map-one2one.
%abbrev permission`gterm#map-one2one/gterm#func-eq/gterm = gterm#map-one2one/gterm#func-eq/gterm.
%abbrev permission`predicate#map-one2one/predicate#func-eq/predicate = predicate#map-one2one/predicate#func-eq/predicate.
%abbrev permission`predicate#map-one2one/predicate#func-eq/gterm = predicate#map-one2one/predicate#func-eq/gterm.
%abbrev permission`gterm#eq?-total* = gterm#eq?-total*.
%abbrev permission`gterm#eq-ne-implies-false = gterm#eq-ne-implies-false.
%abbrev permission`predicate#eq?-total* = predicate#eq?-total*.
%abbrev permission`predicate#eq-ne-implies-false = predicate#eq-ne-implies-false.
%abbrev permission`predargs#eq?-total* = predargs#eq?-total*.
%abbrev permission`predargs#eq-ne-implies-false = predargs#eq-ne-implies-false.
%abbrev permission`gterm#eq?-total = gterm#eq?-total.
%abbrev permission`predicate#eq?-total = predicate#eq?-total.
%abbrev permission`predargs#eq?-total = predargs#eq?-total.
%abbrev permission`gterm#eq?-total/L1 = gterm#eq?-total/L1.
%abbrev permission`gterm#eq?-total/L2 = gterm#eq?-total/L2.
%abbrev permission`predicate#eq?-total/L1 = predicate#eq?-total/L1.
%abbrev permission`predicate#eq?-total/L2 = predicate#eq?-total/L2.
%abbrev permission`predargs#eq?-total/L1 = predargs#eq?-total/L1.
%abbrev permission`predargs#eq?-total/L2 = predargs#eq?-total/L2.
%abbrev permission`eq = eq.
%abbrev permission`eq/ = eq/.
%abbrev permission`ne = ne.
%abbrev permission`eq? = eq?.
%abbrev permission`eq?/yes = eq?/yes.
%abbrev permission`eq?/no = eq?/no.
%abbrev permission`meta-eq = meta-eq.
%abbrev permission`false-implies-eq = false-implies-eq.
%abbrev permission`eq-reflexive = eq-reflexive.
%abbrev permission`eq-symmetric = eq-symmetric.
%abbrev permission`eq-transitive = eq-transitive.
%abbrev permission`object-eq-implies-eq = object-eq-implies-eq.
%abbrev permission`object-preserves-eq = object-preserves-eq.
%abbrev permission`unit-eq-implies-eq = unit-eq-implies-eq.
%abbrev permission`false-implies-ne = false-implies-ne.
%abbrev permission`eq-ne-implies-false = eq-ne-implies-false.
%abbrev permission`ne-anti-reflexive = ne-anti-reflexive.
%abbrev permission`ne-symmetric = ne-symmetric.
%abbrev permission`eq?-total* = eq?-total*.
%abbrev permission`eq?-total = eq?-total.
%abbrev permission`term2nat = term2nat.
%abbrev permission`nat2term = nat2term.
%abbrev permission`prec = prec.
%abbrev permission`prec/ = prec/.
%abbrev permission`compare = compare.
%abbrev permission`compare/< = compare/<.
%abbrev permission`compare/= = compare/=.
%abbrev permission`compare/> = compare/>.
%abbrev permission`false-implies-term2nat = false-implies-term2nat.
%abbrev permission`false-implies-not2term = false-implies-not2term.
%abbrev permission`term2nat-respects-eq = term2nat-respects-eq.
%abbrev permission`nat2term-respects-eq = nat2term-respects-eq.
%abbrev permission`term2nat-total* = term2nat-total*.
%abbrev permission`term2nat-total = term2nat-total.
%abbrev permission`nat2term-total* = nat2term-total*.
%abbrev permission`nat2term-total = nat2term-total.
%abbrev permission`term2nat-deterministic = term2nat-deterministic.
%abbrev permission`nat2term-deterministic = nat2term-deterministic.
%abbrev permission`nat2term-deterministic/L = nat2term-deterministic/L.
%abbrev permission`term2nat-preserves-ne = term2nat-preserves-ne.
%abbrev permission`term2nat-preserves-ne/L = term2nat-preserves-ne/L.
%abbrev permission`nat2term-preserves-ne = nat2term-preserves-ne.
%abbrev permission`nat2term-preserves-ne/L = nat2term-preserves-ne/L.
%abbrev permission`prec-anti-reflexive = prec-anti-reflexive.
%abbrev permission`prec-anti-symmetric = prec-anti-symmetric.
%abbrev permission`prec-transitive = prec-transitive.
%abbrev permission`compare-respects-eq = compare-respects-eq.
%abbrev permission`compare-total* = compare-total*.
%abbrev permission`compare-total*/L = compare-total*/L.
%abbrev permission`compare-total = compare-total.
%abbrev permission`equiv = equiv.
%abbrev permission`equiv/identity = equiv/identity.
%abbrev permission`equiv/commute = equiv/commute.
%abbrev permission`equiv/associate = equiv/associate.
%abbrev permission`equiv/combine = equiv/combine.
%abbrev permission`equiv/zero = equiv/zero.
%abbrev permission`equiv/one = equiv/one.
%abbrev permission`equiv/distribute = equiv/distribute.
%abbrev permission`equiv/mul = equiv/mul.
%abbrev permission`equiv/add = equiv/add.
%abbrev permission`equiv/reflexive = equiv/reflexive.
%abbrev permission`equiv/symmetric = equiv/symmetric.
%abbrev permission`equiv/transitive = equiv/transitive.
%abbrev permission`equiv/transitive2 = equiv/transitive2.
%abbrev permission`equiv/transitive3 = equiv/transitive3.
%abbrev permission`equiv/transitive4 = equiv/transitive4.
%abbrev permission`equiv/transitive5 = equiv/transitive5.
%abbrev permission`equiv/transitive6 = equiv/transitive6.
%abbrev permission`equiv/transitive7 = equiv/transitive7.
%abbrev permission`equiv/transitive8 = equiv/transitive8.
%abbrev permission`equiv/reorder = equiv/reorder.
%abbrev permission`equiv/double-associate = equiv/double-associate.
%abbrev permission`equiv/roll2 = equiv/roll2.
%abbrev permission`equiv/roll3 = equiv/roll3.
%abbrev permission`equiv/roll4 = equiv/roll4.
%abbrev permission`equiv/roll5 = equiv/roll5.
%abbrev permission`equiv/roll6 = equiv/roll6.
%abbrev permission`equiv/roll7 = equiv/roll7.
%abbrev permission`null = null.
%abbrev permission`null/0 = null/0.
%abbrev permission`null/* = null/*.
%abbrev permission`null/+ = null/+.
%abbrev permission`nonnull = nonnull.
%abbrev permission`nonnull/scale = nonnull/scale.
%abbrev permission`nonnull/combine/1 = nonnull/combine/1.
%abbrev permission`nonnull/combine/2 = nonnull/combine/2.
%abbrev permission`nonnull/combine/1+2 = nonnull/combine/1+2.
%abbrev permission`nonnull/unit = nonnull/unit.
%abbrev permission`null? = null?.
%abbrev permission`null?/yes = null?/yes.
%abbrev permission`null?/no = null?/no.
%abbrev permission`leq = leq.
%abbrev permission`leq/ = leq/.
%abbrev permission`false-implies-equiv = false-implies-equiv.
%abbrev permission`equiv-respects-eq = equiv-respects-eq.
%abbrev permission`equiv-reflexive = equiv-reflexive.
%abbrev permission`equiv-symmetric = equiv-symmetric.
%abbrev permission`equiv-transitive = equiv-transitive.
%abbrev permission`equiv/frac-admissible = equiv/frac-admissible.
%abbrev permission`false-implies-null = false-implies-null.
%abbrev permission`null-implies-equiv-empty = null-implies-equiv-empty.
%abbrev permission`equiv-preserves-null = equiv-preserves-null.
%abbrev permission`equiv-preserves-null-converse = equiv-preserves-null-converse.
%abbrev permission`equiv-empty-implies-null = equiv-empty-implies-null.
%abbrev permission`false-implies-nonnull = false-implies-nonnull.
%abbrev permission`nonnull-respects-equ = nonnull-respects-equ.
%abbrev permission`null-nonnull-contradiction = null-nonnull-contradiction.
%abbrev permission`nonnull-deterministic = nonnull-deterministic.
%abbrev permission`equiv-preserves-nonnull = equiv-preserves-nonnull.
%abbrev permission`equiv-preserves-nonnull-converse = equiv-preserves-nonnull-converse.
%abbrev permission`null?-total* = null?-total*.
%abbrev permission`null?-total*/combine = null?-total*/combine.
%abbrev permission`null?-total*/scale = null?-total*/scale.
%abbrev permission`null?-total = null?-total.
%abbrev permission`combine-right-identity-null = combine-right-identity-null.
%abbrev permission`combine-right-identity-null/L = combine-right-identity-null/L.
%abbrev permission`false-implies-leq = false-implies-leq.
%abbrev permission`leq-respects-eq = leq-respects-eq.
%abbrev permission`leq-reflexive = leq-reflexive.
%abbrev permission`leq-anti-symmetric = leq-anti-symmetric.
%abbrev permission`leq-transitive = leq-transitive.
