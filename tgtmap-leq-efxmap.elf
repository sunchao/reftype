%%% leq relation from tgtmap to efxmap
%%% Most of theorems here can delegate to map`leq

% ========================================
% ============== Definitions =============
% ========================================

tgtmap`leq-efxmap : tgtmap -> efxmap -> type.

tgtmap`leq-efxmap/
  : tgtmap`leq-efxmap GM XM
    <- efxmap2tgtmap XM GMP
    <- tgtmap`leq GM GMP.


% ========================================
% ============== Theorems ================
% ========================================


%theorem tgtmap`false-implies-leq-efxmap
  : forall* {GM} {XM}
    forall {F: void} exists {L: tgtmap`leq-efxmap GM XM} true.

%worlds () (tgtmap`false-implies-leq-efxmap _ _).
%total {} (tgtmap`false-implies-leq-efxmap _ _).


%theorem tgtmap`leq-efxmap-respects-eq
  : forall* {GM} {XM} {GMP} {XMP}
    forall {L: tgtmap`leq-efxmap GM XM}
    {E: tgtmap`eq GM GMP}
    {E: efxmap`eq XM XMP}
    exists {L: tgtmap`leq-efxmap GMP XMP}
    true.

- : tgtmap`leq-efxmap-respects-eq
    (tgtmap`leq-efxmap/ GM<=XGM XM2XGM) GM=GMP XM=XMP
    (tgtmap`leq-efxmap/ GM<=XGM1 XM2XGM1)
    <- efxmap2tgtmap-respects-eq XM2XGM XM=XMP tgtmap`eq/ XM2XGM1
    <- tgtmap`leq-respects-eq GM<=XGM GM=GMP tgtmap`eq/ GM<=XGM1.

%worlds () (tgtmap`leq-efxmap-respects-eq _ _ _ _).
%total {} (tgtmap`leq-efxmap-respects-eq _ _ _ _).


%theorem tgtmap`leq-efxmap-right-transitive
  : forall* {GM} {XM1} {XM2}
    forall {L: tgtmap`leq-efxmap GM XM1}
    {L: efxmap`leq XM1 XM2}
    exists {L: tgtmap`leq-efxmap GM XM2}
    true.

- : tgtmap`leq-efxmap-right-transitive
    (tgtmap`leq-efxmap/ GM<=GM1 XM1=>GM1) XM1<=XM2
    (tgtmap`leq-efxmap/ GM<=GM2 XM2=>GM2)
    <- efxmap2tgtmap-total XM2=>GM2
    <- efxmap2tgtmap-preserves-leq* XM1<=XM2 XM1=>GM1 XM2=>GM2 GM1<=GM2
    <- tgtmap`leq-transitive GM<=GM1 GM1<=GM2 GM<=GM2.

%worlds () (tgtmap`leq-efxmap-right-transitive _ _ _).
%total {} (tgtmap`leq-efxmap-right-transitive _ _ _).


%theorem tgtmap`leq-efxmap-left-transitive
  : forall* {GM1} {GM2} {XM}
    forall {L: tgtmap`leq GM1 GM2}
    {L: tgtmap`leq-efxmap GM2 XM}
    exists {L: tgtmap`leq-efxmap GM1 XM}
    true.

- : tgtmap`leq-efxmap-left-transitive
    GM1<=GM2 (tgtmap`leq-efxmap/ GM2<=GM XM=>GM)
    (tgtmap`leq-efxmap/ GM1<=GM XM=>GM)
    <- tgtmap`leq-transitive GM1<=GM2 GM2<=GM GM1<=GM.

%worlds () (tgtmap`leq-efxmap-left-transitive _ _ _).
%total {} (tgtmap`leq-efxmap-left-transitive _ _ _).


%theorem tgtmap`leq-efxmap-transitive
  : forall* {G1} {G2} {M1} {M2}
    forall {G2<=M1: tgtmap`leq-efxmap G2 M1}
    {G1<=G2: tgtmap`leq G1 G2}
    {M1<=M2: efxmap`leq M1 M2}
    exists {G1<=M2: tgtmap`leq-efxmap G1 M2}
    true.

- : tgtmap`leq-efxmap-transitive G2<=M1 G1<=G2 M1<=M2 G1<=M2
    <- tgtmap`leq-efxmap-left-transitive G1<=G2 G2<=M1 G1<=M1
    <- tgtmap`leq-efxmap-right-transitive G1<=M1 M1<=M2 G1<=M2.

%worlds () (tgtmap`leq-efxmap-transitive _ _ _ _).
%total {} (tgtmap`leq-efxmap-transitive _ _ _ _).


%theorem tgtmap`lookup-respects-leq-efxmap
  : forall* {GM} {N} {S} {XM}
    forall {L: tgtmap`lookup GM N S}
    {LE: tgtmap`leq-efxmap GM XM}
    exists {M} {L: efxmap`lookup XM N M}
    {SP} {DM: inner-efxmap`domain M SP}
    {LE: set`leq S SP}
    true.

- : tgtmap`lookup-respects-leq-efxmap
    GM->N=S (tgtmap`leq-efxmap/ GM<=GMP XM=>GMP) M XM->N=M SP DM-M=SP S<=SP
    <- tgtmap`lookup-respects-leq GM->N=S GM<=GMP SP GMP->N=SP S<=SP
    <- efxmap2tgtmap-lookup-implies-lookup-converse
      XM=>GMP GMP->N=SP M DM-M=SP XM->N=M.

%worlds () (tgtmap`lookup-respects-leq-efxmap _ _ _ _ _ _ _).
%total {} (tgtmap`lookup-respects-leq-efxmap _ _ _ _ _ _ _).


%theorem tgtmap`lookup-respects-leq-efxmap*
  : forall* {GM} {XM} {N} {M} {S}
    forall {L: tgtmap`lookup GM N S}
    {LE: tgtmap`leq-efxmap GM XM}
    {L: efxmap`lookup XM N M}
    exists {SP} {DM: inner-efxmap`domain M SP}
    {LE: set`leq S SP}
    true.

- : tgtmap`lookup-respects-leq-efxmap* L1 LE L2 SP DM SLE
    <- tgtmap`lookup-respects-leq-efxmap L1 LE _ L2x _ DMx SLE
    <- efxmap`lookup-unique L2x L2 efxmap`eq/ nat`eq/ E
    <- inner-efxmap`domain-respects-eq DMx E set`eq/ DM.

%worlds () (tgtmap`lookup-respects-leq-efxmap* _ _ _ _ _ _).
%total {} (tgtmap`lookup-respects-leq-efxmap* L _ _ _ _ _).


%theorem tgtmap`fresh-respects-geq-efxmap
  : forall* {XM} {GM} {N}
    forall {FS: efxmap`fresh XM N}
    {LE: tgtmap`leq-efxmap GM XM}
    exists {FS: tgtmap`fresh GM N}
    true.

- : tgtmap`fresh-respects-geq-efxmap
    N!<XM (tgtmap`leq-efxmap/ GM<=GMP XM=>GMP) N!<GM
    <- efxmap2tgtmap-preserves-fresh N!<XM XM=>GMP N!<GMP
    <- tgtmap`fresh-respects-geq N!<GMP GM<=GMP N!<GM.

%worlds () (tgtmap`fresh-respects-geq-efxmap _ _ _).
%total {} (tgtmap`fresh-respects-geq-efxmap _ _ _).


%theorem tgtmap`leq-efxmap-implies-size-le
  : forall* {GM} {XM} {N1} {N2}
    forall {LE: tgtmap`leq-efxmap GM XM}
    {SZ: tgtmap`size GM N1} {SZ: efxmap`size XM N2}
    exists {G: nat`ge N2 N1}
    true.

- : tgtmap`leq-efxmap-implies-size-le
    (tgtmap`leq-efxmap/ GM<=GMP XM=>GMP) SZ-GM=N1 SZ-XM=N2 N2>=N1
    <- efxmap2tgtmap-preserves-size SZ-XM=N2 XM=>GMP SZ-GMP=N2
    <- tgtmap`leq-implies-size-le GM<=GMP SZ-GM=N1 SZ-GMP=N2 N2>=N1.

%worlds () (tgtmap`leq-efxmap-implies-size-le _ _ _ _).
%total {} (tgtmap`leq-efxmap-implies-size-le _ _ _ _).


%theorem tgtmap`update-left-preserves-leq-efxmap*
  : forall* {GM} {XM} {N} {S} {M} {GMS} {XMS}
    forall {LE: tgtmap`leq-efxmap GM XM}
    {U: tgtmap`update GM N S GMS}
    {U: efxmap`update XM N M XMS}
    {DM: inner-efxmap`domain M S}
    exists {LE: tgtmap`leq-efxmap GMS XMS}
    true.

- : tgtmap`update-left-preserves-leq-efxmap*
    (tgtmap`leq-efxmap/ GM<=GMP XM=>GMP) GM+N+S=GMS XM+N+M=XMS DM-M=S
    (tgtmap`leq-efxmap/ GMS<=GMPS XMS=>GMPS)
    <- tgtmap`update-total GMP+N+S=GMPS
    <- update-preserves-efxmap2tgtmap
      XM=>GMP DM-M=S XM+N+M=XMS GMP+N+S=GMPS XMS=>GMPS
    <- set`leq-reflexive _ S<=S
    <- tgtmap`update-preserves-leq*
      GM<=GMP S<=S GM+N+S=GMS GMP+N+S=GMPS GMS<=GMPS.

%worlds () (tgtmap`update-left-preserves-leq-efxmap* _ _ _ _ _).
%total {} (tgtmap`update-left-preserves-leq-efxmap* _ _ _ _ _).


%theorem tgtmap`update-preserves-leq-efxmap
  : forall* {GM} {XM} {N} {S} {GMS} {XMS} {SP} {M}
    forall {LE: tgtmap`leq-efxmap GM XM}
    {U: tgtmap`update GM N S GMS}
    {U: efxmap`update XM N M XMS}
    {D: inner-efxmap`domain M SP}
    {LE: set`leq S SP}
    exists {LE: tgtmap`leq-efxmap GMS XMS}
    true.

- : tgtmap`update-preserves-leq-efxmap
    (tgtmap`leq-efxmap/ GM<=GMP XM=>GMP) GM+N+S=GMS XM+N+M=XMS DM-M=SP S<=SP
    (tgtmap`leq-efxmap/ GMS<=GMPS XMS=>GMPS)
    <- tgtmap`update-total GMP+N+S=GMPS
    <- update-preserves-efxmap2tgtmap
      XM=>GMP DM-M=SP XM+N+M=XMS GMP+N+S=GMPS XMS=>GMPS
    <- tgtmap`update-preserves-leq*
      GM<=GMP S<=SP GM+N+S=GMS GMP+N+S=GMPS GMS<=GMPS.

%worlds () (tgtmap`update-preserves-leq-efxmap _ _ _ _ _ _).
%total {} (tgtmap`update-preserves-leq-efxmap _ _ _ _ _ _).


%theorem tgtmap`fresh-update-preserves-leq-efxmap-converse
  : forall* {GM} {XM} {GMP} {XMP} {N} {S} {M}
    forall {LE: tgtmap`leq-efxmap GM XM}
    {F: tgtmap`fresh GMP N}
    {U: tgtmap`update GMP N S GM}
    {F: efxmap`fresh XMP N }
    {U: efxmap`update XMP N M XM}
    exists {LE: tgtmap`leq-efxmap GMP XMP}
    true.

- : tgtmap`fresh-update-preserves-leq-efxmap-converse
    (tgtmap`leq-efxmap/ GM<=GMS XM=>GMS) N!<GMP GMP+N=GM N!<XMP XMP+N=XM
    (tgtmap`leq-efxmap/ GMP<=GMSx XMP=>GMSx)
    <- tgtmap`update-implies-lookup GMP+N=GM GM->N=_
    <- tgtmap`lookup-respects-leq GM->N=_ GM<=GMS _ GMS->N=_ _
    <- tgtmap`lookup-implies-fresh-update GMS->N=_ GMSx N!<GMSx GMSx+N=GMS
    <- fresh-update-preserves-efxmap2tgtmap-converse*
      XM=>GMS N!<XMP XMP+N=XM N!<GMSx GMSx+N=GMS XMP=>GMSx
    <- tgtmap`fresh-update-preserves-leq-converse
      GM<=GMS N!<GMP GMP+N=GM N!<GMSx GMSx+N=GMS GMP<=GMSx _.

%worlds () (tgtmap`fresh-update-preserves-leq-efxmap-converse _ _ _ _ _ _ ).
%total {} (tgtmap`fresh-update-preserves-leq-efxmap-converse _ _ _ _ _ _).


%theorem tgtmap`fresh-update2-preserves-leq-efxmap-converse
  : forall* {GM} {XM} {N} {M} {XMP}
    forall {LE: tgtmap`leq-efxmap GM XM}
    {F: tgtmap`fresh GM N}
    {F: efxmap`fresh XMP N}
    {U: efxmap`update XMP N M XM}
    exists {LE: tgtmap`leq-efxmap GM XMP}
    true.

- : tgtmap`fresh-update2-preserves-leq-efxmap-converse
    (tgtmap`leq-efxmap/ GM<=GMS XM=>GMS) N!<GM N!<XMP XMP+N=XM
    (tgtmap`leq-efxmap/ GM<=GMSx XMP=>GMSx)
    <- efxmap`update-implies-lookup XMP+N=XM XM->N=_
    <- efxmap2tgtmap-lookup-implies-lookup XM=>GMS XM->N=_ _ _ GMS->N=_
    <- tgtmap`lookup-implies-fresh-update GMS->N=_ GMSx N!<GMSx GMSx+N=GMS
    <- fresh-update-preserves-efxmap2tgtmap-converse*
      XM=>GMS N!<XMP XMP+N=XM N!<GMSx GMSx+N=GMS XMP=>GMSx
    <- tgtmap`fresh-update2-preserves-leq-converse
      GM<=GMS N!<GM N!<GMSx GMSx+N=GMS GM<=GMSx.

%worlds () (tgtmap`fresh-update2-preserves-leq-efxmap-converse _ _ _ _ _).
%total {} (tgtmap`fresh-update2-preserves-leq-efxmap-converse _ _ _ _ _).


%theorem tgtmap`domain-preserves-leq-efxmap
  : forall* {GM} {XM} {S}
    forall {LE: tgtmap`leq-efxmap GM XM}
    {DM: tgtmap`domain GM S}
    exists {SP} {DM: efxmap`domain XM SP}
    {LE: set`leq S SP}
    true.

- : tgtmap`domain-preserves-leq-efxmap
    (tgtmap`leq-efxmap/ GM<=GMP XM=>GMP) DM-GM=S SP DM-XM=SP S<=SP
    <- tgtmap`domain-preserves-leq GM<=GMP DM-GM=S SP DM-GMP=SP S<=SP
    <- efxmap2tgtmap-preserves-domain-converse DM-GMP=SP XM=>GMP DM-XM=SP.

%worlds () (tgtmap`domain-preserves-leq-efxmap _ _ _ _ _).
%total {} (tgtmap`domain-preserves-leq-efxmap _ _ _ _ _).


%theorem tgtmap`domain-preserves-leq-efxmap*
  : forall* {GM} {XM} {S} {SP}
    forall {LE: tgtmap`leq-efxmap GM XM}
    {DM: tgtmap`domain GM S}
    {DM: efxmap`domain XM SP}
    exists {LE: set`leq S SP}
    true.

- : tgtmap`domain-preserves-leq-efxmap*
    (tgtmap`leq-efxmap/ GM<=GMP XM=>GMP) DM-GM=S DM-XM=SP S<=SP
    <- efxmap2tgtmap-preserves-domain DM-XM=SP XM=>GMP DM-GMP=SP
    <- tgtmap`domain-preserves-leq* GM<=GMP DM-GM=S DM-GMP=SP S<=SP.

%worlds () (tgtmap`domain-preserves-leq-efxmap* _ _ _ _).
%total {} (tgtmap`domain-preserves-leq-efxmap* _ _ _ _).


% sort of like map`leq-reflexive

%theorem tgtmap2efxmap-implies-leq-efxmap
  : forall* {GM} {X} {XM}
    forall {T: tgtmap2efxmap GM X XM}
    exists {LE: tgtmap`leq-efxmap GM XM}
    true.

- : tgtmap2efxmap-implies-leq-efxmap GM=>XM
    (tgtmap`leq-efxmap/ GM<=GM XM=>GM)
    <- tgtmap2efxmap-implies-efxmap2tgtmap GM=>XM XM=>GM
    <- tgtmap`leq-reflexive _ GM<=GM.

%worlds () (tgtmap2efxmap-implies-leq-efxmap _ _).
%total {} (tgtmap2efxmap-implies-leq-efxmap _ _).


%theorem empty-tgtmap-leq-efxmap*
  : forall {M}
    exists {LE: tgtmap`leq-efxmap tgtmap/0 M}
    true.

- : empty-tgtmap-leq-efxmap* _ (tgtmap`leq-efxmap/ tgtmap`leq/0 M2G)
    <- efxmap2tgtmap-total M2G.

%worlds () (empty-tgtmap-leq-efxmap* _ _).
%total {} (empty-tgtmap-leq-efxmap* _ _). 

%abbrev empty-tgtmap-leq-efxmap = empty-tgtmap-leq-efxmap* _.