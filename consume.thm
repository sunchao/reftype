% here, we need to prove that if we have two efxmap
% XM1 join XM2, and if XM2 contains all write permissions,
% then XM1 won't contain consume permission for all 
% corresponding write permissions in XM2.
%%% $Id: consume.thm,v 1.1 2013/03/04 22:24:38 csun Exp $

all-write : efxmap -> type.

all-write/inner : inner-efxmap -> type.

all-write/inner/0 : all-write/inner inner-efxmap/0.

all-write/inner/+ 
  : all-write/inner (inner-efxmap/+ _ efx/write M)
    <- all-write/inner M.


all-write/0 : all-write efxmap/0.

all-write/+
  : all-write (efxmap/+ _ M XM)
    <- all-write/inner M
    <- all-write XM.


%theorem set+nat2tgtmap-write-implies-all-write :
    forall* {S} {F} {XM} {GM}
    forall  {S+F=XM: set+nat2tgtmap S F GM}
            {GM=>XM: tgtmap2efxmap GM efx/write XM}
    exists  {W-XM: all-write XM}
    true.

- : set+nat2tgtmap-write-implies-all-write
    set+nat2tgtmap/0 tgtmap2efxmap/0 all-write/0.

- : set+nat2tgtmap-write-implies-all-write
    (set+nat2tgtmap/+ S+F=GM) 
    (tgtmap2efxmap/+ GM=>XM (set2inner-efxmap/+ set2inner-efxmap/0))
    (all-write/+ W-XM (all-write/inner/+ all-write/inner/0))
    <- set+nat2tgtmap-write-implies-all-write S+F=GM GM=>XM W-XM.

%worlds () (set+nat2tgtmap-write-implies-all-write _ _ _).
%total (S) (set+nat2tgtmap-write-implies-all-write S _ _).



filter-consume : efxmap -> efxmap -> type.

filter-consume/0 : filter-consume efxmap/0 efxmap/0.


filter-consume/inner : inner-efxmap -> set -> type.

filter-consume/inner/0 : filter-consume/inner inner-efxmap/0 set/0.
 
filter-consume/inner/consume
  : filter-consume/inner (inner-efxmap/+ F efx/consume M) S
    <- inner-efxmap`shift F M MS
    <- filter-consume/inner MS SS
    <- set`add SS F S.

filter-consume/inner/write
  : filter-consume/inner (inner-efxmap/+ F efx/write M) S
    <- inner-efxmap`shift F M MS
    <- filter-consume/inner MS S.

filter-consume/inner/read
  : filter-consume/inner (inner-efxmap/+ F efx/read M) S
    <- inner-efxmap`shift F M MS
    <- filter-consume/inner MS S.


filter-consume/+
  : filter-consume (efxmap/+ L M XM) XMO
    <- efxmap`shift L XM XM'
    <- filter-consume/inner M S
    <- inner-efxmap`restrict M S MO
    <- filter-consume XM' XMO'
    <- efxmap`update XMO' L MO XMO.


%theorem filter-consume/inner-implies-size-leq :
    forall* {M} {S} {MS}
    forall  {F: filter-consume/inner M S}
            {D: inner-efxmap`domain M MS}
    exists  {LEQ: set`leq S MS}
    true.

- : filter-consume/inner-implies-size-leq 
    filter-consume/inner/0 inner-efxmap`domain/0 set`leq/0.

- : filter-consume/inner-implies-size-leq 
    (filter-consume/inner/consume SS+F=S MS=>SS SH-M=MS)
    (inner-efxmap`domain/+ DM-M) S<=MS
    <- inner-efxmap`shift-preserves-domain DM-M SH-M=MS _ SH-MSS DM-MS
    <- filter-consume/inner-implies-size-leq MS=>SS DM-MS SS<=MSS
    <- set`shift-implies-update SH-MSS MSS+F=MS
    <- set`update-left-preserves-leq* SS<=MSS SS+F=S MSS+F=MS S<=MS.

- : filter-consume/inner-implies-size-leq 
    (filter-consume/inner/write MS=>S SH-M=MS)
    (inner-efxmap`domain/+ DM-M) S<=MS
    <- inner-efxmap`shift-preserves-domain DM-M SH-M=MS _ SH-MSS DM-MS
    <- filter-consume/inner-implies-size-leq MS=>S DM-MS S<=MSS
    <- set`shift-implies-update SH-MSS UD-MSS
    <- set`add-implies-leq UD-MSS MSS<=MS
    <- set`leq-transitive S<=MSS MSS<=MS S<=MS.

- : filter-consume/inner-implies-size-leq 
    (filter-consume/inner/read MS=>S SH-M=MS)
    (inner-efxmap`domain/+ DM-M) S<=MS
    <- inner-efxmap`shift-preserves-domain DM-M SH-M=MS _ SH-MSS DM-MS
    <- filter-consume/inner-implies-size-leq MS=>S DM-MS S<=MSS
    <- set`shift-implies-update SH-MSS UD-MSS
    <- set`add-implies-leq UD-MSS MSS<=MS
    <- set`leq-transitive S<=MSS MSS<=MS S<=MS.

%worlds () (filter-consume/inner-implies-size-leq _ _ _).
%total (F) (filter-consume/inner-implies-size-leq F _ _).


%theorem filter-consume-implies-size-leq :
    forall* {M1} {M2} {S1} {S2}
    forall  {F: filter-consume M1 M2}
            {D1: efxmap`domain M1 S1}
            {D2: efxmap`domain M2 S2}
    exists  {S2<=S1: set`leq S2 S1}
    true.

- : filter-consume-implies-size-leq filter-consume/0 _ _ set`leq/0.

- : filter-consume-implies-size-leq
    (filter-consume/+ M2P+L=M2 FC-M1P=M2P _ _ SH) 
    DM1 DM2 S2<=S1
    <- efxmap`domain-total DD1
    <- efxmap`domain-total DD2
    <- efxmap`shift-implies-update SH M1P+L=M1
    <- filter-consume-implies-size-leq FC-M1P=M2P DD1 DD2 S2P<=S1P
    <- efxmap`update-commute-domain M1P+L=M1 DD1 DM1 S1P+L=S1
    <- efxmap`update-commute-domain M2P+L=M2 DD2 DM2 S2P+L=S2
    <- set`update-preserves-leq* S2P<=S1P unit`eq/
      S2P+L=S2 S1P+L=S1 S2<=S1.
      
%worlds () (filter-consume-implies-size-leq _ _ _ _).
%total (F) (filter-consume-implies-size-leq F _ _ _).


%theorem filter-consume-preserves-fresh :
    forall* {M1} {M2} {N}
    forall  {F: filter-consume M1 M2}
            {FS: efxmap`fresh M1 N}
    exists  {FS: efxmap`fresh M2 N}
    true.

- : filter-consume-preserves-fresh 
    F FS FS2
    <- efxmap`domain-total DM1 
    <- efxmap`domain-total DM2
    <- filter-consume-implies-size-leq F DM1 DM2 S2<=S1
    <- efxmap`domain-preserves-fresh FS DM1 N!<S1
    <- set`not-member-respects-geq N!<S1 S2<=S1 N!<S2
    <- efxmap`domain-preserves-fresh-converse N!<S2 DM2 FS2.

%worlds () (filter-consume-preserves-fresh _ _ _).
%total  {} (filter-consume-preserves-fresh _ _ _).


%theorem only-consume-once/inner/L :
    forall* {M} {S1} {S2} {M1} {M2}
    forall  {N1} {SZ1: inner-efxmap`size M1 N1}
            {N2} {SZ2: inner-efxmap`size M2 N2}
            {U: inner-efxmap`join M1 M2 M}
            {F: filter-consume/inner M1 S1}
            {D: inner-efxmap`domain M2 S2}
    exists  {D: set`disjoint S1 S2}
    true.

% the join/= consume case is not possible
     
- : only-consume-once/inner/L
    _ _ _ _ inner-efxmap`join/L filter-consume/inner/0 _ set`disjoint/L.
    
- : only-consume-once/inner/L _ _ _ _ inner-efxmap`join/R _ _ set`disjoint/R.

- : only-consume-once/inner/L
    _ SZ-M1 _ (inner-efxmap`size/+ SZ-M2)
    (inner-efxmap`join/> J P) FC
    (inner-efxmap`domain/+ DM-M2) DDD
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- inner-efxmap`shift-total SH-M2
    <- inner-efxmap`domain-total DM-M1
    <- inner-efxmap`shift-preserves-size SZ-M2 SH-M2 SZ-M2S
    <- inner-efxmap`shift-preserves-join 
      J (inner-efxmap`shift/+ P2) SH-M2 _ SH-M JS
    <- inner-efxmap`shift-preserves-domain DM-M2 SH-M2 _ SH-S2 DM-M2S
    <- filter-consume/inner-implies-size-leq FC DM-M1 LEQ
    <- nat`plus-implies-gt P nat`eq/ GT
    <- inner-efxmap`domain-preserves-fresh 
      (inner-efxmap`fresh/< GT) DM-M1 FS2
    <- set`not-member-respects-geq FS2 LEQ FS3
    <- only-consume-once/inner/L _ SZ-M1 _ SZ-M2S JS FC DM-M2S S1S-D-S2S
    <- set`shift-implies-update SH-S2 UD-S2
    <- set`not-member-add-preserves-disjoint S1S-D-S2S FS3 UD-S2 DDD.

- : only-consume-once/inner/L
    _ (inner-efxmap`size/+ SZ-M1) _ SZ-M2
    (inner-efxmap`join/< M1-U-NM2=M P)
    (filter-consume/inner/consume S1S+F=S1 FC-M1S=S1S SH-M1=M1S)
    (inner-efxmap`domain/+ DM-M2) S1-D-S2S
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- inner-efxmap`shift-preserves-join
      M1-U-NM2=M SH-M1=M1S (inner-efxmap`shift/+ P2) _ SH-M=MS M1S-U-NM2S=MS 
    <- inner-efxmap`shift-preserves-size SZ-M1 SH-M1=M1S SZ-M1S
    <- only-consume-once/inner/L _ SZ-M1S _ SZ-M2
      M1S-U-NM2S=MS FC-M1S=S1S (inner-efxmap`domain/+ DM-M2) S1S-D-S2S
    <- set`disjoint-symmetric S1S-D-S2S S2S-D-S1S
    <- nat`plus-implies-gt P nat`eq/ GT
    <- set`not-member-add-preserves-disjoint
      S2S-D-S1S (set`not-member/< GT) S1S+F=S1 S2S-D-S1
    <- set`disjoint-symmetric S2S-D-S1 S1-D-S2S.
      
- : only-consume-once/inner/L
    _ (inner-efxmap`size/+ SZ-M1) _ SZ-M2
    (inner-efxmap`join/< M1-U-NM2=M P)
    (filter-consume/inner/write FC-M1S=S1S SH-M1=M1S)
    (inner-efxmap`domain/+ DM-M2) S1-D-S2
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- inner-efxmap`shift-preserves-join
      M1-U-NM2=M SH-M1=M1S (inner-efxmap`shift/+ P2) _ SH-M=MS M1S-U-NM2S=MS 
    <- inner-efxmap`shift-preserves-size SZ-M1 SH-M1=M1S SZ-M1S
    <- only-consume-once/inner/L _ SZ-M1S _ SZ-M2
      M1S-U-NM2S=MS FC-M1S=S1S (inner-efxmap`domain/+ DM-M2) S1-D-S2.

- : only-consume-once/inner/L 
    _ (inner-efxmap`size/+ SZ-M1) _ SZ-M2
    (inner-efxmap`join/< M1-U-NM2=M P)
    (filter-consume/inner/read FC-M1S=S1S SH-M1=M1S)
    (inner-efxmap`domain/+ DM-M2) S1-D-S2
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- inner-efxmap`shift-preserves-join
      M1-U-NM2=M SH-M1=M1S (inner-efxmap`shift/+ P2) _ SH-M=MS M1S-U-NM2S=MS 
    <- inner-efxmap`shift-preserves-size SZ-M1 SH-M1=M1S SZ-M1S
    <- only-consume-once/inner/L _ SZ-M1S _ SZ-M2
      M1S-U-NM2S=MS FC-M1S=S1S (inner-efxmap`domain/+ DM-M2) S1-D-S2.

- : only-consume-once/inner/L 
    _ (inner-efxmap`size/+ SZ-M1) _ (inner-efxmap`size/+ SZ-M2)
    (inner-efxmap`join/= M1-U-M2 _ nat`eq/)
    (filter-consume/inner/write F-M1S=S1 SH-M1=M1S)
    (inner-efxmap`domain/+ DM-M2) DDD
    <- inner-efxmap`shift-total SH-M2=M2S
    <- inner-efxmap`shift-preserves-join
      M1-U-M2 SH-M1=M1S SH-M2=M2S _ SH-M3=M3S M1S-U-M2S=M3S
    <- inner-efxmap`shift-preserves-domain 
      DM-M2 SH-M2=M2S _ SH-S2=S2S DM-M2S=S2S
    <- inner-efxmap`shift-preserves-size SZ-M1 SH-M1=M1S SZ-M1S
    <- inner-efxmap`shift-preserves-size SZ-M2 SH-M2=M2S SZ-M2S
    <- only-consume-once/inner/L _ SZ-M1S _ SZ-M2S
      M1S-U-M2S=M3S F-M1S=S1 DM-M2S=S2S S1S-D-S2S
    <- inner-efxmap`domain-total DM-M1S
    <- filter-consume/inner-implies-size-leq F-M1S=S1 DM-M1S LEQ
    <- inner-efxmap`shift-implies-fresh SH-M1=M1S FS-M1S
    <- inner-efxmap`domain-preserves-fresh FS-M1S DM-M1S FS2
    <- set`not-member-respects-geq FS2 LEQ FS3
    <- set`shift-implies-update SH-S2=S2S UD-S2
    <- set`not-member-add-preserves-disjoint S1S-D-S2S FS3 UD-S2 DDD.

- : only-consume-once/inner/L 
    _ (inner-efxmap`size/+ SZ-M1) _ (inner-efxmap`size/+ SZ-M2)
    (inner-efxmap`join/= M1-U-M2 _ nat`eq/)
    (filter-consume/inner/read F-M1S=S1 SH-M1=M1S)
    (inner-efxmap`domain/+ DM-M2) DDD
    <- inner-efxmap`shift-total SH-M2=M2S
    <- inner-efxmap`shift-preserves-join
      M1-U-M2 SH-M1=M1S SH-M2=M2S _ SH-M3=M3S M1S-U-M2S=M3S
    <- inner-efxmap`shift-preserves-domain 
      DM-M2 SH-M2=M2S _ SH-S2=S2S DM-M2S=S2S
    <- inner-efxmap`shift-preserves-size SZ-M1 SH-M1=M1S SZ-M1S
    <- inner-efxmap`shift-preserves-size SZ-M2 SH-M2=M2S SZ-M2S
    <- only-consume-once/inner/L _ SZ-M1S _ SZ-M2S
      M1S-U-M2S=M3S F-M1S=S1 DM-M2S=S2S S1S-D-S2S
    <- inner-efxmap`domain-total DM-M1S
    <- filter-consume/inner-implies-size-leq F-M1S=S1 DM-M1S LEQ
    <- inner-efxmap`shift-implies-fresh SH-M1=M1S FS-M1S
    <- inner-efxmap`domain-preserves-fresh FS-M1S DM-M1S FS2
    <- set`not-member-respects-geq FS2 LEQ FS3
    <- set`shift-implies-update SH-S2=S2S UD-S2
    <- set`not-member-add-preserves-disjoint S1S-D-S2S FS3 UD-S2 DDD.

%worlds () (only-consume-once/inner/L _ _ _ _ _ _ _ _).
%total {N1 N2} (only-consume-once/inner/L N1 _ N2 _ _ _ _ _).


%theorem only-consume-once/inner :
    forall* {M} {S1} {S2} {M1} {M2}
    forall  {U: inner-efxmap`join M1 M2 M}
            {F: filter-consume/inner M1 S1}
            {D: inner-efxmap`domain M2 S2}
    exists  {X: set`disjoint S1 S2}
    true.

- : only-consume-once/inner U F D X
    <- inner-efxmap`size-total SZ-M1
    <- inner-efxmap`size-total SZ-M2
    <- only-consume-once/inner/L _ SZ-M1 _ SZ-M2 U F D X.

%worlds () (only-consume-once/inner _ _ _ _).
%total  {} (only-consume-once/inner _ _ _ _).


%theorem restrict-leq-implies-domain :
    forall* {M} {S} {SP} {MP}
    forall  {DM: inner-efxmap`domain M S}
            {R: inner-efxmap`restrict M SP MP}
            {L: set`leq SP S}
    exists  {DM: inner-efxmap`domain MP SP}
    true.

- : restrict-leq-implies-domain DM-M R SP<=S DM-MP=SP
    <- inner-efxmap`domain-total DM-MP=SS
    <- inner-efxmap`restrict-implies-domain-intersection* 
      R DM-M DM-MP=SS S-X-SP=SS
    <- set`intersection-commutative S-X-SP=SS SP-X-S=SS
    <- set`leq-implies-intersection SP<=S SP-X-S=SP
    <- set`intersection-deterministic 
      SP-X-S=SS SP-X-S=SP set`eq/ set`eq/ SS=SP
    <- inner-efxmap`domain-respects-eq 
      DM-MP=SS inner-efxmap`eq/ SS=SP DM-MP=SP.

%worlds () (restrict-leq-implies-domain _ _ _ _).
%total {} (restrict-leq-implies-domain _ _ _ _).
            
    

%theorem only-consume-once/L :
    forall* {M1} {MS1} {M2} {M} {S1}
    forall  {J: inner-efxmap`join M1 M2 M}
            {F: filter-consume/inner M1 S1}
            {R: inner-efxmap`restrict M1 S1 MS1}
    exists  {X: inner-efxmap`disjoint MS1 M2}
    true.

- : only-consume-once/L J F R XXX
    <- inner-efxmap`domain-total DM-M2
    <- inner-efxmap`domain-total DM-M1
    <- only-consume-once/inner J F DM-M2 S1-X-S2
    <- filter-consume/inner-implies-size-leq F DM-M1 LEQ
    <- restrict-leq-implies-domain DM-M1 R LEQ DM-MS1
    <- inner-efxmap`domain-preserves-disjoint-converse
      S1-X-S2 DM-MS1 DM-M2 XXX.

%worlds () (only-consume-once/L _ _ _ _).
%total  {} (only-consume-once/L _ _ _ _).
      


%theorem only-consume-once* :
    forall* {XM1} {XM2} {XM} {XM1O}
    forall  {N1} {SZ1: efxmap`size XM1 N1}
            {N2} {SZ2: efxmap`size XM2 N2}
            {U: efxmap`join XM1 XM2 XM}
            {F: filter-consume XM1 XM1O}
    exists  {D: efxmap`deep-disjoint XM1O XM2}
    true.

- : only-consume-once* _ _ _ _ efxmap`join/L 
    filter-consume/0 efxmap`deep-disjoint/L.

- : only-consume-once* _ _ _ _ efxmap`join/R F efxmap`deep-disjoint/R.
    
- : only-consume-once* _ (efxmap`size/+ SZ1)
    _ (efxmap`size/+ SZ2) 
    (efxmap`join/= XM1-U-XM2=XM3 M1-U-M2 nat`eq/)
    (filter-consume/+ XM1OP+L=XM1O FC-XM1P=XM1OP 
      RS-M1-S=M1O FCI-M1=S SH) XM1O-X-XM2
    <- efxmap`shift-total SH2
    <- efxmap`shift-preserves-join
      XM1-U-XM2=XM3 SH SH2 _ _ XM1P-U-XM2P=XM3P
    <- efxmap`shift-preserves-size SZ1 SH SZ11
    <- efxmap`shift-preserves-size SZ2 SH2 SZ21
    <- only-consume-once* _ SZ11 _ SZ21 
      XM1P-U-XM2P=XM3P FC-XM1P=XM1OP XM1OP-X-XM2P
    <- only-consume-once/L M1-U-M2 FCI-M1=S RS-M1-S=M1O M1O-X-M2
    <- efxmap`shift-implies-update SH2 UD2
    <- efxmap`update-disjoint-implies-disjoint 
      XM1OP-X-XM2P XM1OP+L=XM1O UD2 M1O-X-M2 XM1O-X-XM2.

- : only-consume-once* (s N1)
    (efxmap`size/+ SZ1) N2 SZ2 (efxmap`join/< J P)
    (filter-consume/+ UD FC _ _ SH-XM1) DX4
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- efxmap`shift-preserves-size SZ1 SH-XM1 SZ11
    <- efxmap`shift-preserves-join J SH-XM1 (efxmap`shift/+ P2) _ _ JJ
    <- only-consume-once* N1 SZ11 N2 SZ2 JJ FC DX1
    <- efxmap`deep-disjoint-symmetric DX1 DX2
    <- nat`plus-implies-gt P nat`eq/ GT
    <- efxmap`fresh-update-preserves-deep-disjoint
      DX2 (efxmap`fresh/< GT) UD DX3
    <- efxmap`deep-disjoint-symmetric DX3 DX4.

- : only-consume-once* N1 SZ1 (s N2) (efxmap`size/+ SZ2)
    (efxmap`join/> J P) FC XX
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- efxmap`shift-total SH2
    <- efxmap`shift-preserves-size SZ2 SH2 SZ21
    <- efxmap`shift-preserves-join J (efxmap`shift/+ P2) SH2 _ _ JJJ
    <- only-consume-once* N1 SZ1 N2 SZ21 JJJ FC DX
    <- efxmap`shift-implies-update SH2 UD2
    <- nat`plus-implies-gt P nat`eq/ GT
    <- filter-consume-preserves-fresh FC (efxmap`fresh/< GT) FS
    <- efxmap`fresh-update-preserves-deep-disjoint
      DX FS UD2 XX.

%worlds () (only-consume-once* _ _ _ _ _ _ _).
%total {N1 N2} (only-consume-once* N1 _ N2 _ _ _ _).


%theorem only-consume-once :
    forall* {XM1} {XM2} {XM} {XM1O}
    forall  {U: efxmap`join XM1 XM2 XM}
            {F: filter-consume XM1 XM1O}
    exists  {D: efxmap`deep-disjoint XM1O XM2}
    true.

- : only-consume-once U F D
    <- efxmap`size-total SZ1
    <- efxmap`size-total SZ2
    <- only-consume-once* _ SZ1 _ SZ2 U F D.

%worlds () (only-consume-once _ _ _).
%total  {} (only-consume-once _ _ _).



filter-non-consume : efxmap -> efxmap -> type.

filter-non-consume/0 : filter-non-consume efxmap/0 efxmap/0.


filter-non-consume/inner : inner-efxmap -> inner-efxmap -> type.

filter-non-consume/inner/0
  : filter-non-consume/inner inner-efxmap/0 inner-efxmap/0.
 
filter-non-consume/inner/consume
  : filter-non-consume/inner (inner-efxmap/+ F efx/consume M) MP
    <- inner-efxmap`shift F M MS
    <- filter-non-consume/inner MS MP.

filter-non-consume/inner/write
  : filter-non-consume/inner (inner-efxmap/+ F efx/write M) MP
    <- inner-efxmap`shift F M MS
    <- filter-non-consume/inner MS MSP
    <- inner-efxmap`update MSP F efx/write MP.

filter-non-consume/inner/read
  : filter-non-consume/inner (inner-efxmap/+ F efx/read M) MP
    <- inner-efxmap`shift F M MS
    <- filter-non-consume/inner MS MSP
    <- inner-efxmap`update MSP F efx/read MP.


filter-non-consume/+
  : filter-non-consume (efxmap/+ L M XM) XMO
    <- efxmap`shift L XM XM'
    <- filter-non-consume/inner M MO
    <- filter-non-consume XM' XMO'
    <- efxmap`update XMO' L MO XMO.


%theorem filter-non-consume/inner-total/L :
    forall  {M} {N} {SZ: inner-efxmap`size M N} 
    exists  {MP} {F: filter-non-consume/inner M MP}
    true.

- : filter-non-consume/inner-total/L
    inner-efxmap/0 _ _ _ filter-non-consume/inner/0.

- : filter-non-consume/inner-total/L
    (inner-efxmap/+ F efx/read M) _ (inner-efxmap`size/+ SZ)
    _ (filter-non-consume/inner/read UD FNC SH)
    <- inner-efxmap`shift-total* F M MS SH
    <- inner-efxmap`shift-preserves-size SZ SH SZP
    <- filter-non-consume/inner-total/L MS _ SZP MSP FNC
    <- inner-efxmap`update-total* MSP F efx/read MP UD.

- : filter-non-consume/inner-total/L
    (inner-efxmap/+ F efx/write M) _ (inner-efxmap`size/+ SZ)
    _ (filter-non-consume/inner/write UD FNC SH)
    <- inner-efxmap`shift-total* F M MS SH
    <- inner-efxmap`shift-preserves-size SZ SH SZP
    <- filter-non-consume/inner-total/L MS _ SZP MSP FNC
    <- inner-efxmap`update-total* MSP F efx/write MP UD.

- : filter-non-consume/inner-total/L
    (inner-efxmap/+ F efx/consume M) _ (inner-efxmap`size/+ SZ)
    _ (filter-non-consume/inner/consume FNC SH)
    <- inner-efxmap`shift-total* F M MS SH
    <- inner-efxmap`shift-preserves-size SZ SH SZP
    <- filter-non-consume/inner-total/L MS _ SZP MSP FNC.

%worlds () (filter-non-consume/inner-total/L _ _ _ _ _).
%total (N) (filter-non-consume/inner-total/L _ N _ _ _).


%theorem filter-non-consume/inner-total :
    forall* {M}
    exists  {MP} {F: filter-non-consume/inner M MP}
    true.

- : filter-non-consume/inner-total MP F
    <- inner-efxmap`size-total SZ
    <- filter-non-consume/inner-total/L _ _ SZ MP F.

%worlds () (filter-non-consume/inner-total _ _).
%total  {} (filter-non-consume/inner-total _ _).


%theorem shift-preserves-filter-non-consume/inner :
    forall* {M1} {M2} {MP1} {MP2} {N}
    forall  {F: filter-non-consume/inner M1 M2}
            {SH: inner-efxmap`shift N M1 MP1}
            {SH: inner-efxmap`shift N M2 MP2}
    exists  {F: filter-non-consume/inner MP1 MP2}
    true.

- : shift-preserves-filter-non-consume/inner 
    filter-non-consume/inner/0 _ _ filter-non-consume/inner/0.

- : shift-preserves-filter-non-consume/inner 
    (filter-non-consume/inner/consume F SH) 
    (inner-efxmap`shift/+ P) SH2 (filter-non-consume/inner/consume FK SHK)
    <- inner-efxmap`shift-total SH3
    <- shift-preserves-filter-non-consume/inner F SH3 SH2 FK
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- inner-efxmap`shifts-add SH SH3 P2 SHK.

- : shift-preserves-filter-non-consume/inner 
    (filter-non-consume/inner/write U F SH) 
    (inner-efxmap`shift/+ P) SH2
    (filter-non-consume/inner/write UK FK SHK)
    <- inner-efxmap`shift-total SH3
    <- inner-efxmap`shift-total SH4
    <- shift-preserves-filter-non-consume/inner F SH3 SH4 FK
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- inner-efxmap`shifts-add SH SH3 P2 SHK
    <- inner-efxmap`shift-preserves-update* U SH4 P SH2 UK.

- : shift-preserves-filter-non-consume/inner 
    (filter-non-consume/inner/read U F SH) 
    (inner-efxmap`shift/+ P) SH2
    (filter-non-consume/inner/read UK FK SHK)
    <- inner-efxmap`shift-total SH3
    <- inner-efxmap`shift-total SH4
    <- shift-preserves-filter-non-consume/inner F SH3 SH4 FK
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- inner-efxmap`shifts-add SH SH3 P2 SHK
    <- inner-efxmap`shift-preserves-update* U SH4 P SH2 UK.

%worlds () (shift-preserves-filter-non-consume/inner _ _ _ _).
%total (I) (shift-preserves-filter-non-consume/inner I _ _ _).


%theorem shift-preserves-filter-non-consume :
    forall* {M1} {M2} {MP1} {MP2} {N}
    forall  {F: filter-non-consume M1 M2}
            {SH: efxmap`shift N M1 MP1}
            {SH: efxmap`shift N M2 MP2}
    exists  {F: filter-non-consume MP1 MP2}
    true.

- : shift-preserves-filter-non-consume 
    filter-non-consume/0 _ _ filter-non-consume/0.

- : shift-preserves-filter-non-consume
    (filter-non-consume/+ U F FI SH) 
    (efxmap`shift/+ P) SH2 
    (filter-non-consume/+ UK FK FI SHK)
    <- efxmap`shift-total SH3
    <- efxmap`shift-total SH4
    <- shift-preserves-filter-non-consume F SH3 SH4 FK
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- efxmap`shifts-add SH SH3 P2 SHK
    <- efxmap`shift-preserves-update* U SH4 P SH2 UK.

%worlds () (shift-preserves-filter-non-consume _ _ _ _).
%total (F) (shift-preserves-filter-non-consume F _ _ _).


%theorem filter-non-consume-total/L :
    forall {XM} {N} {SZ: efxmap`size XM N}
    exists {XMP} {F: filter-non-consume XM XMP}
    true.

- : filter-non-consume-total/L efxmap/0 _ _ _ filter-non-consume/0.

- : filter-non-consume-total/L
    (efxmap/+ L M XM) (s N1) (efxmap`size/+ SZ) XMP
    (filter-non-consume/+ UD F FI SH)
    <- efxmap`shift-total* L XM XMS SH
    <- efxmap`shift-preserves-size SZ SH SZP
    <- filter-non-consume-total/L XMS N1 SZP XMPS F
    <- filter-non-consume/inner-total MP FI
    <- efxmap`update-total* XMPS L MP XMP UD.

%worlds () (filter-non-consume-total/L _ _ _ _ _).
%total (N) (filter-non-consume-total/L _ N _ _ _).
    

%theorem filter-non-consume-total :
    forall* {XM}
    exists  {XMP} {F: filter-non-consume XM XMP}
    true.

- : filter-non-consume-total XMP F
    <- efxmap`size-total SZ
    <- filter-non-consume-total/L _ _ SZ XMP F.

%worlds () (filter-non-consume-total _ _).
%total  {} (filter-non-consume-total _ _).



%theorem filter-non-consume/inner-deterministic :
    forall* {M1} {M2} {M1P} {M2P}
    forall  {F: filter-non-consume/inner M1 M2}
            {F: filter-non-consume/inner M1P M2P}
            {EQ: inner-efxmap`eq M1 M1P}
    exists  {EQ: inner-efxmap`eq M2 M2P}
    true.

- : filter-non-consume/inner-deterministic 
    filter-non-consume/inner/0 filter-non-consume/inner/0 
    _ inner-efxmap`eq/.

- : filter-non-consume/inner-deterministic 
    (filter-non-consume/inner/consume F SH) 
    (filter-non-consume/inner/consume FP SHP) EQ MMEQ
    <- inner-efxmap`map/+-preserves-eq-converse
      EQ NEQ XEQ MEQ
    <- inner-efxmap`shift-deterministic SH SHP NEQ MEQ MEQP
    <- filter-non-consume/inner-deterministic F FP MEQP MMEQ.
 
- : filter-non-consume/inner-deterministic 
    (filter-non-consume/inner/write UD F SH) 
    (filter-non-consume/inner/write UDP FP SHP) EQ MMEQP
    <- inner-efxmap`map/+-preserves-eq-converse
      EQ NEQ XEQ MEQ
    <- inner-efxmap`shift-deterministic SH SHP NEQ MEQ MEQP
    <- filter-non-consume/inner-deterministic F FP MEQP MMEQ
    <- inner-efxmap`update-deterministic 
      UD UDP MMEQ NEQ XEQ MMEQP.

- : filter-non-consume/inner-deterministic 
    (filter-non-consume/inner/read UD F SH) 
    (filter-non-consume/inner/read UDP FP SHP) EQ MMEQP
    <- inner-efxmap`map/+-preserves-eq-converse
      EQ NEQ XEQ MEQ
    <- inner-efxmap`shift-deterministic SH SHP NEQ MEQ MEQP
    <- filter-non-consume/inner-deterministic F FP MEQP MMEQ
    <- inner-efxmap`update-deterministic 
      UD UDP MMEQ NEQ XEQ MMEQP.

%worlds () (filter-non-consume/inner-deterministic _ _ _ _).
%total (F) (filter-non-consume/inner-deterministic F _ _ _).


%theorem filter-non-consume/inner-implies-leq :
    forall* {M1} {M2}
    forall  {F: filter-non-consume/inner M1 M2}
    exists  {L: inner-efxmap`leq M2 M1}
    true.

- : filter-non-consume/inner-implies-leq
    filter-non-consume/inner/0 inner-efxmap`leq/0.

- : filter-non-consume/inner-implies-leq
    (filter-non-consume/inner/consume F SH) LE2
    <- filter-non-consume/inner-implies-leq F LE
    <- inner-efxmap`shift-implies-update SH U
    <- inner-efxmap`shift-implies-fresh SH FS
    <- inner-efxmap`fresh-update-implies-leq FS U LE1
    <- inner-efxmap`leq-transitive LE LE1 LE2.

- : filter-non-consume/inner-implies-leq
    (filter-non-consume/inner/read UD F SH) LEQ
    <- filter-non-consume/inner-implies-leq F LE
    <- inner-efxmap`shift-implies-update SH U
    <- inner-efxmap`update-preserves-leq*
      LE (efx`leq/eq efx`eq/) UD U LEQ.

- : filter-non-consume/inner-implies-leq
    (filter-non-consume/inner/write UD F SH) LEQ
    <- filter-non-consume/inner-implies-leq F LE
    <- inner-efxmap`shift-implies-update SH U
    <- inner-efxmap`update-preserves-leq*
      LE (efx`leq/eq efx`eq/) UD U LEQ.

%worlds () (filter-non-consume/inner-implies-leq _ _).
%total (F) (filter-non-consume/inner-implies-leq F _).



%theorem filter-non-consume/inner-implies-leq23/L :
    forall* {M1} {M2} {M3} {M4}
    forall  {N1} {SZ1: inner-efxmap`size M1 N1}
            {N2} {SZ2: inner-efxmap`size M2 N2}
            {J: inner-efxmap`join M1 M2 M3}
            {F: filter-non-consume/inner M2 M4}
    exists  {M5} {F: filter-non-consume/inner M3 M5}
            {L: inner-efxmap`leq M4 M5}
    true.


%theorem filter-non-consume/inner-implies-leq23/LL* :
    forall* {MP} {N} {MS} {M}
    forall  {X} 
            {F: filter-non-consume/inner M MP}
            {SH: inner-efxmap`shift N MS M}
    exists  {MO} 
            {F: filter-non-consume/inner
		(inner-efxmap/+ N X MS) MO}
            {L: inner-efxmap`leq MP MO} 
    true.

- : filter-non-consume/inner-implies-leq23/LL*
    efx/read F SH %{=>}% _ 
    (filter-non-consume/inner/read UD1 F SH) LL
    <- inner-efxmap`update-total UD1
    <- filter-non-consume/inner-implies-leq F L
    <- inner-efxmap`shift-implies-fresh SH FS
    <- inner-efxmap`fresh-respects-geq FS L FS2
    <- inner-efxmap`fresh-update-implies-leq FS2 UD1 LL.

- : filter-non-consume/inner-implies-leq23/LL*
    efx/write F SH %{=>}% _ 
    (filter-non-consume/inner/write UD1 F SH) LL
    <- inner-efxmap`update-total UD1
    <- filter-non-consume/inner-implies-leq F L
    <- inner-efxmap`shift-implies-fresh SH FS
    <- inner-efxmap`fresh-respects-geq FS L FS2
    <- inner-efxmap`fresh-update-implies-leq FS2 UD1 LL.

- : filter-non-consume/inner-implies-leq23/LL*
    efx/consume F SH %{=>}% _ 
    (filter-non-consume/inner/consume F SH) LL
    <- inner-efxmap`leq-reflexive _ LL.

%worlds () (filter-non-consume/inner-implies-leq23/LL* _ _ _ _ _ _).
%total  {} (filter-non-consume/inner-implies-leq23/LL* _ _ _ _ _ _).

%abbrev filter-non-consume/inner-implies-leq23/LL =
filter-non-consume/inner-implies-leq23/LL* _.
						   
- : filter-non-consume/inner-implies-leq23/L _ _ _ _ 
    inner-efxmap`join/L F _ F LE
    <- inner-efxmap`leq-reflexive _ LE.

- : filter-non-consume/inner-implies-leq23/L
    _ _ _ _ inner-efxmap`join/R
    filter-non-consume/inner/0 _ F inner-efxmap`leq/0
    <- filter-non-consume/inner-total _ F.

- : filter-non-consume/inner-implies-leq23/L 
    _ (inner-efxmap`size/+ SZ1) _ (inner-efxmap`size/+ SZ2) 
    (inner-efxmap`join/< J P) F %{=>}% _ FP3 LE0
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- inner-efxmap`shift-total SH1
    <- inner-efxmap`shift-preserves-join
      J SH1 (inner-efxmap`shift/+ P2) _ SH3 JP
    <- inner-efxmap`shift-preserves-size SZ1 SH1 SZ1P
    <- filter-non-consume/inner-implies-leq23/L
      _ SZ1P _ (inner-efxmap`size/+ SZ2) JP F _ FP2 LEP
    <- filter-non-consume/inner-implies-leq23/LL FP2 SH3 _ FP3 LE2
    <- inner-efxmap`leq-transitive LEP LE2 LE0.

- : filter-non-consume/inner-implies-leq23/L
    _ (inner-efxmap`size/+ SZ1) _ (inner-efxmap`size/+ SZ2)
    (inner-efxmap`join/> J P) 
    (filter-non-consume/inner/consume F SH2) %{=>}% _ 
    (filter-non-consume/inner/consume FP2 SH3) LEP
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- inner-efxmap`shift-preserves-join
      J (inner-efxmap`shift/+ P2) SH2 _ SH3 JP
    <- inner-efxmap`shift-preserves-size SZ2 SH2 SZ2P
    <- filter-non-consume/inner-implies-leq23/L
      _ (inner-efxmap`size/+ SZ1) _ SZ2P JP F _ FP2 LEP.

- : filter-non-consume/inner-implies-leq23/L
    _ (inner-efxmap`size/+ SZ1) _ (inner-efxmap`size/+ SZ2)
    (inner-efxmap`join/> J P) 
    (filter-non-consume/inner/read UD F SH2) %{=>}% _ 
    (filter-non-consume/inner/read UD3 FP2 SH3) LEP2
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- inner-efxmap`shift-preserves-join
      J (inner-efxmap`shift/+ P2) SH2 _ SH3 JP
    <- inner-efxmap`shift-preserves-size SZ2 SH2 SZ2P
    <- filter-non-consume/inner-implies-leq23/L
      _ (inner-efxmap`size/+ SZ1) _ SZ2P JP F _ FP2 LEP
    <- inner-efxmap`update-total UD3
    <- inner-efxmap`update-preserves-leq*
      LEP (efx`leq/eq efx`eq/) UD UD3 LEP2.
    
- : filter-non-consume/inner-implies-leq23/L
    _ (inner-efxmap`size/+ SZ1) _ (inner-efxmap`size/+ SZ2)
    (inner-efxmap`join/> J P) 
    (filter-non-consume/inner/write UD F SH2) %{=>}% _ 
    (filter-non-consume/inner/write UD3 FP2 SH3) LEP2
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- inner-efxmap`shift-preserves-join
      J (inner-efxmap`shift/+ P2) SH2 _ SH3 JP
    <- inner-efxmap`shift-preserves-size SZ2 SH2 SZ2P
    <- filter-non-consume/inner-implies-leq23/L
      _ (inner-efxmap`size/+ SZ1) _ SZ2P JP F _ FP2 LEP
    <- inner-efxmap`update-total UD3
    <- inner-efxmap`update-preserves-leq*
      LEP (efx`leq/eq efx`eq/) UD UD3 LEP2.
    
% do case analysis on efx`join

- : filter-non-consume/inner-implies-leq23/L 
    _ (inner-efxmap`size/+ SZ1) _ (inner-efxmap`size/+ SZ2) 
    (inner-efxmap`join/= J efx`join/rr nat`eq/)
    (filter-non-consume/inner/read UD2 F2 SH2) _ 
    (filter-non-consume/inner/read UD3 F3 SH3) LEP
    <- inner-efxmap`shift-total SH1 
    <- inner-efxmap`shift-preserves-size SZ1 SH1 SZ1P
    <- inner-efxmap`shift-preserves-size SZ2 SH2 SZ2P
    <- inner-efxmap`shift-preserves-join J SH1 SH2 _ SH3 JP
    <- filter-non-consume/inner-implies-leq23/L 
      _ SZ1P _ SZ2P JP F2 _ F3 LE
    <- inner-efxmap`update-total UD3
    <- inner-efxmap`update-preserves-leq* 
      LE (efx`leq/eq efx`eq/) UD2 UD3 LEP.

- : filter-non-consume/inner-implies-leq23/L 
    _ (inner-efxmap`size/+ SZ1) _ (inner-efxmap`size/+ SZ2) 
    (inner-efxmap`join/= J efx`join/ww nat`eq/)
    (filter-non-consume/inner/write UD2 F2 SH2) _ 
    (filter-non-consume/inner/write UD3 F3 SH3) LEP
    <- inner-efxmap`shift-total SH1 
    <- inner-efxmap`shift-preserves-size SZ1 SH1 SZ1P
    <- inner-efxmap`shift-preserves-size SZ2 SH2 SZ2P
    <- inner-efxmap`shift-preserves-join J SH1 SH2 _ SH3 JP
    <- filter-non-consume/inner-implies-leq23/L 
      _ SZ1P _ SZ2P JP F2 _ F3 LE
    <- inner-efxmap`update-total UD3
    <- inner-efxmap`update-preserves-leq* 
      LE (efx`leq/eq efx`eq/) UD2 UD3 LEP.

- : filter-non-consume/inner-implies-leq23/L 
    _ (inner-efxmap`size/+ SZ1) _ (inner-efxmap`size/+ SZ2) 
    (inner-efxmap`join/= J efx`join/rw nat`eq/)
    (filter-non-consume/inner/write UD2 F2 SH2) _ 
    (filter-non-consume/inner/write UD3 F3 SH3) LEP
    <- inner-efxmap`shift-total SH1 
    <- inner-efxmap`shift-preserves-size SZ1 SH1 SZ1P
    <- inner-efxmap`shift-preserves-size SZ2 SH2 SZ2P
    <- inner-efxmap`shift-preserves-join J SH1 SH2 _ SH3 JP
    <- filter-non-consume/inner-implies-leq23/L 
      _ SZ1P _ SZ2P JP F2 _ F3 LE
    <- inner-efxmap`update-total UD3
    <- inner-efxmap`update-preserves-leq* 
      LE (efx`leq/eq efx`eq/) UD2 UD3 LEP.

- : filter-non-consume/inner-implies-leq23/L 
    _ (inner-efxmap`size/+ SZ1) _ (inner-efxmap`size/+ SZ2) 
    (inner-efxmap`join/= J efx`join/wr nat`eq/)
    (filter-non-consume/inner/read UD2 F2 SH2) _ 
    (filter-non-consume/inner/write UD3 F3 SH3) LEP
    <- inner-efxmap`shift-total SH1 
    <- inner-efxmap`shift-preserves-size SZ1 SH1 SZ1P
    <- inner-efxmap`shift-preserves-size SZ2 SH2 SZ2P
    <- inner-efxmap`shift-preserves-join J SH1 SH2 _ SH3 JP
    <- filter-non-consume/inner-implies-leq23/L 
      _ SZ1P _ SZ2P JP F2 _ F3 LE
    <- inner-efxmap`update-total UD3
    <- inner-efxmap`update-preserves-leq* 
      LE efx`leq/rw UD2 UD3 LEP.

- : filter-non-consume/inner-implies-leq23/L 
    _ (inner-efxmap`size/+ SZ1) _ (inner-efxmap`size/+ SZ2) 
    (inner-efxmap`join/= J efx`join/rc nat`eq/)
    (filter-non-consume/inner/consume F2 SH2) _ 
    (filter-non-consume/inner/consume F3 SH3) LE
    <- inner-efxmap`shift-total SH1 
    <- inner-efxmap`shift-preserves-size SZ1 SH1 SZ1P
    <- inner-efxmap`shift-preserves-size SZ2 SH2 SZ2P
    <- inner-efxmap`shift-preserves-join J SH1 SH2 _ SH3 JP
    <- filter-non-consume/inner-implies-leq23/L 
      _ SZ1P _ SZ2P JP F2 _ F3 LE.

- : filter-non-consume/inner-implies-leq23/L 
    _ (inner-efxmap`size/+ SZ1) _ (inner-efxmap`size/+ SZ2) 
    (inner-efxmap`join/= J efx`join/wc nat`eq/)
    (filter-non-consume/inner/consume F2 SH2) _ 
    (filter-non-consume/inner/consume F3 SH3) LE
    <- inner-efxmap`shift-total SH1 
    <- inner-efxmap`shift-preserves-size SZ1 SH1 SZ1P
    <- inner-efxmap`shift-preserves-size SZ2 SH2 SZ2P
    <- inner-efxmap`shift-preserves-join J SH1 SH2 _ SH3 JP
    <- filter-non-consume/inner-implies-leq23/L 
      _ SZ1P _ SZ2P JP F2 _ F3 LE.
    
%worlds () (filter-non-consume/inner-implies-leq23/L _ _ _ _ _ _ _ _ _).
%total {N1 N2} 
(filter-non-consume/inner-implies-leq23/L N1 _ N2 _ _ _ _ _ _).


%theorem filter-non-consume/inner-implies-leq23 :
    forall* {M1} {M2} {M3} {M4}
    forall  {J: inner-efxmap`join M1 M2 M3}
            {F: filter-non-consume/inner M2 M4}
    exists  {M5} {F: filter-non-consume/inner M3 M5}
            {L: inner-efxmap`leq M4 M5}
    true.

- : filter-non-consume/inner-implies-leq23
    J F _ FP L
    <- inner-efxmap`size-total SZ1
    <- inner-efxmap`size-total SZ2
    <- filter-non-consume/inner-implies-leq23/L
      _ SZ1 _ SZ2 J F _ FP L.

%worlds () (filter-non-consume/inner-implies-leq23 _ _ _ _ _).
%total  {} (filter-non-consume/inner-implies-leq23 _ _ _ _ _).


%theorem filter-non-consume-implies-leq/L :
    forall* {XM1} {XM2}
    forall  {N} {SZ: efxmap`size XM1 N}
            {F: filter-non-consume XM1 XM2}
    exists  {LE: efxmap`leq XM2 XM1}
    true.

- : filter-non-consume-implies-leq/L
    _ _ filter-non-consume/0 efxmap`leq/0.

- : filter-non-consume-implies-leq/L _ (efxmap`size/+ SZ)
    (filter-non-consume/+ XMOP+L=XMO F FI XM=>XMP) XMO<=LMXM
    <- efxmap`shift-preserves-size SZ XM=>XMP SZS
    <- filter-non-consume-implies-leq/L _ SZS F XMOP<=XMP
    <- efxmap`shift-implies-update XM=>XMP XMP+L=LMXM
    <- filter-non-consume/inner-implies-leq FI M-LE
    <- efxmap`update-preserves-leq*
      XMOP<=XMP M-LE XMOP+L=XMO XMP+L=LMXM XMO<=LMXM.

%worlds () (filter-non-consume-implies-leq/L _ _ _ _).
%total (N) (filter-non-consume-implies-leq/L N _ _ _).


%theorem filter-non-consume-implies-leq :
    forall* {XM1} {XM2}
    forall  {F: filter-non-consume XM1 XM2}
    exists  {LE: efxmap`leq XM2 XM1}
    true.

- : filter-non-consume-implies-leq F LE
    <- efxmap`size-total SZ
    <- filter-non-consume-implies-leq/L _ SZ F LE.

%worlds () (filter-non-consume-implies-leq _ _).
%total  {} (filter-non-consume-implies-leq _ _).


%theorem consume-once-left/L :
    forall* {XM1} {XM2} {XM3} {XM4}
    forall  {N1} {SZ1: efxmap`size XM1 N1}
            {N2} {SZ2: efxmap`size XM2 N2} 
            {J: efxmap`join XM1 XM2 XM3}
            {F: filter-non-consume XM2 XM4}
    exists  {XM5} {F: filter-non-consume XM3 XM5}
            {L: efxmap`leq XM4 XM5}
    true.

- : consume-once-left/L _ _ _ _ efxmap`join/L F _ F LE
    <- efxmap`leq-reflexive _ LE.

- : consume-once-left/L _ _ _ _
    efxmap`join/R filter-non-consume/0 _ F efxmap`leq/0
    <- filter-non-consume-total _ F.

- : consume-once-left/L _ (efxmap`size/+ SZ1) _ (efxmap`size/+ SZ2)
    (efxmap`join/= J IJ nat`eq/)
    (filter-non-consume/+ UD F FI SH2) _ 
    (filter-non-consume/+ UD1 FP FIP SH3) L
    <- efxmap`shift-total SH1
    <- efxmap`shift-preserves-join J SH1 SH2 _ SH3 JP
    <- efxmap`shift-preserves-size SZ1 SH1 SZ1S
    <- efxmap`shift-preserves-size SZ2 SH2 SZ2S
    <- filter-non-consume/inner-implies-leq23 IJ FI _ FIP M-LE
    <- consume-once-left/L _ SZ1S _ SZ2S JP F _ FP LE
    <- efxmap`update-total UD1
    <- efxmap`update-preserves-leq* LE M-LE UD UD1 L.

- : consume-once-left/L _ (efxmap`size/+ SZ1) _ (efxmap`size/+ SZ2)
    (efxmap`join/< J P) F _ (filter-non-consume/+ UD-X8 FP FI SH3) LL
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- efxmap`shift-total SH1
    <- efxmap`shift-preserves-join J SH1 (efxmap`shift/+ P2) _ SH3 JP
    <- efxmap`shift-preserves-size SZ1 SH1 SZ1S
    <- consume-once-left/L _ SZ1S _ (efxmap`size/+ SZ2) JP F _ FP LE
    <- efxmap`shift-implies-fresh SH3 N1!<X2
    <- filter-non-consume/inner-total _ FI
    <- filter-non-consume-implies-leq FP X8<=X2
    <- efxmap`fresh-respects-geq N1!<X2 X8<=X2 N1!<X8
    <- efxmap`update-total UD-X8
    <- efxmap`fresh-update-implies-leq N1!<X8 UD-X8 X8<=X11
    <- efxmap`leq-transitive LE X8<=X11 LL.
      
- : consume-once-left/L _ (efxmap`size/+ SZ1) _ (efxmap`size/+ SZ2)
    (efxmap`join/> J P) (filter-non-consume/+ UD F FI SH2) 
    _ (filter-non-consume/+ UD3 FP FI SH3) LL
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- efxmap`shift-preserves-join J (efxmap`shift/+ P2) SH2 _ SH3 JP
    <- efxmap`shift-preserves-size SZ2 SH2 SZ2S
    <- consume-once-left/L _ (efxmap`size/+ SZ1) _ SZ2S JP F _ FP LE
    <- efxmap`update-total UD3
    <- inner-efxmap`leq-reflexive _ M-LE
    <- efxmap`update-preserves-leq* LE M-LE UD UD3 LL.

%worlds () (consume-once-left/L _ _ _ _ _ _ _ _ _).    
%total {N1 N2} (consume-once-left/L N1 _ N2 _ _ F _ _ _).    


%theorem consume-once-left :
    forall* {XM1} {XM2} {XM3} {XM4}
    forall  {J: efxmap`join XM1 XM2 XM3}
            {F: filter-non-consume XM2 XM4}
    exists  {XM5} {F: filter-non-consume XM3 XM5}
            {L: efxmap`leq XM4 XM5}
    true.

- : consume-once-left J F _ FO L
    <- efxmap`size-total SZ1
    <- efxmap`size-total SZ2
    <- consume-once-left/L _ SZ1 _ SZ2 J F _ FO L.

%worlds () (consume-once-left _ _ _ _ _).
%total  {} (consume-once-left _ _ _ _ _).