%%% shortcut
%abbrev fldperm-fun
  : object -> nat -> (object -> permission) -> permission
 = [o][F][PF] unitperm (precise-exists o F ([v] PF v)).


%%% auxiliary theorems that are not included in 
%%% library signatures.

%theorem implies-respects-permission-eq :
    forall* {P1} {P2} {P3} {P4}
    forall  {IMP: implies P1 P2}
            {E: permission`eq P1 P3}
            {E: permission`eq P2 P4}
    exists  {IMP: implies P3 P4}
    true.

- : implies-respects-permission-eq I permission`eq/ permission`eq/ I.

%worlds () (implies-respects-permission-eq _ _ _ _).
%total  {} (implies-respects-permission-eq _ _ _ _).


%theorem false-implies-transform :
    forall* {K} {O1:output K} {O2:output K}
    forall  {F:void}
    exists  {TS: transform O1 O2}
    true.

%worlds () (false-implies-transform _ _).
%total  {} (false-implies-transform _ _).


%theorem false-implies-predmap-lookup :
    forall* {PM} {N}
    forall  {F:void}
    exists  {CJ} {PM-L: predmap`lookup PM N (conj2pred CJ)}
    true.

%worlds () (false-implies-predmap-lookup _ _ _).
%total  {} (false-implies-predmap-lookup _ _ _).


%theorem fldperm-can-lookup/false-imply :
        forall* {PM} {NN} {C} {F:nat} {G} {A}
        forall  {V:void}
        exists  {AF} {PF:clspred -> object -> permission} {FCP} 
                {A=>AF: annot=>perm A AF}
                {F2P: nn=>perm NN AF PF}
                {L: predmap`lookup PM C FCP}
                {I: {o} implies (unitperm (nonlinear (G o)))
                    (unitperm
                      (nonlinear
                        (nested ((fldperm F PF) FCP o) o all)))}
        true.

%worlds (objvar) (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).
%total  {} (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).


%theorem fldperm-can-lookup/L :
        forall* {CM} {PM} {FM} {F} {NN} {A} {G} {C}
        forall  {FM=>G: fldmap=>conj CM PM FM ([r] G r) PM}
                {FM-L: fldmap`lookup FM F (ty/ NN A C)}
        exists  {AF} {PF} {FCP} 
                {A=>AF: annot=>perm A AF}
                {FNN=>P: nn=>perm NN AF PF}
                {PM-L: predmap`lookup PM C FCP}
                {IMP: {o} implies (unitperm (nonlinear (G o)))
                      (unitperm
                        (nonlinear
                          (nested ((fldperm F PF) FCP o) o all)))}
        true.

- : fldperm-can-lookup/L (fldmap=>conj/null FMP=>G F<=FM=FMP)
    (fldmap`lookup/> FM->F P) AF PF CP A=>AF FNN=>PF PM->C IMP
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- fldmap`shift-preserves-lookup* FM->F F<=FM=FMP P2 FMP->F
    <- fldperm-can-lookup/L FMP=>G FMP->F AF PF CP A=>AF FNN=>PF PM->C IMP.

- : fldperm-can-lookup/L (fldmap=>conj/in _ FNN2P A=>AF _ PM-L) 
     (fldmap`lookup/= _) _ _ _ A=>AF FNN2P PM-L 
    ([o] implies/trans3
      (implies/conj2combine)
      (implies/combine
        (implies/reflexive)
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
      (implies/equiv equiv/identity)).

- : fldperm-can-lookup/L (fldmap=>conj/in FM=>G _ _ FM-SH _)
    (fldmap`lookup/> FM-L P) AF PF CP A=>AF FNN=>P PM-L
    ([o] implies/trans4
      (implies/conj2combine)
      (implies/combine 
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
        (I o))
      (implies/equiv equiv/commute)
      (implies/equiv equiv/identity))
    <- nat`plus-swap-succ P P'
    <- nat`plus-commutative P' P''
    <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
    <- fldperm-can-lookup/L FM=>G FM-L' AF PF CP A=>AF FNN=>P PM-L I.

- : fldperm-can-lookup/L 
    (fldmap=>conj/out F2C
      (F2CF:{f} fldmap=>conj _ _ _ ([r] CJ f r) _) 
      ([f] PM-U f) _ _ _ _ PM-FS) _ AF PF PD A=>AF FNN2P PM-L I
    <- predmap`size-total SZ-PM
    <- predmap`fresh-update-increases-size
      SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
    <- fldmap=>conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
    <- predmap`size-total SZ-PMF
    <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
    <- fldmap=>conj-implies-predmap-leq F2C PMF<=PM
    <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
    <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
    <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
    <- nat`gt-anti-reflexive SZ-PM>PM F
    <- fldperm-can-lookup/false-imply F AF PF PD A=>AF FNN2P PM-L I.

%worlds (objvar) (fldperm-can-lookup/L _ _ _ _ _ _ _ _ _).
%total  (FM=>G) (fldperm-can-lookup/L FM=>G _ _ _ _ _ _ _ _).


%%% This theorem says if we have a class predicate and we 
%%% know that this class has a field F, then we can pull out
%%% the nesting fact about F from the predicate.

%%% STRANGE: here I have to use (conj2pred CJ) instead of CP. 

%theorem fldperm-can-lookup :
        forall* {CM} {PM} {C} {FM} {F} {NN} {A} {FC} {CJ}
        forall  {CM=>PM: clsmap=>predmap CM PM}
                {PM-L: predmap`lookup PM C (conj2pred CJ)}
                {CM-L: clsmap`lookup CM C FM}
                {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
        exists  {AF} {PF} {CP:clspred} 
                {A=>AF: annot=>perm A AF}
                {FNN=>P: nn=>perm NN AF PF}
                {PM-L: predmap`lookup PM FC CP}
                {IMP: {o} implies
                      (unitperm
                        (nonlinear
                          (predcall (conj2pred CJ) (predargs/1 o))))
                      (unitperm
                        (nonlinear
                          (nested ((fldperm F PF) CP o) o all)))}
        true.

- : fldperm-can-lookup
    CM=>PM PM-L CM-L FM-L AF PF CP A=>AF FNN=>PF PM->FC 
    ([o] implies/trans
      (implies/nonlinear
        (bimplies/trans
          (bimplies/predcall/Y/inline)
          (bimplies/trans
            (bimplies/predcall/+/inline o)
            (bimplies/predcall/0/inline))))
      (IMP o))
     <- clsmap=>predmap-implies-fldmap=>conj CM=>PM PM-L CM-L FM=>G
     <- fldperm-can-lookup/L FM=>G FM-L AF PF CP A=>AF FNN=>PF PM->FC IMP.

%worlds (objvar) (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).
%total  {} (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).


%%% This relation says all (unique) locations
%%% in this set are of the same class.
%%% The set should only has positive numbers.

set-one-class : cxt N -> set -> nat -> type.

set-one-class/0 : set-one-class _ set/0 _.

set-one-class/obj : cxt N -> set -> nat -> type.

set-one-class/obj/0 : set-one-class/obj _ set/0 _.

set-one-class/obj/+
  : set-one-class/obj B (set/+ (s L) S) C
    <- set`shift (s L) S S'
    <- cxt-lookup-ty B (s L) _ C
    <- set-one-class/obj B S' C.


set-one-class/+/z
  : set-one-class B (set/+ z S) C
    <- set`shift z S S'
    <- set-one-class/obj B S' C.

set-one-class/+/s
  : set-one-class B (set/+ (s L) S) C
    <- set-one-class/obj B (set/+ (s L) S) C.


%theorem typing-read/L1 :
    forall* {CM} {FM} {PM} {XM} {N} {B: cxt N} 
            {C} {NN} {A} {FC} {S} {O} {PF}
    forall  {F} {K} {S-SZ: set`size S (s K)}
            {S-C: set-one-class/obj B S C}
            {CM-L: clsmap`lookup CM C FM}
            {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
            {T=>PF: ty=>perm PM (ty/ NN A FC) PF}
            {S+F=>GM: set+nat=>efxmap S F efx/write XM}
    exists  {G} {Pi} {Pi'}
            {S=>G: set=>fact/objequal B O S G}
            {XM=>Pi: efxmap=>input/obj CM PM B XM Pi}
            {IMP: implies
                  ((unitperm (nonlinear G)) , Pi)
                  ((unitperm (precise-exists O F ([v] (PF v))) , 
                     (unitperm
                       (encumbered 
                         (unitperm
                           (precise-exists O F ([v] (PF v)))) Pi))) , Pi') }
    true.

- : typing-read/L1 F z (set`size/+ set`size/0)
    (set-one-class/obj/+ set-one-class/obj/0 B->SL=C set`shift/0)
    CM-L FM-L T=>PF (set+nat=>efxmap/+ set+nat=>efxmap/0)
    %{=>}% _ _ _
    (set=>fact/objequal/+ set=>fact/objequal/0 B->SL=C set`update/0)
    (efxmap=>input/obj/+ efxmap=>input/obj/0 
      (inner-efxmap=>perm/+
        inner-efxmap=>perm/0 T=>PF FM-L inner-efxmap`fresh/0 inner-efxmap`update/0)
      CM-L B->SL=C efxmap`fresh/0 efxmap`update/0)
    (implies/trans3
      (implies/combine
        (implies/nonlinear
          (bimplies/trans
            (bimplies/neg
              (bimplies/trans
                (bimplies/conj/XX
                  (bimplies/reflexive)
                  (bimplies/rem-negneg))
                (bimplies/conj-true))
              (bool`ne/FT))
            (bimplies/trans
              (bimplies/rem-negneg)
              (bimplies/objequal-symmetric))))
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/equiv
              (equiv/transitive
                (equiv/identity)
                (equiv/identity)))
            (implies/trans
              (implies/self-implication)
              (implies/equiv-encumbered
                (equiv/transitive
                  (equiv/identity)
                  (equiv/identity))
                (equiv/reflexive))))))
      (implies/objequal
        ([o] (fldperm-fun o F ([v] PF v)) , 
          (unitperm
            (encumbered (fldperm-fun o F ([v] PF v))
              (combine (combine (fldperm-fun R F ([v] PF v)) empty) empty)))))
      (implies/equiv (equiv/symmetric equiv/identity))).

- : typing-read/L1 F (s N) (set`size/+ SZ-S)
    (set-one-class/obj/+ SOC-SS B->SL=C SL<<S=SS)
    CM-L FM-L T=>PF (set+nat=>efxmap/+ S1+FX=XM1)
    %{=>}% _ _ _ 
    (set=>fact/objequal/+ SS=>GS B->SL=C SS+SL=S)
    (efxmap=>input/obj/+ XMS=>PiS 
      (inner-efxmap=>perm/+
        inner-efxmap=>perm/0 T=>PF FM-L inner-efxmap`fresh/0 inner-efxmap`update/0)
      CM-L B->SL=C SL!<XMS XMS+S=LSXM)
    (implies/trans6
      (implies/equiv equiv/commute)
      (implies/combine
        (implies/combine
          (implies/equiv equiv/identity)
          (implies/reflexive))
        (implies/disj2cond))
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans6
          (implies/combine
            (implies/reflexive)
            (implies/equiv equiv/identity))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (implies/nonlinear bimplies/objequal-symmetric)
                (implies/trans
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/self-implication))))
              (implies/objequal
                ([o] (fldperm-fun o F ([v] PF v)) , 
                  (unitperm
                    (encumbered (fldperm-fun o F ([v] PF v))
                      (fldperm-fun R F ([v] PF v)))))))
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine
                (implies/reflexive)
                (implies/trans3
                  (implies/self-implication)
                  (implies/equiv-encumbered
                    (equiv/commute)
                    (equiv/combine
                      (equiv/symmetric equiv/identity)
                      (equiv/reflexive)))
                  (implies/combine-assoc-encumbered)))
              (implies/linear-modus-ponens)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/chain-implication))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans2
          (implies/combine
            (implies/reflexive)
            (implies/trans3
              (implies/equiv 
                (equiv/transitive
                  (equiv/symmetric equiv/associate)
                  (equiv/combine
                    (equiv/reflexive)
                    (equiv/commute))))
              (implies/combine
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/reflexive)
                        (equiv/combine
                          (equiv/symmetric equiv/identity)
                          (equiv/reflexive)))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens))
                (IMP))
              (implies/trans
                (implies/equiv
                  (equiv/associate))
                (implies/combine
                  (implies/trans
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/symmetric equiv/associate)))
                    (implies/combine
                      (implies/reflexive)
                      (implies/chain-implication)))
                  (implies/reflexive)))))
          (implies/equiv 
            (equiv/transitive
              (equiv/commute)
              (equiv/symmetric equiv/associate)))))
      (implies/cond-pull))
    <- set`shift-implies-update SL<<S=SS SS+SL=S
    <- efxmap`shift-total SL<<XM=XMS
    <- efxmap`shift-implies-update SL<<XM=XMS XMS+S=LSXM
    <- efxmap`shift-implies-fresh SL<<XM=XMS SL!<XMS
    <- shift-preserves-set+nat=>efxmap
      S1+FX=XM1 SL<<S=SS SL<<XM=XMS SS+FX=XMS
    <- set`shift-preserves-size SZ-S SL<<S=SS SZ-SS
    <- typing-read/L1 F N SZ-SS SOC-SS CM-L FM-L T=>PF
      SS+FX=XMS %{=>}% _ _ _ SS=>GS XMS=>PiS IMP.

%worlds () (typing-read/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (K) (typing-read/L1 _ K _ _ _ _ _ _ _ _ _ _ _ _).



%theorem typing-read/L2L :
    forall* {PF1: object -> permission} {PF2} {F} {O:object}
    forall  {E: {o} permission`eq (PF1 o) (PF2 o)}
    exists  {IMP: implies
                  (unitperm
                    (nonlinear
                      (nested
                        (unitperm
                          (precise-exists O F ([o] PF1 o))) O all)))
                  (unitperm
                    (nonlinear
                      (nested
                        (unitperm
                          (precise-exists O F ([o] PF2 o))) O all)))}
    true.

- : typing-read/L2L ([_] permission`eq/) implies/reflexive.
    
%worlds () (typing-read/L2L _ _).
%total  {} (typing-read/L2L _ _).


%theorem typing-read/L2 :
    forall* {CM} {FM} {PM} {XM} {N} {B: cxt N} 
            {C} {NN} {A} {FC} {S} {O} {PF} {CJ}
    forall  {F} {K} {S-SZ: set`size S (s K)}
            {S-C: set-one-class B S C}
            {CM=>PM: clsmap=>predmap CM PM}
            {CM-L: clsmap`lookup CM C FM}
            {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
            {PM-L: predmap`lookup PM C (conj2pred CJ)}
            {T=>PF: ty=>perm PM (ty/ NN A FC) PF}
            {S+F=>GM: set+nat=>efxmap S F efx/write XM}
    exists  {PG} {Pi} {Pi'}
            {S=>G: set=>fact B O S PG}
            {XM=>Pi: efxmap=>input CM PM B XM Pi}
            {IMP: implies ((one-predcall (conj2pred CJ) O) , (PG , Pi))
                  ((unitperm (precise-exists O F ([v] (PF v))) , 
                     (unitperm
                       (encumbered 
                         (unitperm
                           (precise-exists O F ([v] (PF v)))) Pi))) , Pi') }
    true.

- : typing-read/L2 _ _ SZ
    (set-one-class/+/s SOC)
    CM=>PM CM-L FM-L PM-L T=>PF S+FX=>XM %{=>}%
    _ _ _ (set=>fact/+/s S=>G) (efxmap=>input/+/s XM=>Pi)
    (implies/trans
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/combine 
            (implies/trans3
              (implies/equiv
                (equiv/transitive
                  (equiv/symmetric equiv/identity)
                  (equiv/commute)))
              (implies/combine
                (implies/trans
                  (implies/empty2true)
                  (implies/nonlinear bimplies/add-negneg))
                (implies/cond-neg))
              (implies/cond-elim))
            (implies/reflexive))
          (IMP)))
      (implies/equiv equiv/roll2))
    <- typing-read/L1 _ _ SZ SOC CM-L FM-L T=>PF S+FX=>XM
      _ _ _ S=>G XM=>Pi IMP.

- : typing-read/L2 _ z (set`size/+ set`size/0)
    (set-one-class/+/z set-one-class/obj/0 set`shift/0) CM=>PM
    CM-L FM-L PM-L T=>PF (set+nat=>efxmap/+ set+nat=>efxmap/0)
    %{=>}% _ _ _ 
    (set=>fact/+/z set=>fact/objequal/0 set`shift/0)
    (efxmap=>input/+/z efxmap=>input/obj/0 efxmap`shift/0)
    (implies/trans3
      (implies/combine
        (implies/trans
          (IMP-CP O)
          (IMP-PF))
        (implies/trans3
          (implies/combine
            (implies/trans3
              (implies/cond-gen-inner)
              (implies/cond-inner
                (bimplies/reflexive)
                (bimplies/reflexive)
                (implies/reflexive)
                (implies/trans
                  (implies/equiv equiv/commute)
                  (implies/combine
                    (implies/nonlinear
                      (bimplies/ft))
                    (implies/reflexive))))
              (implies/cond-pull))
            (implies/equiv equiv/identity))
          (implies/equiv 
            (equiv/transitive3
              (equiv/symmetric equiv/associate)
              (equiv/combine
                (equiv/reflexive) (equiv/commute))
              (equiv/associate)))
          (implies/combine
            (implies/carve) (implies/reflexive))))
      (implies/equiv equiv/associate)
      (implies/combine
        (implies/trans4
          (implies/equiv equiv/associate)
          (implies/combine 
            (implies/carve) (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/trans
              (implies/chain-implication)
              (implies/equiv-encumbered
                (equiv/reflexive) (equiv/symmetric equiv/identity)))))
        (implies/reflexive)))
    <- fldperm-can-lookup CM=>PM PM-L CM-L FM-L _ _ _ 
      A=>AF FNN=>P PM-L=CP IMP-CP
    <- ty=>perm-deterministic/L1 (ty=>perm/ PM-L=CP FNN=>P A=>AF) T=>PF 
      predmap`eq/ nonnull`eq/ annot`eq/ nat`eq/ PF1=PF2
    <- typing-read/L2L PF1=PF2 IMP-PF.
    
- : typing-read/L2 _ (s N) (set`size/+ SZ-S)
    (set-one-class/+/z SCO Z<<S=SS) CM=>PM CM-L FM-L PM-L T=>PF
    (set+nat=>efxmap/+ S+FX=XM) %{=>}% _ _ _
    (set=>fact/+/z SS=>G Z<<S=SS)
    (efxmap=>input/+/z XMS=>Pi Z<<XM=XMS)
    (implies/trans5
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/equiv equiv/commute)
          (implies/cond-push)))
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans7
          (implies/equiv equiv/roll2)
          (implies/combine
            (IMP-CP O)
            (implies/trans5
              (implies/combine
                (implies/reflexive)
                (implies/equiv equiv/identity))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/carve) 
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/commute) (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/reflexive) (implies/chain-implication))))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (IMP-PF)
                (implies/reflexive))
              (implies/carve))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/chain-implication))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans5
          (implies/combine
            (implies/reflexive)
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/trans3
                    (implies/equiv (equiv/symmetric equiv/identity))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans
                        (implies/self-implication)
                        (implies/combine-assoc-encumbered)))
                    (implies/linear-modus-ponens))
                  (implies/trans
                    (implies/equiv equiv/commute) (IMP))))))
          (implies/equiv equiv/roll4)
          (implies/combine
            (implies/reflexive)
            (implies/equiv equiv/roll3))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/reflexive) (implies/chain-implication)))
            (implies/reflexive))))
      (implies/cond-pull))
    <- set`shift-preserves-size SZ-S Z<<S=SS SZ-SS
    <- fldperm-can-lookup CM=>PM PM-L CM-L FM-L _ _ _ 
      A=>AF FNN=>P PM-L=CP IMP-CP
    <- efxmap`shift-total Z<<XM=XMS
    <- shift-preserves-set+nat=>efxmap S+FX=XM Z<<S=SS Z<<XM=XMS SS+FX=XMS
    <- typing-read/L1 F N SZ-SS SCO CM-L FM-L T=>PF SS+FX=XMS _ _ _
      SS=>G XMS=>Pi IMP
    <- ty=>perm-deterministic/L1 (ty=>perm/ PM-L=CP FNN=>P A=>AF) T=>PF 
      predmap`eq/ nonnull`eq/ annot`eq/ nat`eq/ PF1=PF2
    <- typing-read/L2L PF1=PF2 IMP-PF.

%worlds () (typing-read/L2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {K} (typing-read/L2 _ K _ _ _ _ _ _ _ _ _ _ _ _ _ _).



%theorem efxmap`split-implies-deep-disjoint :
    forall* {IM1} {IM2} {XM1} {XM2} {L} {XM1S} {XM2S}
    forall  {DJ: efxmap`deep-disjoint XM1 XM2}
            {DJ: inner-efxmap`disjoint IM1 IM2}
            {UD: efxmap`update XM1 L IM1 XM1S}
            {UD: efxmap`update XM2 L IM2 XM2S}
    exists  {DJ: efxmap`deep-disjoint XM1S XM2S}
    true.

%worlds () (efxmap`split-implies-deep-disjoint _ _ _ _ _).
%trustme %total  {} (efxmap`split-implies-deep-disjoint _ _ _ _ _).


%theorem efxmap`split-implies-join :
    forall* {XM} {XM1} {XM2} {GM}
    forall  {SP: efxmap`split XM GM XM1 XM2}
    exists  {J: efxmap`join XM1 XM2 XM}
    true.

%worlds () (efxmap`split-implies-join _ _).
%trustme %total  {} (efxmap`split-implies-join _ _).


%theorem efxmap`split-implies-deep-disjoint :
    forall* {XM} {GM} {XM1} {XM2}
    forall  {SP: efxmap`split XM GM XM1 XM2}
    exists  {DS: efxmap`deep-disjoint XM1 XM2}
    true.

%worlds () (efxmap`split-implies-deep-disjoint _ _).
%trustme %total  {} (efxmap`split-implies-deep-disjoint _ _).



%theorem inner-efxmap`split-implies-join-disjoint :
    forall* {M} {M1} {M2} {S}
    forall  {P: inner-efxmap`split M S M1 M2}
    exists  {J: inner-efxmap`join M1 M2 M}
            {D: inner-efxmap`disjoint M1 M2}
    true.

- : inner-efxmap`split-implies-join-disjoint 
    (inner-efxmap`split/ R-S2 R-S1 S/S1=S2 S1<=S M=>S) M1<>M2 M1UM2=M
    <- set`leq-reflexive _ S<=S
    <- inner-efxmap`domain-leq-implies-no-restriction M=>S S<=S R-S
    <- set`remove-implies-disjoint S/S1=S2 S1<>S2
    <- set`remove-subset-implies-union S/S1=S2 S1<=S S1US2=S
    <- inner-efxmap`restrict-left-preserves-disjoint-union
      S1<>S2 S1US2=S R-S1 R-S2 R-S M1UM2=M M1<>M2.

%worlds () (inner-efxmap`split-implies-join-disjoint _ _ _).
%total  {} (inner-efxmap`split-implies-join-disjoint _ _ _).
          
 

% these two maps have to be disjoint

%theorem inner-efxmap`join-implies-combine/L2 :
    forall* {M1} {M2} {M} {F} {X} {MS} {M1S}
    forall  {J: inner-efxmap`join M1 M2 M}
            {D: inner-efxmap`disjoint M1 M2}
            {U: inner-efxmap`update MS F X M}
            {FS: inner-efxmap`fresh MS F}
            {U: inner-efxmap`update M1S F X M1}
            {FS: inner-efxmap`fresh M1S F}
    exists  {J: inner-efxmap`join M1S M2 MS}
            {D: inner-efxmap`disjoint M1S M2}
    true.

- : inner-efxmap`join-implies-combine/L2 
    M1UM2=M M1<>M2 MS+F=M F!<MS M1S+F=M1 F!<M1S M1SUM2=MS M1S<>M2
    <- inner-efxmap`fresh-update-implies-unit-join F!<M1S M1S+F=M1 M1SUF=M1
    <- inner-efxmap`fresh-implies-unit-disjoint F!<M1S M1S<>F
    <- inner-efxmap`disjoint-join-commutative M1S<>F M1SUF=M1 FUM1S=M1
    <- inner-efxmap`join-associative FUM1S=M1 M1UM2=M MSP M1SUM2=MSP FUMSP=M
    <- inner-efxmap`fresh-update-implies-unit-join F!<MS MS+F=M MSUF=M
    <- inner-efxmap`fresh-implies-unit-disjoint F!<MS MS<>F
    <- inner-efxmap`disjoint-join-commutative MS<>F MSUF=M FUMS=M
    <- inner-efxmap`update-implies-lookup M1S+F=M1 M1->F
    <- inner-efxmap`disjoint-lookup-implies-fresh M1->F M1<>M2 F!<M2
    <- inner-efxmap`join-preserves-fresh* F!<M1S F!<M2 M1SUM2=MSP F!<MSP
    <- inner-efxmap`fresh-implies-unit-disjoint F!<MSP MSP<>F
    <- inner-efxmap`disjoint-symmetric MSP<>F F<>MSP
    <- inner-efxmap`disjoint-join-commutative F<>MSP FUMSP=M MSPUF=M
    <- inner-efxmap`fresh-unit-join-implies-update F!<MSP MSPUF=M MSP+F=M
    <- inner-efxmap`fresh-update-cancels F!<MS MS+F=M F!<MSP MSP+F=M
      nat`eq/ inner-efxmap`eq/ efx`eq/ MS=MSP
    <- inner-efxmap`eq-symmetric MS=MSP MSP=MS
    <- inner-efxmap`join-respects-eq 
      M1SUM2=MSP inner-efxmap`eq/ inner-efxmap`eq/ MSP=MS M1SUM2=MS
    <- inner-efxmap`fresh-update-implies-leq F!<M1S M1S+F=M1 M1S<=M1
    <- inner-efxmap`leq-reflexive _ M2<=M2
    <- inner-efxmap`disjoint-respects-geq M1<>M2 M1S<=M1 M2<=M2 M1S<>M2.

%worlds () (inner-efxmap`join-implies-combine/L2 _ _ _ _ _ _ _ _).
%total  {} (inner-efxmap`join-implies-combine/L2 _ _ _ _ _ _ _ _).


%theorem inner-efxmap`join-implies-combine/L1 :
    forall* {M1} {M2} {M} {F} {X} {M1S}
    forall  {J: inner-efxmap`join M1 M2 M}
            {D: inner-efxmap`disjoint M1 M2}
            {U: inner-efxmap`update M1S F X M1}
            {FS: inner-efxmap`fresh M1S F}
    exists  {MS} {J: inner-efxmap`join M1S M2 MS}
            {D: inner-efxmap`disjoint M1S M2}
            {U: inner-efxmap`update MS F X M}
            {NM: inner-efxmap`fresh MS F}
    true.

- : inner-efxmap`join-implies-combine/L1 M1UM2=M M1<>M2
    M1S+FX=M1 F!<M1S MS M1SUM2=MS M1S<>M2 MS+FX=M F!<MS
    <- inner-efxmap`update-implies-lookup M1S+FX=M1 M1->F=X
    <- inner-efxmap`disjoint-lookup-implies-fresh M1->F=X M1<>M2 F!<M2
    <- inner-efxmap`fresh-update-implies-unit-join F!<M1S M1S+FX=M1 M1SUFX=M1
    <- inner-efxmap`fresh-implies-unit-disjoint F!<M1S M1S<>FX
    <- inner-efxmap`disjoint-join-commutative M1S<>FX M1SUFX=M1 FXUM1S=M1
    <- inner-efxmap`join-associative FXUM1S=M1 M1UM2=M MS M1SUM2=MS FXUMS=M
    <- inner-efxmap`join-preserves-fresh* F!<M1S F!<M2 M1SUM2=MS F!<MS
    <- inner-efxmap`fresh-implies-unit-disjoint F!<MS MS<>FX
    <- inner-efxmap`disjoint-symmetric MS<>FX FX<>MS
    <- inner-efxmap`disjoint-join-commutative FX<>MS FXUMS=M MSUFX=M
    <- inner-efxmap`fresh-unit-join-implies-update F!<MS MSUFX=M MS+FX=M
    <- inner-efxmap`fresh-update-implies-leq F!<M1S M1S+FX=M1 M1S<=M1
    <- inner-efxmap`disjoint-respects-geq* M1<>M2 M1S<=M1 M1S<>M2.
      
%worlds () (inner-efxmap`join-implies-combine/L1 _ _ _ _ _ _ _ _ _).
%total  {} (inner-efxmap`join-implies-combine/L1 _ _ _ _ _ _ _ _ _).
    

%theorem inner-efxmap`join-implies-combine :
    forall* {IM} {IM1} {IM2} {FM} {PM} {O} {PI}
    forall  {J: inner-efxmap`join IM1 IM2 IM}
            {D: inner-efxmap`disjoint IM1 IM2}
            {IM=>PI : inner-efxmap=>perm O IM FM PM PI}
    exists  {PI1} {PI2}
            {IM1=>PI1 : inner-efxmap=>perm O IM1 FM PM PI1}
            {IM2=>PI2 : inner-efxmap=>perm O IM2 FM PM PI2}
            {IMP: implies PI (PI1 , PI2)}
    true.

%theorem inner-efxmap`join-implies-combine/L :
    forall* {IM} {IM1} {IM2} {F} {O} {FM} {PM} {Pi} 
            {T} {PF} {IMS} {X}
    forall  {B} {MB?: inner-efxmap`domain? IM1 F B}
            {FM-L: fldmap`lookup FM F T}
            {T=>PF: ty=>perm PM T PF}
            {J: inner-efxmap`join IM1 IM2 IM}
            {D: inner-efxmap`disjoint IM1 IM2}
            {U: inner-efxmap`update IMS F X IM}
            {FS: inner-efxmap`fresh IMS F}
            {IM=>Pi: inner-efxmap=>perm O IMS FM PM Pi}
    exists  {Pi1} {Pi2}
            {IM1=>Pi1: inner-efxmap=>perm O IM1 FM PM Pi1}
            {IM1=>Pi2: inner-efxmap=>perm O IM2 FM PM Pi2}
            {IMP: implies (unitperm (precise-exists O F PF) , Pi) (Pi1 , Pi2)}
    true.

- : inner-efxmap`join-implies-combine/L
    true (inner-efxmap`domain?/in L) FM-L T=>PF
    IM1UIM2=IM IM1<>IM2 IMS+FX=IM F!<IMS IMS=>Pi %{=>}%
    _ _ (inner-efxmap=>perm/+ IM1S=>Pi1S T=>PF FM-L F!<IM1S IM1S+FX=IM1)
    IM2=>Pi2 
    (implies/trans
      (implies/combine
        (implies/reflexive) IMP)
      (implies/equiv equiv/associate))
    <- inner-efxmap`update-implies-lookup IMS+FX=IM IM->F=X
    <- inner-efxmap`disjoint-lookup-implies-fresh L IM1<>IM2 F!<IM2
    <- inner-efxmap`disjoint-join-commutative IM1<>IM2 IM1UIM2=IM IM2UIM1=IM
    <- inner-efxmap`fresh-join-left-preserves-lookup-converse
      F!<IM2 IM->F=X IM2UIM1=IM IM1->F
    <- inner-efxmap`lookup-implies-fresh-update IM1->F _ F!<IM1S IM1S+FX=IM1
    <- inner-efxmap`join-implies-combine/L2 
      IM1UIM2=IM IM1<>IM2 IMS+FX=IM F!<IMS IM1S+FX=IM1 F!<IM1S 
      IM1SUIM2=IMS IM1S<>IM2
    <- inner-efxmap`join-implies-combine IM1SUIM2=IMS IM1S<>IM2 IMS=>Pi
      _ _ IM1S=>Pi1S IM2=>Pi2 IMP.

- : inner-efxmap`join-implies-combine/L
    false (inner-efxmap`domain?/out F!<IM1) FM-L T=>PF
    IM1UIM2=IM IM1<>IM2 IMS+FX=IM F!<IMS IMS=>Pi
    _ _  IM1=>Pi1
    (inner-efxmap=>perm/+ IM2S=>Pi2S T=>PF FM-L F!<IM2S IM2S+FX=IM2)
    (implies/trans
      (implies/combine
        (implies/reflexive) 
        (implies/trans IMP (implies/equiv equiv/commute)))
      (implies/equiv equiv/roll2))
    <- inner-efxmap`update-implies-lookup IMS+FX=IM IM->F
    <- inner-efxmap`fresh-join-left-preserves-lookup-converse
      F!<IM1 IM->F IM1UIM2=IM IM2->F
    <- inner-efxmap`lookup-implies-fresh-update IM2->F IM2S F!<IM2S IM2S+FX=IM2
    <- inner-efxmap`disjoint-join-commutative IM1<>IM2 IM1UIM2=IM IM2UIM1=IM
    <- inner-efxmap`disjoint-symmetric IM1<>IM2 IM2<>IM1
    <- inner-efxmap`join-implies-combine/L2 
      IM2UIM1=IM IM2<>IM1 IMS+FX=IM F!<IMS IM2S+FX=IM2 F!<IM2S
      IM2SUIM1=IMS IM2S<>IM1
    <- inner-efxmap`join-implies-combine IM2SUIM1=IMS IM2S<>IM1 IMS=>Pi
      _ _ IM2S=>Pi2S IM1=>Pi1 IMP.

- : inner-efxmap`join-implies-combine
    inner-efxmap`join/L _
    IM=>Pi _ _ inner-efxmap=>perm/0 IM=>Pi
    (implies/equiv
      (equiv/transitive
        (equiv/symmetric equiv/identity)
        (equiv/commute))).

- : inner-efxmap`join-implies-combine
    inner-efxmap`join/R _
    IM=>Pi _ _ IM=>Pi inner-efxmap=>perm/0
    (implies/equiv (equiv/symmetric equiv/identity)).

%% in this case since IM1 and IM2 are disjoint, field F
%% can only be in one of them.
- : inner-efxmap`join-implies-combine IM1UIM2=IM IM1<>IM2
    (inner-efxmap=>perm/+ IMS=>Pi T=>PF FM-L F!<IMS IMS+F=IM)
    _ _ IM1=>Pi1 IM2=>Pi2 IMP
    <- inner-efxmap`update-implies-lookup IMS+F=IM IM->F
    <- inner-efxmap`domain?-total MB?
    <- inner-efxmap`join-implies-combine/L _ MB?
      FM-L T=>PF IM1UIM2=IM IM1<>IM2 IMS+F=IM F!<IMS IMS=>Pi
      _ _ IM1=>Pi1 IM2=>Pi2 IMP.

%worlds () 
(inner-efxmap`join-implies-combine _ _ _ _ _ _ _ _)
(inner-efxmap`join-implies-combine/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (T2 T1) 
(inner-efxmap`join-implies-combine _ _ T1 _ _ _ _ _)
(inner-efxmap`join-implies-combine/L _ _ _ _ _ _ _ _ T2 _ _ _ _ _).





    
    

efxmap`deep-disjoint : efxmap -> efxmap -> type.

efxmap`deep-disjoint/L : efxmap`deep-disjoint efxmap/0 M.

efxmap`deep-disjoint/R : efxmap`deep-disjoint M efxmap/0.

efxmap`deep-disjoint/=
  : efxmap`deep-disjoint (efxmap/+ L1 IM1 XM1) (efxmap/+ L2 IM2 XM2)
    <- nat`eq L1 L2
    <- inner-efxmap`disjoint IM1 IM2
    <- efxmap`deep-disjoint XM1 XM2.

efxmap`deep-disjoint/< 
  : efxmap`deep-disjoint (efxmap/+ L1 IM1 XM1) (efxmap/+ L2 IM2 XM2)
    <- nat`plus (s L0) L1 L2
    <- efxmap`deep-disjoint XM1 (efxmap/+ L0 IM2 XM2).

efxmap`deep-disjoint/>
  : efxmap`deep-disjoint (efxmap/+ L1 IM1 XM1) (efxmap/+ L2 IM2 XM2)
    <- nat`plus (s L3) L2 L1
    <- efxmap`deep-disjoint (efxmap/+ L3 IM1 XM1) XM2.


%theorem efxmap`split-implies-join-disjoint :
    forall* {XM} {GM} {XM1} {XM2}
    forall  {P: efxmap`split XM GM XM1 XM2}
    exists  {J: efxmap`join XM1 XM2 XM}
            {D: efxmap`deep-disjoint XM1 XM2}
    true.

- : efxmap`split-implies-join-disjoint 
    (efxmap`split/+ XM2S-U XM1S-U 
      XMS=>XM1S+XM2S IM=>IM1+IM2 GM-LS L!<XMS XMS+L=XM) XX YY
    <- inner-efxmap`split-implies-join-disjoint 
      IM=>IM1+IM2 IM1UIM2=IM IM1<>IM2
    <- efxmap`split-implies-join-disjoint 
      XMS=>XM1S+XM2S XM1SUXM2S=XMS XM1S<>XM2S
    <- 

      

%theorem efxmap`join-implies-combine :
    forall* {XM} {CM} {PM} {XM1} {XM2} {N} {B:cxt N} {Pi}
    forall  {J: efxmap`join XM1 XM2 XM}
            {XM=>Pi : efxmap=>perm XM CM PM B Pi}
    exists  {Pi1} {Pi2} 
            {XM1=>Pi1: efxmap=>perm XM1 CM PM B Pi1}
            {XM2=>Pi2: efxmap=>perm XM2 CM PM B Pi2}
            {IMP: implies Pi (Pi1 , Pi2)}
    true.

- : efxmap`join-implies-combine
    efxmap`join/L XM=>Pi efxmap=>perm/0 XM=>Pi 
    (implies/equiv
      (equiv/transitive
        (equiv/symmetric equiv/identity)
        (equiv/commute))).

- : efxmap`join-implies-combine
    efxmap`join/R XM=>Pi XM=>Pi efxmap=>perm/0
    (implies/equiv (equiv/symmetric equiv/identity)).