efxmap`project-preserves-wf 
  : {N} efxmap`size XM N
    -> tgtmap`leq-efxmap GM XM
    -> efxmap`project XM GM XMP
    -> tgtmap`wf GM
    -> efxmap`wf XMP
    -> type.
%mode efxmap`project-preserves-wf +N +SZ +LE +P +W1 -W2.

- : efxmap`project-preserves-wf _ _ _ P tgtmap`wf/0 WF
    <- efxmap`project-empty _ P2
    <- efxmap`project-unique P2 P efxmap`eq/ tgtmap`eq/ EQ
    <- efxmap`wf-respects-eq efxmap`wf/0 EQ WF.

- : efxmap`project-preserves-wf _ SZ GM<=XM
    (efxmap`project/U/out XM1+GM=>XMP N!<XM1 XM1+N+M1=XM N!<GM) 
    WF-GM (WF-XMP:efxmap`wf XMP)
    <- efxmap`fresh-update-increases-size-converse SZ N!<XM1 XM1+N+M1=XM SZS
    <- tgtmap`fresh-update2-preserves-leq-efxmap-converse
      GM<=XM N!<GM N!<XM1 XM1+N+M1=XM GM<=XM1
    <- efxmap`project-preserves-wf _ SZS GM<=XM1 XM1+GM=>XMP WF-GM WF-XMP.
      
- : efxmap`project-preserves-wf _ SZ GM<=XM
    (efxmap`project/U/in XMP+GM=>XMPP N!<XMP XMP+N+M1=XM
      GM->N=S M1|S=M2 XMPP+N+M2=XMP) WF-GM WF-XMP
    <- tgtmap`lookup-implies-fresh-update GM->N=S GMP N!<GMP GMP+N+S=GM
    <- tgtmap`fresh-update-preserves-leq-efxmap-converse
      GM<=XM N!<GMP GMP+N+S=GM N!<XMP XMP+N+M1=XM GMP<=XMP
    <- efxmap`fresh-update-preserves-project-converse
      XMP+GM=>XMPP N!<XMP N!<GMP GMP+N+S=GM XMP+GMP=>XMPP
    <- tgtmap`fresh-update-preserves-wf-converse WF-GM N!<GMP GMP+N+S=GM WF-GMP _
    <- efxmap`fresh-update-increases-size-converse SZ N!<XMP XMP+N+M1=XM SZS
    <- efxmap`project-preserves-wf _ SZS GMP<=XMP XMP+GMP=>XMPP WF-GMP WF-XMPP
    <- efxmap`update-implies-lookup XMP+N+M1=XM XM->N=M1
    <- tgtmap`wf-lookup-implies-non-empty WF-GM GM->N=S SZ-S>0
    <- tgtmap`lookup-respects-leq-efxmap* GM->N=S GM<=XM XM->N=M1 SP DM-M1=SP S<=SP
    <- inner-efxmap`restrict-leq-implies-domain M1|S=M2 DM-M1=SP S<=SP DM-M2=S
    <- inner-efxmap`domain-preserves-size-converse SZ-S>0 DM-M2=S SZ-M2>0
    <- efxmap`update-preserves-wf WF-XMPP SZ-M2>0 XMPP+N+M2=XMP WF-XMP.
 
%worlds () (efxmap`project-preserves-wf _ _ _ _ _ _).
%total (N) (efxmap`project-preserves-wf N _ _ _ _ _). 


% we want to show that if XM/GM=XM1+XM2, and XM2P<=XM,
% then XM2P<=XM2.

%theorem efxmap`leq-disjoint-implies-empty :
    forall* {M1} {M2}
    forall  {L: efxmap`leq M1 M2}
            {D: efxmap`disjoint M1 M2}
    exists  {E: efxmap`eq M1 efxmap/0}
    true.

- : efxmap`leq-disjoint-implies-empty efxmap`leq/0 _ efxmap`eq/.
   
- : efxmap`leq-disjoint-implies-empty
    (efxmap`leq/> L P1) (efxmap`disjoint/< D P2) E
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- efxmap`false-implies-eq F E.

- : efxmap`leq-disjoint-implies-empty
    (efxmap`leq/= _ _ nat`eq/) (efxmap`disjoint/< D P) E
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-eq F E.

- : efxmap`leq-disjoint-implies-empty
    (efxmap`leq/> L P1) (efxmap`disjoint/> D P2) E2
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- efxmap`map/+-preserves-eq EQ inner-efxmap`eq/ efxmap`eq/ MEQ
    <- efxmap`leq-respects-eq L MEQ efxmap`eq/ LP
    <- efxmap`leq-disjoint-implies-empty LP D E
    <- efxmap`eq-symmetric E EP
    <- efxmap`eq-contradiction EP F
    <- efxmap`false-implies-eq F E2.

- : efxmap`leq-disjoint-implies-empty
    (efxmap`leq/= _ _ nat`eq/) (efxmap`disjoint/> D P) E
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-eq F E.

%worlds () (efxmap`leq-disjoint-implies-empty _ _ _).
%total (L) (efxmap`leq-disjoint-implies-empty L _ _).


%theorem inner-efxmap`leq-disjoint-implies-empty :
    forall* {M1} {M2}
    forall  {L: inner-efxmap`leq M1 M2}
            {D: inner-efxmap`disjoint M1 M2}
    exists  {E: inner-efxmap`eq M1 inner-efxmap/0}
    true.

- : inner-efxmap`leq-disjoint-implies-empty inner-efxmap`leq/0 _ inner-efxmap`eq/.
   
- : inner-efxmap`leq-disjoint-implies-empty
    (inner-efxmap`leq/> L P1) (inner-efxmap`disjoint/< D P2) E
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- inner-efxmap`false-implies-eq F E.

- : inner-efxmap`leq-disjoint-implies-empty
    (inner-efxmap`leq/= _ _ nat`eq/) (inner-efxmap`disjoint/< D P) E
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- inner-efxmap`false-implies-eq F E.

- : inner-efxmap`leq-disjoint-implies-empty
    (inner-efxmap`leq/> L P1) (inner-efxmap`disjoint/> D P2) E2
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- inner-efxmap`map/+-preserves-eq EQ 
      efx`eq/ inner-efxmap`eq/ MEQ
    <- inner-efxmap`leq-respects-eq L MEQ inner-efxmap`eq/ LP
    <- inner-efxmap`leq-disjoint-implies-empty LP D E
    <- inner-efxmap`eq-symmetric E EP
    <- inner-efxmap`eq-contradiction EP F
    <- inner-efxmap`false-implies-eq F E2.

- : inner-efxmap`leq-disjoint-implies-empty
    (inner-efxmap`leq/= _ _ nat`eq/) (inner-efxmap`disjoint/> D P) E
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- inner-efxmap`false-implies-eq F E.

%worlds () (inner-efxmap`leq-disjoint-implies-empty _ _ _).
%total (L) (inner-efxmap`leq-disjoint-implies-empty L _ _).


efxmap`leq-deep-disjoint-implies-empty
  : efxmap`wf M1 
    -> efxmap`wf M2
    -> efxmap`leq M1 M2
    -> efxmap`deep-disjoint M1 M2
    -> efxmap`eq M1 efxmap/0
    -> type.
%mode efxmap`leq-deep-disjoint-implies-empty +WF1 +WF2 +LE1 +DJ -EQ.

- : efxmap`leq-deep-disjoint-implies-empty _ _ efxmap`leq/0 _ efxmap`eq/.
   
- : efxmap`leq-deep-disjoint-implies-empty _ _
    (efxmap`leq/> L P1) (efxmap`deep-disjoint/< D P2) E
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- efxmap`false-implies-eq F E.

- : efxmap`leq-deep-disjoint-implies-empty _ _
    (efxmap`leq/= _ _ nat`eq/) (efxmap`deep-disjoint/< D P) E
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-eq F E.

- : efxmap`leq-deep-disjoint-implies-empty
    (efxmap`wf/+ WF-M1 WF-XM1) (efxmap`wf/+ WF-M2 WF-XM2)
    (efxmap`leq/> L P1) (efxmap`deep-disjoint/> D P2) E2
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- efxmap`map/+-preserves-eq EQ inner-efxmap`eq/ efxmap`eq/ MEQ
    <- efxmap`leq-respects-eq L MEQ efxmap`eq/ LP
    <- efxmap`leq-deep-disjoint-implies-empty 
      (efxmap`wf/+ WF-M1 WF-XM1) WF-XM2 LP D E
    <- efxmap`eq-symmetric E EP
    <- efxmap`eq-contradiction EP F
    <- efxmap`false-implies-eq F E2.

- : efxmap`leq-deep-disjoint-implies-empty _ _
    (efxmap`leq/= _ _ nat`eq/) (efxmap`deep-disjoint/> D P) E
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-eq F E.

- : efxmap`leq-deep-disjoint-implies-empty 
    (efxmap`wf/+ (inner-efxmap`wf/ SZ) _) WF-M2
    (efxmap`leq/= LE DLE nat`eq/)
    (efxmap`deep-disjoint/= DJ DDJ nat`eq/) EQ
    <- inner-efxmap`leq-disjoint-implies-empty DLE DDJ D=0
    <- inner-efxmap`size-respects-eq SZ D=0 nat`eq/ SZ2
    <- inner-efxmap`size-unique inner-efxmap`size/0 SZ2 inner-efxmap`eq/ NEQ
    <- nat`eq-contradiction NEQ V
    <- efxmap`false-implies-eq V EQ.

- : efxmap`leq-deep-disjoint-implies-empty 
    WF-XM1 WF-XM2 (efxmap`leq/> LE P)
    (efxmap`deep-disjoint/= DJ DDJ nat`eq/) EQ
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT V
    <- efxmap`false-implies-eq V EQ.

%worlds () (efxmap`leq-deep-disjoint-implies-empty _ _ _ _ _).
%total (L) (efxmap`leq-deep-disjoint-implies-empty _ _ L _ _).


%abbrev leq-disjoint-implies-empty = efxmap`leq-disjoint-implies-empty.


%theorem inner-efxmap`join-disjoint-right-leq-implies-leq :
    forall* {XM1} {XM2} {XM3} {XM}
    forall  {XM1UXM2=XM: inner-efxmap`join XM1 XM2 XM}
            {XM2^XM3: inner-efxmap`disjoint XM2 XM3}
            {XM3<=XM: inner-efxmap`leq XM3 XM}
    exists  {XM3<=XM1: inner-efxmap`leq XM3 XM1}
    true.

%worlds () (inner-efxmap`join-disjoint-right-leq-implies-leq _ _ _ _).
%trustme %total  {} (inner-efxmap`join-disjoint-right-leq-implies-leq _ _ _ _).


efxmap`join-deep-disjoint-right-leq-implies-leq/L 
  : {N1} efxmap`size XM1 N1
    -> {N2} efxmap`size XM2 N2
    -> efxmap`wf XM2
    -> efxmap`wf XM3
    -> efxmap`join XM1 XM2 XM
    -> efxmap`deep-disjoint XM2 XM3
    -> efxmap`leq XM3 XM
    -> efxmap`leq XM3 XM1
    -> type.
%mode efxmap`join-deep-disjoint-right-leq-implies-leq/L
+N1 +SZ1 +N2 +SZ2 +WF2 +WF3 +J +DJ +LE1 -LE2.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L 
    _ (efxmap`size/+ SZ1) _ (efxmap`size/+ SZ2)
    (efxmap`wf/+ WF-M1 WF-XM1) (efxmap`wf/+ WF-M2 WF-XM2)
    (efxmap`join/= J DJ nat`eq/)  (efxmap`deep-disjoint/= X DX nat`eq/) 
    (efxmap`leq/= LE DLE nat`eq/) (efxmap`leq/= LE2 DLE2 nat`eq/)
    <- efxmap`join-deep-disjoint-right-leq-implies-leq/L
      _ SZ1 _ SZ2 WF-XM1 WF-XM2 J X LE LE2
    <- inner-efxmap`join-disjoint-right-leq-implies-leq 
      DJ DX DLE DLE2.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L _ _ _ _
    _ (efxmap`wf/+ (inner-efxmap`wf/ SZ) _) 
    (efxmap`join/> _ _)  (efxmap`deep-disjoint/= _ DX nat`eq/) 
    (efxmap`leq/= _ DLE nat`eq/) LE2
    <- inner-efxmap`disjoint-symmetric DX DX2
    <- inner-efxmap`disjoint-leq-implies-empty DX2 DLE Z=D
    <- inner-efxmap`eq-symmetric Z=D D=0
    <- inner-efxmap`size-respects-eq SZ D=0 nat`eq/ SZ2
    <- inner-efxmap`size-unique inner-efxmap`size/0 SZ2 inner-efxmap`eq/ NEQ
    <- nat`eq-contradiction NEQ V
    <- efxmap`false-implies-leq V LE2.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L 
    _ (efxmap`size/+ SZ1) _ (efxmap`size/+ SZ2)
    (efxmap`wf/+ WF-M1 WF-XM1) (efxmap`wf/+ WF-M2 WF-XM2)
    (efxmap`join/< J P)  (efxmap`deep-disjoint/= X DX nat`eq/) 
    (efxmap`leq/= LE DLE nat`eq/) LE2
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-leq F LE2.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L 
    _ _ _ _ _ _
    (efxmap`join/= _ _ nat`eq/)  (efxmap`deep-disjoint/= _ _ nat`eq/) 
    (efxmap`leq/> _ P) LE2
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-leq F LE2.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L 
    _ _ _ _ _ _
    (efxmap`join/> _ _)  (efxmap`deep-disjoint/= _ _ nat`eq/) 
    (efxmap`leq/> _ P) LE2
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-leq F LE2.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L 
    _ _ _ _ WF2 WF3 join/L D LE LE2
    <- efxmap`deep-disjoint-symmetric D DP
    <- efxmap`leq-deep-disjoint-implies-empty WF3 WF2 LE DP E
    <- efxmap`leq-reflexive _ LE3
    <- leq-respects-eq LE3 eq/ E LE2.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L _ _ _ _ _ _ join/R _ LE LE.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L
    _ _ _ _ _ _ _ deep-disjoint/R _ leq/0.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L _ _ _ _ _ _
    (join/< _ P1) (deep-disjoint/< _ P2)
    (leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- false-implies-leq F LE.

% SHP and SH2 unified.
- : efxmap`join-deep-disjoint-right-leq-implies-leq/L _ (size/+ SZ)
    _ (size/+ SZ2) WF-XM1 WF-XM2
    (join/< J P1) D (leq/> LE P2) (leq/> LE3P P2)
    <- nat`plus-swap-succ P1 P1P
    <- nat`plus-commutative P1P P1S
    <- shift-total SH
    <- shift-preserves-join J SH (shift/+ P1S) _ SHP JP
    <- nat`plus-swap-succ P2 P2P
    <- nat`plus-commutative P2P P2S
    <- shift-preserves-leq LE (shift/+ P2S) SHP LE2
    <- shift-preserves-size SZ SH SZK
    <- efxmap`join-deep-disjoint-right-leq-implies-leq/L
      _ SZK _ (size/+ SZ2) WF-XM1 WF-XM2 JP D LE2 LE3
    <- shift-preserves-leq-converse LE3 (shift/+ P2S) SH LE3P.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L
    _ (size/+ SZ) _ (size/+ SZ2) (efxmap`wf/+ WF-M1 WF-XM1)
    (efxmap`wf/+ WF-M2 WF-XM2)
    (join/< J P1) (deep-disjoint/> D P2)
    (leq/= LE M-LE nat`eq/) (leq/= LEE M-LE nat`eq/)
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- efxmap`map/+-preserves-eq EQ inner-efxmap`eq/ eq/ MEQ
    <- join-respects-eq J eq/ MEQ eq/ JP
    <- efxmap`join-deep-disjoint-right-leq-implies-leq/L
      _ SZ _ (size/+ SZ2) (efxmap`wf/+ WF-M1 WF-XM1) WF-XM2 JP D LE LEE.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L 
    _ (size/+ SZ) _ (size/+ SZ2) (efxmap`wf/+ WF-M1 WF-XM1)
    (efxmap`wf/+ WF-M2 WF-XM2)
    (join/> J P1) (deep-disjoint/< D P2) (leq/> LE P3) LEE2
    <- nat`plus-right-cancels P2 P3 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- map/+-preserves-eq EQ inner-efxmap`eq/ eq/ MEQ
    <- deep-disjoint-respects-eq D eq/ MEQ DP
    <- efxmap`join-deep-disjoint-right-leq-implies-leq/L 
      _ (size/+ SZ) _ SZ2 WF-XM1 (efxmap`wf/+ WF-M2 WF-XM2) J DP LE LEE
    <- nat`plus-swap-succ P3 P3S
    <- nat`plus-commutative P3S P3P
    <- nat`plus-swap-succ P1 P1S
    <- nat`plus-commutative P1S P1P
    <- shift-preserves-leq
      LEE (shift/+ P3P) (shift/+ P1P) LEE2.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L _ _ _ _ _ _
    (join/= _ _ nat`eq/) (deep-disjoint/< _ P)
    (leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L _ _ _ _ _ _
    (join/= _ _ nat`eq/) (deep-disjoint/> _ P)
    (leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L _ _ _ _ _ _
    (join/> _ _) (deep-disjoint/< _ P)
    (leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L _ _ _ _ _ _
    (join/> _ _) (deep-disjoint/> _ P) 
    (leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L _ _ _ _ _ _
    (join/= _ _ nat`eq/) (deep-disjoint/> _ P1) 
    (leq/> _ P2) LE
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- false-implies-leq F LE.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L
    _ (size/+ SZ) _ (size/+ SZ2) (efxmap`wf/+ WF-M1 WF-XM1)
    (efxmap`wf/+ WF-M2 WF-XM2)
    (join/= J M-J nat`eq/) (deep-disjoint/< D P1) 
    (leq/> LE P2) (leq/> LEP P2)
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- map/+-preserves-eq EQ inner-efxmap`eq/ eq/ MEQ
    <- deep-disjoint-respects-eq D eq/ MEQ DP
    <- efxmap`join-deep-disjoint-right-leq-implies-leq/L
      _ SZ _ SZ2 WF-XM1 (efxmap`wf/+ WF-M2 WF-XM2) J DP LE LEP.

- : efxmap`join-deep-disjoint-right-leq-implies-leq/L _ _ _ _ _ _
    (join/> _ _) (deep-disjoint/> _ P1) (leq/> _ P2) LE
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- false-implies-leq F LE.

%worlds () (efxmap`join-deep-disjoint-right-leq-implies-leq/L _ _ _ _ _ _ _ _ _ _).
%total {N1 N2} 
(efxmap`join-deep-disjoint-right-leq-implies-leq/L N1 _ N2 _ _ _ _ _ _ _).


efxmap`join-deep-disjoint-right-leq-implies-leq
  : efxmap`wf XM2 
    -> efxmap`wf XM3 
    -> efxmap`join XM1 XM2 XM
    -> efxmap`deep-disjoint XM2 XM3
    -> efxmap`leq XM3 XM
    -> efxmap`leq XM3 XM1
    -> type.
%mode efxmap`join-deep-disjoint-right-leq-implies-leq +WF1 +WF2 +J +DJ +LE1 -LE2.

- : efxmap`join-deep-disjoint-right-leq-implies-leq WF1 WF2 U D LE LE2
    <- size-total SZ1
    <- size-total SZ2
    <- efxmap`join-deep-disjoint-right-leq-implies-leq/L 
      _ SZ1 _ SZ2 WF1 WF2 U D LE LE2.

%worlds () (efxmap`join-deep-disjoint-right-leq-implies-leq _ _ _ _ _ _).
%total  {} (efxmap`join-deep-disjoint-right-leq-implies-leq _ _ _ _ _ _).




%{%
#ifdef DATA_NOT_WF
%}%


%{%
#endif
%}%


%%% Test Cases for Reftyping

%{ 

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Example 1 (from Bill's thesis, page 60) 
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  class ListItem {
    @unique Object item;
    @unique ListItem next;
    ListItem(@unique Object o, @unique ListItem n) {
      item = o; next = n;
    }

    @unique Object getItem() {
      Object temp = item;
      item = null;
      return temp;
    }
  }

  class Bad {
    @unique ListItem a;
    @unique Object b;
 
    Bad(@unique Object o, @unique ListItem n) {
      a = new ListItem(o,n);
      b = null;
    }

    @unique ListItem getList() {
      ListItem temp = a;
      a = null;
      return temp;
    }

    // GOOD

    @writes this.a, this.b
    @nonnull unique ListItem send() {
      ListItem bad = a; 
      this.b = bad.getItem(); // write this.a.item, write this.b
      ListItem t = this.getList();  // write this.a
      ListItem ret = new ListItem(t,null); // consume t
      return ret;
    }

    // BAD

    @writes this.a, this.b
    @nonnull unique ListItem send() {
      ListItem bad = a; 
      ListItem t = this.getList();  // write this.a - cannot check since 
      ListItem ret = new ListItem(t,null); // consume t
      this.b = bad.getItem(); // write bad.item, write this.b
      return ret;
    }
  } 

  send() method can be translated to (roughly):
  
  // GOOD

  let _ = 
    let 
      bad = this.a // write this.a
    in 
      this.b = bad.getItem() // write this.b, (write bad.item => write this.a)
    end
  in
    let 
      t = this.getList() // write this.a
    in
      let 
        ret = new ListItem(t,null) // consume t
      in
        ret // consume ret
      end
    end
  end
   
  // BAD

  let bad = this.a in
    let t = this.getList() in
      let ret = new ListItem(t,null) in
        let _ = this.b = bad.getItem() in 
          ret
        end
      end
    end
  end

  This example code can be checked with a little bit restructuring
and the help of "destructive-read" rule.

}%



%theorem reftyping-ok/expr
  : forall* {CM} {PM} {MM} {W} {L1} {L2} {B} {E} {RT} {XX} 
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {RTYP-E: reftyping L1 CM MM B E (out/expr RT XX) L2}
    exists {Pi1} {Pi2} {Out}
    {B=>Pi1: cxt2perm CM PM B Pi1} 
    {XM=>Pi2: effects2input CM PM B XX ([f] Pi2 f)}
    {XM=>Out: effects2output CM PM B RT XX ([f] Out f)}
    {TYP: {f} typing W (Pi1 , (Pi2 f)) E (Out f)}
    true.

- : reftyping-ok/expr CM-CM CM2PM
    (reftyping/read RTYP-E CM-L FM-L
      (make-targets-and-effects/borrow S+F=>GM GM2XM
        consider-ftype/shared) XX1+XX2=XX)
    %{=>}% _ _ _ B=>Pi1 XX=>Pin2 
    (effects2output/shared XM=>Pi1 MX=>Pi2 T2TF)
    (effects/ TRANS.


- : reftyping-ok/expr CM-CM CM2PM
    (reftyping/read RTYP-E CM-L FM-L
      (make-targets-and-effects/shared consider-ftype/unique) XX1+XX2=XX)
    %{=>}% _ _ _ B=>Pi1 XX=>Pin2
    (effects2output/unique/0t tgtmap`size/0 XM=>Pi1 
      ([_] set2facts/0) MX=>Pi2 T2TF) 
    ([f]
      (tTrans2
        (tRead1
          (tTrans2
            (TYP-E f)
            (transform/trans
              (TRANS f)
              (transform/inside [r]
                (transform/trans
                  (transform/skolem)
                  (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
          (letTyping/exists [v]
            (letTyping/exists [r]
              (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans4
                (implies/combine
                  (implies/trans3
                    (implies/equiv (equiv/symmetric equiv/identity))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans5
                        (implies/equiv (equiv/symmetric equiv/zero))
                        (implies/scale (implies/gen-pack-encumber v))
                        (implies/scale-distribute-encumbered)
                        (implies/equiv-encumbered
                          (equiv/distribute) (equiv/reflexive))
                        (implies/combine-assoc-encumbered)))
                    (implies/linear-modus-ponens))
                  (implies/equiv equiv/roll2))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/chain-implication)
                  (implies/equiv equiv/commute))
                (implies/equiv 
                  (equiv/transitive
                    (equiv/commute)
                    (equiv/symmetric equiv/associate)))))))
        (transform/rem-unused)))
    <- effects`join-implies-leq XX1+XX2=XX XX1<=XX XX2<=XX
    <- reftyping-ok/expr CM-CM CM2PM RTYP-E %{=>}% 
      _ _ _ B=>Pi1 XX1=>Pi2' XX1=>Out1' TYP-E'
    <- reftyping-frame CM-CM CM2PM B=>Pi1 XX1=>Pi2' XX1=>Out1' TYP-E'
      XX1<=XX %{=>}% _ _ XX=>Pin2 XX=>Out TYP-E
    <- reftyping-ok/before-read/shared
      CM-CM CM2PM CM-L FM-L XX2<=XX XX=>Out _ _ _ T2TF MX=>Pi2 XM=>Pi1 TRANS.
        
- : reftyping-ok/expr CM-CM CM2PM
    (reftyping/read RTYP-E CM-L FM-L 
      (make-targets-and-effects/shared consider-ftype/shared) XX1+XX2=XX)
    %{=>}% _ _ _ B=>Pi1 XX=>Pin2
    (effects2output/shared XM=>Pi1 MX=>Pi2 T2TF)
    ([f]
      (tTrans2
        (tRead1
          (tTrans2
            (TYP-E f)
            (transform/trans
              (TRANS f)
              (transform/inside [r]
                (transform/trans
                  (transform/skolem)
                  (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
          (letTyping/exists [v]
            (letTyping/exists [r]
              (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans4
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans4
                    (implies/combine
                      (implies/reflexive) 
                      (implies/trans
                        (implies/scale (IMP v))
                        (implies/equiv equiv/distribute)))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans
                        (implies/equiv (equiv/symmetric equiv/distribute))
                        (implies/scale (implies/pack v)))
                      (implies/reflexive))
                    (implies/equiv equiv/commute))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine 
                  (implies/reflexive)
                  (implies/trans3
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens) implies/reflexive)
                    (implies/equiv equiv/commute)))))))
        (transform/rem-unused)))
    <- effects`join-implies-leq XX1+XX2=XX XX1<=XX XX2<=XX
    <- reftyping-ok/expr CM-CM CM2PM RTYP-E %{=>}% 
      _ _ _ B=>Pi1 XX1=>Pi2' XX1=>Out1' TYP-E'
    <- reftyping-frame CM-CM CM2PM B=>Pi1 XX1=>Pi2' XX1=>Out1' TYP-E'
      XX1<=XX %{=>}% _ _ XX=>Pin2 XX=>Out TYP-E
    <- reftyping-ok/before-read/shared
      CM-CM CM2PM CM-L FM-L XX2<=XX XX=>Out _ _ _ T2TF MX=>Pi2 XM=>Pi1 TRANS
    <- sharedperm-can-be-duplicated* T2TF IMP.

%worlds () (reftyping-ok/expr _ _ _ _ _ _ _ _ _ _).
%total (T) (reftyping-ok/expr _ _ T _ _ _ _ _ _ _).
