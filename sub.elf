%%% Theorems about reftyping/sub

%%% A motivating example is:
%%% (if ... e1 else e2).f = e3

%%% We need to think about the following cases:

%%% unique ==> shared:
%%% In this case, not only we need to consider fld objects, but also
%%% all the possible object targets as well.

%theorem reftype-sub-transform/L
  : forall* {PM} {NN} {C} {PF1}
    forall {T2PF1: ty2perm PM (ty/ NN annot/unique C) ([o] PF1 o)}
    exists {PF2} {T2PF2: ty2perm PM (ty/ NN annot/shared C) ([o] PF2 o)}
    {TRANS: {x} transform (output/expr x (PF1 x)) (output/expr x (PF2 x))}
    true.

- : reftype-sub-transform/L
    (ty2perm/ PML nn2perm/yes annot2perm/unique) _
    (ty2perm/ PML nn2perm/yes annot2perm/shared)
    ([x] transform/trans3
      (transform/implies
        (implies/trans
          (implies/commute)
          (implies/combine implies/cond-neg implies/reflexive)))
      (transform/cond/nest)
      (transform/implies
        (implies/trans
          (implies/combine implies/cond-unneg implies/reflexive)
          (implies/commute)))).

- : reftype-sub-transform/L
    (ty2perm/ PML nn2perm/may annot2perm/unique) _
    (ty2perm/ PML nn2perm/may annot2perm/shared)
    ([x] transform/trans3
      (transform/implies
        (implies/trans implies/cond-neg
          (implies/equiv (equiv/symmetric equiv/identity))))
      (transform/cond/nest)
      (transform/implies
        (implies/trans implies/identity implies/cond-unneg))).

%worlds (gtermvar) (reftype-sub-transform/L _ _ _ _).
%total { } (reftype-sub-transform/L _ _ _ _).


%theorem reftype-sub-transform/L*
  : forall* {PM} {NN} {C} {PF1} {PF2}
    forall {T2PF1: ty2perm PM (ty/ NN annot/unique C) ([o] PF1 o)}
    {T2PF2: ty2perm PM (ty/ NN annot/shared C) ([o] PF2 o)}
    exists {TRANS: {x} transform (output/expr x (PF1 x)) (output/expr x (PF2 x))}
    true.

- : reftype-sub-transform/L* T2PF1 T2PF2
    ([x] transform/trans
      (TRANS x)
      (transform/implies (implies/equiv (PEQV x))))
    <- reftype-sub-transform/L T2PF1 _ T2PF2' TRANS
    <- ty2perm-deterministic T2PF2' T2PF2 predmap`eq/ ty`eq/ PEQ
    <- ({x} permission`eq-implies-equiv (PEQ x) (PEQV x)).

%worlds (gtermvar) (reftype-sub-transform/L* _ _ _).
%total { } (reftype-sub-transform/L* _ _ _).


%%% delegate to letRefTyping-helper/base/unique/L2**
%%% where fldset2perm is also a input.
%theorem reftype-sub-transform/L1
  : forall* {CM} {B} {NN} {C} {FM} {PM} {S} {CP} {FS} {PiS} {GF} {PF} {PF2} {N}
    forall {SZ: set`size S (s N)}
    {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {CM-B-S: cxt-unique-objset B NN C S}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FM-DM: fldmap`domain FM FS}
    {ME: make-encumbered CM PM B S PiS}
    {S=>GF: {x} set2cond B x S (GF x)}
    {FM2P: {x} fldset2perm PM x FM FS (PF2 x)}
    exists {IMP: {x} implies (combine (PF x) (combine (GF x) PiS))
          (combine (GF x)
            (combine
              (combine (PF x)
                (unitperm (conditional (objequal x null) empty
                  (unitperm (encumbered (PF2 x) (combine (allperm x) (one-predcall CP x)))))))
              (unitperm (encumbered (encumbered-fldperm x PF2 CP) PiS))))}
    true.

%theorem reftype-sub-transform/L1L
  : forall* {GF} {PF} {PF2} {PF2'} {CP} {PiS}
    forall {PEQ: {x} permission`eq (PF2 x) (PF2' x)}
    exists {EQV: {x} equiv
          (combine (GF x)
            (combine
              (combine (PF x)
                (unitperm (conditional (objequal x null) empty
                  (unitperm (encumbered (PF2 x) (combine (allperm x) (one-predcall CP x)))))))
              (unitperm (encumbered (encumbered-fldperm x PF2 CP) PiS))))
          (combine (GF x)
            (combine
              (combine (PF x)
                (unitperm (conditional (objequal x null) empty
                  (unitperm (encumbered (PF2' x) (combine (allperm x) (one-predcall CP x)))))))
              (unitperm (encumbered (encumbered-fldperm x PF2' CP) PiS))))}
    true.

- : reftype-sub-transform/L1L ([_] permission`eq/) ([_] equiv/reflexive).

%worlds (gtermvar) (reftype-sub-transform/L1L _ _).
%total { } (reftype-sub-transform/L1L _ _).


- : reftype-sub-transform/L1 SZ T2PF-B CM-B-S CML PML FM-DM ME S=>GF FS2P
    ([x] implies/trans (IMP x) (implies/equiv (PEQV x)))
    <- letRefTyping-helper/base/unique/L2** _ SZ T2PF-B CM-B-S CML PML
      FM-DM ME S=>GF _ FS2P' IMP
    <- ({x} fldset2perm-unique (FS2P' x) (FS2P x) predmap`eq/ object`eq/
         fldmap`eq/ set`eq/ (PEQ x))
    <- reftype-sub-transform/L1L PEQ PEQV.

%worlds (gtermvar) (reftype-sub-transform/L1 _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform/L1 _ _ _ _ _ _ _ _ _ _).


%theorem reftype-sub-transform/L2
  : forall* {PM} {PF} {CJ} {NN} {C}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {PML: predmap`lookup PM C (conj2pred CJ)}
    exists {PF2} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF2}
    {IMP: {x} implies
          (combine (PF x)
            (unitperm
              (conditional (objequal x null) empty
                (combine (allperm x) (one-predcall (conj2pred CJ) x)))))
          (PF2 x)}
    true.

- : reftype-sub-transform/L2
    (ty2perm/ PML nn2perm/yes annot2perm/borrow) PMLP
    _ (ty2perm/ PML nn2perm/yes annot2perm/unique)
    ([x] implies/trans
      (implies/symmetric-associate)
      (implies/combine implies/reflexive
        (implies/trans
          (implies/cond-factor)
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/identity)
            (implies/trans4
              (implies/combine
                (implies/trans
                  (implies/combine implies/reflexive implies/nonlinear2empty)
                  (implies/identity))
                (implies/reflexive))
              (implies/commute)
              (implies/identity)
              (implies/combine implies/reflexive (implies/equiv (EQV x))))))))
    <- predmap`lookup-unique PMLP PML predmap`eq/ nat`eq/ CPEQ
    <- one-predcall-respects-eq CPEQ EQV.

- : reftype-sub-transform/L2
    (ty2perm/ PML nn2perm/may annot2perm/borrow) PMLP
    _ (ty2perm/ PML nn2perm/may annot2perm/unique)
    ([x] implies/trans
      (implies/combine
        (implies/trans
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/trans (implies/combine implies/reflexive implies/nonlinear2empty)
              (implies/identity)))
          (implies/cond-equal))
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/combine implies/reflexive (implies/equiv (EQV x)))))
      (implies/equiv
        (equiv/transitive equiv/commute equiv/identity)))
    <- predmap`lookup-unique PMLP PML predmap`eq/ nat`eq/ CPEQ
    <- one-predcall-respects-eq CPEQ EQV.

%worlds (gtermvar) (reftype-sub-transform/L2 _ _ _ _ _).
%total { } (reftype-sub-transform/L2 _ _ _ _ _).


%theorem reftype-sub-transform/L2*
  : forall* {PM} {PF} {CJ} {NN} {C} {PF2}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {PML: predmap`lookup PM C (conj2pred CJ)}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) PF2}
    exists {IMP: {x} implies
                 (combine (PF x)
                   (unitperm
                     (conditional (objequal x null) empty
                       (combine (allperm x) (one-predcall (conj2pred CJ) x)))))
                 (PF2 x)}
    true.

- : reftype-sub-transform/L2* T2PF PML T2PF2
    ([x] implies/trans (IMP x) (implies/equiv (PEQV x)))
    <- reftype-sub-transform/L2 T2PF PML _ T2PF2' IMP
    <- ty2perm-deterministic T2PF2' T2PF2 predmap`eq/ ty`eq/ PEQ
    <- ({x} permission`eq-implies-equiv (PEQ x) (PEQV x)).

%worlds (gtermvar) (reftype-sub-transform/L2* _ _ _ _).
%total { } (reftype-sub-transform/L2* _ _ _ _).


%theorem reftype-sub-transform/L3
  : forall* {PM} {NN1} {NN2} {C} {PF1}
    {PF: object -> object -> permission -> permission} {PiB}
    forall {NN-SUB: nonnull`sub NN1 NN2}
    {T2PF1: ty2perm PM (ty/ NN1 annot/unique C) ([o] PF1 o)}
    exists {PF2} {T2PF2: ty2perm PM (ty/ NN2 annot/shared C) ([o] PF2 o)}
    {TRANS: {x}{r}{p} transform (output/expr x (PiB , ((PF1 x) , (PF x r p))))
            (output/expr x (PiB , ((PF2 x) , (PF x r p))))}
    true.

- : reftype-sub-transform/L3 NN-SUB T2PF _ T2PF2
    ([o][r][p] transform/trans3
      (transform/implies
        (implies/trans implies/reorder implies/commute))
      (TRANS' o r p)
      (transform/implies
        (implies/trans
          (implies/combine implies/reflexive (IMP o))
          (implies/trans implies/commute implies/reorder))))
    <- reftype-sub-transform/L T2PF _ T2PF' TRANS
    <- ({x}{r}{p} transform-commutes-envadd* (TRANS x) envadd/expr envadd/expr (TRANS' x r p))
    <- nn-leq-implies-permission-leq T2PF' NN-SUB _ T2PF2 IMP.

%worlds (gtermvar) (reftype-sub-transform/L3 _ _ _ _ _).
%total { } (reftype-sub-transform/L3 _ _ _ _ _).


%theorem reftype-sub-transform/L4
  : forall* {CM} {PM} {B} {S} {FS} {M2} {PiM2} {GF}
    {NN} {C} {PF} {FM} {PiB} {PiS}
    forall {CM2PM: clsmap2predmap CM PM}
    {B=>PiB: cxt2perm PM B PiB}
    {B-S: cxt-unique-objset B NN C S}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {S+FS=>M2: set+set2set S FS M2}
    {S=>GF: {x} set2cond B x S (GF x)}
    {M2=>PiM2: capset2perm CM PM B M2 PiM2}
    {ME: make-encumbered CM PM B S PiS}
    {T2PF:ty2perm PM (ty/ NN annot/unique C) ([x] PF x)}
    exists {Pi}
    {IMP: {o}{r} implies
          (combine PiB
            (combine PiS
              (combine PiM2
                (combine
                  (unitperm
                    (conditional (objequal o r) empty (GF o)))
                  (PF r)))))
          (combine PiB (combine (PF o) (Pi o r)))}
    true.

- : reftype-sub-transform/L4 CM2PM B=>PiB CM-B-S CML FM-DM
    S+FS=>M S=>GF M=>PiM S=>PiS T2PF _
    ([o][r] implies/trans5
      (implies/combine implies/reflexive
        (implies/trans
          (implies/associate)
          (implies/combine
            (implies/trans implies/commute IMP1)
            (implies/reflexive))))
      (implies/associate)
      (implies/combine IMP2 implies/reflexive)
      (implies/symmetric-associate)
      (implies/combine implies/reflexive
        (implies/trans
          (implies/equiv
            (equiv/transitive
              (equiv/combine equiv/reflexive equiv/commute)
              (equiv/associate)))
          (IMP3 o r))))
    <- restore-object-permission CM-B-S CM2PM CML FM-DM S=>PiS S+FS=>M M=>PiM _ IMP1 SAP
    <- set-all-permissions-implies/L3 B=>PiB SAP _ SAP* IMP2
    <- make-before-write-format/L1 SAP* CM-B-S S=>GF T2PF _ IMP3.

%worlds (gtermvar) (reftype-sub-transform/L4 _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform/L4 _ _ _ _ _ _ _ _ _ _ _ _).


%%% This lemma says if we have two object sets S0 and S1, and two corresponding
%%% conditional permissions G0 and G1. Suppose S0 is less than or equal to S1, then
%%% we can derive G1 from G0.
%theorem reftype-sub-transform/L5
  : forall* {PM} {G0} {G1} {S0} {S1} {O}
    forall {S0=>G0: set2cond PM O S0 G0}
    {S1=>G1: set2cond PM O S1 G1}
    {S0<=S1: set`leq S0 S1}
    exists {G0=>G1: implies G0 G1}
    true.

%theorem reftype-sub-transform/L5/L
  : forall* {PM} {G0} {G1} {S0} {S1} {O}
    forall {N1} {SZ: set`size S1 N1}
    {S0=>G0: set2cond PM O S0 G0}
    {S1=>G1: set2cond PM O S1 G1}
    {S0<=S1: set`leq S0 S1}
    exists {G0=>G1: implies G0 G1}
    true.

%theorem reftype-sub-transform/L5/L1
  : forall* {B} {G0} {S0} {S1} {O} {S1P} {N} {G1P} {G1} {O'} {T}
    forall {N1P} {SZ: set`size S1P N1P}
    {S0=>G0: set2cond B O S0 G0}
    {S1P=>G1P: set2cond B O S1P G1P}
    {NM: set`not-member S1P N}
    {AD: set`add S1P N S1}
    {BL: cxt`lookup B N (cxt-info/ O' T)}
    {S0<=S1: set`leq S0 S1}
    {IMP1: implies G1 (unitperm (conditional (objequal O O') empty G1P))}
    {IMP2: implies (unitperm (conditional (objequal O O') empty G1P)) G1}
    {P} {MB?: set`member? S0 N P}
    exists {G0=>G1: implies G0 G1}
    true.

%theorem reftype-sub-transform/L5/L2
  : forall* {B} {S} {G} {O'} {O}
    forall {S=>G: set2cond B O S G}
    exists {G=>G': implies G (unitperm (conditional (objequal O O') empty G))}
    true.

- : reftype-sub-transform/L5/L2 set2cond/0 implies/contradiction.

- : reftype-sub-transform/L5/L2
    (set2cond/U SP=>GP AD NM BL)
    (implies/trans
      (implies/cond-inner
      (bimplies/reflexive)
      (bimplies/reflexive)
      (implies/reflexive)
        (IMP))
      (IMP2))
    <- reftype-sub-transform/L5/L2 SP=>GP IMP
    <- cond-objequal-can-swap _ _ _ _ IMP2.

%worlds (gtermvar) (reftype-sub-transform/L5/L2 _ _).
%total (A) (reftype-sub-transform/L5/L2 A _).


%theorem reftype-sub-transform/L5/L3
  : forall* {O1} {O2} {O} {Pi1} {Pi2}
    forall {OE: object`eq O1 O2}
    exists {EQV: equiv (unitperm (conditional (objequal O O1) Pi1 Pi2))
                 (unitperm (conditional (objequal O O2) Pi1 Pi2))}
    true.

- : reftype-sub-transform/L5/L3 object`eq/ equiv/reflexive.

%worlds (gtermvar) (reftype-sub-transform/L5/L3 _ _).
%total { } (reftype-sub-transform/L5/L3 _ _).


- : reftype-sub-transform/L5/L1 _ SZ-S1P S0=>G0 S1P=>G1P N!<S1P S1P+N=S1
    BL S0<=S1 IMP1 IMP2 _ (set`member?/out N!<S0)
    (implies/trans3
      (G0=>G1P)
      (IMP3)
      (IMP2))
    <- set`not-member-update2-preserves-leq-converse S0<=S1 N!<S0 N!<S1P S1P+N=S1 S0<=S1P
    <- reftype-sub-transform/L5/L _ SZ-S1P S0=>G0 S1P=>G1P S0<=S1P G0=>G1P
    <- reftype-sub-transform/L5/L2 S1P=>G1P IMP3.

- : reftype-sub-transform/L5/L1 _ SZ-S1P S0=>G0 S1P=>G1P N!<S1P S1P+N=S1
    (BL1:cxt`lookup _ _ (cxt-info/ O' _)) S0<=S1 IMP1 IMP2 _ (set`member?/in N<-S0)
    (implies/trans4
      (IMP3)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (G0P=>G1P))
      (implies/equiv EQV)
      (IMP2))
    <- set`member-implies-not-member-add N<-S0 S0P N!<S0P S0P+N=S0
    <- set`not-member-update-preserves-leq-converse S0<=S1 N!<S0P S0P+N=S0
      N!<S1P S1P+N=S1 S0P<=S1P unit`eq/
    <- set2cond/U-inversion S0=>G0 N!<S0P S0P+N=S0 G0P S0P=>G0P O'' _ BL0 IMP3 IMP4
    <- reftype-sub-transform/L5/L _ SZ-S1P S0P=>G0P S1P=>G1P S0P<=S1P G0P=>G1P
    <- cxt`lookup-unique BL0 BL1 cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE _
    <- reftype-sub-transform/L5/L3 OE EQV.

- : reftype-sub-transform/L5/L (s _) SZ-S1 S0=>G0 S1=>G1 S0<=S1 IMP
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) _ NM AD
    <- set2cond/U-inversion S1=>G1 NM AD G1P S1P=>G1P _ _ BL IMP1 IMP2
    <- set`member?-total MB?
    <- set`not-member-add-increases-size-converse SZ-S1 NM AD SZ-S1P
    <- reftype-sub-transform/L5/L1 _ SZ-S1P S0=>G0 S1P=>G1P NM AD BL S0<=S1 IMP1 IMP2 _ MB? IMP.

- : reftype-sub-transform/L5/L z set`size/0 set2cond/0 set2cond/0 _ implies/reflexive.

- : reftype-sub-transform/L5 S2G1 S2G2 LE IMP
    <- set`size-total SZ
    <- reftype-sub-transform/L5/L _ SZ S2G1 S2G2 LE IMP.

%worlds (gtermvar) (reftype-sub-transform/L5/L _ _ _ _ _ _)
(reftype-sub-transform/L5/L1 _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A A1) (reftype-sub-transform/L5/L A _ _ _ _ _)
(reftype-sub-transform/L5/L1 A1 _ _ _ _ _ _ _ _ _ _ _ _).

%worlds (gtermvar) (reftype-sub-transform/L5 _ _ _ _).
%total { } (reftype-sub-transform/L5 _ _ _ _).


%theorem reftype-sub-transform/L6
  : forall* {PM} {G} {S} {O}
    forall {S=>G: {o} set2cond PM o S (G o)}
    exists {IMP: {o} implies (G o) (unitperm (conditional (objequal o O) empty (G o)))}
    true.

- : reftype-sub-transform/L6 S2G IMP
    <- ({x} reftype-sub-transform/L5/L2 (S2G x) (IMP x)).

%worlds (gtermvar) (reftype-sub-transform/L6 _ _).
%total { } (reftype-sub-transform/L6 _ _).


%theorem reftype-sub-transform/L7/L1
  : forall* {PF0} {PM} {NN0} {NN1} {A} {C} {Pi}
    forall {T2PF0: ty2perm PM (ty/ NN0 A C) PF0}
    {NN0<=NN1: nonnull`sub NN0 NN1}
    exists {PF1} {T2PF1: ty2perm PM (ty/ NN1 A C) PF1}
    {IMP: {x} implies ((PF0 x) , (unitperm (encumbered (PF0 x) Pi)))
          ((PF1 x) , (unitperm (encumbered (PF1 x) Pi)))}
    true.

- : reftype-sub-transform/L7/L1
    T2PF (nonnull`leq/= nonnull`eq/) _ T2PF ([_] implies/reflexive).

- : reftype-sub-transform/L7/L1
    (ty2perm/ PML nn2perm/yes A2P) nonnull`leq/< _
    (ty2perm/ PML nn2perm/may A2P)
    ([x] implies/trans3
      (implies/combine implies/commute implies/combine-assoc-encumbered)
      (implies/symmetric-associate)
      (implies/combine implies/reflexive implies/linear-modus-ponens)).

%worlds (gtermvar) (reftype-sub-transform/L7/L1 _ _ _ _ _).
%total { } (reftype-sub-transform/L7/L1 _ _ _ _ _).


%theorem reftype-sub-transform/L7/L2
  : forall* {CM} {PM} {B} {NN} {C} {K} {O1} {Pi}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-K-NN-C: clsmap-cxt-unique-cap CM B (s K) NN C}
    exists {N} {F} {O} {A0} {C0} {PF} {PF2}
    {N2P: nat2pair (s K) (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ nn/yes A0 C0))}
    {CF: create-fldperm CM PM C0 F PF}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) PF2}
    {TRANS: transform
          (output/expr O1 ((fldperm O F PF) , Pi))
          (output/exists [x]
            (output/expr O1
              (((PF2 x) , (unitperm (encumbered (PF2 x) (fldperm O F ([v] PF v))))) , Pi)))}
    true.

- : reftype-sub-transform/L7/L2 CM-CM CM2PM
    (clsmap-cxt-unique-cap/nest (CML:clsmap`lookup CM C FM)
      (FML: fldmap`lookup FM F (ty/ FNN annot/unique FC))
      (CM-B-K-NN-C:clsmap-cxt-unique-cap CM B (s K) nonnull/yes C))
    _ _ _ _ _ _ _ N2P BL CF (ty2perm/ PM-FL NN2P annot2perm/unique)
    (transform/trans3
      (TRANS)
      (transform/inside [o]
        (transform/trans3
          (transform/implies
            (implies/trans3
              (implies/combine
                (implies/trans3
                  (implies/combine implies/reflexive
                    (implies/equiv (equiv/symmetric equiv/identity)))
                  (IMP2 o)
                  (implies/combine implies/reflexive implies/identity))
                (implies/reflexive))
              (implies/symmetric-associate)
              (implies/combine (implies/equiv (equiv/symmetric equiv/one))
                (implies/reflexive))))
          (transform/skolem)
          (transform/inside [r]
            (transform/implies
              (implies/trans4
                (implies/combine
                  (implies/trans5
                    (implies/equiv equiv/one)
                    (implies/equiv (equiv/symmetric equiv/identity))
                    (implies/combine implies/commute
                      (implies/trans
                        (implies/gen-pack-encumber r)
                        (implies/combine-assoc-encumbered)))
                    (implies/symmetric-associate)
                    (implies/combine implies/reflexive implies/linear-modus-ponens))
                  (implies/reflexive))
                (implies/symmetric-associate)
                (implies/combine implies/reflexive
                  (implies/trans
                    (implies/associate)
                    (implies/combine implies/chain-implication implies/reflexive)))
                (implies/associate))))))
      (transform/rem-unused))
    <- reftype-sub-transform/L7/L2 CM-CM CM2PM CM-B-K-NN-C N F0 O A0 C0 PF _
      N2P BL CF (ty2perm/ PML nn2perm/yes annot2perm/unique) TRANS
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2P NN2P PM-FL IMP
    <- pullout-fldperm IMP IMP2.

- : reftype-sub-transform/L7/L2 CM-CM CM2PM
    (clsmap-cxt-unique-cap/base (N2P:pair2nat (pair/ N F) (s K))
      (BL: cxt`lookup B N (cxt-info/ O (ty/ nn/yes A0 C0))) (NA: not-shared A0)
      (CML: clsmap`lookup CM C0 FM) (FML: fldmap`lookup FM F (ty/ FNNP annot/unique FC))
      (NN-LEQ: nonnull`leq FNN FNNP))
    _ _ _ _ _ _ _
    N2P BL (create-fldperm/ CML FML T2PF0) T2PF
    (transform/trans3
      (transform/implies
        (implies/combine
          (implies/equiv (equiv/symmetric equiv/one))
          (implies/reflexive)))
      (transform/skolem)
      (transform/inside [o]
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/trans5
                (implies/equiv equiv/one)
                (implies/equiv (equiv/symmetric equiv/identity))
                (implies/combine implies/commute
                  (implies/trans
                    (implies/gen-pack-encumber o)
                    (implies/combine-assoc-encumbered)))
                (implies/symmetric-associate)
                (implies/combine implies/reflexive implies/linear-modus-ponens))
              (implies/reflexive))
            (implies/combine (IMP o) implies/reflexive)))))
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-FT
    <- clsmap-ty-implies-ty2perm CM2PM CM-FT PF0 T2PF0
    <- reftype-sub-transform/L7/L1 T2PF0 NN-LEQ PF T2PF IMP.

%worlds (gtermvar) (reftype-sub-transform/L7/L2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A) (reftype-sub-transform/L7/L2 _ _ A _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftype-sub-transform/L7/L2*
  : forall* {CM} {PM} {B} {NN} {C} {K} {O1} {Pi}
    {N} {F} {O} {A0} {C0} {PF}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-K-NN-C: clsmap-cxt-unique-cap CM B (s K) NN C}
    {N2P: nat2pair (s K) (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ nn/yes A0 C0))}
    {CF: create-fldperm CM PM C0 F PF}
    exists {PF2} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF2}
    {TRANS: transform
          (output/expr O1 ((fldperm O F PF) , Pi))
          (output/exists [x]
            (output/expr O1
              (((PF2 x) , (unitperm (encumbered (PF2 x) (fldperm O F ([v] PF v))))) , Pi)))}
    true.

- : reftype-sub-transform/L7/L2*
    CM-CM CM2PM CM-B-K-NN-C
    (N2P':nat2pair (s K) (pair/ N' F'))
    (BL':cxt`lookup B N' (cxt-info/ O' (ty/ _ A0' C0')))
    (CF':create-fldperm CM PM C0' F' PF') _ T2PF
    (transform/trans3
      (transform/implies (implies/combine (implies/equiv EQV) implies/reflexive))
      (TRANS)
      (transform/inside [x]
        (transform/implies
          (implies/combine
            (implies/combine implies/reflexive
              (implies/equiv-encumbered equiv/reflexive
                (equiv/symmetric EQV)))
            (implies/reflexive)))))
    <- reftype-sub-transform/L7/L2 CM-CM CM2PM CM-B-K-NN-C N F O A0 C0 PF _
      N2P BL CF T2PF TRANS
    <- nat2pair-unique N2P' N2P nat`eq/ PE
    <- pair-eq-implies-eq PE (N'=N:nat`eq N' N) (F'=F:nat`eq F' F)
    <- cxt`lookup-unique BL' BL cxt`eq/ N'=N CIE
    <- cxt-info-eq-inversion CIE O'=O TE
    <- ty-eq-inversion TE NN0'=NN0 A0'=A0 C0'=C0
    <- create-fldperm-unique CF' CF clsmap`eq/ predmap`eq/ C0'=C0 F'=F PF'=PF
    <- permission`precise-exists-respects-eq O'=O F'=F PF'=PF EQ
    <- permission`eq-implies-equiv EQ EQV.

%worlds (gtermvar) (reftype-sub-transform/L7/L2* _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform/L7/L2* _ _ _ _ _ _ _ _ _).


%%% This theorem says if we have a clsmap-cxt-unique-capset relation and
%%% a set of permissions from capset2perm, then we can pull out a field permission
%%% from the permissions.
%theorem reftype-sub-transform/L7
  : forall* {CM} {PM} {B} {NN} {C} {M} {Pi} {O} {Pi'} {PiB}
    forall {N} {SZ: set`size M (s N)}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {Z!<M: set`not-member M shared}
    {CM-B-NN-C-M: clsmap-cxt-unique-capset CM B NN C M}
    {B=>Pi: cxt2perm PM B PiB}
    {M=>Pi: capset2perm CM PM B M Pi}
    exists {PF} {T2P: ty2perm PM (ty/ NN annot/unique C) PF}
    {IMP: transform (output/expr O (PiB , (Pi , Pi')))
          (output/exists [o]
            (output/expr O
              (PiB , ((PF o) , ((unitperm (encumbered (PF o) Pi)) , Pi')))))}
    true.

%theorem reftype-sub-transform/L7/F
  : forall* {PM} {NN} {C} {PiB} {Pi} {Pi'} {O}
    forall {V: void}
    exists {PF} {T2P: ty2perm PM (ty/ NN annot/unique C) PF}
    {IMP: transform (output/expr O (PiB , (Pi , Pi')))
          (output/exists [o]
            (output/expr O
              (PiB , ((PF o) , ((unitperm (encumbered (PF o) Pi)) , Pi')))))}
    true.


- : reftype-sub-transform/L7 _ SZ CM-CM CM2PM NM
    (CM-B-NN-C-M:clsmap-cxt-unique-capset CM B NN C _)
    B=>PiB M=>Pi _ T2PF TRANS
    <- set`lookup-implies-not-member-update (set`lookup/= nat`eq/) MP
      (K!<MP:set`not-member MP shared) MP+K=M
    <- set`add-implies-member MP+K=M MB
    <- set`member-not-member-contradiction MB NM V
    <- reftype-sub-transform/L7/F V _ T2PF TRANS.

- : reftype-sub-transform/L7 _ SZ CM-CM CM2PM NM
    (CM-B-NN-C-M:clsmap-cxt-unique-capset CM B NN C _)
    B=>PiB M=>Pi _ T2PF
    (transform/trans3
      (transform/implies
        (implies/trans4
          (implies/combine (implies/trans IMP implies/commute)
            (implies/combine (implies/equiv (equiv/symmetric EQV)) implies/reflexive))
          (implies/equiv equiv/symmetric-associate)
          (implies/combine implies/reflexive
            (implies/trans
              (implies/associate)
              (implies/combine
                (implies/trans
                  (implies/associate)
                  (implies/combine
                    (implies/trans
                      (implies/combine implies/reflexive implies/cond-neg)
                      (implies/cond-elim))
                    (implies/reflexive)))
                (implies/reflexive))))
          (implies/equiv
            (equiv/transitive4
              (equiv/combine equiv/reflexive
                (equiv/symmetric-associate))
              (equiv/reorder)
              (equiv/associate)
              (equiv/commute)))))
      (TRANS')
      (transform/inside [o]
        (transform/implies
          (implies/trans11
            (implies/equiv
              (equiv/transitive
                (equiv/commute)
                (equiv/symmetric-associate)))
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric-associate)
                (equiv/roll3)))
            (implies/combine
              (implies/trans
                (IMP)
                (implies/combine
                  (implies/gen-false-encumbered) implies/reflexive))
              (implies/reflexive))
            (implies/symmetric-associate)
            (implies/combine implies/reflexive (implies/equiv equiv/roll3))
            (implies/associate)
            (implies/combine
              (implies/trans implies/commute implies/chain-implication)
              (implies/reflexive))
            (implies/combine implies/reflexive (implies/equiv equiv/roll3))
            (implies/associate)
            (implies/combine
              (implies/trans
                add-encumber
                (implies/equiv-encumbered
                  (equiv/reflexive)
                  (EQV)))
              implies/reflexive)
            (implies/equiv
              (equiv/transitive
                (equiv/roll2)
                (equiv/combine equiv/reflexive equiv/roll2)))))))
    <- set`lookup-implies-not-member-update (set`lookup/= nat`eq/) MP K!<MP MP+K=M
    <- clsmap-cxt-unique-capset/U-inversion CM-B-NN-C-M K!<MP MP+K=M
      CM-B-NN-C-MP (CM-B-K-NN-C:clsmap-cxt-unique-cap CM B (s K) NN C)
    <- reftype-sub-transform/L7/L2 CM-CM CM2PM CM-B-K-NN-C _ _ _ _ _ _ _ N2P BL CF T2PF TRANS
    <- capset2perm/U-inversion* M=>Pi K!<MP MP+K=M N2P BL CF PiP MP=>PiP EQV
    <- transform-commutes-envadd* TRANS envadd/expr (envadd/exists [_] envadd/expr) TRANS'
    <- cxt2perm-duplicate-notnull-info B=>PiB BL IMP.

%worlds (gtermvar) (reftype-sub-transform/L7/F _ _ _ _).
%total { } (reftype-sub-transform/L7/F _ _ _ _).

%worlds (gtermvar) (reftype-sub-transform/L7 _ _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform/L7 _ _ _ _ _ _ _ _ _ _ _).


%theorem reftype-sub-transform/L8
  : forall* {PF0} {PM} {NN0} {NN1} {A} {C} {Pi}
    forall {T2PF0: ty2perm PM (ty/ NN0 A C) PF0}
    {NN0<=NN1: nonnull`sub NN0 NN1}
    exists {PF1} {T2PF1: ty2perm PM (ty/ NN1 A C) PF1}
    {IMP: {x}{p:permission} implies ((PF0 x) , (unitperm (encumbered (PF0 x) (Pi p))))
          ((PF1 x) , (unitperm (encumbered (PF1 x) (Pi p))))}
    true.

- : reftype-sub-transform/L8
    T2PF (nonnull`leq/= nonnull`eq/) _ T2PF ([_][_] implies/reflexive).

- : reftype-sub-transform/L8
    (ty2perm/ PML nn2perm/yes A2P) nonnull`leq/< _
    (ty2perm/ PML nn2perm/may A2P)
    ([x][p] implies/trans3
      (implies/combine implies/commute implies/combine-assoc-encumbered)
      (implies/symmetric-associate)
      (implies/combine implies/reflexive implies/linear-modus-ponens)).

%worlds (gtermvar) (reftype-sub-transform/L8 _ _ _ _ _).
%total { } (reftype-sub-transform/L8 _ _ _ _ _).


%theorem reftype-sub-transform/shared
  : forall* {CM} {PM} {B} {NN0} {C0} {PF0} {V0} {V1} {PiV0} {PiB} {NN1} {C1} {G1}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B=>PiB: cxt2perm PM B PiB}
    {CM-B-RT1: clsmap-cxt-reftype CM B (reftype/ NN0 C0 targets/shared)}
    {CM-B-RT2: clsmap-cxt-reftype CM B (reftype/ NN1 C1 G1)}
    {SUB: reftype`sub CM V0 (reftype/ NN0 C0 targets/shared) (reftype/ NN1 C1 G1) V1}
    {RT1=>Pi1: reftype2perm CM PM B (reftype/ NN0 C0 targets/shared) ([o][r][p] PF0 o r p)}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    exists {PF1} {PiV1}
    {RT2=>Pi2: reftype2perm CM PM B (reftype/ NN1 C1 G1) ([o][r][p] PF1 o r p)}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {TRANS: transform
            (output/exists [o]
              (output/exists [r]
                (output/exists [p]
                  (output/expr o (PiB , ((PF0 o r p) , PiV0))))))
            (output/exists [o]
              (output/exists [r]
                (output/exists [p]
                  (output/expr o (PiB , ((PF1 o r p), PiV1))))))}
    true.

- : reftype-sub-transform/shared _ _ _ _ _
    (reftype`sub/ _ _ NN-SUB targets`sub/ss)
    (reftype2perm/shared T2PF1) V0=>PiV0 _ _ (reftype2perm/shared T2PF2) V0=>PiV0
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/implies
            (implies/combine implies/reflexive (implies/combine (IMP o) implies/reflexive))))))
    <- nn-leq-implies-permission-leq T2PF1 NN-SUB _ T2PF2 IMP.

%worlds (gtermvar) (reftype-sub-transform/shared _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform/shared _ _ _ _ _ _ _ _ _ _ _ _ _).


%%% Convert fresh to other types
%theorem reftype-sub-transform/fresh
  : forall* {CM} {PM} {B} {NN0} {C0} {PF0} {V0} {V1} {PiV0} {PiB} {NN1} {C1} {G1}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B=>PiB: cxt2perm PM B PiB}
    {CM-B-RT1: clsmap-cxt-reftype CM B (reftype/ NN0 C0 targets/fresh)}
    {CM-B-RT2: clsmap-cxt-reftype CM B (reftype/ NN1 C1 G1)}
    {SUB: reftype`sub CM V0 (reftype/ NN0 C0 targets/fresh) (reftype/ NN1 C1 G1) V1}
    {RT1=>Pi1: reftype2perm CM PM B (reftype/ NN0 C0 targets/fresh) ([o][r][p] PF0 o r p)}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    exists {PF1} {PiV1}
    {RT2=>Pi2: reftype2perm CM PM B (reftype/ NN1 C1 G1) ([o][r][p] PF1 o r p)}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {TRANS: transform
            (output/exists [o]
              (output/exists [r]
                (output/exists [p]
                  (output/expr o (PiB , ((PF0 o r p) , PiV0))))))
            (output/exists [o]
              (output/exists [r]
                (output/exists [p]
                  (output/expr o (PiB , ((PF1 o r p), PiV1))))))}
    true.

%%% fresh => fresh
- : reftype-sub-transform/fresh
    CM-CM CM2PM (B=>PiB:cxt2perm PM B PiB)
    (clsmap-cxt-reftype/fresh _)
    (clsmap-cxt-reftype/fresh _)
    (reftype`sub/ CML FM-DM (NN-SUB:nonnull`leq NN0 NN1) targets`sub/ff)
    (reftype2perm/fresh T2PF0)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/fresh T2PF1)
    (env2input/ U0=>PiU0 M0=>PiM0)
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/implies
            (implies/combine implies/reflexive
              (implies/combine (IMP o) implies/reflexive))))))
  <- nn-leq-implies-permission-leq T2PF0 NN-SUB _ T2PF1 IMP.

%%% fresh => shared
- : reftype-sub-transform/fresh
    CM-CM CM2PM (B=>PiB:cxt2perm PM B PiB)
    (clsmap-cxt-reftype/fresh _)
    (clsmap-cxt-reftype/shared _)
    (reftype`sub/ CML FM-DM (NN-SUB:nonnull`leq NN0 NN1) targets`sub/fs)
    (reftype2perm/fresh T2PF0)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/shared T2PF1)
    (env2input/ U0=>PiU0 M0=>PiM0)
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (TRANS o r p))))
    <- reftype-sub-transform/L3 NN-SUB T2PF0 _ T2PF1 TRANS.

%%% fresh => unique+fresh
- : reftype-sub-transform/fresh
    CM-CM CM2PM (B=>PiB:cxt2perm PM B PiB)
    (clsmap-cxt-reftype/fresh _)
    (clsmap-cxt-reftype/unique _
      (B-NN-C-S:cxt-unique-objset B NN1 C S)
      (CM-B-M:clsmap-cxt-unique-capset CM B NN1 C M) wf-unique-targets/unique+fresh)
    (reftype`sub/ CML FM-DM (NN-SUB:nonnull`sub NN0 NN1)
      (targets`sub/fu (M0-M=M1:set`split M0 M M1)))
    (reftype2perm/fresh (T2PF0:ty2perm PM (ty/ NN0 annot/unique C) PF0))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/unique+fresh T2PF1 S=>GF (M=>PiM:capset2perm CM PM B M PiM))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M1=>PiM1:capset2perm CM PM B M1 PiM1))
    (transform/trans
      (transform/inside [x]
        (transform/trans3
          (transform/trans
            (transform/rem-unused)
            (transform/rem-unused))
          (transform/implies
            (implies/trans
              (implies/combine implies/reflexive
                (implies/combine (IMP x) implies/reflexive))
              (implies/combine implies/reflexive
                (implies/combine
                  (implies/trans
                    (implies/equiv
                      (equiv/transitive
                        (equiv/symmetric equiv/identity)
                        (equiv/commute)))
                    (implies/combine
                      (implies/trans4
                        (implies/empty2true)
                        (implies/nonlinear bimplies/objequal-reflexive)
                        (implies/nonlinear bimplies/disj-weaken/true)
                        (implies/disj2cond))
                      (implies/trans
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/combine implies/reflexive implies/self-implication))))
                  (implies/reflexive)))))
          (transform/trans3
            (transform/gen-exists* objectk exprk
              ([r] output/expr r
                (combine PiB
                  (combine
                    (combine
                      (unitperm
                        (conditional (objequal r x) empty (unitperm (nonlinear (neg t)))))
                      (combine (PF1 x) (unitperm (encumbered (PF1 x) (PF1 x)))))
                    (combine PiU0 PiM0))))
              x)
            (transform/inside [r]
              (transform/gen-exists* (termk permissionk) exprk
                ([v] output/expr r
                  (combine PiB
                    (combine
                      (combine
                        (unitperm
                          (conditional (objequal r x) empty (unitperm (nonlinear (neg t)))))
                        (combine (PF1 x) (unitperm (encumbered (PF1 x) v))))
                      (combine PiU0 PiM0)))))
              (PF1 x))
            (transform/inside [r]
              (transform/inside [p]
                (transform/implies
                  (implies/trans
                    (implies/combine implies/reflexive
                      (implies/combine
                        (implies/combine
                          (implies/cond-inner
                            (bimplies/reflexive)
                            (bimplies/reflexive)
                            (implies/reflexive)
                            (implies/contradiction))
                          (implies/reflexive))
                        (implies/reflexive)))
                    (implies/combine implies/reflexive
                      (implies/trans3
                        (implies/equiv equiv/swap-middle)
                        (implies/combine implies/reflexive
                          (implies/trans3
                            (implies/combine implies/reflexive
                              (implies/equiv (PiM0<=>PiM+PiM1)))
                            (implies/associate)
                            (implies/combine
                              (implies/trans
                                (implies/symmetric-associate)
                                (implies/combine implies/reflexive
                                  (implies/trans
                                    (add-encumber)
                                    (implies/equiv-encumbered equiv/reflexive equiv/commute))))
                              (implies/reflexive))))
                        (implies/equiv equiv/swap-middle))))))))))
      (transform/reorder))
    <- ({x} cxt-unique-objset-implies-set2cond B-NN-C-S (GF x) (S=>GF x))
    <- nn-leq-implies-permission-leq T2PF0 NN-SUB PF1 T2PF1 IMP
    <- set`split-implies-permission-combine M0-M=M1 M0=>PiM0 PiM PiM1
M=>PiM M1=>PiM1 PiM0<=>PiM+PiM1.

%worlds (gtermvar) (reftype-sub-transform/fresh _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform/fresh _ _ _ _ _ _ _ _ _ _ _ _ _).


%%% Convert unique to other types
%%% TODO: we should try to remove the second clsmap-cxt-reftype.
%theorem reftype-sub-transform/unique
  : forall* {CM} {PM} {B} {NN0} {C0} {S0} {MF0} {PF0} {V0} {V1}
    {PiV0} {PiB} {NN1} {C1} {W0} {G1}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B=>PiB: cxt2perm PM B PiB}
    {CM-B-RT1: clsmap-cxt-reftype CM B (reftype/ NN0 C0 (targets/unique S0 MF0 W0))}
    {CM-B-RT2: clsmap-cxt-reftype CM B (reftype/ NN1 C1 G1)}
    {SUB: reftype`sub CM V0 (reftype/ NN0 C0 (targets/unique S0 MF0 W0))
          (reftype/ NN1 C1 G1) V1}
    {RT1=>Pi1: reftype2perm CM PM B
               (reftype/ NN0 C0 (targets/unique S0 MF0 W0)) ([o][r][p] PF0 o r p)}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    exists {PF1} {PiV1}
    {RT2=>Pi2: reftype2perm CM PM B (reftype/ NN1 C1 G1) ([o][r][p] PF1 o r p)}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {TRANS: transform
            (output/exists [o]
              (output/exists [r]
                (output/exists [p]
                  (output/expr o (PiB , ((PF0 o r p) , PiV0))))))
            (output/exists [o]
              (output/exists [r]
                (output/exists [p]
                  (output/expr o (PiB , ((PF1 o r p), PiV1))))))}
    true.

%%% borrow => shared
- : reftype-sub-transform/unique CM-CM CM2PM B=>PiB
    (clsmap-cxt-reftype/unique _ CM-B-S _ _)
    (clsmap-cxt-reftype/shared _)
    (reftype`sub/ CML FM-DM NN-SUB
      (targets`sub/us (S+FS=>M:set+set2set S FS M)
        (U0-S=U1:set`split U0 S U1) (M0-M=M1:set`split M0 M M1)))
    (reftype2perm/borrow SZ set`size/0 T2PF-B S=>GF)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
          (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/shared T2PF2)
    (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/trans3
            (transform/implies
              (implies/trans
                (implies/combine implies/reflexive
                  (implies/trans8
                    (implies/combine implies/reflexive
                      (implies/trans
                        (implies/combine (implies/equiv (equiv/symmetric PiS+PiU1<=>PiU0))
                          (implies/equiv (PiM0<=>PiM+PiM1)))
                        (implies/equiv (equiv/symmetric equiv/associate))))
                    (implies/associate)
                    (implies/combine
                      (implies/trans (implies/equiv (equiv/symmetric equiv/associate)) (IMP4 o))
                      (implies/equiv equiv/reorder))
                    (implies/equiv equiv/swap-middle)
                    (implies/combine
                      (implies/trans
                        (IMP1 o)
                        (implies/combine implies/reflexive
                          (implies/combine (IMP2 o) implies/reflexive)))
                      (implies/reflexive))
                    (implies/trans3
                      (implies/combine
                        (implies/equiv equiv/reorder)
                        (implies/equiv (equiv/symmetric equiv/associate)))
                      (implies/equiv equiv/swap-middle)
                      (implies/combine
                        (implies/trans
                          (implies/equiv equiv/reorder)
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/cond-factor)
                              (implies/cond-inner
                                (bimplies/reflexive)
                                (bimplies/reflexive)
                                (implies/identity)
                                (implies/linear-modus-ponens)))))
                        (implies/reflexive)))
                    (implies/combine (IMP5 o) implies/reflexive)
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/combine equiv/reflexive
                          (equiv/transitive (equiv/combine equiv/reflexive equiv/commute)
                            (equiv/reorder)))
                        (equiv/associate)
                        (equiv/commute)))))
                (implies/reorder)))
            (transform/drop)
            (TRANS o r p)))))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- set`split-implies-permission-combine M0-M=M1 M0=>PiM0 PiM PiM1
      M=>PiM M1=>PiM1 PiM0<=>PiM+PiM1
    <- make-encumbered-combines-converse U0=>PiU0 U0-S=U1 PiS PiU1
      S=>PiS U1=>PiU1 PiS+PiU1<=>PiU0
    <- callRefTyping-helper/L1 _ SZ CM-B-S S+FS=>M M=>PiM S=>GF PiF0 FS2CP IMP1
    <- fldset2condperm-bimplies-fldset2perm CM2PM CML FS2CP PiF FS2P IMP2 IMP3
    <- reftype-sub-transform/L1 SZ T2PF-B CM-B-S CML PML FM-DM S=>PiS
      S=>GF FS2P IMP4
    <- reftype-sub-transform/L2 T2PF-B PML _ T2PF IMP5
    <- reftype-sub-transform/L3 NN-SUB T2PF _ T2PF2 TRANS.

%%% unique => shared
- : reftype-sub-transform/unique CM-CM CM2PM B=>PiB
    (clsmap-cxt-reftype/unique _ CM-B-S _ _)
    (clsmap-cxt-reftype/shared _)
    (reftype`sub/ CML FM-DM NN-SUB
      (targets`sub/us (S+FS=>M:set+set2set S FS M)
        (U0-S=U1:set`split U0 S U1) (M0-M=M1:set`split M0 M M1)))
    (reftype2perm/unique SZ-MF (T2PF:ty2perm PM _ PF)
      ([x] ((S=>GF:{x} set2cond B x S (GF x)) x))
      (MF=>PiMF:capset2perm CM PM B MF PiMF))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
          (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/shared T2PF2)
    (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/trans3
            (transform/implies
              (implies/trans4
                (implies/combine implies/reflexive
                  (implies/trans
                    (implies/combine implies/associate
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine (equiv/symmetric PiS+PiU1<=>PiU0)
                            (PiM0<=>PiM+PiM1))
                          (equiv/swap-middle))))
                    (implies/equiv equiv/swap-middle)))
                (implies/associate)
                (implies/combine
                  (implies/trans
                    (implies/combine implies/reflexive
                      (implies/trans implies/commute implies/symmetric-associate))
                    (IMP o r))
                  (implies/reflexive))
                (implies/equiv
                  (equiv/transitive
                    (equiv/symmetric-associate)
                    (equiv/combine equiv/reflexive (equiv/symmetric-associate))))))
            (TRANS o r p)
            (transform/trans
              (transform/implies
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/associate))
                    (equiv/roll3))))
              (transform/drop))))))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- set`split-implies-permission-combine M0-M=M1 M0=>PiM0 PiM PiM1
      M=>PiM M1=>PiM1 PiM0<=>PiM+PiM1
    <- make-encumbered-combines-converse U0=>PiU0 U0-S=U1 PiS PiU1
      S=>PiS U1=>PiU1 PiS+PiU1<=>PiU0
    <- reftype-sub-transform/L4 CM2PM B=>PiB CM-B-S CML FM-DM S+FS=>M
      S=>GF M=>PiM S=>PiS T2PF _ IMP
    <- reftype-sub-transform/L3 NN-SUB T2PF _ T2PF2 TRANS.

%%% unique+fresh => shared
- : reftype-sub-transform/unique CM-CM CM2PM B=>PiB
    (clsmap-cxt-reftype/unique _ CM-B-S _ _)
    (clsmap-cxt-reftype/shared _)
    (reftype`sub/ CML FM-DM NN-SUB
      (targets`sub/us (S+FS=>M:set+set2set S FS M)
        (U0-S=U1:set`split U0 S U1) (M0-M=M1:set`split M0 M M1)))
    (reftype2perm/unique+fresh (T2PF:ty2perm PM _ PF)
      ([x] ((S=>GF:{x} set2cond B x S (GF x)) x))
      (MF=>PiMF:capset2perm CM PM B MF PiMF))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
          (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/shared T2PF2)
    (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
      (M1=>PiM1:capset2perm CM PM B M1 PiM1))
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/trans3
            (transform/implies
              (implies/trans4
                (implies/combine implies/reflexive
                  (implies/trans
                    (implies/combine implies/associate
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine (equiv/symmetric PiS+PiU1<=>PiU0)
                            (PiM0<=>PiM+PiM1))
                          (equiv/swap-middle))))
                    (implies/equiv equiv/swap-middle)))
                (implies/associate)
                (implies/combine
                  (implies/trans
                    (implies/combine implies/reflexive
                      (implies/trans implies/commute implies/symmetric-associate))
                    (IMP o r))
                  (implies/reflexive))
                (implies/equiv
                  (equiv/transitive
                    (equiv/symmetric-associate)
                    (equiv/combine equiv/reflexive (equiv/symmetric-associate))))))
            (TRANS o r p)
            (transform/trans
              (transform/implies
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/associate))
                    (equiv/roll3))))
              (transform/drop))))))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- set`split-implies-permission-combine M0-M=M1 M0=>PiM0 PiM PiM1
      M=>PiM M1=>PiM1 PiM0<=>PiM+PiM1
    <- make-encumbered-combines-converse U0=>PiU0 U0-S=U1 PiS PiU1
      S=>PiS U1=>PiU1 PiS+PiU1<=>PiU0
    <- reftype-sub-transform/L4 CM2PM B=>PiB CM-B-S CML FM-DM S+FS=>M
      S=>GF M=>PiM S=>PiS T2PF _ IMP
    <- reftype-sub-transform/L3 NN-SUB T2PF _ T2PF2 TRANS.

%%% borrow => borrow
- : reftype-sub-transform/unique CM-CM CM2PM B=>PiB
    (clsmap-cxt-reftype/unique _ CM-B-S0 _ (wf-unique-targets/borrow SZ-S0 set`size/0))
    (clsmap-cxt-reftype/unique _ CM-B-S1 _ (wf-unique-targets/borrow SZ-S1 set`size/0))
    (reftype`sub/ CML FM-DM NN-SUB
      (targets`sub/bb (S0<=S1:set`leq S0 S1)))
    (reftype2perm/borrow _ set`size/0 (T2PF0:ty2perm PM _ PF0)
      ([x] ((S0=>GF0:{x} set2cond B x S0 (GF0 x)) x)))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/borrow SZ-S1 set`size/0 (T2PF1:ty2perm PM _ PF1)
      ([x] ((S1=>GF1:{x} set2cond B x S1 (GF1 x)) x)))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/implies
            (implies/combine implies/reflexive
              (implies/combine (implies/combine (IMP o) (GF0=>GF1 o))
                (implies/reflexive)))))))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- ({x} cxt-unique-objset-implies-set2cond CM-B-S1 _ (S1=>GF1 x))
    <- ({x} reftype-sub-transform/L5 (S0=>GF0 x) (S1=>GF1 x) S0<=S1 (GF0=>GF1 x))
    <- nn-leq-implies-permission-leq T2PF0 NN-SUB _ T2PF1 IMP.

%%% unique => unique
- : reftype-sub-transform/unique
    CM-CM CM2PM (B=>PiB:cxt2perm PM B PiB)
    (clsmap-cxt-reftype/unique _ CM-B-S0 _ (wf-unique-targets/unique _))
    (clsmap-cxt-reftype/unique _ CM-B-S1 _ (wf-unique-targets/unique SZ-M1))
    (reftype`sub/ CML FM-DM (NN-SUB:nonnull`leq NN0 NN1)
      (targets`sub/uu (S0<=S1:set`leq S0 S1) (has-encumbered/1 _)
        (Q0-M=Q1:set`split Q0 M Q1) (M1-M=M0:set`split M1 M M0) _))
    (reftype2perm/unique _ (T2PF0:ty2perm PM _ PF0)
      ([x] ((S0=>GF0:{x} set2cond B x S0 (GF0 x)) x)) (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (Q0=>PiQ0:capset2perm CM PM B Q0 PiQ0)) _ _
    (reftype2perm/unique SZ-M1 (T2PF1:ty2perm PM _ PF1)
      ([x] ((S1=>GF1:{x} set2cond B x _ (GF1 x)) x)) (M1=>PiM1:capset2perm CM PM B M1 PiM1))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (Q1=>PiQ1:capset2perm CM PM B Q1 PiQ1))
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/implies
            (implies/trans
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/combine
                    (implies/combine
                      (implies/cond-inner
                        (bimplies/reflexive)
                        (bimplies/reflexive)
                        (implies/reflexive)
                        (GF0=>GF1 o))
                      (IMP r))
                    (implies/trans
                      (implies/combine implies/reflexive (implies/equiv PiQ0<=>PiM+PiQ1))
                      (implies/reorder)))
                  (implies/associate)
                  (implies/combine
                    (implies/trans
                      (implies/symmetric-associate)
                      (implies/combine implies/reflexive
                        (implies/trans
                          (implies/symmetric-associate)
                          (implies/combine implies/reflexive
                            (implies/trans
                              (add-encumber)
                              (implies/equiv-encumbered
                                (equiv/reflexive)
                                (equiv/transitive equiv/commute PiM+PiM0<=>PiM1)))))))
                    (implies/reflexive))))
              (implies/reflexive))))))
    <- ({x} cxt-unique-objset-implies-set2cond CM-B-S1 _ (S1=>GF1 x))
    <- ({x} reftype-sub-transform/L5 (S0=>GF0 x) (S1=>GF1 x) S0<=S1 (GF0=>GF1 x))
    <- set`split-implies-permission-combine Q0-M=Q1 Q0=>PiQ0 PiM PiQ1
      M=>PiM Q1=>PiQ1 PiQ0<=>PiM+PiQ1
    <- set`split-implies-permission-combine-converse M1-M=M0 M=>PiM M0=>PiM0 PiM1
      M1=>PiM1 PiM+PiM0<=>PiM1
    <- reftype-sub-transform/L7/L1 T2PF0 NN-SUB PF1 T2PF1 IMP.

%%% unique => unique+fresh
- : reftype-sub-transform/unique
    CM-CM CM2PM (B=>PiB:cxt2perm PM B PiB)
    (clsmap-cxt-reftype/unique _ CM-B-S0 _ (wf-unique-targets/unique _))
    (clsmap-cxt-reftype/unique _ CM-B-S1 CM-B-NN-C-MF1
      (wf-unique-targets/unique+fresh))
    (reftype`sub/ CML FM-DM (NN-SUB:nonnull`leq NN0 NN1)
      (targets`sub/uu (S0<=S1:set`leq S0 S1) (has-encumbered/1 _)
        (Q0-M=Q1:set`split Q0 M Q1) (M+M0=M1:set`combine M M0 M1) KK))
    (reftype2perm/unique SZ-M0 (T2PF0:ty2perm PM _ PF0)
      ([x] ((S0=>GF0:{x} set2cond B x S0 (GF0 x)) x)) (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (Q0=>PiQ0:capset2perm CM PM B Q0 PiQ0)) _ _
    (reftype2perm/unique+fresh (T2PF1:ty2perm PM _ PF1)
      ([x] ((S1=>GF1:{x} set2cond B x S1 (GF1 x)) x))
      (M1=>PiM1:capset2perm CM PM B M1 PiM1))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (Q1=>PiQ1:capset2perm CM PM B Q1 PiQ1))
    (transform/trans
      (transform/inside [o]
        (transform/inside [r]
          (transform/inside [p]
            (transform/trans
              (transform/implies
                (implies/trans
                  (implies/combine implies/reflexive
                    (implies/trans3
                      (implies/combine
                        (implies/combine
                          (implies/cond-inner
                            (bimplies/reflexive)
                            (bimplies/reflexive)
                            (implies/reflexive)
                            (GF0=>GF1 o))
                          (IMP r))
                        (implies/trans
                          (implies/combine implies/reflexive (implies/equiv PiQ0<=>PiM+PiQ1))
                          (implies/reorder)))
                      (implies/associate)
                      (implies/combine
                        (implies/trans
                          (implies/symmetric-associate)
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/symmetric-associate)
                              (implies/combine implies/reflexive
                                (implies/trans
                                  (add-encumber)
                                  (implies/equiv-encumbered
                                    (equiv/reflexive)
                                    (equiv/transitive3
                                      (equiv/commute)
                                      (PiM+PiM0<=>PiM1)
                                      (equiv/symmetric equiv/identity))))))))
                        (implies/reflexive))))
                  (implies/reflexive)))
              (transform/gen-exists* (termk permissionk) exprk
                ([p] output/expr o
                  (combine PiB
                    (combine
                      (combine (unitperm (conditional (objequal o r) empty (GF1 o)))
                        (combine (PF1 r) (unitperm (encumbered (PF1 r) (combine PiM1 p)))))
                      (combine PiU0 PiQ1))))
                empty)))))
      (transform/inside [_]
        (transform/inside [_]
          (transform/rem-unused))))
    <- ({x} cxt-unique-objset-implies-set2cond CM-B-S1 _ (S1=>GF1 x))
    <- ({x} reftype-sub-transform/L5 (S0=>GF0 x) (S1=>GF1 x) S0<=S1 (GF0=>GF1 x))
    <- set`split-implies-permission-combine Q0-M=Q1 Q0=>PiQ0 PiM PiQ1
      M=>PiM Q1=>PiQ1 PiQ0<=>PiM+PiQ1
    <- set`split-implies-permission-combine-converse M+M0=M1 M=>PiM M0=>PiM0 PiM1
      M1=>PiM1 PiM+PiM0<=>PiM1
    <- reftype-sub-transform/L7/L1 T2PF0 NN-SUB PF1 T2PF1 IMP.

%%% unique+fresh => unique+fresh
- : reftype-sub-transform/unique
    CM-CM CM2PM (B=>PiB:cxt2perm PM B PiB)
    (clsmap-cxt-reftype/unique _ CM-B-S0 _ (wf-unique-targets/unique+fresh))
    (clsmap-cxt-reftype/unique _ CM-B-S1 _ (wf-unique-targets/unique+fresh))
    (reftype`sub/ CML FM-DM (NN-SUB:nonnull`leq NN0 NN1)
      (targets`sub/uu (S0<=S1:set`leq S0 S1) (has-encumbered/2)
        (Q0-M=Q1:set`split Q0 M Q1) (M+M0=M1:set`combine M M0 M1) KK))
    (reftype2perm/unique+fresh (T2PF0:ty2perm PM _ PF0)
      ([x] ((S0=>GF0:{x} set2cond B x S0 (GF0 x)) x)) (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (Q0=>PiQ0:capset2perm CM PM B Q0 PiQ0)) _ _
    (reftype2perm/unique+fresh (T2PF1:ty2perm PM _ PF1)
      ([x] ((S1=>GF1:{x} set2cond B x S1 (GF1 x)) x))
      (M1=>PiM1:capset2perm CM PM B M1 PiM1))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (Q1=>PiQ1:capset2perm CM PM B Q1 PiQ1))
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/implies
            (implies/trans
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/combine
                    (implies/combine
                      (implies/cond-inner
                        (bimplies/reflexive)
                        (bimplies/reflexive)
                        (implies/reflexive)
                        (GF0=>GF1 o))
                      (IMP r p))
                    (implies/trans
                      (implies/combine implies/reflexive (implies/equiv PiQ0<=>PiM+PiQ1))
                      (implies/reorder)))
                  (implies/associate)
                  (implies/combine
                    (implies/trans
                      (implies/symmetric-associate)
                      (implies/combine implies/reflexive
                        (implies/trans
                          (implies/symmetric-associate)
                          (implies/combine implies/reflexive
                            (implies/trans
                              (add-encumber)
                              (implies/equiv-encumbered
                                (equiv/reflexive)
                                (equiv/transitive
                                  (equiv/swap)
                                  (equiv/combine
                                    (equiv/transitive equiv/commute PiM+PiM0<=>PiM1)
                                    (equiv/reflexive)))))))))
                    (implies/reflexive))))
              (implies/reflexive))))))
    <- ({x} cxt-unique-objset-implies-set2cond CM-B-S1 _ (S1=>GF1 x))
    <- ({x} reftype-sub-transform/L5 (S0=>GF0 x) (S1=>GF1 x) S0<=S1 (GF0=>GF1 x))
    <- set`split-implies-permission-combine Q0-M=Q1 Q0=>PiQ0 PiM PiQ1
      M=>PiM Q1=>PiQ1 PiQ0<=>PiM+PiQ1
    <- set`split-implies-permission-combine-converse M+M0=M1 M=>PiM M0=>PiM0 PiM1
      M1=>PiM1 PiM+PiM0<=>PiM1
    <- reftype-sub-transform/L8 T2PF0 NN-SUB PF1 T2PF1 IMP.

%worlds (gtermvar) (reftype-sub-transform/unique _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform/unique _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftype-sub-transform
  : forall* {CM} {PM} {B} {NN0} {C0} {PF0} {V0} {V1} {PiV0} {PiB} {NN1} {C1}
    forall {G0} {G1} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B=>PiB: cxt2perm PM B PiB}
    {CM-B-RT0: clsmap-cxt-reftype CM B (reftype/ NN0 C0 G0)}
    {CM-B-RT1: clsmap-cxt-reftype CM B (reftype/ NN1 C1 G1)}
    {SUB: reftype`sub CM V0 (reftype/ NN0 C0 G0) (reftype/ NN1 C1 G1) V1}
    {RT1=>Pi1: reftype2perm CM PM B (reftype/ NN0 C0 G0) ([o][r][p] PF0 o r p)}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    exists {PF1} {PiV1}
    {RT1=>Pi1: reftype2perm CM PM B (reftype/ NN1 C1 G1) ([o][r][p] PF1 o r p)}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {TRANS: transform
            (output/exists [o]
              (output/exists [r]
                (output/exists [p:permission]
                  (output/expr o (PiB , ((PF0 o r p) , PiV0))))))
            (output/exists [o]
              (output/exists [r]
                (output/exists [p]
                  (output/expr o (PiB , ((PF1 o r p), PiV1))))))}
    true.

- : reftype-sub-transform targets/shared _ CM-CM CM2PM B=>PiB CM-B-RT0 CM-B-RT1
    SUB RT0=>Pi0 V0=>PiV0 _ _ R1=>Pi1 V1=>PiV1 TRANS
    <- reftype-sub-transform/shared CM-CM CM2PM B=>PiB CM-B-RT0 CM-B-RT1
      SUB RT0=>Pi0 V0=>PiV0 _ _ R1=>Pi1 V1=>PiV1 TRANS.

- : reftype-sub-transform targets/fresh _ CM-CM CM2PM B=>PiB CM-B-RT0 CM-B-RT1
    SUB RT0=>Pi0 V0=>PiV0 _ _ R1=>Pi1 V1=>PiV1 TRANS
    <- reftype-sub-transform/fresh CM-CM CM2PM B=>PiB CM-B-RT0 CM-B-RT1
      SUB RT0=>Pi0 V0=>PiV0 _ _ R1=>Pi1 V1=>PiV1 TRANS.

- : reftype-sub-transform (targets/unique _ _ _) _ CM-CM CM2PM B=>PiB CM-B-RT0 CM-B-RT1
    SUB RT0=>Pi0 V0=>PiV0 _ _ R1=>Pi1 V1=>PiV1 TRANS
    <- reftype-sub-transform/unique CM-CM CM2PM B=>PiB CM-B-RT0 CM-B-RT1
      SUB RT0=>Pi0 V0=>PiV0 _ _ R1=>Pi1 V1=>PiV1 TRANS.

%worlds (gtermvar) (reftype-sub-transform _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
