%%% Theorems about reftyping/sub

%%% A motivating example is:
%%% (if ... e1 else e2).f = e3

%%% We need to think about the following cases:

%%% unique ==> shared:
%%% In this case, not only we need to consider fld objects, but also
%%% all the possible object targets as well.

%theorem reftype-sub-transform/L
  : forall* {PM} {NN} {C} {PF1}
    forall {T2PF1: ty2perm PM (ty/ NN annot/unique C) ([o] PF1 o)}
    exists {PF2} {T2PF2: ty2perm PM (ty/ NN annot/shared C) ([o] PF2 o)}
    {TRANS: {x} transform (output/expr x (PF1 x)) (output/expr x (PF2 x))}
    true.

- : reftype-sub-transform/L
    (ty2perm/ PML nn2perm/yes annot2perm/unique) _
    (ty2perm/ PML nn2perm/yes annot2perm/shared)
    ([x] transform/trans3
      (transform/implies (implies/equiv equiv/reorder))
      (transform/nest)
      (transform/implies (implies/equiv equiv/reorder))).

- : reftype-sub-transform/L
    (ty2perm/ PML nn2perm/may annot2perm/unique) _
    (ty2perm/ PML nn2perm/may annot2perm/shared)
    ([x] transform/trans3
      (transform/implies
        (implies/trans implies/cond-neg
          (implies/equiv (equiv/symmetric equiv/identity))))
      (transform/cond/nest)
      (transform/implies
        (implies/trans implies/identity implies/cond-unneg))).

%worlds (objvar) (reftype-sub-transform/L _ _ _ _).
%total { } (reftype-sub-transform/L _ _ _ _).


%theorem reftype-sub-transform/L*
  : forall* {PM} {NN} {C} {PF1} {PF2}
    forall {T2PF1: ty2perm PM (ty/ NN annot/unique C) ([o] PF1 o)}
    {T2PF2: ty2perm PM (ty/ NN annot/shared C) ([o] PF2 o)}
    exists {TRANS: {x} transform (output/expr x (PF1 x)) (output/expr x (PF2 x))}
    true.

- : reftype-sub-transform/L* T2PF1 T2PF2
    ([x] transform/trans
      (TRANS x)
      (transform/implies (implies/equiv (PEQV x))))
    <- reftype-sub-transform/L T2PF1 _ T2PF2' TRANS
    <- ty2perm-deterministic T2PF2' T2PF2 predmap`eq/ ty`eq/ PEQ
    <- ({x} permission`eq-implies-equiv (PEQ x) (PEQV x)).

%worlds (objvar) (reftype-sub-transform/L* _ _ _).
%total { } (reftype-sub-transform/L* _ _ _).


%%% delegate to letRefTyping-helper/base/unique/L2**
%%% where fldset2perm is also a input.
%theorem reftype-sub-transform/L1
  : forall* {CM} {B} {NN} {C} {FM} {PM} {S} {CP} {FS} {PiS} {GF} {PF} {PF2} {N}
    forall {SZ: set`size S (s N)}
    {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {CM-B-S: cxt-unique-objset B NN C S}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FM-DM: fldmap`domain FM FS}
    {ME: make-encumbered CM PM B S PiS}
    {S=>GF: {x} set2cond B x S (GF x)}
    {FM2P: {x} fldset2perm PM x FM FS (PF2 x)}
    exists {IMP: {x} implies (combine (PF x) (combine (GF x) PiS))
          (combine (GF x)
            (combine
              (combine (PF x)
                (unitperm (conditional (objequal x null) empty
                  (unitperm (encumbered (PF2 x) (combine (allperm x) (one-predcall CP x)))))))
              (unitperm (encumbered (encumbered-fldperm x PF2 CP) PiS))))}
    true.

%theorem reftype-sub-transform/L1L
  : forall* {GF} {PF} {PF2} {PF2'} {CP} {PiS}
    forall {PEQ: {x} permission`eq (PF2 x) (PF2' x)}
    exists {EQV: {x} equiv
          (combine (GF x)
            (combine
              (combine (PF x)
                (unitperm (conditional (objequal x null) empty
                  (unitperm (encumbered (PF2 x) (combine (allperm x) (one-predcall CP x)))))))
              (unitperm (encumbered (encumbered-fldperm x PF2 CP) PiS))))
          (combine (GF x)
            (combine
              (combine (PF x)
                (unitperm (conditional (objequal x null) empty
                  (unitperm (encumbered (PF2' x) (combine (allperm x) (one-predcall CP x)))))))
              (unitperm (encumbered (encumbered-fldperm x PF2' CP) PiS))))}
    true.

- : reftype-sub-transform/L1L ([_] permission`eq/) ([_] equiv/reflexive).

%worlds (objvar) (reftype-sub-transform/L1L _ _).
%total { } (reftype-sub-transform/L1L _ _).


- : reftype-sub-transform/L1 SZ T2PF-B CM-B-S CML PML FM-DM ME S=>GF FS2P
    ([x] implies/trans (IMP x) (implies/equiv (PEQV x)))
    <- letRefTyping-helper/base/unique/L2** _ SZ T2PF-B CM-B-S CML PML
      FM-DM ME S=>GF _ FS2P' IMP
    <- ({x} fldset2perm-unique (FS2P' x) (FS2P x) predmap`eq/ object`eq/
         fldmap`eq/ set`eq/ (PEQ x))
    <- reftype-sub-transform/L1L PEQ PEQV.

%worlds (objvar) (reftype-sub-transform/L1 _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform/L1 _ _ _ _ _ _ _ _ _ _).


%theorem reftype-sub-transform/L2
  : forall* {PM} {PF} {CJ} {NN} {C}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {PML: predmap`lookup PM C (conj2pred CJ)}
    exists {PF2} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF2}
    {IMP: {x} implies
          (combine (PF x)
            (unitperm
              (conditional (objequal x null) empty
                (combine (allperm x) (one-predcall (conj2pred CJ) x)))))
          (PF2 x)}
    true.

- : reftype-sub-transform/L2
    (ty2perm/ PML nn2perm/yes annot2perm/borrow) PMLP
    _ (ty2perm/ PML nn2perm/yes annot2perm/unique)
    ([x] implies/trans4
      (implies/combine implies/commute implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/trans
          (implies/combine implies/reflexive implies/nonlinear2empty)
          (implies/identity))
        (implies/trans3
          (implies/combine implies/duplicate implies/reflexive)
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/combine implies/reflexive implies/cond-neg)
              (implies/cond-elim)
              (implies/combine implies/reflexive (implies/equiv (EQV x)))))))
      (implies/equiv
        (equiv/transitive equiv/commute equiv/identity)))
    <- predmap`lookup-unique PMLP PML predmap`eq/ nat`eq/ CPEQ
    <- one-predcall-respects-eq CPEQ EQV.

- : reftype-sub-transform/L2
    (ty2perm/ PML nn2perm/may annot2perm/borrow) PMLP
    _ (ty2perm/ PML nn2perm/may annot2perm/unique)
    ([x] implies/trans
      (implies/combine
        (implies/trans
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/trans (implies/combine implies/reflexive implies/nonlinear2empty)
              (implies/identity)))
          (implies/cond-equal))
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/combine implies/reflexive (implies/equiv (EQV x)))))
      (implies/equiv
        (equiv/transitive equiv/commute equiv/identity)))
    <- predmap`lookup-unique PMLP PML predmap`eq/ nat`eq/ CPEQ
    <- one-predcall-respects-eq CPEQ EQV.

%worlds (objvar) (reftype-sub-transform/L2 _ _ _ _ _).
%total { } (reftype-sub-transform/L2 _ _ _ _ _).


%theorem reftype-sub-transform/L3
  : forall* {PM} {NN1} {NN2} {C} {PF1} {PF}
    forall {NN-SUB: nonnull`sub NN1 NN2}
    {T2PF1: ty2perm PM (ty/ NN1 annot/unique C) ([o] PF1 o)}
    exists {PF2} {T2PF2: ty2perm PM (ty/ NN2 annot/shared C) ([o] PF2 o)}
    {TRANS: {x} transform (output/expr x ((PF1 x) , (PF x)))
            (output/expr x ((PF2 x) , (PF x)))}
    true.

- : reftype-sub-transform/L3 NN-SUB T2PF _ T2PF2
    ([o] transform/trans3
      (transform/implies implies/commute)
      (TRANS' o)
      (transform/implies
        (implies/trans
          (implies/commute)
          (implies/combine (IMP o) (implies/reflexive)))))
    <- reftype-sub-transform/L T2PF _ T2PF' TRANS
    <- ({x} transform-commutes-envadd* (TRANS x) envadd/expr envadd/expr (TRANS' x))
    <- nonnull-sub-implies-permission-implies NN-SUB T2PF' _ T2PF2 IMP.

%worlds (objvar) (reftype-sub-transform/L3 _ _ _ _ _).
%total { } (reftype-sub-transform/L3 _ _ _ _ _).


%%% When converting targets/unique to targets/shared, or from one
%%% targets/unique to another targets/unique, we need to make sure:
%%% 1. we have enough capabilities for the object targets, in the case
%%%   of converting unique to shared.
%%% 2. we have enough capabilities for the field targets, in case one
%%%  has more encumbered permissions than another.
%theorem reftype-sub-transform
  : forall* {CM} {PM} {B} {RT1} {RT2} {PF1} {V0} {V1} {PiV0}
    forall {CM2PM: clsmap2predmap CM PM}
    {CM-B-RT: clsmap-cxt-reftype CM B RT1}
    {SUB: reftype`sub V0 RT1 RT2 V1}
    {RT1=>Pi1: reftype2perm CM PM B RT1 ([o][r] PF1 o r)}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    exists {PF2} {PiV1}
    {RT2=>Pi2: reftype2perm CM PM B RT2 ([o][r] PF2 o r)}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {TRANS: transform
            (output/exists [o]
              (output/exists [r]
                (output/expr o ((PF1 o r) , PiV0))))
            (output/exists [o]
              (output/exists [r]
                (output/expr o ((PF2 o r), PiV1))))}
    true.

- : reftype-sub-transform _ _ (reftype`sub/ _ _ NN-SUB targets`sub/ss)
    (reftype2perm/shared T2PF1) V0=>PiV0 _ _ (reftype2perm/shared T2PF2) V0=>PiV0
    (transform/inside [o]
      (transform/inside [r]
        (transform/implies (implies/combine (IMP o) implies/reflexive))))
    <- nonnull-sub-implies-permission-implies NN-SUB T2PF1 _ T2PF2 IMP.

- : reftype-sub-transform _ _
    (reftype`sub/ _ _ NN-SUB
      (targets`sub/us (S+FS=>M:set+set2set set/0 FS M)
        (U0-S=U1:set`split U0 set/0 U1) (M0-M=M1:set`split M0 M M1)))
    (reftype2perm/fresh T2PF1)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
          (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/shared T2PF2)
    (env2input/ (U1=>PiU0:make-encumbered CM PM B U1 PiU0)
          (M1=>PiM0:capset2perm CM PM B M1 PiM0))
    (transform/inside [o]
      (transform/inside [r]
        (TRANS o)))
    <- reftype-sub-transform/L3 NN-SUB T2PF1 _ T2PF2 TRANS
    <- set+set2set-unique S+FS=>M set+set2set/0 set`eq/ set`eq/ M=0
    <- set`split-empty U0-S=U1 U1=U0
    <- set`split-respects-eq M0-M=M1 set`eq/ M=0 set`eq/ M0-0=M1
    <- set`split-empty M0-0=M1 M1=M0
    <- set`eq-symmetric U1=U0 U0=U1
    <- set`eq-symmetric M1=M0 M0=M1
    <- make-encumbered-respects-eq U0=>PiU0 clsmap`eq/ predmap`eq/
      cxt`eq/ U0=U1 permission`eq/ U1=>PiU0
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M1 permission`eq/ M1=>PiM0.

%%% We need to show that with set2cond and capset2perm, we can get
%%% all permissions for x and then nest that permission in shared.

- : reftype-sub-transform CM2PM (clsmap-cxt-reftype/unique _ CM-B-S _)
    (reftype`sub/ CML FM-DM NN-SUB
      (targets`sub/us (S+FS=>M:set+set2set S FS M)
        (U0-S=U1:set`split U0 S U1) (M0-M=M1:set`split M0 M M1)))
    (reftype2perm/borrow SZ set`size/0 T2PF-B S=>GF)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
          (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/shared T2PF2)
    (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
    (transform/inside [o]
      (transform/inside [r]
        (transform/trans3
          (transform/implies
            (implies/trans8
              (implies/combine implies/reflexive
                (implies/trans
                  (implies/combine (implies/equiv (equiv/symmetric PiS+PiU1<=>PiU0))
                    (implies/equiv (PiM0<=>PiM+PiM1)))
                  (implies/equiv (equiv/symmetric equiv/associate))))
              (implies/associate)
              (implies/combine
                (implies/trans (implies/equiv (equiv/symmetric equiv/associate)) (IMP4 o))
                (implies/equiv equiv/reorder))
              (implies/equiv equiv/swap-middle)
              (implies/combine
                (implies/trans
                  (IMP1 o)
                  (implies/combine implies/reflexive
                    (implies/combine (IMP2 o) implies/reflexive)))
                (implies/reflexive))
              (implies/trans3
                (implies/combine
                  (implies/equiv equiv/reorder)
                  (implies/equiv (equiv/symmetric equiv/associate)))
                (implies/equiv equiv/swap-middle)
                (implies/combine
                  (implies/trans
                    (implies/equiv equiv/reorder)
                    (implies/combine implies/reflexive
                      (implies/trans
                        (implies/cond-factor)
                        (implies/cond-inner
                          (bimplies/reflexive)
                          (bimplies/reflexive)
                          (implies/identity)
                          (implies/linear-modus-ponens)))))
                  (implies/reflexive)))
              (implies/combine (IMP5 o) implies/reflexive)
              (implies/equiv
                (equiv/transitive3
                  (equiv/combine equiv/reflexive
                    (equiv/transitive (equiv/combine equiv/reflexive equiv/commute)
                      (equiv/reorder)))
                  (equiv/associate)
                  (equiv/commute)))))
          (transform/drop)
          (TRANS o))))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- set`split-implies-permission-combine M0-M=M1 M0=>PiM0 PiM PiM1
      M=>PiM M1=>PiM1 PiM0<=>PiM+PiM1
    <- make-encumbered-combines-converse U0=>PiU0 U0-S=U1 PiS PiU1
      S=>PiS U1=>PiU1 PiS+PiU1<=>PiU0
    <- callRefTyping-helper/L1 _ SZ CM-B-S S+FS=>M M=>PiM S=>GF PiF0 FS2CP IMP1
    <- fldset2condperm-bimplies-fldset2perm CM2PM CML FS2CP PiF FS2P IMP2 IMP3
    <- reftype-sub-transform/L1 SZ T2PF-B CM-B-S CML PML FM-DM S=>PiS
      S=>GF FS2P IMP4
    <- reftype-sub-transform/L2 T2PF-B PML _ T2PF IMP5
    <- reftype-sub-transform/L3 NN-SUB T2PF _ T2PF2 TRANS.

%worlds (objvar) (reftype-sub-transform _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform _ _ _ _ _ _ _ _ _ _).