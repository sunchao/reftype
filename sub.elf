%%% Theorems about reftyping/sub

%%% A motivating example is:
%%% (if ... e1 else e2).f = e3

%%% We need to think about the following cases:

%%% unique ==> shared:
%%% In this case, not only we need to consider fld objects, but also
%%% all the possible object targets as well.

%theorem reftype-sub-transform/L
  : forall* {PM} {NN} {C} {PF1}
    forall {T2PF1: ty2perm PM (ty/ NN annot/unique C) ([o] PF1 o)}
    exists {PF2} {T2PF2: ty2perm PM (ty/ NN annot/shared C) ([o] PF2 o)}
    {TRANS: {x} transform (output/expr x (PF1 x)) (output/expr x (PF2 x))}
    true.

- : reftype-sub-transform/L
    (ty2perm/ PML nn2perm/yes annot2perm/unique) _
    (ty2perm/ PML nn2perm/yes annot2perm/shared)
    ([x] transform/trans3
      (transform/implies
        (implies/trans
          (implies/commute)
          (implies/combine implies/cond-neg implies/reflexive)))
      (transform/cond/nest)
      (transform/implies
        (implies/trans
          (implies/combine implies/cond-unneg implies/reflexive)
          (implies/commute)))).

- : reftype-sub-transform/L
    (ty2perm/ PML nn2perm/may annot2perm/unique) _
    (ty2perm/ PML nn2perm/may annot2perm/shared)
    ([x] transform/trans3
      (transform/implies
        (implies/trans implies/cond-neg
          (implies/equiv (equiv/symmetric equiv/identity))))
      (transform/cond/nest)
      (transform/implies
        (implies/trans implies/identity implies/cond-unneg))).

%worlds (objvar) (reftype-sub-transform/L _ _ _ _).
%total { } (reftype-sub-transform/L _ _ _ _).


%theorem reftype-sub-transform/L*
  : forall* {PM} {NN} {C} {PF1} {PF2}
    forall {T2PF1: ty2perm PM (ty/ NN annot/unique C) ([o] PF1 o)}
    {T2PF2: ty2perm PM (ty/ NN annot/shared C) ([o] PF2 o)}
    exists {TRANS: {x} transform (output/expr x (PF1 x)) (output/expr x (PF2 x))}
    true.

- : reftype-sub-transform/L* T2PF1 T2PF2
    ([x] transform/trans
      (TRANS x)
      (transform/implies (implies/equiv (PEQV x))))
    <- reftype-sub-transform/L T2PF1 _ T2PF2' TRANS
    <- ty2perm-deterministic T2PF2' T2PF2 predmap`eq/ ty`eq/ PEQ
    <- ({x} permission`eq-implies-equiv (PEQ x) (PEQV x)).

%worlds (objvar) (reftype-sub-transform/L* _ _ _).
%total { } (reftype-sub-transform/L* _ _ _).


%%% delegate to letRefTyping-helper/base/unique/L2**
%%% where fldset2perm is also a input.
%theorem reftype-sub-transform/L1
  : forall* {CM} {B} {NN} {C} {FM} {PM} {S} {CP} {FS} {PiS} {GF} {PF} {PF2} {N}
    forall {SZ: set`size S (s N)}
    {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {CM-B-S: cxt-unique-objset B NN C S}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FM-DM: fldmap`domain FM FS}
    {ME: make-encumbered CM PM B S PiS}
    {S=>GF: {x} set2cond B x S (GF x)}
    {FM2P: {x} fldset2perm PM x FM FS (PF2 x)}
    exists {IMP: {x} implies (combine (PF x) (combine (GF x) PiS))
          (combine (GF x)
            (combine
              (combine (PF x)
                (unitperm (conditional (objequal x null) empty
                  (unitperm (encumbered (PF2 x) (combine (allperm x) (one-predcall CP x)))))))
              (unitperm (encumbered (encumbered-fldperm x PF2 CP) PiS))))}
    true.

%theorem reftype-sub-transform/L1L
  : forall* {GF} {PF} {PF2} {PF2'} {CP} {PiS}
    forall {PEQ: {x} permission`eq (PF2 x) (PF2' x)}
    exists {EQV: {x} equiv
          (combine (GF x)
            (combine
              (combine (PF x)
                (unitperm (conditional (objequal x null) empty
                  (unitperm (encumbered (PF2 x) (combine (allperm x) (one-predcall CP x)))))))
              (unitperm (encumbered (encumbered-fldperm x PF2 CP) PiS))))
          (combine (GF x)
            (combine
              (combine (PF x)
                (unitperm (conditional (objequal x null) empty
                  (unitperm (encumbered (PF2' x) (combine (allperm x) (one-predcall CP x)))))))
              (unitperm (encumbered (encumbered-fldperm x PF2' CP) PiS))))}
    true.

- : reftype-sub-transform/L1L ([_] permission`eq/) ([_] equiv/reflexive).

%worlds (objvar) (reftype-sub-transform/L1L _ _).
%total { } (reftype-sub-transform/L1L _ _).


- : reftype-sub-transform/L1 SZ T2PF-B CM-B-S CML PML FM-DM ME S=>GF FS2P
    ([x] implies/trans (IMP x) (implies/equiv (PEQV x)))
    <- letRefTyping-helper/base/unique/L2** _ SZ T2PF-B CM-B-S CML PML
      FM-DM ME S=>GF _ FS2P' IMP
    <- ({x} fldset2perm-unique (FS2P' x) (FS2P x) predmap`eq/ object`eq/
         fldmap`eq/ set`eq/ (PEQ x))
    <- reftype-sub-transform/L1L PEQ PEQV.

%worlds (objvar) (reftype-sub-transform/L1 _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform/L1 _ _ _ _ _ _ _ _ _ _).


%theorem reftype-sub-transform/L2
  : forall* {PM} {PF} {CJ} {NN} {C}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {PML: predmap`lookup PM C (conj2pred CJ)}
    exists {PF2} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF2}
    {IMP: {x} implies
          (combine (PF x)
            (unitperm
              (conditional (objequal x null) empty
                (combine (allperm x) (one-predcall (conj2pred CJ) x)))))
          (PF2 x)}
    true.

- : reftype-sub-transform/L2
    (ty2perm/ PML nn2perm/yes annot2perm/borrow) PMLP
    _ (ty2perm/ PML nn2perm/yes annot2perm/unique)
    ([x] implies/trans
      (implies/symmetric-associate)
      (implies/combine implies/reflexive
        (implies/trans
          (implies/cond-factor)
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/identity)
            (implies/trans4
              (implies/combine
                (implies/trans
                  (implies/combine implies/reflexive implies/nonlinear2empty)
                  (implies/identity))
                (implies/reflexive))
              (implies/commute)
              (implies/identity)
              (implies/combine implies/reflexive (implies/equiv (EQV x))))))))
    <- predmap`lookup-unique PMLP PML predmap`eq/ nat`eq/ CPEQ
    <- one-predcall-respects-eq CPEQ EQV.

- : reftype-sub-transform/L2
    (ty2perm/ PML nn2perm/may annot2perm/borrow) PMLP
    _ (ty2perm/ PML nn2perm/may annot2perm/unique)
    ([x] implies/trans
      (implies/combine
        (implies/trans
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/trans (implies/combine implies/reflexive implies/nonlinear2empty)
              (implies/identity)))
          (implies/cond-equal))
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/combine implies/reflexive (implies/equiv (EQV x)))))
      (implies/equiv
        (equiv/transitive equiv/commute equiv/identity)))
    <- predmap`lookup-unique PMLP PML predmap`eq/ nat`eq/ CPEQ
    <- one-predcall-respects-eq CPEQ EQV.

%worlds (objvar) (reftype-sub-transform/L2 _ _ _ _ _).
%total { } (reftype-sub-transform/L2 _ _ _ _ _).


%theorem reftype-sub-transform/L2*
  : forall* {PM} {PF} {CJ} {NN} {C} {PF2}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {PML: predmap`lookup PM C (conj2pred CJ)}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) PF2}
    exists {IMP: {x} implies
                 (combine (PF x)
                   (unitperm
                     (conditional (objequal x null) empty
                       (combine (allperm x) (one-predcall (conj2pred CJ) x)))))
                 (PF2 x)}
    true.

- : reftype-sub-transform/L2* T2PF PML T2PF2
    ([x] implies/trans (IMP x) (implies/equiv (PEQV x)))
    <- reftype-sub-transform/L2 T2PF PML _ T2PF2' IMP
    <- ty2perm-deterministic T2PF2' T2PF2 predmap`eq/ ty`eq/ PEQ
    <- ({x} permission`eq-implies-equiv (PEQ x) (PEQV x)).

%worlds (objvar) (reftype-sub-transform/L2* _ _ _ _).
%total { } (reftype-sub-transform/L2* _ _ _ _).


%theorem reftype-sub-transform/L3
  : forall* {PM} {NN1} {NN2} {C} {PF1} {PF: object -> object -> permission} {PiB}
    forall {NN-SUB: nonnull`sub NN1 NN2}
    {T2PF1: ty2perm PM (ty/ NN1 annot/unique C) ([o] PF1 o)}
    exists {PF2} {T2PF2: ty2perm PM (ty/ NN2 annot/shared C) ([o] PF2 o)}
    {TRANS: {x}{r} transform (output/expr x (PiB , ((PF1 x) , (PF x r))))
            (output/expr x (PiB , ((PF2 x) , (PF x r))))}
    true.

- : reftype-sub-transform/L3 NN-SUB T2PF _ T2PF2
    ([o][r] transform/trans3
      (transform/implies
        (implies/trans implies/reorder implies/commute))
      (TRANS' o r)
      (transform/implies
        (implies/trans
          (implies/combine implies/reflexive (IMP o))
          (implies/trans implies/commute implies/reorder))))
    <- reftype-sub-transform/L T2PF _ T2PF' TRANS
    <- ({x}{r:object} transform-commutes-envadd* (TRANS x) envadd/expr envadd/expr (TRANS' x r))
    <- nn-leq-implies-permission-leq T2PF' NN-SUB _ T2PF2 IMP.

%worlds (objvar) (reftype-sub-transform/L3 _ _ _ _ _).
%total { } (reftype-sub-transform/L3 _ _ _ _ _).


%theorem reftype-sub-transform/L4
  : forall* {CM} {PM} {B} {S} {FS} {M2} {PiM2} {GF}
    {NN} {C} {PF} {FM} {PiB} {PiS}
    forall {CM2PM: clsmap2predmap CM PM}
    {B=>PiB: cxt2perm PM B PiB}
    {B-S: cxt-unique-objset B NN C S}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {S+FS=>M2: set+set2set S FS M2}
    {S=>GF: {x} set2cond B x S (GF x)}
    {M2=>PiM2: capset2perm CM PM B M2 PiM2}
    {ME: make-encumbered CM PM B S PiS}
    {T2PF:ty2perm PM (ty/ NN annot/unique C) ([x] PF x)}
    exists {Pi}
    {IMP: {o}{r} implies
          (combine PiB
            (combine PiS
              (combine PiM2
                (combine
                  (unitperm
                    (conditional (objequal o r) empty (GF o)))
                  (PF r)))))
          (combine PiB (combine (PF o) (Pi o r)))}
    true.

- : reftype-sub-transform/L4 CM2PM B=>PiB CM-B-S CML FM-DM
    S+FS=>M S=>GF M=>PiM S=>PiS T2PF _
    ([o][r] implies/trans5
      (implies/combine implies/reflexive
        (implies/trans
          (implies/associate)
          (implies/combine
            (implies/trans implies/commute IMP1)
            (implies/reflexive))))
      (implies/associate)
      (implies/combine IMP2 implies/reflexive)
      (implies/symmetric-associate)
      (implies/combine implies/reflexive
        (implies/trans
          (implies/equiv
            (equiv/transitive
              (equiv/combine equiv/reflexive equiv/commute)
              (equiv/associate)))
          (IMP3 o r))))
    <- restore-object-permission CM-B-S CM2PM CML FM-DM S=>PiS S+FS=>M M=>PiM _ IMP1 SAP
    <- set-all-permissions-implies/L3 B=>PiB SAP _ SAP* IMP2
    <- make-before-write-format/L1 SAP* CM-B-S S=>GF T2PF _ IMP3.

%worlds (objvar) (reftype-sub-transform/L4 _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform/L4 _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftype-sub-transform/L5
  : forall* {PM} {G0} {G1} {S0} {S1} {O}
    forall {S0=>G0: set2cond PM O S0 G0}
    {S1=>G1: set2cond PM O S1 G1}
    {S0<=S1: set`leq S0 S1}
    exists {G0=>G1: implies G0 G1}
    true.

%theorem reftype-sub-transform/L5/L
  : forall* {PM} {G0} {G1} {S0} {S1} {O}
    forall {N1} {SZ: set`size S1 N1}
    {S0=>G0: set2cond PM O S0 G0}
    {S1=>G1: set2cond PM O S1 G1}
    {S0<=S1: set`leq S0 S1}
    exists {G0=>G1: implies G0 G1}
    true.

%theorem reftype-sub-transform/L5/L1
  : forall* {B} {G0} {S0} {S1} {O} {S1P} {N} {G1P} {G1} {O'} {T}
    forall {N1P} {SZ: set`size S1P N1P}
    {S0=>G0: set2cond B O S0 G0}
    {S1P=>G1P: set2cond B O S1P G1P}
    {NM: set`not-member S1P N}
    {AD: set`add S1P N S1}
    {BL: cxt`lookup B N (cxt-info/ O' T)}
    {S0<=S1: set`leq S0 S1}
    {IMP1: implies G1 (unitperm (conditional (objequal O O') empty G1P))}
    {IMP2: implies (unitperm (conditional (objequal O O') empty G1P)) G1}
    {P} {MB?: set`member? S0 N P}
    exists {G0=>G1: implies G0 G1}
    true.

%theorem reftype-sub-transform/L5/L2
  : forall* {B} {S} {G} {O'} {O}
    forall {S=>G: set2cond B O S G}
    exists {G=>G': implies G (unitperm (conditional (objequal O O') empty G))}
    true.

- : reftype-sub-transform/L5/L2 set2cond/0 implies/contradiction.

- : reftype-sub-transform/L5/L2
    (set2cond/U SP=>GP AD NM BL)
    (implies/trans
      (implies/cond-inner
      (bimplies/reflexive)
      (bimplies/reflexive)
      (implies/reflexive)
        (IMP))
      (IMP2))
    <- reftype-sub-transform/L5/L2 SP=>GP IMP
    <- cond-objequal-can-swap _ _ _ _ IMP2.

%worlds (objvar) (reftype-sub-transform/L5/L2 _ _).
%total (A) (reftype-sub-transform/L5/L2 A _).


%theorem reftype-sub-transform/L5/L3
  : forall* {O1} {O2} {O} {Pi1} {Pi2}
    forall {OE: object`eq O1 O2}
    exists {EQV: equiv (unitperm (conditional (objequal O O1) Pi1 Pi2))
                 (unitperm (conditional (objequal O O2) Pi1 Pi2))}
    true.

- : reftype-sub-transform/L5/L3 object`eq/ equiv/reflexive.

%worlds (objvar) (reftype-sub-transform/L5/L3 _ _).
%total { } (reftype-sub-transform/L5/L3 _ _).


- : reftype-sub-transform/L5/L1 _ SZ-S1P S0=>G0 S1P=>G1P N!<S1P S1P+N=S1
    BL S0<=S1 IMP1 IMP2 _ (set`member?/out N!<S0)
    (implies/trans3
      (G0=>G1P)
      (IMP3)
      (IMP2))
    <- set`not-member-update2-preserves-leq-converse S0<=S1 N!<S0 N!<S1P S1P+N=S1 S0<=S1P
    <- reftype-sub-transform/L5/L _ SZ-S1P S0=>G0 S1P=>G1P S0<=S1P G0=>G1P
    <- reftype-sub-transform/L5/L2 S1P=>G1P IMP3.

- : reftype-sub-transform/L5/L1 _ SZ-S1P S0=>G0 S1P=>G1P N!<S1P S1P+N=S1
    (BL1:cxt`lookup _ _ (cxt-info/ O' _)) S0<=S1 IMP1 IMP2 _ (set`member?/in N<-S0)
    (implies/trans4
      (IMP3)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (G0P=>G1P))
      (implies/equiv EQV)
      (IMP2))
    <- set`member-implies-not-member-add N<-S0 S0P N!<S0P S0P+N=S0
    <- set`not-member-update-preserves-leq-converse S0<=S1 N!<S0P S0P+N=S0
      N!<S1P S1P+N=S1 S0P<=S1P unit`eq/
    <- set2cond/U-inversion S0=>G0 N!<S0P S0P+N=S0 G0P S0P=>G0P O'' _ BL0 IMP3 IMP4
    <- reftype-sub-transform/L5/L _ SZ-S1P S0P=>G0P S1P=>G1P S0P<=S1P G0P=>G1P
    <- cxt`lookup-unique BL0 BL1 cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE _
    <- reftype-sub-transform/L5/L3 OE EQV.

- : reftype-sub-transform/L5/L (s _) SZ-S1 S0=>G0 S1=>G1 S0<=S1 IMP
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) _ NM AD
    <- set2cond/U-inversion S1=>G1 NM AD G1P S1P=>G1P _ _ BL IMP1 IMP2
    <- set`member?-total MB?
    <- set`not-member-add-increases-size-converse SZ-S1 NM AD SZ-S1P
    <- reftype-sub-transform/L5/L1 _ SZ-S1P S0=>G0 S1P=>G1P NM AD BL S0<=S1 IMP1 IMP2 _ MB? IMP.

- : reftype-sub-transform/L5/L z set`size/0 set2cond/0 set2cond/0 _ implies/reflexive.

- : reftype-sub-transform/L5 S2G1 S2G2 LE IMP
    <- set`size-total SZ
    <- reftype-sub-transform/L5/L _ SZ S2G1 S2G2 LE IMP.

%worlds (objvar) (reftype-sub-transform/L5/L _ _ _ _ _ _)
(reftype-sub-transform/L5/L1 _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A A1) (reftype-sub-transform/L5/L A _ _ _ _ _)
(reftype-sub-transform/L5/L1 A1 _ _ _ _ _ _ _ _ _ _ _ _).

%worlds (objvar) (reftype-sub-transform/L5 _ _ _ _).
%total { } (reftype-sub-transform/L5 _ _ _ _).


%%% When converting targets/unique to targets/shared, or from one
%%% targets/unique to another targets/unique, we need to make sure:
%%% 1. we have enough capabilities for the object targets, in the case
%%%   of converting unique to shared.
%%% 2. we have enough capabilities for the field targets, in case one
%%%  has more encumbered permissions than another.
%theorem reftype-sub-transform
  : forall* {CM} {PM} {B} {RT1} {RT2} {PF1} {V0} {V1} {PiV0} {PiB}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-RT1: clsmap-cxt-reftype CM B RT1}
    {CM-B-RT2: clsmap-cxt-reftype CM B RT2}
    {SUB: reftype`sub CM V0 RT1 RT2 V1}
    {B=>PiB: cxt2perm PM B PiB}
    {RT1=>Pi1: reftype2perm CM PM B RT1 ([o][r] PF1 o r)}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    exists {PF2} {PiV1}
    {RT2=>Pi2: reftype2perm CM PM B RT2 ([o][r] PF2 o r)}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {TRANS: transform
            (output/exists [o]
              (output/exists [r]
                (output/expr o (PiB , ((PF1 o r) , PiV0)))))
            (output/exists [o]
              (output/exists [r]
                (output/expr o (PiB , ((PF2 o r), PiV1)))))}
    true.

- : reftype-sub-transform _ _ _ _ (reftype`sub/ _ _ NN-SUB targets`sub/ss) _
    (reftype2perm/shared T2PF1) V0=>PiV0 _ _ (reftype2perm/shared T2PF2) V0=>PiV0
    (transform/inside [o]
      (transform/inside [r]
        (transform/implies
          (implies/combine implies/reflexive (implies/combine (IMP o) implies/reflexive)))))
    <- nn-leq-implies-permission-leq T2PF1 NN-SUB _ T2PF2 IMP.

- : reftype-sub-transform _ _ _ _
    (reftype`sub/ _ _ NN-SUB
      (targets`sub/us (S+FS=>M:set+set2set set/0 FS M)
        (U0-S=U1:set`split U0 set/0 U1) (M0-M=M1:set`split M0 M M1))) _
    (reftype2perm/fresh T2PF1)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
          (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/shared T2PF2)
    (env2input/ (U1=>PiU0:make-encumbered CM PM B U1 PiU0)
          (M1=>PiM0:capset2perm CM PM B M1 PiM0))
    (transform/inside [o]
      (transform/inside [r]
        (TRANS o r)))
    <- reftype-sub-transform/L3 NN-SUB T2PF1 _ T2PF2 TRANS
    <- set+set2set-unique S+FS=>M set+set2set/0 set`eq/ set`eq/ M=0
    <- set`split-empty U0-S=U1 U1=U0
    <- set`split-respects-eq M0-M=M1 set`eq/ M=0 set`eq/ M0-0=M1
    <- set`split-empty M0-0=M1 M1=M0
    <- set`eq-symmetric U1=U0 U0=U1
    <- set`eq-symmetric M1=M0 M0=M1
    <- make-encumbered-respects-eq U0=>PiU0 clsmap`eq/ predmap`eq/
      cxt`eq/ U0=U1 permission`eq/ U1=>PiU0
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M1 permission`eq/ M1=>PiM0.

%%% We need to show that with set2cond and capset2perm, we can get
%%% all permissions for x and then nest that permission in shared.

- : reftype-sub-transform CM-CM CM2PM (clsmap-cxt-reftype/unique _ CM-B-S _) _
    (reftype`sub/ CML FM-DM NN-SUB
      (targets`sub/us (S+FS=>M:set+set2set S FS M)
        (U0-S=U1:set`split U0 S U1) (M0-M=M1:set`split M0 M M1))) _
    (reftype2perm/borrow SZ set`size/0 T2PF-B S=>GF)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
          (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/shared T2PF2)
    (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
    (transform/inside [o]
      (transform/inside [r]
        (transform/trans3
          (transform/implies
            (implies/trans
              (implies/combine implies/reflexive
                (implies/trans8
                  (implies/combine implies/reflexive
                    (implies/trans
                      (implies/combine (implies/equiv (equiv/symmetric PiS+PiU1<=>PiU0))
                        (implies/equiv (PiM0<=>PiM+PiM1)))
                      (implies/equiv (equiv/symmetric equiv/associate))))
                  (implies/associate)
                  (implies/combine
                    (implies/trans (implies/equiv (equiv/symmetric equiv/associate)) (IMP4 o))
                    (implies/equiv equiv/reorder))
                  (implies/equiv equiv/swap-middle)
                  (implies/combine
                    (implies/trans
                      (IMP1 o)
                      (implies/combine implies/reflexive
                        (implies/combine (IMP2 o) implies/reflexive)))
                    (implies/reflexive))
                  (implies/trans3
                    (implies/combine
                      (implies/equiv equiv/reorder)
                      (implies/equiv (equiv/symmetric equiv/associate)))
                    (implies/equiv equiv/swap-middle)
                    (implies/combine
                      (implies/trans
                        (implies/equiv equiv/reorder)
                        (implies/combine implies/reflexive
                          (implies/trans
                            (implies/cond-factor)
                            (implies/cond-inner
                              (bimplies/reflexive)
                              (bimplies/reflexive)
                              (implies/identity)
                              (implies/linear-modus-ponens)))))
                      (implies/reflexive)))
                  (implies/combine (IMP5 o) implies/reflexive)
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine equiv/reflexive
                        (equiv/transitive (equiv/combine equiv/reflexive equiv/commute)
                          (equiv/reorder)))
                      (equiv/associate)
                      (equiv/commute)))))
              (implies/reorder)))
          (transform/drop)
          (TRANS o r))))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- set`split-implies-permission-combine M0-M=M1 M0=>PiM0 PiM PiM1
      M=>PiM M1=>PiM1 PiM0<=>PiM+PiM1
    <- make-encumbered-combines-converse U0=>PiU0 U0-S=U1 PiS PiU1
      S=>PiS U1=>PiU1 PiS+PiU1<=>PiU0
    <- callRefTyping-helper/L1 _ SZ CM-B-S S+FS=>M M=>PiM S=>GF PiF0 FS2CP IMP1
    <- fldset2condperm-bimplies-fldset2perm CM2PM CML FS2CP PiF FS2P IMP2 IMP3
    <- reftype-sub-transform/L1 SZ T2PF-B CM-B-S CML PML FM-DM S=>PiS
      S=>GF FS2P IMP4
    <- reftype-sub-transform/L2 T2PF-B PML _ T2PF IMP5
    <- reftype-sub-transform/L3 NN-SUB T2PF _ T2PF2 TRANS.

- : reftype-sub-transform CM-CM CM2PM (clsmap-cxt-reftype/unique _ CM-B-S _) _
    (reftype`sub/ CML FM-DM NN-SUB
      (targets`sub/us (S+FS=>M:set+set2set S FS M)
        (U0-S=U1:set`split U0 S U1) (M0-M=M1:set`split M0 M M1))) B=>PiB
    (reftype2perm/unique SZ-MF (T2PF:ty2perm PM _ PF)
      ([x] ((S=>GF:{x} set2cond B x S (GF x)) x))
      (MF=>PiMF:capset2perm CM PM B MF PiMF))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
          (M0=>PiM0:capset2perm CM PM B M0 PiM0)) _ _
    (reftype2perm/shared T2PF2)
    (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
    (transform/inside [o]
      (transform/inside [r]
        (transform/trans3
          (transform/implies
            (implies/trans4
              (implies/combine implies/reflexive
                (implies/trans
                  (implies/combine implies/associate
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine (equiv/symmetric PiS+PiU1<=>PiU0)
                          (PiM0<=>PiM+PiM1))
                        (equiv/swap-middle))))
                  (implies/equiv equiv/swap-middle)))
              (implies/associate)
              (implies/combine
                (implies/trans
                  (implies/combine implies/reflexive
                    (implies/trans implies/commute implies/symmetric-associate))
                  (IMP o r))
                (implies/reflexive))
              (implies/equiv
                (equiv/transitive
                  (equiv/symmetric-associate)
                  (equiv/combine equiv/reflexive (equiv/symmetric-associate))))))
          (TRANS o r)
          (transform/trans
            (transform/implies
              (implies/equiv
                (equiv/transitive
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive equiv/associate))
                  (equiv/roll3))))
            (transform/drop)))))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- set`split-implies-permission-combine M0-M=M1 M0=>PiM0 PiM PiM1
      M=>PiM M1=>PiM1 PiM0<=>PiM+PiM1
    <- make-encumbered-combines-converse U0=>PiU0 U0-S=U1 PiS PiU1
      S=>PiS U1=>PiU1 PiS+PiU1<=>PiU0
    <- reftype-sub-transform/L4 CM2PM B=>PiB CM-B-S CML FM-DM S+FS=>M
      S=>GF M=>PiM S=>PiS T2PF _ IMP
    <- reftype-sub-transform/L3 NN-SUB T2PF _ T2PF2 TRANS.

%worlds (objvar) (reftype-sub-transform _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (reftype-sub-transform _ _ _ _ _ _ _ _ _ _ _ _ _).