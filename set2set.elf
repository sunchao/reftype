%%% Converting object set to (obj,fld) set
%%% $Id: set2set.elf,v 1.3 2013/10/11 19:05:18 csun Exp csun $

%%% Definitions

%%% 1, set+nat2set (objs + fld => (obj,fld) set)

set+nat2set : set -> nat -> set -> type.

set+nat2set/0 : set+nat2set set/0 _ set/0.

set+nat2set/U : set+nat2set SP F QP
                -> pair2nat (pair/ N F) K
                -> set`not-member SP N
                -> set`add SP N S
                -> set`add QP K Q
                -> set+nat2set S F Q.


%%% 2, nat+set2set (obj + flds => (obj,fld) set)

nat+set2set : nat -> set -> set -> type.

nat+set2set/0 : nat+set2set _ set/0 set/0.

nat+set2set/U : nat+set2set N SP QP
                -> pair2nat (pair/ N F) K
                -> set`not-member SP F
                -> set`add SP F S
                -> set`add QP K Q
                -> nat+set2set N S Q.


%%% 3, set+set2set (objs + flds => (obj,fld) set)

set+set2set : set -> set -> set -> type.

set+set2set/0 : set+set2set set/0 _ set/0.

set+set2set/U : set+set2set SP FS QP
                -> nat+set2set N FS R
                -> set`not-member SP N
                -> set`add SP N S
                -> set`union QP R Q
                -> set+set2set S FS Q.


%%% Theorems

% 1. set+nat2set

%theorem set+nat2set-preserves-fresh
  : forall* {S} {N} {F} {K} {Q}
    forall {S+F=>Q: set+nat2set S F Q}
    {NM: set`not-member S N}
    {N+F=>K: pair2nat (pair/ N F) K}
    exists {NM: set`not-member Q K}
    true.

- : set+nat2set-preserves-fresh set+nat2set/0
    set`not-member/0 _ set`not-member/0.

%theorem set+nat2set-preserves-fresh/L
  : forall* {S} {N} {F} {K} {Q} {SP} {QP} {NP} {KP} {B}
    forall {S+F=>Q: set+nat2set SP F QP}
    {NP+F=>KP: pair2nat (pair/ NP F) KP}
    {NMP: set`not-member SP NP}
    {UP: set`add SP NP S}
    {UQ: set`add QP KP Q}
    {NM: set`not-member S N}
    {N+F=>K: pair2nat (pair/ N F) K}
    {E?: nat`eq? N NP B}
    exists {NM: set`not-member Q K}
    true.

- : set+nat2set-preserves-fresh/L _ _ _ UP _ NM _ nat`eq?/yes NMQ
    <- set`add-implies-member UP MB
    <- set`not-member-member-not-equal NM MB N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- set`false-implies-not-member V NMQ.

- : set+nat2set-preserves-fresh/L SP+F=>QP NP+F=>KP _
    SP+NP=S QP+KP=Q N!<S N+F=>K (nat`eq?/no N<>NP) K!<Q
    <- set`update-preserves-not-member-converse N!<S SP+NP=S N!<SP
    <- set+nat2set-preserves-fresh SP+F=>QP N!<SP N+F=>K K!<QP
    <- pair2nat-preserves-ne* (natpair`ne/1 N<>NP) N+F=>K NP+F=>KP K<>KP
    <- set`add-preserves-not-member K!<QP QP+KP=Q K<>KP K!<Q.

- : set+nat2set-preserves-fresh
    (set+nat2set/U SP+F=>QP NP+F=>KP NMP UP UQ) NM N+F=>K NMQ
    <- nat`eq?-total E?
    <- set+nat2set-preserves-fresh/L SP+F=>QP NP+F=>KP NMP UP UQ NM N+F=>K E? NMQ.

%worlds () (set+nat2set-preserves-fresh _ _ _ _)
	(set+nat2set-preserves-fresh/L _ _ _ _ _ _ _ _ _).
%total (T1 T2) (set+nat2set-preserves-fresh T1 _ _ _)
	(set+nat2set-preserves-fresh/L T2 _ _ _ _ _ _ _ _).


%theorem set+nat2set-preserves-size
  : forall* {S} {F} {Q} {N}
    forall {S+F=>Q: set+nat2set S F Q}
    {SZ: set`size S N}
    exists {QZ: set`size Q N}
    true.

%worlds () (set+nat2set-preserves-size _ _ _).
%trustme %total {} (set+nat2set-preserves-size _ _ _).


%theorem set+nat2set-preserves-size-converse
  : forall* {S} {F} {Q} {N}
    forall {S+F=>Q: set+nat2set S F Q}
    {QZ: set`size Q N}
    exists {SZ: set`size S N}
    true.

%worlds () (set+nat2set-preserves-size-converse _ _ _).
%trustme %total {} (set+nat2set-preserves-size-converse _ _ _).


% 2. nat+set2set

%theorem nat+set2set-total*
  : forall {N} {FS}
    exists {S} {N+FS=>S: nat+set2set N FS S} true.

%worlds () (nat+set2set-total* _ _ _ _).
%trustme %total {} (nat+set2set-total* _ _ _ _).

%abbrev nat+set2set-total = nat+set2set-total* _ _ _.


%theorem nat+set2set/U-inversion
  : forall* {N} {FS} {S} {FS'} {F}
    forall {N+FS=>S: nat+set2set N FS S}
    {NM: set`not-member FS' F}
    {AD: set`add FS' F FS}
    exists {S'} {N+FS'=>S': nat+set2set N FS' S'}
    {K} {K=>NF: nat2pair K (pair/ N F)}
    {S'+K=S: set`add S' K S}
    true.

%worlds () (nat+set2set/U-inversion _ _ _ _ _ _ _ _).
%trustme %total {} (nat+set2set/U-inversion _ _ _ _ _ _ _ _).


%theorem nat+set2set/UP-inversion
  : forall* {N} {FS} {S} {SP} {K}
    forall {N+FS=>S: nat+set2set N FS S}
    {NM: set`not-member SP K}
    {A: set`add SP K S}
    exists {FSP} {N+FSP=>SP: nat+set2set N FSP SP}
    {F} {K=>N+F: nat2pair K (pair/ N F)}
    {U: set`add FSP F FS}
    true.

%worlds () (nat+set2set/UP-inversion _ _ _ _ _ _ _ _).
%trustme %total { } (nat+set2set/UP-inversion _ _ _ _ _ _ _ _).


%theorem nat+set2set-unique
  : forall* {N} {FS} {N'} {FS'} {S} {S'}
    forall {N+FS=>S: nat+set2set N FS S}
    {N+FS=>S': nat+set2set N' FS' S'}
    {NE: nat`eq N N'} {SE: set`eq FS FS'}
    exists {SE: set`eq S S'}
    true.

%worlds () (nat+set2set-unique _ _ _ _ _).
%trustme %total { } (nat+set2set-unique _ _ _ _ _).


%theorem nat+set2set-preserves-fresh
  : forall* {S} {N} {F} {K} {Q}
    forall {S+F=>Q: nat+set2set N S Q}
    {NM: set`not-member S F}
    {N+F=>K: pair2nat (pair/ N F) K}
    exists {NM: set`not-member Q K}
    true.

- : nat+set2set-preserves-fresh nat+set2set/0
    set`not-member/0 _ set`not-member/0.

%theorem nat+set2set-preserves-fresh/L
  : forall* {S} {N} {F} {K} {Q} {SP} {QP} {FP} {KP} {B}
    forall {S+F=>Q: nat+set2set N SP QP}
    {NP+F=>KP: pair2nat (pair/ N FP) KP}
    {NMP: set`not-member SP FP}
    {UP: set`add SP FP S}
    {UQ: set`add QP KP Q}
    {NM: set`not-member S F}
    {N+F=>K: pair2nat (pair/ N F) K}
    {E?: nat`eq? F FP B}
    exists {NM: set`not-member Q K}
    true.

- : nat+set2set-preserves-fresh/L _ _ _ UP _ NM _ nat`eq?/yes NMQ
    <- set`add-implies-member UP MB
    <- set`not-member-member-not-equal NM MB N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- set`false-implies-not-member V NMQ.

- : nat+set2set-preserves-fresh/L SP+F=>QP NP+F=>KP _
    SP+NP=S QP+KP=Q N!<S N+F=>K (nat`eq?/no N<>NP) K!<Q
    <- set`update-preserves-not-member-converse N!<S SP+NP=S N!<SP
    <- nat+set2set-preserves-fresh SP+F=>QP N!<SP N+F=>K K!<QP
    <- pair2nat-preserves-ne* (natpair`ne/2 N<>NP) N+F=>K NP+F=>KP K<>KP
    <- set`add-preserves-not-member K!<QP QP+KP=Q K<>KP K!<Q.

- : nat+set2set-preserves-fresh
    (nat+set2set/U SP+F=>QP NP+F=>KP NMP UP UQ) NM N+F=>K NMQ
    <- nat`eq?-total E?
    <- nat+set2set-preserves-fresh/L SP+F=>QP NP+F=>KP NMP UP UQ NM N+F=>K E? NMQ.

%worlds () (nat+set2set-preserves-fresh _ _ _ _)
	(nat+set2set-preserves-fresh/L _ _ _ _ _ _ _ _ _).
%total (T1 T2) (nat+set2set-preserves-fresh T1 _ _ _)
	(nat+set2set-preserves-fresh/L T2 _ _ _ _ _ _ _ _).


%theorem nat+set2set-preserves-size
  : forall* {S} {N} {Q} {K}
    forall {S+F=>Q: nat+set2set N S Q}
    {SZ: set`size S K}
    exists {QZ: set`size Q K}
    true.

%worlds () (nat+set2set-preserves-size _ _ _).
%trustme %total {} (nat+set2set-preserves-size _ _ _).


%theorem nat+set2set-preserves-size-converse
  : forall* {S} {F} {Q} {N}
    forall {S+F=>Q: nat+set2set F S Q}
    {QZ: set`size Q N}
    exists {SZ: set`size S N}
    true.

%worlds () (nat+set2set-preserves-size-converse _ _ _).
%trustme %total {} (nat+set2set-preserves-size-converse _ _ _).


% 3. set+set2set

%theorem set+set2set-respects-eq
  : forall* {S} {FS} {Q} {S'} {FS'} {Q'}
    forall {T: set+set2set S FS Q}
    {SE: set`eq S S'} {FSE: set`eq FS FS'}
    {QE: set`eq Q Q'}
    exists {T': set+set2set S' FS' Q'}
    true.

- : set+set2set-respects-eq T set`eq/ set`eq/ set`eq/ T.

%worlds () (set+set2set-respects-eq _ _ _ _ _).
%total {} (set+set2set-respects-eq _ _ _ _ _).


%theorem set+set2set/U-inversion
  : forall* {S} {FS} {SP} {N} {Q}
    forall {S+FS=>Q: set+set2set S FS Q}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    exists {QP} {SP+FS=>QP: set+set2set SP FS QP}
    {R} {N+FS=>R: nat+set2set N FS R}
    {U: set`union QP R Q}
    true.

%theorem set+set2set/U-inversion/L
  : forall* {S} {FS} {SP} {SP0} {N} {N0} {QP0} {R0} {Q} {B}
    forall {SP0+FS=>QP: set+set2set SP0 FS QP0}
    {N0+FS=>R0: nat+set2set N0 FS R0}
    {NM0: set`not-member SP0 N0}
    {AD0: set`add SP0 N0 S}
    {U: set`union QP0 R0 Q}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    {E?: nat`eq? N N0 B}
    exists {QP} {SP+FS=>QP: set+set2set SP FS QP}
    {R} {N+FS=>R: nat+set2set N FS R}
    {U: set`union QP R Q}
    true.

- : set+set2set/U-inversion/L
    SP0+FS=>QP0 N0+FS=>R0 N0!<SP0 SP0+N0=S QP0+R0=Q N!<SP SP+N=S nat`eq?/yes
    QP0 SP+FS=>QP0 R0 N0+FS=>R0 QP0+R0=Q
    <- set`not-member-add-cancels N0!<SP0 SP0+N0=S N!<SP SP+N=S nat`eq/
      set`eq/ SP0=SP
    <- set+set2set-respects-eq SP0+FS=>QP0 SP0=SP set`eq/ set`eq/ SP+FS=>QP0.

- : set+set2set/U-inversion/L
    SP0+FS=>QP0 N0+FS=>R0 N0!<SP0 SP0+N0=S QP0+R0=Q N!<SP SP+N=S
    (nat`eq?/no N<>N0) _
    (set+set2set/U SP1+FS=>QP1 N0+FS=>R0 N0!<SP1 SP1+N0=SP QP1+R0=QP2)
    R N+FS=>R QP2+R=Q
    <- set`add-commutes-converse SP+N=S SP0+N0=S N<>N0 SP1 SP1+N0=SP SP1+N=SP0
    <- set`add-preserves-not-member-converse N!<SP SP1+N0=SP N!<SP1
    <- set`add-preserves-not-member-converse N0!<SP0 SP1+N=SP0 N0!<SP1
    <- set+set2set/U-inversion SP0+FS=>QP0 N!<SP1 SP1+N=SP0 QP1
      SP1+FS=>QP1 R N+FS=>R QP1+R=QP0
    <- set`union-commutative QP1+R=QP0 R+QP1=QP0
    <- set`union-commutative QP0+R0=Q R0+QP0=Q
    <- set`union-associative-converse QP1+R=QP0 R0+QP0=Q QP2 R0+QP1=QP2 QP2+R=Q
    <- set`union-commutative R0+QP1=QP2 QP1+R0=QP2.

- : set+set2set/U-inversion
    (set+set2set/U SP0+FS=>QP0 N0+FS=>R0 N0!<SP0 SP0+N0=S QP0+R0=Q)
    N!<SP SP+N=S _ SP+FS=>QP _ N+FS=>R QP+R=Q
    <- nat`eq?-total N=N0?
    <- set+set2set/U-inversion/L SP0+FS=>QP0 N0+FS=>R0 N0!<SP0 SP0+N0=S QP0+R0=Q
      N!<SP SP+N=S N=N0? _ SP+FS=>QP _ N+FS=>R QP+R=Q.

%worlds () (set+set2set/U-inversion _ _ _ _ _ _ _ _)
	(set+set2set/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A0 A1) (set+set2set/U-inversion A0 _ _ _ _ _ _ _)
	(set+set2set/U-inversion/L A1 _ _ _ _ _ _ _ _ _ _ _ _).


%theorem set+set2set-unique
  : forall* {S} {FS} {Q} {S'} {FS'} {Q'}
    forall {T: set+set2set S FS Q}
    {T': set+set2set S' FS' Q'}
    {SE: set`eq S S'} {FSE: set`eq FS FS'}
    exists {QE: set`eq Q Q'}
    true.

%worlds () (set+set2set-unique _ _ _ _ _).
%trustme %total {} (set+set2set-unique _ _ _ _ _).


%theorem set+set2set-on-empty-set
  : forall* {FS} exists {T: set+set2set set/0 FS set/0} true.

- : set+set2set-on-empty-set set+set2set/0.

%worlds () (set+set2set-on-empty-set _).
%total {} (set+set2set-on-empty-set _).


%theorem set+set2set-lookup-implies-nat2pair
  : forall* {S} {FS} {S2} {K}
    forall {S+FS=>S2: set+set2set S FS S2}
    {L: set`member S2 K}
    exists {N} {F} {L: set`member S N}
    {L: set`member FS F}
    {K=>NF: nat2pair K (pair/ N F)}
    true.

%theorem set+set2set-lookup-implies-nat2pair/L
  : forall* {SP} {FS} {QP} {N0} {R} {S} {Q} {K} {B}
    forall {SP+FS=>QP: set+set2set SP FS QP}
    {N+FS=>R: nat+set2set N0 FS R}
    {NM: set`not-member SP N0}
    {AD: set`add SP N0 S}
    {U: set`union QP R Q}
    {MB: set`member Q K}
    {MB?: set`member? R K B}
    exists {N} {F} {MB: set`member S N}
    {MB: set`member FS F}
    {K=>NF: nat2pair K (pair/ N F)}
    true.

- : set+set2set-lookup-implies-nat2pair/L
    SP+FS=>QP N0+FS=>R N0!<SP SP+N0=S QP+R=Q K<-Q (set`member?/in K<-R)
    N0 _ N0<-S F<-FS K=>N0+F
    <- set`member-implies-not-member-add K<-R RP K!<RP RP+K=R
    <- nat+set2set/UP-inversion N0+FS=>R K!<RP RP+K=R FSP N0+FSP=>RP F K=>N0+F FSP+F=FS
    <- set`add-implies-member SP+N0=S N0<-S
    <- set`add-implies-member FSP+F=FS F<-FS.

- : set+set2set-lookup-implies-nat2pair/L
    SP+FS=>QP N0+FS=>R N0!<SP SP+N0=S QP+R=Q K<-Q (set`member?/out K!<R)
    _ _ N<-S F<-FS K=>N+F
    <- set`not-member-union-right-preserves-member-converse
      K<-Q K!<R QP+R=Q K<-QP
    <- set+set2set-lookup-implies-nat2pair SP+FS=>QP K<-QP _ _ N<-SP
      F<-FS K=>N+F
    <- set`add-preserves-member N<-SP SP+N0=S N<-S.

- : set+set2set-lookup-implies-nat2pair
    (set+set2set/U SP+FS=>QP N+FS=>R N!<SP SP+N=S QP+R=Q) K<-Q
    _ _ N<-S F<-FS K=>N+F
    <- set`member?-total K<-R?
    <- set+set2set-lookup-implies-nat2pair/L SP+FS=>QP N+FS=>R N!<SP SP+N=S QP+R=Q
      K<-Q K<-R? _ _ N<-S F<-FS K=>N+F.

%worlds () (set+set2set-lookup-implies-nat2pair _ _ _ _ _ _ _)
	(set+set2set-lookup-implies-nat2pair/L _ _ _ _ _ _ _ _ _ _ _ _).
%total (A0 A1) (set+set2set-lookup-implies-nat2pair A0 _ _ _ _ _ _)
	(set+set2set-lookup-implies-nat2pair/L A1 _ _ _ _ _ _ _ _ _ _ _).