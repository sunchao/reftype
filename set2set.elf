%%% Converting object set to (obj,fld) set
%%% $Id: set2set.elf,v 1.3 2013/10/11 19:05:18 csun Exp csun $

%%% Definitions

%%% 1, set+nat2set (objs + fld => (obj,fld) set)

set+nat2set : set -> nat -> set -> type.

set+nat2set/0 : set+nat2set set/0 _ set/0.

set+nat2set/U : set+nat2set S' F Q'
                -> pair2nat (pair/ N F) K
                -> set`not-member S' N
                -> set`add S' N S
                -> set`add Q' K Q
                -> set+nat2set S F Q.


%%% 2, nat+set2set (obj + flds => (obj,fld) set)

nat+set2set : nat -> set -> set -> type.

nat+set2set/0 : nat+set2set _ set/0 set/0.

nat+set2set/U : nat+set2set N S' Q'
                -> pair2nat (pair/ N F) K
                -> set`not-member S' F
                -> set`add S' F S
                -> set`add Q' K Q
                -> nat+set2set N S Q.


%%% 3, set+set2set (objs + flds => (obj,fld) set)

set+set2set : set -> set -> set -> type.

set+set2set/0 : set+set2set set/0 _ set/0.

set+set2set/U : set+set2set S' FS Q'
                -> nat+set2set N FS R
                -> set`not-member S' N
                -> set`add S' N S
                -> set`union Q' R Q
                -> set+set2set S FS Q.


%%% 4, set+nat2map (objs + fld + efx => ((obj,fld) => efx))
nat+map2map : nat -> efxmap -> efxmap -> type.

nat+map2map/0 : nat+map2map _ efxmap/0 efxmap/0.

nat+map2map/U : nat+map2map N XMin' XMout'
                -> pair2nat (pair/ N F) K
                -> efxmap`fresh XMin' F
                -> efxmap`update XMin' F X XMin
                -> efxmap`update XMout' K X XMout
                -> nat+map2map N XMin XMout.

%%% 4, set+map2map (objs + (flds => efx) => ((obj,fld) => efx)

set+map2map : set -> efxmap -> efxmap -> type.

set+map2map/0 : set+map2map set/0 _ efxmap/0.

set+map2map/U : set+map2map S' XMin XMout1
                -> nat+map2map N XMin XMout2
                -> set`not-member S' N
                -> set`add S' N S
                -> efxmap`join XMout1 XMout2 XMout
                -> set+map2map S XMin XMout.

%%% Theorems

% 1. set+nat2set

%theorem set+nat2set-preserves-fresh
  : forall* {S} {N} {F} {K} {Q}
    forall {S+F=>Q: set+nat2set S F Q}
    {NM: set`not-member S N}
    {N+F=>K: pair2nat (pair/ N F) K}
    exists {NM: set`not-member Q K}
    true.

- : set+nat2set-preserves-fresh set+nat2set/0
    set`not-member/0 _ set`not-member/0.

%theorem set+nat2set-preserves-fresh/L
  : forall* {S} {N} {F} {K} {Q} {SP} {QP} {NP} {KP} {B}
    forall {S+F=>Q: set+nat2set SP F QP}
    {NP+F=>KP: pair2nat (pair/ NP F) KP}
    {NMP: set`not-member SP NP}
    {UP: set`add SP NP S}
    {UQ: set`add QP KP Q}
    {NM: set`not-member S N}
    {N+F=>K: pair2nat (pair/ N F) K}
    {E?: nat`eq? N NP B}
    exists {NM: set`not-member Q K}
    true.

- : set+nat2set-preserves-fresh/L _ _ _ UP _ NM _ nat`eq?/yes NMQ
    <- set`add-implies-member UP MB
    <- set`not-member-member-not-equal NM MB N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- set`false-implies-not-member V NMQ.

- : set+nat2set-preserves-fresh/L SP+F=>QP NP+F=>KP _
    SP+NP=S QP+KP=Q N!<S N+F=>K (nat`eq?/no N<>NP) K!<Q
    <- set`update-preserves-not-member-converse N!<S SP+NP=S N!<SP
    <- set+nat2set-preserves-fresh SP+F=>QP N!<SP N+F=>K K!<QP
    <- pair2nat-preserves-ne* (natpair`ne/1 N<>NP) N+F=>K NP+F=>KP K<>KP
    <- set`add-preserves-not-member K!<QP QP+KP=Q K<>KP K!<Q.

- : set+nat2set-preserves-fresh
    (set+nat2set/U SP+F=>QP NP+F=>KP NMP UP UQ) NM N+F=>K NMQ
    <- nat`eq?-total E?
    <- set+nat2set-preserves-fresh/L SP+F=>QP NP+F=>KP NMP UP UQ NM N+F=>K E? NMQ.

%worlds () (set+nat2set-preserves-fresh _ _ _ _)
	(set+nat2set-preserves-fresh/L _ _ _ _ _ _ _ _ _).
%total (T1 T2) (set+nat2set-preserves-fresh T1 _ _ _)
	(set+nat2set-preserves-fresh/L T2 _ _ _ _ _ _ _ _).


%theorem set+nat2set-preserves-size
  : forall* {S} {F} {Q} {N}
    forall {S+F=>Q: set+nat2set S F Q}
    {SZ: set`size S N}
    exists {QZ: set`size Q N}
    true.

- : set+nat2set-preserves-size set+nat2set/0 set`size/0 set`size/0.

- : set+nat2set-preserves-size
    (set+nat2set/U S'+F=>Q' N+F=>K N!<S' S'+N=S Q'+K=Q) SZ-S SZ-Q
    <- set`not-member-add-increases-size-converse SZ-S N!<S' S'+N=S SZ-S'
    <- set+nat2set-preserves-size S'+F=>Q' SZ-S' SZ-Q'
    <- set+nat2set-preserves-fresh S'+F=>Q' N!<S' N+F=>K K!<Q'
    <- set`not-member-add-increases-size SZ-Q' K!<Q' Q'+K=Q SZ-Q.

%worlds () (set+nat2set-preserves-size _ _ _).
%total (N) (set+nat2set-preserves-size N _ _).


%theorem set+nat2set-preserves-size-converse
  : forall* {S} {F} {Q} {N}
    forall {S+F=>Q: set+nat2set S F Q}
    {QZ: set`size Q N}
    exists {SZ: set`size S N}
    true.

- : set+nat2set-preserves-size-converse set+nat2set/0 set`size/0 set`size/0.

- : set+nat2set-preserves-size-converse
    (set+nat2set/U S'+F=>Q' N+F=>K N!<S' S'+N=S Q'+K=Q) SZ-Q SZ-S
    <- set+nat2set-preserves-fresh S'+F=>Q' N!<S' N+F=>K K!<Q'
    <- set`not-member-add-increases-size-converse SZ-Q K!<Q' Q'+K=Q SZ-Q'
    <- set+nat2set-preserves-size-converse S'+F=>Q' SZ-Q' SZ-S'
    <- set`not-member-add-increases-size SZ-S' N!<S' S'+N=S SZ-S.

%worlds () (set+nat2set-preserves-size-converse _ _ _).
%total (N) (set+nat2set-preserves-size-converse N _ _).


% 2. nat+set2set

%theorem false-implies-nat+set2set
  : forall* {N} {FS} {S} forall {F:void} exists {NSS: nat+set2set N FS S} true.

%worlds () (false-implies-nat+set2set _ _).
%total { } (false-implies-nat+set2set _ _).


%theorem nat+set2set-respects-eq
  : forall* {N} {N0} {FS} {FS0} {S} {S0}
    forall {NSS: nat+set2set N FS S}
    {E: nat`eq N N0} {E: set`eq FS FS0} {E: set`eq S S0}
    exists {NSS0: nat+set2set N0 FS0 S0}
    true.

- : nat+set2set-respects-eq NSS nat`eq/ set`eq/ set`eq/ NSS.

%worlds (objvar) (nat+set2set-respects-eq _ _ _ _ _).
%total { } (nat+set2set-respects-eq _ _ _ _ _).


%theorem nat+set2set-total*
  : forall {N} {FS}
    exists {S} {N+FS=>S: nat+set2set N FS S} true.

%abbrev nat+set2set-total = nat+set2set-total* _ _ _.


%theorem nat+set2set-total/L
  : forall* {FS}
    forall {K} {Z: set`size FS K} {N}
    exists {S} {N+FS=>S: nat+set2set N FS S}
    true.

- : nat+set2set-total/L _ _ _ _ nat+set2set/0.

- : nat+set2set-total/L _ Z _ _ (nat+set2set/U NSS1 P2N F A QA)
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) _ F A
    <- set`not-member-add-increases-size-converse Z F A Z1
    <- nat+set2set-total/L _ Z1 _ _ NSS1
    <- pair2nat-total P2N
    <- set`add-total QA.

%worlds () (nat+set2set-total/L _ _ _ _ _).
%total (N) (nat+set2set-total/L N _ _ _ _).

- : nat+set2set-total NSS
    <- set`size-total Z
    <- nat+set2set-total/L _ Z _ _ NSS.

%worlds () (nat+set2set-total* _ _ _ _).
%total {} (nat+set2set-total* _ _ _ _).


%theorem nat+set2set-preserves-fresh
  : forall* {S} {N} {F} {K} {Q}
    forall {S+F=>Q: nat+set2set N S Q}
    {NM: set`not-member S F}
    {N+F=>K: pair2nat (pair/ N F) K}
    exists {NM: set`not-member Q K}
    true.

- : nat+set2set-preserves-fresh nat+set2set/0
    set`not-member/0 _ set`not-member/0.

%theorem nat+set2set-preserves-fresh/L
  : forall* {S} {N} {F} {K} {Q} {SP} {QP} {FP} {KP} {B}
    forall {S+F=>Q: nat+set2set N SP QP}
    {NP+F=>KP: pair2nat (pair/ N FP) KP}
    {NMP: set`not-member SP FP}
    {UP: set`add SP FP S}
    {UQ: set`add QP KP Q}
    {NM: set`not-member S F}
    {N+F=>K: pair2nat (pair/ N F) K}
    {E?: nat`eq? F FP B}
    exists {NM: set`not-member Q K}
    true.

- : nat+set2set-preserves-fresh/L _ _ _ UP _ NM _ nat`eq?/yes NMQ
    <- set`add-implies-member UP MB
    <- set`not-member-member-not-equal NM MB N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- set`false-implies-not-member V NMQ.

- : nat+set2set-preserves-fresh/L SP+F=>QP NP+F=>KP _
    SP+NP=S QP+KP=Q N!<S N+F=>K (nat`eq?/no N<>NP) K!<Q
    <- set`update-preserves-not-member-converse N!<S SP+NP=S N!<SP
    <- nat+set2set-preserves-fresh SP+F=>QP N!<SP N+F=>K K!<QP
    <- pair2nat-preserves-ne* (natpair`ne/2 N<>NP) N+F=>K NP+F=>KP K<>KP
    <- set`add-preserves-not-member K!<QP QP+KP=Q K<>KP K!<Q.

- : nat+set2set-preserves-fresh
    (nat+set2set/U SP+F=>QP NP+F=>KP NMP UP UQ) NM N+F=>K NMQ
    <- nat`eq?-total E?
    <- nat+set2set-preserves-fresh/L SP+F=>QP NP+F=>KP NMP UP UQ NM N+F=>K E? NMQ.

%worlds () (nat+set2set-preserves-fresh _ _ _ _)
	(nat+set2set-preserves-fresh/L _ _ _ _ _ _ _ _ _).
%total (T1 T2) (nat+set2set-preserves-fresh T1 _ _ _)
	(nat+set2set-preserves-fresh/L T2 _ _ _ _ _ _ _ _).


%theorem nat+set2set-lookup-implies-nat2pair-lookup-converse
  : forall* {N} {FS} {S} {K}
    forall {A: nat+set2set N FS S}
		{MB: set`member S K}
    exists {F}
    {R: nat2pair K (pair/ N F)} {MB: set`member FS F}
    true.

%theorem nat+set2set-lookup-implies-nat2pair-lookup-converse/L
  : forall* {N} {FS} {S} {K} {B} {FS'} {S'} {K'} {F'}
    forall {A: nat+set2set N FS' S'}
    {R: nat2pair K' (pair/ N F')}
    {NM: set`not-member FS' F'}
    {A: set`add FS' F' FS}
    {A: set`add S' K' S}
		{MB: set`member S K}
    {E?: nat`eq? K' K B}
		exists {F} {R: nat2pair K (pair/ N F)}
    {MB: set`member FS F}
    true.

- : nat+set2set-lookup-implies-nat2pair-lookup-converse/L
    N+FS'=>S' K'=>N+F' F'!<FS' FS'+F'=FS S'+K'=S K<-S nat`eq?/yes
    _ K'=>N+F' F'<-FS
    <- set`add-implies-member FS'+F'=FS F'<-FS.

- : nat+set2set-lookup-implies-nat2pair-lookup-converse/L
    N+FS'=>S' K'=>N+F' F'!<FS' FS'+F'=FS S'+K'=S K<-S (nat`eq?/no K'<>K)
    _ K=>N+F F<-FS
    <- nat`ne-symmetric K'<>K K<>K'
    <- set`add-preserves-member-converse K<-S S'+K'=S K<>K' K<-S'
    <- nat+set2set-lookup-implies-nat2pair-lookup-converse
      N+FS'=>S' K<-S' _ K=>N+F F<-FS'
    <- set`add-preserves-member F<-FS' FS'+F'=FS F<-FS.

- : nat+set2set-lookup-implies-nat2pair-lookup-converse
    (nat+set2set/U A0 P2N0 F0 U0 SU0) MB _ P2N MBF
    <- nat`eq?-total E?
    <- nat+set2set-lookup-implies-nat2pair-lookup-converse/L
      A0 P2N0 F0 U0 SU0 MB E? _ P2N MBF.

%worlds () (nat+set2set-lookup-implies-nat2pair-lookup-converse _ _ _ _ _)
  (nat+set2set-lookup-implies-nat2pair-lookup-converse/L _ _ _ _ _ _ _ _ _ _).
%total (A A0) (nat+set2set-lookup-implies-nat2pair-lookup-converse A _ _ _ _)
  (nat+set2set-lookup-implies-nat2pair-lookup-converse/L A0 _ _ _ _ _ _ _ _ _).


%theorem nat+set2set-preserves-size
  : forall* {S} {N} {Q} {K}
    forall {S+F=>Q: nat+set2set N S Q}
    {SZ: set`size S K}
    exists {QZ: set`size Q K}
    true.

- : nat+set2set-preserves-size nat+set2set/0 set`size/0 set`size/0.

- : nat+set2set-preserves-size (nat+set2set/U T R F U QU) SZ SZQ
    <- set`not-member-add-increases-size-converse SZ F U SZ'
    <- nat+set2set-preserves-size T SZ' SZQ'
    <- nat+set2set-preserves-fresh T F R QF
    <- set`not-member-add-increases-size SZQ' QF QU SZQ.

%worlds () (nat+set2set-preserves-size _ _ _).
%total (N) (nat+set2set-preserves-size N _ _).


%theorem nat+set2set-preserves-size-converse
  : forall* {S} {F} {Q} {N}
    forall {S+F=>Q: nat+set2set F S Q}
    {QZ: set`size Q N}
    exists {SZ: set`size S N}
    true.

- : nat+set2set-preserves-size-converse nat+set2set/0 set`size/0 set`size/0.

- : nat+set2set-preserves-size-converse
    (nat+set2set/U T R F U QU) SZQ SZ
    <- nat+set2set-preserves-fresh T F R QF
    <- set`not-member-add-increases-size-converse SZQ QF QU SZQ'
    <- nat+set2set-preserves-size-converse T SZQ' SZ'
    <- set`not-member-add-increases-size SZ' F U SZ.

%worlds () (nat+set2set-preserves-size-converse _ _ _).
%total (N) (nat+set2set-preserves-size-converse N _ _).


%theorem nat+set2set/U-inversion
  : forall* {N} {FS} {S} {FS'} {F}
    forall {N+FS=>S: nat+set2set N FS S}
    {NM: set`not-member FS' F}
    {AD: set`add FS' F FS}
    exists {S'} {N+FS'=>S': nat+set2set N FS' S'}
    {K} {K=>NF: nat2pair K (pair/ N F)}
    {S'+K=S: set`add S' K S}
    true.

%theorem nat+set2set/U-inversion/L
  : forall* {N} {FS} {S} {FS'} {F} {B} {FS0} {F0} {S0} {K0}
    forall {N+FS0=>S0: nat+set2set N FS0 S0}
    {NM0: set`not-member FS0 F0}
    {A0: set`add FS0 F0 FS}
    {AS0: set`add S0 K0 S}
    {K2NF0: nat2pair K0 (pair/ N F0)}
    {NM: set`not-member FS' F}
    {A: set`add FS' F FS}
    {E?: nat`eq? F F0 B}
    exists {S'} {N+FS'=>S': nat+set2set N FS' S'}
    {K} {K2NF: nat2pair K (pair/ N F)}
    {AS': set`add S' K S}
    true.

- : nat+set2set/U-inversion/L NSS0 F0 U0 SU0 K2NF0 F1 U1
    nat`eq?/yes %{=>}% _ NSS _ K2NF0 SU0
    <- set`not-member-add-cancels F0 U0 F1 U1 nat`eq/ set`eq/ (FS0=FS:set`eq FS0 FS)
    <- nat+set2set-respects-eq NSS0 nat`eq/ FS0=FS set`eq/ NSS.

- : nat+set2set/U-inversion/L NSS0 F0 U0 SU0 K2NF0 F1 U1
    (nat`eq?/no (F<>F0)) %{=>}% _
    (nat+set2set/U NSS K2NF0 F4 U4 SU2) _ K2NF SU3
    <- set`add-commutes-converse U1 U0 F<>F0 SP U4 U3
    <- set`add-preserves-not-member-converse F1 U4 F3
    <- set`add-preserves-not-member-converse F0 U3 F4
    <- nat+set2set/U-inversion NSS0 F3 U3 _ NSS _ K2NF SU
    <- pair2nat-preserves-ne* (natpair`ne/2 F<>F0) K2NF K2NF0 NE
    <- set`update-commutes SU SU0 NE _ SU2 SU3.

- : nat+set2set/U-inversion (nat+set2set/U NSS0 P2K0 F0 U0 SU0) F1 U1
    _ NSS1 _ P2K1 SU1
    <- nat`eq?-total E?
    <- nat+set2set/U-inversion/L NSS0 F0 U0 SU0 P2K0 F1 U1 E? _ NSS1 _ P2K1 SU1.

%worlds () (nat+set2set/U-inversion _ _ _ _ _ _ _ _)
  (nat+set2set/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N N0) (nat+set2set/U-inversion N _ _ _ _ _ _ _)
  (nat+set2set/U-inversion/L N0 _ _ _ _ _ _ _ _ _ _ _ _).


%theorem nat+set2set-unique
  : forall* {N} {FS} {N'} {FS'} {S} {S'}
    forall {N+FS=>S: nat+set2set N FS S}
    {N+FS=>S': nat+set2set N' FS' S'}
    {NE: nat`eq N N'} {SE: set`eq FS FS'}
    exists {SE: set`eq S S'}
    true.

- : nat+set2set-unique nat+set2set/0 nat+set2set/0 nat`eq/ set`eq/ set`eq/.

- : nat+set2set-unique (nat+set2set/U TP0 R0 F0 U0 QU0) T1 NE1 SE QE
    <- nat+set2set/U-inversion T1 F0 U0 _ TP1 _ R1 QU1
    <- nat+set2set-unique TP0 TP1 NE1 set`eq/ QEP
    <- pair2nat-unique R0 R1 natpair`eq/ NE
    <- set`add-unique QU0 QU1 QEP NE QE.

%worlds () (nat+set2set-unique _ _ _ _ _).
%total (N) (nat+set2set-unique N _ _ _ _).


%theorem nat+set2set/UP-inversion
  : forall* {N} {FS} {S} {SP} {K}
    forall {N+FS=>S: nat+set2set N FS S}
    {NM: set`not-member SP K}
    {A: set`add SP K S}
    exists {FSP} {N+FSP=>SP: nat+set2set N FSP SP}
    {F} {K=>N+F: nat2pair K (pair/ N F)}
    {U: set`add FSP F FS}
    true.

- : nat+set2set/UP-inversion N+FS=>S K!<SP SP+K=S %{=>}%
    _ N+FS'=>SP _ K=>N+F FS'+F=FS
    <- set`add-implies-member SP+K=S K<-S
    <- nat+set2set-lookup-implies-nat2pair-lookup-converse
      N+FS=>S K<-S _ K=>N+F F<-FS
    <- set`member-implies-not-member-add F<-FS FS' F!<FS' FS'+F=FS
    <- nat+set2set/U-inversion N+FS=>S F!<FS' FS'+F=FS S' N+FS'=>S' K'
      K'=>N+F S'+K'=S
    <- pair2nat-unique K'=>N+F K=>N+F natpair`eq/ (K'=K:nat`eq K' K)
    <- nat+set2set-preserves-fresh N+FS'=>S' F!<FS' K'=>N+F K'!<S'
    <- set`not-member-add-cancels K'!<S' S'+K'=S K!<SP SP+K=S K'=K set`eq/ S'=SP
    <- nat+set2set-respects-eq N+FS'=>S' nat`eq/ set`eq/ S'=SP N+FS'=>SP.

%worlds () (nat+set2set/UP-inversion _ _ _ _ _ _ _ _).
%total { } (nat+set2set/UP-inversion _ _ _ _ _ _ _ _).


% 3. set+set2set

%theorem set+set2set-respects-eq
  : forall* {S} {FS} {Q} {S'} {FS'} {Q'}
    forall {T: set+set2set S FS Q}
    {SE: set`eq S S'} {FSE: set`eq FS FS'}
    {QE: set`eq Q Q'}
    exists {T': set+set2set S' FS' Q'}
    true.

- : set+set2set-respects-eq T set`eq/ set`eq/ set`eq/ T.

%worlds () (set+set2set-respects-eq _ _ _ _ _).
%total {} (set+set2set-respects-eq _ _ _ _ _).


%theorem set+set2set/U-inversion
  : forall* {S} {FS} {SP} {N} {Q}
    forall {S+FS=>Q: set+set2set S FS Q}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    exists {QP} {SP+FS=>QP: set+set2set SP FS QP}
    {R} {N+FS=>R: nat+set2set N FS R}
    {U: set`union QP R Q}
    true.

%theorem set+set2set/U-inversion/L
  : forall* {S} {FS} {SP} {SP0} {N} {N0} {QP0} {R0} {Q} {B}
    forall {SP0+FS=>QP: set+set2set SP0 FS QP0}
    {N0+FS=>R0: nat+set2set N0 FS R0}
    {NM0: set`not-member SP0 N0}
    {AD0: set`add SP0 N0 S}
    {U: set`union QP0 R0 Q}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    {E?: nat`eq? N N0 B}
    exists {QP} {SP+FS=>QP: set+set2set SP FS QP}
    {R} {N+FS=>R: nat+set2set N FS R}
    {U: set`union QP R Q}
    true.

- : set+set2set/U-inversion/L
    SP0+FS=>QP0 N0+FS=>R0 N0!<SP0 SP0+N0=S QP0+R0=Q N!<SP SP+N=S nat`eq?/yes
    QP0 SP+FS=>QP0 R0 N0+FS=>R0 QP0+R0=Q
    <- set`not-member-add-cancels N0!<SP0 SP0+N0=S N!<SP SP+N=S nat`eq/
      set`eq/ SP0=SP
    <- set+set2set-respects-eq SP0+FS=>QP0 SP0=SP set`eq/ set`eq/ SP+FS=>QP0.

- : set+set2set/U-inversion/L
    SP0+FS=>QP0 N0+FS=>R0 N0!<SP0 SP0+N0=S QP0+R0=Q N!<SP SP+N=S
    (nat`eq?/no N<>N0) _
    (set+set2set/U SP1+FS=>QP1 N0+FS=>R0 N0!<SP1 SP1+N0=SP QP1+R0=QP2)
    R N+FS=>R QP2+R=Q
    <- set`add-commutes-converse SP+N=S SP0+N0=S N<>N0 SP1 SP1+N0=SP SP1+N=SP0
    <- set`add-preserves-not-member-converse N!<SP SP1+N0=SP N!<SP1
    <- set`add-preserves-not-member-converse N0!<SP0 SP1+N=SP0 N0!<SP1
    <- set+set2set/U-inversion SP0+FS=>QP0 N!<SP1 SP1+N=SP0 QP1
      SP1+FS=>QP1 R N+FS=>R QP1+R=QP0
    <- set`union-commutative QP1+R=QP0 R+QP1=QP0
    <- set`union-commutative QP0+R0=Q R0+QP0=Q
    <- set`union-associative-converse QP1+R=QP0 R0+QP0=Q QP2 R0+QP1=QP2 QP2+R=Q
    <- set`union-commutative R0+QP1=QP2 QP1+R0=QP2.

- : set+set2set/U-inversion
    (set+set2set/U SP0+FS=>QP0 N0+FS=>R0 N0!<SP0 SP0+N0=S QP0+R0=Q)
    N!<SP SP+N=S _ SP+FS=>QP _ N+FS=>R QP+R=Q
    <- nat`eq?-total N=N0?
    <- set+set2set/U-inversion/L SP0+FS=>QP0 N0+FS=>R0 N0!<SP0 SP0+N0=S QP0+R0=Q
      N!<SP SP+N=S N=N0? _ SP+FS=>QP _ N+FS=>R QP+R=Q.

%worlds () (set+set2set/U-inversion _ _ _ _ _ _ _ _)
	(set+set2set/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A0 A1) (set+set2set/U-inversion A0 _ _ _ _ _ _ _)
	(set+set2set/U-inversion/L A1 _ _ _ _ _ _ _ _ _ _ _ _).


%theorem set+set2set-unique
  : forall* {S} {FS} {Q} {S'} {FS'} {Q'}
    forall {T: set+set2set S FS Q}
    {T': set+set2set S' FS' Q'}
    {SE: set`eq S S'} {FSE: set`eq FS FS'}
    exists {QE: set`eq Q Q'}
    true.

- : set+set2set-unique set+set2set/0 set+set2set/0 set`eq/ set`eq/ set`eq/.

- : set+set2set-unique (set+set2set/U TP0 NT0 F0 U0 QU0) T1 SE FSE QE
    <- set+set2set/U-inversion T1 F0 U0 _ TP1 _ NT1 QU1
    <- set+set2set-unique TP0 TP1 set`eq/ FSE QEP
    <- nat+set2set-unique NT0 NT1 nat`eq/ FSE RE
    <- set`union-unique QU0 QU1 QEP RE QE.

%worlds () (set+set2set-unique _ _ _ _ _).
%total (T) (set+set2set-unique T _ _ _ _).


%theorem set+set2set-on-empty-set
  : forall* {FS} exists {T: set+set2set set/0 FS set/0} true.

- : set+set2set-on-empty-set set+set2set/0.

%worlds () (set+set2set-on-empty-set _).
%total {} (set+set2set-on-empty-set _).


%theorem set+set2set-lookup-implies-nat2pair
  : forall* {S} {FS} {S2} {K}
    forall {S+FS=>S2: set+set2set S FS S2}
    {L: set`member S2 K}
    exists {N} {F} {L: set`member S N}
    {L: set`member FS F}
    {K=>NF: nat2pair K (pair/ N F)}
    true.

%theorem set+set2set-lookup-implies-nat2pair/L
  : forall* {SP} {FS} {QP} {N0} {R} {S} {Q} {K} {B}
    forall {SP+FS=>QP: set+set2set SP FS QP}
    {N+FS=>R: nat+set2set N0 FS R}
    {NM: set`not-member SP N0}
    {AD: set`add SP N0 S}
    {U: set`union QP R Q}
    {MB: set`member Q K}
    {MB?: set`member? R K B}
    exists {N} {F} {MB: set`member S N}
    {MB: set`member FS F}
    {K=>NF: nat2pair K (pair/ N F)}
    true.

- : set+set2set-lookup-implies-nat2pair/L
    SP+FS=>QP N0+FS=>R N0!<SP SP+N0=S QP+R=Q K<-Q (set`member?/in K<-R)
    N0 _ N0<-S F<-FS K=>N0+F
    <- set`member-implies-not-member-add K<-R RP K!<RP RP+K=R
    <- nat+set2set/UP-inversion N0+FS=>R K!<RP RP+K=R FSP N0+FSP=>RP F K=>N0+F FSP+F=FS
    <- set`add-implies-member SP+N0=S N0<-S
    <- set`add-implies-member FSP+F=FS F<-FS.

- : set+set2set-lookup-implies-nat2pair/L
    SP+FS=>QP N0+FS=>R N0!<SP SP+N0=S QP+R=Q K<-Q (set`member?/out K!<R)
    _ _ N<-S F<-FS K=>N+F
    <- set`not-member-union-right-preserves-member-converse
      K<-Q K!<R QP+R=Q K<-QP
    <- set+set2set-lookup-implies-nat2pair SP+FS=>QP K<-QP _ _ N<-SP
      F<-FS K=>N+F
    <- set`add-preserves-member N<-SP SP+N0=S N<-S.

- : set+set2set-lookup-implies-nat2pair
    (set+set2set/U SP+FS=>QP N+FS=>R N!<SP SP+N=S QP+R=Q) K<-Q
    _ _ N<-S F<-FS K=>N+F
    <- set`member?-total K<-R?
    <- set+set2set-lookup-implies-nat2pair/L SP+FS=>QP N+FS=>R N!<SP SP+N=S QP+R=Q
      K<-Q K<-R? _ _ N<-S F<-FS K=>N+F.

%worlds () (set+set2set-lookup-implies-nat2pair _ _ _ _ _ _ _)
	(set+set2set-lookup-implies-nat2pair/L _ _ _ _ _ _ _ _ _ _ _ _).
%total (A0 A1) (set+set2set-lookup-implies-nat2pair A0 _ _ _ _ _ _)
	(set+set2set-lookup-implies-nat2pair/L A1 _ _ _ _ _ _ _ _ _ _ _).


%%% 3, theorems about nat+map2map

%theorem nat+map2map-total*
  : forall {N} {XMin}
    exists {XMout} {N+XMin=>XMout: nat+map2map N XMin XMout} true.

%worlds () (nat+map2map-total* _ _ _ _).
%trustme %total {} (nat+map2map-total* _ _ _ _).


%theorem nat+map2map/U-inversion
  : forall* {N} {F} {X} {XMin} {XMin'} {XMout}
    forall {N+XMin=>XMout: nat+map2map N XMin XMout}
    {FS: efxmap`fresh XMin' F}
    {UD: efxmap`update XMin' F X XMin}
    exists {XMout'} {N+XMin'=>XMout': nat+map2map N XMin' XMout'}
    {K} {N+F=>K: pair2nat (pair/ N F) K}
    {UD: efxmap`update XMout' K X XMout}
    true.

%worlds () (nat+map2map/U-inversion _ _ _ _ _ _ _ _).
%trustme %total {} (nat+map2map/U-inversion _ _ _ _ _ _ _ _).


%theorem nat+map2map/UP-inversion
  : forall* {N} {K} {X} {XMin} {XMout} {XMout'}
    forall {N+XMin=>XMout: nat+map2map N XMin XMout}
    {FS: efxmap`fresh XMout' K}
    {UD: efxmap`update XMout' K X XMin}
    exists {XMin'} {N+XMin'=>XMout': nat+map2map N XMin' XMout'}
    {F} {N+F=>K: pair2nat (pair/ N F) K}
    {UD: efxmap`update XMin' F X XMin}
    true.

%worlds () (nat+map2map/UP-inversion _ _ _ _ _ _ _ _).
%trustme %total {} (nat+map2map/UP-inversion _ _ _ _ _ _ _ _).


%theorem nat+map2map-unique
  : forall* {N} {XMin} {XMout} {N'} {XMin'} {XMout'}
    forall {N+XMin=>XMout: nat+map2map N XMin XMout}
    {N'+XMin'=>XMout': nat+map2map N' XMin' XMout'}
    {N=N': nat`eq N N'} {XMin=XMin': efxmap`eq XMin XMin'}
    exists {XMout=XMout': efxmap`eq XMout XMout'}
    true.

%worlds () (nat+map2map-unique _ _ _ _ _).
%trustme %total {} (nat+map2map-unique _ _ _ _ _).


%theorem nat+map2map-preserves-fresh
  : forall* {N} {F} {K} {XMin} {XMout}
    forall {N+XMin=>XMout: nat+map2map N XMin XMout}
    {FS: efxmap`fresh XMin F}
    {N+F=>K: pair2nat (pair/ N F) K}
    exists {FS: efxmap`fresh XMout K}
    true.

- : nat+map2map-preserves-fresh nat+map2map/0
    efxmap`fresh/0 _ efxmap`fresh/0.


%theorem nat+map2map-preserves-fresh/L
  : forall* {N} {F} {F'} {K} {K'} {X} {XMin} {XMin'} {XMout} {XMout'} {B}
    forall {N+XMin'=>XMout': nat+map2map N XMin' XMout'}
    {N+F'=>K': pair2nat (pair/ N F') K'}
    {FS': efxmap`fresh XMin' F'}
    {UD: efxmap`update XMin' F' X XMin}
    {UD: efxmap`update XMout' K' X XMout}
    {FS: efxmap`fresh XMin F}
    {N+F=>K: pair2nat (pair/ N F) K}
    {E?: nat`eq? F F' B}
    exists {NM: efxmap`fresh XMout K}
    true.

- : nat+map2map-preserves-fresh/L _ _ _ UP _ NM _ nat`eq?/yes NMQ
    <- efxmap`update-implies-lookup UP MB
    <- efxmap`fresh-lookup-not-equal NM MB N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- efxmap`false-implies-fresh V NMQ.

- : nat+map2map-preserves-fresh/L SP+F=>QP NP+F=>KP _
    SP+NP=S QP+KP=Q N!<S N+F=>K (nat`eq?/no N<>NP) K!<Q
    <- efxmap`update-preserves-fresh-converse N!<S SP+NP=S N!<SP
    <- nat+map2map-preserves-fresh SP+F=>QP N!<SP N+F=>K K!<QP
    <- pair2nat-preserves-ne* (natpair`ne/2 N<>NP) N+F=>K NP+F=>KP K<>KP
    <- efxmap`update-preserves-fresh K!<QP QP+KP=Q K<>KP K!<Q.

- : nat+map2map-preserves-fresh
    (nat+map2map/U SP+F=>QP NP+F=>KP NMP UP UQ) NM N+F=>K NMQ
    <- nat`eq?-total E?
    <- nat+map2map-preserves-fresh/L SP+F=>QP NP+F=>KP NMP UP UQ NM N+F=>K E? NMQ.

%worlds () (nat+map2map-preserves-fresh _ _ _ _)
	(nat+map2map-preserves-fresh/L _ _ _ _ _ _ _ _ _).
%trustme %total (T1 T2) (nat+map2map-preserves-fresh T1 _ _ _)
	(nat+map2map-preserves-fresh/L T2 _ _ _ _ _ _ _ _).


%theorem nat+map2map-preserves-size
  : forall* {N} {K} {XMin} {XMout}
    forall {N+XMin=>XMout: nat+map2map N XMin XMout}
    {SZ: efxmap`size XMin K}
    exists {SZ: efxmap`size XMout K}
    true.

%worlds () (nat+map2map-preserves-size _ _ _).
%trustme %total {} (nat+map2map-preserves-size _ _ _).


%theorem nat+map2map-preserves-size-converse
  : forall* {N} {K} {XMin} {XMout}
    forall {N+XMin=>XMout: nat+map2map N XMin XMout}
    {SZ: efxmap`size XMout K}
    exists {SZ: efxmap`size XMin K}
    true.

%worlds () (nat+map2map-preserves-size-converse _ _ _).
%trustme %total {} (nat+map2map-preserves-size-converse _ _ _).


%%% 4, theorems about set+map2map

%theorem set+map2map-respects-eq
  : forall* {S} {S'} {XMin} {XMin'} {XMout} {XMout'}
    forall {S+XMin=>XMout: set+map2map S XMin XMout}
    {SE: set`eq S S'} {XME: efxmap`eq XMin XMin'}
    {XME: efxmap`eq XMout XMout'}
    exists {S'+XMin'=>XMout': set+map2map S' XMin' XMout'}
    true.

- : set+map2map-respects-eq T set`eq/ efxmap`eq/ efxmap`eq/ T.

%worlds () (set+map2map-respects-eq _ _ _ _ _).
%total {} (set+map2map-respects-eq _ _ _ _ _).


%theorem set+map2map/U-inversion
  : forall* {S} {S'} {XMin} {N} {XMout}
    forall {S+XMin=>XMout: set+map2map S XMin XMout}
    {NM: set`not-member S' N}
    {A: set`add S' N S}
    exists {XMout1} {S'+XMin=>XMout1: set+map2map S' XMin XMout1}
    {XMout2} {N+XMin=>XMout2: nat+map2map N XMin XMout2}
    {J: efxmap`join XMout1 XMout2 XMout}
    true.

%worlds () (set+map2map/U-inversion _ _ _ _ _ _ _ _).
%trustme %total {} (set+map2map/U-inversion _ _ _ _ _ _ _ _).


%theorem set+map2map-unique
  : forall* {S} {XMin} {XMout} {S'} {XMin'} {XMout'}
    forall {T: set+map2map S XMin XMout}
    {T': set+map2map S' XMin' XMout'}
    {SE: set`eq S S'} {XME: efxmap`eq XMin XMin'}
    exists {XME: efxmap`eq XMout XMout'}
    true.

%worlds () (set+map2map-unique _ _ _ _ _).
%trustme %total {} (set+map2map-unique _ _ _ _ _).


%theorem set+map2map-on-empty-set
  : forall* {XMin} exists {T: set+map2map set/0 XMin efxmap/0} true.

- : set+map2map-on-empty-set set+map2map/0.

%worlds () (set+map2map-on-empty-set _).
%total {} (set+map2map-on-empty-set _).


%theorem set+map2map-lookup-implies-nat2pair
  : forall* {S} {XMin} {XMout} {K} {X}
    forall {S+XMin=>XMout: set+map2map S XMin XMout}
    {L: efxmap`lookup XMout K X}
    exists {N} {F} {L: set`member S N}
    {L: efxmap`lookup XMin F X}
    {K=>NF: nat2pair K (pair/ N F)}
    true.

%worlds () (set+map2map-lookup-implies-nat2pair _ _ _ _ _ _ _).
%trustme %total {} (set+map2map-lookup-implies-nat2pair _ _ _ _ _ _ _).


%theorem nat+map2map-implies-nat+set2set
  : forall* {N} {XMin} {XMout} {S} {Sout}
    forall {N+XMin=>XMout: nat+map2map N XMin XMout}
    {DM-XMin=FS: efxmap`domain XMin S}
    {DM-XMout=Sout: efxmap`domain XMout Sout}
    exists {FS+N=Sout: nat+set2set N S Sout}
    true.

- : nat+map2map-implies-nat+set2set nat+map2map/0 _ _ nat+set2set/0.

- : nat+map2map-implies-nat+set2set
    (nat+map2map/U N+XMin'=>XMout' N+F=>K F!<XMin'
      XMin'+F+X=XMin XMout'+K+X=XMout)
    (DM-XMin=S:efxmap`domain XMin S) (DM-XMout=Sout:efxmap`domain XMout Sout)
    (nat+set2set/U N+S'=>Sout' N+F=>K F!<S' S'+F=S Sout'+K=Sout)
    <- efxmap`domain-total DM-XMin'=S'
    <- efxmap`domain-total DM-XMout'=Sout'
    <- nat+map2map-implies-nat+set2set N+XMin'=>XMout'
      DM-XMin'=S' DM-XMout'=Sout' N+S'=>Sout'
    <- efxmap`domain-preserves-fresh F!<XMin' DM-XMin'=S' F!<S'
    <- efxmap`update-commute-domain XMin'+F+X=XMin DM-XMin'=S' DM-XMin=S S'+F=S
    <- efxmap`update-commute-domain XMout'+K+X=XMout DM-XMout'=Sout'
      DM-XMout=Sout Sout'+K=Sout.

%worlds () (nat+map2map-implies-nat+set2set _ _ _ _).
%total (T) (nat+map2map-implies-nat+set2set T _ _ _).


%theorem set+map2map-implies-set+set2set
  : forall* {S} {XMin} {XMout} {FS} {Sout}
    forall {S+XMin=>XMout: set+map2map S XMin XMout}
    {DM-XMin: efxmap`domain XMin FS}
    {DM-XMout: efxmap`domain XMout Sout}
    exists {S+Sin=>Sout: set+set2set S FS Sout}
    true.

- : set+map2map-implies-set+set2set set+map2map/0 _ _ set+set2set/0.

- : set+map2map-implies-set+set2set
    (set+map2map/U S'+XMin=>XMout1 N+XMin=>XMout2 N!<S' S'+N=S
      XMout1+XMout2=XMout) (DM-XMin=FS:efxmap`domain XMin FS)
    (DM-XMout=Sout:efxmap`domain XMout Sout)
    (set+set2set/U (S'+FS=>Sout1:set+set2set S' FS Sout1)
      N+FS=>Sout2 N!<S' S'+N=S Sout1+Sout2=Sout)
    <- efxmap`domain-total DM-XMout1=Sout1
    <- efxmap`domain-total DM-XMout2=Sout2
    <- set+map2map-implies-set+set2set
      S'+XMin=>XMout1 DM-XMin=FS DM-XMout1=Sout1 S'+FS=>Sout1
    <- nat+map2map-implies-nat+set2set
      N+XMin=>XMout2 DM-XMin=FS DM-XMout2=Sout2 N+FS=>Sout2
    <- efxmap`join-commute-domain XMout1+XMout2=XMout DM-XMout1=Sout1
      DM-XMout2=Sout2 DM-XMout=Sout Sout1+Sout2=Sout.

%worlds () (set+map2map-implies-set+set2set _ _ _ _).
%total (T) (set+map2map-implies-set+set2set T _ _ _).