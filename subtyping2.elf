% Subtyping Rules


%%% Definitions

%% We use a special natural number z to represent the special
%% shared target: world.all. There's a one-to-one mapping between
%% z and (pair/ z z).

%abbrev shared-tgt : nat = nat`z.


% Consider field annotation, and returns either the input unique
% targets, or a shared targets. (no borrowed targets since field
% cannot be borrowed).

consider-ftype : targets -> annot -> targets -> type.

consider-ftype/shared : consider-ftype _ annot/shared targets/shared.

consider-ftype/unique : consider-ftype G annot/unique G.


make-tgts-and-caps : targets -> nat -> cap -> targets -> capmap -> type.

make-tgts-and-caps/shared
  : make-tgts-and-caps targets/shared _ X
    (targets/unique set/0 (set/1 shared-tgt)) (capmap/1 shared-tgt X).

make-tgts-and-caps/unique
  : set+nat2set OS F FS2
    -> set`disjoint FS FS2
    -> set`union FS FS2 FS3
    -> set2capmap FS3 X M
    -> make-tgts-and-caps (targets/unique OS FS) F X (targets/unique set/0 FS3) M.


%% Convert an object target set into a field target set, which
%% includes ALL fields of all object target.

objset2fldset : clsmap -> cxt -> set -> set -> type.

objset2fldset/0 : objset2fldset _ _ set/0 set/0.

objset2fldset/U
  : objset2fldset CM B OSP SP
    -> cxt`lookup B N (cxt-info/ _ (ty/ _ _ C))
    -> clsmap`lookup CM C FM
    -> fldmap`domain FM FS
    -> nat+set2set N FS R
    -> set`union SP R S
    -> set`not-member OSP N
    -> set`add OSP N OS
    -> objset2fldset CM B OS S.


%%% Converting between ty and reftype

ty2reftype : nat -> ty -> reftype -> type.

ty2reftype/shared
  : ty2reftype L (ty/ NN annot/shared C) (reftype/ NN C targets/shared).

ty2reftype/borrow
  : ty2reftype L (ty/ NN annot/borrow C)
    (reftype/ NN C (targets/unique (set/1 L) set/0)).

% ty2reftype/null : ty2reftype _ ty/null reftype/null.


reftype2ty : reftype -> ty -> type.

reftype2ty/shared
  : reftype2ty (reftype/ NN C targets/shared)
    (ty/ NN annot/shared C).

%% TODO: maybe annot/borrow more making sense?
reftype2ty/unique
  : reftype2ty (reftype/ NN C (targets/unique _ _))
    (ty/ NN annot/unique C).

% reftype2ty/null : reftype2ty reftype/null ty/null.


% Compatible : whether (encumbered) targets are compatible
% with the forthcoming effects.

% compatible : clsmap -> cxt -> targets -> effects -> type.

%{ this is rather restrictive: it means once we "hold on"
a unique field from a shared object, we cannot have any
effect on shared, until we release the unique field. For instance,
  (if true a else s).u1 = s.u2 is not allowed. This is caused by
the way we converting permissions - we make the result permission
to be *encumbered* BOTH in permission for a and permission for s
(shared permission). The fix is to replace the encumber permission
for shared with a nesting fact, and then delay the encumber
to later stage. However, at this time it turns out too much change
is required, so we left it to be fixed later.

Update: we need to restrict the occurrences of OS in effects too.
In case we have expression: let x = a in (a.f = 3; x.f = 4; x)
we would first convert the output of "x = a" into a certain format
where "x.f" is already carved from the permissions. Thus, when
checking "a.f = 3", we don't have permission for "a.f" since it's
already in the encumbered part.

We can get the permission for "a.f" by first using linear modus-ponens
to restore the permission for "a.f" and then get the permission for
"x.f" again when starting to check "x.f". However, this cannot
be implemented in the current system.

In order to implement this, we might need to change the way input
permission is generated. Instead of requiring the permissions for
"x", it should require the permissions where "x" will come from.
In this way, we only do carving whenever needed. This may be done
by binding "x" with all the targets & effects it came from, but this
requires a big surgery on the current context definition.

FUTURE WORK: fix compatible/shared.
FUTURE WORK: better/less restrictive compatible/unique
}%

%{
compatible/shared : set`not-member S shared-tgt
                    -> compatible _ _ targets/shared (effects/ _ S Q).

compatible/unique : capmap`domain M R
                    -> set`disjoint FS R
                    -> set`disjoint FS S
                    -> objset2fldset CM B Q FS2
                    -> set`disjoint FS FS2
                    -> compatible CM B (targets/unique OS FS) (effects/ M S Q).
}%


% sub-annotation rule with side effects.
% `targets`: the targets on the LHS
% `capmap`: the declared effects, only nonempty useful when checking parameters
% `set`: the field set on LHS, used when consuming a whole object
% `annot`: the annotation on the RHS
% `effects`: the result effects
sub-annot-efx : targets -> efxmap -> set -> annot -> effects -> type.

sub-annot-efx/consume
  : sub-annot-efx (targets/unique G1 G2) _ FS A (effects/ efxmap/0 G2 G1)
    <- not-borrowed A.

sub-annot-efx/unique2borrow
  : sub-annot-efx (targets/unique G1 G2) XMd
    _ annot/borrow (effects/ XM set/0 set/0)
    <- set+map2map G1 XMd XM1
    <- efxmap-max-efx XMd X
    <- set2efxmap G2 X XM2
    <- efxmap`join XM1 XM2 XM.

sub-annot-efx/shared2borrow
 : sub-annot-efx targets/shared XMd _ annot/borrow
   (effects/ (efxmap/+ shared-tgt X efxmap/0) set/0 set/0)
   <- efxmap-max-efx XMd X.

sub-annot-efx/shared2shared
  : sub-annot-efx targets/shared efxmap/0 _ annot/shared no-effect.


%abbrev sub-nonnull : nn -> nn -> type = [NN1][NN2] nonnull`leq NN2 NN1.

%abbrev sub-annot : annot -> annot -> type = [A1][A2] annot`leq A2 A1.


% The two sets are read and write fields respectively.

subtype : clsmap -> reftype -> ty -> efxmap -> effects -> type.

subtype/ : subtype CM (reftype/ NN1 C1 GS) (ty/ NN2 A2 C2) XM XX
           <- nat`eq C1 C2
           <- sub-nonnull NN1 NN2
           <- clsmap`lookup CM C1 FM
           <- fldmap`domain FM FS
           <- efxmap`domain XM XS
           <- set`leq XS FS
           <- sub-annot-efx GS XM FS A2 XX.

subtype/null : subtype _ reftype/null ty/null _ no-effect.

subtype/maynull : subtype _ reftype/null (ty/ nn/may _ _) _ no-effect.