%%% Effects generated by type checking
%%% $Id$

%%% Definitions


%%% 1, shared efx

shared-efx : type. %name shared-efx SX.

shared-efx/none : shared-efx.

shared-efx/read : shared-efx.

shared-efx/write : shared-efx.


% equality

shared-efx`eq : shared-efx -> shared-efx -> type.

shared-efx`eq/ : shared-efx`eq SX SX.


% join operation

shared-efx`join : shared-efx -> shared-efx -> shared-efx -> type.

shared-efx`join/L : shared-efx`join shared-efx/none SX SX.

shared-efx`join/R : shared-efx`join SX shared-efx/none SX.

shared-efx`join/1
  : shared-efx`join shared-efx/read shared-efx/read shared-efx/read.

shared-efx`join/2
  : shared-efx`join shared-efx/read shared-efx/write shared-efx/write.

shared-efx`join/3
  : shared-efx`join shared-efx/write shared-efx/read shared-efx/write.

shared-efx`join/4
  : shared-efx`join shared-efx/write shared-efx/write shared-efx/write.


% less-equal

shared-efx`leq : shared-efx -> shared-efx -> type.

shared-efx`leq/1 : shared-efx`leq shared-efx/none _.

shared-efx`leq/2 : shared-efx`leq shared-efx/read shared-efx/read.

shared-efx`leq/3 : shared-efx`leq shared-efx/read shared-efx/write.

shared-efx`leq/4 : shared-efx`leq shared-efx/write shared-efx/write.


% disjoint

shared-efx`disjoint : shared-efx -> shared-efx -> type.

shared-efx`disjoint/L : shared-efx`disjoint shared-efx/none _.

shared-efx`disjoint/R : shared-efx`disjoint _ shared-efx/none.


% We need to convert shared-efx to efx so as to get a fraction.

shared-efx2efx : shared-efx -> efx -> type.

shared-efx2efx/read : shared-efx2efx shared-efx/read efx/read.

shared-efx2efx/write : shared-efx2efx shared-efx/write efx/write.



% 2, effects generated by checking a term

effects : type. %name effects XX.

effects/ : efxmap -> shared-efx -> effects.

%abbrev no-effect = effects/ efxmap/0 shared-efx/none.


% equality

effects`eq : effects -> effects -> type.

effects`eq/ : effects`eq XX XX.


% join operation on effects

effects`join : effects -> effects -> effects -> type.

effects`join/
  : effects`join (effects/ M1 X1) (effects/ M2 X2) (effects/ M X)
    <- efxmap`join M1 M2 M
    <- shared-efx`join X1 X2 X.


% less-equal on effects

effects`leq : effects -> effects -> type.

effects`leq/
  : effects`leq (effects/ M1 X1) (effects/ M2 X2)
    <- efxmap`leq M1 M2
    <- shared-efx`leq X1 X2.


% disjoint

effects`disjoint : effects -> effects -> type.

effects`disjoint/
  : effects`disjoint (effects/ M1 X1) (effects/ M2 X2)
    <- efxmap`disjoint M1 M2
    <- shared-efx`disjoint X1 X2.


effects`no-consume : effects -> type.

effects`no-consume/
  : effects`no-consume (effects/ M _)
    <- efxmap`no-consume M.

%%% Theorems

%theorem shared-efx`join-unique
  : forall* {SX1} {SX2} {SX1'} {SX2'} {SX} {SX'}
    forall {J: shared-efx`join SX1 SX2 SX}
    {J': shared-efx`join SX1' SX2' SX'}
    {E1: shared-efx`eq SX1 SX1'} {E2: shared-efx`eq SX2 SX2'}
    exists {E: shared-efx`eq SX SX'}
    true.

- : shared-efx`join-unique J J shared-efx`eq/ shared-efx`eq/ shared-efx`eq/.

- : shared-efx`join-unique shared-efx`join/L shared-efx`join/R
    shared-efx`eq/ shared-efx`eq/ shared-efx`eq/.

- : shared-efx`join-unique shared-efx`join/R shared-efx`join/L
    shared-efx`eq/ shared-efx`eq/ shared-efx`eq/.

%worlds () (shared-efx`join-unique _ _ _ _ _).
%total {} (shared-efx`join-unique _ _ _ _ _).


%theorem shared-efx`join-implies-leq
  : forall* {SX1} {SX2} {SX}
    forall {J: shared-efx`join SX1 SX2 SX}
    exists {L1: shared-efx`leq SX1 SX}
    {L2: shared-efx`leq SX2 SX}
    true.

%worlds () (shared-efx`join-implies-leq _ _ _).
%trustme %total {} (shared-efx`join-implies-leq _ _ _).


%theorem shared-efx`leq-transitive
  : forall* {SX1} {SX2} {SX3}
    forall {SX1<=SX2: shared-efx`leq SX1 SX2}
    {SX2<=SX3: shared-efx`leq SX2 SX3}
    exists {SX1<=SX3: shared-efx`leq SX1 SX3}
    true.

%worlds () (shared-efx`leq-transitive _ _ _).
%trustme %total {} (shared-efx`leq-transitive _ _ _).


%theorem shared-efx`join-commutative
  : forall* {SX1} {SX2} {SX}
    forall {J: shared-efx`join SX1 SX2 SX}
    exists {J: shared-efx`join SX2 SX1 SX}
    true.

%worlds () (shared-efx`join-commutative _ _).
%trustme %total {} (shared-efx`join-commutative _ _).


%theorem shared-efx`join-associative
  : forall* {SX1} {SX2} {SX3} {SX4} {SX5}
    forall {SX1+SX2=SX3: shared-efx`join SX1 SX2 SX3}
    {SX3+SX4=SX5: shared-efx`join SX3 SX4 SX5}
    exists {SX6} {SX2+SX4=SX6: shared-efx`join SX2 SX4 SX6}
    {SX1+SX6=SX5: shared-efx`join SX1 SX6 SX5}
    true.

%worlds () (shared-efx`join-associative _ _ _ _ _).
%trustme %total {} (shared-efx`join-associative _ _ _ _ _).


%theorem shared-efx`join-associative-converse
  : forall* {SX1} {SX2} {SX6} {SX4} {SX5}
    forall {SX2+SX4=SX6: shared-efx`join SX2 SX4 SX6}
    {SX1+SX6=SX5: shared-efx`join SX1 SX6 SX5}
    exists {SX3} {SX1+SX2=SX3: shared-efx`join SX1 SX2 SX3}
    {SX3+SX4=SX5: shared-efx`join SX3 SX4 SX5}
    true.

%worlds () (shared-efx`join-associative-converse _ _ _ _ _).
%trustme %total {} (shared-efx`join-associative-converse _ _ _ _ _).


%theorem shared-efx`disjoint-symmetric
  : forall* {X1} {X2}
    forall {D: shared-efx`disjoint X1 X2}
    exists {D: shared-efx`disjoint X2 X1}
    true.

- : shared-efx`disjoint-symmetric shared-efx`disjoint/L shared-efx`disjoint/R.

- : shared-efx`disjoint-symmetric shared-efx`disjoint/R shared-efx`disjoint/L.

%worlds () (shared-efx`disjoint-symmetric _ _).
%total {} (shared-efx`disjoint-symmetric _ _).


%theorem shared-efx2efx-not-consume
  : forall* {SX} {X}
    forall {SX=>X: shared-efx2efx SX X}
    exists {NC-X: efx`is-consume? X false}
    true.

- : shared-efx2efx-not-consume shared-efx2efx/read efx`is-consume?/read.

- : shared-efx2efx-not-consume shared-efx2efx/write efx`is-consume?/write.

%worlds () (shared-efx2efx-not-consume _ _).
%total {} (shared-efx2efx-not-consume _ _).



%%% Theorems about effects

%theorem effects`eq-inversion
  : forall* {M1} {M2} {X1} {X2}
    forall {E: effects`eq (effects/ M1 X1) (effects/ M2 X2)}
    exists {E: efxmap`eq M1 M2} {E: shared-efx`eq X1 X2}
    true.

- : effects`eq-inversion effects`eq/ efxmap`eq/ shared-efx`eq/.

%worlds () (effects`eq-inversion _ _ _).
%total {} (effects`eq-inversion _ _ _).


%theorem effects/-preserves-eq
  : forall* {M} {M'} {X} {X'}
    forall {ME: efxmap`eq M M'} {XE: shared-efx`eq X X'}
    exists {E: effects`eq (effects/ M X) (effects/ M' X')}
    true.

- : effects/-preserves-eq efxmap`eq/ shared-efx`eq/ effects`eq/.

%worlds () (effects/-preserves-eq _ _ _).
%total {} (effects/-preserves-eq _ _ _).


%theorem effects`join-unique
  : forall* {XX1} {XX1'} {XX2} {XX2'} {XX} {XX'}
    forall {J: effects`join XX1 XX2 XX}
    {J': effects`join XX1' XX2' XX'}
    {E: effects`eq XX1 XX1'} {E: effects`eq XX2 XX2'}
    exists {E: effects`eq XX XX'}
    true.

- : effects`join-unique (effects`join/ XJ MJ) (effects`join/ XJ' MJ') E1 E2 E
    <- effects`eq-inversion E1 ME1 XE1
    <- effects`eq-inversion E2 ME2 XE2
    <- shared-efx`join-unique XJ XJ' XE1 XE2 XE
    <- efxmap`join-unique MJ MJ' ME1 ME2 ME
    <- effects/-preserves-eq ME XE E.

%worlds () (effects`join-unique _ _ _ _ _ ).
%total {} (effects`join-unique _ _ _ _ _ ).


%theorem effects`join-implies-leq
  : forall* {XX1} {XX2} {XX}
    forall {J1: effects`join XX1 XX2 XX}
    exists {L1: effects`leq XX1 XX}
    {L2: effects`leq XX2 XX}
    true.

- : effects`join-implies-leq (effects`join/ XJ MJ)
    (effects`leq/ XL1 ML1) (effects`leq/ XL2 ML2)
    <- shared-efx`join-implies-leq XJ XL1 XL2
    <- efxmap`join-implies-leq MJ ML1 ML2.

%worlds () (effects`join-implies-leq _ _ _).
%total {} (effects`join-implies-leq _ _ _).


%theorem effects`join-associative :
	forall* {XX1} {XX2} {XX3} {XX4} {XX7}
	forall {A12:effects`join XX1 XX2 XX3} {A34:effects`join XX3 XX4 XX7}
	exists {XX6} {A24:effects`join XX2 XX4 XX6} {A16:effects`join XX1 XX6 XX7}
	true.

%worlds () (effects`join-associative _ _ _ _ _).
%trustme %total {}  (effects`join-associative _ _ _ _ _).


%theorem effects`join-associative-converse
: forall* {XX1} {XX2} {XX4} {XX6} {XX7}
	forall {A24:effects`join XX2 XX4 XX6}
  {A16:effects`join XX1 XX6 XX7}
	exists {XX3}
  {A12:effects`join XX1 XX2 XX3}
  {A34:effects`join XX3 XX4 XX7}
	true.

%worlds () (effects`join-associative-converse _ _ _ _ _).
%trustme %total {} (effects`join-associative-converse _ _ _ _ _).


%theorem effects`disjoint-symmetric
  : forall* {XX1} {XX2}
    forall {X12: effects`disjoint XX1 XX2}
    exists {X21: effects`disjoint XX2 XX1}
    true.

%worlds () (effects`disjoint-symmetric _ _).
%trustme %total {} (effects`disjoint-symmetric _ _).


%theorem effects`leq-transitive
  : forall* {XX1} {XX2} {XX3}
    forall {L12: effects`leq XX1 XX2}
    {L23: effects`leq XX2 XX3}
    exists {L13: effects`leq XX1 XX3}
    true.

%worlds () (effects`leq-transitive _ _ _ ).
%trustme %total {} (effects`leq-transitive _ _ _ ).