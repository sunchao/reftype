%%% Effects Generated by Type Checking


% =========================================================================
% ============================ Definitions ================================
% =========================================================================

% effects generated by checking a term

effects : type.
%name effects XX.

effects/ : efxmap -> shared-efx -> set -> effects.

%abbrev no-effect = effects/ efxmap/0 shared-efx/none set/0.


% equality

effects`eq : effects -> effects -> type.

effects`eq/ : effects`eq XX XX.


% well-formed effects

effects`wf : effects -> type.

effects`wf/ : effects`wf (effects/ M X S) 
              <- efxmap`domain M Ms
              <- set`disjoint Ms S.

% join operation on effects

effects`join : effects -> effects -> effects -> type.

% =========================================================================
% Precondition: no overlapping between XM1 and S1, and between XM2 and S2.
% Postcondition: no overlapping between XM and S.

% The read/write/consume effects on fields in XM1 will be covered
% by consume effects on objects in S2, therefore, we need to remove
% them from XM1 so that there will be no overlapping in result.
% For the otherway around (S1 and XM2), any entry in S1 shouldn't occur
% in XM2 since once a object is consumed, no effect can be made on its fields. 
% =========================================================================

effects`join/
  : effects`join
    (effects/ M1 X1 S1) (effects/ M2 X2 S2) (effects/ M X S)
    <- efxmap`domain M1 Ms1
    <- efxmap`domain M2 Ms2
    <- set`disjoint S1 S2 % no multiple consumption
    <- set`remove Ms1 S2 R
    <- efxmap`restrict M1 R M1'
    <- set`disjoint S1 Ms2 % can't consume and then read/write
    <- efxmap`join M1' M2 M
    <- shared-efx`join X1 X2 X
    <- set`join S1 S2 S.


% less-equal on effects

effects`leq : effects -> effects -> type.

% =========================================================================
% Precondition: no overlapping between XM1 and S1, and between XM2 and S2.

% Notice that, keys in M1 may appear in S2, in which case they are consider
% covered by the corresponding key in S2. So, when checking M1 against M2,
% we (may) need to consider a submap of M1.
% =========================================================================

effects`leq/
  : effects`leq (effects/ M1 X1 S1) (effects/ M2 X2 S2)
    <- efxmap`domain M1 Ms1
    <- set`remove Ms1 S2 R
    <- efxmap`restrict M1 R M1'
    <- efxmap`leq M1' M2
    <- shared-efx`leq X1 X2
    <- set`leq S1 S2.


% =========================================================================
% disjoint on effect
%
% Precondition: no overlapping between XM1 and S1, and between XM2 and S2.
%
% Here, all keys in M1 shouldn't appear in S2, and same for M2 and S2.
% =========================================================================

effects`disjoint : effects -> effects -> type.

effects`disjoint/
  : effects`disjoint (effects/ M1 X1 S1) (effects/ M2 X2 S2)
    <- efxmap`domain M1 Ms1
    <- efxmap`domain M2 Ms2
    <- efxmap`deep-disjoint M1 M2
    <- set`disjoint Ms1 S2
    <- set`disjoint Ms2 S1
    <- shared-efx`disjoint SX1 SX2.


% =========================================================================
% ============================ Theorems ===================================
% =========================================================================


% a useful lemma

%theorem remove-disjoint-restrict-nothing
  : forall* {M} {M'} {S1} {S2} {S3}
    forall {DM: efxmap`domain M S1}
    {X: set`disjoint S1 S2}
    {RM: set`remove S1 S2 S3}
    {RS: efxmap`restrict M S3 M'}
    exists {E: efxmap`eq M' M}
    true.

- : remove-disjoint-restrict-nothing DM-M=S1 S1^S2 S1/S2=S3 M|S3=M' M'=M
    <- set`disjoint-implies-remove-nothing S1^S2 S1/S2=S1
    <- set`remove-unique S1/S2=S3 S1/S2=S1 set`eq/ set`eq/ S3=S1
    <- efxmap`restrict-respects-eq M|S3=M' efxmap`eq/ S3=S1 efxmap`eq/ M|S1=M'
    <- set`leq-reflexive _ S1<=S1
    <- efxmap`domain-leq-implies-no-restriction DM-M=S1 S1<=S1 M|S1=M
    <- efxmap`restrict-unique M|S1=M' M|S1=M efxmap`eq/ set`eq/ M'=M.

%worlds () (remove-disjoint-restrict-nothing _ _ _ _ _).
%total {} (remove-disjoint-restrict-nothing _ _ _ _ _). 


%theorem effects`eq-inversion
  : forall* {M1} {M2} {X1} {X2} {S1} {S2}
    forall {E: effects`eq (effects/ M1 X1 S1) (effects/ M2 X2 S2)}
    exists {E: efxmap`eq M1 M2} {E: shared-efx`eq X1 X2} {E: set`eq S1 S2}
    true.

- : effects`eq-inversion effects`eq/ efxmap`eq/ shared-efx`eq/ set`eq/.

%worlds () (effects`eq-inversion _ _ _ _).
%total {} (effects`eq-inversion _ _ _ _).


%theorem effects`join-unique
  : forall* {XX1} {XX1'} {XX2} {XX2'} {XX} {XX'}
    forall {J: effects`join XX1 XX2 XX}
    {J': effects`join XX1' XX2' XX'}
    {E: effects`eq XX1 XX1'} {E: effects`eq XX2 XX2'}
    exists {E: effects`eq XX XX'}
    true.

%worlds () (effects`join-unique _ _ _ _ _ ).
%trustme %total {} (effects`join-unique _ _ _ _ _ ).


%theorem effects`join-implies-leq
  : forall* {XX1} {XX2} {XX}
    forall {WF-XX1: effects`wf XX1}
    {WF-XX2: effects`wf XX2}
    {J1: effects`join XX1 XX2 XX}
    exists {L1: effects`leq XX1 XX}
    {L2: effects`leq XX2 XX}
    true.

- : effects`join-implies-leq
    (effects`wf/ Ms1'^S1 (M1-Ms1':efxmap`domain M1 Ms1'))
    (effects`wf/ Ms2'^S2 (M2-Ms2':efxmap`domain M2 Ms2'))
    (effects`join/ 
      (S1+S2=S:set`union S1 S2 S)
      X1+X2=X (M1'+M2=M:efxmap`join M1' M2 M)
      (S1^Ms2:set`disjoint S1 Ms2) (M1|R=M1':efxmap`restrict M1 R M1')
      (Ms1/S2=R:set`remove Ms1 S2 R)
      (S1^S2)
      (M2-Ms2:efxmap`domain M2 Ms2)
      (M1-Ms1:efxmap`domain M1 Ms1))
    (effects`leq/ S1<=S X1<=X M1'<=M M1|R=M1' Ms1/S=R M1-Ms1)
    (effects`leq/ S2<=S X2<=X M2<=M M2|Ms2=M2 Ms2/S=Ms2 M2-Ms2)
    <- set`union-implies-leq S1+S2=S S1<=S S2<=S
    <- shared-efx`join-implies-leq X1+X2=X X1<=X X2<=X
    <- efxmap`join-implies-leq M1'+M2=M M1'<=M M2<=M
    <- efxmap`domain-unique M1-Ms1' M1-Ms1 efxmap`eq/ Ms1'=Ms1
    <- efxmap`domain-unique M2-Ms2' M2-Ms2 efxmap`eq/ Ms2'=Ms2
    <- set`disjoint-implies-remove-nothing Ms1'^S1 Ms1'/S1=Ms1'
    <- set`remove-respects-eq Ms1'/S1=Ms1' Ms1'=Ms1 set`eq/ Ms1'=Ms1 Ms1/S1=Ms1
    <- set`remove-associates-union* Ms1/S1=Ms1 Ms1/S2=R S1+S2=S Ms1/S=R
    <- set`disjoint-respects-eq Ms2'^S2 Ms2'=Ms2 set`eq/ Ms2^S2
    <- set`disjoint-symmetric Ms2^S2 S2^Ms2
    <- set`union-preserves-disjoint* S1^Ms2 S2^Ms2 S1+S2=S S^Ms2
    <- set`disjoint-symmetric S^Ms2 Ms2^S
    <- set`disjoint-implies-remove-nothing Ms2^S Ms2/S=Ms2
    <- set`leq-reflexive _ Ms2<=Ms2
    <- efxmap`domain-leq-implies-no-restriction M2-Ms2 Ms2<=Ms2 M2|Ms2=M2.

%worlds () (effects`join-implies-leq _ _ _ _ _).
%total {} (effects`join-implies-leq _ _ _ _ _).


%theorem effects`leq-transitive
  : forall* {XX1} {XX2} {XX3}
    forall {WF1: effects`wf XX1} {WF2: effects`wf XX2}
    {WF3: effects`wf XX3} {XX1<=XX2: effects`leq XX1 XX2}
    {XX2<=XX3: effects`leq XX2 XX3}
    exists {XX1<=XX3: effects`leq XX1 XX3}
    true.

% - : effects`leq-transitive 
%     (effects`leq/ S1<=S2 X1<=X2 M1'<=M2 M1|R=M1' Ms1/S2=R DM-M1=Ms1)
%     (effects`leq/ S2<=S3 X2<=X3 M2'<=M3 M2|R'=M2' Ms2/S3=R' DM-M2=Ms2)
%     (effects`leq/ S1<=S3 X1<=X3 M1'<=M3 M1|R''=M1' Ms1/S3=R'' DM-M1=Ms1)
%     <- set`leq-transitive S1<=S2 S2<=S3 S1<=S3
%     <- shared-efx`leq-transitive X1<=X2 X2<=X3 X1<=X3
%     <- 

%worlds () (effects`leq-transitive _ _ _ _ _ _).
%trustme %total {} (effects`leq-transitive _ _ _ _ _ _).


%theorem effects`join-associative :
	forall* {XX1} {XX2} {XX3} {XX4} {XX7}
	forall {A12:effects`join XX1 XX2 XX3} {A34:effects`join XX3 XX4 XX7}
	exists {XX6} {A24:effects`join XX2 XX4 XX6} {A16:effects`join XX1 XX6 XX7}
	true.

% M1'+M2=M3 M3'+M4=M7 => M6, M2'+M4=M6 M1'+M6=M7
% - : effects`join-associative
%     (effects`join/ (S1+S2=S3:set`union S1 S2 S3)
%       X1+X2=X3 M1'+M2=M3 (S1^Ms2:set`disjoint S1 Ms2) M1|R12=M1'
%       Ms1/S2=R12 S1^S2 DM-M2=Ms2 DM-M1=Ms1)
%     (effects`join/ (S3+S4=S7:set`union S3 S4 S7)
%       X3+X4=X7 M3'+M4=M7 (S3^Ms4:set`disjoint S3 Ms4) M3|R34=M3'
%       Ms3/S4=R34 S3^S4 DM-M4=Ms4 DM-M3=Ms3) _
%     (effects`join/ (S2+S4=S6:set`union S2 S4 S6)
%       X2+X4=X6 M2'+M4=M6 (S2^Ms4:set`disjoint S2 Ms4) M2|R24=M2'
%       Ms2/S4=R24 S2^S4 DM-M4=Ms4 DM-M2=Ms2)
%     (effects`join/ (S1+S6=S7:set`union S1 S6 S7)
%       X1+X6=X7 M1'+M6=M7 (S1^Ms6:set`disjoint S1 Ms6) M1|R16=M1'
%       Ms1/S6=R16 S1^S6 DM-M6=Ms6 DM-M1=Ms1)
%     <- shared-efx`join-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7
%     <- set`union-associative S1+S2=S3 S3+S4=S7 S6 S2+S4=S6 S1+S6=S7
%     <- set`union-implies-leq S1+S2=S3 S1<=S3 S2<=S3
%     <- set`disjoint-respects-geq* S3^S4 S1<=S3 S1^S4
%     <- set`disjoint-respects-geq* S3^S4 S2<=S3 S2^S4
%     <- set`union-right-preserves-disjoint* S1^S2 S1^S4 S2+S4=S6 S1^S6
%     <- set`disjoint-respects-geq* S3^Ms4 S1<=S3 S1^Ms4
%     <- set`union-total Ms2+Ms4=Ms6'
%     <- set`union-right-preserves-disjoint* S1^Ms2 S1^Ms4 Ms2+Ms4=Ms6' S1^Ms6'.

%worlds () (effects`join-associative _ _ _ _ _).
%trustme %total {}  (effects`join-associative _ _ _ _ _).


%theorem effects`join-associative-converse
: forall* {XX1} {XX2} {XX4} {XX6} {XX7}
	forall {A24:effects`join XX2 XX4 XX6} 
  {A16:effects`join XX1 XX6 XX7}
	exists {XX3}
  {A12:effects`join XX1 XX2 XX3} 
  {A34:effects`join XX3 XX4 XX7}
	true.

%worlds () (effects`join-associative-converse _ _ _ _ _).
%trustme %total {} (effects`join-associative-converse _ _ _ _ _).


%theorem effects`disjoint-join-commutative
  : forall* {XX1} {XX2} {XX}
    forall {X: effects`disjoint XX1 XX2}
    {J12: effects`join XX1 XX2 XX}
    exists {J21: effects`join XX2 XX1 XX}
    true.

- : effects`disjoint-join-commutative
    (effects`disjoint/ X1^X2 Ms2'^S1 Ms1'^S2 M1^M2 DM2=Ms2' DM1=Ms1')
    (effects`join/ S1+S2=S X1+X2=X M1'+M2=M S1^Ms2 M1|R=M1' Ms1/S2=R
      S1^S2 DM2=Ms2 DM1=Ms1)
    (effects`join/ S2+S1=S X2+X1=X M2+M1=M S2^Ms1 M2|Ms2=M2 Ms2/S1=Ms2
      S2^S1 DM1=Ms1 DM2=Ms2)
    <- set`union-commutative S1+S2=S S2+S1=S
    <- set`disjoint-symmetric S1^S2 S2^S1
    <- shared-efx`join-commutative X1+X2=X X2+X1=X
    <- efxmap`domain-unique DM1=Ms1' DM1=Ms1 efxmap`eq/ Ms1'=Ms1
    <- efxmap`domain-unique DM2=Ms2' DM2=Ms2 efxmap`eq/ Ms2'=Ms2
    <- set`disjoint-respects-eq Ms1'^S2 Ms1'=Ms1 set`eq/ Ms1^S2
    <- set`disjoint-respects-eq Ms2'^S1 Ms2'=Ms2 set`eq/ Ms2^S1
    <- remove-disjoint-restrict-nothing DM1=Ms1 Ms1^S2 Ms1/S2=R M1|R=M1' M1'=M1
    <- efxmap`join-respects-eq M1'+M2=M M1'=M1 efxmap`eq/ efxmap`eq/ M1+M2=M
    <- efxmap`deep-disjoint-join-commutative M1^M2 M1+M2=M M2+M1=M
    <- set`disjoint-implies-remove-nothing Ms2^S1 Ms2/S1=Ms2
    <- set`leq-reflexive _ Ms2<=Ms2
    <- efxmap`domain-leq-implies-no-restriction DM2=Ms2 Ms2<=Ms2 M2|Ms2=M2
    <- set`disjoint-symmetric Ms1^S2 S2^Ms1.

%worlds () (effects`disjoint-join-commutative _ _ _).
%total {} (effects`disjoint-join-commutative _ _ _). 