%%% Effects generated by type checking

%%% Definitions

% 1, effects generated by checking a term
% - `efxmap`: read/write effects on field targets
% - `set`: consume effects on field targets
% - `set`: consume effects on object targets.
effects : type. %name effects XX.

effects/ : efxmap -> set -> set -> effects.

%abbrev no-effect = effects/ efxmap/0 set/0 set/0.


% equality

effects`eq : effects -> effects -> type.

effects`eq/ : effects`eq XX XX.


% remove the complement of the set

efxmap`remove : efxmap -> set -> efxmap -> type.

efxmap`remove/
  : efxmap`domain M R
    -> set`remove R S Q
    -> efxmap`restrict M Q M'
    -> efxmap`remove M S M'.


% join operation on effects

effects`join : effects -> effects -> effects -> type.

% read/write efx in M1 may appear as consume in S2, the result should be
% consume. Also, notice that S1 should be disjoint with domain of M2.
% We also need both effects to be wellformed, and we put this information
% in the relation.

effects`join/
  : efxmap`domain M1 R1
    -> efxmap`domain M2 R2
    -> set`disjoint S1 R1 % cannot have both consume and read/write
    -> set`disjoint S2 R2 % same as above
    -> set`disjoint S1 R2 % consume cannot precede read/write
    -> set`disjoint S1 S2 % cannot consume twice
    -> set`remove R1 S2 S3
    -> efxmap`restrict M1 S3 M1'
    -> efxmap`join M1' M2 M
    -> set`union S1 S2 S
    -> set`disjoint Q1 Q2
    -> set`union Q1 Q2 Q % Q1 and Q2 must be disjoint from S1^S2
    -> effects`join (effects/ M1 S1 Q1) (effects/ M2 S2 Q2) (effects/ M S Q).


% read/write efx in M1 is "covered" by consume efx in S2

effects`leq : effects -> effects -> type.

effects`leq/
  : efxmap`domain M1 R1
    -> efxmap`domain M2 R2
    -> set`remove R1 S2 S3
    -> efxmap`restrict M1 S3 M1'
    -> efxmap`leq M1' M2
    -> set`leq S1 S2
    -> set`leq Q1 Q2
    -> effects`leq (effects/ M1 S1 Q1) (effects/ M2 S2 Q2).


% disjoint

effects`disjoint : effects -> effects -> type.

% precondition is M1^S1, M2^S2

effects`disjoint/
  : efxmap`disjoint M1 M2
    -> set`disjoint S1 S2
    -> effects`disjoint (effects/ M1 S1 Q1) (effects/ M2 S2 Q2).


% leq only on efxmap and shared-efx

effects-leq-no-consume : effects -> effects -> type.

effects-leq-no-consume/
  : effects-leq-no-consume (effects/ M _ _) (effects/ M' _ _)
    <- efxmap`leq M M'


%%% Theorems about effects

%theorem effects`eq-inversion
  : forall* {M1} {M2} {S1} {S2} {Q1} {Q2}
    forall {E: effects`eq (effects/ M1 S1 Q1) (effects/ M2 S2 Q2)}
    exists {ME: efxmap`eq M1 M2} {SE: set`eq S1 S2} {QE: set`eq Q1 Q2}
    true.

- : effects`eq-inversion effects`eq/ efxmap`eq/ set`eq/ set`eq/.

%worlds () (effects`eq-inversion _ _ _ _).
%total {} (effects`eq-inversion _ _ _ _).


%theorem effects/-preserves-eq
  : forall* {M} {M'} {S} {S'} {Q} {Q'}
    forall {ME: efxmap`eq M M'} {SE: set`eq S S'} {QE: set`eq Q Q'}
    exists {E: effects`eq (effects/ M S Q) (effects/ M' S' Q')}
    true.

- : effects/-preserves-eq efxmap`eq/ set`eq/ set`eq/ effects`eq/.

%worlds () (effects/-preserves-eq _ _ _ _).
%total {} (effects/-preserves-eq _ _ _ _).


%theorem effects`eq-symmetric
  : forall* {XX1} {XX2}
    forall {E: effects`eq XX1 XX2}
    exists {E: effects`eq XX2 XX1}
    true.

- : effects`eq-symmetric E E.

%worlds () (effects`eq-symmetric _ _).
%total {} (effects`eq-symmetric _ _).


%theorem effects`leq-inversion
  : forall* {M1} {S1} {Q1} {M2} {S2} {Q2}
    forall {XX1<=XX2: effects`leq (effects/ M1 S1 Q1)
                      (effects/ M2 S2 Q2)}
    exists {R1} {S3} {M1'}
    {DM-M1: efxmap`domain M1 R1}
    {R1/S2=S3: set`remove R1 S2 S3}
    {M1|S3=M1': efxmap`restrict M1 S3 M1'}
    {M1'<=M2: efxmap`leq M1' M2}
    {S1<=S2: set`leq S1 S2}
    {Q1<=Q2: set`leq Q1 Q2}
    true.

- : effects`leq-inversion (effects`leq/ DM1 DM2 RM RS ML SL QL)
    _ _ _ DM1 RM RS ML SL QL.

%worlds () (effects`leq-inversion _ _ _ _ _ _ _ _ _ _).
%total {} (effects`leq-inversion _ _ _ _ _ _ _ _ _ _).


% Some lemmas

%theorem efxmap`remove-implies-domain-disjoint
  : forall* {M} {M'} {S}
    forall {DM: efxmap`remove M S M'}
    exists {R'} {DM: efxmap`domain M' R'} {D: set`disjoint R' S}
    true.

- : efxmap`remove-implies-domain-disjoint
    (efxmap`remove/ DM-M=R R/S=S' M|S'=M') R' DM-M'=R' R'^S
    <- efxmap`domain-total DM-M'=R'
    <- efxmap`restrict-implies-domain-leq* M|S'=M' DM-M'=R' R'<=S'
    <- set`remove-implies-disjoint R/S=S' S^S'
    <- set`leq-reflexive _ S<=S
    <- set`disjoint-respects-geq S^S' S<=S R'<=S' S^R'
    <- set`disjoint-symmetric S^R' R'^S.

%worlds () (efxmap`remove-implies-domain-disjoint _ _ _ _).
%total {} (efxmap`remove-implies-domain-disjoint _ _ _ _).


%theorem efxmap`remove-implies-domain-disjoint*
  : forall* {M} {M'} {S} {R'}
    forall {DM: efxmap`remove M S M'}
    {DM: efxmap`domain M' R'}
    exists {D: set`disjoint R' S}
    true.

- : efxmap`remove-implies-domain-disjoint*
    (efxmap`remove/ DM-M=R R/S=S' M|S'=M') DM-M'=R' R'^S
    <- efxmap`restrict-implies-domain-leq* M|S'=M' DM-M'=R' R'<=S'
    <- set`remove-implies-disjoint R/S=S' S^S'
    <- set`leq-reflexive _ S<=S
    <- set`disjoint-respects-geq S^S' S<=S R'<=S' S^R'
    <- set`disjoint-symmetric S^R' R'^S.

%worlds () (efxmap`remove-implies-domain-disjoint* _ _ _).
%total {} (efxmap`remove-implies-domain-disjoint* _ _ _).


%theorem effects`join-respects-eq
  : forall* {XX1} {XX2} {XX} {XX1'} {XX2'} {XX'}
    forall {J: effects`join XX1 XX2 XX}
    {E1: effects`eq XX1 XX1'} {E2: effects`eq XX2 XX2'}
    {E: effects`eq XX XX'}
    exists {J': effects`join XX1' XX2' XX'}
    true.

- : effects`join-respects-eq J effects`eq/ effects`eq/ effects`eq/ J.

%worlds () (effects`join-respects-eq _ _ _ _ _).
%total {} (effects`join-respects-eq _ _ _ _ _).


%theorem effects`join-unique
  : forall* {XX1} {XX1'} {XX2} {XX2'} {XX} {XX'}
    forall {J: effects`join XX1 XX2 XX}
    {J': effects`join XX1' XX2' XX'}
    {E: effects`eq XX1 XX1'} {E: effects`eq XX2 XX2'}
    exists {E: effects`eq XX XX'}
    true.

- : effects`join-unique
    (effects`join/ DM-M1=R1 DM-M2=R2 _ _ _ _ R1/S2=S3
      M1|S3=M1' M1'+M2=M S1+S2=S Q1^Q2 Q1+Q2=Q)
    (effects`join/ DM-MP1=RP1 DM-MP2=RP2 _ _ _ _ RP1/SP2=SP3
      MP1|SP3=MP1' MP1'+MP2=MP SP1+SP2=SP QP1^QP2 QP1+QP2=QP) E1 E2 E
    <- effects`eq-inversion E1 M1=MP1 S1=SP1 Q1=QP1
    <- effects`eq-inversion E2 M2=MP2 S2=SP2 Q2=QP2
    <- efxmap`domain-unique DM-M1=R1 DM-MP1=RP1 M1=MP1 R1=RP1
    <- efxmap`domain-unique DM-M2=R2 DM-MP2=RP2 M2=MP2 R2=RP2
    <- set`remove-unique R1/S2=S3 RP1/SP2=SP3 R1=RP1 S2=SP2 S3=SP3
    <- efxmap`restrict-unique M1|S3=M1' MP1|SP3=MP1' M1=MP1 S3=SP3 M1'=MP1'
    <- efxmap`join-unique M1'+M2=M MP1'+MP2=MP M1'=MP1' M2=MP2 M=MP
    <- set`union-unique S1+S2=S SP1+SP2=SP S1=SP1 S2=SP2 S=SP
    <- set`union-unique Q1+Q2=Q QP1+QP2=QP Q1=QP1 Q2=QP2 Q=QP
    <- effects/-preserves-eq M=MP S=SP Q=QP E.

%worlds () (effects`join-unique _ _ _ _ _).
%total {} (effects`join-unique _ _ _ _ _).


%theorem effects`join-implies-leq
  : forall* {XX1} {XX2} {XX}
    forall {J1: effects`join XX1 XX2 XX}
    exists {L1: effects`leq XX1 XX}
    {L2: effects`leq XX2 XX}
    true.

- : effects`join-implies-leq (effects`join/ DM-M1=R1 DM-M2=R2 S1^R1 S2^R2
                               S1^R2 S1^S2 R1/S2=S3 M1|S3=M1' M1'+M2=M
                               S1+S2=S Q1^Q2 Q1+Q2=Q)
    (effects`leq/ DM-M1=R1 DM-M=R R1/S=S3 M1|S3=M1' M1'<=M S1<=S Q1<=Q)
    (effects`leq/ DM-M2=R2 DM-M=R R2/S=R2 M2|R2=M2 M2<=M S2<=S Q2<=Q)
    <- efxmap`domain-total DM-M=R
    <- efxmap`join-implies-leq M1'+M2=M M1'<=M M2<=M
    <- set`union-implies-leq S1+S2=S S1<=S S2<=S
    <- set`union-implies-leq Q1+Q2=Q Q1<=Q Q2<=Q
    <- set`union-commutative S1+S2=S S2+S1=S
    <- set`remove-total R1/S=Q3
    <- set`remove-associates-union-converse* S2+S1=S R1/S=Q3 R1/S2=S3 S3/S1=Q3
    <- set`disjoint-symmetric S1^R1 R1^S1
    <- set`remove-implies-leq R1/S2=S3 S3<=R1
    <- set`disjoint-respects-geq* R1^S1 S3<=R1 S3^S1
    <- set`disjoint-implies-remove-nothing S3^S1 S3/S1=S3
    <- set`remove-unique S3/S1=Q3 S3/S1=S3 set`eq/ set`eq/ Q3=S3
    <- set`remove-respects-eq R1/S=Q3 set`eq/ set`eq/ Q3=S3 R1/S=S3
    <- set`union-preserves-disjoint* S1^R2 S2^R2 S1+S2=S S^R2
    <- set`disjoint-symmetric S^R2 R2^S
    <- set`disjoint-implies-remove-nothing R2^S R2/S=R2
    <- set`leq-reflexive _ R2<=R2
    <- efxmap`domain-leq-implies-no-restriction DM-M2=R2 R2<=R2 M2|R2=M2.

%worlds () (effects`join-implies-leq _ _ _).
%total {} (effects`join-implies-leq _ _ _).


% perhaps this should go to map-restrict.elf

%theorem efxmap`restrict-lookup-not-member-implies-fresh-converse
  : forall* {M} {M'} {S} {N} {D}
    forall {R: restrict M S M'}
    {N<-M: efxmap`lookup M N D}
    {N!<M': efxmap`fresh M' N}
    exists {N!<S: set`not-member S N}
    true.

%theorem efxmap`restrict-lookup-not-member-implies-fresh-converse/L
  : forall* {M} {M'} {S} {N} {D}
    forall {R: restrict M S M'}
    {N<-M: efxmap`lookup M N D}
    {N!<M': efxmap`fresh M' N}
    {B} {IN?: set`member? S N B}
    exists {N!<S: set`not-member S N}
    true.

- : efxmap`restrict-lookup-not-member-implies-fresh-converse/L
    M|S=M' M->N=D N!<M' _ (set`member?/in N<-S) N!<S
    <- efxmap`restrict-preserves-lookup M->N=D M|S=M' N<-S M'->N=D
    <- efxmap`fresh-lookup-not-equal N!<M' M'->N=D N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- set`false-implies-not-member F N!<S.

- : efxmap`restrict-lookup-not-member-implies-fresh-converse/L
    _ _ _ _ (set`member?/out N!<S) N!<S.

- : efxmap`restrict-lookup-not-member-implies-fresh-converse R MB F IN
    <- set`member?-total MB?
    <- efxmap`restrict-lookup-not-member-implies-fresh-converse/L R MB F _ MB? IN.

%worlds () (efxmap`restrict-lookup-not-member-implies-fresh-converse/L _ _ _ _ _ _).
%total {} (efxmap`restrict-lookup-not-member-implies-fresh-converse/L _ _ _ _ _ _).

%worlds () (efxmap`restrict-lookup-not-member-implies-fresh-converse _ _ _ _).
%total {} (efxmap`restrict-lookup-not-member-implies-fresh-converse _ _ _ _).

% this is tedius..

%theorem effects`join-associative :
	forall* {XX1} {XX2} {XX3} {XX4} {XX7}
	forall {A12:effects`join XX1 XX2 XX3} {A34:effects`join XX3 XX4 XX7}
	exists {XX6} {A24:effects`join XX2 XX4 XX6} {A16:effects`join XX1 XX6 XX7}
	true.

%theorem effects`join-associative/L1
  : forall* {M1} {M2} {M} {S1} {S2} {S} {Q} {S1'} {S2'} {S'}
    {M1'} {M2'} {M'}
    forall {J: efxmap`join M1 M2 M}
    {DM1: efxmap`domain M1 S1} {R1: set`remove S1 Q S1'}
    {DM2: efxmap`domain M2 S2} {R2: set`remove S2 Q S2'}
    {DM3: efxmap`domain M S} {R: set`remove S Q S'}
    {RS1: efxmap`restrict M1 S1' M1'}
    {RS2: efxmap`restrict M2 S2' M2'}
    {RS: efxmap`restrict M S' M'}
    exists {J: efxmap`join M1' M2' M'}
    true.

- : effects`join-associative/L1
    M1+M2=M DM-M1=S1 S1/Q=S1' DM-M2=S2 S2/Q=S2' DM-M=S S/Q=S'
    M1|S1'=M1' M2|S2'=M2' M|S'=M' M1'+M2'=M'
    <- efxmap`restrict-total M1|Q=M1''
    <- efxmap`restrict-total M2|Q=M2''
    <- efxmap`restrict-total (M|Q=M'':restrict M Q M'')
    <- efxmap`partition-implies-disjoint-join
      (partition/ DM-M1=S1 S1/Q=S1' M1|S1'=M1' M1|Q=M1'') M1'^M1'' M1'+M1''=M1
    <- efxmap`partition-implies-disjoint-join
      (partition/ DM-M2=S2 S2/Q=S2' M2|S2'=M2' M2|Q=M2'') M2'^M2'' M2'+M2''=M2
    <- efxmap`partition-implies-disjoint-join
      (partition/ DM-M=S S/Q=S' M|S'=M' M|Q=M'') M'^M'' M'+M''=M
    <- efxmap`join-double-associative M1'+M1''=M1 M2'+M2''=M2 M1+M2=M
      K1 K2 M1'+M2'=K1 M1''+M2''=K2 K1+K2=M
    <- efxmap`join-commute-restrict*
      M1+M2=M M1|Q=M1'' M2|Q=M2'' M|Q=M'' M1''+M2''=M''
    <- efxmap`join-unique
      M1''+M2''=K2 M1''+M2''=M'' efxmap`eq/ efxmap`eq/ K2=M''
    <- efxmap`join-respects-eq K1+K2=M efxmap`eq/ K2=M'' efxmap`eq/ K1+M''=M
    <- set`remove-implies-disjoint S1/Q=S1' Q^S1'
    <- set`remove-implies-disjoint S2/Q=S2' Q^S2'
    <- set`remove-implies-disjoint S/Q=S' Q^S'
    <- efxmap`restrict-implies-domain-leq M1|S1'=M1' R1 DM-M1'=R1 R1<=S1'
    <- efxmap`restrict-implies-domain-leq M2|S2'=M2' R2 DM-M2'=R2 R2<=S2'
    <- efxmap`restrict-implies-domain-leq M1|Q=M1'' P1 DM-M1''=P1 P1<=Q
    <- efxmap`restrict-implies-domain-leq M2|Q=M2'' P2 DM-M2''=P2 P2<=Q
    <- set`disjoint-respects-geq Q^S1' P2<=Q R1<=S1' P2^R1
    <- set`disjoint-respects-geq Q^S2' P1<=Q R2<=S2' P1^R2
    <- efxmap`domain-preserves-disjoint-converse
      P2^R1 DM-M2''=P2 DM-M1'=R1 M2''^M1'
    <- efxmap`domain-preserves-disjoint-converse
      P1^R2 DM-M1''=P1 DM-M2'=R2 M1''^M2'
    <- efxmap`disjoint-symmetric M2''^M1' M1'^M2''
    <- efxmap`disjoint-symmetric M1''^M2' M2'^M1''
    <- efxmap`join-preserves-disjoint* M1'^M1'' M2'^M1'' M1'+M2'=K1 K1^M1''
    <- efxmap`join-preserves-disjoint* M1'^M2'' M2'^M2'' M1'+M2'=K1 K1^M2''
    <- efxmap`join-right-preserves-disjoint* K1^M1'' K1^M2'' M1''+M2''=K2 K1^K2
    <- efxmap`disjoint-join-right-cancels
      K1^K2 K1+K2=M M'^M'' M'+M''=M K2=M'' efxmap`eq/ K1=M'
    <- efxmap`join-respects-eq
      M1'+M2'=K1 efxmap`eq/ efxmap`eq/ K1=M' M1'+M2'=M'.

%worlds () (effects`join-associative/L1 _ _ _ _ _ _ _ _ _ _ _).
%total {} (effects`join-associative/L1 _ _ _ _ _ _ _ _ _ _ _).


%theorem effects`join-associative/L2
  : forall* {R1} {R1'} {S2} {Q1} {M} {M'} {S6} {Q4} {B}
    forall {DM1: efxmap`domain M R1}
    {DM1': efxmap`domain M' R1'}
    {RS: efxmap`restrict M Q1 M'}
    {NLE: set`leq? Q4 R1' B}
    {RM: set`remove R1 S6 Q4}
    {RM: set`remove R1 S2 Q1}
    {J: set`leq S2 S6}
    exists {LE: set`leq Q4 R1'}
    true.

- : effects`join-associative/L2 DM-M=R1 DM-M'=R1' M|Q1=M'
    (set`leq?/no (set`nle/< N<-Q4 N!<R1')) R1/S6=Q4 R1/S2=Q1 S2<=S6 Q4<=R1'
    <- set`remove-implies-leq R1/S6=Q4 Q4<=R1
    <- set`remove-implies-disjoint R1/S6=Q4 S6^Q4
    <- set`disjoint-symmetric S6^Q4 Q4^S6
    <- set`disjoint-lookup-implies-not-member N<-Q4 Q4^S6 N!<S6
    <- set`member-respects-leq N<-Q4 Q4<=R1 N<-R1
    <- efxmap`restrict-implies-domain-leq* M|Q1=M' DM-M'=R1' R1'<=Q1
    <- efxmap`domain-preserves-lookup-converse N<-R1 DM-M=R1 _ M->N=D
    <- efxmap`domain-preserves-fresh-converse N!<R1' DM-M'=R1' N!<M'
    <- efxmap`restrict-lookup-not-member-implies-fresh-converse
      M|Q1=M' M->N=D N!<M' N!<Q1
    <- set`union-total S2+Q1=P
    <- set`remove-implies-leq-union R1/S2=Q1 S2+Q1=P R1<=P
    <- set`remove-implies-disjoint R1/S2=Q1 S2^Q1
    <- set`member-respects-leq N<-R1 R1<=P N<-P
    <- set`not-member-union-right-preserves-member-converse
      N<-P N!<Q1 S2+Q1=P N<-S2
    <- set`member-respects-leq N<-S2 S2<=S6 N<-S6
    <- set`not-member-member-not-equal N!<S6 N<-S6 N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- set`false-implies-leq V Q4<=R1'.

- : effects`join-associative/L2 _ _ _ (set`leq?/yes Q4<=R1') _ _ _ Q4<=R1'.

%worlds () (effects`join-associative/L2 _ _ _ _ _ _ _ _).
%total {} (effects`join-associative/L2 _ _ _ _ _ _ _ _).


% this is a mess and I think some of the following are
% just garbage, but I don't care since what done is done!

- : effects`join-associative
    (effects`join/ DM-M1=R1 DM-M2=R2 S1^R1 S2^R2 S1^R2 S1^S2 R1/S2=Q1
      M1|Q1=M1' M1'+M2=M3 S1+S2=S3 Q1^Q2 Q1+Q2=Q3)
    (effects`join/ DM-M3=R3 DM-M4=R4 S3^R3 S4^R4 S3^R4 S3^S4 R3/S4=Q2
      M3|Q2=M3' M3'+M4=M7 S3+S4=S7 Q3^Q4 Q3+Q4=Q7)
    _ (effects`join/ DM-M2=R2 DM-M4=R4 S2^R2 S4^R4 S2^R4 S2^S4 R2/S4=Q3
      M2|Q3=M2' M2'+M4=M6 S2+S4=S6 Q2^Q4 Q2+Q4=Q6)
    (effects`join/ DM-M1=R1 DM-M6=R6 S1^R1 S6^R6 S1^R6 S1^S6 R1/S6=Q4
      M1|Q4=M1'' M1''+M6=M7 S1+S6=S7 Q1^Q6 Q1+Q6=Q7)
    <- set`union-associative S1+S2=S3 S3+S4=S7 S6 S2+S4=S6 S1+S6=S7
    <- set`union-associative Q1+Q2=Q3 Q3+Q4=Q7 Q6 Q2+Q4=Q6 Q1+Q6=Q7
    <- set`union-implies-leq S1+S2=S3 S1<=S3 S2<=S3
    <- set`disjoint-respects-geq* S3^R4 S2<=S3 S2^R4
    <- set`remove-total (R1/S6=Q4:set`remove R1 S6 Q4)
    <- set`remove-associates-union-converse* S2+S4=S6 R1/S6=Q4 R1/S2=Q1
      (Q1/S4=Q4:set`remove Q1 S4 Q4)
    <- efxmap`domain-total (DM-M1'=R1':efxmap`domain M1' R1')
    <- efxmap`restrict-total M1'|Q4=M1''
    <- set`remove-implies-leq Q1/S4=Q4 Q4<=Q1
    <- set`leq-implies-intersection Q4<=Q1 Q4^Q1=Q4
    <- set`intersection-commutative Q4^Q1=Q4 Q1^Q4=Q4
    <- efxmap`restrict-associates-intersection*
      M1|Q1=M1' M1'|Q4=M1'' Q1^Q4=Q4 M1|Q4=M1''
    <- set`remove-total (R2/S4=Q3:set`remove R2 S4 Q3)
    <- set`leq?-total Q4<=R1'?
    <- set`union-implies-leq S2+S4=S6 S2<=S6 S4<=S6
    <- effects`join-associative/L2 DM-M1=R1 DM-M1'=R1' M1|Q1=M1'
      Q4<=R1'? R1/S6=Q4 R1/S2=Q1 S2<=S6 Q4<=R1'
    <- set`remove-implies-disjoint R1/S6=Q4 S6^Q4
    <- set`disjoint-respects-geq* S6^Q4 S4<=S6 S4^Q4
    <- set`union-total S4+Q4=U
    <- set`remove-implies-leq-union Q1/S4=Q4 S4+Q4=U Q1<=U
    <- efxmap`restrict-implies-domain-leq* M1|Q1=M1' DM-M1'=R1' R1'<=Q1
    <- set`leq-transitive R1'<=Q1 Q1<=U R1'<=U
    <- set`remove-characterization Q4<=R1' S4^Q4 S4+Q4=U R1'<=U R1'/S4=Q4
    <- efxmap`restrict-total M2|Q3=M2'
    <- effects`join-associative/L1 M1'+M2=M3 DM-M1'=R1' R1'/S4=Q4
      DM-M2=R2 R2/S4=Q3 DM-M3=R3 R3/S4=Q2 M1'|Q4=M1''
      M2|Q3=M2' M3|Q2=M3' M1''+M2'=M3'
    <- efxmap`join-associative M1''+M2'=M3' M3'+M4=M7 M6 M2'+M4=M6 M1''+M6=M7
    <- set`disjoint-respects-geq* S3^S4 S2<=S3 S2^S4
    <- set`disjoint-respects-geq* S3^S4 S1<=S3 S1^S4
    <- set`disjoint-respects-geq* S3^R4 S1<=S3 S1^R4
    <- efxmap`restrict-implies-leq M2|Q3=M2' M2'<=M2
    <- efxmap`domain-total DM-M2'=R2'
    <- efxmap`domain-preserves-leq* M2'<=M2 DM-M2'=R2' DM-M2=R2 R2'<=R2
    <- set`leq-reflexive _ S1<=S1
    <- set`leq-reflexive _ S2<=S2
    <- set`disjoint-respects-geq S1^R2 S1<=S1 R2'<=R2 S1^R2'
    <- set`disjoint-respects-geq S2^R2 S2<=S2 R2'<=R2 S2^R2'
    <- efxmap`domain-total DM-M6=R6
    <- efxmap`join-commute-domain M2'+M4=M6 DM-M2'=R2' DM-M4=R4
      DM-M6=R6 (R2'+R4=R6:set`union R2' R4 R6)
    <- set`union-implies-leq R2'+R4=R6 R2'<=R6 R4<=R6
    <- set`union-right-preserves-disjoint* S1^R2' S1^R4 R2'+R4=R6 S1^R6
    <- set`union-right-preserves-disjoint* S2^R2' S2^R4 R2'+R4=R6 S2^R6
    <- set`remove-implies-disjoint R2/S4=Q3 S4^Q3
    <- efxmap`restrict-implies-domain-leq* M2|Q3=M2' DM-M2'=R2' R2'<=Q3
    <- set`leq-reflexive _ S4<=S4
    <- set`disjoint-respects-geq S4^Q3 S4<=S4 R2'<=Q3 S4^R2'
    <- set`union-right-preserves-disjoint* S4^R2' S4^R4 R2'+R4=R6 S4^R6
    <- set`union-preserves-disjoint* S2^R6 S4^R6 S2+S4=S6 S6^R6
    <- set`union-right-preserves-disjoint* S1^S2 S1^S4 S2+S4=S6 S1^S6
    <- set`union-implies-leq Q1+Q2=Q3 Q1<=Q3 Q2<=Q3
    <- set`disjoint-respects-geq* Q3^Q4 Q2<=Q3 Q2^Q4
    <- set`disjoint-respects-geq* Q3^Q4 Q1<=Q3 Q1^Q4
    <- set`union-right-preserves-disjoint* Q1^Q2 Q1^Q4 Q2+Q4=Q6 Q1^Q6.

%worlds () (effects`join-associative _ _ _ _ _).
%total {}  (effects`join-associative _ _ _ _ _).


%theorem effects`join-right-empty-no-change
  : forall* {XX} {XX'}
    forall {J: effects`join XX no-effect XX'}
    exists {E: effects`eq XX XX'}
    true.

- : effects`join-right-empty-no-change
    (effects`join/ DM1 _ _ _ _ _ R1/S2=S3 M1|S3=M1' MU
      SU _ QU) EQ
    <- set`disjoint-implies-remove-nothing set`disjoint/R R1/S2=R1
    <- set`remove-unique R1/S2=S3 R1/S2=R1 set`eq/ set`eq/ S3=R1
    <- set`union-unique set`union/R SU set`eq/ set`eq/ SE
    <- set`leq-reflexive _ R1<=R1
    <- efxmap`domain-leq-implies-no-restriction DM1 R1<=R1 M1|R1=M1
    <- efxmap`restrict-unique M1|S3=M1' M1|R1=M1 efxmap`eq/ S3=R1 M1'=M1
    <- efxmap`eq-symmetric M1'=M1 M1=M1'
    <- set`union-unique set`union/R QU set`eq/ set`eq/ QE
    <- efxmap`join-unique efxmap`join/R MU efxmap`eq/ efxmap`eq/ ME
    <- efxmap`eq-transitive M1=M1' ME ME2
    <- effects/-preserves-eq ME2 SE QE EQ.

%worlds () (effects`join-right-empty-no-change _ _).
%total {} (effects`join-right-empty-no-change _ _).


%theorem effects`join-associative-converse
: forall* {XX1} {XX2} {XX4} {XX6} {XX7}
	forall {A24:effects`join XX2 XX4 XX6}
  {A16:effects`join XX1 XX6 XX7}
	exists {XX3}
  {A12:effects`join XX1 XX2 XX3}
  {A34:effects`join XX3 XX4 XX7}
	true.

%worlds () (effects`join-associative-converse _ _ _ _ _).
%trustme %total {} (effects`join-associative-converse _ _ _ _ _).


%theorem effects`disjoint-symmetric
  : forall* {XX1} {XX2}
    forall {X12: effects`disjoint XX1 XX2}
    exists {X21: effects`disjoint XX2 XX1}
    true.

%worlds () (effects`disjoint-symmetric _ _).
%trustme %total {} (effects`disjoint-symmetric _ _).


%theorem effects`leq-transitive
  : forall* {XX1} {XX2} {XX3}
    forall {L12: effects`leq XX1 XX2}
    {L23: effects`leq XX2 XX3}
    exists {L13: effects`leq XX1 XX3}
    true.

%worlds () (effects`leq-transitive _ _ _ ).
%trustme %total {} (effects`leq-transitive _ _ _ ).


%theorem effects`join-no-consume-canonical
  : forall* {M1} {S1} {Q1} {M2} {M} {S} {Q}
    forall {J: effects`join (effects/ M1 S1 Q1)
               (effects/ M2 set/0 set/0) (effects/ M S Q)}
    exists {MJ: efxmap`join M1 M2 M} {SE: set`eq S S1}
    {QE: set`eq Q Q1}
    true.

- : effects`join-no-consume-canonical
    (effects`join/ DM-M1=R1 DM-M2=R2 _ S2^R2 S1^R2
      _ R1/E=S3 M1|S3=M1' M1'+M2=M _ _ _)
    M1+M2=M set`eq/ set`eq/
    <- set`disjoint-implies-remove-nothing set`disjoint/R S/0=S
    <- set`remove-unique R1/E=S3 S/0=S set`eq/ set`eq/ S'=S
    <- set`leq-reflexive _ S<=S
    <- set`leq-respects-eq S<=S S'=S set`eq/ S'<=S
    <- efxmap`domain-leq-implies-no-restriction DM-M1=R1 S'<=S M|S'=M
    <- efxmap`restrict-unique M1|S3=M1' M|S'=M efxmap`eq/ set`eq/ M'=M
    <- efxmap`join-respects-eq M1'+M2=M M'=M efxmap`eq/ efxmap`eq/ M1+M2=M.

%worlds () (effects`join-no-consume-canonical _ _ _ _).
%total {} (effects`join-no-consume-canonical _ _ _ _).
