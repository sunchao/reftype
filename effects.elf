%%% Effects generated by type checking
%%% $Id: effects.elf,v 1.1 2013/09/22 20:46:15 csun Exp csun $

%%% Definitions


%%% 1, shared efx

shared-efx : type. %name shared-efx SX.

shared-efx/none : shared-efx.

shared-efx/read : shared-efx.

shared-efx/write : shared-efx.


% equality

shared-efx`eq : shared-efx -> shared-efx -> type.

shared-efx`eq/ : shared-efx`eq SX SX.


% join operation

shared-efx`join : shared-efx -> shared-efx -> shared-efx -> type.

shared-efx`join/L : shared-efx`join shared-efx/none SX SX.

shared-efx`join/R : shared-efx`join SX shared-efx/none SX.

shared-efx`join/1
  : shared-efx`join shared-efx/read shared-efx/read shared-efx/read.

shared-efx`join/2
  : shared-efx`join shared-efx/read shared-efx/write shared-efx/write.

shared-efx`join/3
  : shared-efx`join shared-efx/write shared-efx/read shared-efx/write.

shared-efx`join/4
  : shared-efx`join shared-efx/write shared-efx/write shared-efx/write.


% less-equal

shared-efx`leq : shared-efx -> shared-efx -> type.

shared-efx`leq/1 : shared-efx`leq shared-efx/none _.

shared-efx`leq/2 : shared-efx`leq shared-efx/read shared-efx/read.

shared-efx`leq/3 : shared-efx`leq shared-efx/read shared-efx/write.

shared-efx`leq/4 : shared-efx`leq shared-efx/write shared-efx/write.


% disjoint

shared-efx`disjoint : shared-efx -> shared-efx -> type.

shared-efx`disjoint/L : shared-efx`disjoint shared-efx/none _.

shared-efx`disjoint/R : shared-efx`disjoint _ shared-efx/none.


% We need to convert shared-efx to efx so as to get a fraction.

shared-efx2efx : shared-efx -> efx -> type.

shared-efx2efx/read : shared-efx2efx shared-efx/read efx/read.

shared-efx2efx/write : shared-efx2efx shared-efx/write efx/write.



% 2, effects generated by checking a term

effects : type. %name effects XX.

effects/ : efxmap -> set -> shared-efx -> effects.

%abbrev no-effect = effects/ efxmap/0 set/0 shared-efx/none.


% equality

effects`eq : effects -> effects -> type.

effects`eq/ : effects`eq XX XX.


% remove the complement of the set

efxmap`remove : efxmap -> set -> efxmap -> type.

efxmap`remove/ : efxmap`domain M R
                 -> set`remove R S Q
                 -> efxmap`restrict M Q M'
                 -> efxmap`remove M S M'.


% join operation on effects

effects`join : effects -> effects -> effects -> type.

% read/write efx in M1 may appear as consume in S2, the result should be
% consume. Also, notice that S1 should be disjoint with domain of M2.
% We also need both effects to be wellformed, and we put this information
% in the relation.

effects`join/
  : efxmap`domain M1 R1
    -> efxmap`domain M2 R2
    -> set`disjoint S1 R1 % cannot have both consume and read/write
    -> set`disjoint S2 R2 % same as above
    -> set`disjoint S1 R2 % consume cannot precede read/write
    -> set`disjoint S1 S2 % cannot consume twice
    -> set`remove R1 S2 S3
    -> efxmap`restrict M1 S3 M1'
    -> efxmap`join M1' M2 M
    -> set`union S1 S2 S
    -> shared-efx`join X1 X2 X
    -> effects`join (effects/ M1 S1 X1) (effects/ M2 S2 X2) (effects/ M S X).


% read/write efx in M1 is "covered" by consume efx in S2

effects`leq : effects -> effects -> type.

effects`leq/
  : efxmap`domain M1 R1
    -> efxmap`domain M2 R2
    -> set`remove R1 S2 S3
    -> efxmap`restrict M1 S3 M1'
    -> efxmap`leq M1' M2
    -> set`leq S1 S2
    -> shared-efx`leq X1 X2
    -> effects`leq (effects/ M1 S1 X1) (effects/ M2 S2 X2).


% disjoint

effects`disjoint : effects -> effects -> type.

% precondition is M1^S1, M2^S2

effects`disjoint/
  : efxmap`disjoint M1 M2
    -> set`disjoint S1 S2
    -> shared-efx`disjoint X1 X2
    -> effects`disjoint (effects/ M1 S1 X1) (effects/ M2 S2 X2).


%%% Theorems

%theorem shared-efx`join-unique
  : forall* {SX1} {SX2} {SX1'} {SX2'} {SX} {SX'}
    forall {J: shared-efx`join SX1 SX2 SX}
    {J': shared-efx`join SX1' SX2' SX'}
    {E1: shared-efx`eq SX1 SX1'} {E2: shared-efx`eq SX2 SX2'}
    exists {E: shared-efx`eq SX SX'}
    true.

- : shared-efx`join-unique J J shared-efx`eq/ shared-efx`eq/ shared-efx`eq/.

- : shared-efx`join-unique shared-efx`join/L shared-efx`join/R
    shared-efx`eq/ shared-efx`eq/ shared-efx`eq/.

- : shared-efx`join-unique shared-efx`join/R shared-efx`join/L
    shared-efx`eq/ shared-efx`eq/ shared-efx`eq/.

%worlds () (shared-efx`join-unique _ _ _ _ _).
%total {} (shared-efx`join-unique _ _ _ _ _).


%theorem shared-efx`join-implies-leq
  : forall* {SX1} {SX2} {SX}
    forall {J: shared-efx`join SX1 SX2 SX}
    exists {L1: shared-efx`leq SX1 SX}
    {L2: shared-efx`leq SX2 SX}
    true.

%worlds () (shared-efx`join-implies-leq _ _ _).
%trustme %total {} (shared-efx`join-implies-leq _ _ _).


%theorem shared-efx`leq-transitive
  : forall* {SX1} {SX2} {SX3}
    forall {SX1<=SX2: shared-efx`leq SX1 SX2}
    {SX2<=SX3: shared-efx`leq SX2 SX3}
    exists {SX1<=SX3: shared-efx`leq SX1 SX3}
    true.

%worlds () (shared-efx`leq-transitive _ _ _).
%trustme %total {} (shared-efx`leq-transitive _ _ _).


%theorem shared-efx`join-commutative
  : forall* {SX1} {SX2} {SX}
    forall {J: shared-efx`join SX1 SX2 SX}
    exists {J: shared-efx`join SX2 SX1 SX}
    true.

%worlds () (shared-efx`join-commutative _ _).
%trustme %total {} (shared-efx`join-commutative _ _).


%theorem shared-efx`join-associative
  : forall* {SX1} {SX2} {SX3} {SX4} {SX5}
    forall {SX1+SX2=SX3: shared-efx`join SX1 SX2 SX3}
    {SX3+SX4=SX5: shared-efx`join SX3 SX4 SX5}
    exists {SX6} {SX2+SX4=SX6: shared-efx`join SX2 SX4 SX6}
    {SX1+SX6=SX5: shared-efx`join SX1 SX6 SX5}
    true.

%worlds () (shared-efx`join-associative _ _ _ _ _).
%trustme %total {} (shared-efx`join-associative _ _ _ _ _).


%theorem shared-efx`join-associative-converse
  : forall* {SX1} {SX2} {SX6} {SX4} {SX5}
    forall {SX2+SX4=SX6: shared-efx`join SX2 SX4 SX6}
    {SX1+SX6=SX5: shared-efx`join SX1 SX6 SX5}
    exists {SX3} {SX1+SX2=SX3: shared-efx`join SX1 SX2 SX3}
    {SX3+SX4=SX5: shared-efx`join SX3 SX4 SX5}
    true.

%worlds () (shared-efx`join-associative-converse _ _ _ _ _).
%trustme %total {} (shared-efx`join-associative-converse _ _ _ _ _).


%theorem shared-efx`disjoint-symmetric
  : forall* {X1} {X2}
    forall {D: shared-efx`disjoint X1 X2}
    exists {D: shared-efx`disjoint X2 X1}
    true.

- : shared-efx`disjoint-symmetric shared-efx`disjoint/L shared-efx`disjoint/R.

- : shared-efx`disjoint-symmetric shared-efx`disjoint/R shared-efx`disjoint/L.

%worlds () (shared-efx`disjoint-symmetric _ _).
%total {} (shared-efx`disjoint-symmetric _ _).



%%% Theorems about effects

%theorem effects`eq-inversion
  : forall* {M1} {M2} {X1} {X2} {S1} {S2}
    forall {E: effects`eq (effects/ M1 S1 X1) (effects/ M2 S2 X2)}
    exists {ME: efxmap`eq M1 M2} {SE: set`eq S1 S2} {E: shared-efx`eq X1 X2}
    true.

- : effects`eq-inversion effects`eq/ efxmap`eq/ set`eq/ shared-efx`eq/.

%worlds () (effects`eq-inversion _ _ _ _).
%total {} (effects`eq-inversion _ _ _ _).


%theorem effects/-preserves-eq
  : forall* {M} {M'} {X} {X'} {S} {S'}
    forall {ME: efxmap`eq M M'} {SE: set`eq S S'} {XE: shared-efx`eq X X'}
    exists {E: effects`eq (effects/ M S X) (effects/ M' S' X')}
    true.

- : effects/-preserves-eq efxmap`eq/ set`eq/ shared-efx`eq/ effects`eq/.

%worlds () (effects/-preserves-eq _ _ _ _).
%total {} (effects/-preserves-eq _ _ _ _).


%theorem effects`join-unique
  : forall* {XX1} {XX1'} {XX2} {XX2'} {XX} {XX'}
    forall {J: effects`join XX1 XX2 XX}
    {J': effects`join XX1' XX2' XX'}
    {E: effects`eq XX1 XX1'} {E: effects`eq XX2 XX2'}
    exists {E: effects`eq XX XX'}
    true.

- : effects`join-unique
    (effects`join/ DM-M1=R1 DM-M2=R2 _ _ _ _ R1/S2=S3
      M1|S3=M1' M1'+M2=M S1+S2=S X1+X2=X)
    (effects`join/ DM-MP1=RP1 DM-MP2=RP2 _ _ _ _ RP1/SP2=SP3
      MP1|SP3=MP1' MP1'+MP2=MP SP1+SP2=SP XP1+XP2=XP) E1 E2 E
    <- effects`eq-inversion E1 M1=MP1 S1=SP1 X1=XP1
    <- effects`eq-inversion E2 M2=MP2 S2=SP2 X2=XP2
    <- efxmap`domain-unique DM-M1=R1 DM-MP1=RP1 M1=MP1 R1=RP1
    <- efxmap`domain-unique DM-M2=R2 DM-MP2=RP2 M2=MP2 R2=RP2
    <- set`remove-unique R1/S2=S3 RP1/SP2=SP3 R1=RP1 S2=SP2 S3=SP3
    <- efxmap`restrict-unique M1|S3=M1' MP1|SP3=MP1' M1=MP1 S3=SP3 M1'=MP1'
    <- efxmap`join-unique M1'+M2=M MP1'+MP2=MP M1'=MP1' M2=MP2 M=MP
    <- set`union-unique S1+S2=S SP1+SP2=SP S1=SP1 S2=SP2 S=SP
    <- shared-efx`join-unique X1+X2=X XP1+XP2=XP X1=XP1 X2=XP2 X=XP
    <- effects/-preserves-eq M=MP S=SP X=XP E.

%worlds () (effects`join-unique _ _ _ _ _ ).
%total {} (effects`join-unique _ _ _ _ _ ).


%theorem effects`join-implies-leq
  : forall* {XX1} {XX2} {XX}
    forall {J1: effects`join XX1 XX2 XX}
    exists {L1: effects`leq XX1 XX}
    {L2: effects`leq XX2 XX}
    true.

- : effects`join-implies-leq (effects`join/ DM-M1=R1 DM-M2=R2 S1^R1 S2^R2
                               S1^R2 S1^S2 R1/S2=S3 M1|S3=M1' M1'+M2=M
                               S1+S2=S X1+X2=X)
    (effects`leq/ DM-M1=R1 DM-M=R R1/S=S3 M1|S3=M1' M1'<=M S1<=S X1<=X)
    (effects`leq/ DM-M2=R2 DM-M=R R2/S=R2 M2|R2=M2 M2<=M S2<=S X2<=X)
    <- efxmap`domain-total DM-M=R
    <- efxmap`join-implies-leq M1'+M2=M M1'<=M M2<=M
    <- set`union-implies-leq S1+S2=S S1<=S S2<=S
    <- shared-efx`join-implies-leq X1+X2=X X1<=X X2<=X
    <- set`union-commutative S1+S2=S S2+S1=S
    <- set`remove-total R1/S=Q3
    <- set`remove-associates-union-converse* S2+S1=S R1/S=Q3 R1/S2=S3 S3/S1=Q3
    <- set`disjoint-symmetric S1^R1 R1^S1
    <- set`remove-implies-leq R1/S2=S3 S3<=R1
    <- set`disjoint-respects-geq* R1^S1 S3<=R1 S3^S1
    <- set`disjoint-implies-remove-nothing S3^S1 S3/S1=S3
    <- set`remove-unique S3/S1=Q3 S3/S1=S3 set`eq/ set`eq/ Q3=S3
    <- set`remove-respects-eq R1/S=Q3 set`eq/ set`eq/ Q3=S3 R1/S=S3
    <- set`union-preserves-disjoint* S1^R2 S2^R2 S1+S2=S S^R2
    <- set`disjoint-symmetric S^R2 R2^S
    <- set`disjoint-implies-remove-nothing R2^S R2/S=R2
    <- set`leq-reflexive _ R2<=R2
    <- efxmap`domain-leq-implies-no-restriction DM-M2=R2 R2<=R2 M2|R2=M2.

%worlds () (effects`join-implies-leq _ _ _).
%total {} (effects`join-implies-leq _ _ _).


% this is tedius..

%theorem effects`join-associative :
	forall* {XX1} {XX2} {XX3} {XX4} {XX7}
	forall {A12:effects`join XX1 XX2 XX3} {A34:effects`join XX3 XX4 XX7}
	exists {XX6} {A24:effects`join XX2 XX4 XX6} {A16:effects`join XX1 XX6 XX7}
	true.

%theorem effects`join-associative/L1
  : forall* {M1} {M2} {M} {S1} {S2} {S} {Q} {S1'} {S2'} {S'}
    {M1'} {M2'} {M'}
    forall {J: efxmap`join M1 M2 M}
    {DM1: efxmap`domain M1 S1} {R1: set`remove S1 Q S1'}
    {DM2: efxmap`domain M2 S2} {R2: set`remove S2 Q S2'}
    {DM3: efxmap`domain M S} {R: set`remove S Q S'}
    {RS1: efxmap`restrict M1 S1' M1'}
    {RS2: efxmap`restrict M2 S2' M2'}
    {RS: efxmap`restrict M S' M'}
    exists {J: efxmap`join M1' M2' M'}
    true.

- : effects`join-associative/L1
    M1+M2=M DM-M1=S1 S1/Q=S1' DM-M2=S2 S2/Q=S2' DM-M=S S/Q=S'
    M1|S1'=M1' M2|S2'=M2' M|S'=M' M1'+M2'=M'
    <- efxmap`restrict-total M1|Q=M1''
    <- efxmap`restrict-total M2|Q=M2''
    <- efxmap`restrict-total (M|Q=M'':restrict M Q M'')
    <- efxmap`partition-implies-disjoint-join
      (partition/ DM-M1=S1 S1/Q=S1' M1|S1'=M1' M1|Q=M1'') M1'^M1'' M1'+M1''=M1
    <- efxmap`partition-implies-disjoint-join
      (partition/ DM-M2=S2 S2/Q=S2' M2|S2'=M2' M2|Q=M2'') M2'^M2'' M2'+M2''=M2
    <- efxmap`partition-implies-disjoint-join
      (partition/ DM-M=S S/Q=S' M|S'=M' M|Q=M'') M'^M'' M'+M''=M
    <- efxmap`join-double-associative M1'+M1''=M1 M2'+M2''=M2 M1+M2=M
      K1 K2 M1'+M2'=K1 M1''+M2''=K2 K1+K2=M
    <- efxmap`join-commute-restrict*
      M1+M2=M M1|Q=M1'' M2|Q=M2'' M|Q=M'' M1''+M2''=M''
    <- efxmap`join-unique
      M1''+M2''=K2 M1''+M2''=M'' efxmap`eq/ efxmap`eq/ K2=M''
    <- efxmap`join-respects-eq K1+K2=M efxmap`eq/ K2=M'' efxmap`eq/ K1+M''=M
    <- set`remove-implies-disjoint S1/Q=S1' Q^S1'
    <- set`remove-implies-disjoint S2/Q=S2' Q^S2'
    <- set`remove-implies-disjoint S/Q=S' Q^S'
    <- efxmap`restrict-implies-domain-leq M1|S1'=M1' R1 DM-M1'=R1 R1<=S1'
    <- efxmap`restrict-implies-domain-leq M2|S2'=M2' R2 DM-M2'=R2 R2<=S2'
    <- efxmap`restrict-implies-domain-leq M1|Q=M1'' P1 DM-M1''=P1 P1<=Q
    <- efxmap`restrict-implies-domain-leq M2|Q=M2'' P2 DM-M2''=P2 P2<=Q
    <- set`disjoint-respects-geq Q^S1' P2<=Q R1<=S1' P2^R1
    <- set`disjoint-respects-geq Q^S2' P1<=Q R2<=S2' P1^R2
    <- efxmap`domain-preserves-disjoint-converse
      P2^R1 DM-M2''=P2 DM-M1'=R1 M2''^M1'
    <- efxmap`domain-preserves-disjoint-converse
      P1^R2 DM-M1''=P1 DM-M2'=R2 M1''^M2'
    <- efxmap`disjoint-symmetric M2''^M1' M1'^M2''
    <- efxmap`disjoint-symmetric M1''^M2' M2'^M1''
    <- efxmap`join-preserves-disjoint* M1'^M1'' M2'^M1'' M1'+M2'=K1 K1^M1''
    <- efxmap`join-preserves-disjoint* M1'^M2'' M2'^M2'' M1'+M2'=K1 K1^M2''
    <- efxmap`join-right-preserves-disjoint* K1^M1'' K1^M2'' M1''+M2''=K2 K1^K2
    <- efxmap`disjoint-join-right-cancels
      K1^K2 K1+K2=M M'^M'' M'+M''=M K2=M'' efxmap`eq/ K1=M'
    <- efxmap`join-respects-eq
      M1'+M2'=K1 efxmap`eq/ efxmap`eq/ K1=M' M1'+M2'=M'.

%worlds () (effects`join-associative/L1 _ _ _ _ _ _ _ _ _ _ _).
%total {} (effects`join-associative/L1 _ _ _ _ _ _ _ _ _ _ _).


%theorem effects`join-associative/L3
  : forall* {M} {M'} {S} {N} {D}
    forall {R: restrict M S M'}
    {N<-M: efxmap`lookup M N D}
    {N!<M': efxmap`fresh M' N}
    exists {N!<S: set`not-member S N}
    true.

%theorem effects`join-associative/L3L
  : forall* {M} {M'} {S} {N} {D}
    forall {R: restrict M S M'}
    {N<-M: efxmap`lookup M N D}
    {N!<M': efxmap`fresh M' N}
    {B} {IN?: set`member? S N B}
    exists {N!<S: set`not-member S N}
    true.

- : effects`join-associative/L3L
    M|S=M' M->N=D N!<M' _ (set`member?/in N<-S) N!<S
    <- efxmap`restrict-preserves-lookup M->N=D M|S=M' N<-S M'->N=D
    <- efxmap`fresh-lookup-not-equal N!<M' M'->N=D N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- set`false-implies-not-member F N!<S.

- : effects`join-associative/L3L _ _ _ _ (set`member?/out N!<S) N!<S.

- : effects`join-associative/L3 R MB F IN
    <- set`member?-total MB?
    <- effects`join-associative/L3L R MB F _ MB? IN.

%worlds () (effects`join-associative/L3L _ _ _ _ _ _).
%total {} (effects`join-associative/L3L _ _ _ _ _ _).

%worlds () (effects`join-associative/L3 _ _ _ _).
%total {} (effects`join-associative/L3 _ _ _ _).



%theorem effects`join-associative/L2
  : forall* {R1} {R1'} {S2} {Q1} {M} {M'} {S6} {Q4} {B}
    forall {DM1: efxmap`domain M R1}
    {DM1': efxmap`domain M' R1'}
    {RS: efxmap`restrict M Q1 M'}
    {NLE: set`leq? Q4 R1' B}
    {RM: set`remove R1 S6 Q4}
    {RM: set`remove R1 S2 Q1}
    {J: set`leq S2 S6}
    exists {LE: set`leq Q4 R1'}
    true.

- : effects`join-associative/L2 DM-M=R1 DM-M'=R1' M|Q1=M'
    (set`leq?/no (set`nle/< N<-Q4 N!<R1')) R1/S6=Q4 R1/S2=Q1 S2<=S6 Q4<=R1'
    <- set`remove-implies-leq R1/S6=Q4 Q4<=R1
    <- set`remove-implies-disjoint R1/S6=Q4 S6^Q4
    <- set`disjoint-symmetric S6^Q4 Q4^S6
    <- set`disjoint-lookup-implies-not-member N<-Q4 Q4^S6 N!<S6
    <- set`member-respects-leq N<-Q4 Q4<=R1 N<-R1
    <- efxmap`restrict-implies-domain-leq* M|Q1=M' DM-M'=R1' R1'<=Q1
    <- efxmap`domain-preserves-lookup-converse N<-R1 DM-M=R1 _ M->N=D
    <- efxmap`domain-preserves-fresh-converse N!<R1' DM-M'=R1' N!<M'
    <- effects`join-associative/L3 M|Q1=M' M->N=D N!<M' N!<Q1
    <- set`union-total S2+Q1=P
    <- set`remove-implies-leq-union R1/S2=Q1 S2+Q1=P R1<=P
    <- set`remove-implies-disjoint R1/S2=Q1 S2^Q1
    <- set`member-respects-leq N<-R1 R1<=P N<-P
    <- set`not-member-union-right-preserves-member-converse
      N<-P N!<Q1 S2+Q1=P N<-S2
    <- set`member-respects-leq N<-S2 S2<=S6 N<-S6
    <- set`not-member-member-not-equal N!<S6 N<-S6 N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- set`false-implies-leq V Q4<=R1'.

- : effects`join-associative/L2 _ _ _ (set`leq?/yes Q4<=R1') _ _ _ Q4<=R1'.

%worlds () (effects`join-associative/L2 _ _ _ _ _ _ _ _).
%total {} (effects`join-associative/L2 _ _ _ _ _ _ _ _).


% this is a mess and I think some of the following are
% just garbage, but I don't care since what done is done!

- : effects`join-associative
    (effects`join/ DM-M1=R1 DM-M2=R2 S1^R1 S2^R2 S1^R2 S1^S2 R1/S2=Q1
      M1|Q1=M1' M1'+M2=M3 S1+S2=S3 X1+X2=X3)
    (effects`join/ DM-M3=R3 DM-M4=R4 S3^R3 S4^R4 S3^R4 S3^S4 R3/S4=Q2
      M3|Q2=M3' M3'+M4=M7 S3+S4=S7 X3+X4=X7)
    _ (effects`join/ DM-M2=R2 DM-M4=R4 S2^R2 S4^R4 S2^R4 S2^S4 R2/S4=Q3
      M2|Q3=M2' M2'+M4=M6 S2+S4=S6 X2+X4=X6)
    (effects`join/ DM-M1=R1 DM-M6=R6 S1^R1 S6^R6 S1^R6 S1^S6 R1/S6=Q4
      M1|Q4=M1'' M1''+M6=M7 S1+S6=S7 X1+X6=X7)
    <- set`union-associative S1+S2=S3 S3+S4=S7 S6 S2+S4=S6 S1+S6=S7
    <- set`union-implies-leq S1+S2=S3 S1<=S3 S2<=S3
    <- set`disjoint-respects-geq* S3^R4 S2<=S3 S2^R4
    <- set`remove-total (R1/S6=Q4:set`remove R1 S6 Q4)
    <- set`remove-associates-union-converse* S2+S4=S6 R1/S6=Q4 R1/S2=Q1
      (Q1/S4=Q4:set`remove Q1 S4 Q4)
    <- efxmap`domain-total (DM-M1'=R1':efxmap`domain M1' R1')
    <- efxmap`restrict-total M1'|Q4=M1''
    <- set`remove-implies-leq Q1/S4=Q4 Q4<=Q1
    <- set`leq-implies-intersection Q4<=Q1 Q4^Q1=Q4
    <- set`intersection-commutative Q4^Q1=Q4 Q1^Q4=Q4
    <- efxmap`restrict-associates-intersection*
      M1|Q1=M1' M1'|Q4=M1'' Q1^Q4=Q4 M1|Q4=M1''
    <- set`remove-total (R2/S4=Q3:set`remove R2 S4 Q3)
    <- set`leq?-total Q4<=R1'?
    <- set`union-implies-leq S2+S4=S6 S2<=S6 S4<=S6
    <- effects`join-associative/L2 DM-M1=R1 DM-M1'=R1' M1|Q1=M1'
      Q4<=R1'? R1/S6=Q4 R1/S2=Q1 S2<=S6 Q4<=R1'
    <- set`remove-implies-disjoint R1/S6=Q4 S6^Q4
    <- set`disjoint-respects-geq* S6^Q4 S4<=S6 S4^Q4
    <- set`union-total S4+Q4=U
    <- set`remove-implies-leq-union Q1/S4=Q4 S4+Q4=U Q1<=U
    <- efxmap`restrict-implies-domain-leq* M1|Q1=M1' DM-M1'=R1' R1'<=Q1
    <- set`leq-transitive R1'<=Q1 Q1<=U R1'<=U
    <- set`remove-characterization Q4<=R1' S4^Q4 S4+Q4=U R1'<=U R1'/S4=Q4
    <- efxmap`restrict-total M2|Q3=M2'
    <- effects`join-associative/L1 M1'+M2=M3 DM-M1'=R1' R1'/S4=Q4
      DM-M2=R2 R2/S4=Q3 DM-M3=R3 R3/S4=Q2 M1'|Q4=M1''
      M2|Q3=M2' M3|Q2=M3' M1''+M2'=M3'
    <- efxmap`join-associative M1''+M2'=M3' M3'+M4=M7 M6 M2'+M4=M6 M1''+M6=M7
    <- shared-efx`join-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7
    <- set`disjoint-respects-geq* S3^S4 S2<=S3 S2^S4
    <- set`disjoint-respects-geq* S3^S4 S1<=S3 S1^S4
    <- set`disjoint-respects-geq* S3^R4 S1<=S3 S1^R4
    <- efxmap`restrict-implies-leq M2|Q3=M2' M2'<=M2
    <- efxmap`domain-total DM-M2'=R2'
    <- efxmap`domain-preserves-leq* M2'<=M2 DM-M2'=R2' DM-M2=R2 R2'<=R2
    <- set`leq-reflexive _ S1<=S1
    <- set`leq-reflexive _ S2<=S2
    <- set`disjoint-respects-geq S1^R2 S1<=S1 R2'<=R2 S1^R2'
    <- set`disjoint-respects-geq S2^R2 S2<=S2 R2'<=R2 S2^R2'
    <- efxmap`domain-total DM-M6=R6
    <- efxmap`join-commute-domain M2'+M4=M6 DM-M2'=R2' DM-M4=R4
      DM-M6=R6 (R2'+R4=R6:set`union R2' R4 R6)
    <- set`union-implies-leq R2'+R4=R6 R2'<=R6 R4<=R6
    <- set`union-right-preserves-disjoint* S1^R2' S1^R4 R2'+R4=R6 S1^R6
    <- set`union-right-preserves-disjoint* S2^R2' S2^R4 R2'+R4=R6 S2^R6
    <- set`remove-implies-disjoint R2/S4=Q3 S4^Q3
    <- efxmap`restrict-implies-domain-leq* M2|Q3=M2' DM-M2'=R2' R2'<=Q3
    <- set`leq-reflexive _ S4<=S4
    <- set`disjoint-respects-geq S4^Q3 S4<=S4 R2'<=Q3 S4^R2'
    <- set`union-right-preserves-disjoint* S4^R2' S4^R4 R2'+R4=R6 S4^R6
    <- set`union-preserves-disjoint* S2^R6 S4^R6 S2+S4=S6 S6^R6
    <- set`union-right-preserves-disjoint* S1^S2 S1^S4 S2+S4=S6 S1^S6.

%worlds () (effects`join-associative _ _ _ _ _).
%total {}  (effects`join-associative _ _ _ _ _).


%theorem effects`join-associative-converse
: forall* {XX1} {XX2} {XX4} {XX6} {XX7}
	forall {A24:effects`join XX2 XX4 XX6}
  {A16:effects`join XX1 XX6 XX7}
	exists {XX3}
  {A12:effects`join XX1 XX2 XX3}
  {A34:effects`join XX3 XX4 XX7}
	true.

%worlds () (effects`join-associative-converse _ _ _ _ _).
%trustme %total {} (effects`join-associative-converse _ _ _ _ _).


%theorem effects`disjoint-symmetric
  : forall* {XX1} {XX2}
    forall {X12: effects`disjoint XX1 XX2}
    exists {X21: effects`disjoint XX2 XX1}
    true.

%worlds () (effects`disjoint-symmetric _ _).
%trustme %total {} (effects`disjoint-symmetric _ _).


%theorem effects`leq-transitive
  : forall* {XX1} {XX2} {XX3}
    forall {L12: effects`leq XX1 XX2}
    {L23: effects`leq XX2 XX3}
    exists {L13: effects`leq XX1 XX3}
    true.

%worlds () (effects`leq-transitive _ _ _ ).
%trustme %total {} (effects`leq-transitive _ _ _ ).