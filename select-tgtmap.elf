%%% Select corresponding entries in target map from an effect map.
%%% The output is two effect maps which are deep-disjoint,
%%% and can join back to get the original effect map.


% =============================================
% ================= Definitions ===============
% =============================================

select-tgtmap : efxmap -> tgtmap -> efxmap -> efxmap -> type.

select-set : inner-efxmap -> set -> inner-efxmap -> inner-efxmap -> type.

select-set/0 : select-set inner-efxmap/0 _ inner-efxmap/0 inner-efxmap/0.

select-set/U/in
  : select-set M S M1 M2
    <- inner-efxmap`fresh MP F
    <- inner-efxmap`update MP F X M
    <- set`member S F
    <- select-set MP S M1 M2P
    <- inner-efxmap`update M2P F X M2.

select-set/U/out
  : select-set M S M1 M2
    <- inner-efxmap`fresh MP F
    <- inner-efxmap`update MP F X M
    <- set`not-member S F
    <- select-set MP S M1P M2
    <- inner-efxmap`update M1P F X M1.


select-tgtmap/0 : select-tgtmap efxmap/0 _ efxmap/0 efxmap/0.

select-tgtmap/U/in
  : select-tgtmap XM GM XM1 XM2
    <- efxmap`fresh XMP N
    <- efxmap`update XMP N M XM
    <- tgtmap`lookup GM N S
    <- select-set M S M1 M2
    <- select-tgtmap XMP GM XM1P XM2P
    <- efxmap`update XM1P N M1 XM1
    <- efxmap`update XM2P N M2 XM2.

select-tgtmap/U/out
  : select-tgtmap XM GM XM1 XM2
    <- efxmap`fresh XMP N
    <- efxmap`update XMP N M XM
    <- tgtmap`fresh GM N
    <- select-tgtmap XMP GM XM1P XM2
    <- efxmap`update XM1P N M XM1.


%%% A tgtmap in which all values are empty sets.

equiv-empty : tgtmap -> type.

equiv-empty/0 : equiv-empty tgtmap/0.

equiv-empty/U
  : equiv-empty MP
    -> tgtmap`fresh MP N
    -> tgtmap`update MP N set/0 M
    -> equiv-empty M.

%% Same definition on efxmap will be piggy-packed on tgtmap.


% =============================================
% ================= Theorems ==================
% =============================================

%theorem false-implies-select-set
  : forall* {M} {S} {M1} {M2}
    forall {V:void}
    exists {SS: select-set M S M1 M2}
    true.

%worlds () (false-implies-select-set _ _).
%total {} (false-implies-select-set _ _).


%theorem false-implies-select-tgtmap
  : forall* {XM} {GM} {XM1} {XM2}
    forall {V:void}
    exists {SM: select-tgtmap XM GM XM1 XM2}
    true.

%worlds () (false-implies-select-tgtmap _ _).
%total {} (false-implies-select-tgtmap _ _).


%theorem select-set-respects-eq
  : forall* {M} {MP} {S} {S'} {M1} {M1P} {M2} {M2P}
    forall {SS: select-set M S M1 M2}
    {E: inner-efxmap`eq M MP} {E: set`eq S S'}
    {E: inner-efxmap`eq M1 M1P} {E: inner-efxmap`eq M2 M2P}
    exists {SS: select-set MP S' M1P M2P}
    true.

- : select-set-respects-eq SS inner-efxmap`eq/ set`eq/
    inner-efxmap`eq/ inner-efxmap`eq/ SS.

%worlds () (select-set-respects-eq _ _ _ _ _ _).
%total {} (select-set-respects-eq _ _ _ _ _ _).


%theorem select-tgtmap-respects-eq
  : forall* {XM} {XMP} {GM} {GMP} {XM1} {XM1P} {XM2} {XM2P}
    forall {SS: select-tgtmap XM GM XM1 XM2}
    {E: efxmap`eq XM XMP} {E: tgtmap`eq GM GMP}
    {E: efxmap`eq XM1 XM1P} {E: efxmap`eq XM2 XM2P}
    exists {SS: select-tgtmap XMP GMP XM1P XM2P}
    true.

- : select-tgtmap-respects-eq SS efxmap`eq/ tgtmap`eq/
    efxmap`eq/ efxmap`eq/ SS.

%worlds () (select-tgtmap-respects-eq _ _ _ _ _ _).
%total {} (select-tgtmap-respects-eq _ _ _ _ _ _).


%theorem select-set-total*
  : forall {M} {S}
    exists {M1} {M2}
    {SS: select-set M S M1 M2}
    true.

%abbrev select-set-total = select-set-total* _ _ _ _.

%theorem select-set-total*/L1
  : forall* {M} {S}
    forall {N} {SZ: inner-efxmap`size M N}
    exists {M1} {M2} {SS: select-set M S M1 M2}
    true.

- : select-set-total*/L1 z _ _ _ select-set/0.

%theorem select-set-total*/L2
  : forall* {S} {N} {MP} {M1P} {M2P} {X} {M}
    forall {B} {IN?: set`member? S N B}
    {SS: select-set MP S M1P M2P}
    {FS: inner-efxmap`fresh MP N}
    {U: inner-efxmap`update MP N X M}
    exists {M1} {M2} {SS: select-set M S M1 M2}
    true.

- : select-set-total*/L2 false (set`member?/out OUT)
    SS-MP F U _ _ (select-set/U/out U' SS-MP OUT U F)
    <- inner-efxmap`update-total U'.

- : select-set-total*/L2 true (set`member?/in IN)
    SS-MP F U _ _ (select-set/U/in U' SS-MP IN U F)
    <- inner-efxmap`update-total U'.

%worlds () (select-set-total*/L2 _ _ _ _ _ _ _ _).
%total {} (select-set-total*/L2 _ _ _ _ _ _ _ _).


- : select-set-total*/L1 (s N) SZ  _ _ SS-M
    <- inner-efxmap`lookup-implies-fresh-update
      (inner-efxmap`lookup/= nat`eq/) MP F U
    <- inner-efxmap`fresh-update-increases-size-converse SZ F U SZ'
    <- set`member?-total IN?
    <- select-set-total*/L1 N SZ' _ _ SS-MP
    <- select-set-total*/L2 _ IN? SS-MP F U _ _ SS-M.

%worlds () (select-set-total*/L1 _ _ _ _ _).
%total (N) (select-set-total*/L1 N _ _ _ _).

- : select-set-total* _ _ _ _ SS
    <- inner-efxmap`size-total SZ
    <- select-set-total*/L1 _ SZ _ _ SS.

%worlds () (select-set-total* _ _ _ _ _).
%total {} (select-set-total* _ _ _ _ _).


%theorem select-tgtmap-total*
  : forall {XM} {GM}
    exists {XM1} {XM2}
    {SGM: select-tgtmap XM GM XM1 XM2}
    true.

%abbrev select-tgtmap-total = select-tgtmap-total* _ _ _ _.

%theorem select-tgtmap-total*/L1
  : forall* {XM} {GM}
    forall {N} {SZ: efxmap`size XM N}
    exists {XM1} {XM2}
    {SGM: select-tgtmap XM GM XM1 XM2}
    true.

- : select-tgtmap-total*/L1 z _ _ _ select-tgtmap/0.

%theorem select-tgtmap-total*/L2
  : forall* {N} {M} {XM} {XMP} {GM} {XM1P} {XM2P}
    forall {B} {MB?: tgtmap`domain? GM N B}
    {F: efxmap`fresh XMP N} {U: efxmap`update XMP N M XM}
    {SXMP: select-tgtmap XMP GM XM1P XM2P}
    exists {XM1} {XM2}
    {SGM: select-tgtmap XM GM XM1 XM2}
    true.

- : select-tgtmap-total*/L2 true (tgtmap`domain?/in L)
    F U SS-XMP _ _ (select-tgtmap/U/in U1' U2' SS-XMP SS-M L U F)
    <- select-set-total SS-M
    <- efxmap`update-total U1'
    <- efxmap`update-total U2'.

- : select-tgtmap-total*/L2 false (tgtmap`domain?/out F')
    F U SS-XMP _ _ (select-tgtmap/U/out U' SS-XMP F' U F)
    <- efxmap`update-total U'.

%worlds () (select-tgtmap-total*/L2 _ _ _ _ _ _ _ _).
%total {} (select-tgtmap-total*/L2 _ _ _ _ _ _ _ _).


- : select-tgtmap-total*/L1 (s N) SZ _ _ SS-XM
    <- efxmap`lookup-implies-fresh-update (efxmap`lookup/= nat`eq/) _ F U
    <- efxmap`fresh-update-increases-size-converse SZ F U SZ'
    <- tgtmap`domain?-total IN?
    <- select-tgtmap-total*/L1 N SZ' _ _ SS-XMP
    <- select-tgtmap-total*/L2 _ IN? F U SS-XMP _ _ SS-XM.

%worlds () (select-tgtmap-total*/L1 _ _ _ _ _).
%total (N) (select-tgtmap-total*/L1 N _ _ _ _).

- : select-tgtmap-total* _ _ _ _ SS-XM
    <- efxmap`size-total SZ
    <- select-tgtmap-total*/L1 _ SZ _ _ SS-XM.

%worlds () (select-tgtmap-total* _ _ _ _ _).
%total {} (select-tgtmap-total* _ _ _ _ _).


%theorem select-set-implies-leq
  : forall* {M} {S} {M1} {M2}
    forall {SS: select-set M S M1 M2}
    exists {LE: inner-efxmap`leq M1 M} {LE: inner-efxmap`leq M2 M}
    true.

- : select-set-implies-leq select-set/0 inner-efxmap`leq/0 inner-efxmap`leq/0.

- : select-set-implies-leq
    (select-set/U/in U2 SS' _ U F) LE1 LE2
    <- inner-efxmap`fresh-update-implies-leq F U LE
    <- select-set-implies-leq SS' LE1' LE2'
    <- inner-efxmap`update-preserves-leq* LE2' (efx`leq/eq efx`eq/) U2 U LE2
    <- inner-efxmap`leq-transitive LE1' LE LE1.

- : select-set-implies-leq
    (select-set/U/out U1 SS' _ U F) LE1 LE2
    <- inner-efxmap`fresh-update-implies-leq F U LE
    <- select-set-implies-leq SS' LE1' LE2'
    <- inner-efxmap`update-preserves-leq* LE1' (efx`leq/eq efx`eq/) U1 U LE1
    <- inner-efxmap`leq-transitive LE2' LE LE2.

%worlds () (select-set-implies-leq _ _ _).
%total (SS) (select-set-implies-leq SS _ _).


%theorem select-tgtmap-implies-leq
  : forall* {XM} {GM} {XM1} {XM2}
    forall {SS: select-tgtmap XM GM XM1 XM2}
    exists {LE: efxmap`leq XM1 XM} {LE: efxmap`leq XM2 XM}
    true.

- : select-tgtmap-implies-leq select-tgtmap/0 efxmap`leq/0 efxmap`leq/0.

- : select-tgtmap-implies-leq
    (select-tgtmap/U/in U2 U1 SS-XMP SS-M _ U F) LE1 LE2
    <- select-tgtmap-implies-leq SS-XMP LE1' LE2'
    <- select-set-implies-leq SS-M M-LE1 M-LE2
    <- efxmap`update-preserves-leq* LE1' M-LE1 U1 U LE1
    <- efxmap`update-preserves-leq* LE2' M-LE2 U2 U LE2.

- : select-tgtmap-implies-leq
    (select-tgtmap/U/out U1 SS-XMP _ U F) LE1 LE2
    <- efxmap`fresh-update-implies-leq F U LE
    <- select-tgtmap-implies-leq SS-XMP LE1' LE2'
    <- inner-efxmap`leq-reflexive _ M-LE
    <- efxmap`update-preserves-leq* LE1' M-LE U1 U LE1
    <- efxmap`leq-transitive LE2' LE LE2.

%worlds () (select-tgtmap-implies-leq _ _ _).
%total (SS) (select-tgtmap-implies-leq SS _ _).


%theorem select-set/in-inversion
  : forall* {M} {MP} {N} {X} {S} {M1} {M2}
    forall {SS: select-set M S M1 M2}
    {MB: set`member S N}
    {F: inner-efxmap`fresh MP N}
    {U: inner-efxmap`update MP N X M}
    exists {M2P} {SS: select-set MP S M1 M2P}
    {U: inner-efxmap`update M2P N X M2}
    true.

%theorem select-set/in-inversion/in
  : forall*{F1} {F2} {M2S} {MS} {M1} {M2} {S} {X1} {X2} {MP} {B} {M}
    forall {U2S: inner-efxmap`update M2S F1 X1 M2}
    {SS: select-set MS S M1 M2S}
    {MB: set`member S F1}
    {U1: inner-efxmap`update MS F1 X1 M}
    {FS1: inner-efxmap`fresh MS F1}
    {MB2: set`member S F2}
    {FS2: inner-efxmap`fresh MP F2}
    {U2: inner-efxmap`update MP F2 X2 M}
    {EQ?: nat`eq? F2 F1 B}
    exists {M2P} {SS: select-set MP S M1 M2P}
    {U2P: inner-efxmap`update M2P F2 X2 M2}
    true.

- : select-set/in-inversion/in
    M2S+F+X1=M2 SS-MS=>M1+M2S S->F1 MS+F+X1=M F!<MS S->F2
    F!<MP MP+F+X2=M (nat`eq?/yes) M2S SS-MP=>M1+M2S M2S+F+X2=M2
    <- inner-efxmap`fresh-update-cancels F!<MS MS+F+X1=M
      F!<MP MP+F+X2=M nat`eq/ inner-efxmap`eq/ X1=X2 MS=MP
    <- select-set-respects-eq SS-MS=>M1+M2S MS=MP set`eq/
      inner-efxmap`eq/ inner-efxmap`eq/ SS-MP=>M1+M2S
    <- inner-efxmap`update-respects-eq M2S+F+X1=M2 inner-efxmap`eq/
      nat`eq/ X1=X2 inner-efxmap`eq/ M2S+F+X2=M2.

- : select-set/in-inversion/in
    M2S+F1+X1=M2 SS-MS=>M1+M2S S->F1 MS+F1+X1=M F1!<MS
    S->F2 F2!<MP MP+F2+X2=M (nat`eq?/no F2<>F1) _
    (select-set/U/in M2K+F1+X1=M2U SS-MK=>M1+M2K S->F1 MK+F1+X1=MP F1!<MK)
    M2U+F2+X2=M2
    <- inner-efxmap`update-commutes-converse
      MP+F2+X2=M MS+F1+X1=M F2<>F1 MK MK+F1+X1=MP MK+F2+X2=MS
    <- inner-efxmap`update-preserves-fresh-converse F2!<MP MK+F1+X1=MP F2!<MK
    <- select-set/in-inversion SS-MS=>M1+M2S S->F2 F2!<MK MK+F2+X2=MS
      M2K SS-MK=>M1+M2K M2K+F2+X2=M2S
    <- inner-efxmap`update-preserves-fresh-converse F1!<MS MK+F2+X2=MS F1!<MK
    <- inner-efxmap`update-commutes M2K+F2+X2=M2S M2S+F1+X1=M2 F2<>F1 M2U
      M2K+F1+X1=M2U M2U+F2+X2=M2.

- : select-set/in-inversion
    (select-set/U/in U2S SS-MS MB1 U1 F1) MB2 F2 U2 _ SS-MP UP
    <- nat`eq?-total EQ?
    <- select-set/in-inversion/in U2S SS-MS MB1 U1 F1 MB2 F2 U2 EQ? _ SS-MP UP.

- : select-set/in-inversion
    (select-set/U/out M1S+F+X=M1 SS-MS=>M1S+M2 F!<S MS+F+X=M F!<MS)
    S->N N!<MP MP+N+X2=M M2U
    (select-set/U/out M1S+F+X=M1 SS-MP=>M1S+M2U F!<S MK+F+X=MP F!<MK)
    M2U+N+X2=M2
    <- set`not-member-member-not-equal F!<S S->N F<>N
    <- inner-efxmap`update-commutes-converse MS+F+X=M MP+N+X2=M
      F<>N MK MK+N+X2=MS MK+F+X=MP
    <- inner-efxmap`update-preserves-fresh-converse N!<MP MK+F+X=MP N!<MK
    <- select-set/in-inversion SS-MS=>M1S+M2 S->N
      N!<MK MK+N+X2=MS M2U SS-MP=>M1S+M2U M2U+N+X2=M2
    <- inner-efxmap`update-preserves-fresh-converse F!<MS MK+N+X2=MS F!<MK.

%worlds () (select-set/in-inversion _ _ _ _ _ _ _)
(select-set/in-inversion/in _ _ _ _ _ _ _ _ _ _ _ _).
%total (K1 K2) (select-set/in-inversion K1 _ _ _ _ _ _)
(select-set/in-inversion/in _ K2 _ _ _ _ _ _ _ _ _ _).


%theorem select-set/out-inversion
  : forall* {M} {MP} {N} {X} {S} {M1} {M2}
    forall {SS: select-set M S M1 M2}
    {MB: set`not-member S N}
    {F: inner-efxmap`fresh MP N}
    {U: inner-efxmap`update MP N X M}
    exists {M1P} {SS: select-set MP S M1P M2}
    {U: inner-efxmap`update M1P N X M1}
    true.

%theorem select-set/out-inversion/out
  : forall*{F1} {F2} {M1S} {MS} {M1} {M2} {S} {X1} {X2} {MP} {B} {M}
    forall {U2S: inner-efxmap`update M1S F1 X1 M1}
    {SS: select-set MS S M1S M2}
    {MB: set`not-member S F1}
    {U1: inner-efxmap`update MS F1 X1 M}
    {FS1: inner-efxmap`fresh MS F1}
    {MB2: set`not-member S F2}
    {FS2: inner-efxmap`fresh MP F2}
    {U2: inner-efxmap`update MP F2 X2 M}
    {EQ?: nat`eq? F2 F1 B}
    exists {M1P} {SS: select-set MP S M1P M2}
    {U2P: inner-efxmap`update M1P F2 X2 M1}
    true.

- : select-set/out-inversion/out
    M1S+F+X1=M1 SS-MS=>M1S+M2 S->F1 MS+F+X1=M F!<MS S->F2
    F!<MP MP+F+X2=M (nat`eq?/yes) M1S SS-MP=>M1S+M2 M1S+F+X2=M1
    <- inner-efxmap`fresh-update-cancels F!<MS MS+F+X1=M
      F!<MP MP+F+X2=M nat`eq/ inner-efxmap`eq/ X1=X2 MS=MP
    <- select-set-respects-eq SS-MS=>M1S+M2 MS=MP set`eq/
      inner-efxmap`eq/ inner-efxmap`eq/ SS-MP=>M1S+M2
    <- inner-efxmap`update-respects-eq M1S+F+X1=M1 inner-efxmap`eq/
      nat`eq/ X1=X2 inner-efxmap`eq/ M1S+F+X2=M1.

- : select-set/out-inversion/out
    M1S+F1+X1=M1 SS-MS=>M1S+M2 F1!<S MS+F1+X1=M F1!<MS
    F2!<S F2!<MP MP+F2+X2=M (nat`eq?/no F2<>F1) _
    (select-set/U/out M1K+F1+X1=M1U SS-MK=>M1K+M2 F1!<S MK+F1+X1=MP F1!<MK)
    M1U+F2+X2=M1
    <- inner-efxmap`update-commutes-converse
      MP+F2+X2=M MS+F1+X1=M F2<>F1 MK MK+F1+X1=MP MK+F2+X2=MS
    <- inner-efxmap`update-preserves-fresh-converse F2!<MP MK+F1+X1=MP F2!<MK
    <- select-set/out-inversion SS-MS=>M1S+M2 F2!<S F2!<MK MK+F2+X2=MS
      M1K SS-MK=>M1K+M2 M1K+F2+X2=M1S
    <- inner-efxmap`update-preserves-fresh-converse F1!<MS MK+F2+X2=MS F1!<MK
    <- inner-efxmap`update-commutes M1K+F2+X2=M1S M1S+F1+X1=M1 F2<>F1 M1U
      M1K+F1+X1=M1U M1U+F2+X2=M1.

- : select-set/out-inversion
    (select-set/U/out U1S SS-MS NM1 U1 F1) NM2 F2 U2 _ SS-MP UP
    <- nat`eq?-total EQ?
    <- select-set/out-inversion/out U1S SS-MS NM1 U1 F1 NM2 F2 U2 EQ? _ SS-MP UP.

- : select-set/out-inversion
    (select-set/U/in M2S+F+X=M2 SS-MS=>M1+M2S S->F MS+F+X=M F!<MS)
    N!<S N!<MP MP+N+X2=M M2U
    (select-set/U/in M2S+F+X=M2 SS-MP=>M1+M2U S->F MK+F+X=MP F!<MK)
    M2U+N+X2=M2S
    <- set`not-member-member-not-equal N!<S S->F N<>F
    <- nat`ne-symmetric N<>F F<>N
    <- inner-efxmap`update-commutes-converse MS+F+X=M MP+N+X2=M
      F<>N MK MK+N+X2=MS MK+F+X=MP
    <- inner-efxmap`update-preserves-fresh-converse N!<MP MK+F+X=MP N!<MK
    <- select-set/out-inversion SS-MS=>M1+M2S N!<S
      N!<MK MK+N+X2=MS M2U SS-MP=>M1+M2U M2U+N+X2=M2S
    <- inner-efxmap`update-preserves-fresh-converse F!<MS MK+N+X2=MS F!<MK.

%worlds () (select-set/out-inversion _ _ _ _ _ _ _)
(select-set/out-inversion/out _ _ _ _ _ _ _ _ _ _ _ _).
%total (K1 K2) (select-set/out-inversion K1 _ _ _ _ _ _)
(select-set/out-inversion/out _ K2 _ _ _ _ _ _ _ _ _ _).


%theorem select-set-unique
  : forall* {M} {MP} {S} {SP} {M1} {M1P} {M2} {M2P}
    forall {SS: select-set M S M1 M2}
    {SS: select-set MP SP M1P M2P}
    {E: inner-efxmap`eq M MP} {E: set`eq S SP}
    exists {E: inner-efxmap`eq M1 M1P}
    {E: inner-efxmap`eq M2 M2P}
    true.

- : select-set-unique select-set/0 select-set/0 _ _ inner-efxmap`eq/
    inner-efxmap`eq/.

- : select-set-unique
    (select-set/U/in M2S+F+X=M2 MS=>M1+M2S S->F MS+F+X=M F!<MS)
    SS inner-efxmap`eq/ set`eq/ M1=M1P M2=M2P
    <- select-set/in-inversion SS S->F F!<MS MS+F+X=M M2K MS=>M1P+M2K M2K+F+X=M2P
    <- select-set-unique MS=>M1+M2S MS=>M1P+M2K inner-efxmap`eq/
      set`eq/ M1=M1P M2S=M2K
    <- inner-efxmap`update-unique M2S+F+X=M2 M2K+F+X=M2P
      M2S=M2K nat`eq/ efx`eq/ M2=M2P.

- : select-set-unique
    (select-set/U/out M1P+F+X=M1 MP=>M1P+M2 F!<S MP+F+X=M F!<MP)
    SS inner-efxmap`eq/ set`eq/ M1=M1P M2=M2P
    <- select-set/out-inversion SS F!<S F!<MP MP+F+X=M M1S MP=>M1S+M2
      M1S+N+X=M1P
    <- select-set-unique MP=>M1P+M2 MP=>M1S+M2 inner-efxmap`eq/
      set`eq/ M1P=M1S M2=M2P
    <- inner-efxmap`update-unique M1P+F+X=M1 M1S+N+X=M1P M1P=M1S nat`eq/
      efx`eq/ M1=M1P.

%worlds () (select-set-unique _ _ _ _ _ _).
%total (S) (select-set-unique S _ _ _ _ _).


%theorem select-tgtmap/in-inversion
  : forall* {M} {X} {MP} {N} {G} {S} {M1} {M2}
    forall {SS: select-tgtmap M G M1 M2}
    {MB: tgtmap`lookup G N S}
    {F: efxmap`fresh MP N}
    {U: efxmap`update MP N X M}
    exists {M1P} {M2P} {SS: select-tgtmap MP G M1P M2P}
    {X1} {X2} {SSS: select-set X S X1 X2}
    {U1: efxmap`update M1P N X1 M1}
    {U2: efxmap`update M2P N X2 M2}
    true.

%theorem select-tgtmap/in-inversion/in
  : forall*{N1} {N2} {M1S} {M2S} {G} {X} {S} {Q} {Z}
    {MS} {M1} {M2} {X1} {X2} {MP} {B} {M}
    forall {U2S: efxmap`update M2S N1 X2 M2}
    {U1S: efxmap`update M1S N1 X1 M1}
    {SS: select-tgtmap MS G M1S M2S}
    {SSS: select-set X S X1 X2}
    {MB: tgtmap`lookup G N1 S}
    {U1: efxmap`update MS N1 X M}
    {F1: efxmap`fresh MS N1}
    {MB2: tgtmap`lookup G N2 Q}
    {F2: efxmap`fresh MP N2}
    {U2: efxmap`update MP N2 Z M}
    {EQ?: nat`eq? N2 N1 B}
    exists {M1P} {M2P} {SS: select-tgtmap MP G M1P M2P}
    {Z1} {Z2} {SSSP: select-set Z Q Z1 Z2}
    {U1P: efxmap`update M1P N2 Z1 M1}
    {U2P: efxmap`update M2P N2 Z2 M2}
    true.

- : select-tgtmap/in-inversion/in
    M2S+N+X2=M2 M1S+N+X1=M1 MS=>M1S+M2S X+S=>X1+X2 G->N=S
    MS+N+X=M N!<MS G->N=Q N!<MP MP+N+Z=M nat`eq?/yes M1S M2S
    MP=>M1S+M2S X1 X2 Z+Q=>X1+X2 M1S+N+X1=M1 M2S+N+X2=M2
    <- efxmap`fresh-update-cancels N!<MS MS+N+X=M N!<MP MP+N+Z=M
      nat`eq/ efxmap`eq/ X=Z MS=MP
    <- select-tgtmap-respects-eq MS=>M1S+M2S MS=MP tgtmap`eq/
      efxmap`eq/ efxmap`eq/ MP=>M1S+M2S
    <- tgtmap`lookup-unique G->N=S G->N=Q tgtmap`eq/ nat`eq/ S=Q
    <- select-set-respects-eq X+S=>X1+X2 X=Z S=Q inner-efxmap`eq/
      inner-efxmap`eq/ Z+Q=>X1+X2.

- : select-tgtmap/in-inversion/in
    M2S+N1+X2=M2 M1S+N1+X1=M1 MS=>M1S+M2S X+S=>X1+X2 G->N1=S
    MS+N1+X=M N1!<MS G->N2=Q N2!<MP MP+N2+Z=M (nat`eq?/no N2<>N1)
    _ _ (select-tgtmap/U/in M2K+N1+X2=M2U M1K+N1+X1=M1U
          MK=>M1K+M2K X+S=>X1+X2 G->N1=S MK+N1+X=MP N1!<MK)
    Z1 Z2 Z+Q=>Z1+Z2 M1U+N2+Z1=M1 M2U+N2+Z2=M2
    <- efxmap`update-commutes-converse MP+N2+Z=M MS+N1+X=M N2<>N1
      MK MK+N1+X=MP MK+N2+Z=MS
    <- efxmap`update-preserves-fresh-converse N2!<MP MK+N1+X=MP N2!<MK
    <- select-tgtmap/in-inversion MS=>M1S+M2S G->N2=Q N2!<MK MK+N2+Z=MS
      M1K M2K MK=>M1K+M2K Z1 Z2 Z+Q=>Z1+Z2 M1K+N2+Z1=M1S M2K+N2+Z2=M2S
    <- efxmap`update-preserves-fresh-converse N1!<MS MK+N2+Z=MS N1!<MK
    <- efxmap`update-commutes M1K+N2+Z1=M1S M1S+N1+X1=M1 N2<>N1 M1U
      M1K+N1+X1=M1U M1U+N2+Z1=M1
    <- efxmap`update-commutes M2K+N2+Z2=M2S M2S+N1+X2=M2 N2<>N1 M2U
      M2K+N1+X2=M2U M2U+N2+Z2=M2.

- : select-tgtmap/in-inversion
    (select-tgtmap/U/in U2S U1S SS-MS SS-S L1 U1 F1) L2 F2 U2
    _ _ SS-MP _ _ SS-SP U1P U2P
    <- nat`eq?-total EQ?
    <- select-tgtmap/in-inversion/in U2S U1S SS-MS SS-S L1 U1 F1
      L2 F2 U2 EQ? _ _ SS-MP _ _ SS-SP U1P U2P.

- : select-tgtmap/in-inversion
    (select-tgtmap/U/out
      (M1S+N1+X1=M1:efxmap`update M1S N1 X1 M1)
      (MS=>M1S+M2:select-tgtmap MS G M1S M2)
      (N1!<G:tgtmap`fresh G N1)
      (MS+N1+X1=M: efxmap`update MS N1 X1 M)
      (N1!<MS:efxmap`fresh MS N1))
    (G->N2=S:tgtmap`lookup G N2 S)
    (N2!<MP:efxmap`fresh MP N2)
    (MP+N2+X2=M:efxmap`update MP N2 X2 M)
    M1U M2K (select-tgtmap/U/out M1K+N1+X1=M1U MK=>M1K+M2K
              N1!<G MK+N1+X1=MP N1!<MK)
    Z1 Z2 X2+S=>Z1+Z2 M1U+N2+Z1=M1 M2K+N2+Z2=M2
    <- tgtmap`fresh-lookup-not-equal N1!<G G->N2=S N1<>N2
    <- efxmap`update-commutes-converse MS+N1+X1=M MP+N2+X2=M N1<>N2 MK
      MK+N2+X2=MS MK+N1+X1=MP
    <- efxmap`update-preserves-fresh-converse N2!<MP MK+N1+X1=MP N2!<MK
    <- select-tgtmap/in-inversion MS=>M1S+M2 G->N2=S N2!<MK MK+N2+X2=MS
      M1K M2K MK=>M1K+M2K Z1 Z2 X2+S=>Z1+Z2 M1K+N2+Z1=M1S M2K+N2+Z2=M2
    <- efxmap`update-preserves-fresh-converse N1!<MS MK+N2+X2=MS N1!<MK
    <- nat`ne-symmetric N1<>N2 N2<>N1
    <- efxmap`update-commutes M1K+N2+Z1=M1S M1S+N1+X1=M1 N2<>N1 M1U
      M1K+N1+X1=M1U M1U+N2+Z1=M1.

%worlds () (select-tgtmap/in-inversion _ _ _ _ _ _ _ _ _ _ _ _)
(select-tgtmap/in-inversion/in _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (K1 K2) (select-tgtmap/in-inversion K1 _ _ _ _ _ _ _ _ _ _ _)
(select-tgtmap/in-inversion/in _ _ K2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem select-tgtmap/out-inversion
  : forall* {M} {X} {MP} {N} {G} {M1} {M2}
    forall {SS: select-tgtmap M G M1 M2}
    {MB: tgtmap`fresh G N}
    {F: efxmap`fresh MP N}
    {U: efxmap`update MP N X M}
    exists {M1P} {SS: select-tgtmap MP G M1P M2}
    {U1: efxmap`update M1P N X M1}
    true.

%theorem select-tgtmap/out-inversion/out
  : forall*{N1} {N2} {M1S} {G} {X} {Z}
    {MS} {M1} {M2} {MP} {B} {M}
    forall {U1S: efxmap`update M1S N1 X M1}
    {SS: select-tgtmap MS G M1S M2}
    {MB: tgtmap`fresh G N1}
    {U1: efxmap`update MS N1 X M}
    {F1: efxmap`fresh MS N1}
    {MB2: tgtmap`fresh G N2}
    {F2: efxmap`fresh MP N2}
    {U2: efxmap`update MP N2 Z M}
    {EQ?: nat`eq? N2 N1 B}
    exists {M1P} {SS: select-tgtmap MP G M1P M2}
    {U1P: efxmap`update M1P N2 Z M1}
    true.

- : select-tgtmap/out-inversion/out
    M1S+N+X1=M1 SS-MS=>M1S+M2 N1!<S MS+N+X1=M N!<MS N2!<S
    N!<MP MP+N+X2=M (nat`eq?/yes) M1S SS-MP=>M1S+M2 M1S+N+X2=M1
    <- efxmap`fresh-update-cancels N!<MS MS+N+X1=M
      N!<MP MP+N+X2=M nat`eq/ efxmap`eq/ X1=X2 MS=MP
    <- select-tgtmap-respects-eq SS-MS=>M1S+M2 MS=MP tgtmap`eq/
      efxmap`eq/ efxmap`eq/ SS-MP=>M1S+M2
    <- efxmap`update-respects-eq M1S+N+X1=M1 efxmap`eq/
      nat`eq/ X1=X2 efxmap`eq/ M1S+N+X2=M1.

- : select-tgtmap/out-inversion/out
    M1S+N1+X1=M1 SS-MS=>M1S+M2 N1!<S MS+N1+X1=M N1!<MS
    N2!<S N2!<MP MP+N2+X2=M (nat`eq?/no N2<>N1) _
    (select-tgtmap/U/out M1K+N1+X1=M1U SS-MK=>M1K+M2 N1!<S MK+N1+X1=MP N1!<MK)
    M1U+N2+X2=M1
    <- efxmap`update-commutes-converse
      MP+N2+X2=M MS+N1+X1=M N2<>N1 MK MK+N1+X1=MP MK+N2+X2=MS
    <- efxmap`update-preserves-fresh-converse N2!<MP MK+N1+X1=MP N2!<MK
    <- select-tgtmap/out-inversion SS-MS=>M1S+M2 N2!<S N2!<MK MK+N2+X2=MS
      M1K SS-MK=>M1K+M2 M1K+N2+X2=M1S
    <- efxmap`update-preserves-fresh-converse N1!<MS MK+N2+X2=MS N1!<MK
    <- efxmap`update-commutes M1K+N2+X2=M1S M1S+N1+X1=M1 N2<>N1 M1U
      M1K+N1+X1=M1U M1U+N2+X2=M1.

- : select-tgtmap/out-inversion
    (select-tgtmap/U/out U1S SS-MS NM1 U1 F1) NM2 F2 U2 _ SS-MP UP
    <- nat`eq?-total EQ?
    <- select-tgtmap/out-inversion/out U1S SS-MS NM1 U1 F1 NM2 F2 U2 EQ? _ SS-MP UP.

- : select-tgtmap/out-inversion
    (select-tgtmap/U/in M2S+F+X2=M2 M1S+F+X1=M1 SS-MS=>M1S+M2S X=>X1+X2
      S->F MS+F+X=M F!<MS) N!<S N!<MP MP+N+Z=M _
    (select-tgtmap/U/in M2S+F+X2=M2 M1U+F+X1=M1K SS-MP=>M1U+M2S X=>X1+X2
      S->F MK+F+X=MP F!<MK) M1K+N+Z=M1
    <- tgtmap`fresh-lookup-not-equal N!<S S->F N<>F
    <- nat`ne-symmetric N<>F F<>N
    <- efxmap`update-commutes-converse MS+F+X=M MP+N+Z=M
      F<>N MK MK+N+Z=MS MK+F+X=MP
    <- efxmap`update-preserves-fresh-converse N!<MP MK+F+X=MP N!<MK
    <- select-tgtmap/out-inversion SS-MS=>M1S+M2S N!<S
      N!<MK MK+N+Z=MS M1U SS-MP=>M1U+M2S M1U+N+Z=M1S
    <- efxmap`update-preserves-fresh-converse F!<MS MK+N+Z=MS F!<MK
    <- efxmap`update-commutes M1U+N+Z=M1S M1S+F+X1=M1 N<>F
      M1K M1U+F+X1=M1K M1K+N+Z=M1.

%worlds () (select-tgtmap/out-inversion _ _ _ _ _ _ _)
(select-tgtmap/out-inversion/out _ _ _ _ _ _ _ _ _ _ _ _).
%total (K1 K2) (select-tgtmap/out-inversion K1  _ _ _ _ _ _)
(select-tgtmap/out-inversion/out _ K2 _ _ _ _ _ _ _ _ _ _).


%theorem select-tgtmap-unique
  : forall* {M} {MP} {G} {GP} {M1} {M1P} {M2} {M2P}
    forall {SG: select-tgtmap M G M1 M2}
    {SG: select-tgtmap MP GP M1P M2P}
    {E: efxmap`eq M MP} {E: tgtmap`eq G GP}
    exists {E: efxmap`eq M1 M1P} {E: efxmap`eq M2 M2P}
    true.

- : select-tgtmap-unique select-tgtmap/0 select-tgtmap/0 _ _ efxmap`eq/ efxmap`eq/.

- : select-tgtmap-unique
    (select-tgtmap/U/in M2S+N+X2=M2 M1S+N+X1=M1
      MS=>M1S+M2S X=>X1+X2 L MS+N+X=M N!<MS) M=>M1P+M2P
    efxmap`eq/ tgtmap`eq/ M1=M1P M2=M2P
    <- select-tgtmap/in-inversion M=>M1P+M2P L N!<MS MS+N+X=M
      M1K M2K MS=>M1K+M2K Z1 Z2 X=>Z1+Z2 M1K+N+Z1=M1P M2K+N+Z2=M2P
    <- select-set-unique X=>X1+X2 X=>Z1+Z2 inner-efxmap`eq/ set`eq/ X1=Z1 X2=Z2
    <- select-tgtmap-unique MS=>M1S+M2S MS=>M1K+M2K efxmap`eq/ tgtmap`eq/
      M1S=M1K M2S=M2K
    <- efxmap`update-unique M1S+N+X1=M1 M1K+N+Z1=M1P M1S=M1K nat`eq/ X1=Z1 M1=M1P
    <- efxmap`update-unique M2S+N+X2=M2 M2K+N+Z2=M2P M2S=M2K nat`eq/ X2=Z2 M2=M2P.

- : select-tgtmap-unique
    (select-tgtmap/U/out M1S+N+M=M1 MS=>M1S+M2 FS MS+N+M=M N!<MS) M=>M1P+M2P
    efxmap`eq/ tgtmap`eq/ M1=M1P M2=M2P
    <- select-tgtmap/out-inversion M=>M1P+M2P FS N!<MS MS+N+M=M
      M1K MS=>M1K+M2P M1K+N+M=M1P
    <- select-tgtmap-unique MS=>M1S+M2 MS=>M1K+M2P efxmap`eq/ tgtmap`eq/
      M1S=M1K M2=M2P
    <- efxmap`update-unique M1S+N+M=M1 M1K+N+M=M1P M1S=M1K nat`eq/
      inner-efxmap`eq/ M1=M1P.

%worlds () (select-tgtmap-unique _ _ _ _ _ _).
%total (S) (select-tgtmap-unique S _ _ _ _ _).


%theorem fresh-update2-preserves-select-set-converse
  : forall* {M} {N} {S} {SP} {M1} {M2}
    forall {SS: select-set M S M1 M2}
    {F: inner-efxmap`fresh M N}
    {F: set`not-member SP N} {U: set`add SP N S}
    exists {SS: select-set M SP M1 M2}
    true.

- : fresh-update2-preserves-select-set-converse
    select-set/0 inner-efxmap`fresh/0 _ _ select-set/0.

%theorem fresh-update2-preserves-select-set-converse/U/in
  : forall* {M} {N} {M1} {M2} {M2P} {F} {X} {S} {SP} {MP} {B}
    forall {U: inner-efxmap`update M2P F X M2}
    {SS: select-set MP S M1 M2P} {MB: set`member S F}
    {U: inner-efxmap`update MP F X M} {FS: inner-efxmap`fresh MP F}
    {FS: set`not-member SP N} {A: set`add SP N S}
    {NM: inner-efxmap`fresh M N} {EQ?: nat`eq? F N B}
    exists {SS: select-set M SP M1 M2}
    true.

- : fresh-update2-preserves-select-set-converse/U/in
    _ _ _ MP+N+X=M _ _ _ N!<M nat`eq?/yes SS
    <- inner-efxmap`update-implies-lookup MP+N+X=M M->N=X
    <- inner-efxmap`fresh-lookup-not-equal N!<M M->N=X N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-select-set V SS.

- : fresh-update2-preserves-select-set-converse/U/in
    M2P+F+X=M2 MP+S=>M1+M2P F<-S MP+F+X=M F!<MP N!<SP SP+N=S N!<M
    (nat`eq?/no F<>N)
    (select-set/U/in M2P+F+X=M2 MP+SP=>M1+M2P F<-SP MP+F+X=M F!<MP)
    <- inner-efxmap`update-preserves-fresh-converse N!<M MP+F+X=M N!<MP
    <- set`add-preserves-member-converse F<-S SP+N=S F<>N F<-SP
    <- fresh-update2-preserves-select-set-converse MP+S=>M1+M2P
      N!<MP N!<SP SP+N=S MP+SP=>M1+M2P.

- : fresh-update2-preserves-select-set-converse
    (select-set/U/in U2 SS L US FS) F NM A SSP
    <- nat`eq?-total EQ?
    <- fresh-update2-preserves-select-set-converse/U/in U2 SS
      L US FS NM A F EQ? SSP.

%theorem fresh-update2-preserves-select-set-converse/U/out
  : forall* {M} {N} {M1} {M2} {M1P} {F} {X} {S} {SP} {MP} {B}
    forall {U: inner-efxmap`update M1P F X M1}
    {SS: select-set MP S M1P M2} {MB: set`not-member S F}
    {U: inner-efxmap`update MP F X M} {FS: inner-efxmap`fresh MP F}
    {FS: set`not-member SP N} {A: set`add SP N S}
    {NM: inner-efxmap`fresh M N} {EQ?: nat`eq? F N B}
    exists {SS: select-set M SP M1 M2}
    true.

- : fresh-update2-preserves-select-set-converse/U/out
    _ _ N!<S _ _ _ SP+N=S _ nat`eq?/yes SS
    <- set`add-implies-member SP+N=S N<-S
    <- set`not-member-member-not-equal N!<S N<-S N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-select-set V SS.

- : fresh-update2-preserves-select-set-converse/U/out
    M1P+F+X=M2 MP+S=>M1P+M2 F!<S MP+F+X=M F!<MP N!<SP SP+N=S N!<M
    (nat`eq?/no F<>N)
    (select-set/U/out M1P+F+X=M2 MP+SP=>M1P+M2 F!<SP MP+F+X=M F!<MP)
    <- inner-efxmap`update-preserves-fresh-converse N!<M MP+F+X=M N!<MP
    <- set`add-preserves-not-member-converse F!<S SP+N=S F!<SP
    <- fresh-update2-preserves-select-set-converse MP+S=>M1P+M2 N!<MP
      N!<SP SP+N=S MP+SP=>M1P+M2.

- : fresh-update2-preserves-select-set-converse
    (select-set/U/out U2 SS L US FS) F NM A SSP
    <- nat`eq?-total EQ?
    <- fresh-update2-preserves-select-set-converse/U/out
      U2 SS L US FS NM A F EQ? SSP.

%worlds () (fresh-update2-preserves-select-set-converse _ _ _ _ _)
(fresh-update2-preserves-select-set-converse/U/in _ _ _ _ _ _ _ _ _ _)
(fresh-update2-preserves-select-set-converse/U/out _ _ _ _ _ _ _ _ _ _).
%total (S1 S2 S3) (fresh-update2-preserves-select-set-converse S1 _ _ _ _)
(fresh-update2-preserves-select-set-converse/U/in _ S2 _ _ _ _ _ _ _ _)
(fresh-update2-preserves-select-set-converse/U/out _ S3 _ _ _ _ _ _ _ _).


%theorem update-preserves-select-set
  : forall* {M} {N} {S} {SP} {M1} {M2}
    forall {SS: select-set M SP M1 M2}
    {F: inner-efxmap`fresh M N}
    {U: set`add SP N S}
    exists {SS: select-set M S M1 M2}
    true.

- : update-preserves-select-set select-set/0 FS A select-set/0.

- : update-preserves-select-set (select-set/U/in M2P+F+X=M2
                                  MP+SP=>M1+M2P F<-SP MP+F+X=M F!<MP)
    N!<M SP+N=S (select-set/U/in M2P+F+X=M2 MP+S=>M1+M2P F<-S MP+F+X=M F!<MP)
    <- inner-efxmap`update-implies-lookup MP+F+X=M M->F=X
    <- inner-efxmap`fresh-lookup-not-equal N!<M M->F=X N<>F
    <- inner-efxmap`update-preserves-fresh-converse N!<M MP+F+X=M N!<MP
    <- update-preserves-select-set MP+SP=>M1+M2P N!<MP SP+N=S MP+S=>M1+M2P
    <- set`add-preserves-member F<-SP SP+N=S F<-S.

- : update-preserves-select-set (select-set/U/out M1P+F+X=M1
                                  MP+SP=>M1P+M2 F!<SP MP+F+X=M F!<MP)
    N!<M SP+N=S (select-set/U/out M1P+F+X=M1 MP+S=>M1P+M2 F!<S MP+F+X=M F!<MP)
    <- inner-efxmap`update-implies-lookup MP+F+X=M M->F=X
    <- inner-efxmap`fresh-lookup-not-equal N!<M M->F=X N<>F
    <- nat`ne-symmetric N<>F F<>N
    <- inner-efxmap`update-preserves-fresh-converse N!<M MP+F+X=M N!<MP
    <- update-preserves-select-set MP+SP=>M1P+M2 N!<MP SP+N=S MP+S=>M1P+M2
    <- set`add-preserves-not-member F!<SP SP+N=S F<>N F!<S.

%worlds () (update-preserves-select-set _ _ _ _).
%total (S) (update-preserves-select-set S _ _ _).


%theorem fresh-update2-preserves-select-tgtmap-converse
  : forall* {M} {N} {G} {GP} {M1} {M2} {S}
    forall {SG: select-tgtmap M G M1 M2}
    {F: efxmap`fresh M N}
    {F: tgtmap`fresh GP N} {U: tgtmap`update GP N S G}
    exists {SG: select-tgtmap M GP M1 M2}
    true.

- : fresh-update2-preserves-select-tgtmap-converse
    select-tgtmap/0 efxmap`fresh/0 _ _ select-tgtmap/0.

%theorem fresh-update2-preserves-select-tgtmap-converse/U/in
  : forall* {M} {N1} {N2} {M1} {M2} {M1P} {M2P}
    {G} {GP} {MP} {B} {S1} {S2} {X} {X1} {X2}
    forall {U: efxmap`update M2P N1 X2 M2}
    {U: efxmap`update M1P N1 X1 M1} {SG: select-tgtmap MP G M1P M2P}
    {SS: select-set X S1 X1 X2} {MB: tgtmap`lookup G N1 S1}
    {U: efxmap`update MP N1 X M} {FS: efxmap`fresh MP N1}
    {FS: tgtmap`fresh GP N2} {A: tgtmap`update GP N2 S2 G}
    {NM: efxmap`fresh M N2} {EQ?: nat`eq? N1 N2 B}
    exists {SG: select-tgtmap M GP M1 M2}
    true.

- : fresh-update2-preserves-select-tgtmap-converse/U/in
    _ _ _ _ _ MP+N+X=M _ _ _ N!<M nat`eq?/yes SS
    <- efxmap`update-implies-lookup MP+N+X=M M->N=X
    <- efxmap`fresh-lookup-not-equal N!<M M->N=X N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-select-tgtmap V SS.

- : fresh-update2-preserves-select-tgtmap-converse/U/in
    M2P+N1+X2=M2 M1P+N1+X1=M1 MP+G=>M1P+M2P X+S1=>X1+X2
    G->N1=S1 MP+N1+X=M N1!<MP N2!<GP GP+N2+S2=G N2!<M
    (nat`eq?/no N1<>N2)
    (select-tgtmap/U/in M2P+N1+X2=M2 M1P+N1+X1=M1 MP+GP=>M1P+M2P
      X+S1=>X1+X2 GP->N1=S1 MP+N1+X=M N1!<MP)
    <- efxmap`update-preserves-fresh-converse N2!<M MP+N1+X=M N2!<MP
    <- tgtmap`update-preserves-lookup-converse G->N1=S1 GP+N2+S2=G N1<>N2 GP->N1=S1
    <- fresh-update2-preserves-select-tgtmap-converse MP+G=>M1P+M2P
      N2!<MP N2!<GP GP+N2+S2=G MP+GP=>M1P+M2P.

- : fresh-update2-preserves-select-tgtmap-converse
    (select-tgtmap/U/in U2 U1 SG SS L US FS) F NM A SSP
    <- nat`eq?-total EQ?
    <- fresh-update2-preserves-select-tgtmap-converse/U/in
      U2 U1 SG SS L US FS NM A F EQ? SSP.

%theorem fresh-update2-preserves-select-tgtmap-converse/U/out
  : forall* {M} {N2} {M1} {M2} {M1P} {N1} {X} {G} {GP} {MP} {B} {S2}
    forall {U: efxmap`update M1P N1 X M1}
    {SG: select-tgtmap MP G M1P M2} {MB: tgtmap`fresh G N1}
    {U: efxmap`update MP N1 X M} {FS: efxmap`fresh MP N1}
    {FS: tgtmap`fresh GP N2} {A: tgtmap`update GP N2 S2 G}
    {NM: efxmap`fresh M N2} {EQ?: nat`eq? N1 N2 B}
    exists {SG: select-tgtmap M GP M1 M2}
    true.

- : fresh-update2-preserves-select-tgtmap-converse/U/out
    _ _ N!<G _ _ _ GP+N+S=G _ nat`eq?/yes SS
    <- tgtmap`update-implies-lookup GP+N+S=G G->N=S
    <- tgtmap`fresh-lookup-not-equal N!<G G->N=S N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- false-implies-select-tgtmap V SS.

- : fresh-update2-preserves-select-tgtmap-converse/U/out
    M1P+N1+X=M2 MP+G=>M1P+M2 N1!<G MP+N1+X=M N1!<MP N2!<GP GP+N2+S2=G N2!<M
    (nat`eq?/no N1<>N2)
    (select-tgtmap/U/out M1P+N1+X=M2 MP+GP=>M1P+M2 N1!<GP MP+N1+X=M N1!<MP)
    <- efxmap`update-preserves-fresh-converse N2!<M MP+N1+X=M N2!<MP
    <- tgtmap`update-preserves-fresh-converse N1!<G GP+N2+S2=G N1!<GP
    <- fresh-update2-preserves-select-tgtmap-converse MP+G=>M1P+M2
      N2!<MP N2!<GP GP+N2+S2=G MP+GP=>M1P+M2.

- : fresh-update2-preserves-select-tgtmap-converse
    (select-tgtmap/U/out U2 SS L US FS) F NM A SSP
    <- nat`eq?-total EQ?
    <- fresh-update2-preserves-select-tgtmap-converse/U/out
      U2 SS L US FS NM A F EQ? SSP.

%worlds () (fresh-update2-preserves-select-tgtmap-converse _ _ _ _ _)
(fresh-update2-preserves-select-tgtmap-converse/U/in _ _ _ _ _ _ _ _ _ _ _ _)
(fresh-update2-preserves-select-tgtmap-converse/U/out _ _ _ _ _ _ _ _ _ _).
%total (S1 S2 S3) (fresh-update2-preserves-select-tgtmap-converse S1 _ _ _ _)
(fresh-update2-preserves-select-tgtmap-converse/U/in _ _ S2 _ _ _ _ _ _ _ _ _)
(fresh-update2-preserves-select-tgtmap-converse/U/out _ S3 _ _ _ _ _  _ _ _).


%theorem fresh-update-preserves-select-set-converse
  : forall* {G} {M} {M1} {M2} {N} {MP} {GP} {D}
    forall {SG: select-set M G M1 M2}
    {F1: inner-efxmap`fresh MP N}
    {U1: inner-efxmap`update MP N D M}
    {F2: set`not-member GP N}
    {U2: set`add GP N G}
    exists {M2P}
    {U: inner-efxmap`update M2P N D M2}
    {SG: select-set MP GP M1 M2P}
    true.

- : fresh-update-preserves-select-set-converse SS1 F1 U1 F2 U2 _ U3 SS2
    <- set`add-implies-member U2 MB
    <- select-set/in-inversion SS1 MB F1 U1 _ SS2P U3
    <- fresh-update2-preserves-select-set-converse SS2P F1 F2 U2 SS2.

%worlds () (fresh-update-preserves-select-set-converse _ _ _ _ _ _ _ _).
%total {} (fresh-update-preserves-select-set-converse _  _ _ _ _ _ _ _).


%theorem fresh-update-preserves-select-tgtmap-converse
  : forall* {G} {M} {M1} {M2} {N} {MP} {GP} {D} {S}
    forall {SG: select-tgtmap M G M1 M2}
    {F1: efxmap`fresh MP N}
    {U1: efxmap`update MP N D M}
    {F2: tgtmap`fresh GP N}
    {U2: tgtmap`update GP N S G}
    exists {M1P} {M2P} {D1} {D2}
    {SS: select-set D S D1 D2}
    {U: efxmap`update M1P N D1 M1}
    {U: efxmap`update M2P N D2 M2}
    {SG: select-tgtmap MP GP M1P M2P}
    true.

- : fresh-update-preserves-select-tgtmap-converse
    SG1 F1 U1 F2 U2 _ _ _ _ SS U3 U4 SG2
    <- tgtmap`update-implies-lookup U2 L
    <- select-tgtmap/in-inversion SG1 L F1 U1 _ _ SG2P _ _ SS U3 U4
    <- fresh-update2-preserves-select-tgtmap-converse SG2P F1 F2 U2 SG2.

%worlds () (fresh-update-preserves-select-tgtmap-converse _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (fresh-update-preserves-select-tgtmap-converse _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem update-preserves-select-tgtmap
  : forall* {M} {N} {G} {S} {GP} {M1} {M2}
    forall {SS: select-tgtmap M GP M1 M2}
    {F: efxmap`fresh M N}
    {U: tgtmap`update GP N S G}
    exists {SS: select-tgtmap M G M1 M2}
    true.

- : update-preserves-select-tgtmap select-tgtmap/0 FS A select-tgtmap/0.

- : update-preserves-select-tgtmap
    (select-tgtmap/U/in M2P+F+X2=M2 M1P+F+X1=M1
      MP+SP=>M1+M2P X+S=>X1+X2 SP->F=S MP+F+X=M F!<MP)
    N!<M SP+N=S (select-tgtmap/U/in M2P+F+X2=M2 M1P+F+X1=M1
                  MP+S=>M1+M2P X+S=>X1+X2 S->F=S MP+F+X=M F!<MP)
    <- efxmap`update-implies-lookup MP+F+X=M M->F=X
    <- efxmap`fresh-lookup-not-equal N!<M M->F=X N<>F
    <- efxmap`update-preserves-fresh-converse N!<M MP+F+X=M N!<MP
    <- update-preserves-select-tgtmap MP+SP=>M1+M2P N!<MP SP+N=S MP+S=>M1+M2P
    <- nat`ne-symmetric N<>F F<>N
    <- tgtmap`update-preserves-lookup SP->F=S SP+N=S F<>N S->F=S.

- : update-preserves-select-tgtmap (select-tgtmap/U/out M1P+F+X=M1
                                  MP+SP=>M1P+M2 F!<SP MP+F+X=M F!<MP)
    N!<M SP+N=S (select-tgtmap/U/out M1P+F+X=M1 MP+S=>M1P+M2 F!<S MP+F+X=M F!<MP)
    <- efxmap`update-implies-lookup MP+F+X=M M->F=X
    <- efxmap`fresh-lookup-not-equal N!<M M->F=X N<>F
    <- nat`ne-symmetric N<>F F<>N
    <- efxmap`update-preserves-fresh-converse N!<M MP+F+X=M N!<MP
    <- update-preserves-select-tgtmap MP+SP=>M1P+M2 N!<MP SP+N=S MP+S=>M1P+M2
    <- tgtmap`update-preserves-fresh F!<SP SP+N=S F<>N F!<S.

%worlds () (update-preserves-select-tgtmap _ _ _ _).
%total (S) (update-preserves-select-tgtmap S _ _ _).


%theorem select-set-implies-domain
  : forall* {M} {S} {MS} {M1} {M2}
    forall {SS: select-set M S M1 M2}
    {DM: inner-efxmap`domain M MS}
    {LE: set`leq S MS}
    exists {DM: inner-efxmap`domain M2 S}
    true.

%theorem select-set-implies-domain/L
  : forall* {M} {S} {MS} {M1} {M2}
    forall {N} {SZ: inner-efxmap`size M N}
    {SS: select-set M S M1 M2}
    {DM: inner-efxmap`domain M MS}
    {LE: set`leq S MS}
    exists {DM: inner-efxmap`domain M2 S}
    true.

- : select-set-implies-domain/L _ _ select-set/0 inner-efxmap`domain/0
    set`leq/0 inner-efxmap`domain/0.

- : select-set-implies-domain/L (s N) SZ
    (select-set/U/in M2P+F+X=M2 MP+S=>M1+M2P F<-S MP+F+X=M F!<MP)
    DM-M=MS S<=MS DM-M2=S
    <- set`member-implies-not-member-add F<-S SP F!<SP SP+F=S
    <- inner-efxmap`update-implies-lookup MP+F+X=M M->F=X
    <- inner-efxmap`domain-preserves-lookup M->F=X DM-M=MS F<-MS
    <- set`member-implies-not-member-add F<-MS MSP F!<MSP MSP+F=MS
    <- inner-efxmap`domain-commute-fresh-update-converse
      DM-M=MS F!<MP MP+F+X=M F!<MSP MSP+F=MS DM-MP=MSP
    <- set`not-member-add-preserves-leq-converse
      S<=MS F!<SP SP+F=S F!<MSP MSP+F=MS SP<=MSP
    <- fresh-update2-preserves-select-set-converse
      MP+S=>M1+M2P F!<MP F!<SP SP+F=S MP+SP=>M1+M2P
    <- inner-efxmap`fresh-update-increases-size-converse SZ F!<MP MP+F+X=M SZP
    <- select-set-implies-domain/L N SZP MP+SP=>M1+M2P DM-MP=MSP SP<=MSP DM-M2P=SP
    <- inner-efxmap`domain-commute-update DM-M2P=SP M2P+F+X=M2 SP+F=S DM-M2=S.

- : select-set-implies-domain/L (s N) SZ
    (select-set/U/out M1P+F+X=M2 MP+S=>M1P+M2 F!<S MP+F+X=M F!<MP)
    DM-M=MS S<=MS DM-M2=S
    <- inner-efxmap`update-implies-lookup MP+F+X=M M->F=X
    <- inner-efxmap`domain-preserves-lookup M->F=X DM-M=MS F<-MS
    <- set`member-implies-not-member-add F<-MS MSP F!<MSP MSP+F=MS
    <- inner-efxmap`domain-commute-fresh-update-converse
      DM-M=MS F!<MP MP+F+X=M F!<MSP MSP+F=MS DM-MP=MSP
    <- inner-efxmap`fresh-update-increases-size-converse SZ F!<MP MP+F+X=M SZP
    <- set`irrelevant-add-preserves-leq-converse S<=MS F!<S MSP+F=MS S<=MSP
    <- select-set-implies-domain/L N SZP MP+S=>M1P+M2 DM-MP=MSP S<=MSP DM-M2=S.

%worlds () (select-set-implies-domain/L _ _ _ _ _ _).
%total (N) (select-set-implies-domain/L N _ _ _ _ _).

- : select-set-implies-domain SS DM LE DM2
    <- inner-efxmap`size-total SZ
    <- select-set-implies-domain/L _ SZ SS DM LE DM2.

%worlds () (select-set-implies-domain _ _ _ _).
%total {} (select-set-implies-domain _ _ _ _).


%theorem select-tgtmap-implies-efxmap2tgtmap
  : forall* {M} {G} {M1} {M2}
    forall {SG: select-tgtmap M G M1 M2}
    {LE: tgtmap`leq-efxmap G M}
    exists {T: efxmap2tgtmap M2 G}
    true.

%theorem select-tgtmap-implies-efxmap2tgtmap/L
  : forall* {M} {G} {M1} {M2}
    forall {N} {SZ: efxmap`size M N}
    {SG: select-tgtmap M G M1 M2}
    {LE: tgtmap`leq-efxmap G M}
    exists {T: efxmap2tgtmap M2 G}
    true.

- : select-tgtmap-implies-efxmap2tgtmap/L z _
    select-tgtmap/0 (tgtmap`leq-efxmap/ tgtmap`leq/0 efxmap2tgtmap/0)
    efxmap2tgtmap/0.

- : select-tgtmap-implies-efxmap2tgtmap/L (s N) SZ
    (select-tgtmap/U/in M2P+N+X2=M2 M1P+N+X1=M1 MP+G=>M1P+M2P
      X+S=>X1+X2 G->N=S MP+N+X=M N!<MP) G<=M M2=>G
    <- tgtmap`lookup-implies-fresh-update G->N=S GP N!<GP GP+N+S=G
    <- efxmap`update-implies-lookup MP+N+X=M M->N=X
    <- tgtmap`lookup-respects-leq-efxmap* G->N=S G<=M M->N=X XS DM-X=XS S<=XS
    <- fresh-update2-preserves-select-tgtmap-converse
      MP+G=>M1P+M2P N!<MP N!<GP GP+N+S=G MP+GP=>M1P+M2P
    <- tgtmap`fresh-update-preserves-leq-efxmap-converse
      G<=M N!<GP  GP+N+S=G N!<MP MP+N+X=M GP<=MP
    <- efxmap`fresh-update-increases-size-converse SZ N!<MP MP+N+X=M SZP
    <- select-tgtmap-implies-efxmap2tgtmap/L _ SZP MP+GP=>M1P+M2P GP<=MP M2P=>GP
    <- select-set-implies-domain X+S=>X1+X2 DM-X=XS S<=XS DM-X2=S
    <- update-preserves-efxmap2tgtmap M2P=>GP DM-X2=S M2P+N+X2=M2 GP+N+S=G M2=>G.

- : select-tgtmap-implies-efxmap2tgtmap/L (s N) SZ
    (select-tgtmap/U/out M1P+N+X=M1 MP+G=>M1P+M2
      N!<G MP+N+X=M N!<MP) G<=M M2=>G
    <- tgtmap`fresh-update2-preserves-leq-efxmap-converse
      G<=M N!<G N!<MP MP+N+X=M G<=MP
    <- efxmap`fresh-update-increases-size-converse SZ N!<MP MP+N+X=M SZP
    <- select-tgtmap-implies-efxmap2tgtmap/L _ SZP MP+G=>M1P+M2 G<=MP M2=>G.

%worlds () (select-tgtmap-implies-efxmap2tgtmap/L _ _ _ _ _).
%total (N) (select-tgtmap-implies-efxmap2tgtmap/L N _ _ _ _).

- : select-tgtmap-implies-efxmap2tgtmap SG LE T
    <- efxmap`size-total SZ
    <- select-tgtmap-implies-efxmap2tgtmap/L _ SZ SG LE T.

%worlds () (select-tgtmap-implies-efxmap2tgtmap _ _ _).
%total {} (select-tgtmap-implies-efxmap2tgtmap _ _ _).


% =================================
% ========= equiv-empty ===========
% =================================


%theorem false-implies-equiv-empty
  : forall* {M}
    forall {F:void} exists {EE: equiv-empty M}
    true.

%worlds () (false-implies-equiv-empty _ _).
%total {} (false-implies-equiv-empty _ _).


%theorem equiv-empty-respects-eq
  : forall* {M} {MP}
    forall {EE: equiv-empty M}
    {E: tgtmap`eq M MP}
    exists {EEP: equiv-empty MP}
    true.

- : equiv-empty-respects-eq EE tgtmap`eq/ EE.

%worlds () (equiv-empty-respects-eq _ _ _).
%total {} (equiv-empty-respects-eq _ _ _).


%theorem equiv-empty/U-inversion
  : forall* {MP} {N} {M} {S}
    forall {EE: equiv-empty M}
    {F: tgtmap`fresh MP N}
    {U: tgtmap`update MP N S M}
    exists {EEP: equiv-empty MP}
    {E: set`eq set/0 S}
    true.

%theorem equiv-empty/U-inversion/L
  : forall* {MP1} {MP2} {N1} {N2} {M} {B} {S}
    forall {EE: equiv-empty MP1}
    {F1: tgtmap`fresh MP1 N1}
    {U1: tgtmap`update MP1 N1 set/0 M}
    {F: tgtmap`fresh MP2 N2}
    {U: tgtmap`update MP2 N2 S M}
    {EQ?: nat`eq? N2 N1 B}
    exists {EEP: equiv-empty MP2}
    {E: set`eq set/0 S}
    true.

- : equiv-empty/U-inversion/L
    EE1 F1 U1 F2 U2 nat`eq?/yes EE3 DE
    <- tgtmap`fresh-update-cancels F1 U1 F2 U2 nat`eq/ tgtmap`eq/ DE EQ
    <- equiv-empty-respects-eq EE1 EQ EE3.

- : equiv-empty/U-inversion/L
    EE1 F0 U0 F1 U1 (nat`eq?/no N2<>N1) (equiv-empty/U EE2 F3 U3) DE
    <- tgtmap`update-commutes-converse U1 U0 N2<>N1 _ U3 U2
    <- tgtmap`update-preserves-fresh-converse F1 U3 F2
    <- tgtmap`update-preserves-fresh-converse F0 U2 F3
    <- equiv-empty/U-inversion EE1 F2 U2 EE2 DE.

- : equiv-empty/U-inversion
    (equiv-empty/U EE1 F1 U1) F2 U2 EE2 DE
    <- nat`eq?-total E?
    <- equiv-empty/U-inversion/L EE1 F1 U1 F2 U2 E? EE2 DE.

%worlds () (equiv-empty/U-inversion/L _ _ _ _ _ _ _ _)
(equiv-empty/U-inversion _ _ _ _ _).
%total (N1 N2) (equiv-empty/U-inversion N2 _ _ _ _)
(equiv-empty/U-inversion/L N1 _ _ _ _ _ _ _).


%theorem select-set-left-empty
  : forall* {M} {S}
    forall {DM: inner-efxmap`domain M S}
    exists {SG: select-set M S inner-efxmap/0 M}
    true.

%theorem select-set-left-empty/L
  : forall* {M} {S}
    forall {N} {SZ: inner-efxmap`size M N}
    {DM: inner-efxmap`domain M S}
    exists {SG: select-set M S inner-efxmap/0 M}
    true.

- : select-set-left-empty/L _ _ inner-efxmap`domain/0 select-set/0.

- : select-set-left-empty/L (s N) SZ
    DM-M=S (select-set/U/in MP+F+X=M MP+S=>0+MP F<-S
             MP+F+X=M F!<MP)
    <- inner-efxmap`lookup-implies-fresh-update (inner-efxmap`lookup/= nat`eq/)
      MP F!<MP MP+F+X=M
    <- inner-efxmap`domain-preserves-lookup
      (inner-efxmap`lookup/= nat`eq/)  DM-M=S F<-S
    <- set`member-implies-not-member-add F<-S SP F!<SP SP+F=S
    <- inner-efxmap`fresh-update-increases-size-converse SZ F!<MP MP+F+X=M SZP
    <- inner-efxmap`domain-commute-fresh-update-converse
      DM-M=S F!<MP MP+F+X=M F!<SP SP+F=S DM-MP=SP
    <- select-set-left-empty/L N SZP  DM-MP=SP MP+SP=>0+MP
    <- update-preserves-select-set MP+SP=>0+MP F!<MP SP+F=S MP+S=>0+MP.

- : select-set-left-empty DM SG
    <- inner-efxmap`size-total SZ
    <- select-set-left-empty/L _ SZ DM SG.

%worlds () (select-set-left-empty/L _ _ _ _).
%total (N) (select-set-left-empty/L N _ _ _).

%worlds () (select-set-left-empty _ _).
%total {} (select-set-left-empty _ _).


%theorem select-set-right-empty
  : forall {M}
    exists {SS: select-set M set/0 M inner-efxmap/0}
    true.

%theorem select-set-right-empty/L
  : forall* {M}
    forall {N} {SZ: inner-efxmap`size M N}
    exists {SS: select-set M set/0 M inner-efxmap/0}
    true.

- : select-set-right-empty/L z _ select-set/0.

- : select-set-right-empty/L (s N) Z
    (select-set/U/out U T set`not-member/0 U F)
    <- inner-efxmap`lookup-implies-fresh-update (inner-efxmap`lookup/= nat`eq/) _
      F U
    <- inner-efxmap`fresh-update-increases-size-converse Z F U ZP
    <- select-set-right-empty/L N ZP T.

%worlds () (select-set-right-empty/L _ _ _).
%total (N) (select-set-right-empty/L N _ _).

- : select-set-right-empty _ SS
    <- inner-efxmap`size-total SZ
    <- select-set-right-empty/L _ SZ SS.

%worlds () (select-set-right-empty _ _).
%total {} (select-set-right-empty _ _).


%theorem select-tgtmap-left-equiv-empty
  : forall* {M} {G}
    forall {T: efxmap2tgtmap M G}
    exists {G1} {M1} {SG: select-tgtmap M G M1 M}
    {T: efxmap2tgtmap M1 G1} {EE: equiv-empty G1}
    true.

- : select-tgtmap-left-equiv-empty efxmap2tgtmap/0
    _ _ select-tgtmap/0 efxmap2tgtmap/0 equiv-empty/0.

- : select-tgtmap-left-equiv-empty
    (efxmap2tgtmap/U MP=>GP DM-D=S N!<MP MP+N+D=M GP+N+S=G) %{=>}%
    _ _(select-tgtmap/U/in MP+N+D=M M1P+N+0=M1 MP+G=>M1P+MP
            D+S=>0+D G->N=S MP+N+D=M N!<MP)
    (efxmap2tgtmap/U M1P=>G1P inner-efxmap`domain/0 N!<M1P M1P+N+0=M1 G1P+N+0=G1)
    (equiv-empty/U EE-G1P N!<G1P G1P+N+0=G1)
    <- select-tgtmap-left-equiv-empty MP=>GP M1P _ MP+GP=>M1P+MP M1P=>G1P EE-G1P
    <- select-set-left-empty DM-D=S D+S=>0+D
    <- tgtmap`update-implies-lookup GP+N+S=G G->N=S
    <- efxmap`update-total M1P+N+0=M1
    <- update-preserves-select-tgtmap MP+GP=>M1P+MP N!<MP GP+N+S=G MP+G=>M1P+MP
    <- select-tgtmap-implies-leq MP+G=>M1P+MP M1P<=MP _
    <- efxmap`fresh-respects-geq N!<MP M1P<=MP N!<M1P
    <- efxmap2tgtmap-preserves-fresh N!<M1P M1P=>G1P N!<G1P
    <- tgtmap`update-total G1P+N+0=G1.

%worlds () (select-tgtmap-left-equiv-empty _ _ _ _ _ _).
%total (T) (select-tgtmap-left-equiv-empty T _ _ _ __ _).


%theorem select-tgtmap-right-equiv-empty
  : forall* {M} {M1} {M2}
    forall {SG: select-tgtmap M tgtmap/0 M1 M2}
    exists {G2} {E: efxmap`eq M M1}
    {T: efxmap2tgtmap M2 G2} {EE: equiv-empty G2}
    true.

- : select-tgtmap-right-equiv-empty
    select-tgtmap/0 _ efxmap`eq/ efxmap2tgtmap/0 equiv-empty/0.

- : select-tgtmap-right-equiv-empty
    (select-tgtmap/U/out M1P+N+D=M1 MP+0=>M1P+M2 tgtmap`fresh/0
      MP+N+D=M N!<MP) G2 E T EE
    <- select-tgtmap-right-equiv-empty MP+0=>M1P+M2 G2 MP=M1P T EE
    <- efxmap`update-unique MP+N+D=M M1P+N+D=M1 MP=M1P nat`eq/ inner-efxmap`eq/ E.

%worlds () (select-tgtmap-right-equiv-empty _ _ _ _ _).
%total (SG) (select-tgtmap-right-equiv-empty SG _ _ _ _).


%theorem select-set-implies-disjoint-join
  : forall* {S} {M} {M1} {M2}
    forall {SS: select-set M S M1 M2}
    exists {DJ: inner-efxmap`disjoint M1 M2}
    {J: inner-efxmap`join M1 M2 M}
    true.

- : select-set-implies-disjoint-join
    select-set/0 inner-efxmap`disjoint/L inner-efxmap`join/L.

- : select-set-implies-disjoint-join
    (select-set/U/in M2P+F+X=M2 MP+S=>M1+M2P _ MP+F+X=M F!<MP) M1^M2 M1+M2=M
    <- select-set-implies-leq MP+S=>M1+M2P M1<=MP M2P<=MP
    <- inner-efxmap`fresh-respects-geq F!<MP M1<=MP F!<M1
    <- inner-efxmap`fresh-respects-geq F!<MP M2P<=MP F!<M2P
    <- select-set-implies-disjoint-join MP+S=>M1+M2P M1^M2P M1+M2P=MP
    <- inner-efxmap`fresh-update-preserves-disjoint M1^M2P F!<M1 M2P+F+X=M2 M1^M2
    <- inner-efxmap`fresh-update-implies-unit-join F!<M2P M2P+F+X=M2 M2P+X=M2
    <- inner-efxmap`fresh-update-implies-unit-join F!<MP MP+F+X=M MP+X=M
    <- inner-efxmap`join-associative* M1+M2P=MP MP+X=M M2P+X=M2 M1+M2=M.

- : select-set-implies-disjoint-join
    (select-set/U/out M1P+F+X=M1 MP+S=>M1P+M2 _ MP+F+X=M F!<MP) M1^M2 M1+M2=M
    <- select-set-implies-leq MP+S=>M1P+M2 M1P<=MP M2<=MP
    <- inner-efxmap`fresh-respects-geq F!<MP M1P<=MP F!<M1P
    <- inner-efxmap`fresh-respects-geq F!<MP M2<=MP F!<M2
    <- select-set-implies-disjoint-join MP+S=>M1P+M2 M1P^M2 M1P+M2=MP
    <- inner-efxmap`disjoint-symmetric M1P^M2 M2^M1P
    <- inner-efxmap`fresh-update-preserves-disjoint M2^M1P F!<M2 M1P+F+X=M1 M2^M1
    <- inner-efxmap`disjoint-symmetric M2^M1 M1^M2
    <- inner-efxmap`fresh-update-implies-unit-join F!<M1P M1P+F+X=M1 M1P+X=M1
    <- inner-efxmap`fresh-update-implies-unit-join F!<MP MP+F+X=M MP+X=M
    <- inner-efxmap`disjoint-join-commutative M1P^M2 M1P+M2=MP M2+M1P=MP
    <- inner-efxmap`join-associative* M2+M1P=MP MP+X=M M1P+X=M1 M2+M1=M
    <- inner-efxmap`disjoint-join-commutative M2^M1 M2+M1=M M1+M2=M.

%worlds () (select-set-implies-disjoint-join _ _ _).
%total (S) (select-set-implies-disjoint-join S _ _).


%theorem select-tgtmap-implies-deep-disjoint-join
  : forall* {M} {M1} {M2} {G}
    forall {SG: select-tgtmap M G M1 M2}
    exists {DJ: efxmap`deep-disjoint M1 M2} {J: efxmap`join M1 M2 M}
    true.

- : select-tgtmap-implies-deep-disjoint-join
    select-tgtmap/0 efxmap`deep-disjoint/L efxmap`join/L.

- : select-tgtmap-implies-deep-disjoint-join
    (select-tgtmap/U/in M2P+N+X2=M2 M1P+N+X1=M1 MP=>M1P+M2P
      X+S=>X1+X2 G->N=S MP+N+X=M N!<MP) M1^M2 M1+M2=M
    <- select-tgtmap-implies-deep-disjoint-join MP=>M1P+M2P M1P^M2P M1P+M2P=MP
    <- select-set-implies-disjoint-join X+S=>X1+X2 X1^X2 X1+X2=X
    <- efxmap`update-disjoint-preserves-deep-disjoint
      M1P^M2P M1P+N+X1=M1 M2P+N+X2=M2 X1^X2 M1^M2
    <- select-tgtmap-implies-leq MP=>M1P+M2P M1P<=MP M2P<=MP
    <- efxmap`fresh-respects-geq N!<MP M1P<=MP N!<M1P
    <- efxmap`fresh-respects-geq N!<MP M2P<=MP N!<M2P
    <- efxmap`fresh-update-implies-unit-join N!<M1P M1P+N+X1=M1 M1P+X1=M1
    <- efxmap`fresh-update-implies-unit-join N!<M2P M2P+N+X2=M2 M2P+X2=M2
    <- efxmap`fresh-update-implies-unit-join N!<MP MP+N+X=M MP+X=M
    <- efxmap`deep-disjoint-join-commutative M1P^M2P M1P+M2P=MP M2P+M1P=MP
    <- efxmap`join-associative-converse
      (efxmap`join/= efxmap`join/L X1+X2=X nat`eq/)
      MP+X=M MU MP+X1=MU MU+X2=M
    <- efxmap`join-associative* M2P+M1P=MP MP+X1=MU M1P+X1=M1 M2P+M1=MU
    <- efxmap`deep-disjoint-symmetric M1P^M2P M2P^M1P
    <- efxmap`fresh-update-preserves-deep-disjoint M2P^M1P N!<M2P M1P+N+X1=M1 M2P^M1
    <- efxmap`deep-disjoint-join-commutative M2P^M1 M2P+M1=MU M1+M2P=MU
    <- efxmap`join-associative* M1+M2P=MU MU+X2=M M2P+X2=M2 M1+M2=M.

- : select-tgtmap-implies-deep-disjoint-join
    (select-tgtmap/U/out M1P+N+X=M1 MP+G=>M1P+M2 N!<G
      MP+N+X=M N!<MP) M1^M2 M1+M2=M
    <- select-tgtmap-implies-leq MP+G=>M1P+M2 M1P<=MP M2<=MP
    <- efxmap`fresh-respects-geq N!<MP M1P<=MP N!<M1P
    <- efxmap`fresh-respects-geq N!<MP M2<=MP N!<M2
    <- select-tgtmap-implies-deep-disjoint-join MP+G=>M1P+M2 M1P^M2 M1P+M2=MP
    <- efxmap`deep-disjoint-symmetric M1P^M2 M2^M1P
    <- efxmap`fresh-update-preserves-deep-disjoint M2^M1P N!<M2 M1P+N+X=M1 M2^M1
    <- efxmap`deep-disjoint-symmetric M2^M1 M1^M2
    <- efxmap`fresh-update-implies-unit-join N!<M1P M1P+N+X=M1 M1P+X=M1
    <- efxmap`fresh-update-implies-unit-join N!<MP MP+N+X=M MP+X=M
    <- efxmap`deep-disjoint-join-commutative M1P^M2 M1P+M2=MP M2+M1P=MP
    <- efxmap`join-associative* M2+M1P=MP MP+X=M M1P+X=M1 M2+M1=M
    <- efxmap`deep-disjoint-join-commutative M2^M1 M2+M1=M M1+M2=M.

%worlds () (select-tgtmap-implies-deep-disjoint-join _ _ _).
%total (SG) (select-tgtmap-implies-deep-disjoint-join SG _ _).


%theorem select-set-leq-implies-leq/L
  : forall* {M} {M1} {M2} {M2P} {S} {X}
    forall {N} {SZ: inner-efxmap`size M N}
    {SS: select-set M S M1 M2P}
    {T: set2inner-efxmap S X M2} {LE: inner-efxmap`leq M2 M}
    exists {LE: inner-efxmap`leq M2 M2P}
    true.

- : select-set-leq-implies-leq/L _ _ select-set/0 _ inner-efxmap`leq/0
    inner-efxmap`leq/0.

%theorem select-set-leq-implies-leq/U/in
  : forall* {M2S} {M2P} {F} {Z} {M1} {MS} {S} {M} {M2} {X} {B}
    forall {N} {SZ: inner-efxmap`size M N}
    {U: inner-efxmap`update M2S F Z M2P}
    {SS: select-set MS S M1 M2S} {MB: set`member S F}
    {U: inner-efxmap`update MS F Z M} {FS: inner-efxmap`fresh MS F}
    %{||}% {T: set2inner-efxmap S X M2} {LE: inner-efxmap`leq M2 M}
    {IN?: inner-efxmap`domain? M2 F B}
    exists {LE: inner-efxmap`leq M2 M2P}
    true.

- : select-set-leq-implies-leq/U/in (s N) SZ
    M2S+F+Z=M2P MS+S=>M1+M2S F<-S MS+F+Z=M F!<MS S+X=>M2 M2<=M
    (inner-efxmap`domain?/in M2->F=XP) M2<=M2P
    <- set`member-implies-not-member-add F<-S SP F!<SP SP+F=S
    <- fresh-update-preserves-set2inner-efxmap-converse
      S+X=>M2 F!<SP SP+F=S M2U F!<M2U M2U+F+XP=M2 SP+X=>M2U
    <- inner-efxmap`fresh-update-preserves-leq-converse
      M2<=M F!<M2U M2U+F+XP=M2 F!<MS MS+F+Z=M M2U<=MS XP<=Z
    <- fresh-update2-preserves-select-set-converse
      MS+S=>M1+M2S F!<MS F!<SP SP+F=S MS+SP=>M1+M2S
    <- inner-efxmap`fresh-update-increases-size-converse SZ F!<MS MS+F+Z=M SZP
    <- select-set-leq-implies-leq/L N SZP MS+SP=>M1+M2S SP+X=>M2U M2U<=MS M2U<=M2S
    <- inner-efxmap`update-preserves-leq*
      M2U<=M2S XP<=Z M2U+F+XP=M2 M2S+F+Z=M2P M2<=M2P.

- : select-set-leq-implies-leq/U/in (s N) SZ
    M2S+F+Z=M2P MS+S=>M1+M2S F<-S MS+F+Z=M F!<MS S+X=>M2 M2<=M
    (inner-efxmap`domain?/out F!<M2) M2<=M2P
    <- inner-efxmap`fresh-update2-preserves-leq-converse
      M2<=M F!<M2 F!<MS MS+F+Z=M M2<=MS
    <- inner-efxmap`fresh-update-increases-size-converse SZ F!<MS MS+F+Z=M SZP
    <- select-set-leq-implies-leq/L N SZP MS+S=>M1+M2S S+X=>M2 M2<=MS M2<=M2S
    <- select-set-implies-leq MS+S=>M1+M2S _ M2S<=MS
    <- inner-efxmap`fresh-respects-geq F!<MS M2S<=MS F!<M2S
    <- inner-efxmap`fresh-update-implies-leq F!<M2S M2S+F+Z=M2P M2S<=M2P
    <- inner-efxmap`leq-transitive M2<=M2S M2S<=M2P M2<=M2P.

- : select-set-leq-implies-leq/L N SZ
    (select-set/U/in M2S+F+Z=M2P MS+S=>M1+M2S F<-S MS+F+Z=M F!<MS)
    S+X=>M2 M2<=M M2<=M2P
    <- inner-efxmap`domain?-total DM?
    <- select-set-leq-implies-leq/U/in N SZ M2S+F+Z=M2P MS+S=>M1+M2S F<-S
      MS+F+Z=M F!<MS S+X=>M2 M2<=M DM? M2<=M2P.

- : select-set-leq-implies-leq/L (s N) SZ
    (select-set/U/out M1S+F+Z=M1P MS+S=>M1S+M2P F!<S MS+F+Z=M F!<MS)
    S+X=>M2 M2<=M M2<=M2P
    <- set2inner-efxmap-preserves-fresh F!<S S+X=>M2 F!<M2
    <- inner-efxmap`fresh-update2-preserves-leq-converse
      M2<=M F!<M2 F!<MS MS+F+Z=M M2<=MS
    <- inner-efxmap`fresh-update-increases-size-converse SZ F!<MS MS+F+Z=M SZP
    <- select-set-leq-implies-leq/L N SZP MS+S=>M1S+M2P S+X=>M2 M2<=MS M2<=M2P.

%worlds () (select-set-leq-implies-leq/L _ _ _ _ _ _)
(select-set-leq-implies-leq/U/in _ _ _ _ _ _ _ _ _ _ _).
%total (N1 N2) (select-set-leq-implies-leq/U/in N1 _ _ _ _ _ _ _ _ _ _)
(select-set-leq-implies-leq/L N2 _ _ _ _ _).


%theorem select-set-leq-implies-leq
  : forall* {M} {M1} {M2} {M2P} {S} {X}
    forall {SS: select-set M S M1 M2P}
    {T: set2inner-efxmap S X M2} {LE: inner-efxmap`leq M2 M}
    exists {LE: inner-efxmap`leq M2 M2P}
    true.

- : select-set-leq-implies-leq SS T L LP
    <- inner-efxmap`size-total SZ
    <- select-set-leq-implies-leq/L _ SZ SS T L LP.

%worlds () (select-set-leq-implies-leq _ _ _ _).
%total {} (select-set-leq-implies-leq _ _ _ _).


%theorem select-tgtmap-leq-implies-leq/L
  : forall* {M} {G} {M1} {M2P} {X} {M2}
    forall {N} {SZ: efxmap`size M N} {SG: select-tgtmap M G M1 M2P}
    {T: tgtmap2efxmap G X M2} {LE: efxmap`leq M2 M}
    exists {LE: efxmap`leq M2 M2P}
    true.

- : select-tgtmap-leq-implies-leq/L _ _
    select-tgtmap/0 _ efxmap`leq/0 efxmap`leq/0.

%theorem select-tgtmap-leq-implies-leq/U/in
  : forall* {M} {G} {M1} {M2P} {X} {M2} {M2S} {M1S}
    {N} {D} {D1} {D2} {MS} {S} {B}
    forall {K} {SZ: efxmap`size M K}
    {U2: efxmap`update M2S N D2 M2P}
    {U1: efxmap`update M1S N D1 M1}
    {SG: select-tgtmap MS G M1S M2S}
    {SS: select-set D S D1 D2} {L: tgtmap`lookup G N S}
    {U: efxmap`update MS N D M} {FS: efxmap`fresh MS N} %{||}%
    {T: tgtmap2efxmap G X M2} {LE: efxmap`leq M2 M}
    {IN?: efxmap`domain? M2 N B}
    exists {LE: efxmap`leq M2 M2P}
    true.

- : select-tgtmap-leq-implies-leq/U/in (s N) SZ
    M2S+N+D2=M2P M1S+N+D1=M1 MS+G=>M1S+M2S
    D+S=>D1+D2 G->N=S MS+N+D=M N!<MS G+X=>M2 M2<=M
    (efxmap`domain?/in M2->N=DP) M2<=M2P
    <- tgtmap`lookup-implies-fresh-update G->N=S GP N!<GP GP+N+S=G
    <- fresh-update-preserves-tgtmap2efxmap-converse
      G+X=>M2 N!<GP GP+N+S=G M2U DP S+X=>DP N!<M2U M2U+N+DP=M2 GP+X=>M2U
    <- efxmap`fresh-update-preserves-leq-converse
      M2<=M N!<M2U M2U+N+DP=M2 N!<MS MS+N+D=M M2U<=MS DP<=D
    <- select-set-leq-implies-leq D+S=>D1+D2 S+X=>DP DP<=D DP<=D2
    <- fresh-update2-preserves-select-tgtmap-converse
      MS+G=>M1S+M2S N!<MS N!<GP GP+N+S=G MS+GP=>M1S+M2S
    <- efxmap`fresh-update-increases-size-converse SZ N!<MS MS+N+D=M SZP
    <- select-tgtmap-leq-implies-leq/L N SZP MS+GP=>M1S+M2S GP+X=>M2U M2U<=MS M2U<=M2S
    <- efxmap`update-preserves-leq*
      M2U<=M2S DP<=D2 M2U+N+DP=M2 M2S+N+D2=M2P M2<=M2P.

- :  select-tgtmap-leq-implies-leq/U/in (s N) SZ
    M2S+N+D2=M2P M1S+N+D1=M1 MS+G=>M1S+M2S
    D+S=>D1+D2 G->N=S MS+N+D=M N!<MS G+X=>M2 M2<=M
    (efxmap`domain?/out N!<M2) M2<=M2P
    <- efxmap`fresh-update2-preserves-leq-converse M2<=M N!<M2 N!<MS MS+N+D=M M2<=MS
    <- efxmap`fresh-update-increases-size-converse SZ N!<MS MS+N+D=M SZP
    <- select-tgtmap-leq-implies-leq/L N SZP MS+G=>M1S+M2S G+X=>M2 M2<=MS M2<=M2S
    <- select-tgtmap-implies-leq MS+G=>M1S+M2S _ M2S<=MS
    <- efxmap`fresh-respects-geq N!<MS M2S<=MS N!<M2S
    <- efxmap`fresh-update-implies-leq N!<M2S M2S+N+D2=M2P M2S<=M2P
    <- efxmap`leq-transitive M2<=M2S M2S<=M2P M2<=M2P.

- : select-tgtmap-leq-implies-leq/L N SZ
    (select-tgtmap/U/in M2S+N+D2=M2P M1S+N+D1=M1 MS+G=>M1S+M2S S+X=>D1+D2
      G->N=S MS+N+D=M N!<MS) G+X=>M2 M2<=M M2<=M2P
    <- efxmap`domain?-total DM?
    <- select-tgtmap-leq-implies-leq/U/in N SZ M2S+N+D2=M2P M1S+N+D1=M1
      MS+G=>M1S+M2S S+X=>D1+D2 G->N=S MS+N+D=M N!<MS G+X=>M2 M2<=M DM? M2<=M2P.

- : select-tgtmap-leq-implies-leq/L (s N) SZ
    (select-tgtmap/U/out M1S+N+D=M1 MS+G=>M1S+M2P N!<G MS+N+D=M N!<MS)
    G+X=>M2 M2<=M M2<=M2P
    <- tgtmap2efxmap-preserves-fresh N!<G G+X=>M2 N!<M2
    <- efxmap`fresh-update2-preserves-leq-converse
      M2<=M N!<M2 N!<MS MS+N+D=M M2<=MS
    <- efxmap`fresh-update-increases-size-converse SZ N!<MS MS+N+D=M SZP
    <- select-tgtmap-leq-implies-leq/L N SZP MS+G=>M1S+M2P G+X=>M2 M2<=MS M2<=M2P.

%worlds () (select-tgtmap-leq-implies-leq/L _ _ _ _ _ _)
(select-tgtmap-leq-implies-leq/U/in _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N1 N2) (select-tgtmap-leq-implies-leq/U/in N1 _ _ _ _ _ _ _ _ _ _ _ _)
(select-tgtmap-leq-implies-leq/L N2 _ _ _ _ _).


%theorem select-tgtmap-leq-implies-leq
  : forall* {M} {G} {M1} {M2P} {X} {M2}
    forall {SG: select-tgtmap M G M1 M2P}
    {T: tgtmap2efxmap G X M2} {LE: efxmap`leq M2 M}
    exists {LE: efxmap`leq M2 M2P}
    true.

- : select-tgtmap-leq-implies-leq SG T L LP
    <- efxmap`size-total SZ
    <- select-tgtmap-leq-implies-leq/L _ SZ SG T L LP.

%worlds () (select-tgtmap-leq-implies-leq _ _ _ _).
%total {} (select-tgtmap-leq-implies-leq _ _ _ _).


%theorem fresh-update2-preserves-select-tgtmap
  : forall* {M} {M1} {M2} {G} {GP} {N} {S}
    forall {SG: select-tgtmap M G M1 M2}
    {F: efxmap`fresh M N} {F: tgtmap`fresh G N}
    {U: tgtmap`update G N S GP}
    exists {SGP: select-tgtmap M GP M1 M2}
    true.

- : fresh-update2-preserves-select-tgtmap
    select-tgtmap/0 _ _ _ select-tgtmap/0.

%theorem fresh-update2-preserves-select-tgtmap/U/in
  : forall* {M} {MP} {M1} {M2} {M1P} {M2P} {G} {GP}
    {S1} {S2} {N1} {N2} {D} {D1} {D2} {B}
    forall {FS: efxmap`fresh MP N1}
    {U: efxmap`update MP N1 D M}
    {L: tgtmap`lookup G N1 S1}
    {SS: select-set D S1 D1 D2}
    {SG: select-tgtmap MP G M1P M2P}
    {U1: efxmap`update M1P N1 D1 M1}
    {U2: efxmap`update M2P N1 D2 M2}
    {F2: efxmap`fresh M N2}
    {F3: tgtmap`fresh G N2}
    {U3: tgtmap`update G N2 S2 GP}
    {EQ?: nat`eq? N1 N2 B}
    exists {SGP: select-tgtmap M GP M1 M2}
    true.

%theorem fresh-update2-preserves-select-tgtmap/U/out
  : forall* {M} {MP} {M1} {M2} {M1P} {G} {GP} {S2} {N1} {N2} {D} {B}
    forall {FS: efxmap`fresh MP N1}
    {U: efxmap`update MP N1 D M}
    {L: tgtmap`fresh G N1}
    {SG: select-tgtmap MP G M1P M2}
    {U1: efxmap`update M1P N1 D M1}
    {F2: efxmap`fresh M N2}
    {F3: tgtmap`fresh G N2}
    {U3: tgtmap`update G N2 S2 GP}
    {EQ?: nat`eq? N1 N2 B}
    exists {SGP: select-tgtmap M GP M1 M2}
    true.

- : fresh-update2-preserves-select-tgtmap/U/in
    N!<MP MP+N+D=M G->N=S1 D+S1=>D1+D2 MP+G=>M1P+M2P
    M1P+N+D1=M1 M2P+N+D2=M2 N!<M N!<G G+N+S2=GP (nat`eq?/yes) SG
    <- tgtmap`fresh-lookup-not-equal N!<G G->N=S1 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-select-tgtmap F SG.

- : fresh-update2-preserves-select-tgtmap/U/in
    N1!<MP MP+N1+D=M G->N1=S1 D+S1=>D1+D2 MP+G=>M1P+M2P
    M1P+N1+D1=M1 M2P+N1+D2=M2 N2!<M N2!<G G+N2+S2=GP (nat`eq?/no N1<>N2)
    (select-tgtmap/U/in M2P+N1+D2=M2 M1P+N1+D1=M1 MP+GP=>M1P+M2P
      D+S1=>D1+D2 GP->N1=S1 MP+N1+D=M N1!<MP)
    <- efxmap`update-preserves-fresh-converse N2!<M MP+N1+D=M N2!<MP
    <- fresh-update2-preserves-select-tgtmap
      MP+G=>M1P+M2P N2!<MP N2!<G G+N2+S2=GP MP+GP=>M1P+M2P
    <- tgtmap`update-preserves-lookup G->N1=S1 G+N2+S2=GP N1<>N2 GP->N1=S1.

- : fresh-update2-preserves-select-tgtmap/U/out
    N!<MP MP+N+D=M N!<G1 MP+G=>M1P+M2
    M1P+N+D=M1 N!<M N!<G2 G+N+S2=GP (nat`eq?/yes) SG
    <- efxmap`update-implies-lookup MP+N+D=M M->N=D
    <- efxmap`fresh-lookup-not-equal N!<M M->N=D N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-select-tgtmap F SG.

- : fresh-update2-preserves-select-tgtmap/U/out
    N1!<MP MP+N1+D=M N1!<G MP+G=>M1P+M2
    M1P+N1+D=M1 N2!<M N2!<G G+N2+S2=GP (nat`eq?/no N1<>N2)
    (select-tgtmap/U/out M1P+N1+D=M1 MP+GP=>M1P+M2 N1!<GP MP+N1+D=M N1!<MP)
    <- efxmap`update-preserves-fresh-converse N2!<M MP+N1+D=M N2!<MP
    <- fresh-update2-preserves-select-tgtmap
      MP+G=>M1P+M2 N2!<MP N2!<G G+N2+S2=GP MP+GP=>M1P+M2
    <- tgtmap`update-preserves-fresh N1!<G G+N2+S2=GP N1<>N2 N1!<GP.

- : fresh-update2-preserves-select-tgtmap
    (select-tgtmap/U/in M2P+N1+D2=M2 M1P+N1+D1=M1
      MP+G=>M1P+M2P D+S=>D1+D2 G->N1=S
      MP+N1+D=M N1!<MP) %{||}% N2!<M N2!<G G+N2+S2=GP M+GP=>M1+M2
    <- nat`eq?-total N1=N2?
    <- fresh-update2-preserves-select-tgtmap/U/in
      N1!<MP MP+N1+D=M G->N1=S D+S=>D1+D2 MP+G=>M1P+M2P
      M1P+N1+D1=M1 M2P+N1+D2=M2 %{||}% N2!<M N2!<G G+N2+S2=GP N1=N2? M+GP=>M1+M2.

- : fresh-update2-preserves-select-tgtmap
    (select-tgtmap/U/out M1P+N1+D=M1 MP+G=>M1P+M2 N1!<G MP+N+D=M N1!<MP)
    N2!<M N2!<G G+N2+S2=GP M+GP=>M1+M2
    <- nat`eq?-total N1=N2?
    <- fresh-update2-preserves-select-tgtmap/U/out
      N1!<MP MP+N+D=M N1!<G MP+G=>M1P+M2 M1P+N1+D=M1
      N2!<M N2!<G G+N2+S2=GP N1=N2? M+GP=>M1+M2.

%worlds ()
(fresh-update2-preserves-select-tgtmap _ _ _ _ _)
(fresh-update2-preserves-select-tgtmap/U/out _ _ _ _ _ _ _ _ _ _)
(fresh-update2-preserves-select-tgtmap/U/in _ _ _ _ _ _ _ _ _ _ _ _).
%total (S1 S2 S3)
(fresh-update2-preserves-select-tgtmap S1 _ _ _ _)
(fresh-update2-preserves-select-tgtmap/U/out _ _ _ S3 _ _ _ _ _ _)
(fresh-update2-preserves-select-tgtmap/U/in _ _ _ _ S2 _ _ _ _ _ _ _).


%theorem efxmap2tgtmap-right-implies-select-tgtmap
  : forall* {M1} {M2} {M} {G2}
    forall {T: efxmap2tgtmap M2 G2}
    {X: efxmap`deep-disjoint M1 M2}
    {J: efxmap`join M1 M2 M}
    exists {SG: select-tgtmap M G2 M1 M2}
    true.

%%% TODO: after fix efxmap2tgtmap.

%worlds () (efxmap2tgtmap-right-implies-select-tgtmap _ _ _ _).
%trustme %total {} (efxmap2tgtmap-right-implies-select-tgtmap _ _ _ _).


%theorem select-tgtmap-associates
  : forall* {M} {M1} {M2} {M3} {M4} {G1} {G2} {G}
    forall {SG1: select-tgtmap M G1 M1 M2}
    {SG2: select-tgtmap M1 G2 M3 M4}
    {L1: tgtmap`leq-efxmap G1 M}
    {L2: tgtmap`leq-efxmap G2 M1}
    {X: tgtmap`deep-disjoint G1 G2}
    {J: tgtmap`join G1 G2 G}
    exists {M5} {X: efxmap`deep-disjoint M4 M2}
    {J: efxmap`join M4 M2 M5}
    {SG: select-tgtmap M G M3 M5}
    true.

- : select-tgtmap-associates M+G1=>M1+M2
    M1+G2=>M3+M4 G1<=M G2<=M1 G1^G2 G1+G2=G M5 M4^M2 M4+M2=M5 M+G=>M3+M5
    <- select-tgtmap-implies-deep-disjoint-join M+G1=>M1+M2 M1^M2 M1+M2=M
    <- select-tgtmap-implies-deep-disjoint-join M1+G2=>M3+M4 M3^M4 M3+M4=M1
    <- select-tgtmap-implies-efxmap2tgtmap M+G1=>M1+M2 G1<=M M2=>G1
    <- select-tgtmap-implies-efxmap2tgtmap M1+G2=>M3+M4 G2<=M1 M4=>G2
    <- efxmap`join-associative M3+M4=M1 M1+M2=M M5 M4+M2=M5 M3+M5=M
    <- select-tgtmap-implies-leq M1+G2=>M3+M4 M3<=M1 _
    <- efxmap`deep-disjoint-respects-geq* M1^M2 M3<=M1 M3^M2
    <- efxmap`deep-disjoint-symmetric M3^M2 M2^M3
    <- efxmap`deep-disjoint-symmetric M3^M4 M4^M3
    <- efxmap`join-preserves-deep-disjoint* M4^M3 M2^M3 M4+M2=M5 M5^M3
    <- efxmap`deep-disjoint-symmetric M5^M3 M3^M5
    <- tgtmap`join-commutative G1+G2=G G2+G1=G
    <- join-preserves-efxmap2tgtmap* M4=>G2 M2=>G1 M4+M2=M5 G2+G1=G M5=>G
    <- efxmap2tgtmap-right-implies-select-tgtmap M5=>G M3^M5 M3+M5=M M+G=>M3+M5
    <- efxmap2tgtmap-preserves-deep-disjoint-converse M2=>G1 M4=>G2 G1^G2 M2^M4
    <- efxmap`deep-disjoint-symmetric M2^M4 M4^M2.

%worlds () (select-tgtmap-associates _ _ _ _ _ _ _ _ _ _).
%total {} (select-tgtmap-associates _ _ _ _ _ _ _ _ _ _).


%theorem select-set-self
  : forall* {S} {M} {M1} {M2}
    forall {SS: select-set M S M1 M2}
    {DM: inner-efxmap`domain M S}
    exists {E: inner-efxmap`eq M M2}
    true.

%theorem select-set-self/L
  : forall* {S} {M} {M1} {M2}
    forall {N} {SZ: set`size S N} {SS: select-set M S M1 M2}
    {DM: inner-efxmap`domain M S}
    exists {E: inner-efxmap`eq M M2}
    true.

- : select-set-self/L _ _ select-set/0 inner-efxmap`domain/0 inner-efxmap`eq/.

- : select-set-self/L (s N) SZ (select-set/U/in M2P+F+X=M2 MP+S=>M1+M2P F<-S
                                 MP+F+X=M F!<MP) DM-M=S M=M2
    <- set`member-implies-not-member-add F<-S SP F!<SP SP+F=S
    <- inner-efxmap`domain-commute-fresh-update-converse
      DM-M=S F!<MP MP+F+X=M F!<SP SP+F=S DM-MP=SP
    <- fresh-update2-preserves-select-set-converse MP+S=>M1+M2P
      F!<MP F!<SP SP+F=S MP+SP=>M1+M2P
    <- set`not-member-add-increases-size-converse SZ F!<SP SP+F=S SZP
    <- select-set-self/L N SZP MP+SP=>M1+M2P DM-MP=SP MP=M2P
    <- inner-efxmap`update-unique MP+F+X=M M2P+F+X=M2 MP=M2P nat`eq/ efx`eq/ M=M2.

- : select-set-self/L _ _ (select-set/U/out M1P+F+X=M1 MP+S=>M1P+M2 F!<S
                            MP+F+X=M F!<MP) DM-M=S M=M2
    <- inner-efxmap`update-implies-lookup MP+F+X=M L
    <- inner-efxmap`domain-preserves-lookup L DM-M=S MB
    <- set`not-member-member-not-equal F!<S MB NE
    <- nat`ne-anti-reflexive NE F
    <- inner-efxmap`false-implies-eq F M=M2.

%worlds () (select-set-self/L _ _ _ _ _).
%total (N) (select-set-self/L N _ _ _ _).

- : select-set-self SS DM E
    <- set`size-total SZ
    <- select-set-self/L _ SZ SS DM E.

%worlds () (select-set-self _ _ _).
%total {} (select-set-self S _ _).


%theorem select-tgtmap-self
  : forall* {M} {G} {M1} {M2}
    forall {SG: select-tgtmap M G M1 M2}
    {T: efxmap2tgtmap M G}
    exists {E: efxmap`eq M M2}
    true.

%theorem select-tgtmap-self/L
  : forall* {M} {G} {M1} {M2}
    forall {N} {SZ: tgtmap`size G N} {SG: select-tgtmap M G M1 M2}
    {T: efxmap2tgtmap M G}
    exists {E: efxmap`eq M M2}
    true.

- : select-tgtmap-self/L _ _ select-tgtmap/0 _ efxmap`eq/.

- : select-tgtmap-self/L (s N) SZ
    (select-tgtmap/U/in M2P+N+D2=M2 M1P+N+D1=M1 MP+G=>M1P+M2P D+S=>D1+D2
      G->N=S MP+N+D=M N!<MP) M=>G M=M2
    <- tgtmap`lookup-implies-fresh-update G->N=S GP N!<GP GP+N+S=G
    <- efxmap`update-implies-lookup MP+N+D=M M->N=D
    <- efxmap2tgtmap-lookup-implies-domain M=>G M->N=D G->N=S DM-D=S
    <- fresh-update-preserves-efxmap2tgtmap-converse*
      M=>G N!<MP MP+N+D=M N!<GP GP+N+S=G MP=>GP
    <- select-set-self D+S=>D1+D2 DM-D=S D=D2
    <- fresh-update2-preserves-select-tgtmap-converse MP+G=>M1P+M2P
      N!<MP N!<GP GP+N+S=G MP+GP=>M1P+M2P
    <- tgtmap`fresh-update-increases-size-converse SZ N!<GP GP+N+S=G SZP
    <- select-tgtmap-self/L N SZP MP+GP=>M1P+M2P MP=>GP MP=M2P
    <- efxmap`update-unique MP+N+D=M M2P+N+D2=M2 MP=M2P nat`eq/ D=D2 M=M2.

- : select-tgtmap-self/L _ _
    (select-tgtmap/U/out _ MP+G=>M1P+M2 N!<G
      MP+N+D=M N!<MP) M=>G M=M2
    <- efxmap`update-implies-lookup MP+N+D=M L
    <- efxmap2tgtmap-lookup-implies-lookup M=>G L _ _ LP
    <- tgtmap`fresh-lookup-not-equal N!<G LP NE
    <- nat`ne-anti-reflexive NE F
    <- efxmap`false-implies-eq F M=M2.

%worlds () (select-tgtmap-self/L _ _ _ _ _).
%total (N) (select-tgtmap-self/L N _ _ _ _).

- : select-tgtmap-self SS DM E
    <- tgtmap`size-total SZ
    <- select-tgtmap-self/L _ SZ SS DM E.

%worlds () (select-tgtmap-self _ _ _).
%total {} (select-tgtmap-self S _ _).