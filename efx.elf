%%% Effects 
%%% $Id: efx.elf,v 1.8 2013/06/09 16:59:23 csun Exp $

%%% Definitions

efx : type.	%name efx X.

efx/read : efx.

efx/write : efx.

efx/consume : efx.


%{ 2013.05.17: we treat expose effects on field target
as consume effects, which is not too precise. Another 
possible good way is to redefine tgtmap and efxmap, to allow
arbitrary field level. However, this turns out to be too
much work for now. }%  

% equality

eq : efx -> efx -> type.

eq/ : eq X X.


% less-eq

leq : efx -> efx -> type.

leq/rw : leq efx/read efx/write.

leq/rc : leq efx/read efx/consume.

leq/wc : leq efx/write efx/consume.

leq/eq : leq X1 X2 <- eq X1 X2.


% join

join : efx -> efx -> efx -> type.

join/rr : join efx/read efx/read efx/read.

join/rw : join efx/read efx/write efx/write.

join/wr : join efx/write efx/read efx/write.

join/ww : join efx/write efx/write efx/write.


%{ we CAN'T allow write /\ expose = expose (really sucks).
expose get converted to:
  \exists r_f (r.f -> r_f, r_f < 0.all, P(r_f))

for both input and output. But write converts to
  \exists r_f (r.f -> r_f, r_f.all -> 0, P(r_f))

for input. Thus, when checking E1 ; E2, we have no way to 
get the required permission for write (unless we have permission
for shared, but which will make it unsound.) }%


%%% Theorems


% equality

false-implies-eq : {F:void} eq X1 X2 -> type.
%mode +{X1} +{X2} +{V:void} -{E:eq X1 X2} false-implies-eq V E.

%worlds () (false-implies-eq _ _).
%total  {} (false-implies-eq _ _).


eq-transitive : eq X1 X2 -> eq X2 X3 -> eq X1 X3 -> type.

- : eq-transitive eq/ eq/ eq/.

%mode eq-transitive +E1 +E2 -E.

%worlds () (eq-transitive _ _ _).
%total  {} (eq-transitive _ _ _).


% leq

false-implies-leq : {F:void} leq X1 X2 -> type.
%mode +{X1} +{X2} +{V} -{LE: leq X1 X2} false-implies-leq V LE.

%worlds () (false-implies-leq _ _).
%total  {} (false-implies-leq _ _).


leq-respects-eq : leq X1 X2 -> eq X1 Y1 -> eq X2 Y2 -> leq Y1 Y2 -> type.
%mode leq-respects-eq +LE1 +E1 +E2 -LE2.

- : leq-respects-eq LE eq/ eq/ LE.

%worlds () (leq-respects-eq _ _ _ _).
%total  {} (leq-respects-eq _ _ _ _).


leq-reflexive : {X} leq X X -> type.
%mode leq-reflexive +X -LE.

- : leq-reflexive _ (leq/eq eq/) .

%worlds () (leq-reflexive _ _).
%total {} (leq-reflexive _ _).


leq-anti-symmetric : leq X1 X2 -> leq X2 X1 -> eq X1 X2 -> type.
%mode leq-anti-symmetric +LE1 +LE2 -E.

- : leq-anti-symmetric (leq/eq eq/) (leq/eq eq/) eq/.

%worlds () (leq-anti-symmetric _ _ _).
%total  {} (leq-anti-symmetric _ _ _).


leq-transitive : leq X1 X2 -> leq X2 X3 -> leq X1 X3 -> type.
%mode leq-transitive +LE1 +LE2 -LE3.

- : leq-transitive (leq/eq eq/) LE LE.

- : leq-transitive LE (leq/eq eq/) LE.

- : leq-transitive (leq/eq eq/) (leq/eq eq/) (leq/eq eq/).

- : leq-transitive leq/rw leq/wc leq/rc.

%worlds () (leq-transitive _ _ _).
%total  {} (leq-transitive _ _ _).



% join

false-implies-join* : {F:void} join X1 X2 X3 -> type.
%mode +{X1} +{X2} -{X3} +{V} -{J:join X1 X2 X3} false-implies-join* V J.

%worlds () (false-implies-join* _ _).
%total  {} (false-implies-join* _ _).


false-implies-join : {F:void} join X1 X2 X3 -> type.
%mode +{X1} +{X2} +{X3} +{V} -{J:join X1 X2 X3} false-implies-join V J.
%worlds () (false-implies-join _ _).
%total  {} (false-implies-join _ _).


join-implies-leq* : join X1 X2 X3 -> leq X1 X3 -> type.
%mode join-implies-leq* +J -LE.

- : join-implies-leq* join/rr (leq/eq eq/).

- : join-implies-leq* join/rw leq/rw.

- : join-implies-leq* join/wr (leq/eq eq/).

- : join-implies-leq* join/ww (leq/eq eq/).

%worlds () (join-implies-leq* _ _).
%total  {} (join-implies-leq* _ _).


join-implies-leq : join X1 X2 X3 -> leq X1 X3 -> leq X2 X3 -> type.
%mode join-implies-leq +J -LE1 -LE2.

- : join-implies-leq join/rr (leq/eq eq/) (leq/eq eq/).

- : join-implies-leq join/rw leq/rw (leq/eq eq/).

- : join-implies-leq join/wr (leq/eq eq/) leq/rw.

- : join-implies-leq join/ww (leq/eq eq/) (leq/eq eq/).

%worlds () (join-implies-leq _ _ _).
%total  {} (join-implies-leq _ _ _).


%theorem join-commutative
  : forall* {X1} {X2} {X}
    forall {J: join X1 X2 X}
    exists {J: join X2 X1 X}
    true.

- : join-commutative join/rw join/wr.

- : join-commutative join/wr join/rw.

- : join-commutative join/rr join/rr.

- : join-commutative join/ww join/ww.

%worlds () (join-commutative _ _).
%total {} (join-commutative _ _).


join-respects-eq
  : join X1 X2 X3
    -> eq X1 Y1
    -> eq X2 Y2
    -> eq X3 Y3
    -> join Y1 Y2 Y3 
    -> type.

%mode join-respects-eq +J1 +E1 +E2 +E3 -J2.

- : join-respects-eq J eq/ eq/ eq/ J.

%worlds () (join-respects-eq _ _ _ _ _).
%total  {} (join-respects-eq _ _ _ _ _).


join-deterministic 
  : join X1 X2 X3
    -> join Y1 Y2 Y3
    -> eq X1 Y1 
    -> eq X2 Y2
    -> eq X3 Y3
    -> type.

%mode join-deterministic +J1 +J2 +E1 +E2 -E3.

- : join-deterministic J J eq/ eq/ eq/.

%worlds () (join-deterministic _ _ _ _ _).
%total  {} (join-deterministic _ _ _ _ _).


join-associative
  : join X1 X2 X3 
    -> join X3 X4 X7
    -> {X6} join X2 X4 X6
    -> join X1 X6 X7
    -> type.

%mode join-associative +J1 +J2 -X6 -J3 -J4.

- : join-associative join/rr join/rr _ join/rr join/rr.

- : join-associative join/rr join/rw _ join/rw join/rw.

- : join-associative join/rw join/wr _ join/wr join/rw.

- : join-associative join/rw join/ww _ join/ww join/rw.

- : join-associative join/wr join/wr _ join/rr join/wr.

- : join-associative join/wr join/ww _ join/rw join/ww.

- : join-associative join/ww join/wr _ join/wr join/ww.

- : join-associative join/ww join/ww _ join/ww join/ww.

%worlds () (join-associative _ _ _ _ _).
%total  {} (join-associative _ _ _ _ _).


join-associative-converse
  : join X2 X4 X6
    -> join X1 X6 X7
    -> {X3} join X1 X2 X3
    -> join X3 X4 X7
    -> type.

%mode join-associative-converse +J1 +J2 -X -J3 -J4.

- : join-associative-converse join/rr join/rr _ join/rr join/rr.

- : join-associative-converse join/rw join/rw _ join/rr join/rw.

- : join-associative-converse join/wr join/rw _ join/rw join/wr.

- : join-associative-converse join/ww join/rw _ join/rw join/ww.

- : join-associative-converse join/rr join/wr _ join/wr join/wr.

- : join-associative-converse join/rw join/ww _ join/wr join/ww.

- : join-associative-converse join/wr join/ww _ join/ww join/wr.

- : join-associative-converse join/ww join/ww _ join/ww join/ww.

%worlds () (join-associative-converse _ _ _ _ _).
%total { } (join-associative-converse _ _ _ _ _).


%%% Abbreviations

%abbrev efx`eq = eq.
%abbrev efx`eq/ = eq/.
%abbrev efx`leq = leq.
%abbrev efx`leq/rw = leq/rw.
%abbrev efx`leq/rc = leq/rc.
%abbrev efx`leq/wc = leq/wc.
%abbrev efx`leq/eq = leq/eq.
%abbrev efx`join = join.
%abbrev efx`join/rr = join/rr.
%abbrev efx`join/rw = join/rw.
%abbrev efx`join/wr = join/wr.
%abbrev efx`join/ww = join/ww.
%abbrev efx`false-implies-eq = false-implies-eq.
%abbrev efx`eq-transitive = eq-transitive.
%abbrev efx`false-implies-leq = false-implies-leq.
%abbrev efx`leq-respects-eq = leq-respects-eq.
%abbrev efx`leq-reflexive = leq-reflexive.
%abbrev efx`leq-anti-symmetric = leq-anti-symmetric.
%abbrev efx`leq-transitive = leq-transitive.
%abbrev efx`false-implies-join = false-implies-join.
%abbrev efx`join-implies-leq* = join-implies-leq*.
%abbrev efx`join-implies-leq = join-implies-leq.
%abbrev efx`join-respects-eq = join-respects-eq.
%abbrev efx`join-deterministic = join-deterministic.
%abbrev efx`join-commutative = join-commutative.
%abbrev efx`join-associative = join-associative.
%abbrev efx`join-associative-converse = join-associative-converse.