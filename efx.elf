%%% Effects 

%%% Definitions

efx : type.	%name efx X.

efx/none : efx.

efx/read : efx.

efx/write : efx.

efx/consume : efx.


%{ 2013.05.17: we treat expose effects on field target
as consume effects, which is not too precise. Another 
possible good way is to redefine tgtmap and efxmap, to allow
arbitrary field level. However, this turns out to be too
much work for now. }%  

% equality

eq : efx -> efx -> type.

eq/ : eq X X.


ne : efx -> efx -> type.

ne/nr : ne efx/none efx/read.

ne/nw : ne efx/none efx/write.

ne/nc : ne efx/none efx/consume.

ne/rw : ne efx/read efx/write.

ne/rc : ne efx/read efx/consume.

ne/wc : ne efx/write efx/consume.

ne/sym : ne X1 X2 <- ne X2 X1.


eq? : efx -> efx -> bool -> type.

eq?/yes : eq? X X true.

eq?/no : eq? X1 X2 false <- ne X1 X2.


% less-than

lt : efx -> efx -> type.

lt/rw : lt efx/read efx/write.

lt/rc : lt efx/read efx/consume.

lt/wc : lt efx/write efx/consume.


% less-eq

leq : efx -> efx -> type.

leq/lt : leq X1 X2 <- lt X1 X2.

leq/eq : leq X1 X2 <- eq X1 X2.


% join
% no join for none

join : efx -> efx -> efx -> type.

join/n_ : join efx/none X X.

join/_n : join X efx/none X.

join/rr : join efx/read efx/read efx/read.

join/rw : join efx/read efx/write efx/write.

join/rc : join efx/read efx/consume efx/consume.

join/wr : join efx/write efx/read efx/write.

join/ww : join efx/write efx/write efx/write.

join/wc : join efx/write efx/consume efx/consume.



%{ we CAN'T allow write /\ expose = expose (really sucks).
expose get converted to:
  \exists r_f (r.f -> r_f, r_f < 0.all, P(r_f))

for both input and output. But write converts to
  \exists r_f (r.f -> r_f, r_f.all -> 0, P(r_f))

for input. Thus, when checking E1 ; E2, we have no way to 
get the required permission for write (unless we have permission
for shared, but which will make it unsound.) }%


%%% Theorems


% equality

%theorem false-implies-eq
  : forall* {X1} {X2} 
    forall {F:void} 
    exists {E: eq X1 X2}
    true.

%worlds () (false-implies-eq _ _).
%total {} (false-implies-eq _ _).


%theorem eq-transitive
  : forall* {X1} {X2} {X3}
    forall {E12: eq X1 X2} {E23: eq X2 X3}
    exists {E13: eq X1 X3}
    true.

- : eq-transitive eq/ eq/ eq/.

%worlds () (eq-transitive _ _ _).
%total {} (eq-transitive _ _ _).


%theorem eq?-total
  : forall {X1} {X2}
    exists {B} {E?: eq? X1 X2 B}
    true.

- : eq?-total efx/none efx/none true eq?/yes.

- : eq?-total efx/read efx/none false (eq?/no (ne/sym ne/nr)).

- : eq?-total efx/write efx/none false (eq?/no (ne/sym ne/nw)).

- : eq?-total efx/consume efx/none false (eq?/no (ne/sym ne/nc)).

- : eq?-total efx/none efx/read false (eq?/no ne/nr).

- : eq?-total efx/none efx/write false (eq?/no ne/nw).

- : eq?-total efx/none efx/consume false (eq?/no ne/nc).

- : eq?-total efx/read efx/read true eq?/yes.

- : eq?-total efx/read efx/write false (eq?/no ne/rw).

- : eq?-total efx/read efx/consume false (eq?/no ne/rc).

- : eq?-total efx/write efx/write true eq?/yes.

- : eq?-total efx/write efx/read false (eq?/no (ne/sym ne/rw)).

- : eq?-total efx/write efx/consume false (eq?/no ne/wc).

- : eq?-total efx/consume efx/consume true eq?/yes.

- : eq?-total efx/consume efx/read false (eq?/no (ne/sym ne/rc)).

- : eq?-total efx/consume efx/write false (eq?/no (ne/sym ne/wc)).

%worlds () (eq?-total _ _ _ _).
%total {} (eq?-total _ _ _ _). 


% leq

%theorem false-implies-leq
  : forall* {X1} {X2}
    forall {F:void} 
    exists {LE: leq X1 X2}
    true.

%worlds () (false-implies-leq _ _).
%total {} (false-implies-leq _ _).


%theorem leq-respects-eq
  : forall* {X1} {X2} {Y1} {Y2}
    forall {LE: leq X1 X2} {E: eq X1 Y1} {E: eq X2 Y2}
    exists {LE: leq Y1 Y2}
    true.

- : leq-respects-eq LE eq/ eq/ LE.

%worlds () (leq-respects-eq _ _ _ _).
%total {} (leq-respects-eq _ _ _ _).


%theorem leq-reflexive
  : forall {X} 
    exists {LE: leq X X}
    true.

- : leq-reflexive _ (leq/eq eq/) .

%worlds () (leq-reflexive _ _).
%total {} (leq-reflexive _ _).


%theorem leq-anti-symmetric
  : forall* {X1} {X2}
    forall {LE: leq X1 X2} {LE: leq X2 X1}
    exists {E: eq X1 X2}
    true.

- : leq-anti-symmetric (leq/eq eq/) (leq/eq eq/) eq/.

%worlds () (leq-anti-symmetric _ _ _).
%total {} (leq-anti-symmetric _ _ _).


%theorem lt-transitive
  : forall* {X1} {X2} {X3}
    forall {LT: lt X1 X2} {LT: lt X2 X3}
    exists {LT: lt X1 X3}
    true.

- : lt-transitive lt/nr lt/rw lt/nw.

- : lt-transitive lt/nr lt/rc lt/nc.

- : lt-transitive lt/nw lt/wc lt/nc.

- : lt-transitive lt/rw lt/wc lt/rc.

%worlds () (lt-transitive _ _ _).
%total {} (lt-transitive _ _ _). 


%theorem leq-transitive
  : forall* {X1} {X2} {X3}
    forall {LE: leq X1 X2} {LE: leq X2 X3}
    exists {LE: leq X1 X3}
    true.

- : leq-transitive (leq/eq eq/) LE LE.

- : leq-transitive LE (leq/eq eq/) LE.

- : leq-transitive (leq/eq eq/) (leq/eq eq/) (leq/eq eq/).

- : leq-transitive (leq/lt lt/rw) (leq/lt lt/wc) (leq/lt lt/rc).

%worlds () (leq-transitive _ _ _).
%total {} (leq-transitive _ _ _).


% join

%theorem false-implies-join*
  : forall* {X1} {X2} {X3}
    forall {F:void} 
    exists {J: join X1 X2 X3}
    true.

%worlds () (false-implies-join* _ _).
%total {} (false-implies-join* _ _).


%theorem false-implies-join
  : forall* {X1} {X2} {X3}
    forall {F:void} 
    exists {J: join X1 X2 X3}
    true.

%worlds () (false-implies-join _ _).
%total {} (false-implies-join _ _).


%theorem efx/none-leq-all
  : forall {X}
    exists {LE: leq efx/none X}
    true.

- : efx/none-leq-all efx/none (leq/eq eq/).

- : efx/none-leq-all efx/read (leq/lt lt/nr).

- : efx/none-leq-all efx/write (leq/lt lt/nw).

- : efx/none-leq-all efx/consume (leq/lt lt/nc).

%worlds () (efx/none-leq-all _ _).
%total {} (efx/none-leq-all _ _).


%theorem join-implies-leq*
  : forall* {X1} {X2} {X3}
    forall {J: join X1 X2 X3}
    exists {LE: leq X1 X3}
    true.

- : join-implies-leq* join/n_ LE
    <- efx/none-leq-all _ LE.

- : join-implies-leq* join/_n LE
    <- efx/none-leq-all _ LE.

- : join-implies-leq* join/rr (leq/eq eq/).

- : join-implies-leq* join/rw (leq/lt lt/rw).

- : join-implies-leq* join/wr (leq/eq eq/).

- : join-implies-leq* join/ww (leq/eq eq/).

- : join-implies-leq* join/rc (leq/lt lt/rc).

- : join-implies-leq* join/wc (leq/lt lt/wc).

%worlds () (join-implies-leq* _ _).
%trustme %total {} (join-implies-leq* _ _).


%theorem join-implies-leq
  : forall* {X1} {X2} {X3}
    forall {J: join X1 X2 X3}
    exists {LE13: leq X1 X3} {LE23: leq X2 X3}
    true.

- : join-implies-leq join/rr (leq/eq eq/) (leq/eq eq/).

- : join-implies-leq join/rw (leq/lt lt/rw) (leq/eq eq/).

- : join-implies-leq join/wr (leq/eq eq/) (leq/lt lt/rw).

- : join-implies-leq join/ww (leq/eq eq/) (leq/eq eq/).

- : join-implies-leq join/rc (leq/lt lt/rc) (leq/eq eq/).

- : join-implies-leq join/wc (leq/lt lt/wc) (leq/eq eq/).

%worlds () (join-implies-leq _ _ _).
%trustme %total {} (join-implies-leq _ _ _).


%theorem join-respects-eq
  : forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
    forall {J: join X1 X2 X3} {E: eq X1 Y1} {E: eq X2 Y2} {E: eq X3 Y3} 
    exists {J: join Y1 Y2 Y3}
    true.

- : join-respects-eq J eq/ eq/ eq/ J.

%worlds () (join-respects-eq _ _ _ _ _).
%total {} (join-respects-eq _ _ _ _ _).


%theorem join-deterministic 
  : forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
    forall {J: join X1 X2 X3} {J: join Y1 Y2 Y3}
    {E: eq X1 Y1} {E: eq X2 Y2}
    exists {E: eq X3 Y3}
    true.

- : join-deterministic J J eq/ eq/ eq/.

- : join-deterministic join/n_ join/_n eq/ eq/ eq/.

- : join-deterministic join/_n join/n_ eq/ eq/ eq/.

%worlds () (join-deterministic _ _ _ _ _).
%total {} (join-deterministic _ _ _ _ _).


%theorem join-associative
  : forall* {X1} {X2} {X3} {X4} {X7}
    forall {J: join X1 X2 X3} {J: join X3 X4 X7}
    exists {X6} {J: join X2 X4 X6} {J: join X1 X6 X7}
    true.

- : join-associative join/rr join/rr _ join/rr join/rr.

- : join-associative join/rr join/rw _ join/rw join/rw.

- : join-associative join/rw join/wr _ join/wr join/rw.

- : join-associative join/rw join/ww _ join/ww join/rw.

- : join-associative join/wr join/wr _ join/rr join/wr.

- : join-associative join/wr join/ww _ join/rw join/ww.

- : join-associative join/ww join/wr _ join/wr join/ww.

- : join-associative join/ww join/ww _ join/ww join/ww.

- : join-associative join/rr join/rc _ join/rc join/rc.

- : join-associative join/rw join/wc _ join/wc join/rc.

- : join-associative join/wr join/wc _ join/rc join/wc.

- : join-associative join/ww join/wc _ join/wc join/wc.

- : join-associative join/n_ join/n_ _ join/n_ join/n_.

- : join-associative join/_n join/n_ _ join/n_ join/n_.

- : join-associative join/n_ join/_n _ join/_n join/n_.

- : join-associative join/_n join/_n _ join/n_ join/_n.

- : join-associative join/rr join/_n _ join/_n join/rr.

- : join-associative join/rw join/_n _ join/_n join/rw.

- : join-associative join/rc join/_n _ join/_n join/rc.

- : join-associative join/wr join/_n _ join/_n join/wr.

- : join-associative join/ww join/_n _ join/_n join/ww.

- : join-associative join/wc join/_n _ join/_n join/wc.

- : join-associative join/n_ join/rr _ join/rr join/n_.

- : join-associative join/n_ join/rw _ join/rw join/n_.

- : join-associative join/n_ join/rc _ join/rc join/n_.

- : join-associative join/n_ join/wr _ join/wr join/n_.

- : join-associative join/n_ join/ww _ join/ww join/n_.

- : join-associative join/n_ join/wc _ join/wc join/n_.

- : join-associative join/_n join/rr _ join/n_ join/rr.

- : join-associative join/_n join/rw _ join/n_ join/rw.

- : join-associative join/_n join/wr _ join/n_ join/wr.

- : join-associative join/_n join/ww _ join/n_ join/ww.

- : join-associative join/_n join/rc _ join/n_ join/rc.

- : join-associative join/_n join/wc _ join/n_ join/wc.

%worlds () (join-associative _ _ _ _ _).
%total {} (join-associative _ _ _ _ _).


%theorem join-associative-converse
  : forall* {X1} {X2} {X4} {X6} {X7}
    forall {J: join X2 X4 X6} {J: join X1 X6 X7}
    exists {X3} {J: join X1 X2 X3} {J: join X3 X4 X7}
    true.

- : join-associative-converse join/rr join/rr _ join/rr join/rr.

- : join-associative-converse join/rw join/rw _ join/rr join/rw.

- : join-associative-converse join/wr join/rw _ join/rw join/wr.

- : join-associative-converse join/ww join/rw _ join/rw join/ww.

- : join-associative-converse join/rr join/wr _ join/wr join/wr.

- : join-associative-converse join/rw join/ww _ join/wr join/ww.

- : join-associative-converse join/wr join/ww _ join/ww join/wr.

- : join-associative-converse join/ww join/ww _ join/ww join/ww.

- : join-associative-converse join/wc join/rc _ join/rw join/wc.

- : join-associative-converse join/rc join/wc _ join/wr join/wc.

- : join-associative-converse join/rc join/rc _ join/rr join/rc.

- : join-associative-converse join/wc join/wc _ join/ww join/wc.

- : join-associative-converse join/n_ join/rr _ join/_n join/rr.

%worlds () (join-associative-converse _ _ _ _ _).
%trustme %total {} (join-associative-converse _ _ _ _ _).


%%% Abbreviations

%abbrev efx`eq = eq.
%abbrev efx`eq/ = eq/.
%abbrev efx`ne = ne.
%abbrev efx`ne/nr = ne/nr.
%abbrev efx`ne/nw = ne/nw.
%abbrev efx`ne/nc = ne/nc.
%abbrev efx`ne/rw = ne/rw.
%abbrev efx`ne/rc = ne/rc.
%abbrev efx`ne/wc = ne/wc.
%abbrev efx`ne/sym = ne/sym.
%abbrev efx`eq? = eq?.
%abbrev efx`eq?/yes = eq?/yes.
%abbrev efx`eq?/no = eq?/no.
%abbrev efx`lt = lt.
%abbrev efx`leq = leq.
%abbrev efx`lt/rw = lt/rw.
%abbrev efx`lt/rc = lt/rc.
%abbrev efx`lt/wc = lt/wc.
%abbrev efx`leq/lt = leq/lt.
%abbrev efx`leq/eq = leq/eq.
%abbrev efx`join = join.
%abbrev efx`join/n_ = join/n_.
%abbrev efx`join/_n = join/_n.
%abbrev efx`join/rr = join/rr.
%abbrev efx`join/rw = join/rw.
%abbrev efx`join/wr = join/wr.
%abbrev efx`join/ww = join/ww.
%abbrev efx`join/wc = join/wc.
%abbrev efx`false-implies-eq = false-implies-eq.
%abbrev efx`eq-transitive = eq-transitive.
%abbrev efx`eq?-total = eq?-total.
%abbrev efx`false-implies-leq = false-implies-leq.
%abbrev efx`leq-respects-eq = leq-respects-eq.
%abbrev efx`leq-reflexive = leq-reflexive.
%abbrev efx`leq-anti-symmetric = leq-anti-symmetric.
%abbrev efx`lt-transitive = lt-transitive.
%abbrev efx`leq-transitive = leq-transitive.
%abbrev efx`false-implies-join = false-implies-join.
%abbrev efx`join-implies-leq* = join-implies-leq*.
%abbrev efx`join-implies-leq = join-implies-leq.
%abbrev efx`join-respects-eq = join-respects-eq.
%abbrev efx`join-deterministic = join-deterministic.
%abbrev efx`join-commutative = join-commutative.
%abbrev efx`join-associative = join-associative.
%abbrev efx`join-associative-converse = join-associative-converse.