%%% Effects 

%%% Definitions

efx : type.	%name efx X.

efx/read : efx.
efx/write : efx.
efx/consume : efx.


%{ 2013.05.17: we treat expose effects on field target
as consume effects, which is not too precise. Another 
possible good way is to redefine tgtmap and efxmap, to allow
arbitrary field level. However, this turns out to be too
much work for now. }%  

% equality

eq : efx -> efx -> type.

eq/ : eq X X.


ne : efx -> efx -> type.

ne/rw : ne efx/read efx/write.
ne/rc : ne efx/read efx/consume.
ne/wc : ne efx/write efx/consume.
ne/sym : ne X1 X2 <- ne X2 X1.


eq? : efx -> efx -> bool -> type.

eq?/yes : eq? X X true.
eq?/no : eq? X1 X2 false <- ne X1 X2.


% less-eq

leq : efx -> efx -> type.

leq/rw : leq efx/read efx/write.
leq/rc : leq efx/read efx/consume.
leq/wc : leq efx/write efx/consume.
leq/eq : leq X1 X2 <- eq X1 X2.


% join

join : efx -> efx -> efx -> type.

join/rr : join efx/read efx/read efx/read.
join/rw : join efx/read efx/write efx/write.
join/rc : join efx/read efx/consume efx/consume.
join/wr : join efx/write efx/read efx/write.
join/ww : join efx/write efx/write efx/write.
join/wc : join efx/write efx/consume efx/consume.



%{ we CAN'T allow write /\ expose = expose (really sucks).
expose get converted to:
  \exists r_f (r.f -> r_f, r_f < 0.all, P(r_f))

for both input and output. But write converts to
  \exists r_f (r.f -> r_f, r_f.all -> 0, P(r_f))

for input. Thus, when checking E1 ; E2, we have no way to 
get the required permission for write (unless we have permission
for shared, but which will make it unsound.) }%


%%% Theorems


% equality

%theorem false-implies-eq
  : forall* {X1} {X2} 
    forall {F:void} 
    exists {E: eq X1 X2}
    true.

%worlds () (false-implies-eq _ _).
%total {} (false-implies-eq _ _).


%theorem eq-transitive
  : forall* {X1} {X2} {X3}
    forall {E12: eq X1 X2} {E23: eq X2 X3}
    exists {E13: eq X1 X3}
    true.

- : eq-transitive eq/ eq/ eq/.

%worlds () (eq-transitive _ _ _).
%total {} (eq-transitive _ _ _).


%theorem eq?-total
  : forall {X1} {X2}
    exists {B} {E?: eq? X1 X2 B}
    true.

- : eq?-total efx/read efx/read true eq?/yes.

- : eq?-total efx/read efx/write false (eq?/no ne/rw).

- : eq?-total efx/read efx/consume false (eq?/no ne/rc).

- : eq?-total efx/write efx/write true eq?/yes.

- : eq?-total efx/write efx/read false (eq?/no (ne/sym ne/rw)).

- : eq?-total efx/write efx/consume false (eq?/no ne/wc).

- : eq?-total efx/consume efx/consume true eq?/yes.

- : eq?-total efx/consume efx/read false (eq?/no (ne/sym ne/rc)).

- : eq?-total efx/consume efx/write false (eq?/no (ne/sym ne/wc)).

%worlds () (eq?-total _ _ _ _).
%total {} (eq?-total _ _ _ _). 


% leq

%theorem false-implies-leq
  : forall* {X1} {X2}
    forall {F:void} 
    exists {LE: leq X1 X2}
    true.

%worlds () (false-implies-leq _ _).
%total {} (false-implies-leq _ _).


%theorem leq-respects-eq
  : forall* {X1} {X2} {Y1} {Y2}
    forall {LE: leq X1 X2} {E: eq X1 Y1} {E: eq X2 Y2}
    exists {LE: leq Y1 Y2}
    true.

- : leq-respects-eq LE eq/ eq/ LE.

%worlds () (leq-respects-eq _ _ _ _).
%total {} (leq-respects-eq _ _ _ _).


%theorem leq-reflexive
  : forall {X} 
    exists {LE: leq X X}
    true.

- : leq-reflexive _ (leq/eq eq/) .

%worlds () (leq-reflexive _ _).
%total {} (leq-reflexive _ _).


%theorem leq-anti-symmetric
  : forall* {X1} {X2}
    forall {LE: leq X1 X2} {LE: leq X2 X1}
    exists {E: eq X1 X2}
    true.

- : leq-anti-symmetric (leq/eq eq/) (leq/eq eq/) eq/.

%worlds () (leq-anti-symmetric _ _ _).
%total {} (leq-anti-symmetric _ _ _).


%theorem leq-transitive
  : forall* {X1} {X2} {X3}
    forall {LE: leq X1 X2} {LE: leq X2 X3}
    exists {LE: leq X1 X3}
    true.

- : leq-transitive (leq/eq eq/) LE LE.

- : leq-transitive LE (leq/eq eq/) LE.

- : leq-transitive (leq/eq eq/) (leq/eq eq/) (leq/eq eq/).

- : leq-transitive leq/rw leq/wc leq/rc.

%worlds () (leq-transitive _ _ _).
%total {} (leq-transitive _ _ _).



% join

%theorem false-implies-join*
  : forall* {X1} {X2} {X3}
    forall {F:void} 
    exists {J: join X1 X2 X3}
    true.

%worlds () (false-implies-join* _ _).
%total {} (false-implies-join* _ _).


%theorem false-implies-join
  : forall* {X1} {X2} {X3}
    forall {F:void} 
    exists {J: join X1 X2 X3}
    true.

%worlds () (false-implies-join _ _).
%total {} (false-implies-join _ _).


%theorem join-implies-leq*
  : forall* {X1} {X2} {X3}
    forall {J: join X1 X2 X3}
    exists {LE: leq X1 X3}
    true.

- : join-implies-leq* join/rr (leq/eq eq/).

- : join-implies-leq* join/rw leq/rw.

- : join-implies-leq* join/wr (leq/eq eq/).

- : join-implies-leq* join/ww (leq/eq eq/).

- : join-implies-leq* join/rc leq/rc.

- : join-implies-leq* join/wc leq/wc.

%worlds () (join-implies-leq* _ _).
%total {} (join-implies-leq* _ _).


%theorem join-implies-leq
  : forall* {X1} {X2} {X3}
    forall {J: join X1 X2 X3}
    exists {LE13: leq X1 X3} {LE23: leq X2 X3}
    true.

- : join-implies-leq join/rr (leq/eq eq/) (leq/eq eq/).

- : join-implies-leq join/rw leq/rw (leq/eq eq/).

- : join-implies-leq join/wr (leq/eq eq/) leq/rw.

- : join-implies-leq join/ww (leq/eq eq/) (leq/eq eq/).

- : join-implies-leq join/rc leq/rc (leq/eq eq/).

- : join-implies-leq join/wc leq/wc (leq/eq eq/).

%worlds () (join-implies-leq _ _ _).
%total {} (join-implies-leq _ _ _).


%theorem join-respects-eq
  : forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
    forall {J: join X1 X2 X3} {E: eq X1 Y1} {E: eq X2 Y2} {E: eq X3 Y3} 
    exists {J: join Y1 Y2 Y3}
    true.

- : join-respects-eq J eq/ eq/ eq/ J.

%worlds () (join-respects-eq _ _ _ _ _).
%total {} (join-respects-eq _ _ _ _ _).


%theorem join-deterministic 
  : forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
    forall {J: join X1 X2 X3} {J: join Y1 Y2 Y3}
    {E: eq X1 Y1} {E: eq X2 Y2}
    exists {E: eq X3 Y3}
    true.

- : join-deterministic J J eq/ eq/ eq/.

%worlds () (join-deterministic _ _ _ _ _).
%total {} (join-deterministic _ _ _ _ _).


%theorem join-associative
  : forall* {X1} {X2} {X3} {X4} {X7}
    forall {J: join X1 X2 X3} {J: join X3 X4 X7}
    exists {X6} {J: join X2 X4 X6} {J: join X1 X6 X7}
    true.

- : join-associative join/rr join/rr _ join/rr join/rr.

- : join-associative join/rr join/rw _ join/rw join/rw.

- : join-associative join/rw join/wr _ join/wr join/rw.

- : join-associative join/rw join/ww _ join/ww join/rw.

- : join-associative join/wr join/wr _ join/rr join/wr.

- : join-associative join/wr join/ww _ join/rw join/ww.

- : join-associative join/ww join/wr _ join/wr join/ww.

- : join-associative join/ww join/ww _ join/ww join/ww.

- : join-associative join/rr join/rc _ join/rc join/rc.

- : join-associative join/rw join/wc _ join/wc join/rc.

- : join-associative join/wr join/wc _ join/rc join/wc.

- : join-associative join/ww join/wc _ join/wc join/wc.

%worlds () (join-associative _ _ _ _ _).
%total {} (join-associative _ _ _ _ _).


%theorem join-associative-converse
  : forall* {X1} {X2} {X4} {X6} {X7}
    forall {J: join X2 X4 X6} {J: join X1 X6 X7}
    exists {X3} {J: join X1 X2 X3} {J: join X3 X4 X7}
    true.

- : join-associative-converse join/rr join/rr _ join/rr join/rr.

- : join-associative-converse join/rw join/rw _ join/rr join/rw.

- : join-associative-converse join/wr join/rw _ join/rw join/wr.

- : join-associative-converse join/ww join/rw _ join/rw join/ww.

- : join-associative-converse join/rr join/wr _ join/wr join/wr.

- : join-associative-converse join/rw join/ww _ join/wr join/ww.

- : join-associative-converse join/wr join/ww _ join/ww join/wr.

- : join-associative-converse join/ww join/ww _ join/ww join/ww.

- : join-associative-converse join/wc join/rc _ join/rw join/wc.

- : join-associative-converse join/rc join/wc _ join/wr join/wc.

- : join-associative-converse join/rc join/rc _ join/rr join/rc.

- : join-associative-converse join/wc join/wc _ join/ww join/wc.

%worlds () (join-associative-converse _ _ _ _ _).
%total {} (join-associative-converse _ _ _ _ _).


%%% Abbreviations

%abbrev efx`eq = eq.
%abbrev efx`eq/ = eq/.
%abbrev efx`ne = ne.
%abbrev efx`ne/rw = ne/rw.
%abbrev efx`ne/rc = ne/rc.
%abbrev efx`ne/wc = ne/wc.
%abbrev efx`ne/sym = ne/sym.
%abbrev efx`eq? = eq?.
%abbrev efx`eq?/yes = eq?/yes.
%abbrev efx`eq?/no = eq?/no.
%abbrev efx`leq = leq.
%abbrev efx`leq/rw = leq/rw.
%abbrev efx`leq/rc = leq/rc.
%abbrev efx`leq/wc = leq/wc.
%abbrev efx`leq/eq = leq/eq.
%abbrev efx`join = join.
%abbrev efx`join/rr = join/rr.
%abbrev efx`join/rw = join/rw.
%abbrev efx`join/wr = join/wr.
%abbrev efx`join/ww = join/ww.
%abbrev efx`join/wc = join/wc.
%abbrev efx`false-implies-eq = false-implies-eq.
%abbrev efx`eq-transitive = eq-transitive.
%abbrev efx`eq?-total = eq?-total.
%abbrev efx`false-implies-leq = false-implies-leq.
%abbrev efx`leq-respects-eq = leq-respects-eq.
%abbrev efx`leq-reflexive = leq-reflexive.
%abbrev efx`leq-anti-symmetric = leq-anti-symmetric.
%abbrev efx`leq-transitive = leq-transitive.
%abbrev efx`false-implies-join = false-implies-join.
%abbrev efx`join-implies-leq* = join-implies-leq*.
%abbrev efx`join-implies-leq = join-implies-leq.
%abbrev efx`join-respects-eq = join-respects-eq.
%abbrev efx`join-deterministic = join-deterministic.
%abbrev efx`join-commutative = join-commutative.
%abbrev efx`join-associative = join-associative.
%abbrev efx`join-associative-converse = join-associative-converse.