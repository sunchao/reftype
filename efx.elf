%%% Effects 
%%% $Id: efx.elf,v 1.2 2013/05/13 17:05:14 csun Exp csun $

%abbrev 0 = z.
%abbrev 1 = s 0.
%abbrev 2 = s 1.
%abbrev 3 = s 2.
%abbrev 2>0 = (nat`gt/> nat`gt/1).


%%% Definitions

efx : type.	%name efx X.

efx/ : nat -> efx.

%abbrev efx/read = efx/ 0.
%abbrev efx/write = efx/ 1.
%abbrev efx/expose = efx/ 2.
%abbrev efx/consume = efx/ 3.


% equality

eq : efx -> efx -> type.

eq/ : eq X X.


% well-formed efx 

wf-efx : efx -> type.

wf-efx/ : wf-efx (efx/ N) <- nat`le N 3.


% less-eq

leq : efx -> efx -> type.

leq/ : leq (efx/ N1) (efx/ N2)
    <- nat`le N1 N2.


% join

join : efx -> efx -> efx -> type.

join/1 : join (efx/ 2) (efx/ 2) (efx/ 2).

join/2 : join (efx/ N) (efx/ M) (efx/ P) 
         <- nat`lt N 2
         <- nat`ne M 2
         <- nat`max N M P.

%{ we CAN'T allow write /\ expose = expose (really sucks).
expose get converted to:
  \exists r_f (r.f -> r_f, r_f < 0.all, P(r_f))

for both input and output. But write converts to
  \exists r_f (r.f -> r_f, r_f.all -> 0, P(r_f))

for input. Thus, when checking E1 ; E2, we have no way to 
get the required permission for write (unless we have permission
for shared, but which will make it unsound.) }%


%%% Theorems


% lemmas about nat`max

max-zero-right : nat`max N 0 M -> nat`eq N M -> type.
%mode max-zero-right +MX -EQ.

- : max-zero-right (nat`max/> GT) nat`eq/.

- : max-zero-right nat`max/= nat`eq/.

%worlds () (max-zero-right _ _).
%total  {} (max-zero-right _ _).


max-zero-left : nat`max 0 N M -> nat`eq N M -> type.
%mode max-zero-left +MX -EQ.

- : max-zero-left (nat`max/< GT) nat`eq/.

- : max-zero-left nat`max/= nat`eq/.

%worlds () (max-zero-left _ _).
%total  {} (max-zero-left _ _).


max-zero : {N:nat} nat`max 0 N N -> type.
%mode max-zero +N -MX.

- : max-zero 0 nat`max/=.

- : max-zero (s N) (nat`max/< GT)
    <- nat`succ-implies-gt-zero N GT.

%worlds () (max-zero _ _).
%total {}  (max-zero _ _).


max-equal : nat`max N N M -> nat`eq N M -> type.
%mode max-equal +MX -EQ.

- : max-equal nat`max/= nat`eq/.

- : max-equal (nat`max/> GT) EQ
    <- nat`gt-anti-reflexive GT V
    <- nat`false-implies-eq V EQ.

- : max-equal (nat`max/< GT) EQ
    <- nat`gt-anti-reflexive GT V
    <- nat`false-implies-eq V EQ.

%worlds () (max-equal _ _).
%total  {} (max-equal _ _).


max-ge-lt-implies-eq
  : nat`max N M P -> nat`ge P H -> nat`lt N H -> nat`eq M P -> type.

%mode max-ge-lt-implies-eq +MX +GE +LT -EQ.

- : max-ge-lt-implies-eq (nat`max/< _) _ _ nat`eq/.

- : max-ge-lt-implies-eq nat`max/= _ _ nat`eq/.

- : max-ge-lt-implies-eq nat`max/= (nat`ge/= nat`eq/) _ nat`eq/.

- : max-ge-lt-implies-eq (nat`max/> _) (nat`ge/= nat`eq/) LT EQ
    <- nat`gt-anti-reflexive LT V
    <- nat`false-implies-eq V EQ.

- : max-ge-lt-implies-eq (nat`max/> _) (nat`ge/> GT) LT EQ
    <- nat`gt-anti-symmetric GT LT V
    <- nat`false-implies-eq V EQ.

%worlds () (max-ge-lt-implies-eq _ _ _ _).
%total  {} (max-ge-lt-implies-eq _ _ _ _).


max-gt-implies-eq : nat`max N M P -> nat`gt P N -> nat`eq M P -> type.
%mode max-gt-implies-eq +MX +GT -EQ.

- : max-gt-implies-eq (nat`max/< N<M) P>N nat`eq/.

- : max-gt-implies-eq (nat`max/> _) GT EQ
    <- nat`gt-anti-reflexive GT V
    <- nat`false-implies-eq V EQ.

- : max-gt-implies-eq nat`max/= GT EQ
    <- nat`gt-anti-reflexive GT V
    <- nat`false-implies-eq V EQ.

%worlds () (max-gt-implies-eq _ _ _).
%total  {} (max-gt-implies-eq _ _ _).


% equality

false-implies-eq : {F:void} eq X1 X2 -> type.
%mode +{X1} +{X2} +{V:void} -{E:eq X1 X2} false-implies-eq V E.
%worlds () (false-implies-eq _ _).
%total  {} (false-implies-eq _ _).


eq-transitive : eq X1 X2 -> eq X2 X3 -> eq X1 X3 -> type.

- : eq-transitive eq/ eq/ eq/.

%mode eq-transitive +E1 +E2 -E.
%worlds () (eq-transitive _ _ _).
%total  {} (eq-transitive _ _ _).


efx-eq-implies-eq : eq (efx/ N1) (efx/ N2) -> nat`eq N1 N2 -> type.
%mode efx-eq-implies-eq +XE -NE.

- : efx-eq-implies-eq eq/ nat`eq/.

%worlds () (efx-eq-implies-eq _ _).
%total  {} (efx-eq-implies-eq _ _).


efx-preserves-eq : nat`eq N1 N2 -> eq (efx/ N1) (efx/ N2) -> type.
%mode efx-preserves-eq +NE -XE.

- : efx-preserves-eq nat`eq/ eq/.

%worlds () (efx-preserves-eq _ _).
%total  {} (efx-preserves-eq _ _).


% leq

false-implies-leq : {F:void} leq X1 X2 -> type.
%mode +{X1} +{X2} +{V} -{LE: leq X1 X2} false-implies-leq V LE.
%worlds () (false-implies-leq _ _).
%total  {} (false-implies-leq _ _).


leq-respects-eq : leq X1 X2 -> eq X1 Y1 -> eq X2 Y2 -> leq Y1 Y2 -> type.
%mode leq-respects-eq +LE1 +E1 +E2 -LE2.

- : leq-respects-eq LE eq/ eq/ LE.

%worlds () (leq-respects-eq _ _ _ _).
%total  {} (leq-respects-eq _ _ _ _).


leq-reflexive : {X} leq X X -> type.
%mode leq-reflexive +X -LE.

- : leq-reflexive (efx/ N) (leq/ LE)
    <- nat`ge-reflexive N LE.

%worlds () (leq-reflexive _ _).
%total {} (leq-reflexive _ _).


leq-anti-symmetric : leq X1 X2 -> leq X2 X1 -> eq X1 X2 -> type.
%mode leq-anti-symmetric +LE1 +LE2 -E.

- : leq-anti-symmetric (leq/ GE1) (leq/ GE2) NE
    <- nat`ge-anti-symmetric GE2 GE1 XE
    <- efx-preserves-eq XE NE.

%worlds () (leq-anti-symmetric _ _ _).
%total  {} (leq-anti-symmetric _ _ _).


leq-transitive : leq X1 X2 -> leq X2 X3 -> leq X1 X3 -> type.
%mode leq-transitive +LE1 +LE2 -LE3.

- : leq-transitive (leq/ GE1) (leq/ GE2) (leq/ GE3)
    <- nat`ge-transitive GE2 GE1 GE3.

%worlds () (leq-transitive _ _ _).
%total  {} (leq-transitive _ _ _).


% join

false-implies-join* : {F:void} join X1 X2 X3 -> type.
%mode +{X1} +{X2} -{X3} +{V} -{J:join X1 X2 X3} false-implies-join* V J.
%worlds () (false-implies-join* _ _).
%total  {} (false-implies-join* _ _).


false-implies-join : {F:void} join X1 X2 X3 -> type.
%mode +{X1} +{X2} +{X3} +{V} -{J:join X1 X2 X3} false-implies-join V J.
%worlds () (false-implies-join _ _).
%total  {} (false-implies-join _ _).


join-implies-leq* : join X1 X2 X3 -> leq X1 X3 -> type.
%mode join-implies-leq* +J -LE.

- : join-implies-leq* join/1 (leq/ GE)
    <- nat`ge-reflexive 2 GE.

- : join-implies-leq* (join/2 MX _ _) (leq/ GE)
    <- nat`max-implies-ge MX GE _.

%worlds () (join-implies-leq* _ _).
%total  {} (join-implies-leq* _ _).


join-implies-leq : join X1 X2 X3 -> leq X1 X3 -> leq X2 X3 -> type.
%mode join-implies-leq +J -LE1 -LE2.

- : join-implies-leq join/1 (leq/ GE) (leq/ GE)
    <- nat`ge-reflexive 2 GE.

- : join-implies-leq (join/2 MX _ _) (leq/ GE1) (leq/ GE2)
    <- nat`max-implies-ge MX GE1 GE2.

%worlds () (join-implies-leq _ _ _).
%total  {} (join-implies-leq _ _ _).


join-respects-eq
  : join X1 X2 X3
    -> eq X1 Y1
    -> eq X2 Y2
    -> eq X3 Y3
    -> join Y1 Y2 Y3 
    -> type.

%mode join-respects-eq +J1 +E1 +E2 +E3 -J2.

- : join-respects-eq J eq/ eq/ eq/ J.

%worlds () (join-respects-eq _ _ _ _ _).
%total  {} (join-respects-eq _ _ _ _ _).


join-deterministic 
  : join X1 X2 X3
    -> join Y1 Y2 Y3
    -> eq X1 Y1 
    -> eq X2 Y2
    -> eq X3 Y3
    -> type.

%mode join-deterministic +J1 +J2 +E1 +E2 -E3.

- : join-deterministic join/1 join/1 eq/ eq/ eq/.

- : join-deterministic (join/2 MX1 LT1 NE1) (join/2 MX2 LT2 NE2) eq/ eq/ EQ
    <- nat`max-deterministic MX1 MX2 nat`eq/ nat`eq/ E
    <- efx-preserves-eq E EQ.

- : join-deterministic (join/2 MX _ _) join/1 eq/ eq/ EQ
    <- max-equal MX E
    <- nat`eq-symmetric E EP
    <- efx-preserves-eq EP EQ.

- : join-deterministic join/1 (join/2 MX _ _) eq/ eq/ EQ
    <- max-equal MX E
    <- nat`eq-symmetric E EP
    <- efx-preserves-eq EP EQ.

%worlds () (join-deterministic _ _ _ _ _).
%total  {} (join-deterministic _ _ _ _ _).


join-associative
  : join X1 X2 X3 
    -> join X3 X4 X7
    -> {X6} join X2 X4 X6
    -> join X1 X6 X7
    -> type.

%mode join-associative +J1 +J2 -X6 -J3 -J4.

- : join-associative join/1 join/1 _ join/1 join/1.

- : join-associative join/1 (join/2 MX NE LT) _ (join/2 MX NE LT) J2
    <- nat`gt-anti-reflexive LT V
    <- false-implies-join V J2.

- : join-associative (join/2 MX NE LT) join/1 _ J3 J4
    <- max-gt-implies-eq MX LT E
    <- nat`eq-ne-implies-false E NE V
    <- false-implies-join* V J3
    <- false-implies-join V J4.

both-ne-max-ne
  : nat`ne N1 M
    -> nat`ne N2 M
    -> nat`max N1 N2 N
    -> nat`ne N M
    -> type.

%mode both-ne-max-ne +NE1 +NE2 +MX -NE3.

- : both-ne-max-ne NE1 NE2 (nat`max/> _) NE1.

- : both-ne-max-ne NE1 NE2 (nat`max/< _) NE2.

- : both-ne-max-ne NE _ (nat`max/=) NE.

%worlds () (both-ne-max-ne _ _ _ _).
%total { } (both-ne-max-ne _ _ _ _).

- : join-associative
    (join/2 MX1 NE1 LT1) (join/2 MX2 NE2 LT2) (efx/ N) 
    (join/2 MX3 NE2 LT3) (join/2 MX4 NE LT1)
    <- nat`max-associative MX1 MX2 N MX3 MX4
    <- both-ne-max-ne NE1 NE2 MX3 NE
    <- nat`max-implies-ge MX1 _ GE
    <- nat`gt-transitive-ge LT2 GE LT3.

%worlds () (join-associative _ _ _ _ _).
%total  {} (join-associative _ _ _ _ _).

		
%%% Abbreviations

%abbrev efx`eq = eq.
%abbrev efx`eq/ = eq/.
%abbrev efx`wf-efx = wf-efx.
%abbrev efx`wf-efx/ = wf-efx/.
%abbrev efx`leq = leq.
%abbrev efx`leq/ = leq/.
%abbrev efx`join = join.
%abbrev efx`join/1 = join/1.
%abbrev efx`join/2 = join/2.
%abbrev efx`false-implies-eq = false-implies-eq.
%abbrev efx`eq-transitive = eq-transitive.
%abbrev efx`false-implies-leq = false-implies-leq.
%abbrev efx`leq-respects-eq = leq-respects-eq.
%abbrev efx`leq-reflexive = leq-reflexive.
%abbrev efx`leq-anti-symmetric = leq-anti-symmetric.
%abbrev efx`leq-transitive = leq-transitive.
%abbrev efx`false-implies-join = false-implies-join.
%abbrev efx`join-implies-leq* = join-implies-leq*.
%abbrev efx`join-implies-leq = join-implies-leq.
%abbrev efx`join-respects-eq = join-respects-eq.
%abbrev efx`join-deterministic = join-deterministic.
%abbrev efx`join-associative = join-associative.