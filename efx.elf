%%% effect 
%%% $Id: efx.elf,v 1.1 2012/10/15 20:01:05 csun Exp $


%%% definition

efx : type.	%name efx X.

efx/read : efx.

efx/write : efx.

efx/consume : efx.


%%% equality

eq : efx -> efx -> type.

eq/ : eq X X.


%%% less-eq

leq : efx -> efx -> type.

leq/rw : leq efx/read efx/write.

leq/rc : leq efx/read efx/consume.

leq/wc : leq efx/write efx/consume.

leq/eq : leq X1 X2 <- eq X1 X2.


%%% effect join

join : efx -> efx -> efx -> type.

join/rr : join efx/read efx/read efx/read.

join/ww : join efx/write efx/write efx/write.

join/rw : join efx/read efx/write efx/write.

join/wr : join efx/write efx/read efx/write.

join/rc : join efx/read efx/consume efx/consume.

join/wc : join efx/write efx/consume efx/consume.



%%% theorems


%%% theorems about equality

%theorem false-implies-eq :
	forall* {X1} {X2}
	forall  {F:void}
	exists  {E: eq X1 X2}
	true.

%worlds () (false-implies-eq _ _).
%total  {} (false-implies-eq _ _).


%theorem eq-transitive :
	forall* {X1} {X2} {X3}
	forall  {EQ: eq X1 X2}
		{EQ: eq X2 X3}
	exists  {EQ: eq X1 X3}
	true.

-: eq-transitive eq/ eq/ eq/.

%worlds () (eq-transitive _ _ _).
%total  {} (eq-transitive _ _ _).


%%% theorems about leq

%theorem false-implies-leq :
	forall* {X1} {X2}
	forall  {F:void}
	exists  {E: leq X1 X2}
	true.

%worlds () (false-implies-leq _ _).
%total  {} (false-implies-leq _ _).


%theorem leq-respects-eq :
	forall* {X1} {X2} {Y1} {Y2}
	forall  {L: leq X1 X2} {E1: eq X1 Y1}
		{E2: eq X2 Y2}
	exists  {L: leq Y1 Y2}
	true.

- : leq-respects-eq LEQ eq/ eq/ LEQ.
    
%worlds () (leq-respects-eq _ _ _ _).
%total  {} (leq-respects-eq _ _ _ _).


%theorem leq-reflexive :
	forall {X}
	exists {E: leq X X}
	true.

- : leq-reflexive _ (leq/eq eq/).

%worlds () (leq-reflexive _ _).
%total {} (leq-reflexive _ _).


%theorem leq-anti-symmetric :
	forall* {X1} {X2}
	forall  {L1: leq X1 X2} {L2: leq X2 X1}
	exists  {E: eq X1 X2}
	true.

- : leq-anti-symmetric (leq/eq EQ1) (leq/eq EQ2) EQ1.

%worlds () (leq-anti-symmetric _ _ _).
%total  {} (leq-anti-symmetric _ _ _).


%theorem leq-transitive :
	forall* {X1} {X2} {X3}
	forall  {L1: leq X1 X2} {L2: leq X2 X3}
	exists  {L3: leq X1 X3}
	true.

%worlds () (leq-transitive _ _ _).
%trustme %total  {} (leq-transitive _ _ _).


%%% theorems about join

%theorem false-implies-join :
	forall* {X1} {X2} {X3}
	forall  {F:void}
	exists  {J: join X1 X2 X3}
	true.

%worlds () (false-implies-join _ _).
%total  {} (false-implies-join _ _).


%theorem join-implies-leq* :
	forall* {X1} {X2} {X3}
	forall  {J: join X1 X2 X3}
	exists  {X1<=X3: leq X1 X3}
	true.

- : join-implies-leq* join/ww (leq/eq eq/).

- : join-implies-leq* join/wc leq/wc.

- : join-implies-leq* join/rr (leq/eq eq/).

- : join-implies-leq* join/rw leq/rw.

- : join-implies-leq* join/wr (leq/eq eq/).

- : join-implies-leq* join/rc leq/rc.

%worlds () (join-implies-leq* _ _).
%total  {} (join-implies-leq* _ _).


%theorem join-implies-leq :
	forall* {X0} {X1} {X2}
	forall  {J: join X0 X1 X2}
	exists  {X0<=X2: leq X0 X2}
		{X1<=X2: leq X1 X2}
	true.

- : join-implies-leq join/ww (leq/eq eq/) (leq/eq eq/). 

- : join-implies-leq join/wc (leq/wc) (leq/eq eq/).

%worlds () (join-implies-leq _ _ _).
%trustme %total  {} (join-implies-leq _ _ _).


%theorem join-respects-eq :
	forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
	forall  {J: join X1 X2 X3}
		{E1: eq X1 Y1}
		{E2: eq X2 Y2}
		{E3: eq X3 Y3}
	exists  {K: join Y1 Y2 Y3}
	true.

- : join-respects-eq J eq/ eq/ eq/ J.

%worlds () (join-respects-eq _ _ _ _ _).
%total  {} (join-respects-eq _ _ _ _ _).


%theorem join-deterministic :
	forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
	forall  {J: join X1 X2 X3} {K: join Y1 Y2 Y3}
		{E1: eq X1 Y1} {E2: eq X2 Y2}
	exists	{E3: eq X3 Y3}
	true.

- : join-deterministic J J eq/ eq/ eq/.

%worlds () (join-deterministic _ _ _ _ _).
%total  {} (join-deterministic _ _ _ _ _).


%theorem join-associative :
	forall* {X1} {X2} {X3} {X4} {X7}
	forall  {J: join X1 X2 X3} {J: join X3 X4 X7}
	exists  {X6} {J: join X2 X4 X6} {J: join X1 X6 X7}
	true.

- : join-associative join/rr join/rr _ join/rr join/rr.

- : join-associative join/ww join/ww _ join/ww join/ww.

- : join-associative join/rw join/ww _ join/ww join/rw.

- : join-associative join/wr join/ww _ join/rw join/ww.

- : join-associative join/rr join/rw _ join/rw join/rw.

- : join-associative join/rw join/wr _ join/wr join/rw.

- : join-associative join/wr join/wr _ join/rr join/wr.

- : join-associative join/ww join/wr _ join/wr join/ww.

- : join-associative join/rr join/rc _ join/rc join/rc.

- : join-associative join/rw join/wc _ join/wc join/rc.

- : join-associative join/ww join/wc _ join/wc join/wc.

- : join-associative join/wr join/wc _ join/rc join/wc.

%worlds () (join-associative _ _ _ _ _).
%total  {} (join-associative _ _ _ _ _).

		
%abbrev efx`eq = eq.
%abbrev efx`eq/ = eq/.
%abbrev efx`leq = leq.
%abbrev efx`leq/wc = leq/wc.
%abbrev efx`leq/eq = leq/eq.
%abbrev efx`join = join.
%abbrev efx`join/ww = join/ww.
%abbrev efx`join/wc = join/wc.
%abbrev efx`false-implies-eq = false-implies-eq.
%abbrev efx`eq-transitive = eq-transitive.
%abbrev efx`false-implies-leq = false-implies-leq.
%abbrev efx`leq-respects-eq = leq-respects-eq.
%abbrev efx`leq-reflexive = leq-reflexive.
%abbrev efx`leq-anti-symmetric = leq-anti-symmetric.
%abbrev efx`leq-transitive = leq-transitive.
%abbrev efx`false-implies-join = false-implies-join.
%abbrev efx`join-implies-leq* = join-implies-leq*.
%abbrev efx`join-implies-leq = join-implies-leq.
%abbrev efx`join-respects-eq = join-respects-eq.
%abbrev efx`join-deterministic = join-deterministic.
%abbrev efx`join-associative = join-associative.