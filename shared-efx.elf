%%% Shared Effects


shared-efx : type.
%name shared-efx SX.

shared-efx/none : shared-efx.

shared-efx/read : shared-efx.

shared-efx/write : shared-efx.


% equality 

shared-efx`eq : shared-efx -> shared-efx -> type.

shared-efx`eq/ : shared-efx`eq SX SX.


% join operation

shared-efx`join : shared-efx -> shared-efx -> shared-efx -> type.

shared-efx`join/L : shared-efx`join shared-efx/none SX SX.

shared-efx`join/R : shared-efx`join SX shared-efx/none SX.

shared-efx`join/1
  : shared-efx`join shared-efx/read shared-efx/read shared-efx/read.

shared-efx`join/2
  : shared-efx`join shared-efx/read shared-efx/write shared-efx/write.

shared-efx`join/3 
  : shared-efx`join shared-efx/write shared-efx/read shared-efx/write.

shared-efx`join/4
  : shared-efx`join shared-efx/write shared-efx/write shared-efx/write.


% less-equal

shared-efx`leq : shared-efx -> shared-efx -> type.

shared-efx`leq/1 : shared-efx`leq shared-efx/none _.

shared-efx`leq/2 : shared-efx`leq shared-efx/read shared-efx/read.

shared-efx`leq/3 : shared-efx`leq shared-efx/read shared-efx/write.

shared-efx`leq/4 : shared-efx`leq shared-efx/write shared-efx/write.


% disjoint

shared-efx`disjoint : shared-efx -> shared-efx -> type.

shared-efx`disjoint/L : shared-efx`disjoint shared-efx/none _.

shared-efx`disjoint/R : shared-efx`disjoint _ shared-efx/none.


% ======================= shared-efx2efx ==================================
% We need to convert shared-efx to efx so as to get a fraction.
% =========================================================================

shared-efx2efx : shared-efx -> efx -> type.

shared-efx2efx/read : shared-efx2efx shared-efx/read efx/read.

shared-efx2efx/write : shared-efx2efx shared-efx/write efx/write.

% =========================================================================


%theorem shared-efx`join-implies-leq
  : forall* {SX1} {SX2} {SX}
    forall {J: shared-efx`join SX1 SX2 SX}
    exists {L1: shared-efx`leq SX1 SX}
    {L2: shared-efx`leq SX2 SX}
    true.

%worlds () (shared-efx`join-implies-leq _ _ _).
%trustme %total {} (shared-efx`join-implies-leq _ _ _).


%theorem shared-efx`join-commutative
  : forall* {SX1} {SX2} {SX}
    forall {J: shared-efx`join SX1 SX2 SX}
    exists {J: shared-efx`join SX2 SX1 SX}
    true.

%worlds () (shared-efx`join-commutative _ _).
%trustme %total {} (shared-efx`join-commutative _ _).


%theorem shared-efx`join-associative
  : forall* {SX1} {SX2} {SX3} {SX4} {SX5}
    forall {SX1+SX2=SX3: shared-efx`join SX1 SX2 SX3}
    {SX3+SX4=SX5: shared-efx`join SX3 SX4 SX5}
    exists {SX6} {SX2+SX4=SX6: shared-efx`join SX2 SX4 SX6}
    {SX1+SX6=SX5: shared-efx`join SX1 SX6 SX5}
    true.

%worlds () (shared-efx`join-associative _ _ _ _ _).
%trustme %total {} (shared-efx`join-associative _ _ _ _ _).


%theorem shared-efx`join-associative-converse
  : forall* {SX1} {SX2} {SX6} {SX4} {SX5}
    forall {SX2+SX4=SX6: shared-efx`join SX2 SX4 SX6}
    {SX1+SX6=SX5: shared-efx`join SX1 SX6 SX5}
    exists {SX3} {SX1+SX2=SX3: shared-efx`join SX1 SX2 SX3}
    {SX3+SX4=SX5: shared-efx`join SX3 SX4 SX5}    
    true.

%worlds () (shared-efx`join-associative-converse _ _ _ _ _).
%trustme %total {} (shared-efx`join-associative-converse _ _ _ _ _).