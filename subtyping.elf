%%% Subtyping Rules

%%% Definitions


%%% Environment - a pair of context and capmap

env : type.

env/ : cxt -> capmap -> env.


env`eq : env -> env -> type.

env`eq/ : env`eq V V.


%% We use a special natural number z to represent the special
%% shared target: world.all. There's a one-to-one mapping between
%% z and (pair/ z z).

%abbrev shared-tgt : nat = nat`z.


%%% Type Checking Result

result : kind -> type.

%abbrev expr-result = result exprk.

%abbrev cond-result = result condk.

%abbrev args-result = result argsk.


result/expr : reftype -> env -> expr-result.

result/exists : (object -> result K) -> result K.

result/cond : env -> cond-result.

result/args/0 : env -> args-result.

result/args/+ : reftype -> args-result -> args-result.


result`eq : result K -> result K -> type.

result`eq/ : result`eq R R.



make-tgts-and-caps : capmap -> targets -> nat -> cap -> targets -> capmap -> type.

%%% When the result is shared, we can claim back the encumbered capabilities.
make-tgts-and-caps/shared :
    capmap-split M0 (capmap/1 shared-tgt X) M1 ->
 make-tgts-and-caps M0 targets/shared _ X
   (targets/unique set/0 (capmap/1 shared-tgt X)) M1.

make-tgts-and-caps/unique :
    set+nat2capmap S F X M2 ->
    capmap-min M1 X ->
    capmap-split M M1 M2 ->
    capmap-split M0 M2 M3 ->
  make-tgts-and-caps M0 (targets/unique S M1) F X (targets/unique set/0 M) M3.


% Consider field annotation, and returns either the input unique
% targets, or a shared targets. (no borrowed targets since field
% cannot be borrowed).

consider-ftype : targets -> capmap -> annot -> targets -> capmap -> type.

consider-ftype/shared :
    capmap-split M1 M M0 ->
  consider-ftype (targets/unique set/0 M) M0 annot/shared targets/shared M1.

consider-ftype/unique : consider-ftype G M annot/unique G M.


%%% Converting between ty and reftype

ty2reftype : nat -> ty -> reftype -> type.

ty2reftype/shared : ty2reftype L (ty/ NN annot/shared C) (reftype/ NN C targets/shared).

ty2reftype/borrow : ty2reftype L (ty/ NN annot/borrow C)
    (reftype/ NN C (targets/unique (set/1 L) capmap/0)).

ty2reftype/unique : ty2reftype L (ty/ NN annot/unique C)
    (reftype/ NN C (targets/unique (set/1 L) capmap/0)).

% ty2reftype/null : ty2reftype _ ty/null reftype/null.


reftype2ty : reftype -> ty -> type.

reftype2ty/shared : reftype2ty (reftype/ NN C targets/shared) (ty/ NN annot/shared C).

%% TODO: maybe annot/borrow more making sense?
reftype2ty/unique : reftype2ty (reftype/ NN C (targets/unique _ _)) (ty/ NN annot/unique C).

% reftype2ty/null : reftype2ty reftype/null ty/null.


% Compatible : whether (encumbered) targets are compatible
% with the forthcoming effects.

% compatible : clsmap -> cxt -> targets -> effects -> type.

%{ this is rather restrictive: it means once we "hold on"
a unique field from a shared object, we cannot have any
effect on shared, until we release the unique field. For instance,
  (if true a else s).u1 = s.u2 is not allowed. This is caused by
the way we converting permissions - we make the result permission
to be *encumbered* BOTH in permission for a and permission for s
(shared permission). The fix is to replace the encumber permission
for shared with a nesting fact, and then delay the encumber
to later stage. However, at this time it turns out too much change
is required, so we left it to be fixed later.

Update: we need to restrict the occurrences of OS in effects too.
In case we have expression: let x = a in (a.f = 3; x.f = 4; x)
we would first convert the output of "x = a" into a certain format
where "x.f" is already carved from the permissions. Thus, when
checking "a.f = 3", we don't have permission for "a.f" since it's
already in the encumbered part.

We can get the permission for "a.f" by first using linear modus-ponens
to restore the permission for "a.f" and then get the permission for
"x.f" again when starting to check "x.f". However, this cannot
be implemented in the current system.

In order to implement this, we might need to change the way input
permission is generated. Instead of requiring the permissions for
"x", it should require the permissions where "x" will come from.
In this way, we only do carving whenever needed. This may be done
by binding "x" with all the targets & effects it came from, but this
requires a big surgery on the current context definition.

FUTURE WORK: fix compatible/shared.
FUTURE WORK: better/less restrictive compatible/unique
}%

%{
compatible/shared : set`not-member S shared-tgt
                    -> compatible _ _ targets/shared (effects/ _ S Q).

compatible/unique : capmap`domain M R
                    -> set`disjoint FS R
                    -> set`disjoint FS S
                    -> objset2fldset CM B Q FS2
                    -> set`disjoint FS FS2
                    -> compatible CM B (targets/unique OS FS) (effects/ M S Q).
}%


%%% For the given context, replace all occurrences of object id in the set
%%%  from unique to borrowed.
%%% TODO: change to a better name

cxt-remove-unique : cxt -> set -> cxt -> type.

cxt-remove-unique/0 : cxt-remove-unique B set/0 B.

cxt-remove-unique/U/in :
    cxt-remove-unique B0 S' B1 ->
    cxt`lookup B1 N (cxt-info/ O (ty/ NN annot/unique C)) ->
    cxt`update B1 N (cxt-info/ O (ty/ NN annot/borrow C)) B2 ->
    set`not-member S' N ->
    set`add S' N S ->
  cxt-remove-unique B0 S B2.

cxt-remove-unique/U/out :
    cxt-remove-unique B0 S' B1 ->
    cxt`fresh B1 N ->
    set`not-member S' N ->
    set`add S' N S ->
  cxt-remove-unique B0 S B1.


cxt-add-unique : cxt -> set -> cxt -> type.

cxt-add-unique/0 : cxt-add-unique B set/0 B.

cxt-add-unique/U/in :
    cxt-add-unique B0 S' B1 ->
    cxt`lookup B1 N (cxt-info/ O (ty/ NN annot/borrow C)) ->
    cxt`update B1 N (cxt-info/ O (ty/ NN annot/unique C)) B2 ->
    set`not-member S' N ->
    set`add S' N S ->
  cxt-add-unique B0 S B2.

cxt-add-unique/U/out :
    cxt-add-unique B0 S' B1 ->
    cxt`fresh B1 N ->
    set`not-member S' N ->
    set`add S' N S ->
  cxt-add-unique B0 S B1.


% sub-annotation rule with side effects.
% `targets`: the targets on the LHS
% `env`: the input environment, we need to remove consumed caps from it.
% `set`: the field set on LHS, used when consuming a whole object
% `annot`: the annotation on the RHS
% `env`: the output environment

sub-annot-cap : targets -> env -> set -> annot -> env -> type.

sub-annot-cap/consume :
    set+set2capmap OS S cap/write M2 ->
    capmap-split M0 M2 M3 ->
    capmap-min M1 cap/write ->
    cxt-remove-unique B0 OS B1 ->
  sub-annot-cap (targets/unique OS M1) (env/ B0 M0) S A (env/ B1 M3).

sub-annot-cap/shared2shared : sub-annot-cap targets/shared V _ annot/shared V.


%abbrev sub-nonnull : nn -> nn -> type = [NN1][NN2] nonnull`leq NN2 NN1.

%abbrev sub-annot : annot -> annot -> type = [A1][A2] annot`leq A2 A1.


subtype : clsmap -> reftype -> env -> ty -> env -> type.

subtype/ :
    nat`eq C1 C2 ->
    sub-nonnull NN1 NN2 ->
    clsmap`lookup CM C1 FM ->
    fldmap`domain FM FS ->
    sub-annot-cap GS VI FS A2 VO ->
  subtype CM (reftype/ NN1 C1 GS) VI (ty/ NN2 A2 C2) VO.

subtype/null : subtype _ reftype/null V ty/null V.

subtype/maynull : subtype _ reftype/null V (ty/ nn/may _ _) V.


%%% Theorems

%theorem make-tgts-and-caps-implies-min-cap
  : forall* {M0} {G0} {F} {X} {M} {M1}
    forall {MG: make-tgts-and-caps M0 G0 F X (targets/unique set/0 M) M1}
    exists {MC-M=X: capmap-min M X}
    true.

- : make-tgts-and-caps-implies-min-cap (make-tgts-and-caps/shared _)
    (capmap-min/U capmap-min/0 MI capmap`update/0 capmap`fresh/0)
    <- cap/write-is-upper-bound _ MI.

- : make-tgts-and-caps-implies-min-cap
    (make-tgts-and-caps/unique (S+X=M2:set+nat2capmap S F Xx M2)
      (MC-M1=X:capmap-min M1 Xx)
      (M=M1+M2:capmap-split M M1 M2)
      (M0-M2=M3:capmap-split M0 M2 M3)) MC-M=X
    <- capmap-split-implies-disjoint-join M=M1+M2 _ M1+M2=M
    <- set+nat2capmap-implies-min-cap S+X=M2 MC-M2=X
    <- capmap-join-preserves-min-cap MC-M1=X MC-M2=X M1+M2=M MC-M=X.

%worlds (objvar) (make-tgts-and-caps-implies-min-cap _ _).
%total { } (make-tgts-and-caps-implies-min-cap _ _).


%theorem false-implies-cxt-remove-unique
  : forall* {B0} {S} {B1}
    forall {V: void}
    exists {B0-S=B1: cxt-remove-unique B0 S B1}
    true.

%worlds (objvar) (false-implies-cxt-remove-unique _ _).
%total { } (false-implies-cxt-remove-unique _ _).


%%% A better version of this is cxt-remove-unique-preserves-domain,
%%% but we don't have domain defined for cxt - maybe later if we found a need for it.

%theorem cxt-remove-unique-preserves-size
  : forall* {B0} {B1} {N} {S}
    forall {SZ0: cxt`size B0 N}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    exists {SZ1: cxt`size B1 N}
    true.

%theorem cxt-remove-unique-preserves-size/L
  : forall* {B} {N} {CI} {K0}
    forall {BL: cxt`lookup B N CI}
    {SZ: cxt`size B K0}
    exists {K1} {SZ: cxt`size B (s K1)}
    true.

%theorem cxt-remove-unique-preserves-size/F
  : forall* {B}
    forall {V:void}
    exists {K} {SZ: cxt`size B (s K)}
    true.

%worlds (objvar) (cxt-remove-unique-preserves-size/F _ _ _).
%total { } (cxt-remove-unique-preserves-size/F _ _ _).

- : cxt-remove-unique-preserves-size/L BL cxt`size/0 _ SZ
    <- cxt`lookup-contradiction BL V
    <- cxt-remove-unique-preserves-size/F V _ SZ.

- : cxt-remove-unique-preserves-size/L BL (cxt`size/+ SZ) _ (cxt`size/+ SZ).

%worlds (objvar) (cxt-remove-unique-preserves-size/L _ _ _ _).
%total { } (cxt-remove-unique-preserves-size/L _ _ _ _).


- : cxt-remove-unique-preserves-size SZ cxt-remove-unique/0 SZ.

- : cxt-remove-unique-preserves-size (SZ-B0:cxt`size B0 K)
    (cxt-remove-unique/U/in (B0-S=B1:cxt-remove-unique B0 S' B1)
      (B1-L:cxt`lookup B1 N _) (B1-U:cxt`update B1 N _ B2)
      (N!<S':set`not-member S' N) (S'+N=S:set`add S' N S)) (SZ-B2:cxt`size B2 K)
    <- cxt-remove-unique-preserves-size SZ-B0 B0-S=B1 SZ-B1
    <- cxt`lookup-implies-fresh-update B1-L B3 B3-F B3-U
    <- cxt`update-overwrites B3-U B1-U nat`eq/ B3-UP
    <- cxt-remove-unique-preserves-size/L B1-L SZ-B1 KP SZ-B1P
    <- cxt`size-unique SZ-B1P SZ-B1 cxt`eq/ (EQ:nat`eq (s KP) K)
    <- cxt`fresh-update-increases-size-converse SZ-B1P B3-F B3-U SZ-B3
    <- cxt`fresh-update-increases-size SZ-B3 B3-F B3-UP SZ-B2P
    <- cxt`size-respects-eq SZ-B2P cxt`eq/ EQ SZ-B2.

- : cxt-remove-unique-preserves-size (SZ-B0:cxt`size B0 K)
    (cxt-remove-unique/U/out (B0-S=B1:cxt-remove-unique B0 S' B1) FS
      (N!<S':set`not-member S' N) (S'+N=S:set`add S' N S)) (SZ-B1:cxt`size B1 K)
    <- cxt-remove-unique-preserves-size SZ-B0 B0-S=B1 SZ-B1.

%worlds (objvar) (cxt-remove-unique-preserves-size _ _ _).
%total (Z) (cxt-remove-unique-preserves-size _ Z _).


%theorem cxt-remove-unique-preserves-lookup-info
  : forall* {B0} {S} {B1} {N} {O} {NN} {A0} {C}
    forall {BL0: cxt`lookup B0 N (cxt-info/ O (ty/ NN A0 C))}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    exists {A1} {BL1: cxt`lookup B1 N (cxt-info/ O (ty/ NN A1 C))}
    true.

%theorem cxt-remove-unique-preserves-lookup-info/L
  : forall* {B0} {S} {B1} {N} {O} {NN} {A0} {C} {S'} {B2} {N0} {O0} {NN0} {C0}
    forall {B0-S=B1: cxt-remove-unique B0 S' B1}
    {B1-L: cxt`lookup B1 N (cxt-info/ O (ty/ NN annot/unique C))}
    {B1-U: cxt`update B1 N (cxt-info/ O (ty/ NN annot/borrow C)) B2}
    {NM: set`not-member S' N}
    {AD: set`add S' N S}
    {B0-L: cxt`lookup B1 N0 (cxt-info/ O0 (ty/ NN0 A0 C0))}
    {K} {EQ?: nat`eq? N0 N K}
    exists {A1} {B2-L: cxt`lookup B2 N0 (cxt-info/ O0 (ty/ NN0 A1 C0))}
    true.

- : cxt-remove-unique-preserves-lookup-info/L B0-S=B1 B1-L B1-U=B2
    N!<S' S'+N=S B1-LP _ nat`eq?/yes _ B2-LP
    <- cxt`lookup-unique B1-L B1-LP cxt`eq/ nat`eq/ CIE
    <- cxt`update-implies-lookup B1-U=B2 B2-L
    <- cxt-info-eq-inversion CIE OE TE
    <- ty-eq-inversion TE NNE _ CE
    <- ty-preserves-eq NNE annot`eq/ CE TEP
    <- cxt-info-preserves-eq OE TEP CIEP
    <- cxt`lookup-respects-eq B2-L cxt`eq/ nat`eq/ CIEP B2-LP.

- : cxt-remove-unique-preserves-lookup-info/L B0-S=B1 B1-L (B1-U=B2:cxt`update B1 _ _ B2)
    N!<S' S'+N=S B1-LP _ (nat`eq?/no (N0<>N:nat`ne N0 N)) _ B2-LP
    <- cxt`update-preserves-lookup B1-LP B1-U=B2 N0<>N B2-LP.

%worlds (objvar) (cxt-remove-unique-preserves-lookup-info/L _ _ _ _ _ _ _ _ _ _).
%total { } (cxt-remove-unique-preserves-lookup-info/L _ _ _ _ _ _ _ _ _ _).

- : cxt-remove-unique-preserves-lookup-info BL cxt-remove-unique/0 _ BL.

- : cxt-remove-unique-preserves-lookup-info
    B0-L (cxt-remove-unique/U/in B0-S=B1 B1-L B1-U NM UD) _ B2-L
    <- nat`eq?-total EQ?
    <- cxt-remove-unique-preserves-lookup-info B0-L B0-S=B1 _ B1-L2
    <- cxt-remove-unique-preserves-lookup-info/L B0-S=B1 B1-L B1-U NM UD B1-L2 _ EQ? _ B2-L.

- : cxt-remove-unique-preserves-lookup-info
    (B0-L:cxt`lookup B0 N0 _) (cxt-remove-unique/U/out B0-S=B1 N!<B1 NM UD)
    _ (B1-L:cxt`lookup B1 N0 _)
    <- cxt-remove-unique-preserves-lookup-info B0-L B0-S=B1 _ B1-L.

%worlds (objvar) (cxt-remove-unique-preserves-lookup-info _ _ _ _).
%total (A) (cxt-remove-unique-preserves-lookup-info _ A _ _).


%theorem cxt-remove-unique-preserves-lookup-info-converse
  : forall* {B0} {S} {B1} {N} {O} {NN} {A1} {C}
    forall {BL0: cxt`lookup B1 N (cxt-info/ O (ty/ NN A1 C))}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    exists {A0} {BL1: cxt`lookup B0 N (cxt-info/ O (ty/ NN A0 C))}
    true.

%worlds (objvar) (cxt-remove-unique-preserves-lookup-info-converse _ _ _ _).
%trustme %total (A) (cxt-remove-unique-preserves-lookup-info-converse _ A _ _).


%theorem cxt-remove-unique-preserves-lookup-info-converse
  : forall* {B0} {S} {B1} {N} {O} {NN} {A1} {C}
    forall {BL0: cxt`lookup B1 N (cxt-info/ O (ty/ NN A1 C))}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    exists {A0} {BL1: cxt`lookup B0 N (cxt-info/ O (ty/ NN A0 C))}
    true.

%worlds (objvar) (cxt-remove-unique-preserves-lookup-info-converse _ _ _ _).
%trustme %total (A) (cxt-remove-unique-preserves-lookup-info-converse _ A _ _).


%theorem cxt-remove-unique-preserves-fresh
  : forall* {B0} {S} {B1} {N}
    forall {N!<B0: cxt`fresh B0 N}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    exists {N!<B1: cxt`fresh B1 N}
    true.

- : cxt-remove-unique-preserves-fresh FS cxt-remove-unique/0 FS.

- : cxt-remove-unique-preserves-fresh N!<B0
    (cxt-remove-unique/U/in B0-S'=B1 B1-L B1-U _ _) N!<B2
    <- cxt-remove-unique-preserves-fresh N!<B0 B0-S'=B1 N!<B1
    <- cxt`fresh-lookup-not-equal N!<B1 B1-L NE
    <- cxt`update-preserves-fresh N!<B1 B1-U NE N!<B2.

- : cxt-remove-unique-preserves-fresh N!<B0
    (cxt-remove-unique/U/out B0-S'=B1 FS _ _) N!<B1
    <- cxt-remove-unique-preserves-fresh N!<B0 B0-S'=B1 N!<B1.

%worlds () (cxt-remove-unique-preserves-fresh _ _ _).
%total (C) (cxt-remove-unique-preserves-fresh _ C _).


%%% A little bit overlapping with cxt-remove-unique-preserves-lookup-info

%theorem cxt-remove-unique-preserves-unique-or-borrow
  : forall* {B0} {S} {B1} {N} {O} {NN} {A0} {C}
    forall {B0-L: cxt`lookup B0 N (cxt-info/ O (ty/ NN A0 C))}
    {UB-0: unique-or-borrow A0}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    exists {A1} {B1-L: cxt`lookup B1 N (cxt-info/ O (ty/ NN A1 C))}
    {UB-1: unique-or-borrow A1}
    true.

- : cxt-remove-unique-preserves-unique-or-borrow B0-L UB0
    cxt-remove-unique/0 _ B0-L UB0.

- : cxt-remove-unique-preserves-unique-or-borrow
    B0-L UB0 (cxt-remove-unique/U/out B0-S'=B2 K!<B2 K!<S' S'+K=S) _ B2-L UB2
    <- cxt-remove-unique-preserves-unique-or-borrow B0-L UB0 B0-S'=B2 _ B2-L UB2.

%theorem cxt-remove-unique-preserves-unique-or-borrow/L/in
  : forall* {B} {B0} {S} {B1} {N} {O} {NN} {A0} {C}
    {S'} {B2} {O1} {NN1} {C1} {K}
    forall {B0-L: cxt`lookup B0 N (cxt-info/ O (ty/ NN A0 C))}
    {UB0: unique-or-borrow A0}
    {B0-S'=B2: cxt-remove-unique B0 S' B2}
    {B2-L: cxt`lookup B2 K (cxt-info/ O1 (ty/ NN1 annot/unique C1))}
    {B2-U: cxt`update B2 K (cxt-info/ O1 (ty/ NN1 annot/borrow C1)) B1}
    {K!<S': set`not-member S' K}
    {S'+K=S: set`add S' K S}
    {EQ?: nat`eq? K N B}
    exists {A1} {B1-L: cxt`lookup B1 N (cxt-info/ O (ty/ NN A1 C))}
    {UB1: unique-or-borrow A1}
    true.

- : cxt-remove-unique-preserves-unique-or-borrow/L/in
    (B0-L:cxt`lookup B0 N (cxt-info/ O (ty/ NN A0 C)))
    UB0 B0-S'=B2
    (B2-L:cxt`lookup B2 N (cxt-info/ O1 (ty/ NN1 annot/unique C1)))
    B2-U K!<S' S'+K=S nat`eq?/yes _ B1-L unique-or-borrow/borrow
    <- cxt-remove-unique-preserves-lookup-info B0-L B0-S'=B2 _ B2-LP
    <- cxt`lookup-unique B2-L B2-LP cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE TE
    <- ty-eq-inversion TE NNE _ CE
    <- ty-preserves-eq NNE annot`eq/ CE TEP
    <- cxt-info-preserves-eq OE TEP CIEP
    <- cxt`update-respects-eq B2-U cxt`eq/ nat`eq/ CIEP cxt`eq/ B2-UP
    <- cxt`update-implies-lookup B2-UP B1-L.

- : cxt-remove-unique-preserves-unique-or-borrow/L/in
    B0-L UB0 B0-S'=B2 B2-L B2-U K!<S' S'+K=S (nat`eq?/no (K<>N: nat`ne K N))
    _ B1-L UB1
    <- cxt-remove-unique-preserves-unique-or-borrow B0-L UB0 B0-S'=B2 _ B2-LP UB1
    <- nat`ne-symmetric K<>N N<>K
    <- cxt`update-preserves-lookup B2-LP B2-U N<>K B1-L.

- : cxt-remove-unique-preserves-unique-or-borrow
    B0-L UB0 (cxt-remove-unique/U/in B0-S'=B2 B2-L B2-U K!<S' S'+K=S)
    _ B1-L UB1
    <- nat`eq?-total EQ?
    <- cxt-remove-unique-preserves-unique-or-borrow/L/in B0-L UB0
      B0-S'=B2 B2-L B2-U K!<S' S'+K=S EQ? _ B1-L UB1.

%worlds (objvar) (cxt-remove-unique-preserves-unique-or-borrow _ _ _ _ _ _)
(cxt-remove-unique-preserves-unique-or-borrow/L/in _ _ _ _ _ _ _ _ _ _ _).
%total (A B) (cxt-remove-unique-preserves-unique-or-borrow _ _ A _ _ _)
(cxt-remove-unique-preserves-unique-or-borrow/L/in _ _ B _ _ _ _ _ _ _ _).


%theorem cxt-remove-unique-respects-not-member
  : forall* {B0} {S} {B1} {N} {S'}
    forall {B0-S=B1: cxt-remove-unique B0 S' B1}
    {N!<S': set`not-member S' N}
    {S'+N=S: set`add S' N S}
    {N!<B1: cxt`fresh B1 N}
    exists {B0-S=B1: cxt-remove-unique B0 S B1}
    true.

- : cxt-remove-unique-respects-not-member cxt-remove-unique/0 N!<S' S'+N=S N!<B1
    (cxt-remove-unique/U/out cxt-remove-unique/0 N!<B1 N!<S' S'+N=S).

%theorem cxt-remove-unique-respects-not-member/out
  : forall* {B0} {S1} {B1} {N} {S2} {N0} {S0}
    forall {B0-S2=B1: cxt-remove-unique B0 S2 B1}
    {B1-F: cxt`fresh B1 N}
    {N!<S2: set`not-member S2 N}
    {S2+N=S1: set`add S2 N S1}
    {N0!<S1: set`not-member S1 N0}
    {S1+N0=S0: set`add S1 N0 S0}
    {N0!<B1: cxt`fresh B1 N0}
    {K} {EQ?: nat`eq? N0 N K}
    exists {B0-S=B1: cxt-remove-unique B0 S0 B1}
    true.

- : cxt-remove-unique-respects-not-member/out
    B0-S2=B1 B1-F N!<S2 S2+N=S1 N!<S1 S1+N=S0 _ _ nat`eq?/yes B0-S=B1
    <- set`add-implies-member S2+N=S1 N<-S1
    <- set`member-not-member-contradiction N<-S1 N!<S1 V
    <- false-implies-cxt-remove-unique V B0-S=B1.

- : cxt-remove-unique-respects-not-member/out
    (B0-S2=B1:cxt-remove-unique B0 S2 B1)
    (N!<B1:cxt`fresh B1 N)
    (N!<S2:set`not-member S2 N)
    (S2+N=S1:set`add S2 N S1)
    (N0!<S1:set`not-member S1 N0)
    (S1+N0=S0:set`add S1 N0 S0)
    (N0!<B1:cxt`fresh B1 N0) _ (nat`eq?/no (N0<>N:nat`ne N0 N))
    (cxt-remove-unique/U/out B0-S3=B1 N!<B1 N!<S3 S3+N=S0)
    <- nat`ne-symmetric N0<>N N<>N0
    <- set`add-commutes S2+N=S1 S1+N0=S0 N<>N0 S3 S2+N0=S3 S3+N=S0
    <- set`add-preserves-not-member-converse N0!<S1 S2+N=S1 N0!<S2
    <- set`add-preserves-not-member N!<S2 S2+N0=S3 N<>N0 N!<S3
    <- cxt-remove-unique-respects-not-member B0-S2=B1 N0!<S2 S2+N0=S3 N0!<B1 B0-S3=B1.

%theorem cxt-remove-unique-respects-not-member/in
  : forall* {B0} {S1} {B1} {N} {S2} {O} {NN} {C} {B2} {N0} {S0}
    forall {B0-S2=B1: cxt-remove-unique B0 S2 B1}
    {B1-L: cxt`lookup B1 N (cxt-info/ O (ty/ NN annot/unique C))}
    {B1-U: cxt`update B1 N (cxt-info/ O (ty/ NN annot/borrow C)) B2}
    {N!<S2: set`not-member S2 N}
    {S2+N=S1: set`add S2 N S1}
    {N0!<S1: set`not-member S1 N0}
    {S1+N0=S0: set`add S1 N0 S0}
    {N0!<B1: cxt`fresh B2 N0}
    {K} {EQ?: nat`eq? N0 N K}
    exists {B0-S=B1: cxt-remove-unique B0 S0 B2}
    true.

- : cxt-remove-unique-respects-not-member/in
    B0-S2=B1 B1-L B1-U N!<S2 S2+N=S1 N!<S1 S1+N=S0 _ _ nat`eq?/yes B0-S=B1
    <- set`add-implies-member S2+N=S1 N<-S1
    <- set`member-not-member-contradiction N<-S1 N!<S1 V
    <- false-implies-cxt-remove-unique V B0-S=B1.

- : cxt-remove-unique-respects-not-member/in
    (B0-S2=B1:cxt-remove-unique B0 S2 B1)
    (B1-L:cxt`lookup B1 N (cxt-info/ O (ty/ NN annot/unique C)))
    (B1-U:cxt`update B1 N (cxt-info/ O (ty/ NN annot/borrow C)) B2)
    (N!<S2:set`not-member S2 N)
    (S2+N=S1:set`add S2 N S1)
    (N0!<S1:set`not-member S1 N0)
    (S1+N0=S0:set`add S1 N0 S0) (N0!<B2:cxt`fresh B2 N0) _ (nat`eq?/no N0<>N)
    (cxt-remove-unique/U/in B0-S3=B1 B1-L B1-U N!<S3 S3+N=S0)
    <- nat`ne-symmetric N0<>N N<>N0
    <- set`add-commutes S2+N=S1 S1+N0=S0 N<>N0 S3 S2+N0=S3 S3+N=S0
    <- set`add-preserves-not-member-converse N0!<S1 S2+N=S1 N0!<S2
    <- set`add-preserves-not-member N!<S2 S2+N0=S3 N<>N0 N!<S3
    <- cxt`update-preserves-fresh-converse N0!<B2 B1-U N0!<B1
    <- cxt-remove-unique-respects-not-member B0-S2=B1 N0!<S2 S2+N0=S3 N0!<B1 B0-S3=B1.

- : cxt-remove-unique-respects-not-member
    (cxt-remove-unique/U/in
      (B0-S2=B1:cxt-remove-unique B0 S2 B1)
      (B1-L:cxt`lookup B1 N (cxt-info/ O (ty/ NN annot/unique C)))
      (B1-U:cxt`update B1 N (cxt-info/ O (ty/ NN annot/borrow C)) B2)
      (N!<S2:set`not-member S2 N)
      (S2+N=S1:set`add S2 N S1))
    (N0!<S1:set`not-member S1 N0)
    (S1+N0=S0:set`add S1 N0 S0)
    (N0!<B2:cxt`fresh B2 N0)
    B0-S0=B2
    <- nat`eq?-total EQ?
    <- cxt-remove-unique-respects-not-member/in
      B0-S2=B1 B1-L B1-U N!<S2 S2+N=S1 N0!<S1 S1+N0=S0 N0!<B2 _ EQ? B0-S0=B2.

- : cxt-remove-unique-respects-not-member
    (cxt-remove-unique/U/out B0-S2=B1 N!<B1 N!<S2 S2+N=S1) N0!<S1 S1+N0=S0 N0!<B1 B0-S0=B2
    <- nat`eq?-total EQ?
    <- cxt-remove-unique-respects-not-member/out
      B0-S2=B1 N!<B1 N!<S2 S2+N=S1 N0!<S1 S1+N0=S0 N0!<B1 _ EQ? B0-S0=B2.

%worlds (objvar) (cxt-remove-unique-respects-not-member _ _ _ _ _)
(cxt-remove-unique-respects-not-member/out _ _ _ _ _ _ _ _ _ _)
(cxt-remove-unique-respects-not-member/in _ _ _ _ _ _ _ _ _ _ _).
%total (A B C) (cxt-remove-unique-respects-not-member A _ _ _ _)
(cxt-remove-unique-respects-not-member/out B _ _ _ _ _ _ _ _ _)
(cxt-remove-unique-respects-not-member/in C _ _ _ _ _ _ _ _ _ _).


%theorem cxt-remove-unique-preserves-fresh-update
  : forall* {B0} {B0'} {N} {B1} {S} {O} {NN} {A0} {C}
    forall {B0-S=B1: cxt-remove-unique B0 S B1}
    {N!<B0: cxt`fresh B0' N}
    {B0'+N=B1: cxt`update B0' N (cxt-info/ O (ty/ NN A0 C)) B0}
    exists {A1} {B1'}
    {N!<B1: cxt`fresh B1' N}
    {B1'+N=B1: cxt`update B1' N (cxt-info/ O (ty/ NN A1 C)) B1}
    {B0'-S=B1': cxt-remove-unique B0' S B1'}
    true.

- : cxt-remove-unique-preserves-fresh-update
    cxt-remove-unique/0 F U _ _ F U cxt-remove-unique/0.

%theorem cxt-remove-unique-preserves-fresh-update/L
  : forall* {B0} {B0'} {N} {B1} {S} {O} {NN} {A0} {C} {S'} {B2} {N0}
    {O0} {NN0} {C0}
    forall {B0-S=B2: cxt-remove-unique B0 S' B2}
    {B2-L: cxt`lookup B2 N (cxt-info/ O (ty/ NN annot/unique C))}
    {B2-U: cxt`update B2 N (cxt-info/ O (ty/ NN annot/borrow C)) B1}
    {N!<S': set`not-member S' N}
    {S'+N=S: set`add S' N S}
    {N!<B0: cxt`fresh B0' N0}
    {B0'+N=B1: cxt`update B0' N0 (cxt-info/ O0 (ty/ NN0 A0 C0)) B0}
    {K} {EQ?: nat`eq? N0 N K}
    exists {A1} {B1'}
    {N!<B1: cxt`fresh B1' N0}
    {B1'+N=B1: cxt`update B1' N0 (cxt-info/ O0 (ty/ NN0 A1 C0)) B1}
    {B0'-S=B1': cxt-remove-unique B0' S B1'}
    true.

- : cxt-remove-unique-preserves-fresh-update/L B0-S'=B2
    (B2-L:cxt`lookup B2 N (cxt-info/ O (ty/ NN annot/unique C)))
    B2+N=B1 (N!<S':set`not-member S' N) S'+N=S
    (N!<B0':cxt`fresh B0' N)
    (B0'+N=B0:cxt`update B0' N (cxt-info/ O0 (ty/ NN0 A0 C0)) B0)
    _ nat`eq?/yes _ _ N!<B2' B2'+N'=B1 B0'-S=B2'
    <- cxt-remove-unique-preserves-fresh-update
      B0-S'=B2 N!<B0' B0'+N=B0 _ B2' N!<B2' B2'+N=B2 B0'-S'=B2'
    <- cxt`update-implies-lookup B2'+N=B2 B2-LP
    <- cxt`lookup-unique B2-L B2-LP cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE TE
    <- ty-eq-inversion TE NNE _ CE
    <- ty-preserves-eq NNE annot`eq/ CE TEP
    <- cxt-info-preserves-eq OE TEP CIEP
    <- cxt-remove-unique-respects-not-member B0'-S'=B2' N!<S' S'+N=S N!<B2' B0'-S=B2'
    <- cxt`update-overwrites B2'+N=B2 B2+N=B1 nat`eq/ B2'+N=B1
    <- cxt`update-respects-eq B2'+N=B1 cxt`eq/ nat`eq/ CIEP cxt`eq/ B2'+N'=B1.

- : cxt-remove-unique-preserves-fresh-update/L B0-S'=B2
    (B2-L:cxt`lookup B2 N _) B2+N=B1 (N!<S':set`not-member S' N) S'+N=S
    (N0!<B0':cxt`fresh B0' N0) (B0'+N0=B0:cxt`update B0' N0 _ B0)
    _ (nat`eq?/no (N0<>N:nat`ne N0 N)) _ B1' N0!<B1' B1'+N0=B1
    (cxt-remove-unique/U/in B0'-S'=B2' (B2'-L:cxt`lookup B2' N _)
      (B2'+N=B1': cxt`update B2' N _ B1') N!<S' S'+N=S)
    <- cxt-remove-unique-preserves-fresh-update
      B0-S'=B2 N0!<B0' B0'+N0=B0 _ B2' N0!<B2' B2'+N0=B2 B0'-S'=B2'
    <- cxt`update-commutes B2'+N0=B2 B2+N=B1 N0<>N B1' B2'+N=B1' B1'+N0=B1
    <- cxt`update-preserves-fresh N0!<B2' B2'+N=B1' N0<>N N0!<B1'
    <- nat`ne-symmetric N0<>N N<>N0
    <- cxt`update-preserves-lookup-converse B2-L B2'+N0=B2 N<>N0 B2'-L.

- : cxt-remove-unique-preserves-fresh-update
    (cxt-remove-unique/U/in B0-S'=B2
      (B2-L:cxt`lookup B2 N _) B2-U (N!<S':set`not-member S' N) S'+N=S)
    (N0!<B0':cxt`fresh B0' N0)
    (B0'+N0=B0:cxt`update B0' N0 _ B0) _ B1' N0!<B1' B1'+N0=B1 B0'-S=B1'
    <- nat`eq?-total N0<>N?
    <- cxt-remove-unique-preserves-fresh-update/L B0-S'=B2
      B2-L B2-U N!<S' S'+N=S N0!<B0' B0'+N0=B0 _ N0<>N? _ B1' N0!<B1' B1'+N0=B1 B0'-S=B1'.

- : cxt-remove-unique-preserves-fresh-update
    (cxt-remove-unique/U/out B0-S'=B1 N!<B1 N!<S' S'+N=S)
    N0!<B0' B0'+N0=B0 _ B1' N0!<B1' B1'+N0=B1 B0'-S=B1'
    <- cxt-remove-unique-preserves-fresh-update B0-S'=B1 N0!<B0' B0'+N0=B0
      _ B1' N0!<B1' B1'+N0=B1 B0'-S'=B1'
    <- cxt`update-preserves-fresh-converse N!<B1 B1'+N0=B1 N!<B1'
    <- cxt-remove-unique-respects-not-member B0'-S'=B1' N!<S' S'+N=S N!<B1' B0'-S=B1'.

%worlds (objvar) (cxt-remove-unique-preserves-fresh-update _ _ _ _ _ _ _ _)
  (cxt-remove-unique-preserves-fresh-update/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A B) (cxt-remove-unique-preserves-fresh-update A _ _ _ _ _ _ _)
  (cxt-remove-unique-preserves-fresh-update/L B _ _ _ _ _ _ _ _ _ _ _ _ _).
