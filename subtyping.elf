% Subtyping Rules


%%% Definitions

% 1, consider field annotation, and returns either the input unique
% targets, or a shared targets. (no borrowed targets since field
% cannot be borrowed).

consider-ftype : targets -> annot -> targets -> type.

consider-ftype/shared : consider-ftype _ annot/shared targets/shared.

consider-ftype/unique : consider-ftype G annot/unique G.


% 2, given input targets for field reference receiver,
% field annotation, field ID, and effects, compute the result
% targets and effects.

% create-shared-efx : efx -> shared-efx -> type.

% create-shared-efx/read : create-shared-efx efx/read shared-efx/read.

% create-shared-efx/write : create-shared-efx efx/write shared-efx/write.


make-targets-and-effects : targets -> nat -> efx -> targets -> effects -> type.

make-targets-and-effects/shared
  : make-targets-and-effects
      targets/shared  _ X (targets/unique set/0 (set/1 z))
      (effects/ (efxmap/+ z X efxmap/0) set/0 set/0).

make-targets-and-effects/unique
  : set+nat2set G1 F G1'
    -> set`disjoint G2 G1'
    -> set`union G2 G1' G
    -> set2efxmap G X M
    -> make-targets-and-effects
      (targets/unique G1 G2) F X (targets/unique set/0 G)
      (effects/ M set/0 set/0).


%%% 5, converting between ty and reftype

ty2reftype : nat -> ty -> reftype -> type.

ty2reftype/shared
  : ty2reftype L (ty/ NN annot/shared C) (reftype/ NN C targets/shared).

ty2reftype/borrow
  : ty2reftype L (ty/ NN annot/borrow C)
    (reftype/ NN C (targets/unique (set/1 L) set/0)).

% ty2reftype/null : ty2reftype _ ty/null reftype/null.


reftype2ty : reftype -> ty -> type.

reftype2ty/shared
  : reftype2ty (reftype/ NN C targets/shared)
    (ty/ NN annot/shared C).

%% TODO: maybe annot/borrow more making sense?
reftype2ty/unique
  : reftype2ty (reftype/ NN C (targets/unique _ _))
    (ty/ NN annot/unique C).

% reftype2ty/null : reftype2ty reftype/null ty/null.


% 6. compatible : whether (encumbered) targets are compatible
% with the forthcoming effects.

% compatible/B : bool -> shared-efx -> type.

% compatible/B/true : compatible/B true shared-efx/none.

% compatible/B/false : compatible/B false _.


compatible : targets -> effects -> type.

%{ this is rather restrictive: it means once we "hold on"
a unique field from a shared object, we cannot have any
effect on shared, until we release the unique field. For instance,
  (if true a else s).u1 = s.u2 is not allowed. This is caused by
the way we converting permissions - we make the result permission
to be *encumbered* BOTH in permission for a and permission for s
(shared permission). The fix is to replace the encumber permission
for shared with a nesting fact, and then delay the encumber
to later stage. However, at this time it turns out too much change
is required, so we left it to be fixed later.
TODO: fix compatible/shared.
}%

compatible/shared : compatible targets/shared _.

compatible/unique : efxmap`domain M R
                    -> set`disjoint G R
                    -> set`disjoint G S
                    -> compatible (targets/unique _ G)
                      (effects/ M S _).


% sub-annotation rule with side effects.
% `targets`: the targets on the LHS
% `efxmap`: the declared effects, only nonempty useful when checking parameters
% `set`: the field set on LHS, used when consuming a whole object
% `annot`: the annotation on the RHS
% `effects`: the result effects
sub-annot-efx : targets -> efxmap -> set -> annot -> effects -> type.

sub-annot-efx/consume
  : sub-annot-efx (targets/unique G1 G2) _ FS A (effects/ efxmap/0 G G1)
    <- not-borrowed A
    <- set+set2set G1 FS G1'
    <- set`disjoint G2 G1'
    <- set`union G2 G1' G.

sub-annot-efx/unique2borrow
  : sub-annot-efx (targets/unique G1 G2) XMd
    _ annot/borrow (effects/ XM set/0 set/0)
    <- set+map2map G1 XMd XM1
    <- efxmap-max-efx XMd X
    <- set2efxmap G2 X XM2
    <- efxmap`join XM1 XM2 XM.

sub-annot-efx/shared2borrow
 : sub-annot-efx targets/shared XMd _ annot/borrow
   (effects/ (efxmap/+ z X efxmap/0) set/0 set/0)
   <- efxmap-max-efx XMd X.

sub-annot-efx/shared2shared
  : sub-annot-efx targets/shared efxmap/0 _ annot/shared no-effect.


%abbrev sub-nonnull : nn -> nn -> type = [NN1][NN2] nonnull`leq NN2 NN1.

%abbrev sub-annot : annot -> annot -> type = [A1][A2] annot`leq A2 A1.


% The two sets are read and write fields respectively.

subtype : clsmap -> reftype -> ty -> efxmap -> effects -> type.

subtype/ : subtype CM (reftype/ NN1 C1 GS) (ty/ NN2 A2 C2) XM XX
           <- nat`eq C1 C2
           <- sub-nonnull NN1 NN2
           <- clsmap`lookup CM C1 FM
           <- fldmap`domain FM FS
           <- efxmap`domain XM XS
           <- set`leq XS FS
           <- sub-annot-efx GS XM FS A2 XX.

subtype/null : subtype _ reftype/null ty/null _ no-effect.

subtype/maynull : subtype _ reftype/null (ty/ nn/may _ _) _ no-effect.