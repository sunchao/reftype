%%% Subtyping Rules


%%% ======================= Abbreviations =====================================

%% We use a special natural number z to represent the special
%% shared target: world.all. There's a one-to-one mapping between
%% z and (pair/ z z).

%abbrev shared-tgt : nat = nat`z.


%%% ======================= Definitions =======================================

%% Environment - a pair of unique objects and capabilities

env : type.

env/ : set -> set -> env.


env`eq : env -> env -> type.

env`eq/ : env`eq V V.



%% Spliting a capability set into two subsets.

capset-split : set -> set -> set -> type.

capset-split/ :
    set`disjoint S1 S2 ->
    set`union S1 S2 S ->
  capset-split S S1 S2.



make-tgts-and-caps : set -> targets -> nat -> targets -> set -> type.

%%% When the result is shared, we can claim back the encumbered capabilities.
make-tgts-and-caps/shared :
    capset-split M0 (set/1 shared-tgt) M1 ->
 make-tgts-and-caps M0 targets/shared _
   (targets/unique set/0 (set/1 shared-tgt)) M1.

make-tgts-and-caps/unique :
    set+nat2set S F M2 ->
    capset-split M M1 M2 ->
    capset-split M0 M2 M3 ->
  make-tgts-and-caps M0 (targets/unique S M1) F (targets/unique set/0 M) M3.


% Consider field annotation, and returns either the input unique
% targets, or a shared targets. (no borrowed targets since field
% cannot be borrowed).

consider-ftype : targets -> set -> annot -> targets -> set -> type.

consider-ftype/shared :
    capset-split M1 M M0 ->
  consider-ftype (targets/unique set/0 M) M0 annot/shared targets/shared M1.

consider-ftype/unique : consider-ftype G M annot/unique G M.


%%% Converting between ty and reftype

ty2reftype : nat -> ty -> reftype -> type.

ty2reftype/shared : ty2reftype L (ty/ NN annot/shared C) (reftype/ NN C targets/shared).

ty2reftype/borrow : ty2reftype L (ty/ NN annot/borrow C)
    (reftype/ NN C (targets/unique (set/1 L) set/0)).

ty2reftype/unique : ty2reftype L (ty/ NN annot/unique C)
    (reftype/ NN C (targets/unique (set/1 L) set/0)).


reftype2ty : reftype -> ty -> type.

reftype2ty/shared : reftype2ty (reftype/ NN C targets/shared) (ty/ NN annot/shared C).

%% TODO: maybe annot/borrow more making sense?
reftype2ty/unique : reftype2ty (reftype/ NN C (targets/unique _ _)) (ty/ NN annot/unique C).


% sub-annotation rule with side effects.
% `targets`: the targets on the LHS
% `env`: the input environment, we need to remove consumed caps from it.
% `set`: the field set on LHS, used when consuming a whole object
% `annot`: the annotation on the RHS
% `env`: the output environment

%abbrev empty-env = (env/ set/0 set/0).

sub-annot : targets -> env -> set -> annot -> env -> env -> type.

sub-annot/unique :
    set+set2set S FS M2 ->
    capset-split M0 M2 M3 ->
    set`leq S U0 ->
    set`remove U0 S U1 ->
  sub-annot (targets/unique S M1) (env/ U0 M0) FS A (env/ S M2) (env/ U1 M3).

sub-annot/shared : sub-annot targets/shared V _ annot/shared empty-env V.


subtype : clsmap -> reftype -> env -> ty -> env -> env -> type.

subtype/ :
    nat`eq C1 C2 ->
    nonnull`leq NN2 NN1 ->
    clsmap`lookup CM C1 FM ->
    fldmap`domain FM FS ->
    sub-annot G V1 FS A2 V3 V2 ->
  subtype CM (reftype/ NN1 C1 G) V1 (ty/ NN2 A2 C2) V3 V2.

subtype/null : subtype _ reftype/null V ty/null empty-env V.

subtype/maynull : subtype _ reftype/null V (ty/ nn/may _ _) empty-env V.



%%% ======================= Theorems =======================================


%theorem capset-split-implies-disjoint-union
  : forall* {CS} {CS1} {CS2}
    forall {SP: capset-split CS CS1 CS2}
    exists {CS1^CS2: set`disjoint CS1 CS2} {CS1+CS2=CS: set`union CS1 CS2 CS}
    true.

- : capset-split-implies-disjoint-union (capset-split/ D U) D U.

%worlds (objvar) (capset-split-implies-disjoint-union _ _ _).
%total { } (capset-split-implies-disjoint-union _ _ _).


%theorem capset-split-implies-leq
  : forall* {CS} {CS1} {CS2}
    forall {SP: capset-split CS CS1 CS2}
    exists {CS1<=CS: set`leq CS1 CS} {CS2<=CS: set`leq CS2 CS}
    true.

- : capset-split-implies-leq (capset-split/ _ U) L1 L2
    <- set`union-implies-leq U L1 L2.

%worlds (objvar) (capset-split-implies-leq _ _ _).
%total { } (capset-split-implies-leq _ _ _).


%theorem capset-split-respects-eq
  : forall* {M} {MP} {M1} {M1P} {M2} {M2P}
    forall {M-M1=M2: capset-split M M1 M2}
    {M=MP: set`eq M MP}
    {M1=M1P: set`eq M1 M1P}
    {M2=M2P: set`eq M2 M2P}
    exists {M-M1=M2: capset-split MP M1P M2P}
    true.

%worlds () (capset-split-respects-eq _ _ _ _ _).
%trustme %total { } (capset-split-respects-eq _ _ _ _ _).


%theorem capset-split-unique
  : forall* {M} {MP} {M1} {M1P} {M2} {M2P}
    forall {M-M1=M2: capset-split M M1 M2}
    {MP-M1P=M2P: capset-split MP M1P M2P}
    {M=MP: set`eq M MP}
    {M1=M1P: set`eq M1 M1P}
    exists {M2=M2P: set`eq M2 M2P}
    true.

- : capset-split-unique (capset-split/ M1^M2 M1+M2=M)
    (capset-split/ M1P^M2P M1P+M2P=MP) M=MP M1=M1P M2=M2P
    <- set`union-commutative M1+M2=M M2+M1=M
    <- set`union-commutative M1P+M2P=MP M2P+M1P=MP
    <- set`disjoint-symmetric M1^M2 M2^M1
    <- set`disjoint-symmetric M1P^M2P M2P^M1P
    <- set`disjoint-union-implies-remove M2+M1=M M2^M1 M-M1=M2
    <- set`disjoint-union-implies-remove M2P+M1P=MP M2P^M1P MP-M1P=M2P
    <- set`remove-unique M-M1=M2 MP-M1P=M2P M=MP M1=M1P M2=M2P.

%worlds () (capset-split-unique _ _ _ _ _).
%total { } (capset-split-unique _ _ _ _ _).


%theorem capset-split-empty
  : forall* {M} {M1}
    forall {M-E=M1: capset-split M set/0 M1}
    exists {M1=M: set`eq M1 M}
    true.

%worlds () (capset-split-empty _ _).
%trustme %total { } (capset-split-empty _ _).