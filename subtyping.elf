% Subtyping Rules
% $Id: subtyping.elf,v 1.6 2013/06/11 16:39:23 csun Exp csun $

%%% Definitions

%{
 06-16-13: a special case here is when field set is empty, the
 result will contain keys that are mapped to set/0, and thus we
 will eventually end up with efxmap in which some keys are mapped
 to inner-efxmap/0. This is necessary since object may have
 no field, but we still need to record consume effect on it. tgtmap
 in targets should never have set/0 as value.

 When we remove a tgtmap from a efxmap, we need to first remove all
 entries with inner-efxmap/0 from the efxmap.
}%


% 1, determine the max effect from these two sets.

read-or-write : set -> set -> shared-efx -> type.

read-or-write/none : read-or-write set/0 set/0 shared-efx/none.

read-or-write/read : read-or-write (set/+ _ _) set/0 shared-efx/read.

read-or-write/write : read-or-write (set/+ _ _) (set/+ _ _) shared-efx/write.


% determine if we should generate any effect on shared.

efx-on-shared : bool -> shared-efx -> shared-efx -> type.

efx-on-shared/true : efx-on-shared true SX SX.

efx-on-shared/false : efx-on-shared false _ shared-efx/none.


%{
 Consider field annotation, and returns either the input unique
 targets, or a shared targets. (no borrowed targets since field
 cannot be borrowed).
}%

consider-ftype : targets -> annot -> targets -> type.

consider-ftype/shared : consider-ftype _ annot/shared targets/shared.

consider-ftype/unique : consider-ftype G annot/unique G.


%{
 Given input targets for field reference receiver,
 field annotation, field ID, and effects, compute the result
 targets and effects.
}%

create-shared-efx : efx -> shared-efx -> type.

create-shared-efx/read : create-shared-efx efx/read shared-efx/read.

create-shared-efx/write : create-shared-efx efx/write shared-efx/write.


make-targets-and-effects : targets -> nat -> efx -> targets -> effects -> type.

make-targets-and-effects/shared
  : create-shared-efx X SX
    -> make-targets-and-effects
      targets/shared  _ X (targets/unique set/0 set/0 true)
      (effects/ efxmap/0 set/0 SX set/0).

make-targets-and-effects/unique
  : set+nat2set G1 F G1'
    -> set`disjoint G2 G1'
    -> set`union G2 G1' G
    -> set2efxmap G X M
    -> create-shared-efx X SXx
    -> efx-on-shared SB SXx SX
    -> make-targets-and-effects
      (targets/unique G1 G2 SB) F X (targets/unique set/0 G SB)
      (effects/ M set/0 SX set/0).


sub-annot : targets -> set -> set -> set -> annot -> effects -> type.

sub-annot/consume
  : sub-annot (targets/unique G1 G2 false) _ _ FS A
    (effects/ efxmap/0 G shared-efx/none G1)
    <- not-borrowed A
    <- set+set2set G1 FS G1'
    <- set`disjoint G2 G1'
    <- set`union G2 G1' G.

sub-annot/unique2borrow
  : sub-annot (targets/unique G1 G2 B) RS WS _
    annot/borrow (effects/ M set/0 SX set/0)
    <- set+set2set G1 RS SR
    <- set+set2set G1 WS SW
    <- set`union G2 SR SR2
    <- set`union G2 SW SW2
    <- set2efxmap SR2 efx/read  M1
    <- set2efxmap SW2 efx/write M2
    <- efxmap`join M1 M2 M
    <- read-or-write RS WS SXx
    <- efx-on-shared B SXx SX.

sub-annot/shared2borrow
 : sub-annot targets/shared RS WS _ annot/borrow
   (effects/ efxmap/0 set/0 SX set/0)
    <- read-or-write RS WS SX.

sub-annot/shared2shared
  : sub-annot targets/shared set/0 set/0 _ annot/shared no-effect.


%abbrev sub-nonnull : nn -> nn -> type = [NN1][NN2] nonnull`leq NN2 NN1.


% The two sets are read and write fields respectively.

subtype : clsmap -> reftype -> ty -> set -> set -> effects -> type.

subtype/ : subtype CM (reftype/ NN1 C1 GS) (ty/ NN2 A2 C2) RS WS XX
           <- nat`eq C1 C2
           <- sub-nonnull NN1 NN2
           <- clsmap`lookup CM C1 FM
           <- fldmap`domain FM FS
           <- set`leq RS FS
           <- set`leq WS FS
           <- sub-annot GS RS WS FS A2 XX.

subtype/null : subtype _ reftype/null ty/null _ _ no-effect.

subtype/maynull : subtype _ reftype/null (ty/ nn/may _ _) _ _ no-effect.


%%% Theorems