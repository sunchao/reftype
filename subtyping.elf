%%% Subtyping Rules

%%% Definitions


%%% Environment - a pair of context and capmap

env : type.

env/ : cxt -> capmap -> env.


env`eq : env -> env -> type.

env`eq/ : env`eq V V.


%% We use a special natural number z to represent the special
%% shared target: world.all. There's a one-to-one mapping between
%% z and (pair/ z z).

%abbrev shared-tgt : nat = nat`z.


%%% Type Checking Result

result : kind -> type.

%abbrev expr-result = result exprk.

%abbrev cond-result = result condk.

%abbrev args-result = result argsk.


result/expr : reftype -> env -> expr-result.

result/exists : (object -> result K) -> result K.

result/cond : env -> cond-result.

result/args/0 : env -> args-result.

result/args/+ : reftype -> args-result -> args-result.


result`eq : result K -> result K -> type.

result`eq/ : result`eq R R.




%%% Given a set of targets for a receiver and a field ID, creates a set of
%%% result targets, and possible output effects.
%%% TODO: refactor this!

make-tgts-and-caps : capmap -> targets -> nat -> cap -> targets -> capmap -> type.

%%% When the result is shared, we can claim back the encumbered capabilities.
make-tgts-and-caps/shared
  : make-tgts-and-caps M0 targets/shared _ X
    (targets/unique set/0 (capmap/1 shared-tgt X)) M1
    <- capmap-split M0 (capmap/1 shared-tgt X) M1.

make-tgts-and-caps/unique
  : set+nat2capmap OS F X M2
    -> capmap-min-cap M1 X
    -> capmap`disjoint M1 M2
    -> capmap`join M1 M2 M
    -> capmap-split M0 M2 M3
    -> make-tgts-and-caps M0 (targets/unique OS M1) F X (targets/unique set/0 M) M3.


% Consider field annotation, and returns either the input unique
% targets, or a shared targets. (no borrowed targets since field
% cannot be borrowed).

consider-ftype : targets -> capmap -> annot -> targets -> capmap -> type.

consider-ftype/shared
  : consider-ftype (targets/unique set/0 M) M0 annot/shared targets/shared M1
    <- capmap`disjoint M M0
    <- capmap`join M M0 M1.

consider-ftype/unique : consider-ftype G M annot/unique G M.


% %% Convert an object target set into a field target set, which
% %% includes ALL fields of all object target.

% objset2fldset : clsmap -> cxt -> set -> set -> type.

% objset2fldset/0 : objset2fldset _ _ set/0 set/0.

% objset2fldset/U
%   : objset2fldset CM B OSP SP
%     -> cxt`lookup B N (cxt-info/ _ (ty/ _ _ C))
%     -> clsmap`lookup CM C FM
%     -> fldmap`domain FM FS
%     -> nat+set2set N FS R
%     -> set`union SP R S
%     -> set`not-member OSP N
%     -> set`add OSP N OS
%     -> objset2fldset CM B OS S.


%%% Converting between ty and reftype

ty2reftype : nat -> ty -> reftype -> type.

ty2reftype/shared
  : ty2reftype L (ty/ NN annot/shared C) (reftype/ NN C targets/shared).

ty2reftype/borrow
  : ty2reftype L (ty/ NN annot/borrow C)
    (reftype/ NN C (targets/unique (set/1 L) capmap/0)).

% ty2reftype/null : ty2reftype _ ty/null reftype/null.


reftype2ty : reftype -> ty -> type.

reftype2ty/shared
  : reftype2ty (reftype/ NN C targets/shared)
    (ty/ NN annot/shared C).

%% TODO: maybe annot/borrow more making sense?
reftype2ty/unique
  : reftype2ty (reftype/ NN C (targets/unique _ _))
    (ty/ NN annot/unique C).

% reftype2ty/null : reftype2ty reftype/null ty/null.


% Compatible : whether (encumbered) targets are compatible
% with the forthcoming effects.

% compatible : clsmap -> cxt -> targets -> effects -> type.

%{ this is rather restrictive: it means once we "hold on"
a unique field from a shared object, we cannot have any
effect on shared, until we release the unique field. For instance,
  (if true a else s).u1 = s.u2 is not allowed. This is caused by
the way we converting permissions - we make the result permission
to be *encumbered* BOTH in permission for a and permission for s
(shared permission). The fix is to replace the encumber permission
for shared with a nesting fact, and then delay the encumber
to later stage. However, at this time it turns out too much change
is required, so we left it to be fixed later.

Update: we need to restrict the occurrences of OS in effects too.
In case we have expression: let x = a in (a.f = 3; x.f = 4; x)
we would first convert the output of "x = a" into a certain format
where "x.f" is already carved from the permissions. Thus, when
checking "a.f = 3", we don't have permission for "a.f" since it's
already in the encumbered part.

We can get the permission for "a.f" by first using linear modus-ponens
to restore the permission for "a.f" and then get the permission for
"x.f" again when starting to check "x.f". However, this cannot
be implemented in the current system.

In order to implement this, we might need to change the way input
permission is generated. Instead of requiring the permissions for
"x", it should require the permissions where "x" will come from.
In this way, we only do carving whenever needed. This may be done
by binding "x" with all the targets & effects it came from, but this
requires a big surgery on the current context definition.

FUTURE WORK: fix compatible/shared.
FUTURE WORK: better/less restrictive compatible/unique
}%

%{
compatible/shared : set`not-member S shared-tgt
                    -> compatible _ _ targets/shared (effects/ _ S Q).

compatible/unique : capmap`domain M R
                    -> set`disjoint FS R
                    -> set`disjoint FS S
                    -> objset2fldset CM B Q FS2
                    -> set`disjoint FS FS2
                    -> compatible CM B (targets/unique OS FS) (effects/ M S Q).
}%


%%% For the given context, replace all occurrences of object id in the set
%%%  from unique to borrowed.
%%% TODO: change to a better name
cxt-remove-unique : cxt -> set -> cxt -> type.

cxt-remove-unique/0 : cxt-remove-unique B set/0 B.

cxt-remove-unique/U
  : cxt-remove-unique B0 S' B1
    -> cxt`lookup B1 N (cxt-info/ O (ty/ NN annot/unique C))
    -> cxt`update B1 N (cxt-info/ O (ty/ NN annot/borrow C)) B2
    -> set`not-member S' N
    -> set`add S' N S
    -> cxt-remove-unique B0 S B2.



% sub-annotation rule with side effects.
% `targets`: the targets on the LHS
% `env`: the input environment, we need to remove consumed caps from it.
% `set`: the field set on LHS, used when consuming a whole object
% `annot`: the annotation on the RHS
% `env`: the output environment

sub-annot-cap : targets -> env -> set -> annot -> env -> type.

sub-annot-cap/consume
  : set+set2capmap OS S cap/write M2
    -> capmap-split M0 M2 M3
    -> capmap-min-cap M1 cap/write
    -> cxt-remove-unique B0 OS B1
    -> sub-annot-cap (targets/unique OS M1) (env/ B0 M0) S A (env/ B1 M3).

sub-annot-cap/shared2shared : sub-annot-cap targets/shared V _ annot/shared V.


%abbrev sub-nonnull : nn -> nn -> type = [NN1][NN2] nonnull`leq NN2 NN1.

%abbrev sub-annot : annot -> annot -> type = [A1][A2] annot`leq A2 A1.


%%% The two sets are read and write fields respectively.

subtype : clsmap -> reftype -> env -> ty -> env -> type.

subtype/ : subtype CM (reftype/ NN1 C1 GS) VI (ty/ NN2 A2 C2) VO
           <- nat`eq C1 C2
           <- sub-nonnull NN1 NN2
           <- clsmap`lookup CM C1 FM
           <- fldmap`domain FM FS
           <- sub-annot-cap GS VI FS A2 VO.

subtype/null : subtype _ reftype/null V ty/null V.

subtype/maynull : subtype _ reftype/null V (ty/ nn/may _ _) V.


%theorem make-tgts-and-caps-implies-min-cap
  : forall* {M0} {G0} {F} {X} {M} {M1}
    forall {MG: make-tgts-and-caps M0 G0 F X (targets/unique set/0 M) M1}
    exists {MC-M=X: capmap-min-cap M X}
    true.

- : make-tgts-and-caps-implies-min-cap (make-tgts-and-caps/shared _)
    (capmap-min-cap/U capmap-min-cap/0 MI capmap`update/0 capmap`fresh/0)
    <- cap/write-is-upper-bound _ MI.

- : make-tgts-and-caps-implies-min-cap
    (make-tgts-and-caps/unique OS+X=M2 MC-M1=X M1^M2 M1+M2=M M0-M2=M3) MC-M=X
    <- set+nat2capmap-implies-min-cap OS+X=M2 MC-M2=X
    <- capmap-join-preserves-min-cap MC-M1=X MC-M2=X M1+M2=M MC-M=X.

%worlds (objvar) (make-tgts-and-caps-implies-min-cap _ _).
%total { } (make-tgts-and-caps-implies-min-cap _ _).