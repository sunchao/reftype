% This theorem says if we have a let expression:

%   let x = e1 in e2 end
% and that the output from checking e1 is Out1, from e2 is
% Out2. Then, we can substitute all occurrences of x in Out2
% with some form derived from Out1, and the result of substitution
% Out2' is equivalent to the combination of Out1 and Out2.

%% ----------------------------------------------------------
%% Definitions
%% ----------------------------------------------------------

%% For a let expression let x = e1 in e2, `targets` is from e1, `nat` is
%% the object index for x, and `effects` is from e2.

%abbrev unique-target : targets = targets/unique set/0 set/0.

%% The following three theorems say that x can only occur in one of
%% the three constructs inside effect, if the effect is well-formed
%% with-respect-to clsmap and cxt.

% a wrapper

object-in-efxmap : effects -> nat -> type.

object-in-efxmap/ : object-in-efxmap (effects/ M _ _) N
                    <- efxmap-map-objects M OS
                    <- set`member OS N.


%% -----------------------------------------------------------
%% Lemmas
%% -----------------------------------------------------------

%theorem subst-effects-one-occurrence/1
  : forall* {CM} {B} {M} {S} {Q} {OS} {SS} {N}
    forall {CM-B-XX: clsmap-cxt-effects CM B (effects/ M S Q)}
    {M=>OS: efxmap-map-objects M OS}
    {S=>SS: set-map-objects S SS}
    {MB: set`member OS N}
    exists {OUT-S: set`not-member SS N}
    {OUT-Q: set`not-member Q N}
    true.

%worlds (objvar) (subst-effects-one-occurrence/1 _ _ _ _ _ _).
%trustme %total { } (subst-effects-one-occurrence/1 _ _ _ _ _ _).


%theorem subst-effects-one-occurrence/2
  : forall* {CM} {B} {M} {S} {Q} {OS} {SS} {N}
    forall {CM-B-XX: clsmap-cxt-effects CM B (effects/ M S Q)}
    {M=>MS: efxmap-map-objects M OS}
    {S=>SS: set-map-objects S SS}
    {IN-SS: set`member SS N}
    exists {OUT-OS: set`not-member OS N}
    {OUT-Q: set`not-member Q N}
    true.

%worlds (objvar) (subst-effects-one-occurrence/2 _ _ _ _ _ _).
%trustme %total () (subst-effects-one-occurrence/2 _ _ _ _ _ _).


%theorem subst-effects-one-occurrence/3
  : forall* {CM} {B} {M} {S} {Q} {OS} {SS} {N}
    forall {CM-B-XX: clsmap-cxt-effects CM B (effects/ M S Q)}
    {M=>MS: efxmap-map-objects M OS}
    {S=>SS: set-map-objects S SS}
    {IN-Q: set`member Q N}
    exists {OUT-OS: set`not-member OS N}
    {OUT-SS: set`not-member SS N}
    true.

%worlds (objvar) (subst-effects-one-occurrence/3 _ _ _ _ _ _).
%trustme %total () (subst-effects-one-occurrence/3 _ _ _ _ _ _).


%theorem let-helper/L1
  : forall* {CM} {B} {M1} {S1} {M2} {S2} {Q1} {Q2} {Q} {M} {S}
    forall {CM-B-XX: clsmap-cxt-effects CM B (effects/ M2 S2 Q2)}
    {XJ: effects`join (effects/ M1 S1 Q1) (effects/ M2 S2 Q2) (effects/ M S Q)}
    exists {M0} {TC: transfer-consume CM B (effects/ M S Q) (effects/ M1 S1 Q1)
                     (effects/ M0 S1 Q1) Q2}
    true.

- : let-helper/L1 (clsmap-cxt-effects/ _ _ Q2=>S3 _ _ _ _ _)
    (effects`join/ DM-M1=R1 DM-M2=R2 S1^R1 S2^R2 S1^R2 S1^S2 R1/S2=R
      M1|R=M1' M1'uM2=M S1uS2=S Q1^Q2 Q1uQ2=Q) %{=>}%
    _ (transfer-consume/ S1<=S Q1<=Q S/S1=S2 Q/Q1=Q2 Q2=>S3
        S2uS3=S4 S4=>M3 MuM3=MP)
    <- set`union-implies-leq S1uS2=S S1<=S S2<=S
    <- set`union-implies-leq Q1uQ2=Q Q1<=Q Q2<=Q
    <- set`union-commutative S1uS2=S S2uS1=S
    <- set`disjoint-symmetric S1^S2 S2^S1
    <- set`union-commutative Q1uQ2=Q Q2uQ1=Q
    <- set`disjoint-symmetric Q1^Q2 Q2^Q1
    <- set`disjoint-union-implies-remove S2uS1=S S2^S1 S/S1=S2
    <- set`disjoint-union-implies-remove Q2uQ1=Q Q2^Q1 Q/Q1=Q2
    <- set`union-total S2uS3=S4
    <- set2efxmap-total S4=>M3
    <- efxmap`join-total MuM3=MP.

%worlds (objvar) (let-helper/L1 _ _ _ _).
%total { } (let-helper/L1 _ _ _ _).


%theorem let-helper/L2
  : forall* {M1} {S1} {Q1} {M2} {S2} {Q2}
    {M} {S} {Q} {MP} {M0} {CM} {B}
    forall {CM-B-XXP: clsmap-cxt-effects CM B (effects/ MP S Q)}
    {XX1+XX2=XX: effects`join (effects/ M1 S1 Q1) (effects/ M2 S2 Q2)
               (effects/ M S Q)}
    {XX<c=XXP: effects-leq-no-consume (effects/ M S Q) (effects/ MP S Q)}
    {XX'+XX1=>XXc+Q: transfer-consume CM B
                     (effects/ MP S Q) (effects/ M1 S1 Q1) (effects/ M0 S1 Q1) Q2}
    exists {S3} {FS3} {M3} {Q2=>FS3: objset2fldset CM B Q2 FS3}
    {S2^FS3: set`disjoint S2 FS3}
    {S2uFS3=S3: set`union S2 FS3 S3}
    {S3=>M3: set2efxmap S3 efx/write M3}
    {MP^Mk: efxmap`disjoint MP M3}
    {MP+M3=M0: efxmap`join MP M3 M0}
    true.

- : let-helper/L2
    (clsmap-cxt-effects/
      (DM-MP=RP:efxmap`domain MP RP)
      (RP^S:set`disjoint RP S)
      (Q=>FS:objset2fldset CM B Q FS)
      (RP^FS:set`disjoint RP FS)
      (S^FS:set`disjoint S FS) _ _ _)
    (effects`join/ _ _ _ _ _
      (S1^S2:set`disjoint S1 S2) RM RS M1P+M2=M S1+S2=S Q1^Q2
      (Q1+Q2=Q:set`union Q1 Q2 Q))
    (effects-leq-no-consume/ M<=MP)
    (transfer-consume/ S1<=S Q1<=Q
      (S/S1=S2P:set`remove S S1 S2P)
      (Q/Q1=Q2:set`remove Q Q1 Q2)
      Q2=>FS3 S2PuFS3=S3 S3=>M3 MP+M3=Mc) %{=>}%
    S3 FS3 M3 Q2=>FS3 S2^FS3 S2uFS3=S3 S3=>M3 MP^M3 MP+M3=Mc
    <- set`union-commutative S1+S2=S S2+S1=S
    <- set`disjoint-symmetric S1^S2 S2^S1
    <- set`union-commutative Q1+Q2=Q Q2+Q1=Q
    <- set`disjoint-symmetric Q1^Q2 Q2^Q1
    <- set`disjoint-union-implies-remove S2+S1=S S2^S1 S/S1=S2
    <- set`remove-unique S/S1=S2P S/S1=S2 set`eq/ set`eq/ S2P=S2
    <- set`union-respects-eq S2PuFS3=S3 S2P=S2 set`eq/ set`eq/ S2uFS3=S3
    <- set`union-implies-leq S1+S2=S _ S2<=S
    <- set`remove-implies-leq Q/Q1=Q2 Q2<=Q
    <- objset2fldset-preserves-leq* Q2<=Q Q2=>FS3 Q=>FS FS3<=FS
    <- set`disjoint-respects-geq S^FS S2<=S FS3<=FS S2^FS3
    <- set`leq-reflexive _ RP<=RP
    <- set`disjoint-respects-geq RP^S RP<=RP S2<=S RP^S2
    <- set`disjoint-respects-geq RP^FS RP<=RP FS3<=FS RP^FS3
    <- set`union-right-preserves-disjoint* RP^S2 RP^FS3 S2uFS3=S3 RP^S3
    <- set2efxmap-implies-domain S3=>M3 DM-M3=S3
    <- efxmap`domain-preserves-disjoint-converse RP^S3 DM-MP=RP DM-M3=S3 MP^M3.

%worlds (objvar) (let-helper/L2 _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L2 _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L3
  : forall* {M1} {S1} {Q1} {M2} {S2} {Q2} {QP}
    {M} {S} {Q} {MP} {M0} {CM} {B} {S0} {Q0}
    forall {CM-B-XXV: clsmap-cxt-effects CM B (effects/ MP S Q)}
    {XX1+XX2=XX: effects`join (effects/ M1 S1 Q1) (effects/ M2 S2 Q2) (effects/ M S Q)}
    {XX<=XXV: efxmap`leq M MP}
    {XX'+XX1=>XXc+Q: transfer-consume CM B (effects/ MP S Q) (effects/ M1 S1 Q1)
                     (effects/ M0 S0 Q0) QP}
    exists {S3} {FS3} {M3} {QP=>FS3: objset2fldset CM B QP FS3}
    {S2^FS3: set`disjoint S2 FS3}
    {S2uFS3=S3: set`union S2 FS3 S3}
    {S3=>M3: set2efxmap S3 efx/write M3}
    {MP^M3: efxmap`disjoint MP M3}
    {MP+M3=M0: efxmap`join MP M3 M0}
    {QE: set`eq QP Q2} {E: set`eq S0 S1} {E: set`eq Q0 Q1}
    true.

- : let-helper/L3
    (clsmap-cxt-effects/
      (DM-M'=R':efxmap`domain M' R')
      (R'^S:set`disjoint R' S)
      (Q=>FS:objset2fldset CM B Q FS)
      (R'^FS:set`disjoint R' FS)
      (S^FS:set`disjoint S FS) _ _ _)
    (effects`join/ _ _ _ _ _
      (S1^S2:set`disjoint S1 S2) RM RS M1'+M2=M S1+S2=S Q1^Q2
      (Q1+Q2=Q:set`union Q1 Q2 Q)) M<=M'
    (transfer-consume/ S1<=S Q1<=Q
      S/S1=S2' Q/Q1=Q3 Q3=>FS3 S2'uFS3=S3 S3=>M3 M'+M3=Mc) %{=>}%
    S3 FS3 M3 Q3=>FS3 S2^FS3 S2uFS3=S3 S3=>M3 M'^M3 M'+M3=Mc Q3=Q2 set`eq/ set`eq/
    <- set`union-commutative S1+S2=S S2+S1=S
    <- set`disjoint-symmetric S1^S2 S2^S1
    <- set`union-commutative Q1+Q2=Q Q2+Q1=Q
    <- set`disjoint-symmetric Q1^Q2 Q2^Q1
    <- set`disjoint-union-implies-remove S2+S1=S S2^S1 S/S1=S2
    <- set`disjoint-union-implies-remove Q2+Q1=Q Q2^Q1 Q/Q1=Q2
    <- set`remove-unique S/S1=S2' S/S1=S2 set`eq/ set`eq/ S2'=S2
    <- set`union-respects-eq S2'uFS3=S3 S2'=S2 set`eq/ set`eq/ S2uFS3=S3
    <- set`union-implies-leq S1+S2=S _ S2<=S
    <- set`remove-implies-leq Q/Q1=Q3 Q3<=Q
    <- objset2fldset-preserves-leq* Q3<=Q Q3=>FS3 Q=>FS FS3<=FS
    <- set`disjoint-respects-geq S^FS S2<=S FS3<=FS S2^FS3
    <- set`remove-unique Q/Q1=Q3 Q/Q1=Q2 set`eq/ set`eq/ Q3=Q2
    <- set`leq-reflexive _ R'<=R'
    <- set`disjoint-respects-geq R'^S R'<=R' S2<=S R'^S2
    <- set`disjoint-respects-geq R'^FS R'<=R' FS3<=FS R'^FS3
    <- set`union-right-preserves-disjoint* R'^S2 R'^FS3 S2uFS3=S3 R'^S3
    <- set2efxmap-implies-domain S3=>M3 DM-M3=S3
    <- efxmap`domain-preserves-disjoint-converse R'^S3 DM-M'=R' DM-M3=S3 M'^M3.

%worlds (objvar) (let-helper/L3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L4
  : forall* {M} {N} {Mout} {Min} {Rout}
    forall {PT: efxmap-partition-on-index M N Mout Min}
    {DM: efxmap`domain Mout Rout}
    exists {Oout} {ESO: efxmap-same-object Min N}
    {Rout=>Oout: set-map-objects Rout Oout}
    {N!<Oout: set`not-member Oout N}
    true.

%worlds (objvar) (let-helper/L4 _ _ _ _ _ _).
%trustme %total { } (let-helper/L4 _ _ _ _ _ _).


%theorem let-helper/L51/L
  : forall* {M} {N} {K} {X}
    forall {SN} {SZ: efxmap`size M SN}
    {MO: efxmap-map-objects M (set/1 N)}
    {ML: efxmap`lookup M K X}
    exists {F} {N+F=K: pair2nat (pair/ N F) K}
    true.

%theorem let-helper/L51/L1
  : forall* {SP} {N} {NP}
    forall {AD: set`add SP NP (set/1 N)}
    exists {EQ: nat`eq NP N}
    true.

- : let-helper/L51/L1 set`update/0 nat`eq/.

- : let-helper/L51/L1 (set`update/= E) E.

%worlds (objvar) (let-helper/L51/L1 _ _).
%total { } (let-helper/L51/L1 _ _).


%theorem let-helper/L51/L2
  : forall* {MP} {SP} {K} {X} {N} {NP}
    forall {MP=>SP: efxmap-map-objects MP SP}
    {ML: efxmap`lookup MP K X}
    {SP+NP=S: set`add SP NP (set/1 N)}
    exists {EQ: set`eq SP (set/1 N)}
    true.

- : let-helper/L51/L2 efxmap-map-objects/0 ML set`update/0 E
    <- efxmap`lookup-contradiction ML V
    <- set`false-implies-eq V E.

- : let-helper/L51/L2 _ _ (set`update/= E) set`eq/.

%worlds (objvar) (let-helper/L51/L2 _ _ _ _).
%total { } (let-helper/L51/L2 _ _ _ _).

%theorem let-helper/L51/LL
  : forall* {M} {N} {K} {X} {KP} {B} {MP} {FP} {SP} {XP} {NP}
    forall {SN} {SZ: efxmap`size MP SN} {MPO: efxmap-map-objects MP SP}
    {N+F=K: pair2nat (pair/ NP FP) KP}
    {FS: efxmap`fresh MP KP} {UD: efxmap`update MP KP XP M}
    {A: set`add SP NP (set/1 N)}
    {ML: efxmap`lookup M K X}
    {EQ?: nat`eq? KP K B}
    exists {F} {N+F=K: pair2nat (pair/ N F) K}
    true.

- : let-helper/L51/LL _ SZ MP=>SP NP+FP=KP KP!<MP (MP+KP=M:efxmap`update MP KP XP M)
    SP+NP=S (M->K=X:efxmap`lookup M K X) (nat`eq?/no (KP<>K:nat`ne KP K)) _ N+F=K
    <- nat`ne-symmetric KP<>K K<>KP
    <- efxmap`update-preserves-lookup-converse M->K=X MP+KP=M K<>KP MP->K=X
    <- let-helper/L51/L2 MP=>SP MP->K=X SP+NP=S SP=
    <- efxmap-map-objects-respects-eq MP=>SP efxmap`eq/ SP= MP=>SP1
    <- let-helper/L51/L _ SZ MP=>SP1 MP->K=X _ N+F=K.

- : let-helper/L51/LL _ _ MP=>SP NP+F=K KP!<MP MP+KP=M
    SP+NP=S M->K=X (nat`eq?/yes) _ N+F=K
    <- let-helper/L51/L1 SP+NP=S NP=N
    <- pair-preserves-eq NP=N nat`eq/ PE
    <- pair2nat-respects-eq NP+F=K PE nat`eq/ N+F=K.

- : let-helper/L51/L (s SN) SZ
    (efxmap-map-objects/U M'=>S' N+F=K' K!<M' M'+K=M S'+N=S) ML _ N+F=K
    <- nat`eq?-total E?
    <- efxmap`fresh-update-increases-size-converse SZ K!<M' M'+K=M SZ'
    <- let-helper/L51/LL SN SZ' M'=>S' N+F=K' K!<M' M'+K=M S'+N=S ML E? _ N+F=K.

%worlds (objvar) (let-helper/L51/L _ _ _ _ _ _)
  (let-helper/L51/LL _ _ _ _ _ _ _ _ _ _ _).
%total (M0 M) (let-helper/L51/L M _ _ _ _ _)
  (let-helper/L51/LL M0 _ _ _ _ _ _ _ _ _ _).


% %theorem let-helper/L51
%   : forall* {M} {N} {K} {X}
%     forall {MO: efxmap-map-objects M (set/1 N)}
%     {ML: efxmap`lookup M K X}
%     exists {F} {N+F=K: pair2nat (pair/ N F) K}
%     true.

% - : let-helper/L51 MO ML _ T
%     <- efxmap`size-total SZ
%     <- let-helper/L51/L _ SZ MO ML _ T.

% %worlds (objvar) (let-helper/L51 _ _ _ _).
% %total { } (let-helper/L51 _ _ _ _).


%theorem let-helper/L5*/L
  : forall* {CM} {B} {FM} {MF} {SF} {FS}
    {N} {M} {NN} {A} {C} {S}
    forall {SN} {SZ: efxmap`size M SN}
    {DM-M: efxmap`domain M S}
    {CM-B-S: {x} clsmap-cxt-fldset CM (B x) S}
    {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {ESO: efxmap-same-object M N}
    {EMF: efxmap-map-fields M MF}
    {DM-MF: efxmap`domain MF SF}
    {DM-FM: fldmap`domain FM FS}
    exists {SF<=FS: set`leq SF FS}
    true.

- : let-helper/L5*/L _ efxmap`size/0 efxmap`domain/0
    ([_] clsmap-cxt-fldset/0)
    BL CML ESO efxmap-map-fields/0 efxmap`domain/0 DM-FM set`leq/0.

- : let-helper/L5*/L _ SZ DM-M=S CM-B-S BL CML ESO
    (efxmap-map-fields/U
      (M'=>MF':efxmap-map-fields M' MF')
      (N+F=K0: pair2nat (pair/ N0 F0) K)
      (K!<M': efxmap`fresh M' K)
      (M'+K=M: efxmap`update M' K X M)
      (MF'+F=MF: efxmap`update MF' F0 X MF))
    DM-MF=SF DM-FM SF<=FS
    <- efxmap`domain-total DM-MF'=SF'
    <- efxmap`domain-total DM-M'=S'
    <- efxmap`domain-preserves-fresh K!<M' DM-M'=S' K!<S'
    <- efxmap`update-commute-domain M'+K=M DM-M'=S' DM-M=S S'+K=S
    <- efxmap-same-object/U-inversion ESO K!<M' M'+K=M ESO'
      (match-index?/yes (N+F=K2:pair2nat (pair/ N2 F2) K))
    <- efxmap`update-commute-domain MF'+F=MF DM-MF'=SF' DM-MF=SF
      (SF'+F=SF:set`add SF' F0 SF)
    <- ({x} clsmap-cxt-fldset/U-inversion (CM-B-S x) K!<S'
         S'+K=S (CM-B-S' x) _ _ N+F=K1 _ _ _ _ (BL' x) _ CML' _ FML')
    <- nat2pair-unique N+F=K2 N+F=K1 nat`eq/ PE
    <- nat2pair-unique N+F=K1 N+F=K0 nat`eq/ PE'
    <- pair-eq-implies-eq PE' NE' FE'
    <- pair-eq-implies-eq PE NE FE
    <- ({x} cxt`lookup-unique (BL x) (BL' x) cxt`eq/ NE (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE NNE AE CE
    <- clsmap`lookup-unique CML CML' clsmap`eq/ CE FME
    <- fldmap`domain-respects-eq DM-FM FME set`eq/ DM-FM'
    <- fldmap`domain-preserves-lookup FML' DM-FM' F<-S'
    <- set`member-respects-eq F<-S' set`eq/ FE' F<-S
    <- efxmap`fresh-update-increases-size-converse SZ K!<M' M'+K=M SZ'
    <- let-helper/L5*/L _ SZ' DM-M'=S' CM-B-S' BL CML ESO' M'=>MF'
      DM-MF'=SF' DM-FM SF'<=FS
    <- set`add-member-preserves-leq SF'<=FS SF'+F=SF F<-S SF<=FS.

%worlds (objvar) (let-helper/L5*/L _ _ _ _ _ _ _ _ _ _ _).
%total (DM) (let-helper/L5*/L DM _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L5*
  : forall* {CM} {B} {FM} {MF} {SF} {FS} {N} {M} {NN} {A} {C} {S}
    forall {DM-M: efxmap`domain M S}
    {CM-B-S: {x} clsmap-cxt-fldset CM (B x) S}
    {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {ESO: efxmap-same-object M N}
    {EMF: efxmap-map-fields M MF}
    {DM-MF: efxmap`domain MF SF}
    {DM-FM: fldmap`domain FM FS}
    exists {SF<=FS: set`leq SF FS}
    true.

- : let-helper/L5* DM-M CM-B-S BL CML M-N M=>MF DM-MF=SF DM-FM=FS SF<=FS
    <- efxmap`size-total SZ
    <- let-helper/L5*/L _ SZ DM-M CM-B-S BL CML M-N M=>MF DM-MF=SF DM-FM=FS SF<=FS.

%worlds (objvar) (let-helper/L5* _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L5* _ _ _ _ _ _ _ _ _).


%theorem let-helper/L5
  : forall* {CM} {FM} {B} {R} {MFin} {N} {Min} {NN} {A} {C}
    forall {DM-M: efxmap`domain Min R}
    {CM-B-R: {x} clsmap-cxt-fldset CM (B x) R}
    {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {ESO: efxmap-same-object Min N}
    {EMF: efxmap-map-fields Min MFin}
    exists {SFin} {FS}
    {DM-MFin: efxmap`domain MFin SFin}
    {DM-FM: fldmap`domain FM FS}
    {SFin<=FS: set`leq SFin FS}
    true.

- : let-helper/L5 DM-M CM-B-R BL CML ESO EMF _ _ DM-MFin=SFin
    DM-FM=FS SFin<=FS
    <- fldmap`domain-total DM-FM=FS
    <- efxmap`domain-total DM-MFin=SFin
    <- let-helper/L5* DM-M CM-B-R BL CML ESO EMF DM-MFin=SFin
      DM-FM=FS SFin<=FS.

%worlds (objvar) (let-helper/L5 _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L5 _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L6
  : forall* {M1} {M2} {M} {S1} {S2} {S} {Q1} {Q2} {Q}
    forall {J: effects`join (effects/ M1 S1 Q1) (effects/ M2 S2 Q2)
               (effects/ M S Q)}
    exists {LE: efxmap`leq M2 M}
    true.

- : let-helper/L6 (effects`join/ _ _ _ _ _ _ _ _ M1P+M2=M _ _ _) M2<=M
    <- efxmap`join-implies-leq M1P+M2=M _ M2<=M.

%worlds (objvar) (let-helper/L6 _ _).
%total { } (let-helper/L6 _ _).


%theorem let-helper/L7
  : forall* {CM} {PM} {FM} {CJ} {FS} {Pf}
    forall {FM2G: fldmap2conj CM PM FM ([x] CJ x) PM}
    {FM2P: {x} fldmap2perm PM x FM FS (Pf x)}
    exists {IMP: {x} bimplies true (CJ x) (nested (Pf x) x all)}
    true.

%worlds (objvar) (let-helper/L7 _ _ _).
%trustme %total { } (let-helper/L7 _ _ _).


%{%
  Given a subset of fields for a class, we really want to have
the permissions for them carving out of the permission for
the whole class.

It SHOULD goes like this:

  (x = null ? 0 : (Pif <- x.all , x.all->0, P(x)))
==>
  (x = null ? x = null : (x != null , Pif , Pif --|- x.all , P(x)))
==>
  ((x = null ? 0 : Pif) , (x = null ? 0 : (Pif --|- (x.all , P(x)))))
==>
  .. ??
==>
  ((x = null ? 0 : Pif) , (x = null ? 0 : Pif) --|- (x = null ? 0 : (x.all , P(x))))

However, currently I couldn't find a way to prove this.
The following let-helper/L8 will assume the above for now. Otherwise,
the permission format would just become too complicated.

Update: chatted with Dr. Boyland, and he confirmed that this is not provable.
I need to find a workaround for this.

Maybe something like this:

  (x = null ? 0 : (Pif <- x.all , x.all -> 0 , P(x)))
==>
  (x = null ? 0 : (Pif , Pif --|- (x.all , P(x))))
==>
  (x = null ? 0 : Pif) , (x = null ? 0 : Pif --|- (x.all , P(x)))

%}%

%theorem let-helper/L8
  : forall* {CM} {PM} {FS} {NN} {C} {AF} {Pf} {FM} {PF} {CP}
    forall {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {A2P: annot2perm annot/unique AF}
    {NN2P: nn2perm NN AF PF}
    {PML: predmap`lookup PM C CP}
    {M2P: {x} fldmap2perm PM x FM FS (Pf x)}
    exists {Pfn1} {Pfn2}
    {IMP1: {x} implies (Pfn1 x) (Pfn2 x)}
    {IMP2: {x} implies (Pfn2 x) (Pfn1 x)}
    {CN: consider-nn ([x] Pf x) NN ([x] Pfn2 x)}
    {IMP: {x} implies (PF CP x) ((Pfn1 x) , (unitperm (encumbered (Pfn1 x) (PF CP x))))}
    true.

- : let-helper/L8 CM2PM CML annot2perm/unique nn2perm/may PML
    ([x] FS=>Pf x) _ _ IMP1 IMP2 consider-nn/may
    ([x] implies/trans
      (implies/cond-inner
        bimplies/reflexive
        bimplies/reflexive
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/trans6
          (implies/combine implies/reflexive
            (implies/trans
              (implies/nonlinear bimplies/conj-duplicate)
              (implies/conj2combine)))
          (implies/equiv equiv/associate)
          (implies/combine implies/reflexive
            (implies/trans
              (implies/equiv (EQV x))
              (implies/nonlinear
                (bimplies/trans4
                  (bimplies/predcall/Y/inline)
                  (bimplies/predcall/+/inline x)
                  (bimplies/predcall/0/inline)
                  (BIMP x)))))
          (implies/equiv
            (equiv/transitive equiv/commute equiv/associate))
          (implies/combine implies/carve implies/reflexive)
          (implies/equiv (equiv/symmetric equiv/associate))))
      (implies/cond-distribute))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- clsmap-predmap-implies-lookup-format CM-PM PML _ PMLP ([x] PEQ x)
    <- ({x} permission`eq-implies-equiv (PEQ x) (EQV x))
    <- clsmap2predmap-implies-fldmap2conj CM2PM PMLP CML FM=>CJ
    <- let-helper/L7 FM=>CJ FS=>Pf ([x] BIMP x).

% - : let-helper/L8 CM2PM CML annot2perm/unique nn2perm/yes PML
%     ([x] FS=>Pf x) _ _ consider-nn/yes consider-nn/yes
%     ([x] implies/trans
%       (implies/combine
%         (implies/trans
%           (implies/nonlinear bimplies/tt)
%           (implies/true2empty))
%         (implies/trans3
%           (implies/combine (implies/reflexive)
%             (implies/trans3
%               (implies/nonlinear bimplies/conj-duplicate)
%               (implies/conj2combine)
%               (implies/combine
%                 (implies/trans
%                   (implies/equiv (EQV x))
%                   (implies/nonlinear
%                     (bimplies/trans4
%                       (bimplies/predcall/Y/inline)
%                       (bimplies/predcall/+/inline x)
%                       (bimplies/predcall/0/inline)
%                       (BIMP x))))
%                 (implies/reflexive))))
%           (implies/equiv equiv/associate)
%           (implies/combine
%             (implies/trans
%               (implies/equiv equiv/commute)
%               (implies/carve))
%             (implies/reflexive))))
%       (implies/equiv
%         (equiv/transitive3
%           (equiv/commute)
%           (equiv/identity)
%           (equiv/symmetric equiv/associate))))
%     <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
%     <- clsmap-predmap-implies-lookup-format CM-PM PML _ PMLP ([x] PEQ x)
%     <- ({x} permission`eq-implies-equiv (PEQ x) (EQV x))
%     <- clsmap2predmap-implies-fldmap2conj CM2PM PMLP CML FM=>CJ
%     <- let-helper/L7 FM=>CJ FS=>Pf ([x] BIMP x).

%worlds (objvar) (let-helper/L8 _ _ _ _ _ _ _ _ _).
%trustme %total { } (let-helper/L8 _ _ _ _ _ _ _ _ _).


%theorem let-helper/L9
  : forall* {CM} {PM} {FM} {B} {N} {NN} {A} {C} {FS} {Pf} {Pfn} {S} {M}
    forall {SN} {SZ-FS=SN: set`size FS (s SN)}
    {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {FM2P: {x} fldmap2perm PM x FM FS (Pf x)}
    {CN: consider-nn Pf NN ([x] Pfn x)}
    {N+FS=>S: nat+set2set N FS S}
    {S=>M: set2efxmap S efx/write M}
    exists {Pf2} {M2P: {x} efxmap2perm CM PM (B x) M (Pf2 x)}
    {IMP: {x} implies (Pfn x) (Pf2 x)}
    {IMP: {x} implies (Pf2 x) (Pfn x)}
    true.

%theorem let-helper/L9/F1
  : forall* {PM} {B:object -> cxt} {M} {Pfn}
    forall {CM}
    exists {Pf2} {M2P: {x} efxmap2perm CM PM (B x) M (Pf2 x)}
    {IMP: {x} implies (Pfn x) (Pf2 x)}
    {IMP: {x} implies (Pf2 x) (Pfn x)}
    true.

%worlds (objvar) (let-helper/L9/F1 _ _ _ _ _).
%trustme %total {} (let-helper/L9/F1 _ _ _ _ _).


%theorem let-helper/L9/L
  : forall* {PF1} {PF2} {F}
    forall {EQ: {x}{x1} permission`eq (PF1 x x1) (PF2 x1)}
    exists {EQV: {x} equiv (unitperm (precise-exists x F ([x1] PF1 x x1)))
                 (unitperm (precise-exists x F ([x1] PF2 x1)))}
    true.

- : let-helper/L9/L ([_][_] permission`eq/) ([_] equiv/reflexive).

%worlds (objvar) (let-helper/L9/L _ _).
%total { } (let-helper/L9/L _ _).


- : {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ nn/yes A C))}
    let-helper/L9 z SZ BL CML
    ([x] fldmap2perm/U (FSP=>PiP x) (F!<FSP:set`not-member FSP F)
      (FSP+F=FS:set`add FSP F FS) (FML:fldmap`lookup FM F T)
      (T2PFF x)) consider-nn/yes
    (N+FS=>S:nat+set2set N FS S) (S=>M:set2efxmap S efx/write M)
    %{=>}% _
    ([x] efxmap2perm/U (MP=>E x) N+F=K (BL x) CML FML T2PF
      consider-nn/yes apply-efx/write K!<MP MP+K=M)
    ([x] implies/trans
      (implies/combine implies/reflexive
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/equiv
            (equiv/transitive
              (equiv/combine (EQV x) (EQV2 x))
              (equiv/identity)))))
      (implies/equiv (equiv/symmetric equiv/identity)))
    ([x] implies/trans
      (implies/equiv equiv/identity)
      (implies/combine implies/reflexive
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/equiv
            (equiv/transitive
              (equiv/symmetric equiv/identity)
              (equiv/combine (equiv/symmetric (EQV x))
                (equiv/symmetric (EQV2 x))))))))
    <- set`not-member-add-size-implies-empty F!<FSP FSP+F=FS SZ FSP=E
    <- nat+set2set/U-inversion N+FS=>S F!<FSP FSP+F=FS SP N+FSP=>SP K N+F=K SP+K=S
    <- nat+set2set-preserves-fresh N+FSP=>SP F!<FSP N+F=K K!<SP
    <- set2efxmap/U-inversion S=>M K!<SP SP+K=S MP _ SP=>MP efx-id/ MP+K=M
    <- nat+set2set-unique N+FSP=>SP nat+set2set/0 nat`eq/ FSP=E SP=E
    <- set2efxmap-unique SP=>MP set2efxmap/0 SP=E efx`eq/ MP=E
    <- set2efxmap-preserves-fresh K!<SP SP=>MP K!<MP
    <- efxmap`eq-symmetric MP=E E=MP
    <- ty2perm-no-var T2PFF _ ([r][o] EQF r o) T2PF
    <- let-helper/L9/L EQF EQV
    <- ({x} efxmap2perm-respects-eq efxmap2perm/0 clsmap`eq/ predmap`eq/ cxt`eq/
      E=MP permission`eq/ (MP=>E x))
    <- ({x} fldmap2perm-equiv (FSP=>PiP x) fldmap2perm/0 predmap`eq/ object`eq/
      fldmap`eq/ FSP=E (EQV2 x)).

- : {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ nn/may A C))}
    let-helper/L9 z SZ BL CML
    ([x] fldmap2perm/U (FSP=>PiP x) (F!<FSP:set`not-member FSP F)
      (FSP+F=FS:set`add FSP F FS) (FML:fldmap`lookup FM F T)
      (T2PFF x)) consider-nn/may
    (N+FS=>S:nat+set2set N FS S) (S=>M:set2efxmap S efx/write M)
    %{=>}% _
    ([x] efxmap2perm/U (MP=>E x) N+F=K (BL x) CML FML T2PF
      consider-nn/may apply-efx/write K!<MP MP+K=M)
    ([x] implies/trans
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (implies/trans
          (implies/equiv (equiv/combine (EQV x) (EQV2 x)))
          (implies/equiv equiv/identity)))
      (implies/equiv (equiv/symmetric equiv/identity)))
    ([x] (implies/trans
        (implies/equiv equiv/identity)
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/equiv
            (equiv/transitive3
              (equiv/symmetric (EQV x))
              (equiv/symmetric equiv/identity)
              (equiv/combine equiv/reflexive (equiv/symmetric (EQV2 x))))))))
    <- set`not-member-add-size-implies-empty F!<FSP FSP+F=FS SZ FSP=E
    <- nat+set2set/U-inversion N+FS=>S F!<FSP FSP+F=FS SP N+FSP=>SP K N+F=K SP+K=S
    <- nat+set2set-preserves-fresh N+FSP=>SP F!<FSP N+F=K K!<SP
    <- set2efxmap/U-inversion S=>M K!<SP SP+K=S MP _ SP=>MP efx-id/ MP+K=M
    <- nat+set2set-unique N+FSP=>SP nat+set2set/0 nat`eq/ FSP=E SP=E
    <- set2efxmap-unique SP=>MP set2efxmap/0 SP=E efx`eq/ MP=E
    <- set2efxmap-preserves-fresh K!<SP SP=>MP K!<MP
    <- efxmap`eq-symmetric MP=E E=MP
    <- ty2perm-no-var T2PFF _ ([r][o] EQF r o) T2PF
    <- let-helper/L9/L EQF EQV
    <- ({x} efxmap2perm-respects-eq efxmap2perm/0 clsmap`eq/ predmap`eq/ cxt`eq/
      E=MP permission`eq/ (MP=>E x))
    <- ({x} fldmap2perm-equiv (FSP=>PiP x) fldmap2perm/0 predmap`eq/ object`eq/
      fldmap`eq/ FSP=E (EQV2 x)).

- : {BL:{x} cxt`lookup (B x) N (cxt-info/ x (ty/ nn/yes A C))}
    let-helper/L9 (s SN) SZ ([x] BL x) CML
    ([x] fldmap2perm/U (FSP=>PiP x)
      F!<FSP (FSP+F=FS:set`add FSP F FS) FML (T2PFF x))
    consider-nn/yes
    (N+FS=>S:nat+set2set N FS S)
    (S=>M:set2efxmap S efx/write M) %{=>}% _
    ([x] efxmap2perm/U (MP=>Pf2P x) N+F=K (BL x) CML FML T2PF
      consider-nn/yes apply-efx/write K!<MP MP+K=M)
    ([x] implies/trans4
      (implies/combine implies/duplicate implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive
        (implies/trans4
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/cond-inner
                (bimplies/reflexive)
                (bimplies/reflexive)
                (implies/equiv (equiv/symmetric equiv/identity))
                (implies/combine (implies/equiv (EQV x)) implies/reflexive))
              (implies/cond-distribute)
              (implies/equiv equiv/commute)))
          (implies/equiv equiv/associate)
          (implies/combine (IMPP x) implies/reflexive)
          (implies/equiv equiv/commute)))
      (implies/equiv equiv/associate))
    ([x] implies/trans
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive
        (implies/trans5
          (implies/combine
            (implies/cond-inner
              (bimplies/reflexive)
              (bimplies/reflexive)
              (implies/equiv equiv/reflexive)
              (implies/equiv (equiv/symmetric (EQV x))))
            (implies/trans (IMPP2 x) (implies/equiv equiv/commute)))
          (implies/equiv equiv/associate)
          (implies/combine implies/cond-factor implies/reflexive)
          (implies/combine
            (implies/cond-inner
              (bimplies/reflexive)
              (bimplies/reflexive)
              (implies/equiv equiv/identity)
              (implies/reflexive))
            (implies/nonlinear2empty))
          (implies/equiv equiv/identity))))
    <- ty2perm-no-var T2PFF _ ([r][o] EQF r o) T2PF
    <- let-helper/L9/L EQF EQV
    <- nat+set2set/U-inversion N+FS=>S F!<FSP FSP+F=FS SP N+FSP=>SP K N+F=K SP+K=S
    <- nat+set2set-preserves-fresh N+FSP=>SP F!<FSP N+F=K K!<SP
    <- set2efxmap/U-inversion S=>M K!<SP SP+K=S MP _ SP=>MP efx-id/ MP+K=M
    <- set`not-member-add-increases-size-converse SZ F!<FSP FSP+F=FS SZP
    <- let-helper/L9 SN SZP BL CML FSP=>PiP consider-nn/yes
      N+FSP=>SP SP=>MP _ MP=>Pf2P IMPP IMPP2
    <- set2efxmap-preserves-fresh K!<SP SP=>MP K!<MP.

- : let-helper/L9 (s SN) SZ ([x] BL x) CML
    ([x] fldmap2perm/U (FSP=>PiP x) F!<FSP FSP+F=FS FML (T2PFF x))
    consider-nn/may N+FS=>S S=>M %{=>}% _
    ([x] efxmap2perm/U (MP=>Pf2P x) N+F=K (BL x) CML FML T2PF
      consider-nn/may apply-efx/write K!<MP MP+K=M)
([x] implies/trans3
      (implies/cond-inner
        bimplies/reflexive
        bimplies/reflexive
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/combine (implies/equiv (EQV x)) implies/reflexive))
      (implies/cond-distribute)
      (implies/combine implies/reflexive (IMPP x)))
    ([x] implies/trans3
      (implies/combine (implies/reflexive) (IMPP2 x))
      (implies/cond-factor)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/identity)
        (implies/combine (implies/equiv (equiv/symmetric (EQV x))) implies/reflexive)))
    <- ty2perm-no-var T2PFF _ ([r][o] EQF r o) T2PF
    <- let-helper/L9/L EQF EQV
    <- nat+set2set/U-inversion N+FS=>S F!<FSP FSP+F=FS SP N+FSP=>SP K N+F=K SP+K=S
    <- nat+set2set-preserves-fresh N+FSP=>SP F!<FSP N+F=K K!<SP
    <- set2efxmap/U-inversion S=>M K!<SP SP+K=S MP _ SP=>MP efx-id/ MP+K=M
    <- set`not-member-add-increases-size-converse SZ F!<FSP FSP+F=FS SZP
    <- let-helper/L9 SN SZP BL CML FSP=>PiP consider-nn/may
      N+FSP=>SP SP=>MP _ MP=>Pf2P IMPP IMPP2
    <- set2efxmap-preserves-fresh K!<SP SP=>MP K!<MP.

%worlds (objvar) (let-helper/L9 _ _ _ _ _ _ _ _ _ _ _ _).
%total (SN) (let-helper/L9 SN _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L9*
  : forall* {CM} {PM} {FM} {B} {N} {NN} {A} {C} {FS} {Pf} {Pfn} {SN}
    forall {SZ: set`size FS (s SN)}
    {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {FM2P: {x} fldmap2perm PM x FM FS (Pf x)}
    {CN: consider-nn Pf NN ([x] Pfn x)}
    exists {Pf2} {S} {M}
    {N+FS=>S: nat+set2set N FS S}
    {S=>M: set2efxmap S efx/write M}
    {M2P: {x} efxmap2perm CM PM (B x) M (Pf2 x)}
    {IMP: {x} implies (Pfn x) (Pf2 x)}
    {IMP: {x} implies (Pf2 x) (Pfn x)}
    true.

- : let-helper/L9* SZ BL CML FS2P CN _ _ _ N+FS=>S S=>M M=>P IMP IMP2
    <- nat+set2set-total N+FS=>S
    <- set2efxmap-total S=>M
    <- let-helper/L9 _ SZ BL CML FS2P CN N+FS=>S S=>M _ M=>P IMP IMP2.

%worlds (objvar) (let-helper/L9* _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L9* _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L10
  : forall* {M} {N} {Mout} {Min}
    forall {P: efxmap-partition-on-index M N Mout Min}
    exists {Mout<=M: efxmap`leq Mout M} {Min<=M: efxmap`leq Min M}
    {M2out^M2in: efxmap`disjoint Mout Min}
    {M2outuM2in=M: efxmap`join Mout Min M}
    true.

- : let-helper/L10 (efxmap-partition-on-index/ _ _ P) L1 L2 D J
    <- efxmap`partition-implies-leq P L1 L2
    <- efxmap`partition-implies-disjoint-join P D J.

%worlds (objvar) (let-helper/L10 _ _ _ _ _).
%total { } (let-helper/L10 _ _ _ _ _).


%theorem let-helper/L11
  : forall* {M} {MF} {N} {SF}
    forall {M-N: efxmap-same-object M N}
    {M=>S: efxmap-map-fields M MF}
    {DM-MF: efxmap`domain MF SF}
    exists {S} {MP} {N+SF=>S: nat+set2set N SF S}
    {S=>M: set2efxmap S efx/write MP}
    {M<=MP: efxmap`leq M MP} % domain also same
    true.

%worlds (objvar) (let-helper/L11 _ _ _ _ _ _ _ _).
%trustme %total { } (let-helper/L11 _ _ _ _ _ _ _ _).


%theorem let-helper/L11*
  : forall* {M} {MF} {N} {SF} {S} {MP} {MS}
    forall {M-N: efxmap-same-object M N}
    {M=>S: efxmap-map-fields M MF}
    {DM-MF: efxmap`domain MF SF}
    {N+SF=>S: nat+set2set N SF S}
    {S=>M: set2efxmap S efx/write MP}
    {DM-M: efxmap`domain M MS}
    exists {M<=MP: efxmap`leq M MP} % domain also same
    {DM-MP=MS: efxmap`domain MP MS}
    true.

%worlds (objvar) (let-helper/L11* _ _ _ _ _ _ _ _).
%trustme %total { } (let-helper/L11* _ _ _ _ _ _ _ _).


% should go to efxmap-base.elf

%theorem let-helper/L12
  : forall* {M} {S} {M2}
    forall {M2<=M: efxmap`leq M2 M}
    {DM-M2=S: efxmap`domain M2 S}
    exists {M1} {M2P} {MP: efxmap`partition M S M1 M2P}
    {M2<=M2P: efxmap-vleq M2 M2P}
    true.

%worlds (objvar) (let-helper/L12 _ _ _ _ _ _).
%trustme %total { } (let-helper/L12 _ _ _ _ _ _).


%theorem let-helper/L13
  : forall* {M1} {M2} {M} {M1P} {M2P} {MP}
    forall {M1<=M1P: efxmap`leq M1 M1P}
    {M2<=M2P: efxmap`leq M2 M2P}
    {M1+M2=M: efxmap`join M1 M2 M}
    {M1P+M2P=MP: efxmap`join M1P M2P MP}
    exists {M<=MP: efxmap`leq M MP}
    true.

%worlds (objvar) (let-helper/L13 _ _ _ _ _).
%trustme %total {} (let-helper/L13 _ _ _ _ _).


%theorem let-helper/L14
  : forall* {M} {N} {M1} {M2}
    forall {P: efxmap-partition-on-index M N M1 M2}
    exists {S} {P: efxmap`partition M S M1 M2}
    true.

- : let-helper/L14 (efxmap-partition-on-index/ _ _ P) _ P.

%worlds (objvar) (let-helper/L14 _ _ _).
%total { } (let-helper/L14 _ _ _).


%theorem let-helper/L15
  : forall* {PM} {NN} {C} {PF}
    forall {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    exists {PF2} {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF2}
    {IMP: {x} implies (PF x) ((PF x) , (PF2 x))}
    true.

- : let-helper/L15
    (ty2perm/ PML nn2perm/yes annot2perm/unique) _
    (ty2perm/ PML nn2perm/yes annot2perm/borrow)
    ([x] implies/trans5
      (implies/combine implies/duplicate
        (implies/trans
          (implies/combine implies/reflexive implies/duplicate)
          (implies/equiv equiv/associate)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive
        (implies/equiv equiv/associate))
      (implies/equiv equiv/roll2)
      (implies/combine implies/reflexive
        (implies/combine implies/reflexive
          (implies/equiv
            (equiv/transitive
              (equiv/symmetric equiv/identity)
              (equiv/commute)))))).

- : let-helper/L15
    (ty2perm/ PML nn2perm/may annot2perm/unique) _
    (ty2perm/ PML nn2perm/may annot2perm/borrow)
    ([x] implies/trans
      (implies/cond-inner
        bimplies/reflexive
        bimplies/reflexive
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/trans4
          (implies/combine
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/duplicate))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive (implies/equiv equiv/roll2))
          (implies/equiv equiv/associate)))
      (implies/cond-distribute)).

%worlds (objvar) (let-helper/L15 _ _ _ _).
%total { } (let-helper/L15 _ _ _ _).


%theorem let-helper/L16
  : forall* {CM} {B:object -> cxt} {M} {S} {Q}
    forall {CM-B-XX: {x} clsmap-cxt-effects CM (B x) (effects/ M S Q)}
    exists {R} {DM: efxmap`domain M R}
    {CM-B-R: {x} clsmap-cxt-fldset CM (B x) R}
    {CM-B-Q: {x} clsmap-cxt-objset CM (B x) Q}
    true.

- : let-helper/L16
    ([x] clsmap-cxt-effects/ DM R^S (Q=>FS x)
      (R^FS) S^FS (CM-B-R x) _ (CM-B-Q x))
    _ DM CM-B-R CM-B-Q.

%worlds (objvar) (let-helper/L16 _ _ _ _ _).
%total { } (let-helper/L16 _ _ _ _ _).


%theorem let-helper/L17
  : forall* {CM} {B:object -> cxt} {M} {S} {Q} {OS} {SS} {N}
    forall {CM-B-XX: {x} clsmap-cxt-effects CM (B x) (effects/ M S Q)}
    {M=>OS: efxmap-map-objects M OS}
    {S=>SS: set-map-objects S SS}
    {MB: set`member OS N}
    exists {OUT-S: set`not-member SS N}
    {OUT-Q: set`not-member Q N}
    true.

%worlds (objvar) (let-helper/L17 _ _ _ _ _ _).
%trustme %total { } (let-helper/L17 _ _ _ _ _ _).


%theorem let-helper/L18
  : forall* {CM} {S} {OS} {Q} {N} {S2} {S3} {M3} {PM} {B} {Pi} {BP} {T}
    forall {S=>OS: set-map-objects S OS}
    {N!<OS: set`not-member OS N}
    {N!<Q: set`not-member Q N}
    {Q=>S2: objset2fldset CM B Q S2}
    {SuS2=S3: set`union S S2 S3}
    {S3=>M3: set2efxmap S3 efx/write M3}
    {M=>Pi: efxmap2perm CM PM B M3 Pi}
    {BF: cxt`fresh B N}
    {BU: {x} cxt`update B N (cxt-info/ x T) (BP x)}
    exists {BP+Q=>S2: {x} objset2fldset CM (BP x) Q S2}
    {M=>Pi: {x} efxmap2perm CM PM (BP x) M3 Pi}
    true.

%worlds (objvar) (let-helper/L18 _ _ _ _ _ _ _ _ _ _ _).
%trustme %total { } (let-helper/L18 _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L19
  : forall* {CM} {B} {BP} {N} {S} {T}
    forall {F: cxt`fresh B N}
    {U: {x} cxt`update B N (cxt-info/ x T) (BP x)}
    {CM-BP-XX: {x} clsmap-cxt-objset CM (BP x) S}
    {N!<S: set`not-member S N}
    exists {CM-B-XX: clsmap-cxt-objset CM B S}
    true.

%worlds (objvar) (let-helper/L19 _ _ _ _ _).
%trustme %total { } (let-helper/L19 _ _ _ _ _).


%theorem let-helper/L20
  : forall* {CM} {PM} {BP} {B} {Q} {PiQ} {N} {T}
    forall {Q=>PiQ: make-encumbered CM PM B Q PiQ}
    {F: cxt`fresh B N}
    {U: {x} cxt`update B N (cxt-info/ x T) (BP x)}
    {N!<Q: set`not-member Q N}
    exists {Q=>PiQ: {x} make-encumbered CM PM (BP x) Q PiQ}
    true.

%worlds (objvar) (let-helper/L20 _ _ _ _ _).
%trustme %total { } (let-helper/L20 _ _ _ _ _).


%theorem let-helper/L21
  : forall* {Mout} {Rout} {Oout} {N} {T} {BP} {CM} {PM} {B} {Pi}
    forall {DM: efxmap`domain Mout Rout}
    {Rout=>Oout: set-map-objects Rout Oout}
    {N!<Oout: set`not-member Oout N}
    {F: cxt`fresh B N}
    {U: {x} cxt`update B N (cxt-info/ x T) (BP x)}
    {M=>P: efxmap2perm CM PM B Mout Pi}
    exists {M=>P: {x} efxmap2perm CM PM (BP x) Mout Pi}
    true.

%worlds (objvar) (let-helper/L21 _ _ _ _ _ _ _).
%trustme %total { } (let-helper/L21 _ _ _ _ _ _ _).

%%% This is a very brave assumption. We need to modify "compatible"
%%%  to get this proved.

%theorem let-helper/L22
  : forall* {CM} {B} {OS} {FS} {S} {Q} {M} {Mout} {Min} {MFin} {MFinP} {N}
    forall {CB: compatible CM B (targets/unique OS FS) (effects/ M S Q)}
    {SUB: efxmap-partition-on-index M N Mout Min}
    {Min=>MFin: efxmap-map-fields Min MFin}
    {OS+MFin=>MFinP: set+map2map OS MFin MFinP}
    exists {MFinP^Mout: efxmap`disjoint MFinP Mout}
    true.

%worlds (objvar) (let-helper/L22 _ _ _ _ _).
%trustme %total {} (let-helper/L22 _ _ _ _ _).


%theorem let-helper/L23
  : forall* {M} {MP} {M1} {M2} {S} {S1} {S2}
    forall {DM: efxmap`domain M S}
    {DMP: efxmap`domain MP S}
    {M<=MP: efxmap`leq M MP}
    {M1^M2: efxmap`disjoint M1 M2}
    {M1+M2=M: efxmap`join M1 M2 M}
    {DM-M1=S1: efxmap`domain M1 S1}
    {DM-M2=S2: efxmap`domain M2 S2}
    exists {M1P} {M2P}
    {DM-M1P=S1: efxmap`domain M1P S1}
    {DM-M2P=S2: efxmap`domain M2P S2}
    {M1<=M1P: efxmap`leq M1 M1P}
    {M2<=M2P: efxmap`leq M2 M2P}
    {M1P^M2P: efxmap`disjoint M1P M2P}
    {M1P+M2P=MP: efxmap`join M1P M2P MP}
    true.

%worlds (objvar) (let-helper/L23 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {} (let-helper/L23 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L24
  : forall* {M} {MF} {N}
    forall {M=>MF: efxmap-map-fields M MF}
    {M-N: efxmap-same-object M N}
    exists {N+MF=M: nat+map2map N MF M}
    true.

%worlds (objvar) (let-helper/L24 _ _ _).
%trustme %total { } (let-helper/L24 _ _ _).


%theorem let-helper/L25
  : forall* {CM} {PM} {B} {M} {S} {MF} {Pi} {GF} {NN} {C} {BF} {N}
    forall {SN} {SZ: set`size S (s SN)}
    {CM-B-S: clsmap-cxt-unique-objset CM B NN C S}
    {S+MF=M: set+map2map S MF M}
    {M=>Pi: efxmap2perm CM PM B M Pi}
    {S=>G: {x} set2cond B x S (GF x)}
    {N!<B: cxt`fresh B N}
    {B+N=BF: {x} cxt`update B N (cxt-info/ x (ty/ NN annot/borrow C)) (BF x)}
    exists {MN} {Pf} {N+MF=MN: nat+map2map N MF MN}
    {M=>Pf: {x} efxmap2perm CM PM (BF x) MN (Pf x)}
    {IMP: {x} implies (combine (GF x) Pi)
          (combine (GF x)
            (combine (Pf x) (unitperm (encumbered (Pf x) Pi))))}
    true.

%{%
 we have two context: the old context which we can look up for the object
  O and get a type (ty/ NN1 A C), and the updated context which we can
  lookup the variable x and the type (ty/ NN A C).
  NN is always less than or equal to NN1.
%}%

%theorem let-helper/L25L1
  : forall* {CM} {PM} {B} {O} {N1} {MF} {M2} {Pi2} {BF}
    {NN1} {NN2} {A} {C} {N2}
    forall {L: cxt`lookup B N2 (cxt-info/ O (ty/ NN2 A C))}
    {N1!<B: cxt`fresh B N1}
    {B+N1=BF: {x} cxt`update B N1 (cxt-info/ x (ty/ NN1 A C)) (BF x)}
    {NN1<=NN2: nonnull`leq NN1 NN2}
    {N2+MF=M2: nat+map2map N2 MF M2}
    {M2=>Pi2: efxmap2perm CM PM B M2 Pi2}
    exists {M1} {Pi1} {N1+MF=M1: nat+map2map N1 MF M1}
    {M1=>Pi1: {x} efxmap2perm CM PM (BF x) M1 (Pi1 x)}
    {IMP: {x} implies
          (combine (unitperm (nonlinear (objequal x O))) Pi2)
          (combine (Pi1 x) (unitperm (encumbered (Pi1 x) Pi2)))}
    true.

- : let-helper/L25L1
    BL BF BU _ nat+map2map/0 efxmap2perm/0 _ _ nat+map2map/0
    ([_] efxmap2perm/0)
    ([_] implies/trans
      (implies/combine implies/nonlinear2empty implies/reflexive)
      (implies/combine implies/reflexive implies/gen-implication)).

%theorem let-helper/L25L1L1
  : forall* {F} {FP} {NN1} {NN2} {Pi2} {PF}
    forall {CNN: consider-nn ([x] unitperm (precise-exists x FP PF)) NN2 Pi2}
    {FP=F: nat`eq FP F} {NNP=NN: nonnull`leq NN1 NN2}
    exists {Pi1} {CNN: consider-nn ([x] unitperm (precise-exists x F PF)) NN1 Pi1}
    {IMP: {x} implies (Pi2 x) (combine (Pi1 x) (unitperm (encumbered (Pi1 x) (Pi2 x))))}
    true.

- : let-helper/L25L1L1 CNN nat`eq/
    (nonnull`leq/= nonnull`eq/) _ CNN
    ([_] implies/trans
      (implies/equiv (equiv/symmetric equiv/identity))
      (implies/combine implies/reflexive implies/self-implication)).

- : let-helper/L25L1L1 consider-nn/yes nat`eq/
    (nonnull`leq/<) _ consider-nn/may
    ([_] implies/trans
      (implies/equiv equiv/commute)
      (implies/combine implies/reflexive
        (implies/trans4
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine implies/gen-implication
            implies/self-implication)
          (implies/combine-merge-encumbered)
          (implies/equiv-encumbered
            (equiv/transitive equiv/commute equiv/identity)
            (equiv/reflexive))))).

%worlds (objvar) (let-helper/L25L1L1 _ _ _ _ _ _).
%total { } (let-helper/L25L1L1 _ _ _ _ _ _).


%theorem let-helper/L25L1L2
  : forall* {X} {PiF} {Pi} {PiF2}
    forall {O} {AP: apply-efx X (PiF O) Pi}
    {IMP: {x} implies (PiF x) (combine (PiF2 x) (unitperm (encumbered (PiF2 x) (PiF x))))}
    exists {PiP} {APX: {x} apply-efx X (PiF2 x) (PiP x)}
    {IMP: {x} implies
           (combine (unitperm (nonlinear (objequal x O))) Pi)
          (combine (PiP x) (unitperm (encumbered (PiP x) Pi)))}
    true.

- : {O: object}
    {PiF: object -> permission}
    {PiF2: object -> permission}
    {IMP: {x} implies (PiF x) (combine (PiF2 x) (unitperm (encumbered (PiF2 x) (PiF x))))}
    let-helper/L25L1L2 O apply-efx/read IMP
    _ ([_] apply-efx/read)
    ([x] implies/trans
      (implies/combine (implies/nonlinear bimplies/objequal-symmetric)
        (implies/trans3
          (implies/scale (IMP O))
          (implies/equiv equiv/distribute)
          (implies/combine implies/reflexive implies/scale-distribute-encumbered)))
      (implies/objequal
        ([y] (combine (scale half (PiF2 y))
               (unitperm
                 (encumbered
                   (scale half (PiF2 y))
                   (scale half (PiF O)))))))).

- : {IMP: {x} implies (PiF x) (combine (PiF2 x) (unitperm (encumbered (PiF2 x) (PiF x))))}
    let-helper/L25L1L2 O apply-efx/write IMP
    _ ([_] apply-efx/write)
    ([x] implies/trans
      (implies/combine (implies/nonlinear bimplies/objequal-symmetric) (IMP O))
      (implies/objequal
        ([y] (combine (PiF2 y) (unitperm (encumbered (PiF2 y) (PiF O))))))).

%worlds (objvar) (let-helper/L25L1L2 _ _ _ _ _ _).
%total { } (let-helper/L25L1L2 _ _ _ _ _ _).


%theorem let-helper/L25L1L3
  : forall* {X} {OP:object} {O} {Pi}
    forall {PiF:object -> permission} {AP: apply-efx X (PiF OP) Pi}
    {O=OP: object`eq O OP}
    exists {AP: apply-efx X (PiF O) Pi}
    true.

- : let-helper/L25L1L3 _ AP object`eq/ AP.

%worlds (objvar) (let-helper/L25L1L3 _ _ _ _).
%total { } (let-helper/L25L1L3 _ _ _ _).

- : {B+N=BF: {x} cxt`update B N1 (cxt-info/ x (ty/ NN1 A C)) (BF x)}
    let-helper/L25L1
    (BL:cxt`lookup B N2 (cxt-info/ O2 (ty/ NN2 A C)))
    (N1!<B:cxt`fresh B N1) B+N=BF NN1<=NN2
    (nat+map2map/U (N2+MFP=M2P:nat+map2map N2 MFP M2P)
      (N2+F=K2:pair2nat (pair/ N2 F) K2)
      F!<MFP MFP+F+X=MF (M2P+K2+X=M2:efxmap`update M2P K2 Xx M2))
    M2=>Pi2 %{=>}% _ _
    (nat+map2map/U N1+MFP=M1P N1+F=K1 F!<MFP MFP+F+X=MF
      M1P+K1+X=M1)
    ([x] efxmap2perm/U (M1P=>Pi12 x) N1+F=K1 (BFL x) CML
      FML T2PF CNN (APX x) K1!<M1P M1P+K1+X=M1)
    ([x] implies/trans6
      (implies/combine implies/duplicate
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/trans
            (implies/combine
              (implies/equiv (equiv/symmetric (Pi21+Pi22<=>Pi2)))
              (implies/trans implies/self-implication
                (implies/equiv-encumbered
                  (equiv/symmetric (Pi21+Pi22<=>Pi2)) equiv/reflexive)))
            (implies/equiv (equiv/symmetric equiv/associate)))))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/equiv
        (equiv/transitive
          (equiv/combine equiv/reflexive equiv/roll2)
          (equiv/associate)))
      (implies/combine (IMP2 x)
        (implies/trans
          (implies/equiv equiv/associate)
          (implies/combine (IMPP x) implies/reflexive)))
      (implies/equiv
        (equiv/transitive5
          (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive equiv/roll2)
          (equiv/associate)
          (equiv/combine equiv/reflexive equiv/associate)))
      (implies/combine implies/reflexive
        (implies/trans
          (implies/combine (implies/combine-merge-encumbered) implies/reflexive)
          (implies/chain-implication))))
    <- nat+map2map-preserves-fresh N2+MFP=M2P F!<MFP N2+F=K2 K2!<M2P
    <- efxmap2perm/U-inversion M2=>Pi2 K2!<M2P M2P+K2+X=M2 %{=>}%
      N2P FP N2P+FP=K2 O2P NNP AP CP BL2 FM CML2 T2 FML2 PF T2PF
      PiF CNN2 Pi21 APX2 Pi22 M2P=>Pi22
      (Pi21+Pi22<=>Pi2:equiv (Pi21 , Pi22) Pi2)
    <- let-helper/L25L1 BL N1!<B B+N=BF NN1<=NN2 N2+MFP=M2P
      M2P=>Pi22 %{=>}% M1P Pi12 N1+MFP=M1P ([x] M1P=>Pi12 x) ([x] IMPP x)
    <- pair2nat-total (N1+F=K1:pair2nat (pair/ N1 F) K1)
    <- efxmap`update-total (M1P+K1+X=M1:efxmap`update M1P K1 Xx M1)
    <- nat+map2map-preserves-fresh N1+MFP=M1P F!<MFP N1+F=K1 K1!<M1P
    <- ({x} cxt`update-implies-lookup (B+N=BF x) (BFL x))
    <- nat2pair-unique N2+F=K2 N2P+FP=K2 nat`eq/ N2+F=N2P+FP
    <- pair-eq-implies-eq N2+F=N2P+FP N2=N2P F=FP
    <- cxt`lookup-unique BL BL2 cxt`eq/ N2=N2P CIE
    <- cxt-info-eq-inversion CIE O2=O2P TE
    <- ty-eq-inversion TE NN=NNP A=AP C=CP
    <- nat`eq-symmetric C=CP CP=C
    <- nat`eq-symmetric F=FP FP=F
    <- nonnull`eq-symmetric NN=NNP NNP=NN
    <- nonnull`leq-respects-eq NN1<=NN2 nonnull`eq/ NN=NNP NN1<=NNP
    <- clsmap`lookup-respects-eq CML2 clsmap`eq/ CP=C fldmap`eq/ CML
    <- fldmap`lookup-respects-eq FML2 fldmap`eq/ FP=F ty`eq/ FML
    <- let-helper/L25L1L1 CNN2 FP=F NN1<=NNP _ CNN IMP3
    <- let-helper/L25L1L3 PiF APX2 O2=O2P APX2P
    <- let-helper/L25L1L2 _ APX2P IMP3 _ ([x] APX x) IMP2.

%worlds (objvar) (let-helper/L25L1 _ _ _ _ _ _ _ _ _ _ _).
%total (M) (let-helper/L25L1 _ _ _ _ M _ _ _ _ _ _).


%theorem let-helper/L25L2
  : forall* {O1} {O2} {Pi2} {Pi2P}
    forall {O1=O2: {x} object`eq (O1 x) O2}
    {IMP2:{x:gterm objectk}
               implies (combine (unitperm (nonlinear (objequal x O2))) Pi2)
                  (combine (Pi2P x) (unitperm (encumbered (Pi2P x) Pi2)))}
    exists {IMP2:{x:gterm objectk}
                  implies (combine (unitperm (nonlinear (objequal x (O1 x)))) Pi2)
                  (combine (Pi2P x) (unitperm (encumbered (Pi2P x) Pi2)))}
    true.

- : let-helper/L25L2 ([_] object`eq/) IMP IMP.

%worlds (objvar) (let-helper/L25L2 _ _ _).
%total { } (let-helper/L25L2 _ _ _).


%theorem let-helper/L25L3
  : forall* {B} {N} {OF:object -> object} {TF}
    forall {BL: {x} cxt`lookup B N (cxt-info/ (OF x) TF)}
    exists {O} {T} {BL: cxt`lookup B N (cxt-info/ O T)}
    {EQ: {x} object`eq (OF x) O}
    true.

- : let-helper/L25L3
    ([_] cxt`lookup/= N1=N2) _ _ (cxt`lookup/= N1=N2) ([_] object`eq/).

- : let-helper/L25L3
    ([x] cxt`lookup/> (BL x) P) _ _ (cxt`lookup/> BLP P) EQF
    <- let-helper/L25L3 BL _ _ BLP EQF.

%worlds (objvar) (let-helper/L25L3 _ _ _ _ _).
%total (L) (let-helper/L25L3 L _ _ _ _).


- : let-helper/L25 z SZ CM-B-S
    (set+map2map/U SP+MF=MP1 NP+MF=>MP2 NP!<SP (SP+NP=S:set`add SP NP S)
      (MP1+MP2=M:efxmap`join MP1 MP2 M))
    M=>Pi ([x] S=>GF x) BF BU %{=>}% _ _
    (N+MF=>MN:nat+map2map N MF MN) MN=>Pf
    ([x] implies/trans9
      (implies/combine (GIMP1 x) implies/reflexive)
      (implies/equiv equiv/commute)
      (implies/combine implies/reflexive implies/cond-gen-inner)
      (implies/cond-push)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/equiv equiv/commute)
              (IMPP2 x))
            (implies/reflexive)))
        (implies/trans3
          (implies/combine implies/reflexive
            (implies/trans5
              (implies/equiv equiv/commute)
              (implies/combine (GFP=>F x) implies/nonlinear2empty)
              (implies/equiv equiv/identity)
              (implies/duplicate)
              (implies/combine implies/reflexive (F=>GFP x))))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans3
              (implies/equiv equiv/commute)
              (implies/combine
                (implies/contradiction)
                (implies/reflexive))
              (IMPP2 x))
            (implies/reflexive))))
      (implies/cond-distribute)
      (implies/combine implies/cond-equal implies/reflexive)
      (implies/equiv equiv/commute)
      (implies/combine (GIMP2 x) implies/reflexive))
    <- set`not-member-add-size-implies-empty NP!<SP SP+NP=S SZ SP=0
    <- ({x} set2cond/U-inversion (S=>GF x) NP!<SP SP+NP=S (GFP x) (SP=>GFP x)
      (OF x) _ (BL x) (GIMP1 x) (GIMP2 x))
    <- let-helper/L25L3 BL _ _ BL1 ([x] OF=O2 x)
    <- clsmap-cxt-unique-objset/U-inversion CM-B-S NP!<SP SP+NP=S
      CM-B-SP O1 NNP BLP NN<=NNP
    <- set+map2map-unique SP+MF=MP1 set+map2map/0 SP=0 efxmap`eq/ MP1=0
    <- efxmap`join-unique MP1+MP2=M efxmap`join/L MP1=0 efxmap`eq/ M=MP2
    <- efxmap2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/ cxt`eq/ M=MP2
      permission`eq/ MP2=>Pi
    <- let-helper/L25L1 BLP BF BU NN<=NNP NP+MF=>MP2
      MP2=>Pi _ _ N+MF=>MN MN=>Pf IMPP
    <- cxt`lookup-unique BL1 BLP cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE O2=O1 TE
    <- ({x:object} object`eq-transitive (OF=O2 x) O2=O1 (OF=O1 x))
    <- let-helper/L25L2 OF=O1 IMPP IMPP2
    <- ({x} set2cond-implies (SP=>GFP x) set2cond/0 object`eq/ SP=0 (GFP=>F x) (F=>GFP x)).

- : {S=>GF: {x} set2cond B x S (GF x)}
    let-helper/L25 _ SZ S-NN-C
    (set+map2map/U SP+MF=M1 N1+MF=M2 (N1!<SP:set`not-member SP Nx1)
      SP+N1=S (M1+M2=M:efxmap`join M1 M2 M)) M=>Pi
      ([x] S=>GF x) BF ([x] BU x)
     %{=>}% MN Pf (N+MF=MN:nat+map2map Nx MF MN) ([x] MN=>Pf x)
    ([x] implies/trans7
      (implies/combine (GF=>EQ+GFP x) (implies/equiv (Pi<=>Pi1+Pi2)))
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans7
          (implies/combine implies/reflexive (implies/equiv equiv/identity))
          (implies/equiv
            (equiv/transitive
              (equiv/combine equiv/reflexive equiv/commute)
              (equiv/associate)))
          (implies/combine (IMP2P x)
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/self-implication)
                  (implies/equiv-encumbered
                    (Pi<=>Pi1+Pi2)
                    (equiv/reflexive))
                  (implies/combine-assoc-encumbered)))
              (implies/linear-modus-ponens)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive implies/chain-implication)
          (implies/combine (implies/equiv (Pi2P<=>Pf x))
            (implies/equiv-encumbered (Pi2P<=>Pf x) equiv/reflexive))
          (implies/equiv
            (equiv/transitive (equiv/symmetric equiv/identity) (equiv/commute))))
        (implies/trans4
          (implies/combine
            (implies/nonlinear2empty)
            (implies/trans3
              (implies/equiv equiv/commute)
              (implies/equiv equiv/associate)
              (implies/combine
                (GFP+Pi1=>Pf+Pf-Pi1 x)
                (implies/reflexive))))
          (implies/equiv
            (equiv/transitive equiv/commute equiv/identity))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine implies/reflexive
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/transitive
                          (Pi<=>Pi1+Pi2)
                          (equiv/commute))
                        (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive implies/chain-implication)))))
      (implies/cond-distribute)
      (implies/combine
        (EQ+GFP=>GF x) (implies/cond-equal)))
    <- ({x} set2cond/U-inversion (S=>GF x) N1!<SP SP+N1=S (GFP x)
         (SP=>GFP x) (OF x) T (BL1 x)
         (GF=>EQ+GFP x) (EQ+GFP=>GF x))
    <- let-helper/L25L3 BL1 _ _ BL1P ([x] OF=O1 x)
    <- clsmap-cxt-unique-objset/U-inversion S-NN-C N1!<SP SP+N1=S
      SP-NN-C O2 NNP BL2 NN<=NNP
    <- cxt`lookup-unique BL1P BL2 cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE O1=O2 TE
    <- ({x} object`eq-transitive (OF=O1 x) O1=O2 (OF=O2 x))
    <- not-member-nat+map2map-implies-disjoint SP+MF=M1 N1+MF=M2 N1!<SP M1^M2
    <- efxmap`disjoint-join-implies-equiv M1^M2 M1+M2=M M=>Pi
      Pi1 Pi2 M1=>Pi1 M2=>Pi2 (Pi<=>Pi1+Pi2:equiv Pi (combine Pi1 Pi2))
    <- set`not-member-add-increases-size-converse SZ N1!<SP SP+N1=S SZP
    <- let-helper/L25 _ SZP SP-NN-C SP+MF=M1 M1=>Pi1 ([x] SP=>GFP x)
      BF ([x] BU x) _ _ N+MF=MN ([x] MN=>Pf x) (GFP+Pi1=>Pf+Pf-Pi1)
    <- let-helper/L25L1 BL2 BF ([x] BU x) NN<=NNP N1+MF=M2 M2=>Pi2
      M2P Pi2P N+MF=M2P ([x] BF+M2P=>Pi2P x) ([x] IMP2 x)
    <- nat+map2map-unique N+MF=M2P N+MF=MN nat`eq/ efxmap`eq/ M2P=MN
    <- ({x} efxmap2perm-equiv (BF+M2P=>Pi2P x) (MN=>Pf x) clsmap`eq/
         predmap`eq/ cxt`eq/ M2P=MN (Pi2P<=>Pf x))
    <- let-helper/L25L2 OF=O2 IMP2 IMP2P.

%worlds (objvar) (let-helper/L25 _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N) (let-helper/L25 N _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L26
  : forall* {CM} {B} {FS} {M} {OS} {S} {Q} {Mout} {Min} {MFin} {N} {Min2} {Min1} {X}
    forall {CB: compatible CM B (targets/unique OS FS) (effects/ M S Q)}
    {M|N=Mout+Min: efxmap-partition-on-index M N Mout Min}
    {Min=>MFin: efxmap-map-fields Min MFin}
    {S+MFin=Min2: set+map2map OS MFin Min2}
    {FS+X=MF: set2efxmap FS X Min1}
    exists {Min2^Mout: efxmap`disjoint Min2 Mout}
    {Min1^Mout: efxmap`disjoint Min1 Mout}
    true.

%worlds (objvar) (let-helper/L26 _ _ _ _ _ _ _).
%trustme %total {} (let-helper/L26 _ _ _ _ _ _ _).


%theorem let-helper/L27
  : forall* {CM} {PM} {B} {M} {M2} {MF} {S} {N} {MP} {NN} {C} {BF} {GF} {Pi}
    forall {SN} {SZ: set`size S (s SN)}
    {M=>MF: efxmap-map-fields M2 MF}
    {M-N: efxmap-same-object M2 N}
    {CM-B-S: clsmap-cxt-unique-objset CM B NN C S}
    {S+MF=>M: set+map2map S MF M}
    {M=<=MP: efxmap-vleq M MP}
    {MP=>Pi: efxmap2perm CM PM B MP Pi}
    {S=>G: {x} set2cond B x S (GF x)}
    {N!<B: cxt`fresh B N}
    {B+N=BF: {x} cxt`update B N (cxt-info/ x (ty/ NN annot/borrow C)) (BF x)}
    exists {Pf} {N+MF=M2: nat+map2map N MF M2}
    {M2=>Pf: {x} efxmap2perm CM PM (BF x) M2 (Pf x)}
    {IMP: {x} implies (combine (GF x) Pi)
          (combine (GF x)
            (combine (Pf x) (unitperm (encumbered (Pf x) Pi))))}
    true.

- : let-helper/L27 _ SZ M2=>MF M2-N CM-B-S S+MF=M M=<=MP MP=>PiP
    ([x] S=>GF x) N!<B ([x] B+N=BF x) %{=>}% _ N+MF=M2 ([x] M2=>Pf x)
    ([x] implies/trans5
      (implies/combine implies/reflexive (implies/equiv PiP<=>Pi+Pi3))
      (implies/equiv equiv/associate)
      (implies/combine (IMP1 x)
        (implies/trans3
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/reflexive)
            (implies/trans3
              (implies/self-implication)
              (implies/equiv-encumbered
                (equiv/transitive (PiP<=>Pi+Pi3) equiv/commute)
                (equiv/reflexive))
              (implies/combine-assoc-encumbered)))
          (implies/linear-modus-ponens)))
      (implies/equiv
        (equiv/transitive
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))
      (implies/combine implies/reflexive
        (implies/combine implies/reflexive
          (implies/chain-implication))))
    <- let-helper/L24 M2=>MF M2-N N+MF=M2
    <- efxmap-vleq-implies-leq M=<=MP M<=MP
    <- efxmap2perm-respects-geq MP=>PiP M<=MP Pi Pi3 M=>Pi PiP<=>Pi+Pi3
    <- let-helper/L25 _ SZ CM-B-S S+MF=M M=>Pi ([x] S=>GF x) N!<B
      ([x] B+N=BF x) MN Pf N+MF=MN ([x] MN=>Pf x) ([x] IMP1 x)
    <- nat+map2map-unique N+MF=MN N+MF=M2 nat`eq/ efxmap`eq/ MN=M2
    <- ({x} efxmap2perm-respects-eq (MN=>Pf x) clsmap`eq/ predmap`eq/ cxt`eq/ MN=M2
      permission`eq/ (M2=>Pf x)).

%worlds (objvar) (let-helper/L27 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L27 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

%{%

This format records properties about three permissions:
  1). the permission for "x"
  2). the permission for where "x" come from
  3). the rest of permission after taking the permissions for
     checking e2.

I think for 1), it should always be the same.

%}%

let-output-format : clsmap -> predmap -> cxt ->
   nat -> reftype -> effects -> effects -> expr-output -> type.

let-output-format/simple/unique
  : ({x} cxt`update B N (cxt-info/ x (ty/ NN annot/borrow C)) (BP x))
    -> ty2perm PM (ty/ NN annot/unique C) ([x] Pf x)
    -> ({x} effects2input CM PM (BP x) (effects/ M2 S2 Q2) (Pi2 x))
    -> efxmap`domain M2out S2out
    -> efxmap`partition M2 S2out M2in M2out
    -> efxmap`partition M S2out M1 M2out
    -> ({x} efxmap2perm CM PM (BP x) M2in (Pxf x))
    -> ({x} implies (Pxf x) (Pxf2 x))
    -> efxmap2perm CM PM B M1 Pi3
    -> let-output-format CM PM B N (reftype/ NN C unique-target)
      (effects/ M _ _) (effects/ M2 S2 Q2)
      (output/exists [x]
        (output/expr x
          (combine (Pi2 x)
            (combine (unitperm (encumbered (Pxf2 x) (Pf x))) Pi3)))).

let-output-format/unique/0f
  : ({x} cxt`update B N (cxt-info/ x (ty/ NN annot/borrow C)) (BP x))
    -> ({x} effects2input CM PM (BP x) (effects/ M2 S2 Q2) (Pi2 x))
    -> ({x} set2cond B x OS (PiG x))
    -> efxmap-partition-on-index M2 N M2out M2in
    -> efxmap-split M M1 M2outk
    -> efxmap-split M2outk Mk1 M2out
    -> ({x} efxmap2perm CM PM (BP x) M2in (Pxf x))
    -> efxmap2perm CM PM B Mk1 Pf
    -> efxmap2perm CM PM B M1 Pi3
    -> let-output-format CM PM B N (reftype/ NN C (targets/unique OS set/0))
      (effects/ M _ _) (effects/ M2 S2 Q2)
      (output/exists [x]
        (output/expr x
          (combine (PiG x)
            (combine (Pi2 x)
              (combine (unitperm (encumbered (Pxf x) Pf)) Pi3))))).

let-output-format/unique/+f
  : ({x} cxt`update B N (cxt-info/ x (ty/ NN annot/borrow C)) (BP x))
    -> ty2perm PM (ty/ NN annot/unique C) ([x] PF x)
    -> ({x} effects2input CM PM (BP x) (effects/ M2 S2 Q2) (Pi2 x))
    -> ({x} set2cond B x OS (PiG x))
    -> efxmap-partition-on-index M2 N M2out M2in
    -> efxmap-split M MP Mk2
    -> efxmap-split MP M1 M12
    -> efxmap-split M12 Mk1 M2out
    -> ({x} efxmap2perm CM PM (BP x) M2in (Pxf x))
    -> efxmap2perm CM PM B Mk1 Pf1
    -> efxmap2perm CM PM B Mk2 Pf2
    -> efxmap2perm CM PM B M1 Pi3
    -> let-output-format CM PM B N (reftype/ NN C (targets/unique OS FS))
      (effects/ M _ _) (effects/ M2 S2 Q2)
      (output/exists [x]
        (output/exists [v]
          (output/expr x
            (combine (PiG x)
              (combine (Pi2 x)
                (combine
                  (unitperm
                    (encumbered (Pxf x)
                      (combine Pf1 (PF v))))
                  (combine (unitperm (encumbered (PF v) Pf2)) Pi3))))))).


%% ----------------------------------------------------
%% Main Theorems
%% ----------------------------------------------------

%theorem let-helper-before/unique/F
  : forall* {CM} {PM} {B} {Q} {Out0} {OS} {XX2} {N} {NN} {C} {XXV}
    forall {F:void}
    exists {PiQ} {Out1} {Out2} {XX2A}
    {Q=>PiQ: make-encumbered CM PM B Q PiQ}
    {EA: envadd PiQ Out0 Out1}
    {XX2<c=XX2A: effects-leq-no-consume XX2 XX2A}
    {FMT: let-output-format CM PM B N (reftype/ NN C (targets/unique OS set/0))
          XXV XX2A Out2}
    {TRANS: transform Out1 Out2}
    true.

%worlds (objvar) (let-helper-before/unique/F _ _ _ _ _ _ _ _ _ _).
%total {} (let-helper-before/unique/F _ _ _ _ _ _ _ _ _ _).


%theorem let-helper-before/unique
  : forall* {CM} {PM} {B} {XX1} {XX2} {XX} {XX0} {Q} {XX2P}
    {NN} {C} {Out0} {N} {BP} {XXV} {FM} {OS} {Z}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-OS: clsmap-cxt-unique-objset CM B NN C OS}
    {BF: cxt`fresh B N}
    {BU: {x} cxt`update B N (cxt-info/ x (ty/ NN annot/borrow C)) (BP x)}
    {CML: clsmap`lookup CM C FM} % not sure whether we need this!
    {CM-B-XX2: {x} clsmap-cxt-effects CM (BP x) XX2}
    {CM-B-XX2P: clsmap-cxt-effects CM B XX2P}
    {CM-B-XXV: clsmap-cxt-effects CM B XXV}
    {SUB: subst-effects CM B (targets/unique OS set/0) N XX2 XX2P}
    {XX1+XX2P=XX: effects`join XX1 XX2P XX}
    {XX<=XXV: effects-leq-no-consume XX XXV}
    {TC: transfer-consume CM B XXV XX1 XX0 Q}
    {SZ-OS: set`size OS (s Z)}
    {XX0=>Piin: effects2output CM PM B
                (reftype/ NN C (targets/unique OS set/0)) XX0 Out0}
    exists {PiQ} {Out1} {Out2} {XX2A}
    {Q=>PiQ: make-encumbered CM PM B Q PiQ}
    {EA: envadd PiQ Out0 Out1}
    {XX2<c=XX2A: effects-leq-no-consume XX2 XX2A}
    {FMT: let-output-format CM PM B N (reftype/ NN C (targets/unique OS set/0))
          XXV XX2A Out2}
    {TRANS: transform Out1 Out2}
    true.

- : let-helper-before/unique CM-CM CM2PM CM-B-OS N!<B ([x] B+N=BF x)
    CML ([x] CM-BP-XX2 x) CM-B-XX2P CM-B-XXV
    (subst-effects/unique/1 CB
      (S2=>R2:set-map-objects S2 R2) _ _ N!<R2 N!<Q2 _)
    XX1+XX2P=XX (effects-leq-no-consume/ (M<=MP: efxmap`leq M MP))
    (XXV+XX1=>XX0+QP: transfer-consume CM B _ _ _ QP)
    SZ (effects2output/simple _ _ simple-targets/unique _ _)
    %{=>}% _ _ _ _ K1 K2 K3 K4 K5
    <- set`size-unique set`size/0 SZ set`eq/ EQ
    <- nat`eq-contradiction EQ F
    <- let-helper-before/unique/F F _ _ _ _ K1 K2 K3 K4 K5.

- : let-helper-before/unique CM-CM CM2PM _ N!<B ([x] B+N=BF x)
    CML ([x] CM-BP-XX2 x) CM-B-XX2P CM-B-XXV
    (subst-effects/unique/1 CB
      (S2=>R2:set-map-objects S2 R2) _ _ N!<R2 N!<Q2 _)
    XX1+XX2P=XX (effects-leq-no-consume/ (M<=MP: efxmap`leq M MP))
    (XXV+XX1=>XX0+QP: transfer-consume CM B _ _ _ QP)
    _ (effects2output/unique/+f T2PF _ _ _ _ _ _ _ SZ)
    %{=>}% _ _ _ _ K1 K2 K3 K4 K5
    <- set`size-unique set`size/0 SZ set`eq/ EQ
    <- nat`eq-contradiction EQ F
    <- let-helper-before/unique/F F _ _ _ _ K1 K2 K3 K4 K5.

- : let-helper-before/unique CM-CM CM2PM CM-B-OS N!<B ([x] B+N=BF x)
    CML ([x] CM-BP-XX2 x) CM-B-XX2P CM-B-XXV
    (subst-effects/unique/1 CB
      (S2=>R2:set-map-objects S2 R2) _ _ N!<R2 N!<Q2
      (subst-efxmap/ M2|N=M2out+M2in M2in=>MF2in
        (S+MF2in=>Mk1:set+map2map OS MF2in Mk1) _
         FS+X=>Mk2 (Mk1+Mk2=Mk3:efxmap`join Mk1 Mk2 Mk3) Mk3+M2out=M2outk))
    XX1+XX2P=XX (effects-leq-no-consume/ (M<=MP: efxmap`leq M MP))
    (XXV+XX1=>XX0+QP: transfer-consume CM B _ _ _ QP) _
    (effects2output/unique/0f T2PF
      (M0=>Pi0: efxmap2perm CM PM B M0 Pi0) OS=>PiG
      (B=>PiB: cxt2perm CM PM B PiB) set`size/0 SZ-OS=SN)
    %{=>}% _ _ _ _ QP=>PiQ2 (envadd/exists [x] envadd/expr)
    (effects-leq-no-consume/ (M2<=M2P:efxmap`leq M2 M2P))
    (let-output-format/unique/0f
      ([x] B+N=BF x)
      ([x] effects2input/
        (cxt2perm/U B=>PiB N!<B (B+N=BF x) T2PF)
        (BP+Q2=>PiQ2 x) (BP+Q2=>FS3 x) S2uFS3=S3 S3=>M3
        (BP+M3=>Pi3 x) (M2P=>Pi2P x))
      OS=>PiG
      M2P|N=M2outP+M2in MP=>M1+M2outkP
      (efxmap-split/ Mk1P^M2outP Mk1P+M2outP=M2outkP)
      ([x] M2in=>Pif x) Mk1P=>Pik1P M1=>Pi1)
    (transform/inside [x]
      (transform/implies
        (implies/trans6
          (implies/combine implies/reflexive % PiQ2
            (implies/combine implies/reflexive % PiB
              (implies/combine implies/reflexive % PF
                (implies/combine implies/reflexive % PiG
                  (implies/trans3
                    (implies/equiv (Pi0<=>PiP+Pi3))
                    (implies/combine
                      (implies/trans
                        (implies/equiv (PiP<=>Pi1+Pi2outkP))
                        (implies/combine
                          (implies/reflexive)
                          (implies/equiv (Pi2outkP<=>Pik1P+Pi2outP))))
                      (implies/reflexive))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/symmetric equiv/associate)
                        (equiv/combine
                          (equiv/reflexive)
                          (equiv/transitive
                            (equiv/symmetric equiv/associate)
                            (equiv/combine equiv/reflexive equiv/commute))))))))))
          (implies/equiv
            (equiv/transitive3
              (equiv/roll2)
              (equiv/combine
                (equiv/reflexive) (equiv/roll2))
              (equiv/associate)))
          (implies/combine
            (implies/reflexive)
            (implies/trans
              (implies/combine implies/reflexive
                (implies/equiv equiv/roll4))
              (implies/equiv equiv/associate)))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/combine (implies/equiv equiv/commute)
              (implies/reflexive))
            (implies/trans6
              (implies/combine implies/reflexive
                (implies/equiv equiv/roll2))
              (implies/equiv equiv/associate)
              (implies/combine
                (IMPP x)
                (implies/reflexive))
              (implies/equiv
                (equiv/transitive
                  (equiv/commute)
                  (equiv/symmetric equiv/associate)))
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/combine implies/reflexive
                    (implies/equiv equiv/roll2))
                  (implies/equiv equiv/associate)
                  (implies/combine
                    (implies/equiv (Pi2outP+Pif<=>Pi2P x))
                    (implies/reflexive))))
              (implies/equiv equiv/roll2)))
          (implies/equiv
            (equiv/transitive4
              (equiv/associate)
              (equiv/combine equiv/reflexive
                (equiv/roll2))
              (equiv/roll2)
              (equiv/combine equiv/reflexive
                (equiv/combine equiv/reflexive
                  (equiv/commute))))))))
    <- let-helper/L3 CM-B-XXV XX1+XX2P=XX M<=MP XXV+XX1=>XX0+QP %{=>}%
      S3 FS3 M3 QP=>FS3 S2P^FS3 S2uFS3=S3 S3=>M3
      (MP^M3:efxmap`disjoint MP M3) (MP+M3=M0:efxmap`join MP M3 M0)
      (QP=Q2P:set`eq QP Q2P) (S0=S1:set`eq S0 S1) (Q0=Q1:set`eq Q0 Q1)
    <- efxmap`disjoint-join-implies-equiv MP^M3 MP+M3=M0 M0=>Pi0 PiP Pi3
      MP=>PiP M3=>Pi3 Pi0<=>PiP+Pi3
    <- objset2fldset-respects-eq QP=>FS3 clsmap`eq/ cxt`eq/ QP=Q2P set`eq/ Q2=>FS3
    <- set2efxmap-unique FS+X=>Mk2 set2efxmap/0 set`eq/ efx`eq/ Mk2=0
    <- efxmap`join-unique Mk1+Mk2=Mk3 efxmap`join/R efxmap`eq/ Mk2=0 Mk3=Mk1
    <- let-helper/L6 XX1+XX2P=XX (M2outk<=M:efxmap`leq M2outk M)
    <- let-helper/L18 S2=>R2 N!<R2 N!<Q2 Q2=>FS3 S2uFS3=S3
      S3=>M3 M3=>Pi3 N!<B ([x] B+N=BF x) ([x] BP+Q2=>FS3 x) ([x] BP+M3=>Pi3 x)
    <- efxmap`leq-transitive M2outk<=M M<=MP M2outk<=MP
    <- efxmap`domain-total DM-M2outk=R2outk
    <- let-helper/L12 M2outk<=MP DM-M2outk=R2outk _ _
      (MP|R2outk=M1+M2outkP:efxmap`partition MP R2outk M1 M2outkP)
      M2outk=<=M2outkP
    <- let-helper/L16 ([x] CM-BP-XX2 x) _
      DM-M2=R2 ([x] CM-BP-R2 x) ([x] CM-BP-Q2 x)
    <- let-helper/L19 N!<B ([x] B+N=BF x) CM-BP-Q2 N!<Q2 CM-B-Q2
    <- make-encumbered-total CM-CM CM2PM CM-B-Q2 _ Q2=>PiQ2
    <- let-helper/L20 Q2=>PiQ2 N!<B ([x] B+N=BF x)
      N!<Q2 ([x] BP+Q2=>PiQ2 x)
    <- set`eq-symmetric QP=Q2P Q2=QP
    <- make-encumbered-respects-eq Q2=>PiQ2 clsmap`eq/ predmap`eq/ cxt`eq/
      Q2=QP permission`eq/ (QP=>PiQ2:make-encumbered CM PM B QP PiQ2)
    <- let-helper/L10 M2|N=M2out+M2in M2out<=M2 M2in<=M2 M2out^M2in M2out+M2in=M2
    <- efxmap`domain-total DM-M2in=R2in
    <- efxmap`domain-preserves-leq* M2in<=M2 DM-M2in=R2in DM-M2=R2 R2in<=R2
    <- ({x} clsmap-cxt-fldset-respects-geq (CM-BP-R2 x) R2in<=R2 (CM-BP-R2in x))
    <- efxmap`domain-total (DM-M2out=R2out:efxmap`domain M2out R2out)
    <- let-helper/L4 M2|N=M2out+M2in DM-M2out=R2out _  M2in-of-N R2out=>O2out N!<O2out
    <- efxmap`partition-implies-disjoint-join MP|R2outk=M1+M2outkP
      M1^M2outkP M1+M2outkP=MP
    <- efxmap`disjoint-join-implies-equiv M1^M2outkP M1+M2outkP=MP
      MP=>PiP Pi1 Pi2outkP M1=>Pi1 M2outkP=>Pi2outkP PiP<=>Pi1+Pi2outkP
    <- efxmap`join-respects-eq Mk3+M2out=M2outk Mk3=Mk1 efxmap`eq/ efxmap`eq/
      Mk1+M2out=M2outk
    <- let-helper/L26 CB M2|N=M2out+M2in M2in=>MF2in
      S+MF2in=>Mk1 FS+X=>Mk2 Mk1^M2out Mk2^M2out
    <- efxmap-disjoint-join-vleq-converse Mk1^M2out Mk1+M2out=M2outk
      M2outk=<=M2outkP Mk1P M2outP Mk1P^M2outP Mk1P+M2outP=M2outkP
      Mk1=<=Mk1P M2out=<=M2outP
    <- efxmap`disjoint-join-implies-equiv Mk1P^M2outP Mk1P+M2outP=M2outkP
      M2outkP=>Pi2outkP Pik1P Pi2outP Mk1P=>Pik1P M2outP=>Pi2outP
      Pi2outkP<=>Pik1P+Pi2outP
    <- let-helper/L27 _ SZ-OS=SN M2in=>MF2in M2in-of-N CM-B-OS
      S+MF2in=>Mk1 Mk1=<=Mk1P Mk1P=>Pik1P
      ([x] OS=>PiG x) N!<B ([x] B+N=BF x) _ N+MF2in=M2in
      ([x] M2in=>Pif x) ([x] IMPP x)
    <- efxmap-vleq-reflexive M2in=<=M2in
    <- efxmap-partition-on-index-vleq-converse M2|N=M2out+M2in M2out=<=M2outP
      M2in=<=M2in M2P M2P|N=M2outP+M2in M2=<=M2P
    <- efxmap-vleq-implies-leq M2=<=M2P M2<=M2P
    <- efxmap-vleq-implies-same-domain M2out=<=M2outP DM-M2out=M2outP
    <- efxmap-same-domain-implies-domain-left
      DM-M2out=M2outP DM-M2out=R2out DM-M2outP=R2out
    <- let-helper/L21 DM-M2outP=R2out
      R2out=>O2out N!<O2out N!<B ([x] B+N=BF x) M2outP=>Pi2outP
      ([x] BP+M2outP=>Pi2outP x)
    <- efxmap-vleq-preserves-disjoint-left M2out^M2in M2out=<=M2outP M2outP^M2in
    <- let-helper/L10 M2P|N=M2outP+M2in _ _ _ M2outP+M2in=M2P % TODO: better not call this lemma.
    <- ({x} efxmap`disjoint-join-implies-equiv-converse M2outP^M2in
         M2outP+M2in=M2P (BP+M2outP=>Pi2outP x) (M2in=>Pif x)
         _ (M2P=>Pi2P x) (Pi2outP+Pif<=>Pi2P x))
    <- efxmap-partition-implies-split MP|R2outk=M1+M2outkP MP=>M1+M2outkP.

%worlds (objvar) (let-helper-before/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper-before/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%%% Here Pxf is combined into permission Pi2. After using the latter,
%%% we need to use Pxf to restore the permission for Px.

%theorem let-helper-before/simple/unique
  : forall* {CM} {PM} {B} {XX1} {XX2} {XX} {XX0} {Q} {XX2P}
    {NN} {C} {Out0} {N} {BP} {XXV} {FM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {BF: cxt`fresh B N}
    {BU: {x} cxt`update B N (cxt-info/ x (ty/ NN annot/borrow C)) (BP x)}
    {CML: clsmap`lookup CM C FM} % not sure whether we need this!
    {CM-B-XX2: {x:object} clsmap-cxt-effects CM (BP x) XX2}
    {CM-B-XX2P: clsmap-cxt-effects CM B XX2P}
    {CM-B-XXV: clsmap-cxt-effects CM B XXV}
    {SUB: subst-effects CM B unique-target N XX2 XX2P}
    {XX1+XX2P=XX: effects`join XX1 XX2P XX}
    {XX<=XXV: effects-leq-no-consume XX XXV}
    {TC: transfer-consume CM B XXV XX1 XX0 Q}
    {XX0=>Piin: effects2output CM PM B (reftype/ NN C unique-target) XX0 Out0}
    exists {PiQ} {Out1} {Out2} {XX2A}
    {Q=>PiQ: make-encumbered CM PM B Q PiQ}
    {EA: envadd PiQ Out0 Out1}
    {XX2<c=XX2A: effects-leq-no-consume XX2 XX2A}
    {FMT: let-output-format CM PM B N (reftype/ NN C unique-target) XXV XX2A Out2}
    {TRANS: transform Out1 Out2}
    true.

%theorem let-helper-before/simple/unique/L
  : forall* {M} {MS} {N} {Mout} {Min}
    forall {M=>MS: efxmap-map-objects M MS}
    {MB: set`member MS N}
    {P: efxmap-partition-on-index M N Mout Min}
    exists {SN} {SZ: efxmap`size Min (s SN)}
    true.

%worlds (objvar) (let-helper-before/simple/unique/L _ _ _ _ _).
%trustme %total {} (let-helper-before/simple/unique/L _ _ _ _ _).


- : let-helper-before/simple/unique CM-CM CM2PM BF ([x] BU x) CML
    ([x] CM-BP-XX2 x) CM-B-XX2P CM-B-XXV
    (subst-effects/unique/1 CB S2=>OS2 M=>MS N<-MS N!<OS2 N!<Q2
      (subst-efxmap/
        (M2=>M2out+M2in:efxmap-partition-on-index M2 N M2out M2in)
        (M2in=>M2Fin:efxmap-map-fields M2in M2Fin)
        S+M2Fin=>MK1 _ S2+X=>MK2 MK1+MK2=MK
        (MK+M2out=M2outK:efxmap`join MK M2out M2outK)))
    XX1+XX2P=XX (effects-leq-no-consume/ (M<=MP:efxmap`leq M MP))
    (XXV+XX1=>XX0+QP:transfer-consume CM B _ _ _ QP)
    (effects2output/simple
      (ty2perm/ PML NN2P A2P) RT2T simple-targets/unique
      (M0=>Pi0:efxmap2perm CM PM B M0 Pi0) (B=>PiB:cxt2perm CM PM B PiB))
  %{=>}% _ _ _ _ QP=>PiQ2 (envadd/exists [x] envadd/expr)
    (effects-leq-no-consume/ M2<=M2P)
    (let-output-format/simple/unique
      BU (ty2perm/ PML NN2P A2P)
      ([x] effects2input/
        (cxt2perm/U B=>PiB BF (BU x) T2PF2)
        (BP+Q2=>PiQ2 x) (BP+Q2=>FS3 x) S2uFS3=S3
        S3=>M3 (BP+M3=>Pi3 x) (M2P=>Pi2P x))
      (DM-M2outP=R2out:efxmap`domain M2outP R2out)
      M2P|R2out=M2inP+M2outP MP|R2out=M1+M2outP
       ([x] M2inP=>Pxf x) ([x] IMP2P x) M1=>Pi1)
    (transform/inside [x]
      (transform/implies
        (implies/trans4
          (implies/combine
            (implies/reflexive) % X12
            (implies/combine
              (implies/reflexive) % PiB
              (implies/trans
                (implies/combine % PF
                  (IMP3 x)
                  (implies/equiv
                    (equiv/transitive
                      (Pi0<=>PiP+Pi3)
                      (equiv/commute))))
                (implies/equiv (equiv/symmetric equiv/associate)))))
          (implies/trans
            (implies/combine implies/reflexive
              (implies/trans
                (implies/combine implies/reflexive
                  (implies/equiv equiv/roll2))
                (implies/equiv equiv/associate)))
            (implies/equiv equiv/roll2))
          (implies/trans
            (implies/combine (implies/equiv equiv/commute)
              (implies/trans
                (implies/combine implies/reflexive
                  (implies/trans
                    (implies/combine implies/reflexive
                      (implies/combine implies/reflexive
                        (implies/equiv PiP<=>Pi1+P2outP)))
                    (implies/equiv equiv/roll2)))
                (implies/equiv equiv/associate)))
            (implies/equiv equiv/associate))
          (implies/trans
            (implies/combine implies/reflexive
              (implies/trans3
                (implies/combine
                  (implies/trans (IMP1 x) (implies/equiv equiv/commute))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/trans
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/equiv equiv/roll2)
                      (implies/trans
                        (implies/combine implies/reflexive
                          (implies/trans3
                            (implies/combine (IMP2 x) implies/reflexive)
                            (implies/equiv equiv/commute)
                            (implies/equiv (P2outP+Pxf<=>Pi2P x))))
                        (implies/equiv equiv/commute))))
                  (implies/equiv equiv/roll2))))
            (implies/equiv equiv/associate)))))
    <- let-helper/L3 CM-B-XXV XX1+XX2P=XX M<=MP XXV+XX1=>XX0+QP %{=>}%
      S3 FS3 M3 QP=>FS3 S2P^FS3 S2uFS3=S3 S3=>M3
      (MP^M3:efxmap`disjoint MP M3) (MP+M3=M0:efxmap`join MP M3 M0)
      (QP=Q2P:set`eq QP Q2P) (S0=S1:set`eq S0 S1) (Q0=Q1:set`eq Q0 Q1)
    <- efxmap`disjoint-join-implies-equiv MP^M3 MP+M3=M0 M0=>Pi0 PiP Pi3
      MP=>PiP M3=>Pi3 Pi0<=>PiP+Pi3
    <- objset2fldset-respects-eq QP=>FS3 clsmap`eq/ cxt`eq/ QP=Q2P set`eq/ Q2=>FS3
    <- set+map2map-unique S+M2Fin=>MK1 set+map2map/0 set`eq/ efxmap`eq/ MK1=0
    <- set2efxmap-unique S2+X=>MK2 set2efxmap/0 set`eq/ efx`eq/ MK2=0
    <- efxmap`join-unique MK1+MK2=MK efxmap`join/L MK1=0 MK2=0 MK=0
    <- efxmap`join-unique MK+M2out=M2outK efxmap`join/L MK=0 efxmap`eq/ M2outK=M2out
    <- let-helper/L6 XX1+XX2P=XX M2outK<=M
    <- let-helper/L18 S2=>OS2 N!<OS2 N!<Q2 Q2=>FS3 S2uFS3=S3
      S3=>M3 M3=>Pi3 BF BU ([x] BP+Q2=>FS3 x) ([x] BP+M3=>Pi3 x)
    <- efxmap`leq-respects-eq M2outK<=M M2outK=M2out efxmap`eq/ M2out<=M
    <- efxmap`leq-transitive M2out<=M M<=MP M2out<=MP
    <- efxmap`domain-total (DM-M2out=R2out:efxmap`domain M2out R2out)
    <- let-helper/L12 M2out<=MP DM-M2out=R2out _ _
      (MP|R2out=M1+M2outP:efxmap`partition MP R2out M1 M2outP) M2out=<=M2outP
    <- let-helper/L16 ([x] CM-BP-XX2 x) _
      DM-M2=R2 ([x] CM-BP-R2 x) ([x] CM-BP-Q2 x)
    <- let-helper/L19 BF BU CM-BP-Q2 N!<Q2 CM-B-Q2
    <- make-encumbered-total CM-CM CM2PM CM-B-Q2 _ Q2=>PiQ2
    <- let-helper/L20 Q2=>PiQ2 BF BU N!<Q2 BP+Q2=>PiQ2
    <- set`eq-symmetric QP=Q2P Q2=QP
    <- make-encumbered-respects-eq Q2=>PiQ2 clsmap`eq/ predmap`eq/ cxt`eq/
      Q2=QP permission`eq/ QP=>PiQ2
    <- let-helper/L10 M2=>M2out+M2in M2out<=M2 M2in<=M2 M2out^M2in M2out+M2in=M2
    <- efxmap`domain-total DM-M2in=R2in
    <- efxmap`domain-preserves-leq* M2in<=M2 DM-M2in=R2in DM-M2=R2 R2in<=R2
    <- ({x} clsmap-cxt-fldset-respects-geq (CM-BP-R2 x) R2in<=R2 (CM-BP-R2in x))
    <- let-helper/L4 M2=>M2out+M2in DM-M2out=R2out _  M2in-of-N R2out=>O2out N!<O2out
    <- ({x} cxt`update-implies-lookup (BU x) (BL x))
    <- let-helper/L5 DM-M2in=R2in ([x] CM-BP-R2in x) ([x] BL x) CML
         M2in-of-N M2in=>M2Fin
      _ _ (DM-M2Fin=S2Fin:efxmap`domain M2Fin S2Fin) DM-FM=FS S2Fin<=FS
    <- ({x:object} fldmap2perm-total CM-CM CM2PM CML DM-FM=FS
         S2Fin<=FS _ (S2Fin=>P2Fin x))
    <- let-helper/L15 (ty2perm/ PML NN2P A2P) _ T2PF2 IMP3
    <- let-helper/L8 CM2PM CML A2P (NN2P:nn2perm _ _ PF) (PML:predmap`lookup PM _ CP)
      S2Fin=>P2Fin %{=>}% _ CN IMP1
    <- let-helper-before/simple/unique/L M=>MS N<-MS M2=>M2out+M2in _ MSZ
    <- efxmap-map-fields-preserves-size MSZ M2in=>M2Fin MFSZ
    <- efxmap`domain-preserves-size MFSZ DM-M2Fin=S2Fin SZ
    <- let-helper/L9* SZ ([x] BL x) CML ([x] S2Fin=>P2Fin x) CN %{=>}%
      Pxf _ _ N+S2Fin=>S (S=>M2inP:set2efxmap _ efx/write M2inP)
      M2inP=>Pxf IMP2 IMP2P
    <- let-helper/L11* M2in-of-N M2in=>M2Fin DM-M2Fin=S2Fin N+S2Fin=>S
      S=>M2inP DM-M2in=R2in M2in<=M2inP DM-M2inP=R2in
    <- efxmap`join-total (M2outP+M2inP=M2P:efxmap`join M2outP M2inP M2P)
    <- efxmap-vleq-implies-leq M2out=<=M2outP M2out<=M2outP
    <- let-helper/L13 M2out<=M2outP M2in<=M2inP M2out+M2in=M2
      M2outP+M2inP=M2P M2<=M2P
    <- efxmap`partition-implies-permission-combine MP|R2out=M1+M2outP
      MP=>PiP Pi1 Pi2outP M1=>Pi1 M2outP=>P2outP PiP<=>Pi1+P2outP
    <- efxmap`domain-preserves-disjoint M2out^M2in DM-M2out=R2out
      DM-M2in=R2in (R2out^R2in:set`disjoint R2out R2in)
    <- efxmap-vleq-implies-same-domain M2out=<=M2outP SDM
    <- efxmap-same-domain-implies-domain-left SDM DM-M2out=R2out DM-M2outP=R2out
    <- efxmap`domain-preserves-disjoint-converse R2out^R2in DM-M2outP=R2out
      DM-M2inP=R2in M2outP^M2inP
    <- efxmap`disjoint-symmetric M2outP^M2inP M2inP^M2outP
    <- efxmap`join-commutative M2outP+M2inP=M2P M2inP+M2outP=M2P
    <- let-helper/L21 DM-M2outP=R2out R2out=>O2out
      N!<O2out BF BU M2outP=>P2outP BP+M2outP=>P2outP
    <- ({x} efxmap`disjoint-join-implies-equiv-converse M2outP^M2inP
         M2outP+M2inP=M2P (BP+M2outP=>P2outP x) (M2inP=>Pxf x) _
         (M2P=>Pi2P x) (P2outP+Pxf<=>Pi2P x))
    <- efxmap`disjoint-join-right-domain-implies-partition
      DM-M2outP=R2out M2inP^M2outP M2inP+M2outP=M2P M2P|R2out=M2inP+M2outP.

%worlds (objvar) (let-helper-before/simple/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper-before/simple/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
