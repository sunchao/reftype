%%% Proof for Let

%%% A few abbreviations

%abbrev unique-obj-permission : clspred -> (object -> permission)
  = [CP] ([x] unitperm (nonlinear (neg (objequal x null))) ,
           (combine (allperm x) (one-predcall CP x))).


%%% A few lemmas

%theorem cxt-fresh-update-preserves-capmap2perm
  : forall* {CM} {PM} {B} {BP} {N} {M} {CI} {Pi}
    forall {B+M=>Pi: capmap2perm CM PM B M Pi}
    {BF: cxt`fresh B N}
    {BU: cxt`update B N CI BP}
    exists {BP+M=>Pi: capmap2perm CM PM BP M Pi}
    true.

- : cxt-fresh-update-preserves-capmap2perm capmap2perm/0 _ _ capmap2perm/0.

- : cxt-fresh-update-preserves-capmap2perm
    (capmap2perm/U B+M'=>Pi2 N+F=>K BL CF X2Q FS UD) BF BU
    (capmap2perm/U BP+M'=>Pi2 N+F=>K BPL CF X2Q FS UD)
    <- cxt-fresh-update-preserves-capmap2perm B+M'=>Pi2 BF BU BP+M'=>Pi2
    <- cxt`fresh-update-preserves-lookup BL BF BU BPL.

%worlds (objvar) (cxt-fresh-update-preserves-capmap2perm _ _ _ _).
%total (M2P) (cxt-fresh-update-preserves-capmap2perm M2P _ _ _).


%theorem cxt-remove-unique-preserves-capmap2perm
  : forall* {CM} {PM} {M} {B0} {B1} {S} {Pi}
    forall {B0+M=>Pi: capmap2perm CM PM B0 M Pi}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    exists {B1+M=>Pi: capmap2perm CM PM B1 M Pi}
    true.

- : cxt-remove-unique-preserves-capmap2perm
    capmap2perm/0 B0-S=B1 capmap2perm/0.

- : cxt-remove-unique-preserves-capmap2perm
    (capmap2perm/U B0+M'=>Pi2 N+F=>K B0-L CF X2Q K!<M' M'+K=M) B0-S=B1
    (capmap2perm/U B1+M'=>Pi2 N+F=>K B1-L CF X2Q K!<M' M'+K=M)
    <- cxt-remove-unique-preserves-capmap2perm B0+M'=>Pi2 B0-S=B1 B1+M'=>Pi2
    <- cxt-remove-unique-preserves-lookup-info B0-L B0-S=B1 _ B1-L.

%worlds (objvar) (cxt-remove-unique-preserves-capmap2perm _ _ _).
%total (A) (cxt-remove-unique-preserves-capmap2perm A _ _).


%{
This version is more complicated - Twelf will say that cxt`lookup will
have variable in cxt-info.

%theorem cxt-remove-unique-preserves-set2cond
  : forall* {B0} {B1} {S} {GF} {S'}
    forall {S=>GF: {x} set2cond B0 x S (GF x)}
    {B0-S=B1: cxt-remove-unique B0 S' B1}
    exists {S=>GF: {x} set2cond B1 x S (GF x)}
    true.

- : cxt-remove-unique-preserves-set2cond ([_] set2cond/0)
    _ ([_] set2cond/0).

- : cxt-remove-unique-preserves-set2cond
    ([x] set2cond/U (B0+S'=>Pi x) S'+N=S N!<S' B0-L) B0-R=B1
    ([x] set2cond/U (B1+S'=>Pi x) S'+N=S N!<S' B1-L)
    <- cxt-remove-unique-preserves-set2cond B0+S'=>Pi B0-R=B1 B1+S'=>Pi
    <- cxt-remove-unique-preserves-lookup-info B0-L B0-R=B1 _ B1-L.

%worlds (objvar) (cxt-remove-unique-preserves-set2cond _ _ _).
%total (A) (cxt-remove-unique-preserves-set2cond A _ _).
}%


%theorem cxt-remove-unique-preserves-set2cond
  : forall* {B0} {B1} {S} {GF} {S'} {O}
    forall {S=>GF: set2cond B0 O S GF}
    {B0-S=B1: cxt-remove-unique B0 S' B1}
    exists {S=>GF: set2cond B1 O S GF}
    true.

- : cxt-remove-unique-preserves-set2cond set2cond/0 _ set2cond/0.

- : cxt-remove-unique-preserves-set2cond
    (set2cond/U (B0+S'=>Pi) S'+N=S N!<S' B0-L) B0-R=B1
    (set2cond/U (B1+S'=>Pi) S'+N=S N!<S' B1-L)
    <- cxt-remove-unique-preserves-set2cond B0+S'=>Pi B0-R=B1 B1+S'=>Pi
    <- cxt-remove-unique-preserves-lookup-info B0-L B0-R=B1 _ B1-L.

%worlds (objvar) (cxt-remove-unique-preserves-set2cond _ _ _).
%total (A) (cxt-remove-unique-preserves-set2cond A _ _).


%theorem letRefTyping-helper/base/unique/L1L
  : forall* {B} {N} {OF:object -> object} {TF}
    forall {BL: {x} cxt`lookup B N (cxt-info/ (OF x) TF)}
    exists {O} {T} {BL: cxt`lookup B N (cxt-info/ O T)}
    {EQ: {x} object`eq (OF x) O}
    true.

- : letRefTyping-helper/base/unique/L1L
    ([_] cxt`lookup/= N1=N2) _ _ (cxt`lookup/= N1=N2) ([_] object`eq/).

- : letRefTyping-helper/base/unique/L1L
    ([x] cxt`lookup/> (BL x) P) _ _ (cxt`lookup/> BLP P) EQF
    <- letRefTyping-helper/base/unique/L1L BL _ _ BLP EQF.

%worlds (objvar) (letRefTyping-helper/base/unique/L1L _ _ _ _ _).
%total (L) (letRefTyping-helper/base/unique/L1L L _ _ _ _).


%{
 we have two context: the old context which we can look up for the object
  O and get a type (ty/ NN1 A C), and the updated context which we can
  lookup the variable x and the type (ty/ NN A C).
  NN is always less than or equal to NN1.

 Note: after carving out the permission for variable x, the encumbered
 permission is lost. This is not too precise. In future, if we want to
 restore the permissions after checking the let body, we should change this.
}%

%theorem letRefTyping-helper/base/unique/L1L2L1
  : forall* {O2} {O2P} {N} {F} {PF} {PiF} {NN1} {NN2}
    forall {Q} {EQ: object`eq O2 O2P} {EQ: nat`eq F N}
    {AN2:apply-nn NN2 ([x:gterm objectk]
         scale Q (unitperm (precise-exists x N ([x1:gterm objectk] PF x1))))
          ([x:gterm objectk] PiF x)}
    {NN1<=NN2: nonnull`leq NN1 NN2}
    exists {PiF2}
    {AN2:apply-nn NN1
          ([x:gterm objectk]
            scale Q (unitperm (precise-exists x F ([x1:gterm objectk] PF x1))))
          ([x:gterm objectk] PiF2 x)}
    {IMP: {x} implies (combine (unitperm (nonlinear (objequal x O2))) (PiF O2P)) (PiF2 x)}
    true.

%theorem letRefTyping-helper/base/unique/L1L2L1
  : forall* {O2} {O2P} {N} {F} {PF}
    forall {Q} {EQ: object`eq O2 O2P} {EQ: nat`eq F N}
    exists {IMP: {x} implies
                 (combine
                   (unitperm (nonlinear (objequal x O2)))
                   (unitperm
                     (conditional
                       (objequal O2P null)
                       (empty)
                       (scale-fldperm Q O2P N PF))))
                 (combine
                   (unitperm
                     (conditional
                       (objequal x null)
                       (empty)
                       (scale-fldperm Q x F PF)))
                   (unitperm
                     (encumbered
                       (unitperm
                         (conditional
                           (objequal x null)
                           (empty)
                           (scale-fldperm Q x F PF)))
                       (unitperm
                         (conditional
                           (objequal O2P null)
                           (empty)
                           (scale-fldperm Q O2P N PF))))))}
    true.

- : letRefTyping-helper/base/unique/L1L2L1 _ object`eq/ nat`eq/
    ([x] implies/trans
      (implies/combine (implies/nonlinear bimplies/objequal-symmetric)
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine implies/reflexive
            (implies/self-implication))))
      (implies/objequal
        ([v] (combine
               (unitperm
                 (conditional
                   (objequal v null)
                   (empty)
                   (scale-fldperm Q v F PF)))
               (unitperm
                 (encumbered
                   (unitperm
                     (conditional
                       (objequal v null)
                       (empty)
                       (scale-fldperm Q v F PF)))
                   (unitperm
                     (conditional
                       (objequal O2P null)
                       (empty)
                       (scale-fldperm Q O2P F PF))))))))).

%worlds (objvar) (letRefTyping-helper/base/unique/L1L2L1 _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L1L2L1 _ _ _ _).


%theorem letRefTyping-helper/base/unique/L1L2
  : forall* {CM} {PM} {B} {O} {N1} {MF} {M2} {Pi2} {BF} {A} {C} {N2} {X} {A1} {NN1} {NN2}
    forall {L: cxt`lookup B N2 (cxt-info/ O (ty/ NN2 A1 C))}
    {N1!<B: cxt`fresh B N1}
    {B+N1=BF: {x} cxt`update B N1 (cxt-info/ x (ty/ NN1 A C)) (BF x)}
    {N2+MF=M2: nat+set2capmap N2 MF X M2}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    {NN1<=NN2: nonnull`leq NN1 NN2}
    exists {M1} {Pi1}
    {N1+MF=M1: nat+set2capmap N1 MF X M1}
    {M1=>Pi1: {x} capmap2perm CM PM (BF x) M1 (Pi1 x)}
    {IMP: {x} implies (combine (unitperm (nonlinear (objequal x O))) Pi2)
          (combine (Pi1 x) (unitperm (encumbered (Pi1 x) Pi2)))}
    true.

- : letRefTyping-helper/base/unique/L1L2 _ _ _ nat+set2capmap/0 capmap2perm/0 LEQ %{=>}%
    _ _ (nat+set2capmap/0) ([_] capmap2perm/0)
    ([x] implies/combine implies/nonlinear2empty implies/self-implication).

- : {B+N=BF:{x} cxt`update B Nx1 (cxt-info/ x (ty/ NNx1 A C)) (BF x)}
    letRefTyping-helper/base/unique/L1L2
    (BL:cxt`lookup B Nx2 (cxt-info/ O2 (ty/ NNx2 A1 C)))
    (N1!<B:cxt`fresh B Nx1) B+N=BF
    (nat+set2capmap/U (N2+MFP=M2P:nat+set2capmap Nx2 MFP Xx M2P)
      (N2+F=K2:pair2nat (pair/ Nx2 F) K2)
      F!<MFP MFP+F+X=MF (M2P+K2+X=M2:capmap`update M2P K2 Xx M2))
    M2=>Pi2 (LEQ:nonnull`leq NNx1 NNx2)
    %{=>}% _ _
    (nat+set2capmap/U N1+MFP=M1P (N1+F=K1:pair2nat (pair/ Nx1 F) K1) F!<MFP
      (MFP+F+X=MF:set`add MFP F MF)
      (M1P+K1+X=M1:capmap`update M1P K1 Xx M1))
    ([x] capmap2perm/U (M1P=>Pi12 x) N1+F=K1 (BFL x)
      (create-fldperm/ CML FML T2PF) X2Q K1!<M1P M1P+K1+X=M1)
    ([x] implies/trans7
      (implies/combine
        (implies/duplicate)
        (implies/equiv (equiv/symmetric (Pi21+Pi22<=>Pi2))))
      (implies/equiv
        (equiv/transitive
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive equiv/roll2)))
      (implies/combine
        (implies/reflexive)
        (implies/combine
          (implies/reflexive)
          (IMPP x)))
      (implies/equiv equiv/associate)
      (implies/combine (IMPP2 x) (implies/reflexive))
      (implies/equiv
        (equiv/transitive3
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive equiv/roll2)
          (equiv/associate)))
      (implies/combine implies/reflexive
        (implies/trans
          (implies/combine-merge-encumbered)
          (implies/equiv-encumbered
            (equiv/reflexive)
            (Pi21+Pi22<=>Pi2)))))
     <- nat+set2capmap-preserves-fresh N2+MFP=M2P F!<MFP N2+F=K2 K2!<M2P
     <- capmap2perm/U-inversion M2=>Pi2 K2!<M2P M2P+K2+X=M2 %{=>}%
       N2P FP N2P+FP=K2 O2P NNP AP CP BL2 _ (create-fldperm/ CML2 FML2 T2PF)
       Q X2Q Pi22 M2P=>Pi22 (Pi21+Pi22<=>Pi2)
     <- letRefTyping-helper/base/unique/L1L2 BL N1!<B B+N=BF N2+MFP=M2P
       M2P=>Pi22 LEQ %{=>}% M1P Pi12 N1+MFP=M1P ([x] M1P=>Pi12 x) ([x] IMPP x)
     <- pair2nat-total (N1+F=K1: pair2nat (pair/ Nx1 F) K1)
     <- capmap`update-total M1P+K1+X=M1
     <- ({x} cxt`update-implies-lookup (B+N=BF x) (BFL x))
     <- nat+set2capmap-preserves-fresh N1+MFP=M1P F!<MFP N1+F=K1 K1!<M1P
     <- nat2pair-unique N2+F=K2 N2P+FP=K2 nat`eq/ N2+F=N2P+FP
     <- pair-eq-implies-eq N2+F=N2P+FP N2=N2P F=FP
     <- cxt`lookup-unique BL BL2 cxt`eq/ N2=N2P CIE
     <- cxt-info-eq-inversion CIE O2=O2P TE
     <- ty-eq-inversion TE NN=NNP A=AP C=CP
     <- nat`eq-symmetric C=CP CP=C
     <- nat`eq-symmetric F=FP FP=F
     <- nonnull`eq-symmetric NN=NNP NNP=NN
     <- clsmap`lookup-respects-eq CML2 clsmap`eq/ CP=C fldmap`eq/ CML
     <- fldmap`lookup-respects-eq FML2 fldmap`eq/ FP=F ty`eq/ FML
     <- letRefTyping-helper/base/unique/L1L2L1 _ O2=O2P F=FP IMPP2.

%worlds (objvar) (letRefTyping-helper/base/unique/L1L2 _ _ _ _ _ _ _ _ _ _ _).
%total (M) (letRefTyping-helper/base/unique/L1L2 _ _ _ M _ _ _ _ _ _ _ ).


%theorem letRefTyping-helper/base/unique/L1L3
  : forall* {O1} {O2} {Pi2} {Pi2P}
    forall {O1=O2: {x} object`eq (O1 x) O2}
    {IMP2:{x:gterm objectk}
           implies (combine (unitperm (nonlinear (objequal x O2))) Pi2)
           (combine (Pi2P x) (unitperm (encumbered (Pi2P x) Pi2)))}
    exists {IMP2:{x:gterm objectk}
                  implies
                  (combine (unitperm (nonlinear (objequal x (O1 x)))) Pi2)
                  (combine (Pi2P x) (unitperm (encumbered (Pi2P x) Pi2)))}
    true.

- : letRefTyping-helper/base/unique/L1L3 ([_] object`eq/) IMP IMP.

%worlds (objvar) (letRefTyping-helper/base/unique/L1L3 _ _ _).
%total { } (letRefTyping-helper/base/unique/L1L3 _ _ _).


%theorem letRefTyping-helper/base/unique/L1
  : forall* {S} {B} {GF} {FS} {M1} {N} {C} {B1} {CM} {PM} {PiM1} {A} {NN} {X}
    forall {SN} {SZ-S: set`size S (s SN)}
    {CM-B-S: cxt-unique-objset B NN C S}
    {S+FS=M1: set+set2capmap S FS X M1}
    {M1=>PiM1: capmap2perm CM PM B M1 PiM1}
    {S=>GF: {x} set2cond B x S (GF x)}
    {BF: cxt`fresh B N}
    {BL: {x} cxt`update B N (cxt-info/ x (ty/ NN A C)) (B1 x)}
    exists {M2} {PiM2}
    {N+FS=M2: nat+set2capmap N FS X M2}
    {M2=>PiM2: {x} capmap2perm CM PM (B1 x) M2 (PiM2 x)}
    {PiM1+GF=>PiM2: {x} implies (combine (GF x) PiM1)
                    (combine (GF x)
                      (combine (PiM2 x) (unitperm (encumbered (PiM2 x) PiM1))))}
    true.

 - : letRefTyping-helper/base/unique/L1 z SZ CM-B-S
     (set+set2capmap/U SP+MF=MP1 NP+MF=>MP2 NP!<SP (SP+NP=S:set`add SP NP S)
       (MP1+MP2=M:capmap`join MP1 MP2 M))
     M=>Pi ([x] S=>GF x) BF BU %{=>}% _ _
     (N+MF=>MN:nat+set2capmap N MF _ MN) MN=>Pf
     ([x] implies/trans8
       (implies/combine (GIMP1 x) implies/reflexive)
       (implies/equiv equiv/commute)
       (implies/cond-push)
       (implies/cond-gen-inner)
       (implies/cond-inner
         (bimplies/reflexive)
         (bimplies/reflexive)
         (implies/trans3
           (implies/combine
             (implies/reflexive)
             ((implies/equiv equiv/identity)))
           (IMPP2 x)
           (implies/equiv (equiv/symmetric equiv/identity)))
         (implies/trans5
           (implies/combine implies/nonlinear2empty
             (implies/combine implies/reflexive (GFP=>F x)))
           (implies/equiv (equiv/transitive equiv/commute equiv/identity))
           (implies/combine implies/reflexive implies/duplicate)
           (implies/equiv equiv/associate)
           (implies/combine
             (implies/trans3
               (implies/equiv equiv/commute)
               (implies/combine (implies/contradiction) implies/reflexive)
               (IMPP2 x))
             (F=>GFP x))))
       (implies/cond-pull)
       (implies/equiv equiv/commute)
       (implies/combine (GIMP2 x) implies/reflexive))
     <- set`not-member-add-size-implies-empty NP!<SP SP+NP=S SZ SP=0
     <- ({x} set2cond/U-inversion (S=>GF x) NP!<SP SP+NP=S (GFP x) (SP=>GFP x)
       (OF x) _ (BL x) (GIMP1 x) (GIMP2 x))
     <- letRefTyping-helper/base/unique/L1L BL _ _ BL1 ([x] OF=O2 x)
     <- cxt-unique-objset/U-inversion CM-B-S NP!<SP SP+NP=S
       CM-B-SP O1 A1 _ BLP UA (LEQ:nonnull`leq NNx1 NNx2)
     <- set+set2capmap-unique SP+MF=MP1 set+set2capmap/0 SP=0 set`eq/ cap`eq/ MP1=0
     <- capmap`join-unique MP1+MP2=M capmap`join/L MP1=0 capmap`eq/ M=MP2
     <- capmap2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/ cxt`eq/ M=MP2
       permission`eq/ MP2=>Pi
     <- cxt`lookup-unique BL1 BLP cxt`eq/ nat`eq/ CIE
     <- ({x} cxt`update-implies-lookup (BU x) (BL2 x))
     <- letRefTyping-helper/base/unique/L1L2
       BLP BF BU NP+MF=>MP2 MP2=>Pi LEQ _ _ N+MF=>MN MN=>Pf IMPP
     <- capmap`eq-symmetric M=MP2 MP2=M
     <- cxt-info-eq-inversion CIE O2=O1 TE
     <- ({x:object} object`eq-transitive (OF=O2 x) O2=O1 (OF=O1 x))
     <- letRefTyping-helper/base/unique/L1L3 OF=O1 IMPP IMPP2
     <- ({x} set2cond-implies (SP=>GFP x) set2cond/0 object`eq/ SP=0 (GFP=>F x) (F=>GFP x)).

- : {S=>GF: {x} set2cond B x S (GF x)}
    letRefTyping-helper/base/unique/L1 _ SZ S-NN-C
    (set+set2capmap/U SP+MF=M1 N1+MF=M2 (N1!<SP:set`not-member SP Nx1)
      SP+N1=S (M1+M2=M:capmap`join M1 M2 M)) M=>Pi ([x] S=>GF x) BF ([x] BU x)
    %{=>}% MN _ (N+MF=MN:nat+set2capmap Nx MF _ MN) ([x] MN=>Pf x)
    ([x] implies/trans7
      (implies/combine (GF=>EQ+GFP x) (implies/equiv (Pi<=>Pi1+Pi2)))
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans7
          (implies/combine implies/reflexive (implies/equiv equiv/identity))
          (implies/equiv
            (equiv/transitive
              (equiv/combine equiv/reflexive equiv/commute)
              (equiv/associate)))
          (implies/combine (IMP2P x)
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/self-implication)
                  (implies/equiv-encumbered
                    (Pi<=>Pi1+Pi2)
                    (equiv/reflexive))
                  (implies/combine-assoc-encumbered)))
              (implies/linear-modus-ponens)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive implies/chain-implication)
          (implies/combine (implies/equiv (Pi2P<=>Pf x))
            (implies/equiv-encumbered (Pi2P<=>Pf x) equiv/reflexive))
          (implies/equiv
            (equiv/transitive (equiv/symmetric equiv/identity) (equiv/commute))))
        (implies/trans4
          (implies/combine
            (implies/nonlinear2empty)
            (implies/trans3
              (implies/equiv equiv/commute)
              (implies/equiv equiv/associate)
              (implies/combine
                (GFP+Pi1=>Pf+Pf-Pi1 x)
                (implies/reflexive))))
          (implies/equiv
            (equiv/transitive equiv/commute equiv/identity))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine implies/reflexive
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/transitive
                          (Pi<=>Pi1+Pi2)
                          (equiv/commute))
                        (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive implies/chain-implication)))))
      (implies/cond-distribute)
      (implies/combine (EQ+GFP=>GF x) (implies/cond-equal)))
     <- ({x} set2cond/U-inversion (S=>GF x) N1!<SP SP+N1=S (GFP x)
          (SP=>GFP x) (OF x) T (BL1 x) (GF=>EQ+GFP x) (EQ+GFP=>GF x))
     <- letRefTyping-helper/base/unique/L1L BL1 _ _ BL1P ([x] OF=O1 x)
     <- cxt-unique-objset/U-inversion S-NN-C N1!<SP SP+N1=S
       SP-NN-C O2 _ _ BL2 UA LEQ
     <- cxt`lookup-unique BL1P BL2 cxt`eq/ nat`eq/ CIE
     <- cxt-info-eq-inversion CIE O1=O2 TE
     <- ({x} object`eq-transitive (OF=O1 x) O1=O2 (OF=O2 x))
     <- not-member-nat+set2capmap-implies-disjoint SP+MF=M1 N1+MF=M2 N1!<SP M1^M2
     <- capmap`disjoint-join-implies-equiv M1^M2 M1+M2=M M=>Pi
       Pi1 Pi2 M1=>Pi1 M2=>Pi2 (Pi<=>Pi1+Pi2:equiv Pi (combine Pi1 Pi2))
     <- set`not-member-add-increases-size-converse SZ N1!<SP SP+N1=S SZP
     <- letRefTyping-helper/base/unique/L1 _ SZP SP-NN-C SP+MF=M1 M1=>Pi1 ([x] SP=>GFP x)
       BF ([x] BU x) _ _ N+MF=MN ([x] MN=>Pf x) (GFP+Pi1=>Pf+Pf-Pi1)
     <- letRefTyping-helper/base/unique/L1L2 BL2 BF ([x] BU x) N1+MF=M2 M2=>Pi2 LEQ
       _ _ N+MF=M2P ([x] BF+M2P=>Pi2P x) ([x] IMP2 x)
     <- nat+set2capmap-unique N+MF=M2P N+MF=MN nat`eq/ set`eq/ cap`eq/ M2P=MN
    <- ({x} capmap2perm-equiv (BF+M2P=>Pi2P x) (MN=>Pf x) clsmap`eq/
         predmap`eq/ cxt`eq/ M2P=MN (Pi2P<=>Pf x))
    <- letRefTyping-helper/base/unique/L1L3 OF=O2 IMP2 IMP2P.

%worlds (objvar) (letRefTyping-helper/base/unique/L1 _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N) (letRefTyping-helper/base/unique/L1 N _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L2L
  : forall* {CP1} {CP} {PF}
    forall {CP1=CP: predicate`eq CP1 CP}
    exists {IMP: {x} equiv (encumbered-fldperm x PF CP1) (encumbered-fldperm x PF CP)}
    true.

- : letRefTyping-helper/base/unique/L2L predicate`eq/ ([_] equiv/reflexive).

%worlds (objvar) (letRefTyping-helper/base/unique/L2L _ _).
%total { } (letRefTyping-helper/base/unique/L2L _ _).


%%% This cannot be proved because we cannot do equiv on conditional!
%theorem letRefTyping-helper/base/unique/L2L4
  : forall* {PF1} {PF} {CP1} {CP} {O} {Pi}
    forall {EQV: {x} equiv (PF1 x) (PF x)}
    {EQ: predicate`eq CP1 CP}
    exists {EQV: {x} equiv
                 (combine (encumbered-fldperm x PF1 CP1)
                   (unitperm (encumbered (encumbered-fldperm x PF1 CP1)
                               (combine (encumbered-fldperm O PF1 CP1) Pi))))
                 (combine (encumbered-fldperm x PF CP)
                   (unitperm (encumbered (encumbered-fldperm x PF CP)
                               (combine (encumbered-fldperm O PF1 CP1) Pi))))}
    true.

%worlds (objvar) (letRefTyping-helper/base/unique/L2L4 _ _ _).
%trustme %total { } (letRefTyping-helper/base/unique/L2L4 _ _ _).


%theorem letRefTyping-helper/base/unique/L2
  : forall* {CM} {B} {NN} {C} {FM} {PM} {S} {CP} {FS} {Pi} {GF}
    forall {N} {SZ: set`size S (s N)}
    {CM-B-S: cxt-unique-objset B NN C S}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FM-DM: fldmap`domain FM FS}
    {ME: make-encumbered CM PM B S Pi}
    {S=>GF: {x} set2cond B x S (GF x)}
    exists {PF} {FM2P2: {x} fldmap2perm2 PM x FM (PF x)}
    {IMP: {x} implies (combine (GF x) Pi)
          (combine (GF x)
            (combine (encumbered-fldperm x PF CP)
              (unitperm (encumbered (encumbered-fldperm x PF CP) Pi))))}
    true.

- : letRefTyping-helper/base/unique/L2 z SZ
    (CM-B-S:cxt-unique-objset B NNx C S)
    (CML:clsmap`lookup CM C FM)
    (PML:predmap`lookup PM C CP)
    (FM-DM:fldmap`domain FM FS)
    (make-encumbered/U ME-SP (BL1:cxt`lookup B Nx (cxt-info/ O1 (ty/ NNx1 A1 C1)))
      (CML1:clsmap`lookup CM C1 FM1)
      (PML1:predmap`lookup PM C1 CP1)
      (FM1-DM:fldmap`domain FM1 FS1)
      ([x] FS1=>Pi x)
      N!<SP (SP+N=S:set`add SP Nx S))
    ([x] S=>GF x) %{=>}% _ ([x] fldmap2perm2/ FM-DM (FS=>Pi x))
    ([x] implies/trans9
      (implies/combine (GIMP1 x)
        (implies/trans
          (implies/combine implies/reflexive Pi2=>E)
          (implies/equiv equiv/identity)))
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans4
          (implies/combine
            (implies/trans
              (implies/equiv (EQV x))
              (implies/nonlinear bimplies/objequal-symmetric))
            (implies/combine implies/reflexive implies/self-implication))
          (implies/objequal
              ([v] (combine (encumbered-fldperm v PF1 CP1)
                     (unitperm (encumbered (encumbered-fldperm v PF1 CP1)
                                 (encumbered-fldperm O1 PF1 CP1))))))
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine implies/reflexive E=>Pi2)
              (add-encumber)))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans3
          (implies/combine implies/nonlinear2empty
            (implies/trans3
              (implies/combine implies/reflexive
                (implies/trans (GIMP3 x) implies/duplicate))
              (implies/equiv
                (equiv/transitive equiv/commute (equiv/symmetric equiv/associate)))
              (implies/combine (GIMP4 x)
                (implies/trans3
                  (implies/combine (implies/contradiction)
                    (implies/trans
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine implies/reflexive implies/self-implication)))
                  (implies/objequal
                    ([v] (combine (encumbered-fldperm v PF1 CP1)
                           (unitperm (encumbered (encumbered-fldperm v PF1 CP1)
                                       (encumbered-fldperm O1 PF1 CP1))))))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine implies/reflexive (E=>Pi2))
                      (add-encumber)))))))
          (implies/equiv (equiv/transitive equiv/commute equiv/identity))
          (implies/equiv equiv/commute)))
      (implies/cond-pull)
      (implies/combine implies/reflexive (GIMP2 x))
      (implies/combine
        (implies/combine (implies/equiv (EQV2 x))
          (implies/equiv-encumbered (EQV2 x) (equiv/reflexive)))
        (implies/reflexive))
      (implies/equiv equiv/commute))
    <- set`not-member-add-size-implies-empty N!<SP SP+N=S SZ (SP=E:set`eq SP set/0)
    <- ({x} set2cond/U-inversion (S=>GF x) N!<SP SP+N=S (GFP x) (SP=>GFP x)
         (O2 x) T2 (BL2 x) (GIMP1 x) (GIMP2 x))
    <- cxt-unique-objset/U-inversion CM-B-S N!<SP SP+N=S CM-B-SP O3 A3 NNx3 BL3 _ _
    <- cxt`lookup-unique BL1 BL3 cxt`eq/ nat`eq/ CI1=CI3
    <- cxt-info-eq-inversion CI1=CI3 O1=O3 T1=T3
    <- ty-eq-inversion T1=T3 NN1=NN3 A1=A3 C1=C
    <- clsmap`lookup-unique CML1 CML clsmap`eq/ C1=C FM1=FM
    <- predmap`lookup-unique PML1 PML predmap`eq/ C1=C CP1=CP
    <- fldmap`domain-unique FM1-DM FM-DM FM1=FM FS1=FS
    <- ({x} fldmap2perm-respects-eq (FS1=>Pi x) predmap`eq/ object`eq/ FM1=FM
         FS1=FS permission`eq/ (FS=>Pi x))
    <- make-encumbered-implies ME-SP make-encumbered/0 clsmap`eq/ predmap`eq/
      cxt`eq/ SP=E Pi2=>E E=>Pi2
    <- ({x} set2cond-implies (SP=>GFP x) set2cond/0 object`eq/ SP=E (GIMP3 x) (GIMP4 x))
    <- ({x} cxt`lookup-unique BL1 (BL2 x) cxt`eq/ nat`eq/ (CI1=CI2 x))
    <- ({x} cxt-info-eq-inversion (CI1=CI2 x) (O1=O2 x) TEQ)
    <- ({x} object`eq-symmetric (O1=O2 x) (O2=O1 x))
    <- ({x} permission-respects-object-eq
         ([y] (unitperm (nonlinear (objequal x y)))) (O2=O1 x) (EQV x))
    <- letRefTyping-helper/base/unique/L2L CP1=CP ([x] EQV2 x).

- : letRefTyping-helper/base/unique/L2 (s N) SZ
    (CM-B-S:cxt-unique-objset B NNx C S)
    (CML:clsmap`lookup CM C FM)
    (PML:predmap`lookup PM C CP)
    (FM-DM:fldmap`domain FM FS)
    (make-encumbered/U
      (ME-SP:make-encumbered CM PM B SP PiBP)
      (BL1:cxt`lookup B Nx (cxt-info/ O1 (ty/ NNx1 A1 C1)))
      (CML1:clsmap`lookup CM C1 FM1)
      (PML1:predmap`lookup PM C1 CP1)
      (FM1-DM:fldmap`domain FM1 FS1)
      ([x] FS1=>Pi x)
      N!<SP (SP+N=S:set`add SP Nx S))
    ([x] S=>GF x) %{=>}% _ ([x] fldmap2perm2/ FM-DM2 (FS2=>Pi x))
    ([x] implies/trans8
      (implies/combine (GIMP1 x) implies/reflexive)
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans8
          (implies/combine
            (implies/trans
              (implies/equiv (EQV x))
              (implies/nonlinear bimplies/objequal-symmetric))
            (implies/equiv equiv/identity))
          (implies/combine (implies/reflexive)
            (implies/combine
              (implies/trans
                (implies/equiv (equiv/symmetric equiv/identity))
                (implies/combine implies/reflexive (implies/self-implication)))
              (implies/reflexive)))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/objequal
              ([v] (combine (encumbered-fldperm v PF1 CP1)
                     (unitperm (encumbered (encumbered-fldperm v PF1 CP1)
                                 (encumbered-fldperm O1 PF1 CP1))))))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive add-encumber)
          (implies/equiv (EQV3 x))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans5
          (implies/combine implies/nonlinear2empty
            (implies/trans
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive
                (implies/trans (implies/equiv equiv/commute) (IMPP x)))))
          (implies/equiv (equiv/transitive equiv/commute equiv/identity))
          (implies/equiv (equiv/roll2))
          (implies/combine (implies/reflexive)
            (implies/trans
              (implies/equiv equiv/roll2)
              (implies/combine (implies/reflexive)
                (implies/trans3
                  (implies/equiv equiv/commute)
                  (add-encumber)
                  (implies/equiv-encumbered
                    (equiv/reflexive) (equiv/commute))))))
          (implies/equiv equiv/commute)))
      (implies/cond-pull)
      (implies/combine (implies/reflexive) (GIMP2 x))
      (implies/equiv equiv/commute))
    <- ({x} set2cond/U-inversion (S=>GF x) N!<SP SP+N=S (GFP x) (SP=>GFP x)
         (O2 x) T2 (BL2 x) (GIMP1 x) (GIMP2 x))
    <- cxt-unique-objset/U-inversion CM-B-S N!<SP SP+N=S CM-B-SP O3 A3 NNx3 BL3 _ _
    <- cxt`lookup-unique BL1 BL3 cxt`eq/ nat`eq/ CI1=CI3
    <- cxt-info-eq-inversion CI1=CI3 O1=O3 T1=T3
    <- ty-eq-inversion T1=T3 NN1=NN3 A1=A3 C1=C
    <- clsmap`lookup-unique CML1 CML clsmap`eq/ C1=C FM1=FM
    <- predmap`lookup-unique PML1 PML predmap`eq/ C1=C CP1=CP
    <- fldmap`domain-unique FM1-DM FM-DM FM1=FM FS1=FS
    <- ({x} fldmap2perm-respects-eq (FS1=>Pi x) predmap`eq/ object`eq/ FM1=FM
         FS1=FS permission`eq/ (FS=>Pi x))
    <- ({x} cxt`lookup-unique BL1 (BL2 x) cxt`eq/ nat`eq/ (CI1=CI2 x))
    <- ({x} cxt-info-eq-inversion (CI1=CI2 x) (O1=O2 x) TE)
    <- ({x} object`eq-symmetric (O1=O2 x) (O2=O1 x))
    <- ({x} permission-respects-object-eq
         ([y] (unitperm (nonlinear (objequal x y)))) (O2=O1 x) (EQV x))
    <- set`not-member-add-increases-size-converse SZ N!<SP SP+N=S SZP
    <- letRefTyping-helper/base/unique/L2 N SZP CM-B-SP CML PML FM-DM ME-SP SP=>GFP
      _ ([x] fldmap2perm2/ (FM-DM2:fldmap`domain FM FS2)
          (FS2=>Pi x)) IMPP
    <- fldmap`domain-unique FM-DM FM-DM2 fldmap`eq/ FS=FS2
    <- set`eq-transitive FS1=FS FS=FS2 FS1=FS2
    <- ({x} fldmap2perm-equiv (FS1=>Pi x) (FS2=>Pi x) predmap`eq/
         object`eq/ FM1=FM FS1=FS2 (EQV2 x))
    <- letRefTyping-helper/base/unique/L2L4 EQV2 CP1=CP ([x] EQV3 x).

%worlds (objvar) (letRefTyping-helper/base/unique/L2 _ _ _ _ _ _ _ _ _ _ _).
%total (ME) (letRefTyping-helper/base/unique/L2 _ _ _ _ _ _ ME _ _ _ _).


%theorem letRefTyping-helper/base/unique/L2*
  : forall* {CM} {B} {NN} {C} {FM} {PM} {S} {CP} {FS} {Pi} {GF} {PF}
    forall {N} {SZ: set`size S (s N)}
    {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {CM-B-S: cxt-unique-objset B NN C S}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FM-DM: fldmap`domain FM FS}
    {ME: make-encumbered CM PM B S Pi}
    {S=>GF: {x} set2cond B x S (GF x)}
    exists {PF2} {T2PF2: ty2perm2 CM PM (ty/ NN annot/unique C) PF2}
    {PF3} {FM2P2: {x} fldmap2perm2 PM x FM (PF3 x)}
    {IMP: {x} implies (combine (PF x) (combine (GF x) Pi))
          (combine (GF x)
            (combine (PF2 x)
              (unitperm (encumbered (encumbered-fldperm x PF3 CP) Pi))))}
    true.

- : letRefTyping-helper/base/unique/L2* _ SZ T2PF
    (CM-B-S:cxt-unique-objset B NNx C S)
    (CML:clsmap`lookup CM C FM)
    (PML:predmap`lookup PM C CP)
    (FM-DM:fldmap`domain FM FS)
    ME ([x] S=>GF x) _ (ty2perm2/unique CML PML ([x] FM=>PF x) T2PF)
    _ FM=>PF
    ([x] implies/trans3
      (implies/combine (implies/reflexive) (IMP x))
      (implies/equiv equiv/roll2)
      (implies/combine implies/reflexive (implies/equiv equiv/associate)))
    <- letRefTyping-helper/base/unique/L2 _ SZ CM-B-S CML PML FM-DM ME S=>GF
      _ ([x] FM=>PF x) ([x] IMP x).

%worlds (objvar) (letRefTyping-helper/base/unique/L2* _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L2* _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L3/L1
  : forall* {Pi1: object -> permission} {Pi2}
    forall {F: void}
    exists {EQV: {x} equiv (Pi1 x) (Pi2 x)}
    true.

%worlds (objvar) (letRefTyping-helper/base/unique/L3/L1 _ _).
%total { } (letRefTyping-helper/base/unique/L3/L1 _ _).


%%% This lemma says that for `fldmap2perm` if `FM` contains some entry
%%% whose key is not in `FS`, then after removing the entry, we can still
%%% get the relation.

%theorem letRefTyping-helper/base/unique/L3/L2
  : forall* {PM} {FM} {FM'} {FS} {Pf} {F} {T}
    forall {FM2P: {x} fldmap2perm PM x FM FS (Pf x)}
    {F!<FS: set`not-member FS F}
    {F!<FM': fldmap`fresh FM' F}
    {FM'+F=FM: fldmap`update FM' F T FM}
    exists {FM2P': {x} fldmap2perm PM x FM' FS (Pf x)}
    true.


%theorem letRefTyping-helper/base/unique/L3/L2/F
  : forall* {PM} {FM} {FS} {Pf}
    forall {F: void}
    exists {FM2P: {x} fldmap2perm PM x FM FS (Pf x)}
    true.

%worlds (objvar) (letRefTyping-helper/base/unique/L3/L2/F _ _).
%total { } (letRefTyping-helper/base/unique/L3/L2/F _ _).


- : letRefTyping-helper/base/unique/L3/L2 ([_] fldmap2perm/0) _ _ _ ([_] fldmap2perm/0).

%theorem letRefTyping-helper/base/unique/L3/L2/L
  : forall* {PM} {FM} {FM'} {FS} {Pf} {F} {F'} {T} {T'} {FS'} {PF}
    forall {FM2P: {x} fldmap2perm PM x FM FS' (Pf x)}
    {NM1: set`not-member FS' F'}
    {AD1: set`add FS' F' FS}
    {FML: fldmap`lookup FM F' T'}
    {T2PF: {x} ty2perm PM T' ([v] PF x v)}
    {NM: set`not-member FS F}
    {FM-F: fldmap`fresh FM' F}
    {FM-U: fldmap`update FM' F T FM}
    {B} {EQ?: nat`eq? F' F B}
    exists {FM2P: {x} fldmap2perm PM x FM' FS
      (combine (unitperm (precise-exists x F' ([v] PF x v))) (Pf x))}
    true.

- : letRefTyping-helper/base/unique/L3/L2/L _
    F!<FS' FS'+F=FS FML T2PF F!<FS _ _ _ nat`eq?/yes FM2P
    <- set`add-implies-member FS'+F=FS F<-FS
    <- set`member-not-member-contradiction F<-FS F!<FS V
    <- letRefTyping-helper/base/unique/L3/L2/F V FM2P.

- : letRefTyping-helper/base/unique/L3/L2/L
    (FM2P:{x} fldmap2perm PM x FM FS' (Pf x))
    (F'!<FS':set`not-member FS' F') (FS'+F=FS:set`add FS' F' FS)
    (FML:fldmap`lookup FM F' T') T2PF F!<FS F!<FM'
    (FM'+F+T=FM:fldmap`update FM' F T FM) _ (nat`eq?/no F'<>F)
    ([x] fldmap2perm/U ((FM2P':{x} fldmap2perm PM x FM' FS' (Pf x)) x)
      F'!<FS' FS'+F=FS (FML': fldmap`lookup FM' F' T') (T2PF x))
    <- set`update-preserves-not-member-converse F!<FS FS'+F=FS F!<FS'
    <- letRefTyping-helper/base/unique/L3/L2 FM2P F!<FS' F!<FM' FM'+F+T=FM FM2P'
    <- fldmap`update-preserves-lookup-converse FML FM'+F+T=FM F'<>F FML'.

- : letRefTyping-helper/base/unique/L3/L2
    ([x] fldmap2perm/U
      ((FM2P: {x} fldmap2perm PM x FM FS' (Pf x)) x)
      (NM:set`not-member FS' F')
      (UD:set`add FS' F' FS)
      (FML:fldmap`lookup FM F' T')
      ((T2PF:{x} ty2perm PM T' ([v] PF x v)) x))
    (NM1:set`not-member FS F)
    (FM-F:fldmap`fresh FM' F)
    (FM-U:fldmap`update FM' F T FM)
    FM2PP
    <- nat`eq?-total EQ?
    <- letRefTyping-helper/base/unique/L3/L2/L FM2P NM UD FML T2PF NM1 FM-F FM-U _ EQ? FM2PP.

%worlds (objvar) (letRefTyping-helper/base/unique/L3/L2 _ _ _ _ _)
(letRefTyping-helper/base/unique/L3/L2/L _ _ _ _ _ _ _ _ _ _ _).
%total (A B) (letRefTyping-helper/base/unique/L3/L2 A _ _ _ _)
(letRefTyping-helper/base/unique/L3/L2/L B _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L3/L3
  : forall* {FM} {N} {T1} {T2} {FM'}
    forall {U: fldmap`update FM N T1 (fldmap/+ N T1 FM')}
    {EQ: ty`eq T1 T2}
    exists {U: fldmap`update FM N T2 (fldmap/+ N T2 FM')}
    true.

- : letRefTyping-helper/base/unique/L3/L3 U ty`eq/ U.

%worlds (objvar) (letRefTyping-helper/base/unique/L3/L3 _ _ _).
%total { } (letRefTyping-helper/base/unique/L3/L3 _ _ _).


%theorem letRefTyping-helper/base/unique/L3/L4
  : forall* {PF1} {PF2} {F}
    forall {EQ: {x}{x1} permission`eq (PF1 x x1) (PF2 x1)}
    exists {EQV: {x} equiv (unitperm (precise-exists x F ([v] PF1 x v)))
                 (unitperm (precise-exists x F ([v] PF2 v)))}
    true.

- : letRefTyping-helper/base/unique/L3/L4 ([_][_] permission`eq/) ([_] equiv/reflexive).

%worlds (objvar) (letRefTyping-helper/base/unique/L3/L4 _ _).
%total { } (letRefTyping-helper/base/unique/L3/L4 _ _).


%theorem letRefTyping-helper/base/unique/L3/L5
  : forall* {PF1: object -> permission} {PF2} {F}
    forall {EQ: {o} permission`eq (PF1 o) (PF2 o)}
    exists {EQV: {x} equiv (unitperm (precise-exists x F ([o] PF1 o)))
                 (unitperm (precise-exists x F ([o] PF2 o)))}
    true.

- : letRefTyping-helper/base/unique/L3/L5 ([_] permission`eq/) ([_] equiv/reflexive).

%worlds (objvar) (letRefTyping-helper/base/unique/L3/L5 _ _).
%total { } (letRefTyping-helper/base/unique/L3/L5 _ _).


%theorem letRefTyping-helper/base/unique/L3/L6
  : forall* {CM} {PM} {FM} {CJ} {FS} {Pf}
    forall {FM-DM: fldmap`domain FM FS}
    {FM2G: fldmap2conj CM PM FM ([x] CJ x) PM}
    {FM2P: {x} fldmap2perm PM x FM FS (Pf x)}
    exists {IMP: {x} equiv (CJ x) (Pf x)}
    true.

- : letRefTyping-helper/base/unique/L3/L6 fldmap`domain/0
    fldmap2conj/0 ([_] fldmap2perm/0) ([_] equiv/reflexive).

- : letRefTyping-helper/base/unique/L3/L6 (fldmap`domain/+ FM-DM)
    (fldmap2conj/in FMP2CJ NN2P A2P SH PML) FM2P
    ([x] equiv/transitive3
      (equiv/combine (EQV2 x) (BIMPP x))
      (equiv/combine (equiv/symmetric (EQV3 x)) (equiv/reflexive))
      (equiv/symmetric (EQV x)))
    <- fldmap`shift-preserves-domain FM-DM SH _ S-SH FMP-DM
    <- set`shift-implies-not-member S-SH NM
    <- set`shift-implies-update S-SH U
    <- ({x} fldmap2perm/U-inversion (FM2P x) NM U _ (FM2PP' x) _ FML (PFP x) (T2PFP x) (EQV x))
    <- ty2perm-no-var ([x] T2PFP x) PF EQ T2PF
    <- letRefTyping-helper/base/unique/L3/L4 EQ EQV3
    <- fldmap`shift-implies-fresh SH FM-F
    <- fldmap`shift-implies-update SH FM-U'
    <- fldmap`lookup-unique (fldmap`lookup/= nat`eq/) FML fldmap`eq/ nat`eq/ TE
    <- ty`eq-symmetric TE TE2
    <- letRefTyping-helper/base/unique/L3/L3 FM-U' TE2 FM-U
    <- letRefTyping-helper/base/unique/L3/L2 FM2PP' NM FM-F FM-U FM2PP
    <- letRefTyping-helper/base/unique/L3/L6 FMP-DM FMP2CJ FM2PP ([x] BIMPP x)
    <- ty2perm-deterministic (ty2perm/ PML NN2P A2P) T2PF predmap`eq/ TE PEQ
    <- letRefTyping-helper/base/unique/L3/L5 PEQ EQV2.

- : letRefTyping-helper/base/unique/L3/L6 (fldmap`domain/+ FM-DM)
    (fldmap2conj/out (FM2J:fldmap2conj _ _ _ _ PM)
      (FM2JF:{p:clspred} fldmap2conj _ (PMF1 p) _ ([o:object] CJ p o) (PMF2 p))
      U _ _ _ _ (F:predmap`fresh PM C)) FM2P EQV
    <- predmap`size-total SZ0
    <- ({p} predmap`fresh-update-increases-size SZ0 F (U p) (SZ1 p))
    <- ({p} fldmap2conj-implies-predmap-leq (FM2JF p) (LEQ1 p))
    <- fldmap2conj-implies-predmap-leq FM2J LEQ2
    <- predmap`leq-transitive (LEQ1 (conj2pred CJ)) LEQ2 LEQ
    <- predmap`leq-implies-size-le LEQ (SZ1 (conj2pred CJ)) SZ0 SZ-LE
    <- ge-self-succ-contradiction SZ-LE V
    <- letRefTyping-helper/base/unique/L3/L1 V EQV.

%worlds (objvar) (letRefTyping-helper/base/unique/L3/L6 _ _ _ _).
%total (FM2G) (letRefTyping-helper/base/unique/L3/L6 _ FM2G _ _).


%theorem letRefTyping-helper/base/unique/L3
  : forall* {CM} {PM} {FM} {CJ} {FS} {Pf}
    forall {DM: fldmap`domain FM FS}
    {FM2G: fldmap2conj CM PM FM ([x] CJ x) PM}
    {FM2P: {x} fldmap2perm PM x FM FS (Pf x)}
    exists {IMP: {x} bimplies true (nested (CJ x) x all) (nested (Pf x) x all)}
    true.

- : letRefTyping-helper/base/unique/L3 DM FM2G FM2P ([x] bimplies/nested/eq (EQV x))
    <- letRefTyping-helper/base/unique/L3/L6 DM FM2G FM2P EQV.

%worlds (objvar) (letRefTyping-helper/base/unique/L3 _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L3 _ _ _ _).


%theorem letRefTyping-helper/base/unique/L4L1L1
  : forall {CP}
    exists {IMP: {x} implies
                 (combine
                   (unitperm
                     (nonlinear (neg (objequal x null))))
                   (combine (allperm x) (one-predcall CP x)))
                 (unitperm (conditional (objequal x null) empty
                             (combine (allperm x) (one-predcall CP x))))}
    true.

- : letRefTyping-helper/base/unique/L4L1L1 _ ([_] implies/cond-intro-neg).

%worlds (objvar) (letRefTyping-helper/base/unique/L4L1L1 _ _).
%total { } (letRefTyping-helper/base/unique/L4L1L1 _ _).


%theorem letRefTyping-helper/base/unique/L4L1
  : forall* {CM} {FM} {PM} {C} {FS} {NN} {PF}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`domain FM FS}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) ([x] PF x)}
    exists {PF2} {PF3}
    {T2PF: ty2perm2 CM PM (ty/ NN annot/unique C) ([x] PF2 x)}
    {M2P: {x} fldmap2perm PM x FM FS (PF3 x)}
    {IMP: {x} implies (PF x) (combine (PF2 x)
       (unitperm (conditional (objequal x null) empty (PF3 x))))}
    true.

- : letRefTyping-helper/base/unique/L4L1 CM-CM CM2PM CML (FM-DM:fldmap`domain FM FS)
    (ty2perm/ PML nn2perm/yes annot2perm/unique) _ _
    (ty2perm2/unique CML PML ([x] fldmap2perm2/ FM-DM (FS=>PF x))
      (ty2perm/ PML nn2perm/yes annot2perm/borrow)) FS=>PF
     ([x:object] implies/trans6
      (implies/combine (implies/duplicate)
        (implies/combine (implies/reflexive) (implies/duplicate)))
      (implies/equiv
        (equiv/transitive4
          (equiv/combine equiv/reflexive equiv/associate)
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive equiv/roll2)
          (equiv/associate)))
      (implies/combine
        (implies/trans5
          (IMP x)
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/equiv
              (equiv/symmetric equiv/identity))
            (implies/trans7
              (implies/combine (implies/reflexive)
                (implies/trans3
                  (implies/nonlinear bimplies/conj-duplicate)
                  (implies/conj2combine)
                  (implies/combine
                    (implies/trans
                      (implies/equiv (EQV x))
                      (implies/nonlinear
                        (bimplies/trans4
                          (bimplies/predcall/Y/inline)
                          (bimplies/predcall/+/inline x)
                          (bimplies/predcall/0/inline)
                          (BIMP x))))
                    (implies/reflexive))))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans
                  (implies/equiv equiv/commute)
                  (implies/carve))
                (implies/reflexive))
              (implies/equiv equiv/commute)
              (implies/combine (implies/duplicate) (implies/reflexive))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/trans
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/equiv (equiv/commute)))
                (implies/reflexive))))
          (implies/cond-distribute)
          (implies/combine (implies/reflexive)
            (implies/trans3
              (implies/cond-gen-inner)
              (implies/cond-inner
                (bimplies/reflexive)
                (bimplies/reflexive)
                (implies/combine implies/nonlinear2empty implies/reflexive)
                (implies/trans
                  (implies/combine
                    (implies/nonlinear2empty)
                    (implies/trans3
                      (implies/equiv equiv/commute)
                      (implies/equiv (equiv/symmetric equiv/associate))
                      (implies/combine implies/reflexive add-encumber)))
                  (implies/equiv (equiv/transitive equiv/commute equiv/identity))))
              (implies/cond-distribute)))
          (implies/equiv
            (equiv/transitive
              (equiv/combine equiv/reflexive equiv/commute)
              (equiv/associate))))
        (implies/trans
          (implies/combine implies/reflexive implies/nonlinear2empty)
          (implies/equiv equiv/identity)))
       (implies/equiv
         (equiv/transitive3
           (equiv/commute)
           (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))
           (equiv/associate)))
       (implies/combine
         (implies/trans3
           (implies/combine implies/duplicate implies/cond-neg)
           (implies/equiv (equiv/symmetric equiv/associate))
           (implies/combine implies/reflexive implies/cond-elim))
         (implies/reflexive))
       (implies/equiv equiv/associate))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- set`leq-reflexive _ FS<=FS
     <- ({x:object} fldmap2perm-total CM-CM CM2PM CML FM-DM FS<=FS _ (FS=>PF x))
     <- clsmap-predmap-implies-lookup-format CM-PM PML _ PMLP ([x] PEQ x)
     <- ({x} permission`eq-implies-equiv (PEQ x) (EQV x))
     <- clsmap2predmap-implies-fldmap2conj CM2PM PMLP CML FM=>CJ
     <- letRefTyping-helper/base/unique/L3 FM-DM FM=>CJ FS=>PF ([x] BIMP x)
     <- letRefTyping-helper/base/unique/L4L1L1 _ IMP.

- : {FS=>PF: {x} fldmap2perm PM x FM FS (PF3 x)}
    letRefTyping-helper/base/unique/L4L1 CM-CM CM2PM CML (FM-DM:fldmap`domain FM FS)
    (ty2perm/ PML nn2perm/may annot2perm/unique) _ _
    (ty2perm2/unique CML PML ([x] fldmap2perm2/ FM-DM (FS=>PF x))
      (ty2perm/ PML nn2perm/may annot2perm/borrow)) FS=>PF
    ([x] implies/trans4
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv
          (equiv/symmetric equiv/identity))
        (implies/trans7
          (implies/combine (implies/reflexive)
            (implies/trans3
              (implies/nonlinear bimplies/conj-duplicate)
              (implies/conj2combine)
              (implies/combine
                (implies/trans
                  (implies/equiv (EQV x))
                  (implies/nonlinear
                    (bimplies/trans4
                      (bimplies/predcall/Y/inline)
                      (bimplies/predcall/+/inline x)
                      (bimplies/predcall/0/inline)
                      (BIMP x))))
                (implies/reflexive))))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/equiv equiv/commute)
              (implies/carve))
            (implies/reflexive))
          (implies/equiv equiv/commute)
          (implies/combine (implies/duplicate) (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/trans
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/equiv (equiv/commute)))
            (implies/reflexive))))
      (implies/cond-distribute)
      (implies/combine (implies/reflexive)
        (implies/trans3
          (implies/cond-gen-inner)
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/combine implies/nonlinear2empty implies/reflexive)
            (implies/trans
              (implies/combine
                (implies/nonlinear2empty)
                (implies/trans3
                  (implies/equiv equiv/commute)
                  (implies/equiv (equiv/symmetric equiv/associate))
                  (implies/combine implies/reflexive add-encumber)))
              (implies/equiv (equiv/transitive equiv/commute equiv/identity))))
          (implies/cond-distribute)))
      (implies/equiv
        (equiv/transitive
          (equiv/combine equiv/reflexive equiv/commute)
          (equiv/associate))))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- set`leq-reflexive _ FS<=FS
     <- ({x:object} fldmap2perm-total CM-CM CM2PM CML FM-DM FS<=FS _ (FS=>PF x))
     <- clsmap-predmap-implies-lookup-format CM-PM PML _ PMLP ([x] PEQ x)
     <- ({x} permission`eq-implies-equiv (PEQ x) (EQV x))
     <- clsmap2predmap-implies-fldmap2conj CM2PM PMLP CML FM=>CJ
     <- letRefTyping-helper/base/unique/L3 FM-DM FM=>CJ FS=>PF ([x] BIMP x).

%worlds (objvar) (letRefTyping-helper/base/unique/L4L1 _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L4L1 _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L4L2
  : forall* {CM} {PM} {FM} {PF1} {NN} {B:object -> cxt} {N} {C} {FS} {A}
    forall {CML: clsmap`lookup CM C FM}
    {M2P: {x} fldmap2perm PM x FM FS (PF1 x)}
    {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ NN A C))}
    exists {M} {PF3} {M=>PF: nat+set2capmap N FS cap/write M}
    {M=>PF3: {x} capmap2perm CM PM (B x) M (PF3 x)}
    {PF2=>PF3: {x} implies
               (unitperm
                 (conditional
                   (objequal x null)
                   empty
                   (PF1 x))) (PF3 x)}
    true.

- : letRefTyping-helper/base/unique/L4L2
    _ ([_] fldmap2perm/0) _ _ _
    nat+set2capmap/0 ([_] capmap2perm/0) ([_] implies/cond-equal).

- : letRefTyping-helper/base/unique/L4L2
    CML ([x] fldmap2perm/U (SP=>PFP x) F!<SP SP+F=S FML (T2PF x))
    ([x] BL x) _ _
    (nat+set2capmap/U N+SP=>MP (N+F=>K:pair2nat (pair/ N F) K)
      F!<SP SP+F=S MP+K=M)
    ([x] capmap2perm/U (MP=>PF3P x) N+F=>K (BL x) (create-fldperm/ CML FML (T2PF x))
      cap2frac/write K!<MP MP+K=M)
    ([x] implies/trans3
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/combine
          (implies/equiv (equiv/symmetric equiv/one))
          (implies/reflexive)))
      (implies/cond-distribute)
      (implies/combine implies/reflexive (IMPP x)))
    <- letRefTyping-helper/base/unique/L4L2 CML SP=>PFP
      BL _ _ N+SP=>MP MP=>PF3P IMPP
    <- pair2nat-total N+F=>K
    <- nat+set2capmap-preserves-fresh N+SP=>MP F!<SP N+F=>K K!<MP
    <- capmap`update-total MP+K=M.

%worlds (objvar) (letRefTyping-helper/base/unique/L4L2 _ _ _ _ _ _ _ _).
%total (A) (letRefTyping-helper/base/unique/L4L2 _ A _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L4L3
  : forall* {X} {PF: object -> permission} {Q}
    forall {X2Q: cap2frac X Q}
    {EQ: cap`eq X cap/write}
    exists {EQV: {x} equiv (scale Q (PF x)) (PF x)}
    true.

- : letRefTyping-helper/base/unique/L4L3 _ cap`eq/ ([_] equiv/one).

%worlds (objvar) (letRefTyping-helper/base/unique/L4L3 _ _ _).
%total { } (letRefTyping-helper/base/unique/L4L3 _ _ _).


%theorem letRefTyping-helper/base/unique/L4
  : forall* {CM} {NN} {C} {FM} {FS} {B0} {B2} {N} {M5}
    {M0} {M1} {M3} {PM} {Out}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {N!<B1: cxt`fresh B0 N}
    {B1+N=B2: {x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/unique C)) (B2 x)}
    {N>0: nat`gt N z}
    {N+FS=M3: nat+set2capmap N FS cap/write M3}
    {M5-M3=M4: capmap-split M5 M3 M0}
    {MIN-X: capmap-min M1 cap/write}
    {CM-Rslt: clsmap-result CM
        (result/expr (reftype/ NN C (targets/unique set/0 M1)) (env/ B0 M0))}
    {Rslt=>Out: result2output CM PM
        (result/expr (reftype/ NN C (targets/unique set/0 M1)) (env/ B0 M0)) Out}
    exists {Pi} {CM-V: {x} clsmap-env CM (env/ (B2 x) M5)}
    {V=>Pi: {x} env2input CM PM (env/ (B2 x) M5) (Pi x)}
    {TRANS: transform Out (output/exists [x] (output/expr x (Pi x)))}
    true.

- : {B0+N=B2: {x} cxt`update B0 N (cxt-info/ x _) (B2 x)}
    letRefTyping-helper/base/unique/L4 CM-CM CM2PM (CML:clsmap`lookup CM C FM)
    (FM-DM:fldmap`domain FM FS) (N!<B0: cxt`fresh B0 N) ([x] B0+N=B2 x) GT
    (N+FS=M3: nat+set2capmap N FS cap/write M3)
    (capmap-split/ M3^M0 M3+M0=M5)
    (MIN-M1=W: capmap-min M1 cap/write)
    (clsmap-result/expr (CM-B0: clsmap-cxt CM B0)
      (clsmap-cxt-reftype/unique (CML2:clsmap`lookup CM C FM2)
        cxt-unique-objset/0 CM-B0-M1 WF) CM-B0-M0)
    (result2output/unique/2 SZ-M1 (T2PF:ty2perm PM _ PF)
      ([_] set2cond/0) (B0=>PiB0:cxt2perm CM PM B0 PiB0)
      (B0+M0=>PiM0:capmap2perm CM PM B0 M0 PiM0)
      (B0+M1=>PiM1:capmap2perm CM PM B0 M1 PiM1) (MIN-M1=X:capmap-min M1 X) (X2Q:cap2frac X Q))
    %{=>}% _
    ([x] clsmap-env/
      (clsmap-cxt/U (CM-B0:clsmap-cxt CM B0)
        (clsmap-ty/ CML) N!<B0 (B0+N=B2 x)) (CM-B2-M5 x))
    ([x] env2input/
      (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B2 x) (T2PF2:ty2perm2 CM PM _ PF2))
      (B2+M5=>PiM5 x))
    (transform/inside [x]
      (transform/trans
        (transform/inside [r]
          (transform/trans
            (transform/implies
              (implies/trans5
                (implies/combine (implies/reflexive)
                  (implies/trans6
                    (implies/combine
                      (implies/trans3
                        (implies/cond-gen-inner)
                        (implies/cond-inner
                          (bimplies/reflexive)
                          (bimplies/reflexive)
                          (implies/equiv equiv/identity)
                          (implies/trans3
                            (implies/combine
                              (implies/nonlinear2empty)
                              (implies/contradiction))
                            (implies/equiv equiv/commute)
                            (implies/equiv equiv/identity)))
                        (implies/cond-equal))
                      (implies/equiv equiv/associate))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans3
                        (implies/combine
                          (implies/nonlinear bimplies/objequal-symmetric)
                          (implies/reflexive))
                        (implies/objequal
                          ([y] (combine (scale Q (PF y))
                                 (unitperm (encumbered (scale Q (PF y)) PiM1)))))
                        (implies/combine
                          (implies/equiv (EQV x))
                          (implies/equiv-encumbered (EQV x) equiv/reflexive)))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/trans
                        (IMP x)
                        (implies/combine implies/reflexive (IMP2 x)))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))))
                (implies/equiv equiv/associate)
                (implies/combine (implies/reflexive)
                  (implies/trans
                    (implies/equiv equiv/roll2)
                    (implies/combine (implies/reflexive)
                      (implies/equiv (PiM3+PiM0<=>PiM5 x)))))
                (implies/equiv equiv/roll2)
                (implies/combine
                  (implies/reflexive)
                  (implies/combine
                    (implies/equiv equiv/commute)
                    (implies/reflexive)))))
            (transform/drop)))
        (transform/rem-unused)))
    <- ({x} cxt`update-implies-lookup (B0+N=B2 x) (B2L x))
    <- letRefTyping-helper/base/unique/L4L1 CM-CM CM2PM CML FM-DM T2PF
      _ _ T2PF2 ([x] FS=>PF x) ([x] IMP x)
    <- letRefTyping-helper/base/unique/L4L2 CML FS=>PF B2L
      M3P PiM3 N+FS=M3P ([x] M3P=>PiM3 x) ([x] IMP2 x)
    <- nat+set2capmap-unique N+FS=M3P N+FS=M3 nat`eq/ set`eq/ cap`eq/ M3P=M3
    <- ({x} capmap2perm-respects-eq (M3P=>PiM3 x) clsmap`eq/ predmap`eq/ cxt`eq/
         M3P=M3 permission`eq/ (B2+M3=>PiM3 x))
    <- ({x} cxt-fresh-update-preserves-capmap2perm B0+M0=>PiM0 N!<B0 (B0+N=B2 x)
         (B2+M0=>PiM0 x))
    <- ({x} capmap-split-implies-permission-combine-converse
         (capmap-split/ M3^M0 M3+M0=M5) (B2+M3=>PiM3 x) (B2+M0=>PiM0 x) (PiM5 x)
         (B2+M5=>PiM5 x) (PiM3+PiM0<=>PiM5 x))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capmap CM-B0-M0 N!<B0
         (B0+N=B2 x) (CM-B2-M0 x))
    <- ({x} nat+set2capmap-implies-clsmap-cxt-capmap
         CM-CM CML FM-DM N+FS=M3 (B2L x) GT (CM-B2-M3 x))
    <- ({x} join-preserves-clsmap-cxt-capmap (CM-B2-M3 x) (CM-B2-M0 x)
         M3+M0=M5 (CM-B2-M5 x))
    <- capmap-min-unique MIN-M1=X MIN-M1=W cap`eq/ capmap`eq/ (X=W:cap`eq X cap/write)
    <- letRefTyping-helper/base/unique/L4L3 X2Q X=W EQV.

%worlds (objvar) (letRefTyping-helper/base/unique/L4 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L4 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L5L2
  : forall* {CM} {PM} {B} {NN} {C} {S} {GF} {PiB}
    forall {K} {SZ: set`size S (s K)}
    {CM-B-S: cxt-unique-objset B NN C S}
    {S=>GF: {x} set2cond B x S (GF x)}
    {B=>PiB: cxt2perm CM PM B PiB}
    exists {PF} {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {IMP: {x} implies (combine PiB (GF x)) (combine (PF x) (combine PiB (GF x)))}
    true.

%theorem letRefTyping-helper/base/unique/L5L2L1
  : forall* {O} {OP}
    forall {EQ: {x} object`eq (OP x) O}
    exists {EQV: {x} equiv (unitperm (nonlinear (objequal x (OP x))))
                 (unitperm (nonlinear (objequal x O)))}
    true.

- : letRefTyping-helper/base/unique/L5L2L1 ([_] object`eq/) ([_] equiv/reflexive).

%worlds (objvar) (letRefTyping-helper/base/unique/L5L2L1 _ _).
%total { } (letRefTyping-helper/base/unique/L5L2L1 _ _).


%theorem letRefTyping-helper/base/unique/L5L2L2
  : forall* {B} {N} {OF:object -> object} {TF}
    forall {BL: {x} cxt`lookup B N (cxt-info/ (OF x) TF)}
    exists {O} {T} {BL: cxt`lookup B N (cxt-info/ O T)}
    {EQ: {x} object`eq (OF x) O}
    true.

- : letRefTyping-helper/base/unique/L5L2L2
    ([_] cxt`lookup/= N1=N2) _ _ (cxt`lookup/= N1=N2) ([_] object`eq/).

- : letRefTyping-helper/base/unique/L5L2L2
    ([x] cxt`lookup/> (BL x) P) _ _ (cxt`lookup/> BLP P) EQF
    <- letRefTyping-helper/base/unique/L5L2L2 BL _ _ BLP EQF.

%worlds (objvar) (letRefTyping-helper/base/unique/L5L2L2 _ _ _ _ _).
%total (L) (letRefTyping-helper/base/unique/L5L2L2 L _ _ _ _).


- : letRefTyping-helper/base/unique/L5L2 (s _) SZ
    (cxt-unique-objset/U CM-B-SP
      (BL:cxt`lookup B N (cxt-info/ O _)) U-OR-B (NN-LEQ:nonnull`leq NN NNP) N!<SP SP+N=S)
    ([x] S=>GF x) (B=>PiB:cxt2perm CM PM B PiB) %{=>}% PF2 T2PF2
    ([x] implies/trans7
      (implies/combine (implies/reflexive) (GIMP1 x))
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans3
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (implies/trans
                  (implies/equiv (EQV2 x))
                  (implies/nonlinear bimplies/objequal-symmetric))
                (IMP2))
              (implies/objequal ([y] (combine (PF y) PiB))))
            (implies/reflexive))
          (implies/combine
            (implies/combine (IMP3 x) implies/reflexive)
            implies/reflexive))
        (implies/trans3
          (implies/combine
            (implies/nonlinear2empty)
            (implies/trans3
              (IMPP x)
              (implies/combine
                (implies/equiv (PEQV x))
                (implies/reflexive))
              (implies/equiv equiv/associate)))
          (implies/equiv equiv/commute)
          (implies/equiv equiv/identity)))
      (implies/cond-pull)
      (implies/combine (implies/reflexive) (GIMP2 x))
      (implies/equiv (equiv/symmetric equiv/associate)))
    <- ({x} set2cond/U-inversion (S=>GF x) N!<SP SP+N=S (GFP x) (SP=>GFP x)
         (OP x) _ (BLP x) (GIMP1 x) (GIMP2 x))
    <- cxt2perm-lookup-not-shared-can-duplicate B=>PiB BL U-OR-B PF T2PF IMP2
    <- letRefTyping-helper/base/unique/L5L2L2 BLP OPP _ BLPP ([x] OP=OPP x)
    <- cxt`lookup-unique BLPP BL cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE (OPP=O:object`eq OPP O) _
    <- ({x} object`eq-transitive (OP=OPP x) OPP=O (OP=O x))
    <- letRefTyping-helper/base/unique/L5L2L1 OP=O EQV2
    <- nonnull-leq-implies-permission-equiv NN-LEQ T2PF PF2 T2PF2 ([x] IMP3 x)
    <- set`not-member-add-increases-size-converse SZ N!<SP SP+N=S SZP
    <- letRefTyping-helper/base/unique/L5L2 _ SZP CM-B-SP SP=>GFP B=>PiB PFP T2PF2P IMPP
    <- ty2perm-deterministic T2PF2P T2PF2 predmap`eq/ ty`eq/ ([x] PEQ x)
    <- ({x} permission`eq-implies-equiv (PEQ x) (PEQV x)).

- : letRefTyping-helper/base/unique/L5L2 z SZ
    (cxt-unique-objset/U CM-B-SP
      (BL:cxt`lookup B N (cxt-info/ O _)) U-OR-B (NN-LEQ:nonnull`leq NN NNP) N!<SP SP+N=S)
    ([x] S=>GF x) (B=>PiB:cxt2perm CM PM B PiB) %{=>}% _ T2PF2
    ([x] implies/trans8
      (implies/combine (IMP2) (GIMP1 x))
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans
          (implies/combine
            (implies/trans
              (implies/equiv (EQV2 x))
              (implies/nonlinear bimplies/objequal-symmetric))
            (implies/reflexive))
          (implies/objequal ([y] (combine (combine (PF y) PiB) empty))))
        (implies/trans
          (implies/combine (implies/nonlinear2empty)
            (implies/trans3
              (implies/combine (implies/reflexive)
                (implies/trans
                  (GIMP3 x)
                  (implies/duplicate)))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans3
                  (implies/equiv (equiv/commute))
                  (implies/combine
                    (implies/contradiction)
                    (implies/reflexive))
                  (implies/objequal ([y] (combine (PF y) PiB))))
                (GIMP4 x))))
          (implies/equiv (equiv/transitive equiv/commute equiv/identity))))
      (implies/cond-pull)
      (implies/combine
        (implies/reflexive)
        (GIMP2 x))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine (IMP3 x) implies/reflexive))
    <- set`not-member-add-size-implies-empty N!<SP SP+N=S SZ (SP=E:set`eq SP set/0)
    <- ({x} set2cond/U-inversion (S=>GF x) N!<SP SP+N=S (GFP x) (SP=>GFP x)
         (OP x) _ (BLP x) (GIMP1 x) (GIMP2 x))
    <- cxt2perm-lookup-not-shared-can-duplicate B=>PiB BL U-OR-B PF T2PF IMP2
    <- letRefTyping-helper/base/unique/L5L2L2 BLP OPP _ BLPP ([x] OP=OPP x)
    <- cxt`lookup-unique BLPP BL cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE (OPP=O:object`eq OPP O) _
    <- ({x} object`eq-transitive (OP=OPP x) OPP=O (OP=O x))
    <- letRefTyping-helper/base/unique/L5L2L1 OP=O EQV2
    <- ({x} set2cond-implies (SP=>GFP x) set2cond/0 object`eq/ SP=E (GIMP3 x) (GIMP4 x))
    <- nonnull-leq-implies-permission-equiv NN-LEQ T2PF PF2 T2PF2 ([x] IMP3 x).

%worlds (objvar) (letRefTyping-helper/base/unique/L5L2 _ _ _ _ _ _ _ _).
%total (N) (letRefTyping-helper/base/unique/L5L2 N _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L5
  : forall* {CM} {NN} {C} {FM} {FS} {S} {M2} {B0} {B1} {B2} {N} {M5}
    {M0} {M1} {M3} {M4} {PM} {Out} {SK} {MK}
    forall {SZ-S: set`size S (s SK)}
    {SZ-M1: capmap`size M1 (s MK)}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {S+FS=M2: set+set2capmap S FS cap/write M2}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    {N!<B1: cxt`fresh B1 N}
    {B1+N=B2: {x} cxt`update B1 N (cxt-info/ x (ty/ NN annot/unique C)) (B2 x)}
    {N>0: nat`gt N z}
    {M0-M2=M4: capmap-split M0 M2 M4}
    {N+FS=M3: nat+set2capmap N FS cap/write M3}
    {M5-M3=M4: capmap-split M5 M3 M4}
    {MIN-X: capmap-min M1 cap/write}
    {CM-Rslt: clsmap-result CM (result/expr (reftype/ NN C (targets/unique S M1)) (env/ B0 M0))}
    {Rslt=>Out: result2output CM PM
                (result/expr (reftype/ NN C (targets/unique S M1)) (env/ B0 M0)) Out}
    exists {Pi} {CM-V: {x} clsmap-env CM (env/ (B2 x) M5)}
    {V=>Pi: {x} env2input CM PM (env/ (B2 x) M5) (Pi x)}
    {TRANS: transform Out (output/exists [x] (output/expr x (Pi x)))}
    true.

- : letRefTyping-helper/base/unique/L5 SZ-S _
    CM-CM CM2PM (CML:clsmap`lookup CM C FM)
    (FM-DM:fldmap`domain FM FS)
    (S+FS=>M2: set+set2capmap S FS cap/write M2)
    (B0-S=B1: cxt-remove-unique B0 S B1)
    (N!<B1: cxt`fresh B1 N) ([x] B1+N=B2 x) GT
    (M0-M2=M4:capmap-split M0 M2 M4)
    (N+FS=M3: nat+set2capmap N FS cap/write M3)
    (capmap-split/ M3^M4 M3+M4=M5)
    (MIN-M1=W: capmap-min M1 cap/write)
    (clsmap-result/expr (CM-B0: clsmap-cxt CM B0)
      (clsmap-cxt-reftype/unique (CML2:clsmap`lookup CM C FM2)
        (CM-B0-S) CM-B0-M1 WF) CM-B0-M0)
    (result2output/unique/2 SZ-M1 (ty2perm/ (PML:predmap`lookup PM C CP)
                                    (NN2P:nn2perm _ _ PF) annot2perm/unique)
      ([x] B0+S=>GF x) (B0=>PiB0:cxt2perm CM PM B0 PiB0)
      (B0+M0=>PiM0:capmap2perm CM PM B0 M0 PiM0)
      (B0+M1=>PiM1:capmap2perm CM PM B0 M1 PiM1)
      (MIN-M1=X:capmap-min M1 X) (X2Q:cap2frac X Q))
    %{=>}% _
    ([x] clsmap-env/
      (clsmap-cxt/U (CM-B1:clsmap-cxt CM B1)
        (clsmap-ty/ CML) N!<B1 (B1+N=B2 x)) (CM-B2-M5 x))
    ([x] env2input/
      (cxt2perm/U B1=>PiB1 N!<B1 (B1+N=B2 x) (T2PF2:ty2perm2 CM PM _ PF2))
      (B2+M5=>PiM5 x))
    (transform/inside [x]
      (transform/trans
        (transform/inside [o]
          (transform/trans
            (transform/implies
              (implies/trans7
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine (implies/equiv (EQV o))
                        (implies/combine
                          (implies/equiv-encumbered (EQV o) equiv/reflexive)
                          (implies/reflexive))))
                    (implies/equiv (equiv/commute))))
                (implies/equiv (equiv/associate))
                (implies/cond-push)
                (implies/cond-gen-inner)
                (implies/cond-inner
                  (bimplies/reflexive)
                  (bimplies/reflexive)
                  (implies/trans8
                    (implies/combine (implies/reflexive)
                      (implies/equiv
                        (equiv/transitive
                          (equiv/identity)
                          (equiv/roll2))))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans
                        (implies/combine
                          (implies/nonlinear bimplies/objequal-symmetric)
                          (implies/reflexive))
                        (implies/objequal ([v] (PF CP v))))
                      (implies/reflexive))
                    (implies/combine
                      (implies/trans (IMP3 x)
                        (implies/combine implies/reflexive (IMP4 x)))
                      (implies/combine
                        (implies/reflexive)
                        (implies/combine (implies/reflexive)
                          (implies/equiv
                            (equiv/transitive
                              (PiM0<=>PiM2+PiM4)
                              (equiv/commute))))))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine (implies/reflexive)
                      (implies/trans3
                        (implies/combine (implies/equiv (PiM3P<=>PiM3 x))
                          (implies/equiv (equiv/roll3)))
                        (implies/equiv equiv/associate)
                        (implies/combine (implies/equiv (PiM3+PiM4<=>PiM5 x))
                          (implies/reflexive))))
                    (implies/combine (implies/reflexive)
                      (implies/combine (implies/reflexive)
                        (implies/trans
                          (implies/combine
                            (implies/equiv (PiB0<=>PiB1+PiS))
                            (implies/reflexive))
                          (implies/equiv (equiv/symmetric equiv/associate)))))
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/associate)
                        (equiv/associate)
                        (equiv/combine equiv/swap equiv/reflexive))))
                  (implies/trans9
                    (implies/combine
                      (implies/nonlinear2empty)
                      (implies/equiv (equiv/commute)))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/identity)))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/roll2)
                        (equiv/associate)))
                    (implies/combine
                      (implies/trans4
                        (IMP5 x)
                        (implies/combine (implies/reflexive)
                          (implies/trans
                            (implies/combine (implies/equiv (PiB0<=>PiB1+PiS))
                              (implies/reflexive))
                            (implies/equiv
                              (equiv/transitive3
                                (equiv/symmetric equiv/associate)
                                (equiv/combine equiv/reflexive equiv/commute)
                                (equiv/commute)))))
                        (implies/equiv (equiv/associate))
                        (implies/combine
                          (IMP2 x) (implies/reflexive)))
                      (implies/combine (implies/reflexive)
                        (implies/combine (implies/reflexive)
                          (implies/equiv
                            (PiM0<=>PiM2+PiM4)))))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine (equiv/symmetric equiv/associate) equiv/reflexive)
                        (equiv/symmetric equiv/associate)))
                    (implies/combine (implies/reflexive)
                      (implies/equiv (equiv/roll4)))
                    (implies/equiv equiv/associate)
                    (implies/combine (IMP x)
                      (implies/equiv
                        (equiv/transitive
                          (equiv/symmetric equiv/associate)
                          (equiv/combine equiv/reflexive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/commute)))))))
                    (implies/trans4
                      (implies/equiv (equiv/symmetric equiv/associate))
                      (implies/combine (implies/reflexive)
                        (implies/equiv (equiv/symmetric equiv/associate)))
                      (implies/combine implies/reflexive % X3
                        (implies/trans3
                          (implies/combine (implies/reflexive) % PiM3
                            (implies/equiv equiv/roll5))
                          (implies/equiv equiv/associate)
                          (implies/combine (implies/equiv (PiM3+PiM4<=>PiM5 x))
                            (implies/reflexive))))
                      (implies/equiv
                        (equiv/transitive7
                          (equiv/roll4)
                          (equiv/combine
                            (equiv/combine (EQV2 x) equiv/reflexive)
                            (equiv/roll4))
                          (equiv/symmetric equiv/associate)
                          (equiv/combine equiv/reflexive equiv/roll2)
                          (equiv/associate)
                          (equiv/combine equiv/reflexive
                            equiv/roll3)
                          (equiv/associate))))))
                (implies/cond-pull)
                (implies/equiv equiv/commute)))
            (transform/drop)))
        (transform/rem-unused)))
    <- cxt-remove-unique-preserves-clsmap-cxt CM-B0 B0-S=B1 CM-B1
    <- cxt-remove-unique-implies-make-encumbered
      B0-S=B1 B0=>PiB0 PiB1 PiS B1=>PiB1 ME-B0-S=PiS
      (PiB0<=>PiB1+PiS:equiv PiB0 (combine PiB1 PiS))
    <- ({x} cxt-remove-unique-preserves-set2cond (B0+S=>GF x) B0-S=B1 (B1+OS=>GF x))
    <- capmap-split-implies-leq M0-M2=M4 M2<=M0 M4<=M0
    <- clsmap-cxt-capmap-respects-geq CM-B0-M0 M4<=M0 CM-B0-M4
    <- cxt-remove-unique-preserves-clsmap-cxt-capmap CM-B0-M4 B0-S=B1 CM-B1-M4
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capmap
         CM-B1-M4 N!<B1 (B1+N=B2 x) (CM-B2-M4 x))
    <- ({x} cxt`update-implies-lookup (B1+N=B2 x) (B2L x))
    <- ({x} nat+set2capmap-implies-clsmap-cxt-capmap
         CM-CM CML FM-DM N+FS=M3 (B2L x) GT (CM-B2-M3 x))
    <- ({x} join-preserves-clsmap-cxt-capmap (CM-B2-M3 x) (CM-B2-M4 x) M3+M4=M5 (CM-B2-M5 x))
    <- cxt-remove-unique-preserves-capmap2perm
      (B0+M0=>PiM0:capmap2perm CM PM B0 M0 PiM0) B0-S=B1 B1+M0=>PiM0
    <- capmap-split-implies-permission-combine M0-M2=M4 B1+M0=>PiM0
      PiM2 PiM4 B1+M2=>PiM2 B1+M4=>PiM4 PiM0<=>PiM2+PiM4
    <- ({x} cxt-fresh-update-preserves-capmap2perm
         B1+M4=>PiM4 N!<B1 (B1+N=B2 x) (B2+M4=>PiM4 x))
    <- cxt-remove-unique-preserves-cxt-unique-objset CM-B0-S B0-S=B1 CM-B1-S
    <- letRefTyping-helper/base/unique/L1 _ SZ-S CM-B1-S S+FS=>M2 B1+M2=>PiM2
         B1+OS=>GF N!<B1 ([x] B1+N=B2 x) M3Q
      ([x] PiM3 x) N+FS=>M3Q ([x] B2+M3Q=>PiM3 x) ([x] IMP x)
    <- nat+set2capmap-unique N+FS=>M3Q N+FS=M3 nat`eq/ set`eq/ cap`eq/ M3Q=M3
    <- ({x} capmap2perm-respects-eq (B2+M3Q=>PiM3 x) clsmap`eq/ predmap`eq/
         cxt`eq/ M3Q=M3 permission`eq/ (B2+M3=>PiM3 x))
    <- ({x} capmap-split-implies-permission-combine-converse
         (capmap-split/ M3^M4 M3+M4=M5) (B2+M3=>PiM3 x) (B2+M4=>PiM4 x) (PiM5 x)
         (B2+M5=>PiM5 x) (PiM3+PiM4<=>PiM5 x))
    <- letRefTyping-helper/base/unique/L5L2 _ SZ-S CM-B0-S B0+S=>GF B0=>PiB0
      PF3 T2PF-B ([x] IMP5 x)
    <- letRefTyping-helper/base/unique/L2* _ SZ-S T2PF-B
      CM-B0-S CML PML FM-DM ME-B0-S=PiS B0+S=>GF PF2P T2PF2P PF3P FM2P2 IMP2
    <- letRefTyping-helper/base/unique/L4L1 CM-CM CM2PM CML FM-DM
      (ty2perm/ PML NN2P annot2perm/unique) _ _ T2PF2 ([x] FS=>PiM3 x)
      ([x] IMP3 x)
    <- letRefTyping-helper/base/unique/L4L2 CML FS=>PiM3 B2L M3P PiM3P N+FS=>M3P
      ([x] B2+M3P=>PiM3P x) ([x] IMP4 x)
    <- capmap-min-unique MIN-M1=X MIN-M1=W cap`eq/ capmap`eq/ (X=W:cap`eq X cap/write)
    <- letRefTyping-helper/base/unique/L4L3 X2Q X=W EQV
    <- nat+set2capmap-unique N+FS=>M3P N+FS=M3 nat`eq/ set`eq/ cap`eq/ M3P=M3
    <- ({x} capmap2perm-equiv (B2+M3P=>PiM3P x) (B2+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ M3P=M3 (PiM3P<=>PiM3 x))
    <- ty2perm2-unique T2PF2P T2PF2 clsmap`eq/ predmap`eq/ ty`eq/ ([x] PEQ x)
    <- ({x} permission`eq-implies-equiv (PEQ x) (EQV2 x)).

%worlds (objvar) (letRefTyping-helper/base/unique/L5 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L5 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L
  : forall* {CM} {NN} {C} {FM} {FS} {S} {M2} {B0} {B1} {B2} {N} {M5}
    {M0} {M1} {M3} {M4} {PM} {Out}
    forall {K1} {K2}
    {SZ-S: set`size S K1}
    {SZ-M1: capmap`size M1 K2}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {S+FS=M2: set+set2capmap S FS cap/write M2}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    {N!<B1: cxt`fresh B1 N}
    {B1+N=B2: {x} cxt`update B1 N (cxt-info/ x (ty/ NN annot/unique C)) (B2 x)}
    {N>0: nat`gt N z}
    {M0-M2=M4: capmap-split M0 M2 M4}
    {N+FS=M3: nat+set2capmap N FS cap/write M3}
    {M5-M3=M4: capmap-split M5 M3 M4}
    {MIN-X: capmap-min M1 cap/write}
    {CM-Rslt: clsmap-result CM (result/expr (reftype/ NN C (targets/unique S M1)) (env/ B0 M0))}
    {Rslt=>Out: result2output CM PM
                (result/expr (reftype/ NN C (targets/unique S M1)) (env/ B0 M0)) Out}
    exists {Pi} {CM-V: {x} clsmap-env CM (env/ (B2 x) M5)}
    {V=>Pi: {x} env2input CM PM (env/ (B2 x) M5) (Pi x)}
    {TRANS: transform Out (output/exists [x] (output/expr x (Pi x)))}
    true.

%%% This is the case where M1 is not empty:
%%% Two subcases: when S is empty and when S is not empty.
%%% If S is empty, all permissions for x come from M1, can we still register it
%%% as a unique variable?
- : letRefTyping-helper/base/unique/L z _ _ _
    CM-CM CM2PM CML FM-DM set+set2capmap/0 cxt-remove-unique/0
    N!<B1 B1+N=B2 GT (M0-M2=M4:capmap-split M0 capmap/0 M4) N+FS=M3
    (M5-M3=M4:capmap-split M5 M3 M4) MIN-X
    CM-Rslt Rslt=>Out %{=>}% _ CM-V V=>Pi TRANS
    <- capmap-split-on-empty _ M0-M2=M0
    <- capmap-split-unique M0-M2=M4 M0-M2=M0 capmap`eq/ capmap`eq/ (M4=M0:capmap`eq M4 M0)
    <- capmap-split-respects-eq M5-M3=M4 capmap`eq/ capmap`eq/ M4=M0 M5-M3=M0
    <- letRefTyping-helper/base/unique/L4 CM-CM CM2PM CML FM-DM N!<B1 B1+N=B2 GT
      N+FS=M3 M5-M3=M0 MIN-X CM-Rslt Rslt=>Out _ CM-V V=>Pi TRANS.

- : letRefTyping-helper/base/unique/L (s _) (s _) SZ SZ-M
    CM-CM CM2PM CML FM-DM S+FS=M2 B0-S=B1 N!<B1 B1+N=B2 GT M0-M2=M4 N+FS=M3
    M5-M3=M4 MIN-X CM-Rslt Rslt=>Out %{=>}% _ CM-V V=>Pi TRANS
    <- letRefTyping-helper/base/unique/L5 SZ SZ-M CM-CM CM2PM CML FM-DM S+FS=M2
      B0-S=B1 N!<B1 B1+N=B2 GT M0-M2=M4 N+FS=M3 M5-M3=M4 MIN-X CM-Rslt Rslt=>Out
      _ CM-V V=>Pi TRANS.

- : letRefTyping-helper/base/unique/L (s _) z _ _
    CM-CM CM2PM (CML:clsmap`lookup CM C FM)
    FM-DM S+FS=>M2 (B0-S=B1: cxt-remove-unique B0 S B1) (N!<B1: cxt`fresh B1 N)
    ([x] B1+N=B2 x) GT (M0-M2=M4:capmap-split M0 M2 M4)
    (N+FS=M3: nat+set2capmap N FS cap/write M3) (capmap-split/ M3^M4 M3+M4=M5) _
    (clsmap-result/expr (CM-B0: clsmap-cxt CM B0)
      (clsmap-cxt-reftype/unique (CML2:clsmap`lookup CM C FM2)
        (CM-B0-S:cxt-unique-objset B0 NN C S) CM-B0-M1 WF) CM-B0-M0)
    (result2output/unique/1 SZ-OS SZ-M1 (ty2perm/ PML NN2P annot2perm/borrow)
      ([x] B0+OS=>GF x) B0=>PiB0 B0+M0=>PiM0)
    %{=>}% _
    ([x] clsmap-env/
      (clsmap-cxt/U (CM-B1:clsmap-cxt CM B1) (clsmap-ty/ CML) N!<B1 (B1+N=B2 x))
      (CM-B2-M5 x))
    ([x] env2input/
      (cxt2perm/U B1=>PiB1 N!<B1 (B1+N=B2 x)
        (ty2perm2/unique CML PML FM=>PF
          (ty2perm/ PML (NN2P:nn2perm NN _ (PF)) annot2perm/borrow)))
      (B2+M5=>PiM5 x))
    (transform/inside [x]
      (transform/trans
        (transform/implies
          (implies/trans6
            (implies/combine
              (implies/equiv (PiB0<=>PiB1+PiS))
              (implies/combine (implies/reflexive)
                (implies/combine
                  (implies/reflexive)
                  (implies/equiv PiM0<=>PiM2+PiM4))))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine (implies/reflexive)
              (implies/trans4
                (implies/combine (implies/reflexive)
                  (implies/equiv equiv/roll2))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans
                    (implies/equiv equiv/commute)
                    (IMP4 x))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))))
            (implies/combine (implies/reflexive)
              (implies/trans5
                (implies/combine (implies/reflexive)
                  (implies/equiv equiv/roll3))
                (implies/equiv equiv/associate)
                (implies/combine
                  (IMP x)
                  (implies/combine (implies/reflexive)
                    (implies/equiv equiv/commute)))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine (implies/reflexive)
                  (implies/equiv (equiv/symmetric equiv/associate)))))
            (implies/combine (implies/reflexive)
              (implies/combine (implies/reflexive)
                (implies/trans3
                  (implies/combine (implies/reflexive)
                    (implies/equiv equiv/roll3))
                  (implies/equiv (equiv/associate))
                  (implies/combine (implies/equiv (PiM3+PiM4<=>PiM5 x))
                    (implies/reflexive)))))
            (implies/equiv
              (equiv/transitive7
                (equiv/roll2)
                (equiv/combine (equiv/reflexive) (equiv/roll3))
                (equiv/associate)
                (equiv/symmetric equiv/associate)
                (equiv/roll2)
                (equiv/combine equiv/reflexive
                  (equiv/combine (equiv/reflexive)
                  (equiv/transitive3
                    (equiv/combine (equiv/reflexive)
                      (equiv/commute))
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive
                        (equiv/combine (equiv/reflexive) (equiv/commute))
                        (equiv/commute))
                      (equiv/reflexive)))))
                (equiv/transitive
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/transitive
                        (equiv/combine
                          (equiv/transitive
                            (equiv/combine
                              (equiv/transitive
                                (equiv/associate)
                                (equiv/commute))
                              (equiv/reflexive))
                            (equiv/symmetric equiv/associate))
                          (equiv/reflexive))
                        (equiv/symmetric equiv/associate))))
                  (equiv/transitive
                    (equiv/associate)
                    (equiv/associate)))))))
        (transform/drop)))
    <- cxt-remove-unique-preserves-clsmap-cxt CM-B0 B0-S=B1 CM-B1
    <- cxt-remove-unique-implies-make-encumbered
      B0-S=B1 B0=>PiB0 PiB1 PiS B1=>PiB1 ME-B0-S=PiS
      (PiB0<=>PiB1+PiS:equiv PiB0 (combine PiB1 PiS))
    <- ({x} cxt-remove-unique-preserves-set2cond (B0+OS=>GF x) B0-S=B1 (B1+OS=>GF x))
    <- capmap-split-implies-leq M0-M2=M4 M2<=M0 M4<=M0
    <- clsmap-cxt-capmap-respects-geq CM-B0-M0 M4<=M0 CM-B0-M4
    <- cxt-remove-unique-preserves-clsmap-cxt-capmap CM-B0-M4 B0-S=B1 CM-B1-M4
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capmap
         CM-B1-M4 N!<B1 (B1+N=B2 x) (CM-B2-M4 x))
    <- ({x} cxt`update-implies-lookup (B1+N=B2 x) (B2L x))
    <- ({x} nat+set2capmap-implies-clsmap-cxt-capmap
         CM-CM CML FM-DM N+FS=M3 (B2L x) GT (CM-B2-M3 x))
    <- ({x} join-preserves-clsmap-cxt-capmap (CM-B2-M3 x) (CM-B2-M4 x) M3+M4=M5 (CM-B2-M5 x))
    <- cxt-remove-unique-preserves-capmap2perm
      (B0+M0=>PiM0:capmap2perm CM PM B0 M0 PiM0) B0-S=B1 B1+M0=>PiM0
    <- capmap-split-implies-permission-combine M0-M2=M4 B1+M0=>PiM0
      PiM2 PiM4 B1+M2=>PiM2 B1+M4=>PiM4 PiM0<=>PiM2+PiM4
    <- ({x} cxt-fresh-update-preserves-capmap2perm
         B1+M4=>PiM4 N!<B1 (B1+N=B2 x) (B2+M4=>PiM4 x))
    <- cxt-remove-unique-preserves-cxt-unique-objset CM-B0-S B0-S=B1 CM-B1-S
    <- letRefTyping-helper/base/unique/L1 _ SZ-OS CM-B1-S S+FS=>M2 B1+M2=>PiM2
         B1+OS=>GF N!<B1 ([x] B1+N=B2 x) M3Q _ N+FS=>M3Q ([x] B2+M3Q=>PiM3 x) ([x] IMP x)
    <- nat+set2capmap-unique N+FS=>M3Q N+FS=M3 nat`eq/ set`eq/ cap`eq/ M3Q=M3
    <- ({x} capmap2perm-respects-eq (B2+M3Q=>PiM3 x) clsmap`eq/ predmap`eq/
         cxt`eq/ M3Q=M3 permission`eq/ (B2+M3=>PiM3 x))
    <- ({x} capmap-split-implies-permission-combine-converse
         (capmap-split/ M3^M4 M3+M4=M5) (B2+M3=>PiM3 x) (B2+M4=>PiM4 x) _
         (B2+M5=>PiM5 x) (PiM3+PiM4<=>PiM5 x))
    <- letRefTyping-helper/base/unique/L2 _ SZ-OS CM-B0-S CML PML FM-DM ME-B0-S=PiS
      B0+OS=>GF PF2 FM=>PF IMP4.

%worlds (objvar) (letRefTyping-helper/base/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique
  : forall* {CM} {NN} {C} {FM} {FS} {S} {M2} {B0} {B1} {B2} {N} {M5}
    {M0} {M1} {M3} {M4} {PM} {Out}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {S+FS=M2: set+set2capmap S FS cap/write M2}
    {B0-S=B1: cxt-remove-unique B0 S B1}
    {N!<B1: cxt`fresh B1 N}
    {B1+N=B2: {x} cxt`update B1 N (cxt-info/ x (ty/ NN annot/unique C)) (B2 x)}
    {N>0: nat`gt N z}
    {M0-M2=M4: capmap-split M0 M2 M4}
    {N+FS=M3: nat+set2capmap N FS cap/write M3}
    {M5-M3=M4: capmap-split M5 M3 M4}
    {MIN-X: capmap-min M1 cap/write}
    {CM-Rslt: clsmap-result CM (result/expr (reftype/ NN C (targets/unique S M1)) (env/ B0 M0))}
    {Rslt=>Out: result2output CM PM
                (result/expr (reftype/ NN C (targets/unique S M1)) (env/ B0 M0)) Out}
    exists {Pi} {CM-V: {x} clsmap-env CM (env/ (B2 x) M5)}
    {V=>Pi: {x} env2input CM PM (env/ (B2 x) M5) (Pi x)}
    {TRANS: transform Out (output/exists [x] (output/expr x (Pi x)))}
    true.

- : letRefTyping-helper/base/unique CM-CM CM2PM CML FM-DM S+FS=M2
    B0-S=B1 N1!<B1 B1+N=B2 GT M0-M2=M4 N+FS=M3 M5-M3=M4 MIN-X
    CM-Rslt Rslt=>Out _ CM-V V=>Pi TRANS
    <- set`size-total SZ-S
    <- capmap`size-total SZ-M1
    <- letRefTyping-helper/base/unique/L _ _ SZ-S SZ-M1
      CM-CM CM2PM CML FM-DM S+FS=M2
      B0-S=B1 N1!<B1 B1+N=B2 GT M0-M2=M4 N+FS=M3 M5-M3=M4 MIN-X
      CM-Rslt Rslt=>Out _ CM-V V=>Pi TRANS.

%worlds (objvar) (letRefTyping-helper/base/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/shared
  : forall* {CM} {PM} {NN} {C} {B0} {M0} {B1} {Out} {N}
    forall {N!<B0: cxt`fresh B0 N}
    {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)}
    {CM-Rslt: clsmap-result CM (result/expr (reftype/ NN C targets/shared) (env/ B0 M0))}
    {Rslt=>Out: result2output CM PM
                (result/expr (reftype/ NN C targets/shared) (env/ B0 M0)) Out}
    exists {Pi} {CM-V: {x} clsmap-env CM (env/ (B1 x) M0)}
    {V=>Pi: {x} env2input CM PM (env/ (B1 x) M0) (Pi x)}
    {TRANS: transform Out (output/exists [x] (output/expr x (Pi x)))}
    true.

- : letRefTyping-helper/base/shared
    (N!<B0:cxt`fresh B0 N) ([x] B0+N=B1 x)
    (clsmap-result/expr CM-B0
      (clsmap-cxt-reftype/shared CML) CM-B0-M)
    (result2output/shared (ty2perm/ PML NN2P annot2perm/shared)
      (B0=>PiB0:cxt2perm CM PM B0 PiB0)
      (M0=>PiM0:capmap2perm CM PM B0 M0 PiM0))
    %{=>}% _
    ([x] clsmap-env/ (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x)) (CM-B1-M x))
    ([x] env2input/
      (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x)
        (ty2perm2/shared (ty2perm/ PML NN2P annot2perm/shared))) (B1+M0=>PiM0 x))
    (transform/inside [x]
      (transform/implies
        (implies/equiv
          (equiv/transitive
            (equiv/associate)
            (equiv/combine (equiv/commute) (equiv/reflexive))))))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capmap CM-B0-M N!<B0 (B0+N=B1 x) (CM-B1-M x))
    <- ({x} cxt-fresh-update-preserves-capmap2perm M0=>PiM0 N!<B0 (B0+N=B1 x) (B1+M0=>PiM0 x)).

%worlds (objvar) (letRefTyping-helper/base/shared _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/shared _ _ _ _ _ _ _ _).
