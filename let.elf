% This theorem says if we have a let expression:

%   let x = e1 in e2 end
% and that the output from checking e1 is Out1, from e2 is
% Out2. Then, we can substitute all occurrences of x in Out2
% with some form derived from Out1, and the result of substitution
% Out2' is equivalent to the combination of Out1 and Out2.

%% ----------------------------------------------------------
%% Definitions
%% ----------------------------------------------------------

%% For a let expression let x = e1 in e2, `targets` is from e1, `nat` is
%% the object index for x, and `effects` is from e2.

%abbrev unique-target : targets = targets/unique set/0 set/0.

%abbrev unique-obj-permission : clspred -> (object -> permission)
  = [CP] ([x] unitperm (nonlinear (neg (objequal x null))) ,
           (combine (allperm x) (one-predcall CP x))).

%abbrev borrow-obj-permission : clspred -> (object -> permission)
  = [CP] ([x] unitperm (nonlinear (neg (objequal x null))) ,
           (combine (empty) (one-predcall CP x))).

%% The following three theorems say that x can only occur in one of
%% the three constructs inside effect, if the effect is well-formed
%% with-respect-to clsmap and cxt.

% a wrapper

object-in-efxmap : effects -> nat -> type.

object-in-efxmap/ : object-in-efxmap (effects/ M _ _) N
                    <- efxmap-map-objects M OS
                    <- set`member OS N.


%% -----------------------------------------------------------
%% Lemmas
%% -----------------------------------------------------------

%theorem subst-effects-one-occurrence/1
  : forall* {CM} {B} {M} {S} {Q} {OS} {SS} {N}
    forall {CM-B-XX: clsmap-cxt-effects CM B (effects/ M S Q)}
    {M=>OS: efxmap-map-objects M OS}
    {S=>SS: set-map-objects S SS}
    {MB: set`member OS N}
    exists {OUT-S: set`not-member SS N}
    {OUT-Q: set`not-member Q N}
    true.

%worlds (objvar) (subst-effects-one-occurrence/1 _ _ _ _ _ _).
%trustme %total { } (subst-effects-one-occurrence/1 _ _ _ _ _ _).


%theorem subst-effects-one-occurrence/2
  : forall* {CM} {B} {M} {S} {Q} {OS} {SS} {N}
    forall {CM-B-XX: clsmap-cxt-effects CM B (effects/ M S Q)}
    {M=>MS: efxmap-map-objects M OS}
    {S=>SS: set-map-objects S SS}
    {IN-SS: set`member SS N}
    exists {OUT-OS: set`not-member OS N}
    {OUT-Q: set`not-member Q N}
    true.

%worlds (objvar) (subst-effects-one-occurrence/2 _ _ _ _ _ _).
%trustme %total () (subst-effects-one-occurrence/2 _ _ _ _ _ _).


%theorem subst-effects-one-occurrence/3
  : forall* {CM} {B} {M} {S} {Q} {OS} {SS} {N}
    forall {CM-B-XX: clsmap-cxt-effects CM B (effects/ M S Q)}
    {M=>MS: efxmap-map-objects M OS}
    {S=>SS: set-map-objects S SS}
    {IN-Q: set`member Q N}
    exists {OUT-OS: set`not-member OS N}
    {OUT-SS: set`not-member SS N}
    true.

%worlds (objvar) (subst-effects-one-occurrence/3 _ _ _ _ _ _).
%trustme %total () (subst-effects-one-occurrence/3 _ _ _ _ _ _).


%theorem let-helper/L1
  : forall* {CM} {B} {M1} {S1} {M2} {S2} {Q1} {Q2} {Q} {M} {S}
    forall {CM-B-XX: clsmap-cxt-effects CM B (effects/ M2 S2 Q2)}
    {XJ: effects`join (effects/ M1 S1 Q1) (effects/ M2 S2 Q2) (effects/ M S Q)}
    exists {M0} {TC: transfer-consume CM B (effects/ M S Q) (effects/ M1 S1 Q1)
                     (effects/ M0 S1 Q1) Q2}
    true.

- : let-helper/L1 (clsmap-cxt-effects/ _ _ Q2=>S3 _ _ _ _ _)
    (effects`join/ DM-M1=R1 DM-M2=R2 S1^R1 S2^R2 S1^R2 S1^S2 R1/S2=R
      M1|R=M1' M1'uM2=M S1uS2=S Q1^Q2 Q1uQ2=Q) %{=>}%
    _ (transfer-consume/ S1<=S Q1<=Q S/S1=S2 Q/Q1=Q2 Q2=>S3
        S2uS3=S4 S4=>M3 MuM3=MP)
    <- set`union-implies-leq S1uS2=S S1<=S S2<=S
    <- set`union-implies-leq Q1uQ2=Q Q1<=Q Q2<=Q
    <- set`union-commutative S1uS2=S S2uS1=S
    <- set`disjoint-symmetric S1^S2 S2^S1
    <- set`union-commutative Q1uQ2=Q Q2uQ1=Q
    <- set`disjoint-symmetric Q1^Q2 Q2^Q1
    <- set`disjoint-union-implies-remove S2uS1=S S2^S1 S/S1=S2
    <- set`disjoint-union-implies-remove Q2uQ1=Q Q2^Q1 Q/Q1=Q2
    <- set`union-total S2uS3=S4
    <- set2efxmap-total S4=>M3
    <- efxmap`join-total MuM3=MP.

%worlds (objvar) (let-helper/L1 _ _ _ _).
%total { } (let-helper/L1 _ _ _ _).


%theorem let-helper/L2
  : forall* {M1} {S1} {Q1} {M2} {S2} {Q2}
    {M} {S} {Q} {MP} {M0} {CM} {B}
    forall {CM-B-XXP: clsmap-cxt-effects CM B (effects/ MP S Q)}
    {XX1+XX2=XX: effects`join (effects/ M1 S1 Q1) (effects/ M2 S2 Q2)
               (effects/ M S Q)}
    {XX<c=XXP: effects-leq-no-consume (effects/ M S Q) (effects/ MP S Q)}
    {XX'+XX1=>XXc+Q: transfer-consume CM B
                     (effects/ MP S Q) (effects/ M1 S1 Q1) (effects/ M0 S1 Q1) Q2}
    exists {S3} {FS3} {M3} {Q2=>FS3: objset2fldset CM B Q2 FS3}
    {S2^FS3: set`disjoint S2 FS3}
    {S2uFS3=S3: set`union S2 FS3 S3}
    {S3=>M3: set2efxmap S3 efx/write M3}
    {MP^Mk: efxmap`disjoint MP M3}
    {MP+M3=M0: efxmap`join MP M3 M0}
    true.

- : let-helper/L2
    (clsmap-cxt-effects/
      (DM-MP=RP:efxmap`domain MP RP)
      (RP^S:set`disjoint RP S)
      (Q=>FS:objset2fldset CM B Q FS)
      (RP^FS:set`disjoint RP FS)
      (S^FS:set`disjoint S FS) _ _ _)
    (effects`join/ _ _ _ _ _
      (S1^S2:set`disjoint S1 S2) RM RS M1P+M2=M S1+S2=S Q1^Q2
      (Q1+Q2=Q:set`union Q1 Q2 Q))
    (effects-leq-no-consume/ M<=MP)
    (transfer-consume/ S1<=S Q1<=Q
      (S/S1=S2P:set`remove S S1 S2P)
      (Q/Q1=Q2:set`remove Q Q1 Q2)
      Q2=>FS3 S2PuFS3=S3 S3=>M3 MP+M3=Mc) %{=>}%
    S3 FS3 M3 Q2=>FS3 S2^FS3 S2uFS3=S3 S3=>M3 MP^M3 MP+M3=Mc
    <- set`union-commutative S1+S2=S S2+S1=S
    <- set`disjoint-symmetric S1^S2 S2^S1
    <- set`union-commutative Q1+Q2=Q Q2+Q1=Q
    <- set`disjoint-symmetric Q1^Q2 Q2^Q1
    <- set`disjoint-union-implies-remove S2+S1=S S2^S1 S/S1=S2
    <- set`remove-unique S/S1=S2P S/S1=S2 set`eq/ set`eq/ S2P=S2
    <- set`union-respects-eq S2PuFS3=S3 S2P=S2 set`eq/ set`eq/ S2uFS3=S3
    <- set`union-implies-leq S1+S2=S _ S2<=S
    <- set`remove-implies-leq Q/Q1=Q2 Q2<=Q
    <- objset2fldset-preserves-leq* Q2<=Q Q2=>FS3 Q=>FS FS3<=FS
    <- set`disjoint-respects-geq S^FS S2<=S FS3<=FS S2^FS3
    <- set`leq-reflexive _ RP<=RP
    <- set`disjoint-respects-geq RP^S RP<=RP S2<=S RP^S2
    <- set`disjoint-respects-geq RP^FS RP<=RP FS3<=FS RP^FS3
    <- set`union-right-preserves-disjoint* RP^S2 RP^FS3 S2uFS3=S3 RP^S3
    <- set2efxmap-implies-domain S3=>M3 DM-M3=S3
    <- efxmap`domain-preserves-disjoint-converse RP^S3 DM-MP=RP DM-M3=S3 MP^M3.

%worlds (objvar) (let-helper/L2 _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L2 _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L3
  : forall* {M1} {S1} {Q1} {M2} {S2} {Q2} {QP}
    {M} {S} {Q} {MP} {M0} {CM} {B} {S0} {Q0}
    forall {CM-B-XXV: clsmap-cxt-effects CM B (effects/ MP S Q)}
    {XX1+XX2=XX: effects`join (effects/ M1 S1 Q1) (effects/ M2 S2 Q2) (effects/ M S Q)}
    {XX<=XXV: efxmap`leq M MP}
    {XX'+XX1=>XXc+Q: transfer-consume CM B (effects/ MP S Q) (effects/ M1 S1 Q1)
                     (effects/ M0 S0 Q0) QP}
    exists {S3} {FS3} {M3} {QP=>FS3: objset2fldset CM B QP FS3}
    {S2^FS3: set`disjoint S2 FS3}
    {S2uFS3=S3: set`union S2 FS3 S3}
    {S3=>M3: set2efxmap S3 efx/write M3}
    {MP^M3: efxmap`disjoint MP M3}
    {MP+M3=M0: efxmap`join MP M3 M0}
    {QE: set`eq QP Q2} {E: set`eq S0 S1} {E: set`eq Q0 Q1}
    true.

- : let-helper/L3
    (clsmap-cxt-effects/
      (DM-M'=R':efxmap`domain M' R')
      (R'^S:set`disjoint R' S)
      (Q=>FS:objset2fldset CM B Q FS)
      (R'^FS:set`disjoint R' FS)
      (S^FS:set`disjoint S FS) _ _ _)
    (effects`join/ _ _ _ _ _
      (S1^S2:set`disjoint S1 S2) RM RS M1'+M2=M S1+S2=S Q1^Q2
      (Q1+Q2=Q:set`union Q1 Q2 Q)) M<=M'
    (transfer-consume/ S1<=S Q1<=Q
      S/S1=S2' Q/Q1=Q3 Q3=>FS3 S2'uFS3=S3 S3=>M3 M'+M3=Mc) %{=>}%
    S3 FS3 M3 Q3=>FS3 S2^FS3 S2uFS3=S3 S3=>M3 M'^M3 M'+M3=Mc Q3=Q2 set`eq/ set`eq/
    <- set`union-commutative S1+S2=S S2+S1=S
    <- set`disjoint-symmetric S1^S2 S2^S1
    <- set`union-commutative Q1+Q2=Q Q2+Q1=Q
    <- set`disjoint-symmetric Q1^Q2 Q2^Q1
    <- set`disjoint-union-implies-remove S2+S1=S S2^S1 S/S1=S2
    <- set`disjoint-union-implies-remove Q2+Q1=Q Q2^Q1 Q/Q1=Q2
    <- set`remove-unique S/S1=S2' S/S1=S2 set`eq/ set`eq/ S2'=S2
    <- set`union-respects-eq S2'uFS3=S3 S2'=S2 set`eq/ set`eq/ S2uFS3=S3
    <- set`union-implies-leq S1+S2=S _ S2<=S
    <- set`remove-implies-leq Q/Q1=Q3 Q3<=Q
    <- objset2fldset-preserves-leq* Q3<=Q Q3=>FS3 Q=>FS FS3<=FS
    <- set`disjoint-respects-geq S^FS S2<=S FS3<=FS S2^FS3
    <- set`remove-unique Q/Q1=Q3 Q/Q1=Q2 set`eq/ set`eq/ Q3=Q2
    <- set`leq-reflexive _ R'<=R'
    <- set`disjoint-respects-geq R'^S R'<=R' S2<=S R'^S2
    <- set`disjoint-respects-geq R'^FS R'<=R' FS3<=FS R'^FS3
    <- set`union-right-preserves-disjoint* R'^S2 R'^FS3 S2uFS3=S3 R'^S3
    <- set2efxmap-implies-domain S3=>M3 DM-M3=S3
    <- efxmap`domain-preserves-disjoint-converse R'^S3 DM-M'=R' DM-M3=S3 M'^M3.

%worlds (objvar) (let-helper/L3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L4
  : forall* {M} {N} {Mout} {Min}
    forall {PT: efxmap-partition-on-index M N Mout Min}
    exists {Oout} {ESO: efxmap-same-object Min N}
    {DM: efxmap-map-objects Mout Oout}
    {N!<Oout: set`not-member Oout N}
    true.

%worlds (objvar) (let-helper/L4 _ _ _ _ _).
%trustme %total { } (let-helper/L4 _ _ _ _ _).


%theorem let-helper/L51/L
  : forall* {M} {N} {K} {X}
    forall {SN} {SZ: efxmap`size M SN}
    {MO: efxmap-map-objects M (set/1 N)}
    {ML: efxmap`lookup M K X}
    exists {F} {N+F=K: pair2nat (pair/ N F) K}
    true.

%theorem let-helper/L51/L1
  : forall* {SP} {N} {NP}
    forall {AD: set`add SP NP (set/1 N)}
    exists {EQ: nat`eq NP N}
    true.

- : let-helper/L51/L1 set`update/0 nat`eq/.

- : let-helper/L51/L1 (set`update/= E) E.

%worlds (objvar) (let-helper/L51/L1 _ _).
%total { } (let-helper/L51/L1 _ _).


%theorem let-helper/L51/L2
  : forall* {MP} {SP} {K} {X} {N} {NP}
    forall {MP=>SP: efxmap-map-objects MP SP}
    {ML: efxmap`lookup MP K X}
    {SP+NP=S: set`add SP NP (set/1 N)}
    exists {EQ: set`eq SP (set/1 N)}
    true.

- : let-helper/L51/L2 efxmap-map-objects/0 ML set`update/0 E
    <- efxmap`lookup-contradiction ML V
    <- set`false-implies-eq V E.

- : let-helper/L51/L2 _ _ (set`update/= E) set`eq/.

%worlds (objvar) (let-helper/L51/L2 _ _ _ _).
%total { } (let-helper/L51/L2 _ _ _ _).

%theorem let-helper/L51/LL
  : forall* {M} {N} {K} {X} {KP} {B} {MP} {FP} {SP} {XP} {NP}
    forall {SN} {SZ: efxmap`size MP SN} {MPO: efxmap-map-objects MP SP}
    {N+F=K: pair2nat (pair/ NP FP) KP}
    {FS: efxmap`fresh MP KP} {UD: efxmap`update MP KP XP M}
    {A: set`add SP NP (set/1 N)}
    {ML: efxmap`lookup M K X}
    {EQ?: nat`eq? KP K B}
    exists {F} {N+F=K: pair2nat (pair/ N F) K}
    true.

- : let-helper/L51/LL _ SZ MP=>SP NP+FP=KP KP!<MP (MP+KP=M:efxmap`update MP KP XP M)
    SP+NP=S (M->K=X:efxmap`lookup M K X) (nat`eq?/no (KP<>K:nat`ne KP K)) _ N+F=K
    <- nat`ne-symmetric KP<>K K<>KP
    <- efxmap`update-preserves-lookup-converse M->K=X MP+KP=M K<>KP MP->K=X
    <- let-helper/L51/L2 MP=>SP MP->K=X SP+NP=S SP=
    <- efxmap-map-objects-respects-eq MP=>SP efxmap`eq/ SP= MP=>SP1
    <- let-helper/L51/L _ SZ MP=>SP1 MP->K=X _ N+F=K.

- : let-helper/L51/LL _ _ MP=>SP NP+F=K KP!<MP MP+KP=M
    SP+NP=S M->K=X (nat`eq?/yes) _ N+F=K
    <- let-helper/L51/L1 SP+NP=S NP=N
    <- pair-preserves-eq NP=N nat`eq/ PE
    <- pair2nat-respects-eq NP+F=K PE nat`eq/ N+F=K.

- : let-helper/L51/L (s SN) SZ
    (efxmap-map-objects/U M'=>S' N+F=K' K!<M' M'+K=M S'+N=S) ML _ N+F=K
    <- nat`eq?-total E?
    <- efxmap`fresh-update-increases-size-converse SZ K!<M' M'+K=M SZ'
    <- let-helper/L51/LL SN SZ' M'=>S' N+F=K' K!<M' M'+K=M S'+N=S ML E? _ N+F=K.

%worlds (objvar) (let-helper/L51/L _ _ _ _ _ _)
  (let-helper/L51/LL _ _ _ _ _ _ _ _ _ _ _).
%total (M0 M) (let-helper/L51/L M _ _ _ _ _)
  (let-helper/L51/LL M0 _ _ _ _ _ _ _ _ _ _).


% %theorem let-helper/L51
%   : forall* {M} {N} {K} {X}
%     forall {MO: efxmap-map-objects M (set/1 N)}
%     {ML: efxmap`lookup M K X}
%     exists {F} {N+F=K: pair2nat (pair/ N F) K}
%     true.

% - : let-helper/L51 MO ML _ T
%     <- efxmap`size-total SZ
%     <- let-helper/L51/L _ SZ MO ML _ T.

% %worlds (objvar) (let-helper/L51 _ _ _ _).
% %total { } (let-helper/L51 _ _ _ _).


%theorem let-helper/L5*/L
  : forall* {CM} {B} {FM} {MF} {SF} {FS}
    {N} {M} {NN} {A} {C} {S}
    forall {SN} {SZ: efxmap`size M SN}
    {DM-M: efxmap`domain M S}
    {CM-B-S: {x} clsmap-cxt-fldset CM (B x) S}
    {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {ESO: efxmap-same-object M N}
    {EMF: efxmap-map-fields M MF}
    {DM-MF: efxmap`domain MF SF}
    {DM-FM: fldmap`domain FM FS}
    exists {SF<=FS: set`leq SF FS}
    true.

- : let-helper/L5*/L _ efxmap`size/0 efxmap`domain/0
    ([_] clsmap-cxt-fldset/0)
    BL CML ESO efxmap-map-fields/0 efxmap`domain/0 DM-FM set`leq/0.

- : let-helper/L5*/L _ SZ DM-M=S CM-B-S BL CML ESO
    (efxmap-map-fields/U
      (M'=>MF':efxmap-map-fields M' MF')
      (N+F=K0: pair2nat (pair/ N0 F0) K)
      (K!<M': efxmap`fresh M' K)
      (M'+K=M: efxmap`update M' K X M)
      (MF'+F=MF: efxmap`update MF' F0 X MF))
    DM-MF=SF DM-FM SF<=FS
    <- efxmap`domain-total DM-MF'=SF'
    <- efxmap`domain-total DM-M'=S'
    <- efxmap`domain-preserves-fresh K!<M' DM-M'=S' K!<S'
    <- efxmap`update-commute-domain M'+K=M DM-M'=S' DM-M=S S'+K=S
    <- efxmap-same-object/U-inversion ESO K!<M' M'+K=M ESO'
      (match-index?/yes (N+F=K2:pair2nat (pair/ N2 F2) K))
    <- efxmap`update-commute-domain MF'+F=MF DM-MF'=SF' DM-MF=SF
      (SF'+F=SF:set`add SF' F0 SF)
    <- ({x} clsmap-cxt-fldset/U-inversion (CM-B-S x) K!<S'
         S'+K=S (CM-B-S' x) _ _ N+F=K1 _ _ _ _ (BL' x) _ CML' _ FML')
    <- nat2pair-unique N+F=K2 N+F=K1 nat`eq/ PE
    <- nat2pair-unique N+F=K1 N+F=K0 nat`eq/ PE'
    <- pair-eq-implies-eq PE' NE' FE'
    <- pair-eq-implies-eq PE NE FE
    <- ({x} cxt`lookup-unique (BL x) (BL' x) cxt`eq/ NE (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE NNE AE CE
    <- clsmap`lookup-unique CML CML' clsmap`eq/ CE FME
    <- fldmap`domain-respects-eq DM-FM FME set`eq/ DM-FM'
    <- fldmap`domain-preserves-lookup FML' DM-FM' F<-S'
    <- set`member-respects-eq F<-S' set`eq/ FE' F<-S
    <- efxmap`fresh-update-increases-size-converse SZ K!<M' M'+K=M SZ'
    <- let-helper/L5*/L _ SZ' DM-M'=S' CM-B-S' BL CML ESO' M'=>MF'
      DM-MF'=SF' DM-FM SF'<=FS
    <- set`add-member-preserves-leq SF'<=FS SF'+F=SF F<-S SF<=FS.

%worlds (objvar) (let-helper/L5*/L _ _ _ _ _ _ _ _ _ _ _).
%total (DM) (let-helper/L5*/L DM _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L5*
  : forall* {CM} {B} {FM} {MF} {SF} {FS} {N} {M} {NN} {A} {C} {S}
    forall {DM-M: efxmap`domain M S}
    {CM-B-S: {x} clsmap-cxt-fldset CM (B x) S}
    {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {ESO: efxmap-same-object M N}
    {EMF: efxmap-map-fields M MF}
    {DM-MF: efxmap`domain MF SF}
    {DM-FM: fldmap`domain FM FS}
    exists {SF<=FS: set`leq SF FS}
    true.

- : let-helper/L5* DM-M CM-B-S BL CML M-N M=>MF DM-MF=SF DM-FM=FS SF<=FS
    <- efxmap`size-total SZ
    <- let-helper/L5*/L _ SZ DM-M CM-B-S BL CML M-N M=>MF DM-MF=SF DM-FM=FS SF<=FS.

%worlds (objvar) (let-helper/L5* _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L5* _ _ _ _ _ _ _ _ _).


%theorem let-helper/L5
  : forall* {CM} {FM} {B} {R} {MFin} {N} {Min} {NN} {A} {C}
    forall {DM-M: efxmap`domain Min R}
    {CM-B-R: {x} clsmap-cxt-fldset CM (B x) R}
    {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {ESO: efxmap-same-object Min N}
    {EMF: efxmap-map-fields Min MFin}
    exists {SFin} {FS}
    {DM-MFin: efxmap`domain MFin SFin}
    {DM-FM: fldmap`domain FM FS}
    {SFin<=FS: set`leq SFin FS}
    true.

- : let-helper/L5 DM-M CM-B-R BL CML ESO EMF _ _ DM-MFin=SFin
    DM-FM=FS SFin<=FS
    <- fldmap`domain-total DM-FM=FS
    <- efxmap`domain-total DM-MFin=SFin
    <- let-helper/L5* DM-M CM-B-R BL CML ESO EMF DM-MFin=SFin
      DM-FM=FS SFin<=FS.

%worlds (objvar) (let-helper/L5 _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L5 _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L6
  : forall* {M1} {M2} {M} {S1} {S2} {S} {Q1} {Q2} {Q}
    forall {J: effects`join (effects/ M1 S1 Q1) (effects/ M2 S2 Q2)
               (effects/ M S Q)}
    exists {LE: efxmap`leq M2 M}
    true.

- : let-helper/L6 (effects`join/ _ _ _ _ _ _ _ _ M1P+M2=M _ _ _) M2<=M
    <- efxmap`join-implies-leq M1P+M2=M _ M2<=M.

%worlds (objvar) (let-helper/L6 _ _).
%total { } (let-helper/L6 _ _).


%theorem let-helper/L7
  : forall* {CM} {PM} {FM} {CJ} {FS} {Pf}
    forall {FM2G: fldmap2conj CM PM FM ([x] CJ x) PM}
    {FM2P: {x} fldmap2perm PM x FM FS (Pf x)}
    exists {IMP: {x} bimplies true (CJ x) (nested (Pf x) x all)}
    true.

%worlds (objvar) (let-helper/L7 _ _ _).
%trustme %total { } (let-helper/L7 _ _ _).


%{%
  Given a subset of fields for a class, we really want to have
the permissions for them carving out of the permission for
the whole class.

It SHOULD goes like this:

  (x = null ? 0 : (Pif <- x.all , x.all->0, P(x)))
==>
  (x = null ? x = null : (x != null , Pif , Pif --|- x.all , P(x)))
==>
  ((x = null ? 0 : Pif) , (x = null ? 0 : (Pif --|- (x.all , P(x)))))
==>
  .. ??
==>
  ((x = null ? 0 : Pif) , (x = null ? 0 : Pif) --|- (x = null ? 0 : (x.all , P(x))))

However, currently I couldn't find a way to prove this.
The following let-helper/L8 will assume the above for now. Otherwise,
the permission format would just become too complicated.

Update: chatted with Dr. Boyland, and he confirmed that this is not provable.
I need to find a workaround for this.

Maybe something like this:

  (x = null ? 0 : (Pif <- x.all , x.all -> 0 , P(x)))
==>
  (x = null ? 0 : (Pif , Pif --|- (x.all , P(x))))
==>
  (x = null ? 0 : Pif) , (x = null ? 0 : Pif --|- (x.all , P(x)))

Update 2:

We KNOW that x is not null in this case, since it's a newly created object.
So, without the conditional, we can do the following:

  (Pif <- x.all , x.all -> 0, P(x))
==>
  (Pif , Pif --|- (x.all , Pif <- x.all , P(x)))
%}%

%theorem let-helper/L8
  : forall* {CM} {PM} {C} {FM} {CP} {FS} {FS0}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {DM-FM=FS: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    exists {Pf} {M2P: {x} fldmap2perm PM x FM FS (Pf x)}
    {IMP: {x} implies ((unique-obj-permission CP) x)
          (combine (Pf x)
            (unitperm
              (encumbered (Pf x) ((unique-obj-permission CP) x))))}
    true.

- : let-helper/L8 CM-CM CM2PM CML PML DM LEQ Pf ([x] FS=>Pf x)
    ([x] implies/trans6
      (implies/combine
        (implies/reflexive)
        (implies/trans3
          (implies/combine (implies/reflexive)
            (implies/trans3
              (implies/nonlinear bimplies/conj-duplicate)
              (implies/conj2combine)
              (implies/combine
                (implies/trans
                  (implies/equiv (EQV x))
                  (implies/nonlinear
                    (bimplies/trans4
                      (bimplies/predcall/Y/inline)
                      (bimplies/predcall/+/inline x)
                      (bimplies/predcall/0/inline)
                      (BIMP x))))
                (implies/reflexive))))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/equiv equiv/commute)
              (implies/carve))
            (implies/reflexive))))
      (implies/equiv equiv/commute)
      (implies/combine
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive add-encumber))
        (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (add-encumber))
      (implies/combine
        (implies/reflexive)
        (implies/equiv-encumbered
          (equiv/reflexive)
          (equiv/commute))))
     <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
     <- ({x:object} fldmap2perm-total CM-CM CM2PM CML DM LEQ _ (FS=>Pf x))
     <- clsmap-predmap-implies-lookup-format CM-PM PML _ PMLP ([x] PEQ x)
     <- ({x} permission`eq-implies-equiv (PEQ x) (EQV x))
     <- clsmap2predmap-implies-fldmap2conj CM2PM PMLP CML FM=>CJ
     <- let-helper/L7 FM=>CJ FS=>Pf ([x] BIMP x).

%worlds (objvar) (let-helper/L8 _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L8 _ _ _ _ _ _ _ _ _).


%theorem let-helper/L9/L
  : forall* {PF1} {PF2} {F} {Q}
    forall {EQ: {x}{x1} permission`eq (PF1 x x1) (PF2 x1)}
    exists {EQV: {x} equiv (scale Q (unitperm (precise-exists x F ([x1] PF1 x x1))))
                 (scale Q (unitperm (precise-exists x F ([x1] PF2 x1))))}
    true.

- : let-helper/L9/L ([_][_] permission`eq/) ([_] equiv/reflexive).

%worlds (objvar) (let-helper/L9/L _ _).
%total { } (let-helper/L9/L _ _).


%theorem let-helper/L9
  : forall* {CM} {PM} {FM} {B} {N} {A} {C} {FS} {Pf} {S} {M} {X} {Q}
    forall {SN} {SZ-FS=SN: set`size FS (s SN)}
    {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ nn/yes A C))}
    {CML: clsmap`lookup CM C FM}
    {FM2P: {x} fldmap2perm PM x FM FS (Pf x)}
    {N+FS=>S: nat+set2set N FS S}
    {S=>M: set2efxmap S X M}
    {X=>Q: efx2frac X Q}
    exists {Pf2} {M2P: {x} efxmap2perm CM PM (B x) M (Pf2 x)}
    {EQV: {x} equiv (scale Q (Pf x)) (Pf2 x)}
    true.

%theorem let-helper/L9L1
  : forall* {X1} {X2} {N} {D}
    forall {XID: efx-id N D X1 X2}
    exists {EQ: efx`eq X2 X1}
    true.

- : let-helper/L9L1 efx-id/ efx`eq/.

%worlds () (let-helper/L9L1 _ _).
%total { } (let-helper/L9L1 _ _).

%theorem let-helper/L9L2
  : forall* {PM} {FM} {FSP} {PF} {Q}
    forall {FSP=>PiP: {x} fldmap2perm PM x FM FSP (PF x)}
    {FSP=E: set`eq FSP set/0}
    exists {EQ: {x} equiv (scale Q (PF x)) empty}
    true.

- : let-helper/L9L2 ([_] fldmap2perm/0) set`eq/ ([_] equiv/zero).

%worlds (objvar) (let-helper/L9L2 _ _ _).
%total { } (let-helper/L9L2 _ _ _).


- : {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ _ A C))}
    let-helper/L9 z SZ BL CML
    ([x] fldmap2perm/U (FSP=>PiP x) (F!<FSP:set`not-member FSP F)
      (FSP+F=FS:set`add FSP F FS) (FML:fldmap`lookup FM F T)
      (T2PFF x))
    (N+FS=>S:nat+set2set N FS S) (S=>M:set2efxmap S Xx M) (X=>Q:efx2frac Xx Q)
    %{=>}% _
    ([x] efxmap2perm/U (MP=>E x) N+F=K (BL x) (create-fldperm/ CML FML T2PF)
      X=>Q apply-nn/yes K!<MP MP+K=M)
    ([x] equiv/transitive
      (equiv/distribute)
      (equiv/combine (EQV x) (EQV2 x)))
    <- set`not-member-add-size-implies-empty F!<FSP FSP+F=FS SZ FSP=E
    <- nat+set2set/U-inversion N+FS=>S F!<FSP FSP+F=FS SP N+FSP=>SP K N+F=K SP+K=S
    <- nat+set2set-preserves-fresh N+FSP=>SP F!<FSP N+F=K K!<SP
    <- set2efxmap/U-inversion S=>M K!<SP SP+K=S MP Xx2 SP=>MP XID MP+K=M'
    <- let-helper/L9L1 XID (X2=X:efx`eq Xx2 Xx)
    <- efxmap`update-respects-eq MP+K=M' efxmap`eq/ nat`eq/ X2=X efxmap`eq/ MP+K=M
    <- nat+set2set-unique N+FSP=>SP nat+set2set/0 nat`eq/ FSP=E SP=E
    <- set2efxmap-unique SP=>MP set2efxmap/0 SP=E efx`eq/ MP=E
    <- set2efxmap-preserves-fresh K!<SP SP=>MP K!<MP
    <- efxmap`eq-symmetric MP=E E=MP
    <- ty2perm-no-var T2PFF _ ([r][o] EQF r o) T2PF
    <- let-helper/L9/L EQF EQV
    <- ({x} efxmap2perm-respects-eq efxmap2perm/0 clsmap`eq/ predmap`eq/ cxt`eq/
      E=MP permission`eq/ (MP=>E x))
    <- let-helper/L9L2 FSP=>PiP FSP=E EQV2.

- : {BL:{x} cxt`lookup (B x) N (cxt-info/ x (ty/ _ A C))}
    let-helper/L9 (s SN) SZ ([x] BL x) CML
    ([x] fldmap2perm/U (FSP=>PiP x)
      F!<FSP (FSP+F=FS:set`add FSP F FS) FML (T2PFF x))
    (N+FS=>S:nat+set2set N FS S)
    (S=>M:set2efxmap S Xx M) (X=>Q:efx2frac Xx Q) %{=>}% _
    ([x] efxmap2perm/U (MP=>Pf2P x) N+F=K (BL x) (create-fldperm/ CML FML T2PF)
      X=>Q apply-nn/yes K!<MP MP+K=M)
    ([x] equiv/transitive
      (equiv/distribute)
      (equiv/combine (EQV x) (EQV2 x)))
    <- ty2perm-no-var T2PFF _ ([r][o] EQF r o) T2PF
    <- let-helper/L9/L EQF EQV
    <- nat+set2set/U-inversion N+FS=>S F!<FSP FSP+F=FS SP N+FSP=>SP K N+F=K SP+K=S
    <- nat+set2set-preserves-fresh N+FSP=>SP F!<FSP N+F=K K!<SP
    <- set2efxmap/U-inversion S=>M K!<SP SP+K=S MP Xx2 SP=>MP XID MP+K=M'
    <- let-helper/L9L1 XID (X2=X:efx`eq Xx2 Xx)
    <- efxmap`update-respects-eq MP+K=M' efxmap`eq/ nat`eq/ X2=X efxmap`eq/ MP+K=M
    <- set`not-member-add-increases-size-converse SZ F!<FSP FSP+F=FS SZP
    <- let-helper/L9 SN SZP BL CML FSP=>PiP
      N+FSP=>SP SP=>MP X=>Q _ MP=>Pf2P EQV2
    <- set2efxmap-preserves-fresh K!<SP SP=>MP K!<MP.

%worlds (objvar) (let-helper/L9 _ _ _ _ _ _ _ _ _ _ _).
%total (SN) (let-helper/L9 SN _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L9*
  : forall* {CM} {PM} {FM} {B} {N} {A} {C} {FS} {Pf} {SN} {X} {Q}
    forall {SZ: set`size FS (s SN)}
    {BL: {x} cxt`lookup (B x) N (cxt-info/ x (ty/ nn/yes A C))}
    {CML: clsmap`lookup CM C FM}
    {FM2P: {x} fldmap2perm PM x FM FS (Pf x)}
    {X=>Q: efx2frac X Q}
    exists {Pf2} {S} {M}
    {N+FS=>S: nat+set2set N FS S}
    {S=>M: set2efxmap S X M}
    {M2P: {x} efxmap2perm CM PM (B x) M (Pf2 x)}
    {EQV: {x} equiv (scale Q (Pf x)) (Pf2 x)}
    true.

- : let-helper/L9* SZ BL CML FS2P X=>Q _ _ _ N+FS=>S S=>M M=>P EQV
    <- nat+set2set-total N+FS=>S
    <- set2efxmap-total S=>M
    <- let-helper/L9 _ SZ BL CML FS2P N+FS=>S S=>M X=>Q _ M=>P EQV.

%worlds (objvar) (let-helper/L9* _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L9* _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L10
  : forall* {M} {N} {Mout} {Min}
    forall {P: efxmap-partition-on-index M N Mout Min}
    exists {Mout<=M: efxmap`leq Mout M} {Min<=M: efxmap`leq Min M}
    {M2out^M2in: efxmap`disjoint Mout Min}
    {M2outuM2in=M: efxmap`join Mout Min M}
    true.

- : let-helper/L10 (efxmap-partition-on-index/ _ _ P) L1 L2 D J
    <- efxmap`partition-implies-leq P L1 L2
    <- efxmap`partition-implies-disjoint-join P D J.

%worlds (objvar) (let-helper/L10 _ _ _ _ _).
%total { } (let-helper/L10 _ _ _ _ _).


%theorem let-helper/L11
  : forall* {M} {MF} {N} {SF}
    forall {M-N: efxmap-same-object M N}
    {M=>S: efxmap-map-fields M MF}
    {DM-MF: efxmap`domain MF SF}
    exists {S} {MP} {N+SF=>S: nat+set2set N SF S}
    {S=>M: set2efxmap S efx/write MP}
    {M<=MP: efxmap`leq M MP} % domain also same
    true.

%worlds (objvar) (let-helper/L11 _ _ _ _ _ _ _ _).
%trustme %total { } (let-helper/L11 _ _ _ _ _ _ _ _).


%theorem let-helper/L11*
  : forall* {M} {MF} {N} {SF} {S} {MP}
    forall {M-N: efxmap-same-object M N}
    {M=>S: efxmap-map-fields M MF}
    {DM-MF: efxmap`domain MF SF}
    {N+SF=>S: nat+set2set N SF S}
    {S=>M: set2efxmap S efx/write MP}
    exists {M<=MP: efxmap-vleq M MP} % domain also same
    true.

%worlds (objvar) (let-helper/L11* _ _ _ _ _ _).
%trustme %total { } (let-helper/L11* _ _ _ _ _ _).


% should go to efxmap-base.elf

%theorem let-helper/L12
  : forall* {M} {S} {M2}
    forall {M2<=M: efxmap`leq M2 M}
    {DM-M2=S: efxmap`domain M2 S}
    exists {M1} {M2P} {MP: efxmap`partition M S M1 M2P}
    {M2<=M2P: efxmap-vleq M2 M2P}
    true.

%worlds (objvar) (let-helper/L12 _ _ _ _ _ _).
%trustme %total { } (let-helper/L12 _ _ _ _ _ _).


%theorem let-helper/L13
  : forall* {M1} {M2} {M} {M1P} {M2P} {MP}
    forall {M1<=M1P: efxmap`leq M1 M1P}
    {M2<=M2P: efxmap`leq M2 M2P}
    {M1+M2=M: efxmap`join M1 M2 M}
    {M1P+M2P=MP: efxmap`join M1P M2P MP}
    exists {M<=MP: efxmap`leq M MP}
    true.

%worlds (objvar) (let-helper/L13 _ _ _ _ _).
%trustme %total {} (let-helper/L13 _ _ _ _ _).


%theorem let-helper/L14
  : forall* {M} {N} {M1} {M2}
    forall {P: efxmap-partition-on-index M N M1 M2}
    exists {S} {P: efxmap`partition M S M1 M2}
    true.

- : let-helper/L14 (efxmap-partition-on-index/ _ _ P) _ P.

%worlds (objvar) (let-helper/L14 _ _ _).
%total { } (let-helper/L14 _ _ _).


%theorem let-helper/L15
  : forall* {PM} {NN} {C} {PF}
    forall {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    exists {PF2} {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF2}
    {IMP: {x} implies (PF x) ((PF x) , (PF2 x))}
    true.

- : let-helper/L15
    (ty2perm/ PML nn2perm/yes annot2perm/unique) _
    (ty2perm/ PML nn2perm/yes annot2perm/borrow)
    ([x] implies/trans5
      (implies/combine implies/duplicate
        (implies/trans
          (implies/combine implies/reflexive implies/duplicate)
          (implies/equiv equiv/associate)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive
        (implies/equiv equiv/associate))
      (implies/equiv equiv/roll2)
      (implies/combine implies/reflexive
        (implies/combine implies/reflexive
          (implies/equiv
            (equiv/transitive
              (equiv/symmetric equiv/identity)
              (equiv/commute)))))).

- : let-helper/L15
    (ty2perm/ PML nn2perm/may annot2perm/unique) _
    (ty2perm/ PML nn2perm/may annot2perm/borrow)
    ([x] implies/trans
      (implies/cond-inner
        bimplies/reflexive
        bimplies/reflexive
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/trans4
          (implies/combine
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/duplicate))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive (implies/equiv equiv/roll2))
          (implies/equiv equiv/associate)))
      (implies/cond-distribute)).

%worlds (objvar) (let-helper/L15 _ _ _ _).
%total { } (let-helper/L15 _ _ _ _).


%theorem let-helper/L16
  : forall* {CM} {B:object -> cxt} {M} {S} {Q}
    forall {CM-B-XX: {x} clsmap-cxt-effects CM (B x) (effects/ M S Q)}
    exists {R} {DM: efxmap`domain M R}
    {CM-B-R: {x} clsmap-cxt-fldset CM (B x) R}
    {CM-B-Q: {x} clsmap-cxt-objset CM (B x) Q}
    true.

- : let-helper/L16
    ([x] clsmap-cxt-effects/ DM R^S (Q=>FS x)
      (R^FS) S^FS (CM-B-R x) _ (CM-B-Q x))
    _ DM ([x] CM-B-R x) ([x] CM-B-Q x).

%worlds (objvar) (let-helper/L16 _ _ _ _ _).
%total { } (let-helper/L16 _ _ _ _ _).


%theorem let-helper/L17
  : forall* {CM} {B:object -> cxt} {M} {S} {Q} {OS} {SS} {N}
    forall {CM-B-XX: {x} clsmap-cxt-effects CM (B x) (effects/ M S Q)}
    {M=>OS: efxmap-map-objects M OS}
    {S=>SS: set-map-objects S SS}
    {MB: set`member OS N}
    exists {OUT-S: set`not-member SS N}
    {OUT-Q: set`not-member Q N}
    true.

%worlds (objvar) (let-helper/L17 _ _ _ _ _ _).
%trustme %total { } (let-helper/L17 _ _ _ _ _ _).


%theorem let-helper/L18
  : forall* {CM} {S} {OS} {Q} {N} {S2} {S3} {M3} {PM} {B} {Pi} {BP} {T}
    forall {S=>OS: set-map-objects S OS}
    {N!<OS: set`not-member OS N}
    {N!<Q: set`not-member Q N}
    {Q=>S2: objset2fldset CM B Q S2}
    {SuS2=S3: set`union S S2 S3}
    {S3=>M3: set2efxmap S3 efx/write M3}
    {M=>Pi: efxmap2perm CM PM B M3 Pi}
    {BF: cxt`fresh B N}
    {BU: {x} cxt`update B N (cxt-info/ x T) (BP x)}
    exists {BP+Q=>S2: {x} objset2fldset CM (BP x) Q S2}
    {M=>Pi: {x} efxmap2perm CM PM (BP x) M3 Pi}
    true.

%worlds (objvar) (let-helper/L18 _ _ _ _ _ _ _ _ _ _ _).
%trustme %total { } (let-helper/L18 _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L19
  : forall* {CM} {B} {BP} {N} {S} {T}
    forall {F: cxt`fresh B N}
    {U: {x} cxt`update B N (cxt-info/ x T) (BP x)}
    {CM-BP-XX: {x} clsmap-cxt-objset CM (BP x) S}
    {N!<S: set`not-member S N}
    exists {CM-B-XX: clsmap-cxt-objset CM B S}
    true.

%worlds (objvar) (let-helper/L19 _ _ _ _ _).
%trustme %total { } (let-helper/L19 _ _ _ _ _).


%theorem let-helper/L20
  : forall* {CM} {PM} {BP} {B} {Q} {PiQ} {N} {T}
    forall {Q=>PiQ: make-encumbered CM PM B Q PiQ}
    {F: cxt`fresh B N}
    {U: {x} cxt`update B N (cxt-info/ x T) (BP x)}
    {N!<Q: set`not-member Q N}
    exists {Q=>PiQ: {x} make-encumbered CM PM (BP x) Q PiQ}
    true.

%worlds (objvar) (let-helper/L20 _ _ _ _ _).
%trustme %total { } (let-helper/L20 _ _ _ _ _).


%theorem let-helper/L21
  : forall* {Mout} {Oout} {N} {T} {BP} {CM} {PM} {B} {Pi}
    forall {Rout=>Oout: efxmap-map-objects Mout Oout}
    {N!<Oout: set`not-member Oout N}
    {F: cxt`fresh B N}
    {U: {x} cxt`update B N (cxt-info/ x T) (BP x)}
    {M=>P: efxmap2perm CM PM B Mout Pi}
    exists {M=>P: {x} efxmap2perm CM PM (BP x) Mout Pi}
    true.

%worlds (objvar) (let-helper/L21 _ _ _ _ _ _).
%trustme %total { } (let-helper/L21 _ _ _ _ _ _).


%theorem let-helper/L21-converse
  : forall* {Mout} {Oout} {N} {T} {BP} {CM} {PM} {B} {PiP}
    forall {Rout=>Oout: efxmap-map-objects Mout Oout}
    {N!<Oout: set`not-member Oout N}
    {F: cxt`fresh B N}
    {U: {x} cxt`update B N (cxt-info/ x T) (BP x)}
    {M=>P: {x} efxmap2perm CM PM (BP x) Mout (PiP x)}
    exists {Pi} {M=>P: efxmap2perm CM PM B Mout Pi}
    {EQV: {x} equiv (PiP x) Pi}
    true.

%worlds (objvar) (let-helper/L21-converse _ _ _ _ _ _ _ _).
%trustme %total { } (let-helper/L21-converse _ _ _ _ _ _ _ _).


%%% This is a very brave assumption. We need to modify "compatible"
%%%  to get this proved.

%theorem let-helper/L22
  : forall* {CM} {B} {OS} {FS} {S} {Q} {M} {Mout} {Min} {MFin} {MFinP} {N}
    forall {CB: compatible CM B (targets/unique OS FS) (effects/ M S Q)}
    {SUB: efxmap-partition-on-index M N Mout Min}
    {Min=>MFin: efxmap-map-fields Min MFin}
    {OS+MFin=>MFinP: set+map2map OS MFin MFinP}
    exists {MFinP^Mout: efxmap`disjoint MFinP Mout}
    true.

%worlds (objvar) (let-helper/L22 _ _ _ _ _).
%trustme %total {} (let-helper/L22 _ _ _ _ _).


%theorem let-helper/L23
  : forall* {M} {MP} {M1} {M2} {S} {S1} {S2}
    forall {DM: efxmap`domain M S}
    {DMP: efxmap`domain MP S}
    {M<=MP: efxmap`leq M MP}
    {M1^M2: efxmap`disjoint M1 M2}
    {M1+M2=M: efxmap`join M1 M2 M}
    {DM-M1=S1: efxmap`domain M1 S1}
    {DM-M2=S2: efxmap`domain M2 S2}
    exists {M1P} {M2P}
    {DM-M1P=S1: efxmap`domain M1P S1}
    {DM-M2P=S2: efxmap`domain M2P S2}
    {M1<=M1P: efxmap`leq M1 M1P}
    {M2<=M2P: efxmap`leq M2 M2P}
    {M1P^M2P: efxmap`disjoint M1P M2P}
    {M1P+M2P=MP: efxmap`join M1P M2P MP}
    true.

%worlds (objvar) (let-helper/L23 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {} (let-helper/L23 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L24
  : forall* {M} {MF} {N}
    forall {M=>MF: efxmap-map-fields M MF}
    {M-N: efxmap-same-object M N}
    exists {N+MF=M: nat+map2map N MF M}
    true.

%worlds (objvar) (let-helper/L24 _ _ _).
%trustme %total { } (let-helper/L24 _ _ _).


%{%
 we have two context: the old context which we can look up for the object
  O and get a type (ty/ NN1 A C), and the updated context which we can
  lookup the variable x and the type (ty/ NN A C).
  NN is always less than or equal to NN1.
%}%

%theorem let-helper/L25L1L1
  : forall* {O2} {O2P} {N} {F} {Q} {PF} {NNP} {PiF}
    forall {EQ: object`eq O2 O2P} {EQ: nat`eq F N}
    {AN2:apply-nn NNP
          ([x:gterm objectk]
          scale Q (unitperm (precise-exists x N ([x1:gterm objectk] PF x1))))
          ([x:gterm objectk] PiF x)}
    {NNP=YES: nonnull`eq NNP nonnull/yes}
    exists {IMP: {x} implies (combine (unitperm (nonlinear (objequal x O2))) (PiF O2P))
                 (combine (scale Q (unitperm (precise-exists x F ([x] PF x))))
                   (unitperm (encumbered (scale Q ((unitperm (precise-exists x F ([x] PF x)))))
                               (PiF O2P))))}
    true.

- : let-helper/L25L1L1 (object`eq/:object`eq O2 O2) (nat`eq/:nat`eq N N)
    apply-nn/yes nonnull`eq/
    ([x] implies/trans
      (implies/combine (implies/nonlinear bimplies/objequal-symmetric)
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine implies/reflexive implies/self-implication)))
      (implies/objequal
        ([y] combine (scale Q (unitperm (precise-exists y N PF)))
          (unitperm (encumbered (scale Q (unitperm (precise-exists y N PF)))
                      (scale Q (unitperm (precise-exists O2 N PF)))))))).

%worlds (objvar) (let-helper/L25L1L1 _ _ _ _ _).
%total { } (let-helper/L25L1L1 _ _ _ _ _).


%theorem let-helper/L25L1
  : forall* {CM} {PM} {B} {O} {N1} {MF} {M2} {Pi2} {BF} {A} {C} {N2}
    forall {L: cxt`lookup B N2 (cxt-info/ O (ty/ nn/yes A C))}
    {N1!<B: cxt`fresh B N1}
    {B+N1=BF: {x} cxt`update B N1 (cxt-info/ x (ty/ nn/yes A C)) (BF x)}
    {N2+MF=M2: nat+map2map N2 MF M2}
    {M2=>Pi2: efxmap2perm CM PM B M2 Pi2}
    exists {M1} {Pi1}
    {N1+MF=M1: nat+map2map N1 MF M1}
    {M1=>Pi1: {x} efxmap2perm CM PM (BF x) M1 (Pi1 x)}
    {IMP: {x} implies (combine (unitperm (nonlinear (objequal x O))) Pi2)
          (combine (Pi1 x) (unitperm (encumbered (Pi1 x) Pi2)))}
    true.

- : let-helper/L25L1 _ _ _ nat+map2map/0 efxmap2perm/0 %{=>}% _ _
    (nat+map2map/0) ([_] efxmap2perm/0)
    ([x] implies/combine implies/nonlinear2empty implies/self-implication).

- : let-helper/L25L1 (BL:cxt`lookup B Nx2 (cxt-info/ O2 (ty/ nn/yes A C)))
    (N1!<B:cxt`fresh B Nx1) B+N=BF
    (nat+map2map/U (N2+MFP=M2P:nat+map2map Nx2 MFP M2P)
      (N2+F=K2:pair2nat (pair/ Nx2 F) K2)
      F!<MFP MFP+F+X=MF (M2P+K2+X=M2:efxmap`update M2P K2 Xx M2))
    M2=>Pi2
    %{=>}% _ _
    (nat+map2map/U N1+MFP=M1P (N1+F=K1:pair2nat (pair/ Nx1 F) K1) F!<MFP
      (MFP+F+X=MF:efxmap`update MFP F Xx MF)
      (M1P+K1+X=M1:efxmap`update M1P K1 Xx M1))
    ([x] efxmap2perm/U (M1P=>Pi12 x) N1+F=K1 (BFL x)
      (create-fldperm/ CML FML T2PF) X2Q apply-nn/yes K1!<M1P M1P+K1+X=M1)
    ([x] implies/trans7
      (implies/combine
        (implies/duplicate)
        (implies/equiv (equiv/symmetric (Pi21+Pi22<=>Pi2))))
      (implies/equiv
        (equiv/transitive
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive equiv/roll2)))
      (implies/combine
        (implies/reflexive)
        (implies/combine
          (implies/reflexive)
          (IMPP x)))
      (implies/equiv equiv/associate)
      (implies/combine (IMPP2 x) (implies/reflexive))
      (implies/equiv
        (equiv/transitive3
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive equiv/roll2)
          (equiv/associate)))
      (implies/combine implies/reflexive
        (implies/trans
          (implies/combine-merge-encumbered)
          (implies/equiv-encumbered
            (equiv/reflexive)
            (Pi21+Pi22<=>Pi2)))))
     <- nat+map2map-preserves-fresh N2+MFP=M2P F!<MFP N2+F=K2 K2!<M2P
     <- efxmap2perm/U-inversion M2=>Pi2 K2!<M2P M2P+K2+X=M2 %{=>}%
       N2P FP N2P+FP=K2 O2P NNP AP CP BL2 _ (create-fldperm/ CML2 FML2 T2PF)
       Q X2Q _ AN2 Pi22 M2P=>Pi22 (Pi21+Pi22<=>Pi2)
     <- let-helper/L25L1 BL N1!<B B+N=BF N2+MFP=M2P
       M2P=>Pi22 %{=>}% M1P Pi12 N1+MFP=M1P ([x] M1P=>Pi12 x) ([x] IMPP x)
     <- pair2nat-total (N1+F=K1: pair2nat (pair/ Nx1 F) K1)
     <- efxmap`update-total M1P+K1+X=M1
     <- ({x} cxt`update-implies-lookup (B+N=BF x) (BFL x))
     <- nat+map2map-preserves-fresh N1+MFP=M1P F!<MFP N1+F=K1 K1!<M1P
     <- nat2pair-unique N2+F=K2 N2P+FP=K2 nat`eq/ N2+F=N2P+FP
     <- pair-eq-implies-eq N2+F=N2P+FP N2=N2P F=FP
     <- cxt`lookup-unique BL BL2 cxt`eq/ N2=N2P CIE
     <- cxt-info-eq-inversion CIE O2=O2P TE
     <- ty-eq-inversion TE NN=NNP A=AP C=CP
     <- nat`eq-symmetric C=CP CP=C
     <- nat`eq-symmetric F=FP FP=F
     <- nonnull`eq-symmetric NN=NNP NNP=NN
     <- clsmap`lookup-respects-eq CML2 clsmap`eq/ CP=C fldmap`eq/ CML
     <- fldmap`lookup-respects-eq FML2 fldmap`eq/ FP=F ty`eq/ FML
     <- let-helper/L25L1L1 O2=O2P F=FP AN2 NNP=NN IMPP2.

%worlds (objvar) (let-helper/L25L1 _ _ _ _ _ _ _ _ _ _).
%total (M) (let-helper/L25L1 _ _ _ M _ _ _ _ _ _ ).


 %theorem let-helper/L25L2
   : forall* {O1} {O2} {Pi2} {Pi2P}
     forall {O1=O2: {x} object`eq (O1 x) O2}
     {IMP2:{x:gterm objectk}
                implies (combine (unitperm (nonlinear (objequal x O2))) Pi2)
            (combine (Pi2P x) (unitperm (encumbered (Pi2P x) Pi2)))}
     exists {IMP2:{x:gterm objectk}
                   implies
                   (combine (unitperm (nonlinear (objequal x (O1 x)))) Pi2)
                   (combine (Pi2P x) (unitperm (encumbered (Pi2P x) Pi2)))}
     true.

 - : let-helper/L25L2 ([_] object`eq/) IMP IMP.

 %worlds (objvar) (let-helper/L25L2 _ _ _).
 %total { } (let-helper/L25L2 _ _ _).


 %theorem let-helper/L25L3
   : forall* {B} {N} {OF:object -> object} {TF}
     forall {BL: {x} cxt`lookup B N (cxt-info/ (OF x) TF)}
     exists {O} {T} {BL: cxt`lookup B N (cxt-info/ O T)}
     {EQ: {x} object`eq (OF x) O}
     true.

 - : let-helper/L25L3
     ([_] cxt`lookup/= N1=N2) _ _ (cxt`lookup/= N1=N2) ([_] object`eq/).

 - : let-helper/L25L3
     ([x] cxt`lookup/> (BL x) P) _ _ (cxt`lookup/> BLP P) EQF
     <- let-helper/L25L3 BL _ _ BLP EQF.

 %worlds (objvar) (let-helper/L25L3 _ _ _ _ _).
 %total (L) (let-helper/L25L3 L _ _ _ _).


 %{
 To prove this, we do induction on set S.
 We take one element from S, say N. We show that
 with N + MF, we get a map M2, and from M2 we get permission Pi2.
 Also, after removing N from S, we get a set SP, and by induction
 we get a map M1, and permission Pi1.
 }%

 %theorem let-helper/L25
   : forall* {CM} {PM} {B} {M} {S} {MF} {Pi} {GF} {C} {BF} {N}
     forall {SN} {SZ: set`size S (s SN)}
     {CM-B-S: clsmap-cxt-unique-objset CM B nn/yes C S}
     {S+MF=M: set+map2map S MF M}
     {M=>Pi: efxmap2perm CM PM B M Pi}
     {S=>G: {x} set2cond B x S (GF x)}
     {N!<B: cxt`fresh B N}
     {B+N=BF: {x} cxt`update B N (cxt-info/ x (ty/ nn/yes annot/borrow C)) (BF x)}
     exists {MN} {Pf}
     {N+MF=MN: nat+map2map N MF MN}
     {M=>Pf: {x} efxmap2perm CM PM (BF x) MN (Pf x)}
     {IMP: {x} implies (combine (GF x) Pi)
           (combine (GF x) (combine (Pf x) (unitperm (encumbered (Pf x) Pi))))}
     true.

 - : {S=>GF: {x} set2cond B x S (GF x)}
     let-helper/L25 _ SZ S-NN-C
     (set+map2map/U SP+MF=M1 N1+MF=M2 (N1!<SP:set`not-member SP Nx1)
       SP+N1=S (M1+M2=M:efxmap`join M1 M2 M))
     M=>Pi
     ([x] S=>GF x) BF ([x] BU x)
      %{=>}% MN _
     (N+MF=MN:nat+map2map Nx MF MN)
     ([x] MN=>Pf x)
    ([x] implies/trans7
      (implies/combine (GF=>EQ+GFP x) (implies/equiv (Pi<=>Pi1+Pi2)))
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans7
          (implies/combine implies/reflexive (implies/equiv equiv/identity))
          (implies/equiv
            (equiv/transitive
              (equiv/combine equiv/reflexive equiv/commute)
              (equiv/associate)))
          (implies/combine (IMP2P x)
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/self-implication)
                  (implies/equiv-encumbered
                    (Pi<=>Pi1+Pi2)
                    (equiv/reflexive))
                  (implies/combine-assoc-encumbered)))
              (implies/linear-modus-ponens)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive implies/chain-implication)
          (implies/combine (implies/equiv (Pi2P<=>Pf x))
            (implies/equiv-encumbered (Pi2P<=>Pf x) equiv/reflexive))
          (implies/equiv
            (equiv/transitive (equiv/symmetric equiv/identity) (equiv/commute))))
        (implies/trans4
          (implies/combine
            (implies/nonlinear2empty)
            (implies/trans3
              (implies/equiv equiv/commute)
              (implies/equiv equiv/associate)
              (implies/combine
                (GFP+Pi1=>Pf+Pf-Pi1 x)
                (implies/reflexive))))
          (implies/equiv
            (equiv/transitive equiv/commute equiv/identity))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine implies/reflexive
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/transitive
                          (Pi<=>Pi1+Pi2)
                          (equiv/commute))
                        (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive implies/chain-implication)))))
      (implies/cond-distribute)
      (implies/combine
        (EQ+GFP=>GF x) (implies/cond-equal)))
     <- ({x} set2cond/U-inversion (S=>GF x) N1!<SP SP+N1=S (GFP x)
          (SP=>GFP x) (OF x) T (BL1 x)
          (GF=>EQ+GFP x) (EQ+GFP=>GF x))
     <- let-helper/L25L3 BL1 _ _ BL1P ([x] OF=O1 x)
     <- clsmap-cxt-unique-objset/U-inversion S-NN-C N1!<SP SP+N1=S
       SP-NN-C O2 _ BL2 (nonnull`leq/= nonnull`eq/)
     <- cxt`lookup-unique BL1P BL2 cxt`eq/ nat`eq/ CIE
     <- cxt-info-eq-inversion CIE O1=O2 TE
     <- ({x} object`eq-transitive (OF=O1 x) O1=O2 (OF=O2 x))
     <- not-member-nat+map2map-implies-disjoint SP+MF=M1 N1+MF=M2 N1!<SP M1^M2
     <- efxmap`disjoint-join-implies-equiv M1^M2 M1+M2=M M=>Pi
       Pi1 Pi2 M1=>Pi1 M2=>Pi2 (Pi<=>Pi1+Pi2:equiv Pi (combine Pi1 Pi2))
     <- set`not-member-add-increases-size-converse SZ N1!<SP SP+N1=S SZP
     <- let-helper/L25 _ SZP SP-NN-C SP+MF=M1 M1=>Pi1 ([x] SP=>GFP x)
       BF ([x] BU x) _ _ N+MF=MN ([x] MN=>Pf x) (GFP+Pi1=>Pf+Pf-Pi1)
     <- let-helper/L25L1 BL2 BF ([x] BU x) N1+MF=M2 M2=>Pi2
       _ _ N+MF=M2P ([x] BF+M2P=>Pi2P x) ([x] IMP2 x)
     <- nat+map2map-unique N+MF=M2P N+MF=MN nat`eq/ efxmap`eq/ M2P=MN
    <- ({x} efxmap2perm-equiv (BF+M2P=>Pi2P x) (MN=>Pf x) clsmap`eq/
         predmap`eq/ cxt`eq/ M2P=MN (Pi2P<=>Pf x))
    <- let-helper/L25L2 OF=O2 IMP2 IMP2P.

 - : let-helper/L25 z SZ CM-B-S
     (set+map2map/U SP+MF=MP1 NP+MF=>MP2 NP!<SP (SP+NP=S:set`add SP NP S)
       (MP1+MP2=M:efxmap`join MP1 MP2 M))
     M=>Pi ([x] S=>GF x) BF BU %{=>}% _ _
     (N+MF=>MN:nat+map2map N MF MN) MN=>Pf
     ([x] implies/trans8
       (implies/combine (GIMP1 x) implies/reflexive)
       (implies/equiv equiv/commute)
       (implies/cond-push)
       (implies/cond-gen-inner)
       (implies/cond-inner
         (bimplies/reflexive)
         (bimplies/reflexive)
         (implies/trans3
           (implies/combine
             (implies/reflexive)
             ((implies/equiv equiv/identity)))
           (IMPP2 x)
           (implies/equiv (equiv/symmetric equiv/identity)))
         (implies/trans5
           (implies/combine implies/nonlinear2empty
             (implies/combine implies/reflexive (GFP=>F x)))
           (implies/equiv (equiv/transitive equiv/commute equiv/identity))
           (implies/combine implies/reflexive implies/duplicate)
           (implies/equiv equiv/associate)
           (implies/combine
             (implies/trans3
               (implies/equiv equiv/commute)
               (implies/combine (implies/contradiction) implies/reflexive)
               (IMPP2 x))
             (F=>GFP x))))
       (implies/cond-pull)
       (implies/equiv equiv/commute)
       (implies/combine (GIMP2 x) implies/reflexive))
     <- set`not-member-add-size-implies-empty NP!<SP SP+NP=S SZ SP=0
     <- ({x} set2cond/U-inversion (S=>GF x) NP!<SP SP+NP=S (GFP x) (SP=>GFP x)
       (OF x) _ (BL x) (GIMP1 x) (GIMP2 x))
     <- let-helper/L25L3 BL _ _ BL1 ([x] OF=O2 x)
     <- clsmap-cxt-unique-objset/U-inversion CM-B-S NP!<SP SP+NP=S
       CM-B-SP O1 _ BLP (nonnull`leq/= nonnull`eq/)
     <- set+map2map-unique SP+MF=MP1 set+map2map/0 SP=0 efxmap`eq/ MP1=0
     <- efxmap`join-unique MP1+MP2=M efxmap`join/L MP1=0 efxmap`eq/ M=MP2
     <- efxmap2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/ cxt`eq/ M=MP2
       permission`eq/ MP2=>Pi
     <- let-helper/L25L1 BLP BF BU NP+MF=>MP2 MP2=>Pi _ _ N+MF=>MN MN=>Pf IMPP
     <- efxmap`eq-symmetric M=MP2 MP2=M
     <- cxt`lookup-unique BL1 BLP cxt`eq/ nat`eq/ CIE
     <- cxt-info-eq-inversion CIE O2=O1 TE
     <- ({x:object} object`eq-transitive (OF=O2 x) O2=O1 (OF=O1 x))
     <- let-helper/L25L2 OF=O1 IMPP IMPP2
     <- ({x} set2cond-implies (SP=>GFP x) set2cond/0 object`eq/ SP=0 (GFP=>F x) (F=>GFP x)).

%worlds (objvar) (let-helper/L25 _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N) (let-helper/L25 N _ _ _ _ _ _ _ _ _ _ _ _).


 %theorem let-helper/L26
   : forall* {CM} {B} {FS} {M} {OS} {S} {Q} {Mout} {Min} {MFin} {N} {Min2} {Min1} {X}
     forall {CB: compatible CM B (targets/unique OS FS) (effects/ M S Q)}
     {M|N=Mout+Min: efxmap-partition-on-index M N Mout Min}
     {Min=>MFin: efxmap-map-fields Min MFin}
     {S+MFin=Min2: set+map2map OS MFin Min2}
     {FS+X=MF: set2efxmap FS X Min1}
     exists {Min2^Mout: efxmap`disjoint Min2 Mout}
     {Min1^Mout: efxmap`disjoint Min1 Mout}
     true.

 %worlds (objvar) (let-helper/L26 _ _ _ _ _ _ _).
 %trustme %total {} (let-helper/L26 _ _ _ _ _ _ _).

 %% Now, for all objects in MP, they are of the same nonnull-ness.
 %% If they are not-null, then in the output we add a objequal relation
 %% for variable x.

 %theorem let-helper/L27
   : forall* {CM} {PM} {B} {M} {M2} {MF} {S} {N} {MP} {C} {BF} {GF} {Pi}
     forall {SN} {SZ: set`size S (s SN)}
     {M=>MF: efxmap-map-fields M2 MF}
     {M-N: efxmap-same-object M2 N}
     {CM-B-S: clsmap-cxt-unique-objset CM B nn/yes C S}
     {S+MF=>M: set+map2map S MF M}
     {M=<=MP: efxmap-vleq M MP}
     {MP=>Pi: efxmap2perm CM PM B MP Pi}
     {S=>G: {x} set2cond B x S (GF x)}
     {N!<B: cxt`fresh B N}
     {B+N=BF: {x} cxt`update B N (cxt-info/ x (ty/ nn/yes annot/borrow C)) (BF x)}
     exists {Pf}
     {N+MF=M2: nat+map2map N MF M2}
     {M2=>Pf: {x} efxmap2perm CM PM (BF x) M2 (Pf x)}
     {IMP: {x} implies (combine (GF x) Pi)
           (combine (GF x)
             (combine (Pf x) (unitperm (encumbered (Pf x) Pi))))}
     true.

 - : let-helper/L27 _ SZ M2=>MF M2-N CM-B-S S+MF=M M=<=MP MP=>PiP
     ([x] S=>GF x) N!<B ([x] B+N=BF x) %{=>}% _ N+MF=M2 ([x] M2=>Pf x)
     ([x] implies/trans5
       (implies/combine implies/reflexive (implies/equiv PiP<=>Pi+Pi3))
       (implies/equiv equiv/associate)
       (implies/combine (IMP1 x)
         (implies/trans3
           (implies/equiv (equiv/symmetric equiv/identity))
           (implies/combine
             (implies/reflexive)
             (implies/trans3
               (implies/self-implication)
               (implies/equiv-encumbered
                 (equiv/transitive (PiP<=>Pi+Pi3) equiv/commute)
                 (equiv/reflexive))
               (implies/combine-assoc-encumbered)))
           (implies/linear-modus-ponens)))
       (implies/equiv
         (equiv/transitive
           (equiv/symmetric equiv/associate)
           (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))
       (implies/combine implies/reflexive
         (implies/combine implies/reflexive
           (implies/chain-implication))))
     <- let-helper/L24 M2=>MF M2-N N+MF=M2
     <- efxmap-vleq-implies-leq M=<=MP M<=MP
     <- efxmap2perm-respects-geq MP=>PiP M<=MP Pi Pi3 M=>Pi PiP<=>Pi+Pi3
     <- let-helper/L25 _ SZ CM-B-S S+MF=M M=>Pi ([x] S=>GF x) N!<B
       ([x] B+N=BF x) MN Pf N+MF=MN ([x] MN=>Pf x) ([x] IMP1 x)
     <- nat+map2map-unique N+MF=MN N+MF=M2 nat`eq/ efxmap`eq/ MN=M2
     <- ({x} efxmap2perm-respects-eq (MN=>Pf x) clsmap`eq/ predmap`eq/ cxt`eq/ MN=M2
       permission`eq/ (M2=>Pf x)).

%worlds (objvar) (let-helper/L27 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper/L27 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper/L28
  : forall* {M} {S} {M1} {M2} {MP}
    forall {M|S=M1+M2: efxmap`partition M S M1 M2}
    {MP<=M: efxmap`leq MP M} {DM-MP=S: efxmap`domain MP S}
    exists {MP=<=M2: efxmap-vleq MP M2}
    true.

%worlds () (let-helper/L28 _ _ _ _).
%trustme %total {} (let-helper/L28 _ _ _ _).


%theorem let-helper/L29
  : forall* {OS} {MF} {M} {FS}
    forall {OS+MF=M: set+map2map OS MF M}
    {OS^FS: set`disjoint OS FS}
    exists {MS} {DM-M=MS: efxmap`domain M MS}
    {FS^MS: set`disjoint FS MS}
    true.

%worlds () (let-helper/L29 _ _ _ _ _).
%trustme %total {} (let-helper/L29 _ _ _ _ _).


%theorem  let-helper/L30
  : forall* {M1} {M2} {M} {S} {MP} {SP} {S2}
    forall {M|S=M1+M2: efxmap`partition M S M1 M2}
    {MP<=M: efxmap`leq MP M}
    {DM-MP=SP: efxmap`domain MP SP}
    {DM-M2=S2: efxmap`domain M2 S2}
    {SP^S2: set`disjoint SP S2}
    exists {MP<=M1: efxmap`leq MP M1}
    true.

%worlds () (let-helper/L30 _ _ _ _ _ _).
%trustme %total {} (let-helper/L30 _ _ _ _ _ _).


%theorem let-helper/L31
  : forall* {M} {M1} {M2} {S} {S0}
    forall {P: efxmap`partition M S M1 M2}
    {DM-M=S0: efxmap`domain M S0} {S<=S0: set`leq S S0}
    exists {DM-M2=S: efxmap`domain M2 S}
    true.

%worlds () (let-helper/L31 _ _ _ _).
%trustme %total {} (let-helper/L31 _ _ _ _).


%theorem let-helper/L32
  : forall* {CM} {BP:object -> cxt} {M} {S} {Q} {FS} {SFS} {X} {M2}
    forall {CM-BP-XX: {x} clsmap-cxt-effects CM (BP x) (effects/ M S Q)}
    {Q=>FS: {x} objset2fldset CM (BP x) Q FS}
    {S+FS=SFS: set`union S FS SFS}
    {SFS=>M2: set2efxmap SFS X M2}
    exists {M^M2: efxmap`disjoint M M2}
    true.

% - : let-helper/L32
%     (clsmap-cxt-effects/ DM-M=R R^S Q=>FS R^FS S^FS _ _ _)
%     Q=>FS' S+FS'=SFS SFS+X=>M2 M^M2
%     <- objset2fldset-unique Q=>FS Q=>FS' clsmap`eq/ cxt`eq/ set`eq/ FS=FS'
%     <- set`disjoint-respects-eq R^FS set`eq/ FS=FS' R^FS'
%     <- set`union-right-preserves-disjoint* R^S R^FS' S+FS'=SFS R^SFS
%     <- set2efxmap-implies-domain SFS+X=>M2 DM-M2=SFS
%     <- efxmap`domain-preserves-disjoint-converse R^SFS DM-M=R DM-M2=SFS M^M2.

%worlds () (let-helper/L32 _ _ _ _ _).
%trustme %total { } (let-helper/L32 _ _ _ _ _).


%theorem let-helper/L33
  : forall* {M} {M2}
    forall {M1<=M: efxmap`leq M2 M}
    exists {M1} {M2P} {SP: efxmap-split M M1 M2P}
    {M2=<=M2P: efxmap-vleq M2 M2P}
    true.

%worlds () (let-helper/L33 _ _ _ _ _).
%trustme %total { } (let-helper/L33 _ _ _ _ _).


%theorem let-helper/L34
  : forall* {MP} {M3} {M0} {M01} {M02}
    forall {MP+M3=M0: efxmap-split M0 MP M3}
    {M01+M02=M0: efxmap-split M0 M01 M02}
    {M02^M3: efxmap`disjoint M02 M3}
    exists {M01P} {M01P+MP3=M01: efxmap-split M01 M01P M3}
    {M01P+M02=MP: efxmap-split MP M01P M02}
    true.

%worlds () (let-helper/L34 _ _ _ _ _ _).
%trustme %total {} (let-helper/L34 _ _ _ _ _ _).


%theorem let-helper/L35
  : forall* {M} {N} {Mout} {Min}
    forall {PT: efxmap-partition-on-index M N Mout Min}
    exists {ESO: efxmap-same-object Min N}
    true.

%worlds () (let-helper/L35 _ _).
%trustme %total { } (let-helper/L35 _ _).


%theorem let-helper/L36
  : forall* {M2} {N} {M2out} {M2outP} {M2in}
    forall {M2|N=M2out+M2in: efxmap-partition-on-index M2 N M2out M2in}
    {M2out=<=M2outP: efxmap-vleq M2out M2outP}
    exists {M2P} {M2P|N=M2outP+M2in: efxmap-partition-on-index M2P N M2outP M2in}
    {M2=<=M2P: efxmap-vleq M2 M2P}
    true.

%worlds () (let-helper/L36 _ _ _ _ _).
%trustme %total {} (let-helper/L36 _ _ _ _ _).


%theorem efxmap-vleq-preserves-efxmap-map-objects
  : forall* {M} {MP} {S}
    forall {M=>S: efxmap-map-objects M S}
    {M=<=MP: efxmap-vleq M MP}
    exists {MP=>S: efxmap-map-objects MP S}
    true.

%worlds (objvar) (efxmap-vleq-preserves-efxmap-map-objects _ _ _).
%trustme %total { } (efxmap-vleq-preserves-efxmap-map-objects _ _ _).


%theorem efxmap-vleq-preserves-efxmap-map-objects-converse
  : forall* {M} {MP} {S}
    forall {M=>S: efxmap-map-objects MP S}
    {M=<=MP: efxmap-vleq M MP}
    exists {MP=>S: efxmap-map-objects M S}
    true.

%worlds (objvar) (efxmap-vleq-preserves-efxmap-map-objects-converse _ _ _).
%trustme %total { } (efxmap-vleq-preserves-efxmap-map-objects-converse _ _ _).


% Similar to let-helper/L21
%theorem cxt2perm-fresh-update-no-var/L
  : forall* {CM} {PM} {B} {Pi1:object -> permission}
    forall {M=>P: {x} cxt2perm CM PM B (Pi1 x)}
    exists {Pi2} {M=>P: cxt2perm CM PM B Pi2}
    {EQV: {x} equiv (Pi1 x) Pi2}
    true.

% - : cxt2perm-fresh-update-no-var/L ([_] cxt2perm/0) _ cxt2perm/0 ([_] equiv/reflexive).

% - : cxt2perm-fresh-update-no-var/L
%     ([x] cxt2perm/U (B=>PiB x) (BF x) (BU x) (T2PF x)) _ (cxt2perm/U B=>PiB' BF' BU' T2PF')
%     ([x] equiv/combine (EQV2 x) (EQV x)).
%     <- cxt2perm-fresh-update-no-var/L ([x] B=>PiB x) _ B=>PiB' EQV.

%worlds (objvar) (cxt2perm-fresh-update-no-var/L _ _ _ _).
%trustme %total (B) (cxt2perm-fresh-update-no-var/L B _ _ _).


%theorem cxt2perm-fresh-update-no-var
  : forall* {CM} {PM} {N} {B} {BP} {PiBP} {NN} {A} {C}
    forall {BF: cxt`fresh B N}
    {BU: {x} cxt`update B N (cxt-info/ x (ty/ NN A C)) (BP x)}
    {BP=>PiBP: {x} cxt2perm CM PM (BP x) (PiBP x)}
    exists {PF} {PiB} {B=>PiB: cxt2perm CM PM B PiB}
    {T=>PF: ty2perm PM (ty/ NN A C) PF}
    {EQV: {x} equiv (PiBP x) ((PF x) , PiB)}
    true.

- : cxt2perm-fresh-update-no-var BF ([x] BU x) ([x] BP=>PiBP x) _ _ B=>PiB' T2PF
    ([x] equiv/transitive
      (EQV x)
      (equiv/combine (EQV4 x) (EQV2 x)))
    <- ({x} cxt2perm/U-inversion (BP=>PiBP x) BF (BU x) _ (B=>PiB x) _ (T2PFF x) (EQV x))
    <- cxt2perm-fresh-update-no-var/L ([x] B=>PiB x) _ B=>PiB' EQV2
    <- ty2perm-no-var T2PFF _ ([r][o] EQF r o) T2PF
    <- ({x} permission`eq-implies-equiv (EQF x x) (EQV4 x)).


%worlds (objvar) (cxt2perm-fresh-update-no-var _ _ _ _ _ _ _ _).
%total { } (cxt2perm-fresh-update-no-var _ _ _ _ _ _ _ _).


 %{%
 This format records properties about three permissions:
   1). the permission for "x"
   2). the permission for where "x" come from
   3). the rest of permission after taking the permissions for
      checking e2.

 I think for 1), it should always be the same.
 %}%

 let-output-format : clsmap -> predmap -> cxt ->
    nat -> reftype -> effects -> effects -> (object -> expr-output) -> type.

 let-output-format/simple/unique
   : ({x} cxt`update B N (cxt-info/ x (ty/ NN annot/borrow C)) (BP x))
     -> ty2perm PM (ty/ NN annot/unique C) ([x] Pf x)
     -> efxmap-partition-on-index M2 N M2out M2in
     -> efxmap-split M M1 M2out
     -> ({x} efxmap2perm CM PM (BP x) M2in (Pxf x))
     -> efxmap2perm CM PM B M1 Pi3
     -> let-output-format CM PM B N (reftype/ NN C unique-target)
       (effects/ M _ _) (effects/ M2 S2 Q2)
       ([x] output/expr x
         (combine (unitperm (encumbered (Pxf x) (Pf x))) Pi3)).

 let-output-format/unique/0f
   : ({x} cxt`update B N (cxt-info/ x (ty/ NN annot/borrow C)) (BP x))
     -> set`size OS (s _)
     -> ({x} set2cond B x OS (PiG x))
     -> efxmap-partition-on-index M2 N M2out M2in
     -> efxmap-split M M1 M2outk
     -> efxmap-split M2outk Mk1 M2out
     -> ({x} efxmap2perm CM PM (BP x) M2in (Pxf x))
     -> efxmap2perm CM PM B Mk1 Pf
     -> efxmap2perm CM PM B M1 Pi3
     -> let-output-format CM PM B N (reftype/ NN C (targets/unique OS set/0))
       (effects/ M _ _) (effects/ M2 S2 Q2)
       ([x] output/expr x
         (combine (PiG x)
           (combine (unitperm (encumbered (Pxf x) Pf)) Pi3))).

 let-output-format/unique/+f
   : ({x} cxt`update B N (cxt-info/ x (ty/ nn/yes annot/borrow C)) (BP x))
     -> set`size OS (s _)
     -> set`size FS (s _)
     -> ty2perm PM (ty/ nn/yes annot/unique C) ([x] PF x)
     -> ({x} set2cond B x OS (PiG x))
     -> efxmap-partition-on-index M2 N M2out M2in
     -> efxmap-split M MP Mk2
     -> efxmap-split MP M1 M12
     -> efxmap-split M12 Mk1 M2out
     -> ({x} efxmap2perm CM PM (BP x) M2in (Pxf x))
     -> efxmap2perm CM PM B Mk1 Pf1
     -> efxmap2perm CM PM B Mk2 Pf2
     -> efxmap2perm CM PM B M1 Pi3
     -> efxmap-min-efx Mk2 X
     -> efx2frac X Z
     -> let-output-format CM PM B N (reftype/ nn/yes C (targets/unique OS FS))
       (effects/ M _ _) (effects/ M2 S2 Q2)
       ([x] output/exists [v]
         (output/expr x
           (combine (unitperm (conditional (objequal x v) empty (PiG x)))
               (combine
                 (unitperm
                   (encumbered (Pxf x) (combine Pf1 (scale Z (PF v)))))
                 (combine (unitperm (encumbered (scale Z (PF v)) Pf2)) Pi3))))).


 %% ----------------------------------------------------
 %% Main Theorems
 %% ----------------------------------------------------

%theorem let-helper-before/unique/F
   : forall* {CM} {PM} {B} {Q} {Out0} {OS} {XX2} {N} {NN} {C} {XXV} {BP:object -> cxt}
     forall {F:void}
     exists {PiQ} {Pi2} {Out1} {Out2} {Out3} {XX2A}
     {Q=>PiQ: make-encumbered CM PM B Q PiQ}
     {EA: envadd PiQ Out0 Out1}
     {XX2<c=XX2A: effects-leq-no-consume XX2 XX2A}
     {FMT: let-output-format CM PM B N (reftype/ NN C (targets/unique OS set/0)) XXV XX2A Out2}
     {XX2A=>Pi2: {x} effects2input CM PM (BP x) XX2A (Pi2 x)}
     {EA: {x} envadd (Pi2 x) (Out2 x) (Out3 x)}
     {TRANS: transform Out1 (output/exists [x] (Out3 x))}
     true.

 %worlds (objvar) (let-helper-before/unique/F _ _ _ _ _ _ _ _ _ _ _ _ _ _).
 %total {} (let-helper-before/unique/F _ _ _ _ _ _ _ _ _ _ _ _ _ _).


 %theorem let-helper-before/unique
   : forall* {CM} {PM} {B} {XX1} {XX2} {XX} {XX0} {Q} {XX2P}
     {NN} {C} {Out0} {N} {BP} {XXV} {FM} {OS} {Z}
     forall {CM-CM: clsmap-clsmap CM CM}
     {CM2PM: clsmap2predmap CM PM}
     {CM-B-OS: clsmap-cxt-unique-objset CM B NN C OS}
     {BF: cxt`fresh B N}
     {BU: {x} cxt`update B N (cxt-info/ x (ty/ NN annot/borrow C)) (BP x)}
     {CML: clsmap`lookup CM C FM} % not sure whether we need this!
     {CM-B-XX2: {x} clsmap-cxt-effects CM (BP x) XX2}
     {CM-B-XX2P: clsmap-cxt-effects CM B XX2P}
     {CM-B-XXV: clsmap-cxt-effects CM B XXV}
     {SUB: subst-effects CM B NN (targets/unique OS set/0) N XX2 XX2P}
     {XX1+XX2P=XX: effects`join XX1 XX2P XX}
     {XX<=XXV: effects-leq-no-consume XX XXV}
     {TC: transfer-consume CM B XXV XX1 XX0 Q}
     {SZ-OS: set`size OS (s Z)}
     {XX0=>Piin: effects2output CM PM B (reftype/ NN C (targets/unique OS set/0)) XX0 Out0}
     exists {PiQ} {Pi2} {Out1} {Out2} {Out3} {XX2A}
     {Q=>PiQ: make-encumbered CM PM B Q PiQ}
     {EA: envadd PiQ Out0 Out1}
     {XX2<c=XX2A: effects-leq-no-consume XX2 XX2A}
     {FMT: let-output-format CM PM B N (reftype/ NN C (targets/unique OS set/0)) XXV XX2A Out2}
     {XX2A=>Pi2: {x} effects2input CM PM (BP x) XX2A (Pi2 x)}
     {EA: {x} envadd (Pi2 x) (Out2 x) (Out3 x)}
     {TRANS: transform Out1 (output/exists [x] (Out3 x))}
     true.

 - : let-helper-before/unique CM-CM CM2PM CM-B-OS N!<B ([x] B+N=BF x)
     CML ([x] CM-BP-XX2 x) CM-B-XX2P CM-B-XXV
     (subst-effects/unique/1 CB
       (S2=>R2:set-map-objects S2 R2) _ _ N!<R2 N!<Q2 _)
     XX1+XX2P=XX (effects-leq-no-consume/ (M<=MP: efxmap`leq M MP))
     (XXV+XX1=>XX0+QP: transfer-consume CM B _ _ _ QP)
     SZ (effects2output/simple _ _ simple-targets/unique _ _)
     %{=>}% _ _ _ _ K1 K2 K3 K4 K5 K6 K7 K8 K9
     <- set`size-unique set`size/0 SZ set`eq/ EQ
     <- nat`eq-contradiction EQ F
     <- let-helper-before/unique/F F _ _ _ _ K1 K2 K3 K4 K5 K6 K7 K8 K9.

 - : let-helper-before/unique CM-CM CM2PM _ N!<B ([x] B+N=BF x)
     CML ([x] CM-BP-XX2 x) CM-B-XX2P CM-B-XXV
     (subst-effects/unique/1 CB
       (S2=>R2:set-map-objects S2 R2) _ _ N!<R2 N!<Q2 _)
     XX1+XX2P=XX (effects-leq-no-consume/ (M<=MP: efxmap`leq M MP))
     (XXV+XX1=>XX0+QP: transfer-consume CM B _ _ _ QP)
     _ (effects2output/unique/+f T2PF _ _ _ _ _ _ _ SZ)
     %{=>}% _ _ _ _ K1 K2 K3 K4 K5 K6 K7 K8 K9
     <- set`size-unique set`size/0 SZ set`eq/ EQ
     <- nat`eq-contradiction EQ F
     <- let-helper-before/unique/F F _ _ _ _ K1 K2 K3 K4 K5 K6 K7 K8 K9.

 - : let-helper-before/unique CM-CM CM2PM CM-B-OS N!<B ([x] B+N=BF x)
     CML ([x] CM-BP-XX2 x) CM-B-XX2P CM-B-XXV
     (subst-effects/unique/1 CB
       (S2=>R2:set-map-objects S2 R2) _ _ N!<R2 N!<Q2
       (subst-efxmap/ M2|N=M2out+M2in M2in=>MF2in
         (S+MF2in=>Mk1:set+map2map OS MF2in Mk1) _
          FS+X=>Mk2 (Mk1+Mk2=Mk3:efxmap`join Mk1 Mk2 Mk3) Mk3+M2out=M2outk))
     XX1+XX2P=XX (effects-leq-no-consume/ (M<=MP: efxmap`leq M MP))
     (XXV+XX1=>XX0+QP: transfer-consume CM B _ _ _ QP) _
     (effects2output/unique/0f T2PF
       (M0=>Pi0: efxmap2perm CM PM B M0 Pi0) OS=>PiG
       (B=>PiB: cxt2perm CM PM B PiB) set`size/0 SZ-OS=SN)
     %{=>}% _ _ _ _ _ _ QP=>PiQ2 (envadd/exists [_] envadd/expr)
     (effects-leq-no-consume/ (M2<=M2P:efxmap`leq M2 M2P))
     (let-output-format/unique/0f
       ([x] B+N=BF x) SZ-OS=SN OS=>PiG M2P|N=M2outP+M2in MP=>M1+M2outkP
       (efxmap-split/ Mk1P^M2outP Mk1P+M2outP=M2outkP)
       ([x] M2in=>Pif x) Mk1P=>Pik1P M1=>Pi1)
       ([x] effects2input/
         (cxt2perm/U B=>PiB N!<B (B+N=BF x) T2PF)
         (BP+Q2=>PiQ2 x) (BP+Q2=>FS3 x) S2uFS3=S3 S3=>M3
         (BP+M3=>Pi3 x) (M2P=>Pi2P x))
     ([_] envadd/expr)
     (transform/inside [x]
       (transform/implies
         (implies/trans7
           (implies/combine implies/reflexive % PiQ2
             (implies/combine implies/reflexive % PiB
               (implies/combine implies/reflexive % PF
                 (implies/combine implies/reflexive % PiG
                   (implies/trans3
                     (implies/equiv (Pi0<=>PiP+Pi3))
                     (implies/combine
                       (implies/trans
                         (implies/equiv (PiP<=>Pi1+Pi2outkP))
                         (implies/combine
                           (implies/reflexive)
                           (implies/equiv (Pi2outkP<=>Pik1P+Pi2outP))))
                       (implies/reflexive))
                     (implies/equiv
                       (equiv/transitive
                         (equiv/symmetric equiv/associate)
                         (equiv/combine
                           (equiv/reflexive)
                           (equiv/transitive
                             (equiv/symmetric equiv/associate)
                             (equiv/combine equiv/reflexive equiv/commute))))))))))
           (implies/equiv
             (equiv/transitive3
               (equiv/roll2)
               (equiv/combine
                 (equiv/reflexive) (equiv/roll2))
               (equiv/associate)))
           (implies/combine
             (implies/reflexive)
             (implies/trans
               (implies/combine implies/reflexive
                 (implies/equiv equiv/roll4))
               (implies/equiv equiv/associate)))
           (implies/equiv equiv/associate)
           (implies/combine
             (implies/combine (implies/equiv equiv/commute)
               (implies/reflexive))
             (implies/trans6
               (implies/combine implies/reflexive
                 (implies/equiv equiv/roll2))
               (implies/equiv equiv/associate)
               (implies/combine
                 (IMPP x)
                 (implies/reflexive))
               (implies/equiv
                 (equiv/transitive
                   (equiv/commute)
                   (equiv/symmetric equiv/associate)))
               (implies/combine implies/reflexive
                 (implies/trans3
                   (implies/combine implies/reflexive
                     (implies/equiv equiv/roll2))
                   (implies/equiv equiv/associate)
                   (implies/combine
                     (implies/equiv (Pi2outP+Pif<=>Pi2P x))
                     (implies/reflexive))))
               (implies/equiv equiv/roll2)))
           (implies/equiv
             (equiv/transitive4
               (equiv/associate)
               (equiv/combine equiv/reflexive
                 (equiv/roll2))
               (equiv/roll2)
               (equiv/combine equiv/reflexive
                 (equiv/combine equiv/reflexive
                   (equiv/commute)))))
           (implies/equiv equiv/roll2))))
     <- let-helper/L3 CM-B-XXV XX1+XX2P=XX M<=MP XXV+XX1=>XX0+QP %{=>}%
       S3 FS3 M3 QP=>FS3 S2P^FS3 S2uFS3=S3 S3=>M3
       (MP^M3:efxmap`disjoint MP M3) (MP+M3=M0:efxmap`join MP M3 M0)
       (QP=Q2P:set`eq QP Q2P) (S0=S1:set`eq S0 S1) (Q0=Q1:set`eq Q0 Q1)
     <- efxmap`disjoint-join-implies-equiv MP^M3 MP+M3=M0 M0=>Pi0 PiP Pi3
       MP=>PiP M3=>Pi3 Pi0<=>PiP+Pi3
     <- objset2fldset-respects-eq QP=>FS3 clsmap`eq/ cxt`eq/ QP=Q2P set`eq/ Q2=>FS3
     <- set2efxmap-unique FS+X=>Mk2 set2efxmap/0 set`eq/ efx`eq/ Mk2=0
     <- efxmap`join-unique Mk1+Mk2=Mk3 efxmap`join/R efxmap`eq/ Mk2=0 Mk3=Mk1
     <- let-helper/L6 XX1+XX2P=XX (M2outk<=M:efxmap`leq M2outk M)
     <- let-helper/L18 S2=>R2 N!<R2 N!<Q2 Q2=>FS3 S2uFS3=S3
       S3=>M3 M3=>Pi3 N!<B ([x] B+N=BF x) ([x] BP+Q2=>FS3 x) ([x] BP+M3=>Pi3 x)
     <- efxmap`leq-transitive M2outk<=M M<=MP M2outk<=MP
     <- efxmap`domain-total DM-M2outk=R2outk
     <- let-helper/L12 M2outk<=MP DM-M2outk=R2outk _ _
       (MP|R2outk=M1+M2outkP:efxmap`partition MP R2outk M1 M2outkP)
       M2outk=<=M2outkP
     <- let-helper/L16 ([x] CM-BP-XX2 x) _
       DM-M2=R2 ([x] CM-BP-R2 x) ([x] CM-BP-Q2 x)
     <- let-helper/L19 N!<B ([x] B+N=BF x) CM-BP-Q2 N!<Q2 CM-B-Q2
     <- make-encumbered-total CM-CM CM2PM CM-B-Q2 _ Q2=>PiQ2
     <- let-helper/L20 Q2=>PiQ2 N!<B ([x] B+N=BF x)
       N!<Q2 ([x] BP+Q2=>PiQ2 x)
     <- set`eq-symmetric QP=Q2P Q2=QP
     <- make-encumbered-respects-eq Q2=>PiQ2 clsmap`eq/ predmap`eq/ cxt`eq/
       Q2=QP permission`eq/ (QP=>PiQ2:make-encumbered CM PM B QP PiQ2)
     <- let-helper/L10 M2|N=M2out+M2in M2out<=M2 M2in<=M2 M2out^M2in M2out+M2in=M2
     <- efxmap`domain-total DM-M2in=R2in
     <- efxmap`domain-preserves-leq* M2in<=M2 DM-M2in=R2in DM-M2=R2 R2in<=R2
     <- ({x} clsmap-cxt-fldset-respects-geq (CM-BP-R2 x) R2in<=R2 (CM-BP-R2in x))
     <- efxmap`domain-total (DM-M2out=R2out:efxmap`domain M2out R2out)
     <- let-helper/L4 M2|N=M2out+M2in _ M2in-of-N M2out=>O2out N!<O2out
     <- efxmap`partition-implies-disjoint-join MP|R2outk=M1+M2outkP
       M1^M2outkP M1+M2outkP=MP
     <- efxmap`disjoint-join-implies-equiv M1^M2outkP M1+M2outkP=MP
       MP=>PiP Pi1 Pi2outkP M1=>Pi1 M2outkP=>Pi2outkP PiP<=>Pi1+Pi2outkP
     <- efxmap`join-respects-eq Mk3+M2out=M2outk Mk3=Mk1 efxmap`eq/ efxmap`eq/
       Mk1+M2out=M2outk
     <- let-helper/L26 CB M2|N=M2out+M2in M2in=>MF2in
       S+MF2in=>Mk1 FS+X=>Mk2 Mk1^M2out Mk2^M2out
     <- efxmap-disjoint-join-vleq-converse Mk1^M2out Mk1+M2out=M2outk
       M2outk=<=M2outkP Mk1P M2outP Mk1P^M2outP Mk1P+M2outP=M2outkP
       Mk1=<=Mk1P M2out=<=M2outP
     <- efxmap`disjoint-join-implies-equiv Mk1P^M2outP Mk1P+M2outP=M2outkP
       M2outkP=>Pi2outkP Pik1P Pi2outP Mk1P=>Pik1P M2outP=>Pi2outP
       Pi2outkP<=>Pik1P+Pi2outP
     <- let-helper/L27 _ SZ-OS=SN M2in=>MF2in M2in-of-N CM-B-OS
       S+MF2in=>Mk1 Mk1=<=Mk1P Mk1P=>Pik1P
       ([x] OS=>PiG x) N!<B ([x] B+N=BF x) _ N+MF2in=M2in
       ([x] M2in=>Pif x) ([x] IMPP x)
     <- efxmap-vleq-reflexive M2in=<=M2in
     <- efxmap-partition-on-index-vleq-converse M2|N=M2out+M2in M2out=<=M2outP
       M2in=<=M2in M2P M2P|N=M2outP+M2in M2=<=M2P
     <- efxmap-vleq-implies-leq M2=<=M2P M2<=M2P
     <- efxmap-vleq-implies-same-domain M2out=<=M2outP DM-M2out=M2outP
     <- efxmap-same-domain-implies-domain-left
       DM-M2out=M2outP DM-M2out=R2out DM-M2outP=R2out
     <- efxmap-vleq-preserves-efxmap-map-objects M2out=>O2out M2out=<=M2outP M2outP=>O2out
     <- let-helper/L21 M2outP=>O2out N!<O2out N!<B ([x] B+N=BF x) M2outP=>Pi2outP
       ([x] BP+M2outP=>Pi2outP x)
     <- efxmap-vleq-preserves-disjoint-left M2out^M2in M2out=<=M2outP M2outP^M2in
     <- let-helper/L10 M2P|N=M2outP+M2in _ _ _ M2outP+M2in=M2P % TODO: better not call this lemma.
     <- ({x} efxmap`disjoint-join-implies-equiv-converse M2outP^M2in
          M2outP+M2in=M2P (BP+M2outP=>Pi2outP x) (M2in=>Pif x)
          _ (M2P=>Pi2P x) (Pi2outP+Pif<=>Pi2P x))
     <- efxmap-partition-implies-split MP|R2outk=M1+M2outkP MP=>M1+M2outkP.

 %worlds (objvar) (let-helper-before/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
 %total { } (let-helper-before/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


 %%% Here Pxf is combined into permission Pi2. After using the latter,
 %%% we need to use Pxf to restore the permission for Px.

 %theorem let-helper-before/simple/unique/L
   : forall* {M} {MS} {N} {Mout} {Min}
     forall {M=>MS: efxmap-map-objects M MS}
     {MB: set`member MS N}
     {P: efxmap-partition-on-index M N Mout Min}
     exists {SN} {SZ: efxmap`size Min (s SN)}
     true.

 %worlds (objvar) (let-helper-before/simple/unique/L _ _ _ _ _).
 %trustme %total {} (let-helper-before/simple/unique/L _ _ _ _ _).


%theorem let-helper-before/simple/unique
  : forall* {CM} {PM} {B} {XX1} {XX2} {XX} {XX0} {Q} {XX2P}
    {C} {Out0} {N} {BP} {XXV} {FM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
     {BF: cxt`fresh B N}
     {BU: {x} cxt`update B N (cxt-info/ x (ty/ nn/yes annot/borrow C)) (BP x)}
     {CML: clsmap`lookup CM C FM} % not sure whether we need this!
     {CM-B-XX2: {x:object} clsmap-cxt-effects CM (BP x) XX2}
     {CM-B-XX2P: clsmap-cxt-effects CM B XX2P}
     {CM-B-XXV: clsmap-cxt-effects CM B XXV}
     {SUB: subst-effects CM B nn/yes unique-target N XX2 XX2P}
     {XX1+XX2P=XX: effects`join XX1 XX2P XX}
     {XX<=XXV: effects-leq-no-consume XX XXV}
     {TC: transfer-consume CM B XXV XX1 XX0 Q}
     {XX0=>Piin: effects2output CM PM B (reftype/ nn/yes C unique-target) XX0 Out0}
     exists {PiQ} {Pi2} {Out1} {Out2} {Out3} {XX2A}
     {Q=>PiQ: make-encumbered CM PM B Q PiQ}
     {EA: envadd PiQ Out0 Out1}
     {XX2<c=XX2A: effects-leq-no-consume XX2 XX2A}
     {FMT: let-output-format CM PM B N (reftype/ nn/yes C unique-target) XXV XX2A Out2}
     {XX2A=>Pi2: {x} effects2input CM PM (BP x) XX2A (Pi2 x)}
     {EA: {x} envadd (Pi2 x) (Out2 x) (Out3 x)}
     {TRANS: transform Out1 (output/exists [x] (Out3 x))}
     true.

 - : let-helper-before/simple/unique CM-CM CM2PM BF ([x] BU x) CML
     ([x] CM-BP-XX2 x) CM-B-XX2P CM-B-XXV
     (subst-effects/unique/1 CB S2=>OS2 M=>MS N<-MS N!<OS2 N!<Q2
       (subst-efxmap/
         (M2=>M2out+M2in:efxmap-partition-on-index M2 N M2out M2in)
         (M2in=>M2Fin:efxmap-map-fields M2in M2Fin)
         S+M2Fin=>MK1 _ S2+X=>MK2 MK1+MK2=MK
         (MK+M2out=M2outK:efxmap`join MK M2out M2outK)))
     XX1+XX2P=XX (effects-leq-no-consume/ (M<=MP:efxmap`leq M MP))
     (XXV+XX1=>XX0+QP:transfer-consume CM B _ _ _ QP)
     (effects2output/simple
       (ty2perm/ PML nn2perm/yes annot2perm/unique) RT2T simple-targets/unique
       (M0=>Pi0:efxmap2perm CM PM B M0 Pi0) (B=>PiB:cxt2perm CM PM B PiB))
   %{=>}% _ _ _ _ _ _ QP=>PiQ2 (envadd/exists [x] envadd/expr)
     (effects-leq-no-consume/ M2<=M2P)
     (let-output-format/simple/unique
       BU (ty2perm/ PML nn2perm/yes annot2perm/unique)
       M2P|N=M2outP+M2inP (efxmap-split/ M1^M2outP M1+M2outP=MP) % MP|R2out=M1+M2outP
       ([x] M2inP=>Pxf x) M1=>Pi1)
       ([x] effects2input/
         (cxt2perm/U B=>PiB BF (BU x) T2PF2)
         (BP+Q2=>PiQ2 x) (BP+Q2=>FS3 x) S2uFS3=S3
         S3=>M3 (BP+M3=>Pi3 x) (M2P=>Pi2P x))
     ([_] envadd/expr)
     (transform/inside [x]
       (transform/implies
         (implies/trans4
           (implies/combine
             (implies/reflexive) % X12
             (implies/combine
               (implies/reflexive) % PiB
               (implies/trans
                 (implies/combine % PF
                   (IMP3 x)
                   (implies/equiv
                     (equiv/transitive
                       (Pi0<=>PiP+Pi3)
                       (equiv/commute))))
                 (implies/equiv (equiv/symmetric equiv/associate)))))
           (implies/trans
             (implies/combine implies/reflexive
               (implies/trans
                 (implies/combine implies/reflexive
                   (implies/equiv equiv/roll2))
                 (implies/equiv equiv/associate)))
             (implies/equiv equiv/roll2))
           (implies/trans
             (implies/combine (implies/equiv equiv/commute)
               (implies/trans
                 (implies/combine implies/reflexive
                   (implies/trans
                     (implies/combine implies/reflexive
                       (implies/combine implies/reflexive
                         (implies/equiv PiP<=>Pi1+P2outP)))
                     (implies/equiv equiv/roll2)))
                 (implies/equiv equiv/associate)))
             (implies/equiv equiv/associate))
           (implies/trans
             (implies/combine implies/reflexive
               (implies/trans3
                 (implies/combine
                   (implies/trans3 (IMP1 x)
                     (implies/combine
                       (implies/equiv
                         (equiv/transitive
                           (equiv/symmetric equiv/one)
                           (EQV x)))
                       (implies/equiv-encumbered
                         (equiv/transitive
                           (equiv/symmetric equiv/one) (EQV x))
                         (equiv/reflexive)))
                     (implies/equiv equiv/commute))
                   (implies/reflexive))
                 (implies/equiv (equiv/symmetric equiv/associate))
                 (implies/trans
                   (implies/combine
                     (implies/reflexive)
                     (implies/trans
                       (implies/equiv equiv/roll2)
                       (implies/trans
                         (implies/combine implies/reflexive
                           (implies/trans
                             (implies/equiv equiv/commute)
                             (implies/equiv (P2outP+Pxf<=>Pi2P x))))
                         (implies/equiv equiv/commute))))
                   (implies/equiv equiv/roll2))))
             (implies/equiv equiv/associate)))))
     <- let-helper/L3 CM-B-XXV XX1+XX2P=XX M<=MP XXV+XX1=>XX0+QP %{=>}%
       S3 FS3 M3 QP=>FS3 S2P^FS3 S2uFS3=S3 S3=>M3
       (MP^M3:efxmap`disjoint MP M3) (MP+M3=M0:efxmap`join MP M3 M0)
       (QP=Q2P:set`eq QP Q2P) (S0=S1:set`eq S0 S1) (Q0=Q1:set`eq Q0 Q1)
     <- efxmap`disjoint-join-implies-equiv MP^M3 MP+M3=M0 M0=>Pi0 PiP Pi3
       MP=>PiP M3=>Pi3 Pi0<=>PiP+Pi3
     <- objset2fldset-respects-eq QP=>FS3 clsmap`eq/ cxt`eq/ QP=Q2P set`eq/ Q2=>FS3
     <- set+map2map-unique S+M2Fin=>MK1 set+map2map/0 set`eq/ efxmap`eq/ MK1=0
     <- set2efxmap-unique S2+X=>MK2 set2efxmap/0 set`eq/ efx`eq/ MK2=0
     <- efxmap`join-unique MK1+MK2=MK efxmap`join/L MK1=0 MK2=0 MK=0
     <- efxmap`join-unique MK+M2out=M2outK efxmap`join/L MK=0 efxmap`eq/ M2outK=M2out
     <- let-helper/L6 XX1+XX2P=XX M2outK<=M
     <- let-helper/L18 S2=>OS2 N!<OS2 N!<Q2 Q2=>FS3 S2uFS3=S3
       S3=>M3 M3=>Pi3 BF BU ([x] BP+Q2=>FS3 x) ([x] BP+M3=>Pi3 x)
     <- efxmap`leq-respects-eq M2outK<=M M2outK=M2out efxmap`eq/ M2out<=M
     <- efxmap`leq-transitive M2out<=M M<=MP M2out<=MP
     <- efxmap`domain-total (DM-M2out=R2out:efxmap`domain M2out R2out)
     <- let-helper/L12 M2out<=MP DM-M2out=R2out _ _
       (MP|R2out=M1+M2outP:efxmap`partition MP R2out M1 M2outP) M2out=<=M2outP
     <- let-helper/L16 ([x] CM-BP-XX2 x) _
       DM-M2=R2 ([x] CM-BP-R2 x) ([x] CM-BP-Q2 x)
     <- let-helper/L19 BF BU CM-BP-Q2 N!<Q2 CM-B-Q2
     <- make-encumbered-total CM-CM CM2PM CM-B-Q2 _ Q2=>PiQ2
     <- let-helper/L20 Q2=>PiQ2 BF BU N!<Q2 BP+Q2=>PiQ2
     <- set`eq-symmetric QP=Q2P Q2=QP
     <- make-encumbered-respects-eq Q2=>PiQ2 clsmap`eq/ predmap`eq/ cxt`eq/
       Q2=QP permission`eq/ QP=>PiQ2
     <- let-helper/L10 M2=>M2out+M2in M2out<=M2 M2in<=M2 M2out^M2in M2out+M2in=M2
     <- efxmap`domain-total DM-M2in=R2in
     <- efxmap`domain-preserves-leq* M2in<=M2 DM-M2in=R2in DM-M2=R2 R2in<=R2
     <- ({x} clsmap-cxt-fldset-respects-geq (CM-BP-R2 x) R2in<=R2 (CM-BP-R2in x))
     <- let-helper/L4 M2=>M2out+M2in _ M2in-of-N M2out=>O2out N!<O2out
     <- ({x} cxt`update-implies-lookup (BU x) (BL x))
     <- let-helper/L5 DM-M2in=R2in ([x] CM-BP-R2in x) ([x] BL x) CML
          M2in-of-N M2in=>M2Fin
       _ _ (DM-M2Fin=S2Fin:efxmap`domain M2Fin S2Fin) DM-FM=FS S2Fin<=FS
     <- let-helper/L15 (ty2perm/ PML nn2perm/yes annot2perm/unique) _ T2PF2 IMP3
     <- let-helper/L8 CM-CM CM2PM CML (PML:predmap`lookup PM _ CP) DM-FM=FS S2Fin<=FS
        %{=>}% Pxf2 ([x] S2Fin=>P2Fin x) IMP1
     <- let-helper-before/simple/unique/L M=>MS N<-MS M2=>M2out+M2in _ MSZ
     <- efxmap-map-fields-preserves-size MSZ M2in=>M2Fin MFSZ
     <- efxmap`domain-preserves-size MFSZ DM-M2Fin=S2Fin SZ
     <- let-helper/L9* SZ ([x] BL x) CML ([x] S2Fin=>P2Fin x) efx2frac/write %{=>}%
       Pxf _ _ N+S2Fin=>S (S=>M2inP:set2efxmap _ efx/write M2inP)
       M2inP=>Pxf EQV
     <- let-helper/L11* M2in-of-N M2in=>M2Fin DM-M2Fin=S2Fin N+S2Fin=>S
       S=>M2inP M2in=<=M2inP
     <- efxmap-partition-on-index-vleq-converse M2=>M2out+M2in M2out=<=M2outP
       M2in=<=M2inP M2P M2P|N=M2outP+M2inP M2=<=M2P
     <- efxmap-vleq-implies-leq M2=<=M2P M2<=M2P
     <- let-helper/L10 M2P|N=M2outP+M2inP _ _ M2outP^M2inP M2outP+M2inP=M2P
     <- efxmap-vleq-preserves-efxmap-map-objects M2out=>O2out M2out=<=M2outP M2outP=>O2out
     <- efxmap`partition-implies-permission-combine MP|R2out=M1+M2outP
       MP=>PiP Pi1 Pi2outP M1=>Pi1 M2outP=>P2outP PiP<=>Pi1+P2outP
     <- let-helper/L21 M2outP=>O2out N!<O2out BF BU M2outP=>P2outP BP+M2outP=>P2outP
     <- ({x} efxmap`disjoint-join-implies-equiv-converse M2outP^M2inP
          M2outP+M2inP=M2P (BP+M2outP=>P2outP x) (M2inP=>Pxf x) _
          (M2P=>Pi2P x) (P2outP+Pxf<=>Pi2P x))
     <- efxmap`partition-implies-disjoint-join MP|R2out=M1+M2outP M1^M2outP M1+M2outP=MP.

%worlds (objvar)
  (let-helper-before/simple/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { }
  (let-helper-before/simple/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).



% given M12out^M3, and M12out <= M01, and M01 => M01P + M3,
% we should get M12out <= M01P.

%theorem let-helper-before/unique/L11
  : forall* {M0} {M1} {M2} {M}
    forall {M0=>M1+M2: efxmap-split M0 M1 M2}
    {M<=M0: efxmap`leq M M0}
    {M^M2: efxmap`disjoint M M2}
    exists {M<=M1: efxmap`leq M M1}
    true.

- : let-helper-before/unique/L11
    (efxmap-split/ M1^M2 M1+M2=M0) M<=M0 M^M2 M<=M1
    <- efxmap`disjoint-symmetric M^M2 M2^M
    <- efxmap`join-disjoint-right-leq-implies-leq M1+M2=M0 M2^M M<=M0 M<=M1.

%worlds () (let-helper-before/unique/L11 _ _ _ _).
%total { } (let-helper-before/unique/L11 _ _ _ _).


%{%

The variable x is bound with a object target set OS, and a
field target set FS. Also, there's a effect map M which contains
mappings from its fields to corresponding effect needed in E2.

This lemma shows that given the following permission:

  x = v ? 0 : G(x) , Pi1 , Pi(v) , Pi(v) --|- PF

where G is conditionals about x (for each object target o in OS, it
has a objequal fact x = o), and Pi1 is field permissions for
all combination of each target of x and each field in M.
Pi(v) is unique permission for variable v.

Given this, we should get:

  Pi2(x) , Pi2(x) --|- (Pi1 , Pi(v)) , Pi(v) --|- PF , x = v ? 0 : G(x)

where Pi2(x) is field permissions for x.

Idea:

 first, we can get
  x = v ? (x = v , Pi1 , Pi(v) , Pi(v) --|- PF)
        : (x != v , G(x) , Pi1 , Pi(v) , Pi(v) --|- PF)

  x = v ? (x = v , Pi(v) , Pi(v) --|- PF , Pi1)
        : (G(x) , Pi1 , Pi(v) , Pi(v) --|- PF)

  x = v ? (Pi2(x) , Pi2(x) --|- Pi(v) , Pi(v) --|- PF , Pi1)
        : (Pi2(x) , Pi2(x) --|- Pi1 , Pi(v) , Pi(v) --|- PF)

  x = v ? (Pi2(x) , Pi2(x) --|- (Pi1 , Pi(v)) , Pi(v) --|- PF)
        : (G(x) , Pi2(x) , Pi2(x) --|- (Pi1 , Pi(v)) , Pi(v) --|- PF)

  Pi2(x) , Pi2(x) --|- (Pi1 , Pi(v)) , Pi(v) --|- PF , x = v ? empty : G(x)

%}%


%theorem let-helper-before/unique/L12L3
  : forall* {M} {MF} {N} {X} {MFR} {NR} {XP} {MR}
    forall {M=>MF: efxmap-map-fields M MF}
    {M-N: efxmap-same-object M N}
    {MX-M: efxmap-max-efx M X}
    {DM-MF=MFR: efxmap`domain MF MFR}
    {N+MFR=NR: nat+set2set N MFR NR}
    {NR+XP=MR: set2efxmap NR XP MR}
    exists {MF=<=MR: efxmap-vleq MF MR}
    true.

%worlds () (let-helper-before/unique/L12L3 _ _ _ _ _ _ _).
%trustme %total {} (let-helper-before/unique/L12L3 _ _ _ _ _ _ _).


%theorem let-helper-before/unique/L12L1
  : forall* {S2} {M2} {X} {M2P} {XP}
    forall {S2+X=>M2: set2efxmap S2 X M2}
    {M2<=M2P: efxmap-vleq M2 M2P}
    {MX-M2P: efxmap-min-efx M2P XP}
    exists {X<=XP: efx`leq X XP}
    true.

%worlds () (let-helper-before/unique/L12L1 _ _ _ _).
%trustme %total { } (let-helper-before/unique/L12L1 _ _ _ _).


%theorem let-helper-before/unique/L12L2L1
  : forall* {CM} {PM} {FM} {FS} {Pf0} {MF} {X} {XP} {Q} {BF} {NN} {C} {N}
    forall {BL: {x} cxt`lookup (BF x) N (cxt-info/ x (ty/ NN annot/borrow C))}
    {FS=>Pf0: {x} fldmap2perm PM x FM FS (Pf0 x)}
    {MX-MF: efxmap-max-efx MF X}
    {X<=XP: efx`leq X XP}
    {XP=>Q: efx2frac XP Q}
    exists {Pf} {MN} {N+MF=MN: nat+map2map N MF MN}
    {M2P: {x} efxmap2perm CM PM (BF x) MN (Pf x)}
    {IMP: {x} implies (scale Q (Pf0 x))
          (combine (Pf x) (unitperm (encumbered (Pf x) (scale Q (Pf0 x)))))}
    true.

%theorem let-helper-before/unique/L12L2L2
  : forall* {N} {MF} {X} {XP} {M1} {M2} {FS} {S}
    forall {MX-MF: efxmap-max-efx MF X}
    {DM-MF: efxmap`domain MF FS}
    {N+MF=M1: nat+map2map N MF M1}
    {N+FS=S: nat+set2set N FS S}
    {X<=XP: efx`leq X XP}
    {S+X=M2: set2efxmap S XP M2}
    exists {M1=<=M2: efxmap-vleq M1 M2}
    true.

%worlds (objvar) (let-helper-before/unique/L12L2L2 _ _ _ _ _ _ _).
%trustme %total {} (let-helper-before/unique/L12L2L2 _ _ _ _ _ _ _).


%theorem let-helper-before/unique/L12L2L4L
  : forall* {CM} {PM} {S} {X} {Q} {M} {B} {Pf}
    forall {S+W=>M: set2efxmap S efx/write M}
    {M=>Pi: efxmap2perm CM PM B M Pf}
    {X=>Q: efx2frac X Q}
    exists {PfP} {MP} {S+X=>MP: set2efxmap S X MP}
    {MP=>PfP: efxmap2perm CM PM B MP PfP}
    {IMP: implies (scale Q Pf) PfP} % TODO: two-way implication
    true.

%theorem let-helper-before/unique/L12L2L4LL
  : forall* {NN1} {N3} {X10} {X12}
    forall {AN:apply-nn NN1
                ([x:gterm objectk]
                scale (fraction/ one)
                  (unitperm (precise-exists x N3 ([x1:gterm objectk] X10 x1))))
                ([x:gterm objectk] X12 x)}
    exists {X15} {AN2:apply-nn NN1
          ([x:gterm objectk]
            scale half
            (unitperm (precise-exists x N3 ([x2:gterm objectk] X10 x2))))
          ([x:gterm objectk] X15 x)}
    {IMP: {x} implies (scale half (X12 x)) (X15 x)}
    true.

- : let-helper-before/unique/L12L2L4LL apply-nn/yes _ apply-nn/yes
    ([_] implies/scale (implies/equiv equiv/one)).

- : let-helper-before/unique/L12L2L4LL apply-nn/may _ apply-nn/may
    ([_] implies/trans
      (implies/scale-distribute-cond)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/zero)
        (implies/scale (implies/equiv equiv/one)))).

%worlds (objvar) (let-helper-before/unique/L12L2L4LL _ _ _ _).
%total { } (let-helper-before/unique/L12L2L4LL _ _ _ _).


- : let-helper-before/unique/L12L2L4L
    S=>M M=>Pf efx2frac/write _ _ S=>M M=>Pf
    (implies/equiv equiv/one).

- : let-helper-before/unique/L12L2L4L
    set2efxmap/0 (efxmap2perm/0) efx2frac/read _ _ set2efxmap/0 (efxmap2perm/0)
    (implies/equiv equiv/zero).

- : let-helper-before/unique/L12L2L4L
    (set2efxmap/U SP=>MP efx-id/ K!<SP SP+K=S
      (MP+K+X=M)) (M=>Pf)
    efx2frac/read %{=>}% _ M0 (set2efxmap/U SP+X=>M0P efx-id/ K!<SP SP+K=S M0P+K+X=M0)
    (efxmap2perm/U (M0P=>PfP2) K=>N+F (BL) (create-fldperm/ CML FML T2PF) efx2frac/read
      AN2 K!<M0P M0P+K+X=M0)
    (implies/trans4
      (implies/scale (implies/equiv (equiv/symmetric (Pf<=>Pf1+Pf2))))
      (implies/equiv equiv/distribute)
      (implies/combine implies/reflexive (IMP0))
      (implies/combine (IMP2 O) implies/reflexive))
    <- set2efxmap-preserves-fresh K!<SP SP=>MP K!<MP
    <- (efxmap2perm/U-inversion (M=>Pf) K!<MP MP+K+X=M _ _ K=>N+F
         O _ A _ (BL) _ (create-fldperm/ CML FML T2PF) _ efx2frac/write
         _ AN _ (MP=>Pf2) (Pf<=>Pf1+Pf2))
    <- let-helper-before/unique/L12L2L4L SP=>MP (MP=>Pf2) efx2frac/read
      PfP2 M0P SP+X=>M0P (M0P=>PfP2) (IMP0)
    <- efxmap`update-total M0P+K+X=M0
    <- set2efxmap-preserves-fresh K!<SP SP+X=>M0P K!<M0P
    <- let-helper-before/unique/L12L2L4LL AN _ AN2 IMP2.

%worlds (objvar) (let-helper-before/unique/L12L2L4L _ _ _ _ _ _ _ _).
%total (S) (let-helper-before/unique/L12L2L4L S _ _ _ _ _ _ _).


%theorem let-helper-before/unique/L12L2L4
  : forall* {CM} {PM} {S} {X} {Q} {M} {B: object -> cxt} {Pf}
    forall {S+W=>M: set2efxmap S efx/write M}
    {M=>Pi: {x} efxmap2perm CM PM (B x) M (Pf x)}
    {X=>Q: efx2frac X Q}
    exists {PfP} {MP} {S+X=>MP: set2efxmap S X MP}
    {MP=>PfP: {x} efxmap2perm CM PM (B x) MP (PfP x)}
    {IMP: {x} implies (scale Q (Pf x)) (PfP x)}
    true.

- : let-helper-before/unique/L12L2L4 S=>M ([x] M=>Pi x) X=>Q
    _ _ S+X=>MP ([x] MP=>PiP x) ([x] IMP x)
    <- ({x} let-helper-before/unique/L12L2L4L S=>M (M=>Pi x) X=>Q
         _ _ S+X=>MP (MP=>PiP x) (IMP x)).

%worlds (objvar) (let-helper-before/unique/L12L2L4 _ _ _ _ _ _ _ _).
%total { } (let-helper-before/unique/L12L2L4 _ _ _ _ _ _ _ _).


%theorem let-helper-before/unique/L12L2L3
  : forall* {CM} {PM} {B:object -> cxt} {S} {M} {X} {MP} {Q} {Pf}
    forall {S+W=M: set2efxmap S efx/write M}
    {S+X=MP: set2efxmap S X MP}
    {X=>Q: efx2frac X Q}
    {M=>Pi: {x} efxmap2perm CM PM (B x) M (Pf x)}
    exists {PfP} {MP=>PfP: {x} efxmap2perm CM PM (B x) MP (PfP x)}
    {QPf=>PfP: {x} implies (scale Q (Pf x)) (PfP x)}
    true.

- : let-helper-before/unique/L12L2L3
    S=>M S+X=>MP X=>Q ([x] M=>Pf x) _ ([x] MP=>PfP x) ([x] Pf=>PfP x)
    <- let-helper-before/unique/L12L2L4 S=>M ([x] M=>Pf x) X=>Q
      _ _ S+X=>MPP ([x] MPP=>PfP x) ([x] Pf=>PfP x)
    <- set2efxmap-unique S+X=>MPP S+X=>MP set`eq/ efx`eq/ MPP=MP
    <- ({x} efxmap2perm-respects-eq (MPP=>PfP x) clsmap`eq/ predmap`eq/
         cxt`eq/ MPP=MP permission`eq/ (MP=>PfP x)).

%worlds (objvar) (let-helper-before/unique/L12L2L3 _ _ _ _ _ _ _).
%total { } (let-helper-before/unique/L12L2L3 _ _ _ _ _ _ _).


%abbrev dup-from-unique
  : {o} implies
    (combine (unitperm (nonlinear (neg (objequal o null))))
      (combine (allperm o) (one-predcall CP o)))
    (combine
      (combine (unitperm (nonlinear (neg (objequal o null))))
        (combine empty (one-predcall CP o)))
      (combine (unitperm (nonlinear (neg (objequal o null))))
        (combine (allperm o) (one-predcall CP o))))
    = [o] implies/trans5
      (implies/combine
        (implies/duplicate)
        (implies/combine
          (implies/reflexive)
          (implies/duplicate)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/equiv equiv/roll3))
      (implies/equiv equiv/associate)
      (implies/combine
        (implies/combine
          (implies/reflexive)
          (implies/equiv
            (equiv/transitive
              (equiv/symmetric equiv/identity)
              (equiv/commute))))
        (implies/reflexive)).

%theorem efxmap-map-fields-preserves-max-efx
  : forall* {M} {MF} {X}
    forall {M=>MF: efxmap-map-fields M MF}
    {MX-M: efxmap-max-efx M X}
    exists {MX-MF: efxmap-max-efx MF X}
    true.

%worlds (objvar) (efxmap-map-fields-preserves-max-efx _ _ _).
%trustme %total { } (efxmap-map-fields-preserves-max-efx _ _ _).


%theorem let-helper-before/unique/L12L2
  : forall* {CM} {PM} {BF} {N} {C} {CP} {MF} {X} {XP} {Q} {FM} {FS} {FS0} {SN}
    forall {SZ-FS=SN: set`size FS (s SN)}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {BL: {x} cxt`lookup (BF x) N (cxt-info/ x (ty/ nn/yes annot/borrow C))}
    {PML: predmap`lookup PM C CP}
    {CML: clsmap`lookup CM C FM}
    {DM-MF: efxmap`domain MF FS}
    {DM-FM: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    {MX-MF: efxmap-max-efx MF X}
    {X<=XP: efx`leq X XP}
    {XP=>Q: efx2frac XP Q}
    exists {Pf} {MN} {N+MF=MN: nat+map2map N MF MN}
    {M2P: {x} efxmap2perm CM PM (BF x) MN (Pf x)}
    {IMP: {x}{o} implies
          (combine (unitperm (nonlinear (objequal x o)))
            (scale Q ((unique-obj-permission CP) o)))
          (combine ((borrow-obj-permission CP) x)
            (combine (Pf x)
              (unitperm (encumbered (Pf x) (scale Q ((unique-obj-permission CP) o))))))}
    true.

- : {BL: {x} cxt`lookup (BF x) N (cxt-info/ x _)}
    let-helper-before/unique/L12L2 SZ CM-CM CM2PM ([x] BL x) PML CML
    (DM-MF=FS:efxmap`domain MF FS) (DM-FM=FS0:fldmap`domain FM FS0)
    (FS<=FS0: set`leq FS FS0) MX-MF (X<=XP:efx`leq Xx XPx)
    (XP=>Q:efx2frac XPx Q) %{=>}% _ _ N+MF=MN ([x] MN=>Pf x)
    ([x][o] implies/trans
      (implies/combine
        (implies/nonlinear bimplies/objequal-symmetric)
        (implies/trans3
          (implies/scale (dup-from-unique o))
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/trans
              (implies/equiv (equiv/distribute))
              (implies/combine implies/scale-from-formula
                (implies/trans
                  (implies/equiv (equiv/distribute))
                  (implies/combine (implies/equiv equiv/zero)
                    (implies/scale-from-formula)))))
            (implies/trans6
              (implies/scale (IMP1 o))
              (implies/equiv equiv/distribute)
              (implies/combine
                (implies/equiv (QPf0<=>Pf2 o))
                (implies/trans
                  (implies/scale-distribute-encumbered)
                  (implies/equiv-encumbered
                    (QPf0<=>Pf2 o)
                    (equiv/reflexive))))
              (implies/combine
                (implies/trans5
                  (implies/equiv (Pi2<=>Pf+Pf3 o))
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/transitive
                          (Pi2<=>Pf+Pf3 o)
                          (equiv/commute))
                        (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/equiv (equiv/symmetric equiv/associate))
                  (implies/combine implies/reflexive implies/linear-modus-ponens))
                (implies/reflexive))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive implies/chain-implication)))))
      (implies/objequal
        ([r] (combine ((borrow-obj-permission CP) r)
               (combine (Pf r)
                 (unitperm (encumbered (Pf r) (scale Q ((unique-obj-permission CP) o)))))))))
    <- let-helper/L8 CM-CM CM2PM CML PML DM-FM=FS0 FS<=FS0
      Pf0 ([x] FS=>Pf0 x) ([x] IMP1 x)
    <- let-helper/L9* SZ BL CML ([x] FS=>Pf0 x) XP=>Q %{=>}%
      _ _ _ (N+FS=>S:nat+set2set N FS S) S+XP=>M
      ([x] M=>Pf2 x) ([x] QPf0<=>Pf2 x)
    <- nat+map2map-total (N+MF=MN:nat+map2map N MF MN)
    <- let-helper-before/unique/L12L2L2 MX-MF DM-MF=FS N+MF=MN N+FS=>S X<=XP S+XP=>M MN=<=M
    <- efxmap-vleq-implies-leq MN=<=M MN<=M
    <- ({x} efxmap2perm-respects-geq (M=>Pf2 x) MN<=M (Pf x) _ (MN=>Pf x) (Pi2<=>Pf+Pf3 x)).

%worlds (objvar) (let-helper-before/unique/L12L2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (let-helper-before/unique/L12L2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper-before/unique/L12
  : forall* {CM} {PM} {B} {M} {S} {MF} {Pi} {GF} {C} {BF} {N} {M2} {MP}
    {X} {XP} {Pi3} {Q} {FM} {MFR} {FMR} {KN} {KN2} {CP} {M3P} {Q1}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {M2=>MF: efxmap-map-fields M2 MF}
    {DM-MF=MFR: efxmap`domain MF MFR}
    {DM-FM=FMR: fldmap`domain FM FMR}
    {MFR<=FMR: set`leq MFR FMR}
    {SZ-S: set`size S (s KN2)}
    {SZ-MFR: set`size MFR (s KN)}
    {CM-B-S: clsmap-cxt-unique-objset CM B nn/yes C S}
    {M2-N: efxmap-same-object M2 N}
    {S+MF=M: set+map2map S MF M}
    {M=<=MP: efxmap-vleq M MP}
    {M=>Pi: efxmap2perm CM PM B MP Pi}
    {S=>G: {x} set2cond B x S (GF x)}
    {N!<B: cxt`fresh B N}
    {B+N=BF: {x} cxt`update B N (cxt-info/ x (ty/ nn/yes annot/borrow C)) (BF x)}
    {MX-MF=X: efxmap-max-efx M2 X}
    {X<=XP: efx`leq X XP}
    {X=>Q1: efx2frac X Q1}
    {M3=>Pi3: efxmap2perm CM PM B M3P Pi3}
    {XP=>Q: efx2frac XP Q}
    {PML: predmap`lookup PM C CP}
    exists {Pf} {N+MF=M2: nat+map2map N MF M2}
    {M=>Pf: {x} efxmap2perm CM PM (BF x) M2 (Pf x)}
    {IMP: {x}{o} implies
          (combine (unitperm (conditional (objequal x o) empty (GF x)))
            (combine Pi
              (combine (scale Q ((unique-obj-permission CP) o))
                (unitperm (encumbered (scale Q ((unique-obj-permission CP) o)) Pi3)))))
          (combine
            (unitperm
              (conditional (objequal x o)
                ((borrow-obj-permission CP) x) (GF x)))
            (combine (Pf x)
              (combine
                (unitperm (encumbered (Pf x) ((scale Q ((unique-obj-permission CP) o)) , Pi)))
                (unitperm (encumbered (scale Q ((unique-obj-permission CP) o)) Pi3)))))}
    true.

%{
two branches:
1)  (objequal x o) + Q (PF o) + Q (PF o) --|- Pi3    (let-helper/L8)
2)  ((GF x) Q (Pf x) , Q (Pf x)
}%

- : {S=>G:{x} set2cond B x S (GF x)} {BU:{x} cxt`update B Nx (cxt-info/ x _) (BF x)}
   let-helper-before/unique/L12 CM-CM CM2PM CML (M2=>MF: efxmap-map-fields M2 MF)
    (DM-MF=MFR:efxmap`domain MF MFR) (DM-FM=FMR:fldmap`domain FM FMR)
    (MFR<=FMR:set`leq MFR FMR) SZS SZ CM-B-S
    (M2-N: efxmap-same-object M2 Nx) (S+MF=>M: set+map2map S MF M)
    (M=<=MP: efxmap-vleq M MP) (MP=>PiP: efxmap2perm CM PM B MP PiP)
    (S=>G) (N!<B: cxt`fresh B Nx) BU (MX-M2=X:efxmap-max-efx M2 X) X<=XP X=>Q1
    (M3P=>Pi3: efxmap2perm CM PM B M3P Pi3)
    (XP=>Q: efx2frac XP Q) PML %{=>}%
    _ N+MF=M2 M2=>Pf
    ([x][o] implies/trans6
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans6
          (implies/combine
            (implies/reflexive)
            (implies/trans
              (implies/equiv equiv/identity)
              (implies/equiv equiv/roll2)))
          (implies/equiv equiv/associate)
          (implies/combine (IMP x o) implies/reflexive)
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive
            (implies/trans
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive
                (implies/trans
                  (implies/equiv equiv/associate)
                  (implies/combine add-encumber implies/reflexive)))))
          (implies/equiv equiv/commute))
        (implies/trans7
          (implies/combine
            (implies/nonlinear2empty)
            (implies/trans3
              (implies/equiv
                (equiv/commute))
              (implies/trans3
                (implies/equiv equiv/roll3)
                (implies/combine
                  (implies/trans3
                    (implies/scale (dup-from-unique o))
                    (implies/equiv equiv/distribute)
                    (implies/combine
                      (implies/trans
                        (implies/equiv (equiv/distribute))
                        (implies/combine implies/scale-from-formula
                          (implies/trans
                            (implies/equiv (equiv/distribute))
                            (implies/combine (implies/equiv equiv/zero)
                              (implies/scale-from-formula)))))
                      (implies/reflexive)))
                  (implies/reflexive))
                (implies/equiv
                  (equiv/transitive
                    (equiv/symmetric equiv/associate)
                    (equiv/combine
                      (equiv/reflexive)
                      (equiv/transitive
                        (equiv/roll2)
                        (equiv/combine equiv/reflexive equiv/roll2))))))
              (implies/combine
                (implies/reflexive)
                (implies/trans4
                  (implies/equiv (equiv/associate))
                  (implies/combine
                    (implies/trans5
                      (implies/combine
                        (implies/reflexive)
                        (implies/equiv (PiP<=>Pi+PiR)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (IMP2 x)
                        (implies/reflexive))
                      (implies/equiv
                        (equiv/transitive3
                          (equiv/commute)
                          (equiv/roll2)
                          (equiv/combine equiv/reflexive equiv/roll2)))
                      (implies/combine
                        (implies/reflexive)
                        (implies/combine implies/reflexive
                          (implies/trans3
                            (implies/equiv equiv/commute)
                            (add-encumber)
                            (implies/equiv-encumbered
                              (equiv/reflexive)
                              (equiv/symmetric (PiP<=>Pi+PiR)))))))
                    (implies/reflexive))
                  (implies/equiv (equiv/symmetric equiv/associate))
                  (implies/combine implies/reflexive
                    (implies/trans
                      (implies/equiv (equiv/symmetric equiv/associate))
                      (implies/combine implies/reflexive
                        (implies/trans
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/trans
                              (add-encumber)
                              (implies/equiv-encumbered
                                (equiv/reflexive)
                                (equiv/commute)))
                            (implies/reflexive))))))))))
          (implies/equiv
            (equiv/transitive3
              (equiv/commute)
              (equiv/identity)
              (equiv/commute)))
          (implies/combine
            (implies/combine (implies/reflexive)
              (implies/combine (implies/equiv (Pf2<=>Pf x))
                (implies/combine
                  (implies/equiv-encumbered
                    (Pf2<=>Pf x)
                    (equiv/reflexive))
                  (implies/reflexive))))
            (implies/reflexive))
          (implies/equiv equiv/commute)
          (implies/equiv equiv/roll2)
          (implies/combine implies/reflexive
            (implies/combine
              (implies/trans
                (implies/combine
                  (implies/nonlinear2empty)
                  (implies/trans
                    (implies/combine implies/reflexive implies/nonlinear2empty)
                    (implies/equiv equiv/identity)))
                (implies/equiv equiv/identity))
              (implies/reflexive)))
          (implies/equiv
            (equiv/transitive4
              (equiv/roll2)
              (equiv/commute)
              (equiv/identity)
              (equiv/commute)))))
      (implies/cond-pull)
      (implies/equiv equiv/commute))
    <- ({x} cxt`update-implies-lookup (BU x) (BLF x))
    <- efxmap-map-fields-preserves-max-efx M2=>MF MX-M2=X MX-MF=X
    <- efxmap-vleq-implies-leq M=<=MP M<=MP
    <- efxmap2perm-respects-geq MP=>PiP M<=MP Pi _ M=>Pi PiP<=>Pi+PiR
    <- let-helper-before/unique/L12L2 SZ CM-CM CM2PM BLF PML CML DM-MF=MFR
      DM-FM=FMR MFR<=FMR MX-MF=X X<=XP XP=>Q Pf _ N+MF=MN ([x] MN=>Pf x) IMP
    <- let-helper/L25 _ SZS CM-B-S S+MF=>M M=>Pi ([x] S=>G x) N!<B BU _ Pf2
      N+MF=MN2 ([x] MN2=>Pf2 x) IMP2
    <- nat+map2map-unique N+MF=MN2 N+MF=MN nat`eq/ efxmap`eq/ (MN2=MN:efxmap`eq MN2 MN)
    <- ({x} efxmap2perm-equiv (MN2=>Pf2 x) (MN=>Pf x) clsmap`eq/ predmap`eq/
         cxt`eq/ MN2=MN (Pf2<=>Pf x))
    <- let-helper/L24 M2=>MF M2-N N+MF=M2
    <- nat+map2map-unique N+MF=MN N+MF=M2 nat`eq/ efxmap`eq/ MN=M2
    <- ({x} efxmap2perm-respects-eq (MN=>Pf x) clsmap`eq/ predmap`eq/
         cxt`eq/ MN=M2 permission`eq/ (M2=>Pf x)).

%worlds (objvar) (let-helper-before/unique/L12
   _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (let-helper-before/unique/L12
   _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem let-helper-before/unique/L13L1L1
  : forall* {O1} {O2} {OF}
    forall {OE: {x} object`eq (OF x) O1} {EQ: object`eq O1 O2}
    exists {EQV: {x} equiv (fact (objequal x (OF x))) (fact (objequal x O2))}
    true.

- : let-helper-before/unique/L13L1L1 ([_] object`eq/) object`eq/ ([_] equiv/reflexive).

%worlds (objvar) (let-helper-before/unique/L13L1L1 _ _ _).
%total { } (let-helper-before/unique/L13L1L1 _ _ _).


%abbrev contradiction-to-borrow-obj-permission
  : {x} implies
    (fact (neg t))
    (combine (fact (neg (objequal x null)))
      (combine empty (one-predcall CP x)))
  = [x] implies/trans
    (implies/duplicate)
    (implies/combine implies/contradiction
      (implies/trans3
        (implies/contradiction)
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/equiv equiv/commute))).


%theorem let-helper-before/unique/L13L1
  : forall* {CM} {PM} {C} {CP} {S} {GF} {B} {PB}
    forall {CM-B: clsmap-cxt CM B}
    {S2G: {x} set2cond B x S (GF x)}
    {CM-B-S: clsmap-cxt-unique-objset CM B nn/yes C S}
    {PML: predmap`lookup PM C CP}
    {B2G: cxt2perm CM PM B PB}
    exists {PF} {T2PF: ty2perm PM (ty/ nn/yes annot/borrow C) PF}
    {IMP: {x} implies
          (combine PB (GF x))
          (combine PB (combine (PF x) (GF x)))}
    true.

- : let-helper-before/unique/L13L1
    _ ([_] set2cond/0) _ PML _ _ (ty2perm/ PML nn2perm/yes annot2perm/borrow)
    ([x] implies/combine implies/reflexive
      (implies/trans implies/duplicate
        (implies/combine (contradiction-to-borrow-obj-permission x) implies/reflexive))).

- : let-helper-before/unique/L13L1
    CM-B ([x] set2cond/U (S2G' x) U F (BL x)) CM-B-S PML (B=>PB:cxt2perm CM PM B PiB)
    _ T2PF2
    ([x] implies/trans5
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans3
          (implies/combine
            (implies/trans
              (implies/equiv (EQV x))
              (implies/nonlinear bimplies/objequal-symmetric))
            (implies/trans
              (implies/equiv equiv/identity)
              (IMP2)))
          (implies/objequal ([r] (combine (PF r) PiB)))
          (implies/equiv
            (equiv/transitive3
              (equiv/symmetric equiv/identity)
              (equiv/symmetric equiv/associate)
              (equiv/roll2))))
        (implies/trans
          (implies/combine implies/nonlinear2empty
            (IMP x))
          (implies/equiv (equiv/transitive equiv/commute equiv/identity))))
      (implies/cond-pull)
      (implies/combine implies/reflexive
        (implies/trans
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/combine (implies/equiv (EQV2 x)) implies/reflexive)
            (implies/reflexive))
          (implies/cond-pull))))
    <- let-helper/L25L3 BL _ _ BLP ([x] OF=O1 x)
    <- clsmap-cxt-unique-objset/U-inversion CM-B-S F U CM-B-S'
      _ _ BL' (nonnull`leq/= nonnull`eq/)
    <- let-helper-before/unique/L13L1 CM-B S2G' CM-B-S' PML B=>PB PF2 T2PF2 IMP
    <- clsmap-cxt-lookup-implies-ty2perm CM-B BL' B=>PB PF T2PF IMP2
    <- cxt`lookup-unique BLP BL' cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE TE
    <- let-helper-before/unique/L13L1L1 ([x] OF=O1 x) OE EQV
    <- ty2perm-deterministic T2PF T2PF2 predmap`eq/ ty`eq/ PEQ
    <- ({x} permission`eq-implies-equiv (PEQ x) (EQV2 x)).

%worlds (objvar) (let-helper-before/unique/L13L1 _ _ _ _ _ _ _ _).
%total (S2G) (let-helper-before/unique/L13L1 _ S2G _ _ _ _ _ _).


%theorem let-helper-before/unique/L13L2
  : forall* {CM} {PM} {C} {CP} {S} {GF} {B} {PB}
    forall {CM-B: clsmap-cxt CM B}
    {S2G: {x} set2cond B x S (GF x)}
    {CM-B-S: clsmap-cxt-unique-objset CM B nn/yes C S}
    {PML: predmap`lookup PM C CP}
    {B2G: cxt2perm CM PM B PB}
    exists {IMP: {x} implies
          (combine PB (GF x))
          (combine PB (combine ((borrow-obj-permission CP) x) (GF x)))}
    true.

- : let-helper-before/unique/L13L2 CM-B S2G CM-B-S PML B2G
    ([x] implies/trans
      (IMP2 x)
      (implies/combine implies/reflexive
        (implies/combine
          (implies/combine implies/reflexive
            (implies/combine implies/reflexive
              (implies/equiv (EQV x))))
          (implies/reflexive))))
    <- let-helper-before/unique/L13L1 CM-B S2G CM-B-S PML B2G _
      (ty2perm/ PML2 nn2perm/yes annot2perm/borrow) IMP2
    <- predmap`lookup-unique PML2 PML predmap`eq/ nat`eq/ PE
    <- clspred-equal-implies-one-predcall-equiv PE EQV.

%worlds (objvar) (let-helper-before/unique/L13L2 _ _ _ _ _ _).
%total { } (let-helper-before/unique/L13L2 _ _ _ _ _ _).


%theorem let-helper-before/unique/L13
  : forall* {CM} {PM} {C} {CP} {S} {GF} {B} {PB}
    forall {CM-B: clsmap-cxt CM B}
    {S2G: {x} set2cond B x S (GF x)}
    {CM-B-S: clsmap-cxt-unique-objset CM B nn/yes C S}
    {PML: predmap`lookup PM C CP}
    {B2G: cxt2perm CM PM B PB}
    exists {IMP: {x}{o} implies
          (combine PB
            (unitperm
              (conditional (objequal x o)
                ((borrow-obj-permission CP) x) (GF x))))
          (combine PB
            (combine ((borrow-obj-permission CP) x)
              (unitperm (conditional (objequal x o) empty (GF x)))))}
    true.

- : let-helper-before/unique/L13 CM-B S2G CM-B-S PML B2G
    ([x][o] implies/trans4
      (implies/cond-push)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/trans
          (IMP x)
          (implies/equiv equiv/associate)))
      (implies/cond-pull)
      (implies/equiv (equiv/symmetric equiv/associate)))
    <- let-helper-before/unique/L13L2 CM-B S2G CM-B-S PML B2G IMP.

%worlds (objvar) (let-helper-before/unique/L13 _ _ _ _ _ _).
%total {} (let-helper-before/unique/L13 _ _ _ _ _ _).


%{%
 If we have M0 = M01 + M02, and M0 = MP + M3
 Then, if M02 is disjoint with M3, we should be able to get M01 = M01P + M3
%}%

%{%
    (let-output-format/unique/+f BU (ty2perm/ PML NN2P A2P)
      ([x] effects2input/
        (cxt2perm/U B=>PiB BF (BU x) T2PF2)
        (BP+Q2=>PiQ2 x) (BP+Q2=>FS3 x) S2uFS3=S3
        S3=>M3 (BP+M3=>Pi3 x) (M2P=>Pi2P x))
      M2P|R2out=M2inP+M2outP MP|R2out=M1+M2outkP
      M2outkP=>Mk3P+M2outP Mk3P=>Mk1P+Mk2P ([x] M2inP=>Pxf x)
      Mk1P=>Pf1 Mk2P=>Pf2 M1=>Pi3)
%}%

%theorem let-helper-before/unique/+
  : forall* {CM} {PM} {B} {XX1} {XX2} {XX} {XX0} {Q} {XX2P}
    {NN} {C} {Out0} {N} {BP} {XXV} {FM} {OS} {FS} {Z}
    forall {OS^FS: set`disjoint OS FS}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {CM-B-OS: clsmap-cxt-unique-objset CM B NN C OS}
    {BF: cxt`fresh B N}
    {BU: {x} cxt`update B N (cxt-info/ x (ty/ NN annot/borrow C)) (BP x)}
    {CML: clsmap`lookup CM C FM} % not sure whether we need this!
    {CM-B-XX2: {x} clsmap-cxt-effects CM (BP x) XX2}
    {CM-B-XX2P: clsmap-cxt-effects CM B XX2P}
    {CM-B-XXV: clsmap-cxt-effects CM B XXV}
    {SUB: subst-effects CM B NN (targets/unique OS FS) N XX2 XX2P}
    {XX1+XX2P=XX: effects`join XX1 XX2P XX}
    {XX<=XXV: effects-leq-no-consume XX XXV}
    {TC: transfer-consume CM B XXV XX1 XX0 Q}
    {SZ-OS: set`size OS (s Z)}
    {SZ-FS: set`size FS (s Z)}
    {XX0=>Piin: effects2output CM PM B (reftype/ NN C (targets/unique OS FS)) XX0 Out0}
    exists {PiQ} {Pi2} {Out1} {Out2} {Out3} {XX2A}
    {Q=>PiQ: make-encumbered CM PM B Q PiQ}
    {EA: envadd PiQ Out0 Out1}
    {XX2<c=XX2A: effects-leq-no-consume XX2 XX2A}
    {FMT: let-output-format CM PM B N (reftype/ NN C (targets/unique OS FS)) XXV XX2A Out2}
    {XX2A=>Pi2: {x} effects2input CM PM (BP x) XX2A (Pi2 x)}
    {EA: {x} envadd (Pi2 x) (Out2 x) (Out3 x)}
    {TRANS: transform Out1 (output/exists [x] (Out3 x))}
    true.

 - : let-helper-before/unique/+ OS^FS CM-CM CM2PM CM-B CM-B-OS N!<B ([x] B+N=BF x)
     CML ([x] CM-BP-XX2 x) CM-B-XX2P CM-B-XXV
     (subst-effects/unique/1 CB % the effects is (effects/ M2 S2 Q2)
       (S2=>R2:set-map-objects S2 R2) M2=>MS N<-MS N!<R2 N!<Q2
       (subst-efxmap/ (M2|N=M2out+M2in:efxmap-partition-on-index M2 N M2out M2in)
         (M2in=>MF2in)
         (OS+MF2in=Mk1:set+map2map OS MF2in Mk1)
         (MX-M2in=X1:efxmap-max-efx M2in Xx1)
          (FS+X1=>Mk2:set2efxmap FS Xx1 Mk2)
         (Mk1+Mk2=Mk3:efxmap`join Mk1 Mk2 Mk3) Mk3+M2out=M2outk))
     XX1+XX2P=XX (effects-leq-no-consume/ (M<=MP: efxmap`leq M MP))
     (XXV+XX1=>XX0+QP: transfer-consume CM B _ _ _ QP) SZ-OS SZ-FS
     (effects2output/unique/+f
       (ty2perm/ (PML:predmap`lookup PM C CP)
         (nn2perm/yes)
         (annot2perm/unique)) (X=>Q:efx2frac Xx Qx)
       (MX-M02=X:efxmap-min-efx M02 Xx)
       (M02=>Pi02:efxmap2perm CM PM B M02 Pi02)
       (M01=>Pi01:efxmap2perm CM PM B M01 Pi01)
       (M0|FS=>M01+M02:efxmap`partition M0 FS M01 M02)
       OS=>PiG (B=>PiB: cxt2perm CM PM B PiB) _)
     %{=>}% _ _ _ _ _ _ QP=>PiQ2
     (envadd/exists [o] (envadd/exists [x] (envadd/expr)))
     (effects-leq-no-consume/ M2<=M2P)
     (let-output-format/unique/+f ([x] B+N=BF x) SZ-OS SZ-FS
       (ty2perm/ PML nn2perm/yes annot2perm/unique)
       OS=>PiG M2P|N=M2outP+M2in
       MP=>M01P+M02 M01P=>M4+M12outP (efxmap-split/ Mk1P^M2outP Mk1P+M2outP=M12outP)
       ([x] BF+M2in=>Pf x) Mk1P=>Pik1P M02=>Pi02 M4=>Pi4 MX-M02=X X=>Q)
     ([x] effects2input/
       (cxt2perm/U B=>PiB N!<B (B+N=BF x) (ty2perm/ PML nn2perm/yes annot2perm/borrow))
       (BP+Q2=>PiQ2 x) (BP+Q2=>FS3 x) S2uFS3=S3 S3=>M3
       (BP+M3=>Pi3 x) (M2P=>Pi2P x))
     ([x] envadd/exists ([v] envadd/expr))
     (transform/inside [x]
       (transform/inside [o]
         (transform/implies
           (implies/trans6
             (implies/combine
               (implies/reflexive) % PiQ2
               (implies/combine implies/reflexive % PiB
                 (implies/trans5
                   (implies/equiv
                     (equiv/transitive
                       (equiv/combine equiv/reflexive
                         (equiv/combine equiv/reflexive
                           (equiv/commute)))
                       (equiv/roll3)))
                   (implies/combine
                     (implies/equiv
                       (equiv/transitive3
                         (Pi01P+Pi3P<=>Pi01)
                         (equiv/combine
                           (equiv/transitive3
                             (Pi4+Pi12outP<=>Pi01P)
                             (equiv/combine
                               (equiv/reflexive)
                               (Pik1P+Pi2outP<=>Pi12outP))
                             (equiv/roll2))
                           (equiv/reflexive))
                         (equiv/symmetric equiv/associate)))
                     (implies/reflexive))
                   (implies/equiv equiv/swap)
                   (implies/combine
                     (implies/trans
                       (implies/equiv equiv/roll2)
                       (IMP x o))
                     (implies/reflexive))
                   (implies/equiv
                     (equiv/transitive3
                       (equiv/commute)
                       (equiv/symmetric equiv/associate)
                       (equiv/symmetric equiv/associate))))))
             (implies/combine implies/reflexive % PiQ2
               (implies/trans4
                 (implies/equiv
                   (equiv/transitive
                     (equiv/combine equiv/reflexive equiv/roll4)
                     (equiv/associate)))
                 (implies/combine (IMP2 x o) implies/reflexive)
                 (implies/equiv (equiv/symmetric equiv/associate))
                 (implies/equiv
                   (equiv/combine equiv/reflexive % PiB
                     (equiv/transitive
                       (equiv/roll2)
                       (equiv/combine equiv/reflexive % Pi4
                         (equiv/transitive
                           (equiv/roll2)
                           (equiv/combine equiv/reflexive % Pi2outP
                             (equiv/transitive
                               (equiv/roll2)
                               (equiv/combine equiv/reflexive % Pi3P
                                 (equiv/transitive
                                   (equiv/combine equiv/commute equiv/reflexive)
                                   (equiv/symmetric equiv/associate))))))))))))
             (implies/equiv equiv/roll6)
             (implies/combine
               (implies/reflexive)
               (implies/equiv
                 (equiv/transitive8
                   (equiv/roll6)
                   (equiv/combine equiv/reflexive equiv/roll2)
                   (equiv/associate)
                   (equiv/combine
                     (equiv/reflexive)
                     (equiv/transitive3
                       (equiv/combine (equiv/reflexive) (equiv/roll3))
                       (equiv/associate)
                       (equiv/combine
                         (equiv/combine equiv/reflexive Pi3P<=>Pi3)
                         (equiv/reflexive))))
                   (equiv/associate)
                   (equiv/combine equiv/reflexive
                     (equiv/transitive3
                       (equiv/combine equiv/reflexive equiv/associate)
                       (equiv/roll2)
                       (equiv/combine (Pi2outP+Pf<=>Pi2P x) equiv/reflexive)))
                   (equiv/associate)
                   (equiv/combine equiv/reflexive
                     (equiv/transitive
                       (equiv/roll2)
                       (equiv/combine equiv/reflexive equiv/commute))))))
             (implies/combine (implies/reflexive)
               (implies/combine (implies/reflexive)
                 (implies/combine
                   (implies/equiv-encumbered
                     (equiv/reflexive)
                     (equiv/commute))
                   (implies/reflexive))))
             (implies/equiv equiv/roll2)))))
     <- let-helper/L3 CM-B-XXV XX1+XX2P=XX M<=MP XXV+XX1=>XX0+QP %{=>}%
       S3 FS3 M3 QP=>FS3 S2P^FS3 S2uFS3=S3 S3=>M3
       (MP^M3:efxmap`disjoint MP M3) (MP+M3=M0:efxmap`join MP M3 M0)
       (QP=Q2P:set`eq QP Q2P) (S0=S1:set`eq S0 S1) (Q0=Q1:set`eq Q0 Q1)
     <- let-helper/L6 XX1+XX2P=XX (M2outk<=M:efxmap`leq M2outk M)
     <- objset2fldset-respects-eq QP=>FS3 clsmap`eq/ cxt`eq/ QP=Q2P set`eq/ Q2=>FS3
     <- efxmap`partition-implies-disjoint-join M0|FS=>M01+M02 M01^M02 M01+M02=M0
     <- efxmap`disjoint-join-implies-equiv-converse M01^M02 M01+M02=M0
       M01=>Pi01 M02=>Pi02 Pi0 M0=>Pi0 Pi01+Pi02<=>Pi0
     <- efxmap`disjoint-join-implies-equiv MP^M3 MP+M3=M0 M0=>Pi0 PiP Pi3
       MP=>PiP M3=>Pi3 Pi0<=>PiP+Pi3
     <- let-helper/L18 S2=>R2 N!<R2 N!<Q2 Q2=>FS3 S2uFS3=S3
       S3=>M3 M3=>Pi3 N!<B ([x] B+N=BF x) ([x] BP+Q2=>FS3 x) ([x] BP+M3=>Pi3 x)
     <- let-helper/L16 ([x] CM-BP-XX2 x) _
       DM-M2=R2 ([x] CM-BP-R2 x) ([x] CM-BP-Q2 x)
     <- let-helper/L19 N!<B ([x] B+N=BF x) CM-BP-Q2 N!<Q2 CM-B-Q2
     <- make-encumbered-total CM-CM CM2PM CM-B-Q2 _ Q2=>PiQ2
     <- let-helper/L20 Q2=>PiQ2 N!<B ([x] B+N=BF x) N!<Q2 ([x] BP+Q2=>PiQ2 x)
     <- set`eq-symmetric QP=Q2P Q2=QP
     <- make-encumbered-respects-eq Q2=>PiQ2 clsmap`eq/ predmap`eq/ cxt`eq/
       Q2=QP permission`eq/ (QP=>PiQ2:make-encumbered CM PM B QP PiQ2)
     <- efxmap`join-implies-leq MP+M3=M0 MP<=M0 M3<=M0
     <- efxmap`join-implies-leq Mk3+M2out=M2outk Mk3<=M2outk M2out<=M2outk
     <- efxmap`join-implies-leq Mk1+Mk2=Mk3 Mk1<=Mk3 Mk2<=Mk3
     <- efxmap`leq-transitive M2outk<=M M<=MP M2outk<=MP
     <- efxmap`leq-transitive Mk3<=M2outk M2outk<=MP Mk3<=MP
     <- efxmap`leq-transitive Mk1<=Mk3 Mk3<=MP Mk1<=MP
     <- efxmap`leq-transitive Mk2<=Mk3 Mk3<=MP Mk2<=MP
     <- efxmap`leq-transitive M2out<=M2outk M2outk<=MP M2out<=MP
     <- efxmap`leq-transitive M2outk<=MP MP<=M0 M2outk<=M0
     <- efxmap`leq-transitive Mk1<=Mk3 Mk3<=M2outk Mk1<=M2outk
     <- efxmap`leq-transitive Mk2<=Mk3 Mk3<=M2outk Mk2<=M2outk
     <- efxmap`leq-transitive Mk1<=M2outk M2outk<=M0 Mk1<=M0
     <- efxmap`leq-transitive Mk2<=M2outk M2outk<=M0 Mk2<=M0
     <- efxmap`leq-transitive M2out<=M2outk M2outk<=M0 M2out<=M0
     <- set2efxmap-implies-domain FS+X1=>Mk2 DM-Mk2=FS
     <- let-helper/L28 M0|FS=>M01+M02 Mk2<=M0 DM-Mk2=FS Mk2=<=M02
     <- let-helper/L26 CB M2|N=M2out+M2in M2in=>MF2in
       OS+MF2in=Mk1 FS+X1=>Mk2 Mk1^M2out Mk2^M2out
     <- let-helper/L29 OS+MF2in=Mk1 OS^FS S2in DM-Mk1=Sk1 FS^Sk1
     <- efxmap`domain-preserves-disjoint-converse FS^Sk1 DM-Mk2=FS DM-Mk1=Sk1 Mk2^Mk1
     <- efxmap`join-total Mk1+M2out=M12out
     <- efxmap`disjoint-symmetric Mk2^M2out M2out^Mk2
     <- efxmap`disjoint-symmetric Mk2^Mk1 Mk1^Mk2
     <- efxmap`disjoint-respects-geq* MP^M3 Mk1<=MP Mk1^M3
     <- efxmap`disjoint-respects-geq* MP^M3 M2out<=MP M2out^M3
     <- efxmap`join-preserves-disjoint* Mk1^Mk2 M2out^Mk2 Mk1+M2out=M12out M12out^Mk2
     <- efxmap`join-preserves-disjoint* Mk1^M3 M2out^M3 Mk1+M2out=M12out M12out^M3
     <- efxmap`domain-total DM-M12out=S12out
     <- efxmap`domain-preserves-disjoint M12out^Mk2 DM-M12out=S12out DM-Mk2=FS S12out^FS
     <- efxmap`disjoint-leq-implies-join-leq* Mk1^M2out Mk1<=M0 M2out<=M0
       Mk1+M2out=M12out M12out<=M0
     <- efxmap`domain-preserves-leq Mk2<=M0 DM-Mk2=FS R0 DM-M0=S0 FS<=S0
     <- let-helper/L31 M0|FS=>M01+M02 DM-M0=S0 FS<=S0 DM-M02=FS
     <- let-helper/L30 M0|FS=>M01+M02 M12out<=M0 DM-M12out=S12out
       DM-M02=FS S12out^FS M12out<=M01
     <- efxmap`disjoint-symmetric M12out^M3 M3^M12out
     <- efxmap`disjoint-respects-geq* MP^M3 Mk2<=MP Mk2^M3
     <- efxmap`domain-total DM-M3=R3
     <- efxmap`domain-preserves-disjoint Mk2^M3 DM-Mk2=FS DM-M3=R3 FS^R3
     <- efxmap`domain-preserves-disjoint-converse FS^R3 DM-M02=FS DM-M3=R3 M02^M3
     <- let-helper/L34 (efxmap-split/ MP^M3 MP+M3=M0)
       (efxmap-split/ M01^M02 M01+M02=M0) M02^M3 MO1P M01=>M01P+M3 MP=>M01P+M02
     <- efxmap-split-implies-disjoint-join M01=>M01P+M3 M01P^M3 M01P+M3=M01
     <- efxmap`join-disjoint-right-leq-implies-leq
       M01P+M3=M01 M3^M12out M12out<=M01 M12out<=M01P
     <- efxmap`domain-total DM-M12out=R12out
     <- let-helper/L12 M12out<=M01P DM-M12out=R12out %{=>}% M4 M12outP
       M01P|R12out=M4+M12outP M12out=<=M12outP
     <- efxmap-partition-implies-split M01P|R12out=M4+M12outP M01P=>M4+M12outP
     <- efxmap-split-implies-disjoint-join M01P=>M4+M12outP M4^M12outP M4+M12outP=M01P
     <- efxmap-disjoint-join-vleq-converse Mk1^M2out Mk1+M2out=M12out M12out=<=M12outP
       Mk1P M2outP Mk1P^M2outP Mk1P+M2outP=M12outP Mk1=<=Mk1P M2out=<=M2outP
     <- efxmap`disjoint-join-implies-equiv M01P^M3 M01P+M3=M01
       M01=>Pi01 Pi01P Pi3P M01P=>Pi01P M3=>Pi3P Pi01P+Pi3P<=>Pi01
     <- efxmap`disjoint-join-implies-equiv M4^M12outP M4+M12outP=M01P
       M01P=>Pi01P Pi4 Pi12outP M4=>Pi4 M12outP=>Pi12outP Pi4+Pi12outP<=>Pi01P
     <- efxmap`disjoint-join-implies-equiv Mk1P^M2outP Mk1P+M2outP=M12outP
       M12outP=>Pi12outP Pik1P Pi2outP Mk1P=>Pik1P M2outP=>Pi2outP Pik1P+Pi2outP<=>Pi12outP
     <- efxmap`domain-total (DM-M2out=R2out: efxmap`domain M2out R2out)
     <- let-helper/L4 M2|N=M2out+M2in _ M2in-N M2out=>O2out N!<O2out
     <- let-helper/L36 M2|N=M2out+M2in M2out=<=M2outP M2P M2P|N=M2outP+M2in M2=<=M2P
     <- efxmap-vleq-implies-leq M2=<=M2P M2<=M2P
     <- efxmap`domain-total DM-M2in=R2in
     <- let-helper/L10 M2|N=M2out+M2in M2out<=M2 M2in<=M2 M2out^M2in M2out+M2in=M2
     <- efxmap`domain-preserves-leq* M2in<=M2 DM-M2in=R2in DM-M2=R2 R2in<=R2
     <- ({x} clsmap-cxt-fldset-respects-geq (CM-BP-R2 x) R2in<=R2 (CM-BP-R2in x))
     <- let-helper-before/simple/unique/L M2=>MS N<-MS M2|N=M2out+M2in _ SZ-M2in
     <- ({x} cxt`update-implies-lookup (B+N=BF x) (BL x))
     <- let-helper/L5 DM-M2in=R2in ([x] CM-BP-R2in x) ([x] BL x) CML M2in-N M2in=>MF2in
       _ _ (DM-MF2in=S2Fin:efxmap`domain MF2in S2Fin)
       (DM-FM=FS:fldmap`domain FM FMS) S2Fin<=FS
     <- efxmap-map-fields-preserves-size SZ-M2in M2in=>MF2in SZ-MF2in
     <- efxmap`domain-preserves-size SZ-MF2in DM-MF2in=S2Fin SZ-S2Fin
     <- efx2frac-total (X1=>Q1: efx2frac Xx1 Qx1)
     <- let-helper-before/unique/L12L1 FS+X1=>Mk2 Mk2=<=M02 MX-M02=X (X1<=X:efx`leq Xx1 Xx)
     <- let-helper-before/unique/L12 CM-CM CM2PM CML M2in=>MF2in DM-MF2in=S2Fin
       DM-FM=FS (S2Fin<=FS) SZ-OS SZ-S2Fin CM-B-OS M2in-N OS+MF2in=Mk1 Mk1=<=Mk1P
       Mk1P=>Pik1P OS=>PiG N!<B ([x] B+N=BF x) MX-M2in=X1 X1<=X X1=>Q1 M02=>Pi02 X=>Q PML
     %{=>}% Pf N+MF2in=>M2in ([x] BF+M2in=>Pf x) IMP
     <- let-helper-before/unique/L13 CM-B OS=>PiG CM-B-OS PML B=>PiB IMP2
     <- let-helper/L10 M2P|N=M2outP+M2in _ _ M2outP^M2in M2outP+M2in=M2P
     <- efxmap-vleq-implies-same-domain M2out=<=M2outP SDM
      <- efxmap-same-domain-implies-domain-left SDM DM-M2out=R2out DM-M2outP=R2out
      <- efxmap-vleq-preserves-efxmap-map-objects M2out=>O2out M2out=<=M2outP M2outP=>O2out
     <- let-helper/L21 M2outP=>O2out N!<O2out N!<B B+N=BF M2outP=>Pi2outP ([x] BF+M2outP=>Pi2outP x)
     <- ({x} efxmap`disjoint-join-implies-equiv-converse M2outP^M2in
          M2outP+M2in=M2P (BF+M2outP=>Pi2outP x) (BF+M2in=>Pf x) (Pi2P x)
          (M2P=>Pi2P x) (Pi2outP+Pf<=>Pi2P x))
     <- efxmap2perm-equiv M3=>Pi3P M3=>Pi3 clsmap`eq/ predmap`eq/ cxt`eq/ efxmap`eq/ Pi3P<=>Pi3.

 %worlds (objvar) (let-helper-before/unique/+
                    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
 %total {} (let-helper-before/unique/+
             _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).