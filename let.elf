%theorem clsmap-cxt-capset/U-inversion
  : forall* {CM} {B} {S} {S'} {K}
    forall {CM-B-S: clsmap-cxt-capset CM B S}
    {NM: set`not-member S' (s K)}
    {AD: set`add S' (s K) S}
    exists {CM-B-S': clsmap-cxt-capset CM B S'}
    {N} {F} {N+F=>K: nat2pair (s K) (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {NS: not-shared A}
    {FM} {CML: clsmap`lookup CM C FM}
    {T} {FML: fldmap`lookup FM F T}
    true.

%%% Proof for Let

%%% A few abbreviations

%abbrev unique-obj-permission : clspred -> (object -> permission)
  = [CP] ([x] unitperm (nonlinear (neg (objequal x null))) ,
           (unitperm (conditional (objequal x null) empty
                       (combine (allperm x) (one-predcall CP x))))).

%%% A few lemmas

ty2perm3 : clsmap -> predmap -> ty -> (object -> permission) -> type.

% ty2perm3/null : ty2perm3 _ _ ty/null ([x] unitperm (nonlinear (objequal x null))).

ty2perm3/shared :
    ty2perm PM (ty/ NN annot/shared C) PF ->
 ty2perm3 _ PM (ty/ NN annot/shared C) ([x] PF x).

ty2perm3/borrow :
    ty2perm PM (ty/ NN annot/borrow C) PF ->
 ty2perm3 _ PM (ty/ NN annot/borrow C) ([x] PF x).

ty2perm3/unique :
   clsmap`lookup CM C FM ->
   predmap`lookup PM C CP ->
   fldmap`domain FM FS ->
   ({x} fldset2perm PM x FM FS (PF x)) ->
   ty2perm PM (ty/ NN annot/borrow C) ([x] (Pi x)) ->
 ty2perm3 CM PM (ty/ NN annot/unique C)
   ([x] combine (Pi x)
     (unitperm
       (conditional
         (objequal x null)
         (empty)
         (unitperm
           (encumbered
             (PF x)
             (combine (allperm x) (one-predcall CP x))))))).


%%% A few theorems about ty2perm3

%theorem ty2perm3-respects-eq
  : forall* {T1} {T2} {CM1} {CM2} {PM1} {PM2} {PF1} {PF2}
    forall {T2PF: ty2perm3 CM1 PM1 T1 PF1}
    {CME: clsmap`eq CM1 CM2} {PME: predmap`eq PM1 PM2} {TE: ty`eq T1 T2}
    {PFE: {o} permission`eq (PF1 o) (PF2 o)}
    exists {T2PF: ty2perm3 CM2 PM2 T2 PF2}
    true.

- : ty2perm3-respects-eq T2PF clsmap`eq/ predmap`eq/ ty`eq/ ([_] permission`eq/) T2PF.

%worlds (gtermvar) (ty2perm3-respects-eq _ _ _ _ _ _).
%total { } (ty2perm3-respects-eq _ _ _ _ _ _).


%theorem ty2perm3-implies/L/unique
  : forall* {Pi1: object -> permission} {Pi2} {CP1} {CP2} {PF1} {PF2}
    forall {FEQ: {o} permission`eq (Pi1 o) (Pi2 o)}
    {PEQ: predicate`eq CP1 CP2} {PF-EQ: {x} permission`eq (PF1 x) (PF2 x)}
    exists {EQ: {x} permission`eq
           (combine (Pi1 x)
             (unitperm (conditional (objequal x null) empty
                         (unitperm (encumbered (PF1 x)
                                     (combine (allperm x) (one-predcall CP1 x)))))))
           (combine (Pi2 x)
             (unitperm (conditional (objequal x null) empty
                         (unitperm (encumbered (PF2 x)
                                     (combine (allperm x) (one-predcall CP2 x)))))))}
    true.

- : ty2perm3-implies/L/unique
     ([_] permission`eq/) predicate`eq/ ([_] permission`eq/) ([_] permission`eq/).

%worlds (gtermvar) (ty2perm3-implies/L/unique _ _ _ _).
%total  {} (ty2perm3-implies/L/unique _ _ _ _).


%theorem ty2perm3-unique
  : forall* {CM1} {CM2} {PM1} {PM2} {T1} {T2} {PF1} {PF2}
    forall {T12PF1: ty2perm3 CM1 PM1 T1 PF1}
    {T22PF2: ty2perm3 CM2 PM2 T2 PF2}
    {E: clsmap`eq CM1 CM2} {E: predmap`eq PM1 PM2} {EQ: ty`eq T1 T2}
    exists {EQ: {o} permission`eq (PF1 o) (PF2 o)}
    true.

- : ty2perm3-unique
    (ty2perm3/unique CML1 PML1 DM1 ([x] FM=>PF1 x) T=>Pi1)
    (ty2perm3/unique CML2 PML2 DM2 ([x] FM=>PF2 x) T=>Pi2)
    (CM-EQ:clsmap`eq CM1 CM2) (PM-EQ:predmap`eq PM1 PM2) T-EQ P-EQ
    <- ty-eq-inversion T-EQ NN-EQ A-EQ C-EQ
    <- clsmap`lookup-unique CML1 CML2 CM-EQ C-EQ FM-EQ
    <- predmap`lookup-unique PML1 PML2 PM-EQ C-EQ CP-EQ
    <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ2
    <- ty2perm-deterministic T=>Pi1 T=>Pi2 PM-EQ T-EQ2 PF-EQ
    <- fldmap`domain-unique DM1 DM2 FM-EQ FS-EQ
    <- ({x} fldset2perm-unique (FM=>PF1 x) (FM=>PF2 x) PM-EQ object`eq/ FM-EQ FS-EQ (EQ x))
    <- ty2perm3-implies/L/unique PF-EQ CP-EQ EQ P-EQ.

- : ty2perm3-unique
    (ty2perm3/borrow T2PF1) (ty2perm3/borrow T2PF2)
    CM-EQ PM-EQ T-EQ PF-EQ
    <- ty-eq-inversion T-EQ NN-EQ A-EQ C-EQ
    <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ2
    <- ty2perm-deterministic T2PF1 T2PF2 PM-EQ T-EQ2 PF-EQ.

- : ty2perm3-unique
    (ty2perm3/shared T2PF1) (ty2perm3/shared T2PF2)
    CM-EQ PM-EQ T-EQ PF-EQ
    <- ty-eq-inversion T-EQ NN-EQ A-EQ C-EQ
    <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ2
    <- ty2perm-deterministic T2PF1 T2PF2 PM-EQ T-EQ2 PF-EQ.

% - : ty2perm3-unique ty2perm3/null ty2perm3/null _ _ _ ([_] permission`eq/).

%worlds (gtermvar) (ty2perm3-unique _ _ _ _ _ _).
%total { } (ty2perm3-unique _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L1L
  : forall* {B} {N} {OF:object -> object} {TF}
    forall {BL: {x} cxt`lookup B N (cxt-info/ (OF x) TF)}
    exists {O} {T} {BL: cxt`lookup B N (cxt-info/ O T)}
    {EQ: {x} object`eq (OF x) O}
    true.

- : letRefTyping-helper/base/unique/L1L
    ([_] cxt`lookup/= N1=N2) _ _ (cxt`lookup/= N1=N2) ([_] object`eq/).

- : letRefTyping-helper/base/unique/L1L
    ([x] cxt`lookup/> (BL x) P) _ _ (cxt`lookup/> BLP P) EQF
    <- letRefTyping-helper/base/unique/L1L BL _ _ BLP EQF.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L1L _ _ _ _ _).
%total (L) (letRefTyping-helper/base/unique/L1L L _ _ _ _).


%theorem letRefTyping-helper/base/unique/L1L2L1
  : forall* {O2} {O2P} {N} {F} {PF}
    forall {EQ: object`eq O2 O2P} {EQ: nat`eq F N}
    exists {IMP: {x} implies
                 (combine
                   (unitperm (nonlinear (objequal x O2)))
                   (unitperm
                     (conditional
                       (objequal O2P null)
                       (empty)
                       (fldperm O2P N PF))))
                 (combine
                   (unitperm
                     (conditional
                       (objequal x null)
                       (empty)
                       (fldperm x F PF)))
                   (unitperm
                     (encumbered
                       (unitperm
                         (conditional
                           (objequal x null)
                           (empty)
                           (fldperm x F PF)))
                       (unitperm
                         (conditional
                           (objequal O2P null)
                           (empty)
                           (fldperm O2P N PF))))))}
    true.

- : letRefTyping-helper/base/unique/L1L2L1 object`eq/ nat`eq/
    ([x] implies/trans
      (implies/combine (implies/nonlinear bimplies/objequal-symmetric)
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine implies/reflexive
            (implies/self-implication))))
      (implies/objequal
        ([v] (combine
               (unitperm
                 (conditional
                   (objequal v null)
                   (empty)
                   (fldperm v F PF)))
               (unitperm
                 (encumbered
                   (unitperm
                     (conditional
                       (objequal v null)
                       (empty)
                       (fldperm v F PF)))
                   (unitperm
                     (conditional
                       (objequal O2P null)
                       (empty)
                       (fldperm O2P F PF))))))))).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L1L2L1 _ _ _).
%total { } (letRefTyping-helper/base/unique/L1L2L1 _ _ _).


%theorem letRefTyping-helper/base/unique/L1L2
  : forall* {CM} {PM} {B} {O} {N1} {MF} {M2} {Pi2} {BF} {A} {C} {N2} {A1} {NN1} {NN2}
    forall {L: cxt`lookup B (s N2) (cxt-info/ O (ty/ NN2 A1 C))}
    {N1!<B: cxt`fresh B (s N1)}
    {B+N1=BF: {x} cxt`update B (s N1) (cxt-info/ x (ty/ NN1 A C)) (BF x)}
    {N2+MF=M2: nat+set2set (s N2) MF M2}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {NN1<=NN2: nonnull`leq NN1 NN2}
    exists {M1} {Pi1}
    {N1+MF=M1: nat+set2set (s N1) MF M1}
    {M1=>Pi1: {x} capset2perm CM PM (BF x) M1 (Pi1 x)}
    {IMP: {x} implies (combine (unitperm (nonlinear (objequal x O))) Pi2)
          (combine (Pi1 x) (unitperm (encumbered (Pi1 x) Pi2)))}
    true.

%theorem letRefTyping-helper/base/unique/L1L2/F
  : forall* {CM} {PM} {N1} {MF} {BF} {O} {Pi2}
    forall {F:void}
    exists {M1} {Pi1}
    {N1+MF=M1: nat+set2set (s N1) MF M1}
    {M1=>Pi1: {x} capset2perm CM PM (BF x) M1 (Pi1 x)}
    {IMP: {x} implies (combine (unitperm (nonlinear (objequal x O))) Pi2)
          (combine (Pi1 x) (unitperm (encumbered (Pi1 x) Pi2)))}
    true.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L1L2/F _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L1L2/F _ _ _ _ _ _).

- : letRefTyping-helper/base/unique/L1L2 _ _ _ nat+set2set/0 capset2perm/0 LEQ
    _ _ (nat+set2set/0) ([_] capset2perm/0)
    ([x] implies/combine implies/nonlinear2empty implies/self-implication).

- : letRefTyping-helper/base/unique/L1L2
    (BL:cxt`lookup B (s Nx2) _)
    (N1!<B:cxt`fresh B (s Nx1)) B+N=BF
    (nat+set2set/U (N2+MFP=M2P:nat+set2set (s Nx2) MFP M2P)
      (N2+F=K2:pair2nat (pair/ (s Nx2) F) shared)
      F!<MFP MFP+F+X=MF M2P+K2+X=M2) M2=>Pi2 LEQ _ _ N1+MF=M1 M1=>Pi1 IMP
    <- nat2pair-deterministic/0 N2+F=K2 PE
    <- pair-eq-implies-eq PE E1 E2
    <- nat`eq-symmetric E1 E1S
    <- nat`eq-contradiction E1S V
    <- letRefTyping-helper/base/unique/L1L2/F V _ _ N1+MF=M1 M1=>Pi1 IMP.

- : {B+N=BF:{x} cxt`update B (s Nx1) (cxt-info/ x (ty/ NNx1 A C)) (BF x)}
    letRefTyping-helper/base/unique/L1L2
    (BL:cxt`lookup B (s Nx2) (cxt-info/ O2 (ty/ NNx2 A1 C)))
    (N1!<B:cxt`fresh B (s Nx1)) B+N=BF
    (nat+set2set/U (N2+MFP=M2P:nat+set2set (s Nx2) MFP M2P)
      (N2+F=K2:pair2nat (pair/ (s Nx2) F) (s K2))
      F!<MFP MFP+F+X=MF (M2P+K2+X=M2:set`add M2P (s K2) M2))
    M2=>Pi2 (LEQ:nonnull`leq NNx1 NNx2) _ _
    (nat+set2set/U N1+MFP=M1P (N1+F=K1:pair2nat (pair/ (s Nx1) F) (s K1)) F!<MFP
      (MFP+F+X=MF:set`add MFP F MF)
      (M1P+K1+X=M1:set`add M1P (s K1) M1))
    ([x] capset2perm/U (M1P=>Pi12 x) N1+F=K1 (BFL x)
      (create-fldperm/ CML FML T2PF) K1!<M1P M1P+K1+X=M1)
    ([x] implies/trans7
      (implies/combine
        (implies/duplicate)
        (implies/equiv (equiv/symmetric (Pi21+Pi22<=>Pi2))))
      (implies/equiv
        (equiv/transitive
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive equiv/roll2)))
      (implies/combine
        (implies/reflexive)
        (implies/combine
          (implies/reflexive)
          (IMPP x)))
      (implies/equiv equiv/associate)
      (implies/combine (IMPP2 x) (implies/reflexive))
      (implies/equiv
        (equiv/transitive3
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive equiv/roll2)
          (equiv/associate)))
      (implies/combine implies/reflexive
        (implies/trans
          (implies/combine-merge-encumbered)
          (implies/equiv-encumbered
            (equiv/reflexive)
            (Pi21+Pi22<=>Pi2)))))
     <- nat+set2set-preserves-not-member N2+MFP=M2P F!<MFP N2+F=K2 K2!<M2P
     <- capset2perm/U-inversion M2=>Pi2 K2!<M2P M2P+K2+X=M2
       N2P FP N2P+FP=K2 O2P NNP AP CP BL2 _ (create-fldperm/ CML2 FML2 T2PF)
       Pi22 M2P=>Pi22 (Pi21+Pi22<=>Pi2)
     <- letRefTyping-helper/base/unique/L1L2 BL N1!<B B+N=BF N2+MFP=M2P
       M2P=>Pi22 LEQ %{=>}% M1P Pi12 N1+MFP=M1P ([x] M1P=>Pi12 x) ([x] IMPP x)
     <- pair2nat-total-s _ _ K1 (N1+F=K1: pair2nat (pair/ (s Nx1) F) (s K1))
     <- set`update-total M1P+K1+X=M1
     <- ({x} cxt`update-implies-lookup (B+N=BF x) (BFL x))
     <- nat+set2set-preserves-not-member N1+MFP=M1P F!<MFP N1+F=K1 K1!<M1P
     <- nat2pair-unique N2+F=K2 N2P+FP=K2 nat`eq/ N2+F=N2P+FP
     <- pair-eq-implies-eq N2+F=N2P+FP N2=N2P F=FP
     <- cxt`lookup-unique BL BL2 cxt`eq/ N2=N2P CIE
     <- cxt-info-eq-inversion CIE O2=O2P TE
     <- ty-eq-inversion TE NN=NNP A=AP C=CP
     <- nat`eq-symmetric C=CP CP=C
     <- nat`eq-symmetric F=FP FP=F
     <- nonnull`eq-symmetric NN=NNP NNP=NN
     <- clsmap`lookup-respects-eq CML2 clsmap`eq/ CP=C fldmap`eq/ CML
     <- fldmap`lookup-respects-eq FML2 fldmap`eq/ FP=F ty`eq/ FML
     <- letRefTyping-helper/base/unique/L1L2L1 O2=O2P F=FP IMPP2.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L1L2 _ _ _ _ _ _ _ _ _ _ _).
%total (M) (letRefTyping-helper/base/unique/L1L2 _ _ _ M _ _ _ _ _ _ _ ).


%theorem letRefTyping-helper/base/unique/L1L3
  : forall* {O1} {O2} {Pi2} {Pi2P}
    forall {O1=O2: {x} object`eq (O1 x) O2}
    {IMP2:{x:gterm objectk}
           implies (combine (unitperm (nonlinear (objequal x O2))) Pi2)
           (combine (Pi2P x) (unitperm (encumbered (Pi2P x) Pi2)))}
    exists {IMP2:{x:gterm objectk}
                  implies
                  (combine (unitperm (nonlinear (objequal x (O1 x)))) Pi2)
                  (combine (Pi2P x) (unitperm (encumbered (Pi2P x) Pi2)))}
    true.

- : letRefTyping-helper/base/unique/L1L3 ([_] object`eq/) IMP IMP.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L1L3 _ _ _).
%total { } (letRefTyping-helper/base/unique/L1L3 _ _ _).


%theorem letRefTyping-helper/base/unique/L1
  : forall* {S} {B} {GF} {FS} {M1} {N} {C} {B1} {CM} {PM} {PiM1} {A} {NN}
    forall {SN} {SZ-S: set`size S (s SN)}
    {CM-B-S: cxt-unique-objset B NN C S}
    {S+FS=M1: set+set2set S FS M1}
    {M1=>PiM1: capset2perm CM PM B M1 PiM1}
    {S=>GF: {x} set2cond B x S (GF x)}
    {BF: cxt`fresh B (s N)}
    {BL: {x} cxt`update B (s N) (cxt-info/ x (ty/ NN A C)) (B1 x)}
    exists {M2} {PiM2}
    {N+FS=M2: nat+set2set (s N) FS M2}
    {M2=>PiM2: {x} capset2perm CM PM (B1 x) M2 (PiM2 x)}
    {PiM1+GF=>PiM2: {x} implies (combine (GF x) PiM1)
                    (combine (GF x)
                      (combine (PiM2 x) (unitperm (encumbered (PiM2 x) PiM1))))}
    true.

%theorem letRefTyping-helper/base/unique/L1/F
  : forall* {CM} {PM} {FS} {N} {GF:object -> permission} {PiM1} {B1}
    forall {V:void}
    exists {M2} {PiM2}
    {N+FS=M2: nat+set2set (s N) FS M2}
    {M2=>PiM2: {x} capset2perm CM PM (B1 x) M2 (PiM2 x)}
    {PiM1+GF=>PiM2: {x} implies (combine (GF x) PiM1)
                    (combine (GF x)
                      (combine (PiM2 x) (unitperm (encumbered (PiM2 x) PiM1))))}
    true.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L1/F _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L1/F _ _ _ _ _ _).

 - : letRefTyping-helper/base/unique/L1 _ SZ CM-B-S
     (set+set2set/U SP+MF=MP1 NP+MF=>MP2 NP!<SP (SP+NP=S:set`add SP z S) MP1+MP2=M)
     M=>Pi ([x] S=>GF x) BF BU _ _ K1 K2 K3
     <- set`add-implies-member SP+NP=S MB
     <- cxt-unique-objset-no-zero CM-B-S MB V
     <- letRefTyping-helper/base/unique/L1/F V _ _ K1 K2 K3.

 - : letRefTyping-helper/base/unique/L1 z SZ CM-B-S
     (set+set2set/U SP+MF=MP1 NP+MF=>MP2 NP!<SP (SP+NP=S:set`add SP (s NP) S)
       (MP1+MP2=M:set`union MP1 MP2 M))
     M=>Pi ([x] S=>GF x) BF BU %{=>}% _ _
     (N+MF=>MN:nat+set2set (s N) MF MN) MN=>Pf
     ([x] implies/trans8
       (implies/combine (GIMP1 x) implies/reflexive)
       (implies/equiv equiv/commute)
       (implies/cond-push)
       (implies/cond-gen-inner)
       (implies/cond-inner
         (bimplies/reflexive)
         (bimplies/reflexive)
         (implies/trans3
           (implies/combine
             (implies/reflexive)
             ((implies/equiv equiv/identity)))
           (IMPP2 x)
           (implies/equiv (equiv/symmetric equiv/identity)))
         (implies/trans5
           (implies/combine implies/nonlinear2empty
             (implies/combine implies/reflexive (GFP=>F x)))
           (implies/equiv (equiv/transitive equiv/commute equiv/identity))
           (implies/combine implies/reflexive implies/duplicate)
           (implies/equiv equiv/associate)
           (implies/combine
             (implies/trans3
               (implies/equiv equiv/commute)
               (implies/combine (implies/contradiction) implies/reflexive)
               (IMPP2 x))
             (F=>GFP x))))
       (implies/cond-pull)
       (implies/equiv equiv/commute)
       (implies/combine (GIMP2 x) implies/reflexive))
     <- set`not-member-add-size-implies-empty NP!<SP SP+NP=S SZ SP=0
     <- ({x} set2cond/U-inversion (S=>GF x) NP!<SP SP+NP=S (GFP x) (SP=>GFP x)
       (OF x) _ (BL x) (GIMP1 x) (GIMP2 x))
     <- letRefTyping-helper/base/unique/L1L BL _ _ BL1 ([x] OF=O2 x)
     <- cxt-unique-objset/U-inversion CM-B-S NP!<SP SP+NP=S
       CM-B-SP O1 A1 _ BLP UA (LEQ:nonnull`leq NNx1 NNx2)
     <- set+set2set-unique SP+MF=MP1 set+set2set/0 SP=0 set`eq/ MP1=0
     <- set`union-unique MP1+MP2=M set`union/L MP1=0 set`eq/ M=MP2
     <- capset2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/ cxt`eq/ M=MP2
       permission`eq/ MP2=>Pi
     <- cxt`lookup-unique BL1 BLP cxt`eq/ nat`eq/ CIE
     <- ({x} cxt`update-implies-lookup (BU x) (BL2 x))
     <- letRefTyping-helper/base/unique/L1L2
       BLP BF BU NP+MF=>MP2 MP2=>Pi LEQ _ _ N+MF=>MN MN=>Pf IMPP
     <- set`eq-symmetric M=MP2 MP2=M
     <- cxt-info-eq-inversion CIE O2=O1 TE
     <- ({x:object} object`eq-transitive (OF=O2 x) O2=O1 (OF=O1 x))
     <- letRefTyping-helper/base/unique/L1L3 OF=O1 IMPP IMPP2
     <- ({x} set2cond-implies (SP=>GFP x) set2cond/0 object`eq/ SP=0 (GFP=>F x) (F=>GFP x)).

- : {S=>GF: {x} set2cond B x S (GF x)}
    letRefTyping-helper/base/unique/L1 _ SZ S-NN-C
    (set+set2set/U SP+MF=M1 N1+MF=M2 (N1!<SP:set`not-member SP (s Nx1))
      SP+N1=S (M1+M2=M:set`union M1 M2 M)) M=>Pi ([x] S=>GF x) BF ([x] BU x)
    %{=>}% MN _ (N+MF=MN:nat+set2set (s Nx) MF MN) ([x] MN=>Pf x)
    ([x] implies/trans7
      (implies/combine (GF=>EQ+GFP x) (implies/equiv (Pi<=>Pi1+Pi2)))
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans7
          (implies/combine implies/reflexive (implies/equiv equiv/identity))
          (implies/equiv
            (equiv/transitive
              (equiv/combine equiv/reflexive equiv/commute)
              (equiv/associate)))
          (implies/combine (IMP2P x)
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/self-implication)
                  (implies/equiv-encumbered
                    (Pi<=>Pi1+Pi2)
                    (equiv/reflexive))
                  (implies/combine-assoc-encumbered)))
              (implies/linear-modus-ponens)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive implies/chain-implication)
          (implies/combine (implies/equiv (Pi2P<=>Pf x))
            (implies/equiv-encumbered (Pi2P<=>Pf x) equiv/reflexive))
          (implies/equiv
            (equiv/transitive (equiv/symmetric equiv/identity) (equiv/commute))))
        (implies/trans4
          (implies/combine
            (implies/nonlinear2empty)
            (implies/trans3
              (implies/equiv equiv/commute)
              (implies/equiv equiv/associate)
              (implies/combine
                (GFP+Pi1=>Pf+Pf-Pi1 x)
                (implies/reflexive))))
          (implies/equiv
            (equiv/transitive equiv/commute equiv/identity))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine implies/reflexive
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/transitive
                          (Pi<=>Pi1+Pi2)
                          (equiv/commute))
                        (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive implies/chain-implication)))))
      (implies/cond-distribute)
      (implies/combine (EQ+GFP=>GF x) (implies/cond-equal)))
     <- ({x} set2cond/U-inversion (S=>GF x) N1!<SP SP+N1=S (GFP x)
          (SP=>GFP x) (OF x) T (BL1 x) (GF=>EQ+GFP x) (EQ+GFP=>GF x))
     <- letRefTyping-helper/base/unique/L1L BL1 _ _ BL1P ([x] OF=O1 x)
     <- cxt-unique-objset/U-inversion S-NN-C N1!<SP SP+N1=S
       SP-NN-C O2 _ _ BL2 UA LEQ
     <- cxt`lookup-unique BL1P BL2 cxt`eq/ nat`eq/ CIE
     <- cxt-info-eq-inversion CIE O1=O2 TE
     <- ({x} object`eq-transitive (OF=O1 x) O1=O2 (OF=O2 x))
     <- not-member-nat+set2set-implies-disjoint SP+MF=M1 N1+MF=M2 N1!<SP M1^M2
     <- capset`disjoint-join-implies-equiv M1^M2 M1+M2=M M=>Pi
       Pi1 Pi2 M1=>Pi1 M2=>Pi2 (Pi<=>Pi1+Pi2:equiv Pi (combine Pi1 Pi2))
     <- set`not-member-add-increases-size-converse SZ N1!<SP SP+N1=S SZP
     <- letRefTyping-helper/base/unique/L1 _ SZP SP-NN-C SP+MF=M1 M1=>Pi1 ([x] SP=>GFP x)
       BF ([x] BU x) _ _ N+MF=MN ([x] MN=>Pf x) (GFP+Pi1=>Pf+Pf-Pi1)
     <- letRefTyping-helper/base/unique/L1L2 BL2 BF ([x] BU x) N1+MF=M2 M2=>Pi2 LEQ
       _ _ N+MF=M2P ([x] BF+M2P=>Pi2P x) ([x] IMP2 x)
     <- nat+set2set-unique N+MF=M2P N+MF=MN nat`eq/ set`eq/ M2P=MN
    <- ({x} capset2perm-equiv (BF+M2P=>Pi2P x) (MN=>Pf x) clsmap`eq/
         predmap`eq/ cxt`eq/ M2P=MN (Pi2P<=>Pf x))
    <- letRefTyping-helper/base/unique/L1L3 OF=O2 IMP2 IMP2P.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L1 _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N) (letRefTyping-helper/base/unique/L1 N _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L2L
  : forall* {CP1} {CP} {PF}
    forall {CP1=CP: predicate`eq CP1 CP}
    exists {IMP: {x} equiv (encumbered-fldperm x PF CP1) (encumbered-fldperm x PF CP)}
    true.

- : letRefTyping-helper/base/unique/L2L predicate`eq/ ([_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L2L _ _).
%total { } (letRefTyping-helper/base/unique/L2L _ _).


%theorem letRefTyping-helper/base/unique/L2L4
  : forall* {PF1} {PF} {CP1} {CP} {O} {Pi}
    forall {EQV: {x} permission`eq (PF1 x) (PF x)}
    {EQ: predicate`eq CP1 CP}
    exists {EQV: {x} equiv
                 (combine (encumbered-fldperm x PF1 CP1)
                   (unitperm (encumbered (encumbered-fldperm x PF1 CP1)
                               (combine (encumbered-fldperm O PF1 CP1) Pi))))
                 (combine (encumbered-fldperm x PF CP)
                   (unitperm (encumbered (encumbered-fldperm x PF CP)
                               (combine (encumbered-fldperm O PF1 CP1) Pi))))}
    true.

- : letRefTyping-helper/base/unique/L2L4
    ([_] permission`eq/) predicate`eq/ ([_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L2L4 _ _ _).
%total { } (letRefTyping-helper/base/unique/L2L4 _ _ _).


%theorem letRefTyping-helper/base/unique/L2
  : forall* {CM} {B} {NN} {C} {FM} {PM} {S} {CP} {FS} {Pi} {GF}
    forall {N} {SZ: set`size S (s N)}
    {CM-B-S: cxt-unique-objset B NN C S}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FM-DM: fldmap`domain FM FS}
    {ME: make-encumbered CM PM B S Pi}
    {S=>GF: {x} set2cond B x S (GF x)}
    exists {PF} {FM2P2: {x} fldset2perm PM x FM FS (PF x)}
    {IMP: {x} implies (combine (GF x) Pi)
          (combine (GF x)
            (combine (encumbered-fldperm x PF CP)
              (unitperm (encumbered (encumbered-fldperm x PF CP) Pi))))}
    true.

%theorem letRefTyping-helper/base/unique/L2/F
  : forall* {PM} {FM} {GF} {Pi} {CP} {FS}
    forall {V:void}
    exists {PF} {FM2P2: {x} fldset2perm PM x FM FS (PF x)}
    {IMP: {x} implies (combine (GF x) Pi)
          (combine (GF x)
            (combine (encumbered-fldperm x PF CP)
              (unitperm (encumbered (encumbered-fldperm x PF CP) Pi))))}
    true.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L2/F _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L2/F _ _ _ _).

- : letRefTyping-helper/base/unique/L2 _ _ CM-B-S _ _ _
    (make-encumbered/U _ (BL:cxt`lookup _ z _) _ _ _ _ _ A) _ _ KK1 KK2
    <- set`add-implies-member A MB
    <- cxt-unique-objset-no-zero CM-B-S MB V
    <- letRefTyping-helper/base/unique/L2/F V _ KK1 KK2.

- : letRefTyping-helper/base/unique/L2 z SZ
    (CM-B-S:cxt-unique-objset B NNx C S)
    (CML:clsmap`lookup CM C FM)
    (PML:predmap`lookup PM C CP)
    (FM-DM:fldmap`domain FM FS)
    (make-encumbered/U ME-SP (BL1:cxt`lookup B (s Nx) (cxt-info/ O1 (ty/ NNx1 A1 C1)))
      (CML1:clsmap`lookup CM C1 FM1)
      (PML1:predmap`lookup PM C1 CP1)
      (FM1-DM:fldmap`domain FM1 FS1)
      ([x] FS1=>Pi x)
      N!<SP (SP+N=S:set`add SP (s Nx) S))
    ([x] S=>GF x) _ ([x] (FS=>Pi x))
    ([x] implies/trans9
      (implies/combine (GIMP1 x)
        (implies/trans
          (implies/combine implies/reflexive (implies/equiv Pi2<=>E))
          (implies/equiv equiv/identity)))
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans4
          (implies/combine
            (implies/trans
              (implies/equiv (EQV x))
              (implies/nonlinear bimplies/objequal-symmetric))
            (implies/combine implies/reflexive implies/self-implication))
          (implies/objequal
              ([v] (combine (encumbered-fldperm v PF1 CP1)
                     (unitperm (encumbered (encumbered-fldperm v PF1 CP1)
                                 (encumbered-fldperm O1 PF1 CP1))))))
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine implies/reflexive
                (implies/equiv (equiv/symmetric Pi2<=>E)))
              (add-encumber)))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans3
          (implies/combine implies/nonlinear2empty
            (implies/trans3
              (implies/combine implies/reflexive
                (implies/trans (GIMP3 x) implies/duplicate))
              (implies/equiv
                (equiv/transitive equiv/commute (equiv/symmetric equiv/associate)))
              (implies/combine (GIMP4 x)
                (implies/trans3
                  (implies/combine (implies/contradiction)
                    (implies/trans
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine implies/reflexive implies/self-implication)))
                  (implies/objequal
                    ([v] (combine (encumbered-fldperm v PF1 CP1)
                           (unitperm (encumbered (encumbered-fldperm v PF1 CP1)
                                       (encumbered-fldperm O1 PF1 CP1))))))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine implies/reflexive
                        (implies/equiv (equiv/symmetric (Pi2<=>E))))
                      (add-encumber)))))))
          (implies/equiv (equiv/transitive equiv/commute equiv/identity))
          (implies/equiv equiv/commute)))
      (implies/cond-pull)
      (implies/combine implies/reflexive (GIMP2 x))
      (implies/combine
        (implies/combine (implies/equiv (EQV2 x))
          (implies/equiv-encumbered (EQV2 x) (equiv/reflexive)))
        (implies/reflexive))
      (implies/equiv equiv/commute))
    <- set`not-member-add-size-implies-empty N!<SP SP+N=S SZ (SP=E:set`eq SP set/0)
    <- ({x} set2cond/U-inversion (S=>GF x) N!<SP SP+N=S (GFP x) (SP=>GFP x)
         (O2 x) T2 (BL2 x) (GIMP1 x) (GIMP2 x))
    <- cxt-unique-objset/U-inversion CM-B-S N!<SP SP+N=S CM-B-SP O3 A3 NNx3 BL3 _ _
    <- cxt`lookup-unique BL1 BL3 cxt`eq/ nat`eq/ CI1=CI3
    <- cxt-info-eq-inversion CI1=CI3 O1=O3 T1=T3
    <- ty-eq-inversion T1=T3 NN1=NN3 A1=A3 C1=C
    <- clsmap`lookup-unique CML1 CML clsmap`eq/ C1=C FM1=FM
    <- predmap`lookup-unique PML1 PML predmap`eq/ C1=C CP1=CP
    <- fldmap`domain-unique FM1-DM FM-DM FM1=FM FS1=FS
    <- ({x} fldset2perm-respects-eq (FS1=>Pi x) predmap`eq/ object`eq/ FM1=FM
         FS1=FS permission`eq/ (FS=>Pi x))
    <- make-encumbered-equiv ME-SP make-encumbered/0 clsmap`eq/ predmap`eq/
      cxt`eq/ SP=E Pi2<=>E
    <- ({x} set2cond-implies (SP=>GFP x) set2cond/0 object`eq/ SP=E (GIMP3 x) (GIMP4 x))
    <- ({x} cxt`lookup-unique BL1 (BL2 x) cxt`eq/ nat`eq/ (CI1=CI2 x))
    <- ({x} cxt-info-eq-inversion (CI1=CI2 x) (O1=O2 x) TEQ)
    <- ({x} object`eq-symmetric (O1=O2 x) (O2=O1 x))
    <- ({x} permission-respects-object-eq
         ([y] (unitperm (nonlinear (objequal x y)))) (O2=O1 x) (EQV x))
    <- letRefTyping-helper/base/unique/L2L CP1=CP ([x] EQV2 x).

- : letRefTyping-helper/base/unique/L2 (s N) SZ
    (CM-B-S:cxt-unique-objset B NNx C S)
    (CML:clsmap`lookup CM C FM)
    (PML:predmap`lookup PM C CP)
    (FM-DM:fldmap`domain FM FS)
    (make-encumbered/U
      (ME-SP:make-encumbered CM PM B SP PiBP)
      (BL1:cxt`lookup B (s Nx) (cxt-info/ O1 (ty/ NNx1 A1 C1)))
      (CML1:clsmap`lookup CM C1 FM1)
      (PML1:predmap`lookup PM C1 CP1)
      (FM1-DM:fldmap`domain FM1 FS1)
      ([x] FS1=>Pi x)
      N!<SP (SP+N=S:set`add SP (s Nx) S))
    ([x] S=>GF x) _ ([x] (FS2=>Pi x))
    ([x] implies/trans8
      (implies/combine (GIMP1 x) implies/reflexive)
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans8
          (implies/combine
            (implies/trans
              (implies/equiv (EQV x))
              (implies/nonlinear bimplies/objequal-symmetric))
            (implies/equiv equiv/identity))
          (implies/combine (implies/reflexive)
            (implies/combine
              (implies/trans
                (implies/equiv (equiv/symmetric equiv/identity))
                (implies/combine implies/reflexive (implies/self-implication)))
              (implies/reflexive)))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/objequal
              ([v] (combine (encumbered-fldperm v PF1 CP1)
                     (unitperm (encumbered (encumbered-fldperm v PF1 CP1)
                                 (encumbered-fldperm O1 PF1 CP1))))))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive add-encumber)
          (implies/equiv (EQV3 x))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans5
          (implies/combine implies/nonlinear2empty
            (implies/trans
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive
                (implies/trans (implies/equiv equiv/commute) (IMPP x)))))
          (implies/equiv (equiv/transitive equiv/commute equiv/identity))
          (implies/equiv (equiv/roll2))
          (implies/combine (implies/reflexive)
            (implies/trans
              (implies/equiv equiv/roll2)
              (implies/combine (implies/reflexive)
                (implies/trans3
                  (implies/equiv equiv/commute)
                  (add-encumber)
                  (implies/equiv-encumbered
                    (equiv/reflexive) (equiv/commute))))))
          (implies/equiv equiv/commute)))
      (implies/cond-pull)
      (implies/combine (implies/reflexive) (GIMP2 x))
      (implies/equiv equiv/commute))
    <- ({x} set2cond/U-inversion (S=>GF x) N!<SP SP+N=S (GFP x) (SP=>GFP x)
         (O2 x) T2 (BL2 x) (GIMP1 x) (GIMP2 x))
    <- cxt-unique-objset/U-inversion CM-B-S N!<SP SP+N=S CM-B-SP O3 A3 NNx3 BL3 _ _
    <- cxt`lookup-unique BL1 BL3 cxt`eq/ nat`eq/ CI1=CI3
    <- cxt-info-eq-inversion CI1=CI3 O1=O3 T1=T3
    <- ty-eq-inversion T1=T3 NN1=NN3 A1=A3 C1=C
    <- clsmap`lookup-unique CML1 CML clsmap`eq/ C1=C FM1=FM
    <- predmap`lookup-unique PML1 PML predmap`eq/ C1=C CP1=CP
    <- fldmap`domain-unique FM1-DM FM-DM FM1=FM FS1=FS
    <- ({x} fldset2perm-respects-eq (FS1=>Pi x) predmap`eq/ object`eq/ FM1=FM
         FS1=FS permission`eq/ (FS=>Pi x))
    <- ({x} cxt`lookup-unique BL1 (BL2 x) cxt`eq/ nat`eq/ (CI1=CI2 x))
    <- ({x} cxt-info-eq-inversion (CI1=CI2 x) (O1=O2 x) TE)
    <- ({x} object`eq-symmetric (O1=O2 x) (O2=O1 x))
    <- ({x} permission-respects-object-eq
         ([y] (unitperm (nonlinear (objequal x y)))) (O2=O1 x) (EQV x))
    <- set`not-member-add-increases-size-converse SZ N!<SP SP+N=S SZP
    <- letRefTyping-helper/base/unique/L2 N SZP CM-B-SP CML PML FM-DM ME-SP SP=>GFP
      _ ([x] (FS2=>Pi x)) IMPP
    <- set`eq-transitive FS1=FS set`eq/ FS1=FS2
    <- ({x} fldset2perm-unique (FS1=>Pi x) (FS2=>Pi x) predmap`eq/
         object`eq/ FM1=FM FS1=FS2 (PEQ x))
    <- ({x} permission`eq-implies-equiv (PEQ x) (EQV2 x)) % TODO: remove this
    <- letRefTyping-helper/base/unique/L2L4 PEQ CP1=CP ([x] EQV3 x).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L2 _ _ _ _ _ _ _ _ _ _ _).
%total (ME) (letRefTyping-helper/base/unique/L2 _ _ _ _ _ _ ME _ _ _ _).


%theorem letRefTyping-helper/base/unique/L2*
  : forall* {CM} {B} {NN} {C} {FM} {PM} {S} {CP} {FS} {Pi} {GF} {PF}
    forall {N} {SZ: set`size S (s N)}
    {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {CM-B-S: cxt-unique-objset B NN C S}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FM-DM: fldmap`domain FM FS}
    {ME: make-encumbered CM PM B S Pi}
    {S=>GF: {x} set2cond B x S (GF x)}
    exists {PF2} {T2PF2: ty2perm3 CM PM (ty/ NN annot/unique C) PF2}
    {PF3} {FM2P2: {x} fldset2perm PM x FM FS (PF3 x)}
    {IMP: {x} implies (combine (PF x) (combine (GF x) Pi))
          (combine (GF x)
            (combine (PF2 x)
              (unitperm (encumbered (encumbered-fldperm x PF3 CP) Pi))))}
    true.

- : letRefTyping-helper/base/unique/L2* _ SZ T2PF
    (CM-B-S:cxt-unique-objset B NNx C S)
    (CML:clsmap`lookup CM C FM)
    (PML:predmap`lookup PM C CP)
    (FM-DM:fldmap`domain FM FS)
    ME ([x] S=>GF x) _ (ty2perm3/unique CML PML FM-DM ([x] FM=>PF x) T2PF)
    _ FM=>PF
    ([x] implies/trans3
      (implies/combine (implies/reflexive) (IMP x))
      (implies/equiv equiv/roll2)
      (implies/combine implies/reflexive (implies/equiv equiv/associate)))
    <- letRefTyping-helper/base/unique/L2 _ SZ CM-B-S CML PML FM-DM ME S=>GF
      _ ([x] FM=>PF x) ([x] IMP x).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L2* _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L2* _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L2**
  : forall* {CM} {B} {NN} {C} {FM} {PM} {S} {CP} {FS} {PiS} {GF} {PF}
    forall {N} {SZ: set`size S (s N)}
    {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {CM-B-S: cxt-unique-objset B NN C S}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FM-DM: fldmap`domain FM FS}
    {ME: make-encumbered CM PM B S PiS}
    {S=>GF: {x} set2cond B x S (GF x)}
    exists {PF2} {FM2P: {x} fldset2perm PM x FM FS (PF2 x)}
    {IMP: {x} implies (combine (PF x) (combine (GF x) PiS))
          (combine (GF x)
            (combine
              (combine (PF x)
                (unitperm (conditional (objequal x null) empty
                  (unitperm (encumbered (PF2 x) (combine (allperm x) (one-predcall CP x)))))))
              (unitperm (encumbered (encumbered-fldperm x PF2 CP) PiS))))}
    true.

- : letRefTyping-helper/base/unique/L2** _ SZ T2PF
    (CM-B-S:cxt-unique-objset B NNx C S)
    (CML:clsmap`lookup CM C FM)
    (PML:predmap`lookup PM C CP)
    (FM-DM:fldmap`domain FM FS)
    ME ([x] S=>GF x) _ FS=>PF
    ([x] implies/trans3
      (implies/combine (implies/reflexive) (IMP x))
      (implies/equiv equiv/roll2)
      (implies/combine implies/reflexive (implies/equiv equiv/associate)))
    <- letRefTyping-helper/base/unique/L2 _ SZ CM-B-S CML PML FM-DM ME S=>GF
      _ ([x] (FS=>PF x)) ([x] IMP x).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L2** _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L2** _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L3/L1
  : forall* {Pi1: object -> permission} {Pi2}
    forall {F: void}
    exists {EQV: {x} equiv (Pi1 x) (Pi2 x)}
    true.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L3/L1 _ _).
%total { } (letRefTyping-helper/base/unique/L3/L1 _ _).


%%% This lemma says that for `fldset2perm` if `FM` contains some entry
%%% whose key is not in `FS`, then after removing the entry, we can still
%%% get the relation.

%theorem letRefTyping-helper/base/unique/L3/L2/F
  : forall* {PM} {FM} {FS} {Pf}
    forall {F: void}
    exists {FM2P: {x} fldset2perm PM x FM FS (Pf x)}
    true.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L3/L2/F _ _).
%total { } (letRefTyping-helper/base/unique/L3/L2/F _ _).


%theorem letRefTyping-helper/base/unique/L3/L2
  : forall* {PM} {FM} {FM'} {FS} {Pf} {F} {T}
    forall {FM2P: {x} fldset2perm PM x FM FS (Pf x)}
    {F!<FS: set`not-member FS F}
    {F!<FM': fldmap`fresh FM' F}
    {FM'+F=FM: fldmap`update FM' F T FM}
    exists {FM2P': {x} fldset2perm PM x FM' FS (Pf x)}
    true.

- : letRefTyping-helper/base/unique/L3/L2 ([_] fldset2perm/0) _ _ _ ([_] fldset2perm/0).

%theorem letRefTyping-helper/base/unique/L3/L2/L
  : forall* {PM} {FM} {FMP} {Pf} {F} {FP} {T} {TP} {FSP} {PF} {FSQ}
    forall {FM2P: {x} fldset2perm PM x FM FSP (Pf x)}
    {SH: set`shift FP FSQ FSP}
    {FML: fldmap`lookup FM FP TP}
    {T2PF: {x} ty2perm PM TP ([v] PF x v)}
    {NM: set`not-member (set/+ FP FSQ) F}
    {FM-F: fldmap`fresh FMP F}
    {FM-U: fldmap`update FMP F T FM}
    {B} {EQ?: nat`eq? FP F B}
    exists {FM2P: {x} fldset2perm PM x FMP (set/+ FP FSQ)
      (combine (unitperm (precise-exists x FP ([v] PF x v))) (Pf x))}
    true.

- : letRefTyping-helper/base/unique/L3/L2/L _ _ _ _ NM _ _ _ nat`eq?/yes FM2P
    <- set`member-not-member-contradiction (set`lookup/= nat`eq/) NM V
    <- letRefTyping-helper/base/unique/L3/L2/F V FM2P.

- : letRefTyping-helper/base/unique/L3/L2/L FM2P (SH:set`shift FP FSQ FSP)
    FML T2PF NM FM-F FM-U _ (nat`eq?/no (FP<>F:nat`ne FP F))
    ([x] fldset2perm/+ SH (FM2PP x) FMLP (T2PF x))
    <- set`shift-implies-update SH U
    <- set`update-preserves-not-member-converse NM U NM1
    <- letRefTyping-helper/base/unique/L3/L2 FM2P NM1 FM-F FM-U FM2PP
    <- fldmap`update-preserves-lookup-converse FML FM-U FP<>F FMLP.

- : letRefTyping-helper/base/unique/L3/L2
    ([x] fldset2perm/+ SH (FM2P x) FML (T2PF x)) NM F U FM2PP
    <- nat`eq?-total EQ?
    <- letRefTyping-helper/base/unique/L3/L2/L FM2P SH FML T2PF NM F U _ EQ? FM2PP.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L3/L2 _ _ _ _ _)
  (letRefTyping-helper/base/unique/L3/L2/L _ _ _ _ _ _ _ _ _ _).
%total (A B) (letRefTyping-helper/base/unique/L3/L2 A _ _ _ _)
  (letRefTyping-helper/base/unique/L3/L2/L B _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L3/L3
  : forall* {FM} {N} {T1} {T2} {FM'}
    forall {U: fldmap`update FM N T1 (fldmap/+ N T1 FM')}
    {EQ: ty`eq T1 T2}
    exists {U: fldmap`update FM N T2 (fldmap/+ N T2 FM')}
    true.

- : letRefTyping-helper/base/unique/L3/L3 U ty`eq/ U.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L3/L3 _ _ _).
%total { } (letRefTyping-helper/base/unique/L3/L3 _ _ _).


%theorem letRefTyping-helper/base/unique/L3/L4
  : forall* {PF1} {PF2} {F}
    forall {EQ: {x}{x1} permission`eq (PF1 x x1) (PF2 x1)}
    exists {EQV: {x} equiv (unitperm (precise-exists x F ([v] PF1 x v)))
                 (unitperm (precise-exists x F ([v] PF2 v)))}
    true.

- : letRefTyping-helper/base/unique/L3/L4 ([_][_] permission`eq/) ([_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L3/L4 _ _).
%total { } (letRefTyping-helper/base/unique/L3/L4 _ _).


%theorem letRefTyping-helper/base/unique/L3/L5
  : forall* {PF1: object -> permission} {PF2} {F}
    forall {EQ: {o} permission`eq (PF1 o) (PF2 o)}
    exists {EQV: {x} equiv (unitperm (precise-exists x F ([o] PF1 o)))
                 (unitperm (precise-exists x F ([o] PF2 o)))}
    true.

- : letRefTyping-helper/base/unique/L3/L5 ([_] permission`eq/) ([_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L3/L5 _ _).
%total { } (letRefTyping-helper/base/unique/L3/L5 _ _).


%theorem letRefTyping-helper/base/unique/L3/L6
  : forall* {CM} {PM} {FM} {CJ} {FS} {Pf}
    forall {FM-DM: fldmap`domain FM FS}
    {FM2G: fldmap2conj CM PM FM ([x] CJ x) PM}
    {FM2P: {x} fldset2perm PM x FM FS (Pf x)}
    exists {IMP: {x} equiv (CJ x) (Pf x)}
    true.

- : letRefTyping-helper/base/unique/L3/L6 fldmap`domain/0
    fldmap2conj/0 ([_] fldset2perm/0) ([_] equiv/reflexive).

- : letRefTyping-helper/base/unique/L3/L6 (fldmap`domain/+ FM-DM)
    (fldmap2conj/in FMP2CJ NN2P A2P (FM-SH:fldmap`shift F FM FMP)
      (PML:predmap`lookup PMout C _))
    ([x] fldset2perm/+ (FS-SH:set`shift F FS FSP) (FM2P x) FML (T2PFP x))
    ([x] equiv/transitive3
      (equiv/combine (EQV2 x) (BIMPP x))
      (equiv/combine (equiv/symmetric (EQV3 x)) (equiv/reflexive))
      (equiv/symmetric (equiv/reflexive)))
    <- fldmap`shift-preserves-domain* FM-DM FM-SH FS-SH FMP-DM
    <- ty2perm-no-var ([x] T2PFP x) PF EQ T2PF
    <- letRefTyping-helper/base/unique/L3/L4 EQ EQV3
    <- set`shift-implies-not-member FS-SH NM
    <- fldmap`shift-implies-fresh FM-SH FM-F
    <- fldmap`shift-implies-update FM-SH FM-U'
    <- fldmap`lookup-unique (fldmap`lookup/= nat`eq/) FML fldmap`eq/ nat`eq/ TE
    <- ty`eq-symmetric TE TE2
    <- letRefTyping-helper/base/unique/L3/L3 FM-U' TE2 FM-U
    <- letRefTyping-helper/base/unique/L3/L2 FM2P NM FM-F FM-U FM2PP
    <- letRefTyping-helper/base/unique/L3/L6 FMP-DM FMP2CJ FM2PP ([x] BIMPP x)
    <- ty2perm-deterministic (ty2perm/ PML NN2P A2P) T2PF predmap`eq/ TE PEQ
    <- letRefTyping-helper/base/unique/L3/L5 PEQ EQV2.

- : letRefTyping-helper/base/unique/L3/L6 (fldmap`domain/+ FM-DM)
    (fldmap2conj/out (FM2J:fldmap2conj _ _ _ _ PM)
      (FM2JF:{p:clspred} fldmap2conj _ (PMF1 p) _ ([o:object] CJ p o) (PMF2 p))
      U _ _ _ _ (F:predmap`fresh PM C)) FM2P EQV
    <- predmap`size-total SZ0
    <- ({p} predmap`fresh-update-increases-size SZ0 F (U p) (SZ1 p))
    <- ({p} fldmap2conj-implies-predmap-leq (FM2JF p) (LEQ1 p))
    <- fldmap2conj-implies-predmap-leq FM2J LEQ2
    <- predmap`leq-transitive (LEQ1 (conj2pred CJ)) LEQ2 LEQ
    <- predmap`leq-implies-size-le LEQ (SZ1 (conj2pred CJ)) SZ0 SZ-LE
    <- ge-self-succ-contradiction SZ-LE V
    <- letRefTyping-helper/base/unique/L3/L1 V EQV.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L3/L6 _ _ _ _).
%total (FM2G) (letRefTyping-helper/base/unique/L3/L6 _ FM2G _ _).


%theorem letRefTyping-helper/base/unique/L3
  : forall* {CM} {PM} {FM} {CJ} {FS} {Pf}
    forall {DM: fldmap`domain FM FS}
    {FM2G: fldmap2conj CM PM FM ([x] CJ x) PM}
    {FM2P: {x} fldset2perm PM x FM FS (Pf x)}
    exists {IMP: {x} bimplies true (nested (CJ x) x all) (nested (Pf x) x all)}
    true.

- : letRefTyping-helper/base/unique/L3 DM FM2G FM2P ([x] bimplies/nested/eq (EQV x))
    <- letRefTyping-helper/base/unique/L3/L6 DM FM2G FM2P EQV.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L3 _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L3 _ _ _ _).



%{
This relation specifies the format for the encumbered permissions, after
checking "x = e1". Those permissions should be in certain format, and be reused
after do checking the let body. We then should be able to get the permissions for
e1 back.
}%

unique-encumbered-perm-format : clsmap -> predmap -> cxt -> (object -> cxt) ->
    set -> nonnull -> nat -> set -> set -> set ->
    (object -> object -> permission -> permission) -> type.

unique-encumbered-perm-format/unique :
    set`size S (s N1) ->
    set`size M1 (s N2) ->
    ({x} set2cond B0 x S (GF x)) ->
    clsmap`lookup CM C FM ->
    predmap`lookup PM C CP ->
    annot2perm annot/unique AF ->
    nn2perm NN AF PF ->
    capset2perm CM PM B0 M1 PiM1 ->
    capset2perm CM PM B0 M2 PiM2 ->
    ({x} capset2perm CM PM (B1 x) M3 (PiM3 x)) ->
    make-encumbered CM PM B0 S PiS ->
    fldmap`domain FM FS ->
    ({x} fldset2perm PM x FM FS (FPF x)) ->
  unique-encumbered-perm-format CM PM B0 B1 S NN C M1 M2 M3
    ([x][o][_] (unitperm (conditional (objequal x o)
      (combine (combine (unitperm (encumbered (PF CP o) PiM1)) PiM2) PiS)
      (combine (GF x)
        (combine (unitperm (encumbered (PiM3 x) PiM2))
          (combine
            (unitperm
              (encumbered
                (unitperm
                  (conditional (objequal x null) empty
                    (unitperm (encumbered (FPF x) (combine (allperm x) (one-predcall CP x))))))
                PiS))
            (combine (PF CP o)
              (unitperm (encumbered (PF CP o) PiM1))))))))).

unique-encumbered-perm-format/unique+fresh :
    set`size S (s N1) ->
    ({x} set2cond B0 x S (GF x)) ->
    clsmap`lookup CM C FM ->
    predmap`lookup PM C CP ->
    annot2perm annot/unique AF ->
    nn2perm NN AF PF ->
    capset2perm CM PM B0 M1 PiM1 ->
    capset2perm CM PM B0 M2 PiM2 ->
    ({x} capset2perm CM PM (B1 x) M3 (PiM3 x)) ->
    make-encumbered CM PM B0 S PiS ->
    fldmap`domain FM FS ->
    ({x} fldset2perm PM x FM FS (FPF x)) ->
  unique-encumbered-perm-format CM PM B0 B1 S NN C M1 M2 M3
    ([x][o][p] (unitperm (conditional (objequal x o)
      (combine (combine (unitperm (encumbered (PF CP o) (combine PiM1 p))) PiM2) PiS)
      (combine (GF x)
        (combine (unitperm (encumbered (PiM3 x) PiM2))
          (combine
            (unitperm
              (encumbered
                (unitperm
                  (conditional (objequal x null) empty
                    (unitperm (encumbered (FPF x) (combine (allperm x) (one-predcall CP x))))))
                PiS))
            (combine (PF CP o)
              (unitperm (encumbered (PF CP o) (combine PiM1 p)))))))))).

unique-encumbered-perm-format/unique/2
  : set`size S (s N1) ->
    set`size M1 z ->
    ({x} set2cond B0 x S (GF x)) ->
    clsmap`lookup CM C FM ->
    predmap`lookup PM C CP ->
    annot2perm annot/borrow AF ->
    nn2perm NN AF PF ->
    capset2perm CM PM B0 M2 PiM2 ->
    ({x} capset2perm CM PM (B1 x) M3 (PiM3 x)) ->
    make-encumbered CM PM B0 S PiS ->
    fldmap`domain FM FS ->
    ({x} fldset2perm PM x FM FS (FPF x)) ->
    unique-encumbered-perm-format CM PM B0 B1 S NN C M1 M2 M3
  ([x][_][_] combine
      (combine
        (unitperm
          (encumbered
            (unitperm
              (conditional (objequal x null) empty
                (unitperm
                  (encumbered (FPF x) (combine (allperm x) (one-predcall CP x))))))
            PiS))
        (combine (GF x)
          (unitperm (encumbered (PiM3 x) PiM2))))
      (PF CP x)).

unique-encumbered-perm-format/borrow
  : set`size S z ->
    set`size M1 (s _) ->
    ty2perm PM (ty/ NN annot/unique C) PF ->
    capset2perm CM PM B0 M1 PiM1 ->
    unique-encumbered-perm-format CM PM B0 _ S NN C M1 set/0 _
      ([x][o][_] unitperm (encumbered (PF x) PiM1)).

%{
unique-encumbered-perm-format/fresh
  : set`size S z ->
    set`size M1 z ->
    unique-encumbered-perm-format CM PM B0 _ S NN C M1 set/0 _
([x][o][p] unitperm (encumbered (PF x) (combine PiM1).
}%

unique-encumbered-perm-format/fresh
  : set`size S z ->
    ty2perm PM (ty/ NN annot/unique C) PF ->
    capset2perm CM PM B0 M1 PiM1 ->
  unique-encumbered-perm-format CM PM B0 _ S NN C M1 set/0 _
      ([x][_][p] unitperm (encumbered (PF x) (combine PiM1 p))).


%theorem letRefTyping-helper/base/unique/L4L1L1
  : forall {CP}
    exists {IMP: {x} implies
                 (combine
                   (unitperm
                     (nonlinear (neg (objequal x null))))
                   (combine (allperm x) (one-predcall CP x)))
                 (unitperm (conditional (objequal x null) empty
                             (combine (allperm x) (one-predcall CP x))))}
    true.

- : letRefTyping-helper/base/unique/L4L1L1 _ ([_] implies/cond-intro-neg).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L4L1L1 _ _).
%total { } (letRefTyping-helper/base/unique/L4L1L1 _ _).


%%% This lemma says if we have permissions for a unique object, then we
%%% can split it into two parts: all the field permissions of the unique
%%% object, and the encumbered permission.

%theorem letRefTyping-helper/base/unique/L4L1
  : forall* {CM} {FM} {PM} {C} {FS} {NN} {PF}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`domain FM FS}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) ([x] PF x)}
    exists {PF2} {PF3}
    {T2PF: ty2perm3 CM PM (ty/ NN annot/unique C) ([x] PF2 x)}
    {M2P: {x} fldset2perm PM x FM FS (PF3 x)}
    {IMP: {x} implies (PF x) (combine (PF2 x)
       (unitperm (conditional (objequal x null) empty (PF3 x))))}
    true.

- : letRefTyping-helper/base/unique/L4L1 CM-CM CM2PM CML (FM-DM:fldmap`domain FM FS)
    (ty2perm/ PML nn2perm/yes annot2perm/unique) _ _
    (ty2perm3/unique CML PML FM-DM ([x] (FS=>PF x))
      (ty2perm/ PML nn2perm/yes annot2perm/borrow)) FS=>PF
    ([x] implies/trans8
      (implies/trans3
        (implies/combine implies/duplicate implies/cond-neg)
        (implies/symmetric-associate)
        (implies/combine implies/reflexive implies/cond-elim))
      (implies/combine (implies/duplicate)
        (implies/combine (implies/reflexive) (implies/duplicate)))
      (implies/equiv
        (equiv/transitive4
          (equiv/combine equiv/reflexive equiv/associate)
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive equiv/roll2)
          (equiv/associate)))
      (implies/combine
        (implies/trans5
          (IMP x)
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/equiv
              (equiv/symmetric equiv/identity))
            (implies/trans7
              (implies/combine (implies/reflexive)
                (implies/trans3
                  (implies/nonlinear bimplies/conj-duplicate)
                  (implies/conj2combine)
                  (implies/combine
                    (implies/trans
                      (implies/equiv (EQV x))
                      (implies/nonlinear
                        (bimplies/trans4
                          (bimplies/predcall/Y/inline)
                          (bimplies/predcall/+/inline x)
                          (bimplies/predcall/0/inline)
                          (BIMP x))))
                    (implies/reflexive))))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans
                  (implies/equiv equiv/commute)
                  (implies/carve))
                (implies/reflexive))
              (implies/equiv equiv/commute)
              (implies/combine (implies/duplicate) (implies/reflexive))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/trans
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/equiv (equiv/commute)))
                (implies/reflexive))))
          (implies/cond-distribute)
          (implies/combine (implies/reflexive)
            (implies/trans3
              (implies/cond-gen-inner)
              (implies/cond-inner
                (bimplies/reflexive)
                (bimplies/reflexive)
                (implies/combine implies/nonlinear2empty implies/reflexive)
                (implies/trans
                  (implies/combine
                    (implies/nonlinear2empty)
                    (implies/trans3
                      (implies/equiv equiv/commute)
                      (implies/equiv (equiv/symmetric equiv/associate))
                      (implies/combine implies/reflexive add-encumber)))
                  (implies/equiv (equiv/transitive equiv/commute equiv/identity))))
              (implies/cond-distribute)))
          (implies/equiv
            (equiv/transitive
              (equiv/combine equiv/reflexive equiv/commute)
              (equiv/associate))))
        (implies/trans
          (implies/combine implies/reflexive implies/nonlinear2empty)
          (implies/equiv equiv/identity)))
      (implies/equiv
        (equiv/transitive3
          (equiv/commute)
          (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))
          (equiv/associate)))
      (implies/combine
        (implies/trans3
          (implies/combine implies/duplicate implies/cond-neg)
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive implies/cond-elim))
        (implies/reflexive))
      (implies/equiv equiv/associate)
      (implies/combine
        (implies/combine
          (implies/trans3
            (implies/combine implies/duplicate implies/reflexive)
            (implies/symmetric-associate)
            (implies/combine implies/reflexive implies/cond-intro-neg))
          implies/reflexive)
        (implies/reflexive)))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- set`leq-reflexive _ FS<=FS
     <- ({x:object} fldset2perm-total CM-CM CM2PM CML FM-DM FS<=FS _ (FS=>PF x))
     <- clsmap-predmap-implies-lookup-format CM-PM PML _ PMLP ([x] PEQ x)
     <- ({x} permission`eq-implies-equiv (PEQ x) (EQV x))
     <- clsmap2predmap-implies-fldmap2conj CM2PM PMLP CML FM=>CJ
     <- letRefTyping-helper/base/unique/L3 FM-DM FM=>CJ FS=>PF ([x] BIMP x)
     <- letRefTyping-helper/base/unique/L4L1L1 _ IMP.

- : {FS=>PF: {x} fldset2perm PM x FM FS (PF3 x)}
    letRefTyping-helper/base/unique/L4L1 CM-CM CM2PM CML (FM-DM:fldmap`domain FM FS)
    (ty2perm/ PML nn2perm/may annot2perm/unique) _ _
    (ty2perm3/unique CML PML FM-DM ([x] (FS=>PF x))
      (ty2perm/ PML nn2perm/may annot2perm/borrow)) FS=>PF
    ([x] implies/trans4
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv
          (equiv/symmetric equiv/identity))
        (implies/trans7
          (implies/combine (implies/reflexive)
            (implies/trans3
              (implies/nonlinear bimplies/conj-duplicate)
              (implies/conj2combine)
              (implies/combine
                (implies/trans
                  (implies/equiv (EQV x))
                  (implies/nonlinear
                    (bimplies/trans4
                      (bimplies/predcall/Y/inline)
                      (bimplies/predcall/+/inline x)
                      (bimplies/predcall/0/inline)
                      (BIMP x))))
                (implies/reflexive))))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/equiv equiv/commute)
              (implies/carve))
            (implies/reflexive))
          (implies/equiv equiv/commute)
          (implies/combine (implies/duplicate) (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/trans
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/equiv (equiv/commute)))
            (implies/reflexive))))
      (implies/cond-distribute)
      (implies/combine (implies/reflexive)
        (implies/trans3
          (implies/cond-gen-inner)
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/combine implies/nonlinear2empty implies/reflexive)
            (implies/trans
              (implies/combine
                (implies/nonlinear2empty)
                (implies/trans3
                  (implies/equiv equiv/commute)
                  (implies/equiv (equiv/symmetric equiv/associate))
                  (implies/combine implies/reflexive add-encumber)))
              (implies/equiv (equiv/transitive equiv/commute equiv/identity))))
          (implies/cond-distribute)))
      (implies/equiv
        (equiv/transitive
          (equiv/combine equiv/reflexive equiv/commute)
          (equiv/associate))))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- set`leq-reflexive _ FS<=FS
     <- ({x:object} fldset2perm-total CM-CM CM2PM CML FM-DM FS<=FS _ (FS=>PF x))
     <- clsmap-predmap-implies-lookup-format CM-PM PML _ PMLP ([x] PEQ x)
     <- ({x} permission`eq-implies-equiv (PEQ x) (EQV x))
     <- clsmap2predmap-implies-fldmap2conj CM2PM PMLP CML FM=>CJ
     <- letRefTyping-helper/base/unique/L3 FM-DM FM=>CJ FS=>PF ([x] BIMP x).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L4L1 _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L4L1 _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L4L1*
  : forall* {CM} {FM} {PM} {C} {FS} {NN} {PF} {PF'} {PF3} {CP}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FML: fldmap`domain FM FS}
    {M2P: {x} fldset2perm PM x FM FS (PF3 x)}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) ([x] PF x)}
    {T2PF-B: ty2perm PM (ty/ NN annot/borrow C) ([x] PF' x)}
    exists
    {IMP: {x} implies (PF x)
          (combine
            (combine (PF' x)
              (unitperm (conditional (objequal x null) empty
                (unitperm (encumbered (PF3 x) (combine (allperm x) (one-predcall CP x)))))))
            (unitperm (conditional (objequal x null) empty (PF3 x))))}
    true.

%theorem letRefTyping-helper/base/unique/L4L1*L
  : forall* {X6} {X7} {X2} {X3} {X4} {CP'} {CP}
    forall {PiE: {x} permission`eq (X2 x) (X3 x)}
    {PiE2: {x} permission`eq (X6 x) (X7 x)}
    {PiE3: {x} permission`eq (X4 x) (X3 x)}
    {CPE: predicate`eq CP' CP}
    exists
    {IMP3:{x:gterm objectk}
           implies
           (combine
             (combine (X6 x)
               (unitperm
                 (conditional (objequal x null) empty
                   (unitperm
                     (encumbered (X2 x)
                       (combine (allperm x)
                         (one-predcall CP' x)))))))
             (unitperm (conditional (objequal x null) empty (X4 x))))
           (combine
             (combine (X7 x)
               (unitperm
                 (conditional (objequal x null) empty
                   (unitperm
                     (encumbered (X3 x)
                       (combine (allperm x)
                         (one-predcall CP x)))))))
             (unitperm (conditional (objequal x null) empty (X3 x))))}
    true.

- : letRefTyping-helper/base/unique/L4L1*L ([_] permission`eq/) ([_] permission`eq/)
    ([_] permission`eq/) predicate`eq/ ([_] implies/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L4L1*L _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L4L1*L _ _ _ _ _).


- : letRefTyping-helper/base/unique/L4L1* CM-CM CM2PM CML PML DM FS=>PF T2PF T2PFb
    ([x] implies/trans (IMP2 x) (IMP3 x))
    <- letRefTyping-helper/base/unique/L4L1 CM-CM CM2PM CML DM T2PF _ _
      (ty2perm3/unique CML' PML' DM' ([x] (FS=>PF' x)) T2PFb') FS=>PF'' IMP2
    <- clsmap`lookup-unique CML' CML clsmap`eq/ nat`eq/ (FME:fldmap`eq FM' FM)
    <- predmap`lookup-unique PML' PML predmap`eq/ nat`eq/ (CPE: predicate`eq CP' CP)
    <- fldmap`domain-unique DM' DM FME (FSE:set`eq FS' FS)
    <- ({x} fldset2perm-unique (FS=>PF' x) (FS=>PF x) predmap`eq/ object`eq/
         FME FSE (PiE x))
    <- ty2perm-deterministic T2PFb' T2PFb predmap`eq/ ty`eq/ ([x] PiE2 x)
    <- ({x} fldset2perm-unique (FS=>PF'' x) (FS=>PF x) predmap`eq/ object`eq/
         fldmap`eq/ set`eq/ (PiE3 x))
    <- letRefTyping-helper/base/unique/L4L1*L PiE PiE2 PiE3 CPE IMP3.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L4L1* _ _ _ _ _ _ _  _ _).
%total { } (letRefTyping-helper/base/unique/L4L1* _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L4L1**
  : forall* {CM} {FM} {PM} {C} {FS} {NN} {CP} {PF}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FML: fldmap`domain FM FS}
    {T2PF: ty2perm PM (ty/ NN annot/unique C) ([x] PF x)}
    exists {PF3} {PF'}
    {M2P: {x} fldset2perm PM x FM FS (PF3 x)}
    {T2PF-B: ty2perm PM (ty/ NN annot/borrow C) ([x] PF' x)}
    {IMP: {x} implies (PF x)
          (combine
            (combine (PF' x)
              (unitperm (conditional (objequal x null) empty
                (unitperm (encumbered (PF3 x) (combine (allperm x) (one-predcall CP x)))))))
            (unitperm (conditional (objequal x null) empty (PF3 x))))}
    true.

- : letRefTyping-helper/base/unique/L4L1** CM-CM CM2PM CML PML DM
    (ty2perm/ PML1 NN2P annot2perm/unique) _ _ M2P (ty2perm/ PML1 NN2P2 annot2perm/borrow) IMP
    <- set`leq-reflexive _ LE
    <- ({x} fldset2perm-total CM-CM CM2PM CML DM LE _ (M2P x))
    <- nn2perm-total NN2P2
    <- letRefTyping-helper/base/unique/L4L1* CM-CM CM2PM CML PML DM M2P
      (ty2perm/ PML1 NN2P annot2perm/unique)
      (ty2perm/ PML1 NN2P2 annot2perm/borrow) IMP.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L4L1** _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L4L1** _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L4L2
  : forall* {CM} {PM} {FM} {PF1} {NN} {B:object -> cxt} {N} {C} {FS} {A}
    forall {CML: clsmap`lookup CM C FM}
    {M2P: {x} fldset2perm PM x FM FS (PF1 x)}
    {BL: {x} cxt`lookup (B x) (s N) (cxt-info/ x (ty/ NN A C))}
    exists {M} {PF3} {M=>PF: nat+set2set (s N) FS M}
    {M=>PF3: {x} capset2perm CM PM (B x) M (PF3 x)}
    {PF2=>PF3: {x} implies
               (unitperm (conditional
                           (objequal x null) (empty) (PF1 x))) (PF3 x)}
    {PF3=>PF2: {x} implies (PF3 x)
               (unitperm (conditional
                           (objequal x null) (empty) (PF1 x)))}
    true.

- : letRefTyping-helper/base/unique/L4L2 _ ([_] fldset2perm/0) _ _ _
    nat+set2set/0 ([_] capset2perm/0)
    ([_] implies/cond-equal)
    ([_] implies/cond-equal-objequal).

- : letRefTyping-helper/base/unique/L4L2 CML
    ([x] fldset2perm/+ SH (SP=>PFP x) FML (T2PF x)) ([x] BL x) _ _
    (nat+set2set/U N+SP=>MP (N+F=>K:pair2nat (pair/ (s N) F) (s K))
      F!<SP SP+F=S MP+K=M)
    ([x] capset2perm/U (MP=>PF3P x) N+F=>K (BL x)
      (create-fldperm/ CML FML (T2PF x)) K!<MP MP+K=M)
    ([x] implies/trans3
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/reflexive))
      (implies/cond-distribute)
      (implies/combine implies/reflexive (IMPP1 x)))
    ([x] implies/trans3
      (implies/combine implies/reflexive (IMPP2 x))
      (implies/cond-factor)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/identity)
        (implies/reflexive)))
    <- set`shift-implies-not-member SH F!<SP
    <- set`shift-implies-update SH SP+F=S
    <- letRefTyping-helper/base/unique/L4L2 CML SP=>PFP
      BL _ _ N+SP=>MP MP=>PF3P IMPP1 IMPP2
    <- pair2nat-total-s _ _ _ N+F=>K
    <- nat+set2set-preserves-not-member N+SP=>MP F!<SP N+F=>K K!<MP
    <- set`update-total MP+K=M.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L4L2 _ _ _ _ _ _ _ _ _).
%total (A) (letRefTyping-helper/base/unique/L4L2 _ A _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L4L2*
  : forall* {CM} {PM} {FM} {PF1} {NN} {B:object -> cxt} {N} {C} {FS} {A} {M}
    forall {CML: clsmap`lookup CM C FM}
    {M2P: {x} fldset2perm PM x FM FS (PF1 x)}
    {BL: {x} cxt`lookup (B x) (s N) (cxt-info/ x (ty/ NN A C))}
    {M=>PF: nat+set2set (s N) FS M}
    exists {PF3}
    {M=>PF3: {x} capset2perm CM PM (B x) M (PF3 x)}
    {PF2=>PF3: {x} implies
               (unitperm (conditional
                           (objequal x null) (empty) (PF1 x))) (PF3 x)}
    {PF3=>PF2: {x} implies (PF3 x)
               (unitperm (conditional
                           (objequal x null) (empty) (PF1 x)))}
    true.

- : letRefTyping-helper/base/unique/L4L2*
    CML M2P BL (FS2M:nat+set2set _ _ M) _ M2PF3 IMP0 IMP1
    <- letRefTyping-helper/base/unique/L4L2
      CML M2P BL M' _ FS2M' M2PF3' IMP0 IMP1
    <- nat+set2set-unique FS2M' FS2M nat`eq/ set`eq/ M'=M
    <- ({x} capset2perm-respects-eq (M2PF3' x) clsmap`eq/ predmap`eq/ cxt`eq/
         M'=M permission`eq/ (M2PF3 x)).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L4L2* _ _ _ _ _q _ _ _).
%total { } (letRefTyping-helper/base/unique/L4L2* _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L4
  : forall* {CM} {NN} {C} {FM} {FS} {B0} {B1} {N} {M5}
    {M0} {M1} {M3} {PM} {Out} {U0} {U1} {W}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B0: clsmap-cxt CM B0}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {N!<B1: cxt`fresh B0 (s N)}
    {B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)}
    {N+FS=M3: nat+set2set (s N) FS M3}
    {M5-M3=M0: set`split M5 M3 M0}
    {U0+N=U1: set`add U0 (s N) U1}
    {CM-R: clsmap-result CM B0
           (result/expr (reftype/ NN C (targets/unique set/0 M1 W)) (env/ U0 M0))}
    {R=>Out: result2output CM PM B0
        (result/expr (reftype/ NN C (targets/unique set/0 M1 W)) (env/ U0 M0)) Out}
    exists {PiB1} {Pi} {Pi2}
    {CM-B1: {x} clsmap-cxt CM (B1 x)}
    {CM-V: {x} clsmap-cxt-env CM (B1 x) (env/ U1 M5)}
    {V=>Pi: {x} env2input CM PM (B1 x) (env/ U1 M5) (Pi x)}
    {B1=>PiB1: {x} cxt2perm PM (B1 x) (PiB1 x)}
    {EC-FMT: unique-encumbered-perm-format CM PM B0 B1 set/0 NN C M1 set/0 M3 Pi2}
    {TRANS: transform Out
            (output/exists [x]
              (output/exists [o:object]
                (output/exists [p:permission]
                  (output/expr x
                    ((Pi2 x o p) ,((PiB1 x) , (Pi x)))))))}
    true.

- : letRefTyping-helper/base/unique/L4 CM-CM CM2PM
    (CM-B0: clsmap-cxt CM B0)
    (CML:clsmap`lookup CM C FM)
    (FM-DM:fldmap`domain FM FS)
    (N!<B0: cxt`fresh B0 (s N))
    ([x] B0+N=B1 x)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (set`split/ M3^M0 M3+M0=M5)
    (U0+SN=U1: set`add U0 (s N) U1)
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique (CML2:clsmap`lookup CM C FM2)
        cxt-unique-objset/0 CM-B0-M1 (wf-unique-targets/unique+fresh))
      (clsmap-cxt-env/ CM-B0-U0 CM-B0-M0))
    (result2output/expr (B0=>PiB0:cxt2perm PM B0 PiB0)
      (env2input/ U0=>PiU0 (B0+M0=>PiM0:capset2perm CM PM B0 M0 PiM0))
      (reftype2perm/unique+fresh (T2PF:ty2perm PM _ PF) ([_] set2cond/0)
        (B0+M1=>PiM1:capset2perm CM PM B0 M1 PiM1))) _ _ _
    ([x] clsmap-cxt/U (CM-B0:clsmap-cxt CM B0) (clsmap-ty/ CML)
      N!<B0 (B0+N=B1 x))
    ([x] clsmap-cxt-env/
      (clsmap-cxt-objset/U (CM-B1-U0 x) (B1-L x) CML3 N!<U0 U0+SN=U1) (CM-B1-M5 x))
    ([x] env2input/
      (make-encumbered/U (B1+U0=>PiU0 x) (B1-L x) CML3 PML3 FM-DM2 FM2P N!<U0
        U0+SN=U1) (B1+M5=>PiM5 x))
    ([x] cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/unique T2PF2))
    (unique-encumbered-perm-format/fresh set`size/0 T2PF B0+M1=>PiM1)
    (transform/inside [x]
      (transform/trans
        (transform/inside [r]
          (transform/trans
            (transform/inside [p:permission]
              (transform/implies
                (implies/trans8
                  (implies/trans
                    (implies/equiv equiv/identity)
                    (implies/combine implies/reflexive
                      (implies/trans
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine implies/reflexive
                          (implies/equiv (equiv/symmetric equiv/associate))))))
                  (implies/combine (implies/reflexive)
                    (implies/trans6
                      (implies/combine
                        (implies/trans3
                          (implies/cond-gen-inner)
                          (implies/cond-inner
                            (bimplies/reflexive)
                            (bimplies/reflexive)
                            (implies/equiv equiv/identity)
                            (implies/trans3
                              (implies/combine
                                (implies/nonlinear2empty)
                                (implies/contradiction))
                              (implies/equiv equiv/commute)
                              (implies/equiv equiv/identity)))
                          (implies/cond-equal))
                        (implies/equiv equiv/associate))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans
                          (implies/combine
                            (implies/nonlinear bimplies/objequal-symmetric)
                            (implies/reflexive))
                          (implies/objequal
                            ([y] (combine (PF y)
                                   (unitperm (encumbered (PF y) (PiM1 , p)))))))
                        (implies/reflexive))
                      (implies/equiv (equiv/symmetric equiv/associate))
                      (implies/combine
                        (implies/trans
                          (IMP x)
                          (implies/combine implies/reflexive (IMP2 x)))
                        (implies/reflexive))
                      (implies/equiv (equiv/symmetric equiv/associate))))
                  (implies/equiv equiv/associate)
                  (implies/equiv
                    (equiv/transitive
                      (equiv/combine equiv/reflexive equiv/roll2)
                      (equiv/associate)))
                  (implies/combine (implies/reflexive)
                    (implies/trans
                      (implies/equiv equiv/roll2)
                      (implies/combine (implies/reflexive)
                        (implies/equiv (PiM3+PiM0<=>PiM5 x)))))
                  (implies/equiv equiv/roll2)
                  (implies/combine
                    (implies/reflexive)
                    (implies/combine
                      (implies/equiv equiv/commute)
                      (implies/reflexive)))
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine equiv/reflexive
                        (equiv/symmetric equiv/associate))
                      (equiv/roll2) % X9 (X2 ...)
                      (equiv/combine equiv/reflexive
                        (equiv/transitive3
                          (equiv/associate)
                          (equiv/combine
                            (equiv/transitive4
                              (equiv/roll2)
                              (equiv/combine equiv/reflexive equiv/roll2)
                              (equiv/associate)
                              (equiv/combine equiv/commute equiv/commute))
                            (equiv/reflexive))
                          (equiv/symmetric equiv/associate))))))))
            (transform/reflexive))))
      (transform/reflexive))
    <- clsmap-cxt-objset-cxt-fresh-implies-not-member CM-B0-U0 N!<B0 N!<U0
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- letRefTyping-helper/base/unique/L4L1 CM-CM CM2PM CML FM-DM T2PF
      _ _ (ty2perm3/unique CML3 PML3 FM-DM2 ([x] (FM2P x)) T2PF2)
      ([x] FS=>PF x) ([x] IMP x)
    <- letRefTyping-helper/base/unique/L4L2 CML FS=>PF B1-L
      M3P PiM3 N+FS=M3P ([x] M3P=>PiM3 x) ([x] IMP2 x) _
    <- nat+set2set-unique N+FS=M3P N+FS=M3 nat`eq/ set`eq/ M3P=M3
    <- ({x} capset2perm-respects-eq (M3P=>PiM3 x) clsmap`eq/ predmap`eq/ cxt`eq/
         M3P=M3 permission`eq/ (B1+M3=>PiM3 x))
    <- ({x} cxt-fresh-update-preserves-capset2perm B0+M0=>PiM0 N!<B0 (B0+N=B1 x)
         (B1+M0=>PiM0 x))
    <- ({x} cxt-fresh-update-preserves-make-encumbered U0=>PiU0 N!<B0 (B0+N=B1 x)
         (B1+U0=>PiU0 x))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-objset CM-B0-U0 N!<B0 (B0+N=B1 x)
         (CM-B1-U0 x))
    <- ({x} set`split-implies-permission-combine-converse
         (set`split/ M3^M0 M3+M0=M5) (B1+M3=>PiM3 x) (B1+M0=>PiM0 x) (PiM5 x)
         (B1+M5=>PiM5 x) (PiM3+PiM0<=>PiM5 x))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capset CM-B0-M0 N!<B0
         (B0+N=B1 x) (CM-B1-M0 x))
    <- ({x} nat+set2set-implies-clsmap-cxt-capset
         CML FM-DM (B1-L x) not-shared/unique N+FS=M3 (CM-B1-M3 x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-M3 x) (CM-B1-M0 x)
         M3+M0=M5 (CM-B1-M5 x)).

%{
- : letRefTyping-helper/base/unique/L4 CM-CM CM2PM
    (CM-B0: clsmap-cxt CM B0)
    (CML:clsmap`lookup CM C FM)
    (FM-DM:fldmap`domain FM FS)
    (N!<B0: cxt`fresh B0 (s N))
    ([x] B0+N=B1 x)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (set`split/ M3^M0 M3+M0=M5)
    (U0+SN=U1: set`add U0 (s N) U1)
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique (CML2:clsmap`lookup CM C FM2)
        cxt-unique-objset/0 CM-B0-M1 wf-unique-targets/unique+fresh)
      (clsmap-cxt-env/ CM-B0-U0 CM-B0-M0))
    (result2output/expr (B0=>PiB0:cxt2perm PM B0 PiB0)
      (env2input/ U0=>PiU0 (B0+M0=>PiM0:capset2perm CM PM B0 M0 PiM0))
      (reftype2perm/unique+fresh (T2PF:ty2perm PM _ PF)
        ([_] set2cond/0) capset2perm/0)) _ _ _
    ([x] clsmap-cxt/U (CM-B0:clsmap-cxt CM B0) (clsmap-ty/ CML)
      N!<B0 (B0+N=B1 x))
    ([x] clsmap-cxt-env/
      (clsmap-cxt-objset/U (CM-B1-U0 x) (B1-L x) CML3 N!<U0 U0+SN=U1) (CM-B1-M5 x))
    ([x] env2input/
      (make-encumbered/U (B1+U0=>PiU0 x) (B1-L x) CML3 PML3 FM-DM2 FM2P N!<U0
        U0+SN=U1) (B1+M5=>PiM5 x))
    ([x] cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/unique T2PF2))
    (unique-encumbered-perm-format/fresh set`size/0 set`size/0)
    (transform/trans
      (transform/inside [o:object]
        (transform/inside [r:object]
          (transform/inside [p:permission]
            (transform/trans
              (transform/implies
                (implies/trans3
                  (implies/equiv equiv/identity)
                  (implies/combine implies/reflexive
                    (implies/combine
                      (implies/trans3
                        (implies/combine
                          (implies/trans (cond-to-objequal o r)
                            (implies/nonlinear bimplies/objequal-symmetric))
                          (implies/combine (IMP r) implies/reflexive))
                        (implies/objequal
                          ([x1] (combine
                                  (combine
                                    (combine (X6 x1)
                                      (unitperm
                                        (conditional (objequal x1 null) empty
                                          (unitperm
                                            (encumbered (X7 x1)
                                              (combine (allperm x1)
                                                (one-predcall X8 x1)))))))
                                    (unitperm
                                      (conditional (objequal x1 null) empty (X4 x1))))
                                  (unitperm (encumbered (PF x1) (combine empty p))))))
                        (implies/combine
                          (implies/combine (implies/reflexive) (IMP2 o))
                          (implies/reflexive)))
                      (implies/reflexive)))
                  (implies/equiv
                    (equiv/transitive5
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/combine
                            (equiv/transitive
                              (equiv/combine equiv/symmetric-associate equiv/reflexive)
                              (equiv/symmetric-associate))
                            (equiv/reflexive))
                          (equiv/symmetric-associate)))
                      (equiv/associate)
                      (equiv/combine equiv/commute
                        (equiv/transitive4
                          (equiv/combine equiv/swap equiv/reflexive)
                          (equiv/swap-middle)
                          (equiv/combine
                            (equiv/transitive
                              (equiv/combine equiv/commute equiv/reflexive)
                              (equiv/symmetric-associate))
                            (PiM3+PiM0<=>PiM5 o))
                          (equiv/symmetric-associate)))
                      (equiv/roll2)
                      (equiv/combine equiv/reflexive
                        (equiv/transitive (equiv/symmetric equiv/identity) equiv/commute))))))
              (transform/drop)))))
      (transform/inside [_] (transform/inside [_] transform/rem-unused)))
    <- clsmap-cxt-objset-cxt-fresh-implies-not-member CM-B0-U0 N!<B0 N!<U0
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- letRefTyping-helper/base/unique/L4L1 CM-CM CM2PM CML FM-DM T2PF
      _ _ (ty2perm3/unique CML3 PML3 FM-DM2 ([x] (FM2P x)) T2PF2)
      ([x] FS=>PF x) ([x] IMP x)
    <- letRefTyping-helper/base/unique/L4L2 CML FS=>PF B1-L
      M3P PiM3 N+FS=M3P ([x] M3P=>PiM3 x) ([x] IMP2 x) _
    <- nat+set2set-unique N+FS=M3P N+FS=M3 nat`eq/ set`eq/ M3P=M3
    <- ({x} capset2perm-respects-eq (M3P=>PiM3 x) clsmap`eq/ predmap`eq/ cxt`eq/
         M3P=M3 permission`eq/ (B1+M3=>PiM3 x))
    <- ({x} cxt-fresh-update-preserves-capset2perm B0+M0=>PiM0 N!<B0 (B0+N=B1 x)
         (B1+M0=>PiM0 x))
    <- ({x} cxt-fresh-update-preserves-make-encumbered U0=>PiU0 N!<B0 (B0+N=B1 x)
         (B1+U0=>PiU0 x))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-objset CM-B0-U0 N!<B0 (B0+N=B1 x)
         (CM-B1-U0 x))
    <- ({x} set`split-implies-permission-combine-converse
         (set`split/ M3^M0 M3+M0=M5) (B1+M3=>PiM3 x) (B1+M0=>PiM0 x) (PiM5 x)
         (B1+M5=>PiM5 x) (PiM3+PiM0<=>PiM5 x))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capset CM-B0-M0 N!<B0
         (B0+N=B1 x) (CM-B1-M0 x))
    <- ({x} nat+set2set-implies-clsmap-cxt-capset
         CML FM-DM (B1-L x) not-shared/unique N+FS=M3 (CM-B1-M3 x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-M3 x) (CM-B1-M0 x)
M3+M0=M5 (CM-B1-M5 x)).
}%

- : letRefTyping-helper/base/unique/L4 CM-CM CM2PM
    (CM-B0: clsmap-cxt CM B0)
    (CML:clsmap`lookup CM C FM)
    (FM-DM:fldmap`domain FM FS)
    (N!<B0: cxt`fresh B0 (s N))
    ([x] B0+N=B1 x)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (set`split/ M3^M0 M3+M0=M5)
    (U0+SN=U1: set`add U0 (s N) U1)
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique (CML2:clsmap`lookup CM C FM2)
        cxt-unique-objset/0 CM-B0-M1 (wf-unique-targets/unique _))
      (clsmap-cxt-env/ CM-B0-U0 CM-B0-M0))
    (result2output/expr (B0=>PiB0:cxt2perm PM B0 PiB0)
      (env2input/ U0=>PiU0 (B0+M0=>PiM0:capset2perm CM PM B0 M0 PiM0))
      (reftype2perm/unique SZ-M1 (T2PF:ty2perm PM _ PF) ([_] set2cond/0)
        (B0+M1=>PiM1:capset2perm CM PM B0 M1 PiM1))) _ _ _
    ([x] clsmap-cxt/U (CM-B0:clsmap-cxt CM B0) (clsmap-ty/ CML)
      N!<B0 (B0+N=B1 x))
    ([x] clsmap-cxt-env/
      (clsmap-cxt-objset/U (CM-B1-U0 x) (B1-L x) CML3 N!<U0 U0+SN=U1) (CM-B1-M5 x))
    ([x] env2input/
      (make-encumbered/U (B1+U0=>PiU0 x) (B1-L x) CML3 PML3 FM-DM2 FM2P N!<U0
        U0+SN=U1) (B1+M5=>PiM5 x))
    ([x] cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/unique T2PF2))
    (unique-encumbered-perm-format/borrow set`size/0 SZ-M1 T2PF B0+M1=>PiM1)
    (transform/inside [x]
      (transform/trans
        (transform/inside [r]
          (transform/trans3
            (transform/rem-unused)
            (transform/implies
              (implies/trans8
                (implies/trans
                  (implies/equiv equiv/identity)
                  (implies/combine implies/reflexive
                    (implies/trans
                      (implies/equiv (equiv/symmetric equiv/associate))
                      (implies/combine implies/reflexive
                        (implies/equiv (equiv/symmetric equiv/associate))))))
                (implies/combine (implies/reflexive)
                  (implies/trans6
                    (implies/combine
                      (implies/trans3
                        (implies/cond-gen-inner)
                        (implies/cond-inner
                          (bimplies/reflexive)
                          (bimplies/reflexive)
                          (implies/equiv equiv/identity)
                          (implies/trans3
                            (implies/combine
                              (implies/nonlinear2empty)
                              (implies/contradiction))
                            (implies/equiv equiv/commute)
                            (implies/equiv equiv/identity)))
                        (implies/cond-equal))
                      (implies/equiv equiv/associate))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans
                        (implies/combine
                          (implies/nonlinear bimplies/objequal-symmetric)
                          (implies/reflexive))
                        (implies/objequal
                          ([y] (combine (PF y)
                                 (unitperm (encumbered (PF y) PiM1))))))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/trans
                        (IMP x)
                        (implies/combine implies/reflexive (IMP2 x)))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))))
                (implies/equiv equiv/associate)
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine equiv/reflexive equiv/roll2)
                    (equiv/associate)))
                (implies/combine (implies/reflexive)
                  (implies/trans
                    (implies/equiv equiv/roll2)
                    (implies/combine (implies/reflexive)
                      (implies/equiv (PiM3+PiM0<=>PiM5 x)))))
                (implies/equiv equiv/roll2)
                (implies/combine
                  (implies/reflexive)
                  (implies/combine
                    (implies/equiv equiv/commute)
                    (implies/reflexive)))
                (implies/equiv
                  (equiv/transitive3
                    (equiv/combine equiv/reflexive
                      (equiv/symmetric equiv/associate))
                    (equiv/roll2) % X9 (X2 ...)
                    (equiv/combine equiv/reflexive
                      (equiv/transitive3
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive4
                            (equiv/roll2)
                            (equiv/combine equiv/reflexive equiv/roll2)
                            (equiv/associate)
                            (equiv/combine equiv/commute equiv/commute))
                          (equiv/reflexive))
                        (equiv/symmetric equiv/associate)))))))
            (transform/add-unused))))
      (transform/reflexive))
    <- clsmap-cxt-objset-cxt-fresh-implies-not-member CM-B0-U0 N!<B0 N!<U0
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- letRefTyping-helper/base/unique/L4L1 CM-CM CM2PM CML FM-DM T2PF
      _ _ (ty2perm3/unique CML3 PML3 FM-DM2 ([x] (FM2P x)) T2PF2)
      ([x] FS=>PF x) ([x] IMP x)
    <- letRefTyping-helper/base/unique/L4L2 CML FS=>PF B1-L
      M3P PiM3 N+FS=M3P ([x] M3P=>PiM3 x) ([x] IMP2 x) _
    <- nat+set2set-unique N+FS=M3P N+FS=M3 nat`eq/ set`eq/ M3P=M3
    <- ({x} capset2perm-respects-eq (M3P=>PiM3 x) clsmap`eq/ predmap`eq/ cxt`eq/
         M3P=M3 permission`eq/ (B1+M3=>PiM3 x))
    <- ({x} cxt-fresh-update-preserves-capset2perm B0+M0=>PiM0 N!<B0 (B0+N=B1 x)
         (B1+M0=>PiM0 x))
    <- ({x} cxt-fresh-update-preserves-make-encumbered U0=>PiU0 N!<B0 (B0+N=B1 x)
         (B1+U0=>PiU0 x))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-objset CM-B0-U0 N!<B0 (B0+N=B1 x)
         (CM-B1-U0 x))
    <- ({x} set`split-implies-permission-combine-converse
         (set`split/ M3^M0 M3+M0=M5) (B1+M3=>PiM3 x) (B1+M0=>PiM0 x) (PiM5 x)
         (B1+M5=>PiM5 x) (PiM3+PiM0<=>PiM5 x))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capset CM-B0-M0 N!<B0
         (B0+N=B1 x) (CM-B1-M0 x))
    <- ({x} nat+set2set-implies-clsmap-cxt-capset
         CML FM-DM (B1-L x) not-shared/unique N+FS=M3 (CM-B1-M3 x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-M3 x) (CM-B1-M0 x)
         M3+M0=M5 (CM-B1-M5 x)).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L4 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L4 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L5L2
  : forall* {PM} {B} {NN} {C} {S} {GF} {PiB}
    forall {K} {SZ: set`size S (s K)}
    {CM-B-S: cxt-unique-objset B NN C S}
    {S=>GF: {x} set2cond B x S (GF x)}
    {B=>PiB: cxt2perm PM B PiB}
    exists {PF} {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {IMP: {x} implies (combine PiB (GF x)) (combine (PF x) (combine PiB (GF x)))}
    true.

%theorem letRefTyping-helper/base/unique/L5L2L1
  : forall* {O} {OP}
    forall {EQ: {x} object`eq (OP x) O}
    exists {EQV: {x} equiv (unitperm (nonlinear (objequal x (OP x))))
                 (unitperm (nonlinear (objequal x O)))}
    true.

- : letRefTyping-helper/base/unique/L5L2L1 ([_] object`eq/) ([_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L5L2L1 _ _).
%total { } (letRefTyping-helper/base/unique/L5L2L1 _ _).


%theorem letRefTyping-helper/base/unique/L5L2L2
  : forall* {B} {N} {OF:object -> object} {TF}
    forall {BL: {x} cxt`lookup B N (cxt-info/ (OF x) TF)}
    exists {O} {T} {BL: cxt`lookup B N (cxt-info/ O T)}
    {EQ: {x} object`eq (OF x) O}
    true.

- : letRefTyping-helper/base/unique/L5L2L2
    ([_] cxt`lookup/= N1=N2) _ _ (cxt`lookup/= N1=N2) ([_] object`eq/).

- : letRefTyping-helper/base/unique/L5L2L2
    ([x] cxt`lookup/> (BL x) P) _ _ (cxt`lookup/> BLP P) EQF
    <- letRefTyping-helper/base/unique/L5L2L2 BL _ _ BLP EQF.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L5L2L2 _ _ _ _ _).
%total (L) (letRefTyping-helper/base/unique/L5L2L2 L _ _ _ _).


- : letRefTyping-helper/base/unique/L5L2 (s _) SZ
    (cxt-unique-objset/U CM-B-SP
      (BL:cxt`lookup B (s N) (cxt-info/ O _)) U-OR-B (NN-LEQ:nonnull`leq NN NNP) N!<SP SP+N=S)
    ([x] S=>GF x) (B=>PiB:cxt2perm PM B PiB) PF2 T2PF2
    ([x] implies/trans7
      (implies/combine (implies/reflexive) (GIMP1 x))
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans3
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (implies/trans
                  (implies/equiv (EQV2 x))
                  (implies/nonlinear bimplies/objequal-symmetric))
                (IMP2))
              (implies/objequal ([y] (combine (PF y) PiB))))
            (implies/reflexive))
          (implies/combine
            (implies/combine (IMP3 x) implies/reflexive)
            implies/reflexive))
        (implies/trans3
          (implies/combine
            (implies/nonlinear2empty)
            (implies/trans3
              (IMPP x)
              (implies/combine
                (implies/equiv (PEQV x))
                (implies/reflexive))
              (implies/equiv equiv/associate)))
          (implies/equiv equiv/commute)
          (implies/equiv equiv/identity)))
      (implies/cond-pull)
      (implies/combine (implies/reflexive) (GIMP2 x))
      (implies/equiv (equiv/symmetric equiv/associate)))
    <- ({x} set2cond/U-inversion (S=>GF x) N!<SP SP+N=S (GFP x) (SP=>GFP x)
         (OP x) _ (BLP x) (GIMP1 x) (GIMP2 x))
    <- cxt2perm-lookup-not-shared-can-duplicate B=>PiB BL U-OR-B PF T2PF IMP2
    <- letRefTyping-helper/base/unique/L5L2L2 BLP OPP _ BLPP ([x] OP=OPP x)
    <- cxt`lookup-unique BLPP BL cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE (OPP=O:object`eq OPP O) _
    <- ({x} object`eq-transitive (OP=OPP x) OPP=O (OP=O x))
    <- letRefTyping-helper/base/unique/L5L2L1 OP=O EQV2
    <- nn-leq-implies-permission-leq T2PF NN-LEQ PF2 T2PF2 ([x] IMP3 x)
    <- set`not-member-add-increases-size-converse SZ N!<SP SP+N=S SZP
    <- letRefTyping-helper/base/unique/L5L2 _ SZP CM-B-SP SP=>GFP B=>PiB PFP T2PF2P IMPP
    <- ty2perm-deterministic T2PF2P T2PF2 predmap`eq/ ty`eq/ ([x] PEQ x)
    <- ({x} permission`eq-implies-equiv (PEQ x) (PEQV x)).

- : letRefTyping-helper/base/unique/L5L2 z SZ
    (cxt-unique-objset/U CM-B-SP
      (BL:cxt`lookup B (s N) (cxt-info/ O _)) U-OR-B (NN-LEQ:nonnull`leq NN NNP) N!<SP SP+N=S)
    ([x] S=>GF x) (B=>PiB:cxt2perm PM B PiB) _ T2PF2
    ([x] implies/trans8
      (implies/combine (IMP2) (GIMP1 x))
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans
          (implies/combine
            (implies/trans
              (implies/equiv (EQV2 x))
              (implies/nonlinear bimplies/objequal-symmetric))
            (implies/reflexive))
          (implies/objequal ([y] (combine (combine (PF y) PiB) empty))))
        (implies/trans
          (implies/combine (implies/nonlinear2empty)
            (implies/trans3
              (implies/combine (implies/reflexive)
                (implies/trans
                  (GIMP3 x)
                  (implies/duplicate)))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans3
                  (implies/equiv (equiv/commute))
                  (implies/combine
                    (implies/contradiction)
                    (implies/reflexive))
                  (implies/objequal ([y] (combine (PF y) PiB))))
                (GIMP4 x))))
          (implies/equiv (equiv/transitive equiv/commute equiv/identity))))
      (implies/cond-pull)
      (implies/combine
        (implies/reflexive)
        (GIMP2 x))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine (IMP3 x) implies/reflexive))
    <- set`not-member-add-size-implies-empty N!<SP SP+N=S SZ (SP=E:set`eq SP set/0)
    <- ({x} set2cond/U-inversion (S=>GF x) N!<SP SP+N=S (GFP x) (SP=>GFP x)
         (OP x) _ (BLP x) (GIMP1 x) (GIMP2 x))
    <- cxt2perm-lookup-not-shared-can-duplicate B=>PiB BL U-OR-B PF T2PF IMP2
    <- letRefTyping-helper/base/unique/L5L2L2 BLP OPP _ BLPP ([x] OP=OPP x)
    <- cxt`lookup-unique BLPP BL cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE (OPP=O:object`eq OPP O) _
    <- ({x} object`eq-transitive (OP=OPP x) OPP=O (OP=O x))
    <- letRefTyping-helper/base/unique/L5L2L1 OP=O EQV2
    <- ({x} set2cond-implies (SP=>GFP x) set2cond/0 object`eq/ SP=E (GIMP3 x) (GIMP4 x))
    <- nn-leq-implies-permission-leq T2PF NN-LEQ PF2 T2PF2 ([x] IMP3 x).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L5L2 _ _ _ _ _ _ _ _).
%total (N) (letRefTyping-helper/base/unique/L5L2 N _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L5L3
  : forall* {X1} {X2} {X3} {X4} {X5} {X6} {PiB0} {PiU1} {PiM5}
    forall {P-EQ:{x} permission`eq
                  (combine (X1 x)
                    (unitperm
                      (conditional (objequal x null) empty
                        (unitperm
                          (encumbered (X2 x)
                            (combine (allperm x) (one-predcall X3 x)))))))
                  (combine (X4 x)
                    (unitperm
                      (conditional (objequal x null) empty
                        (unitperm
                          (encumbered (X5 x)
                            (combine (allperm x) (one-predcall X6 x)))))))}
    exists {EQ:{x} permission`eq
            (combine (combine (X4 x) PiB0)
              (combine
                (combine
                  (unitperm
                    (conditional (objequal x null) empty
                      (unitperm (encumbered (X5 x) (combine (allperm x) (one-predcall X6 x))))))
                  PiU1)
                (PiM5 x)))
            (combine (combine (X1 x) PiB0)
              (combine
                (combine
                  (unitperm
                    (conditional (objequal x null) empty
                      (unitperm (encumbered (X2 x) (combine (allperm x) (one-predcall X3 x))))))
                  PiU1)
                (PiM5 x)))}
    true.

- : letRefTyping-helper/base/unique/L5L3 ([_] permission`eq/) ([_] permission`eq/).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L5L3 _ _).
%total { } (letRefTyping-helper/base/unique/L5L3 _ _).


%theorem letRefTyping-helper/base/unique/L5
  : forall* {CM} {NN} {C} {FM} {FS} {S} {M2} {B0} {B1} {N} {M5}
    {M0} {M1} {M3} {M4} {PM} {Out} {SK} {MK} {U0} {U1} {U2} {W}
    forall {SZ-S: set`size S (s SK)}
    {SZ-M1: set`size M1 MK}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B0: clsmap-cxt CM B0}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {S+FS=M2: set+set2set S FS M2}
    {N!<B0: cxt`fresh B0 (s N)}
    {B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)}
    {M0-M2=M4: set`split M0 M2 M4}
    {S<=U0: set`leq S U0}
    {U0-S=U1: set`remove U0 S U1}
    {U1+N=U2: set`add U1 (s N) U2}
    {N+FS=M3: nat+set2set (s N) FS M3}
    {M5-M3=M4: set`split M5 M3 M4}
    {CM-Rslt: clsmap-result CM B0
              (result/expr (reftype/ NN C (targets/unique S M1 W)) (env/ U0 M0))}
    {Rslt=>Out: result2output CM PM B0
                (result/expr (reftype/ NN C (targets/unique S M1 W)) (env/ U0 M0)) Out}
    exists {PiB1} {Pi2} {Pi}
    {CM-B1: {x} clsmap-cxt CM (B1 x)}
    {CM-V: {x} clsmap-cxt-env CM (B1 x) (env/ U2 M5)}
    {V=>Pi: {x} env2input CM PM (B1 x) (env/ U2 M5) (Pi x)}
    {B1=>PiB1: {x} cxt2perm PM (B1 x) (PiB1 x)}
    {EC-FMT: unique-encumbered-perm-format CM PM B0 B1 S NN C M1 M2 M3 Pi2}
    {TRANS: transform Out
            (output/exists [x]
              (output/exists [o]
                (output/exists [p:permission]
                  (output/expr x ((Pi2 x o p) , ((PiB1 x) , Pi x))))))}
    true.

- : letRefTyping-helper/base/unique/L5 _ (SZ-M:set`size M1 z)
    CM-CM CM2PM (CM-B0:clsmap-cxt CM B0)
    (CML:clsmap`lookup CM C FM)
    (FM-DM:fldmap`domain FM FS)
    (S+FS=>M2: set+set2set S FS M2)
    (N!<B0: cxt`fresh B0 (s N))
    ([x] B0+N=B1 x)
    (M0-M2=M4:set`split M0 M2 M4)
    (S<=U0:set`leq S U0)
    (U0-S=U1: set`remove U0 S U1)
    (U1+SN=U2: set`add U1 (s N) U2)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (set`split/ M3^M4 M3+M4=M5)
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique (CML2:clsmap`lookup CM C FM2) CM-B0-S CM-B0-M1
        (wf-unique-targets/borrow _ _))
      (clsmap-cxt-env/ (CM-B0-U0: clsmap-cxt-objset CM B0 U0)
        (CM-B0-M0:clsmap-cxt-capset CM B0 M0)))
    (result2output/expr (B0=>PiB0:cxt2perm PM B0 PiB0)
      (env2input/ B0+U0=>PiU0 (B0+M0=>PiM0:capset2perm CM PM B0 M0 PiM0))
      (reftype2perm/borrow SZ-S SZ-M1
        (ty2perm/ (PML:predmap`lookup PM C CP)
          (NN2P:nn2perm _ _ PF) annot2perm/borrow)
        ([x] (B0+S=>GF:{x}set2cond B0 x S (GF x)) x))) _ _ _
    ([x] clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
    ([x] clsmap-cxt-env/
      (clsmap-cxt-objset/U (CM-B1-U1 x) (B1-L x) CML N!<U1 U1+SN=U2)
      (CM-B1-M5 x))
    ([x] env2input/
      (make-encumbered/U (B1+U1=>PiU1 x) (B1-L x) CML PML FM-DM FS=>PF
        N!<U1 U1+SN=U2) (B1+M5=>PiM5 x))
    ([x] cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/unique T2PF-B))
    (unique-encumbered-perm-format/unique/2 SZ-S SZ-M
      B0+S=>GF CML PML annot2perm/borrow NN2P
      B0+M2=>PiM2 B1+M3=>PiM3 B0+S=>PiS FM-DM FS=>PF)
    (transform/inside [x]
      (transform/inside [o]
        (transform/inside [p:permission]
          (transform/implies
            (implies/trans6
              (implies/equiv equiv/identity)
              (implies/equiv
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/transitive
                        (equiv/combine (PiU0<=>PiS+PiU1) (PiM0<=>PiM2+PiM4))
                        (equiv/symmetric equiv/associate)))
                    (equiv/symmetric equiv/associate))))
              (implies/trans3
                (implies/combine implies/reflexive (implies/equiv equiv/reorder))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans3
                    (IMP5 x)
                    (implies/combine implies/reflexive (implies/equiv equiv/commute))
                    (implies/equiv equiv/associate))
                  (implies/reflexive)))
              (implies/trans
                (implies/equiv
                  (equiv/transitive4
                    (equiv/symmetric equiv/associate)
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine
                      (equiv/symmetric equiv/associate)
                      (equiv/reflexive))))
                (implies/combine (IMP2 x) implies/reflexive))
              (implies/equiv
                (equiv/transitive
                  (equiv/combine
                    (equiv/transitive equiv/associate equiv/commute)
                    (equiv/reflexive))
                  (equiv/symmetric equiv/associate)))
              (implies/trans5
                (implies/combine implies/reflexive
                  (implies/trans4
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/symmetric equiv/associate)
                        (equiv/combine equiv/reflexive equiv/roll5)
                        (equiv/associate)))
                    (implies/combine (IMP x) implies/reflexive)
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/combine
                          (equiv/transitive
                            (equiv/combine equiv/reflexive equiv/commute)
                            (equiv/associate))
                          (equiv/combine equiv/reflexive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive equiv/commute))))
                        (equiv/symmetric equiv/associate)
                        (equiv/combine equiv/reflexive
                          (equiv/transitive
                            (equiv/combine equiv/reflexive equiv/roll4)
                            (equiv/associate)))))
                    (implies/combine implies/reflexive
                      (implies/combine (implies/equiv (PiM3+PiM4<=>PiM5 x))
                        (implies/reflexive)))))
                (implies/equiv equiv/associate)
                (implies/combine implies/reflexive
                  (implies/equiv
                    (equiv/transitive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive3
                          (equiv/symmetric equiv/associate)
                          (equiv/combine equiv/reflexive equiv/reorder)
                          (equiv/associate)))
                      (equiv/roll4))))
                (implies/equiv equiv/associate)
                (implies/combine implies/reflexive
                  (implies/equiv
                    (equiv/transitive
                      (equiv/roll2)
                      (equiv/combine equiv/reflexive equiv/commute))))))))))
    <- clsmap-cxt-objset-cxt-fresh-implies-not-member CM-B0-U0 N!<B0 N!<U0
    <- set`remove-implies-leq U0-S=U1 U1<=U0
    <- set`not-member-respects-geq N!<U0 U1<=U0 N!<U1
    <- clsmap-cxt-objset-respects-geq CM-B0-U0 U1<=U0 CM-B0-U1
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-objset CM-B0-U1
         N!<B0 (B0+N=B1 x) (CM-B1-U1 x))
    <- set`split-implies-leq M0-M2=M4 M2<=M0 M4<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M4<=M0 CM-B0-M4
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capset
         CM-B0-M4 N!<B0 (B0+N=B1 x) (CM-B1-M4 x))
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} nat+set2set-implies-clsmap-cxt-capset
         CML FM-DM (B1-L x) not-shared/unique N+FS=M3 (CM-B1-M3 x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-M3 x) (CM-B1-M4 x) M3+M4=M5 (CM-B1-M5 x))
    <- set`split-implies-permission-combine M0-M2=M4 B0+M0=>PiM0
      PiM2 PiM4 B0+M2=>PiM2 B0+M4=>PiM4 PiM0<=>PiM2+PiM4
    <- ({x} cxt-fresh-update-preserves-capset2perm
         B0+M4=>PiM4 N!<B0 (B0+N=B1 x) (B1+M4=>PiM4 x))
    <- letRefTyping-helper/base/unique/L1 _ SZ-S CM-B0-S S+FS=>M2 B0+M2=>PiM2
         B0+S=>GF N!<B0 ([x] B0+N=B1 x) M3Q
      ([x] PiM3 x) N+FS=>M3Q ([x] B1+M3Q=>PiM3 x) ([x] IMP x)
    <- nat+set2set-unique N+FS=>M3Q N+FS=M3 nat`eq/ set`eq/ M3Q=M3
    <- ({x} capset2perm-respects-eq (B1+M3Q=>PiM3 x) clsmap`eq/ predmap`eq/
         cxt`eq/ M3Q=M3 permission`eq/ (B1+M3=>PiM3 x))
    <- ({x} set`split-implies-permission-combine-converse
         (set`split/ M3^M4 M3+M4=M5) (B1+M3=>PiM3 x) (B1+M4=>PiM4 x) (PiM5 x)
         (B1+M5=>PiM5 x) (PiM3+PiM4<=>PiM5 x))
    <- letRefTyping-helper/base/unique/L5L2 _ SZ-S CM-B0-S B0+S=>GF B0=>PiB0
      PF3 T2PF-B ([x] IMP5 x)
    <- make-encumbered-intro S<=U0 U0-S=U1 B0+U0=>PiU0 PiS PiU1
      B0+S=>PiS B0+U1=>PiU1 (PiU0<=>PiS+PiU1:equiv PiU0 (PiS , PiU1))
    <- ({x} cxt-fresh-update-preserves-make-encumbered
         B0+U1=>PiU1 N!<B0 (B0+N=B1 x) (B1+U1=>PiU1 x))
    <- letRefTyping-helper/base/unique/L2** _ SZ-S T2PF-B
      CM-B0-S CML PML FM-DM B0+S=>PiS B0+S=>GF _ ([x] FS=>PF x) IMP2
    <- letRefTyping-helper/base/unique/L4L2 CML FS=>PF B1-L M3P PiM3P N+FS=>M3P
      ([x] B1+M3P=>PiM3P x) ([x] IMP4 x) _
    <- nat+set2set-unique N+FS=>M3P N+FS=M3 nat`eq/ set`eq/ M3P=M3
    <- ({x} capset2perm-equiv (B1+M3P=>PiM3P x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ M3P=M3 (PiM3P<=>PiM3 x)).

- : letRefTyping-helper/base/unique/L5 SZ-S (SZ-M:set`size _ (s _))
    CM-CM CM2PM (CM-B0:clsmap-cxt CM B0)
    (CML:clsmap`lookup CM C FM)
    (FM-DM:fldmap`domain FM FS)
    (S+FS=>M2: set+set2set S FS M2)
    (N!<B0: cxt`fresh B0 (s N))
    ([x] B0+N=B1 x)
    (M0-M2=M4:set`split M0 M2 M4)
    (S<=U0:set`leq S U0)
    (U0-S=U1: set`remove U0 S U1)
    (U1+SN=U2: set`add U1 (s N) U2)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (set`split/ M3^M4 M3+M4=M5)
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique (CML2:clsmap`lookup CM C FM2) CM-B0-S CM-B0-M1
        (wf-unique-targets/unique _))
      (clsmap-cxt-env/ (CM-B0-U0: clsmap-cxt-objset CM B0 U0)
        (CM-B0-M0:clsmap-cxt-capset CM B0 M0)))
    (result2output/expr (B0=>PiB0:cxt2perm PM B0 PiB0)
      (env2input/ B0+U0=>PiU0 (B0+M0=>PiM0:capset2perm CM PM B0 M0 PiM0))
      (reftype2perm/unique SZ-M1
        (ty2perm/ (PML:predmap`lookup PM C CP)
          (NN2P:nn2perm _ _ PF) annot2perm/unique)
        ([x] B0+S=>GF x)
        (B0+M1=>PiM1:capset2perm CM PM B0 M1 PiM1))) _ _ _
    ([x] clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
    ([x] clsmap-cxt-env/
      (clsmap-cxt-objset/U (CM-B1-U1 x) (B1-L x) CML N!<U1 U1+SN=U2)
      (CM-B1-M5 x))
    ([x] env2input/
      (make-encumbered/U (B1+U1=>PiU1 x) (B1-L x) CML PML FM-DM FS=>PF
        N!<U1 U1+SN=U2) (B1+M5=>PiM5 x))
    ([x] cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/unique T2PF-B))
    (unique-encumbered-perm-format/unique SZ-S SZ-M
      B0+S=>GF CML PML annot2perm/unique NN2P B0+M1=>PiM1
      B0+M2=>PiM2 B1+M3=>PiM3 B0+S=>PiS FM-DM FS=>PF)
    (transform/inside [x]
      (transform/inside [o]
        (transform/inside [p:permission]
          (transform/trans
            (transform/implies
              (implies/trans9
                (implies/equiv
                  (equiv/transitive
                    (equiv/identity)
                    (equiv/combine equiv/reflexive
                      (equiv/transitive
                        (equiv/symmetric equiv/associate)
                        (equiv/combine equiv/reflexive
                          (equiv/symmetric equiv/associate))))))
                (implies/combine
                  (implies/reflexive)
                  (implies/equiv (equiv/commute)))
                (implies/equiv (equiv/associate))
                (implies/equiv
                  (equiv/combine
                    (equiv/combine equiv/reflexive % PiB0
                      (equiv/combine equiv/reflexive % PF
                        (equiv/associate)))
                    (equiv/reflexive)))
                (implies/cond-push)
                (implies/cond-gen-inner)
                (implies/cond-inner
                  (bimplies/reflexive)
                  (bimplies/reflexive)
                  (implies/trans8
                    (implies/combine (implies/reflexive)
                      (implies/equiv
                        (equiv/transitive
                          (equiv/identity)
                          (equiv/roll2))))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans
                        (implies/combine
                          (implies/nonlinear bimplies/objequal-symmetric)
                          (implies/reflexive))
                        (implies/objequal ([v] (PF CP v))))
                      (implies/reflexive))
                    (implies/combine
                      (implies/trans (IMP3 x)
                        (implies/combine implies/reflexive (IMP4 x)))
                      (implies/combine
                        (implies/reflexive)
                        (implies/combine (implies/reflexive)
                          (implies/equiv
                            (equiv/transitive
                              (PiM0<=>PiM2+PiM4)
                              (equiv/commute))))))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine (implies/reflexive)
                      (implies/trans3
                        (implies/combine (implies/equiv (PiM3P<=>PiM3 x))
                          (implies/equiv (equiv/roll3)))
                        (implies/equiv equiv/associate)
                        (implies/combine (implies/equiv (PiM3+PiM4<=>PiM5 x))
                          (implies/reflexive))))
                    (implies/equiv
                      (equiv/transitive8
                        (equiv/combine equiv/reflexive % (X3 EC)
                          (equiv/transitive
                            (equiv/combine equiv/reflexive % PiM5
                              (equiv/combine equiv/reflexive % PiB0
                                (equiv/transitive
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/transitive3
                                      (equiv/combine PiU0<=>PiS+PiU1 equiv/reflexive)
                                      (equiv/symmetric equiv/associate)
                                      (equiv/combine equiv/reflexive equiv/commute))))))
                            (equiv/roll3)))
                        (equiv/symmetric equiv/associate)
                        (equiv/roll3)
                        (equiv/combine equiv/reflexive equiv/roll6)
                        (equiv/associate)
                        (equiv/combine equiv/reflexive equiv/roll5)
                        (equiv/associate)
                        (equiv/combine equiv/reflexive
                          (equiv/transitive3
                            (equiv/combine equiv/reflexive equiv/roll3)
                            (equiv/associate)
                            (equiv/combine equiv/reflexive
                              (equiv/transitive
                                (equiv/combine equiv/reflexive equiv/commute)
                                (equiv/associate)))))))
                    (implies/equiv equiv/commute))
                  (implies/trans9
                    (implies/combine
                      (implies/nonlinear2empty)
                      (implies/equiv (equiv/commute)))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/identity)))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/roll2)
                        (equiv/associate)))
                    (implies/combine (IMP5 x)
                      (implies/equiv
                        (equiv/combine equiv/reflexive
                          (equiv/symmetric equiv/associate))))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          (equiv/transitive
                            (equiv/combine equiv/reflexive equiv/commute)
                            (equiv/associate))
                          (equiv/transitive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/transitive
                                  (equiv/combine (PiU0<=>PiS+PiU1) (PiM0<=>PiM2+PiM4))
                                  (equiv/symmetric equiv/associate))))
                            (equiv/roll3)))
                        (equiv/swap-middle)))
                    (implies/trans3
                      (implies/combine
                        (implies/trans
                          (implies/equiv (equiv/symmetric equiv/associate))
                          (IMP2 x))
                        (implies/equiv equiv/roll5))
                      (implies/equiv (equiv/swap-middle))
                      (implies/combine (IMP x) implies/reflexive))
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/combine
                          (equiv/roll2)
                          (equiv/transitive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive % PiB0
                                (equiv/combine equiv/reflexive
                                  (equiv/combine equiv/reflexive equiv/commute))))
                            (equiv/roll5)))
                        (equiv/swap-middle)
                        (equiv/combine (PiM3+PiM4<=>PiM5 x) equiv/reflexive)))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine equiv/reflexive % PiM5
                          (equiv/transitive
                            (equiv/combine equiv/reflexive % (GF , PiM3-+-PiM2)
                              (equiv/transitive
                                (equiv/combine (equiv/symmetric equiv/associate)
                                  (equiv/reflexive))
                                (equiv/symmetric equiv/associate)))
                            (equiv/symmetric equiv/associate)))
                        (equiv/combine equiv/reflexive
                          (equiv/combine equiv/reflexive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/transitive
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/combine equiv/reflexive
                                      (equiv/combine equiv/reflexive
                                        (equiv/combine equiv/reflexive
                                          (equiv/commute))))))))))))
                    (implies/equiv
                      (equiv/transitive7
                        (equiv/roll4)
                        (equiv/combine equiv/reflexive
                          (equiv/roll6))
                        (equiv/associate)
                        (equiv/combine equiv/reflexive
                          (equiv/transitive3
                            (equiv/roll4)
                            (equiv/combine equiv/reflexive equiv/roll6)
                            (equiv/associate)))
                        (equiv/associate)
                        (equiv/associate)
                        (equiv/combine (equiv/symmetric equiv/associate) equiv/reflexive)))))
                (implies/cond-pull)
                (implies/equiv equiv/commute)))
            (transform/reflexive)))))
    <- clsmap-cxt-objset-cxt-fresh-implies-not-member CM-B0-U0 N!<B0 N!<U0
    <- set`remove-implies-leq U0-S=U1 U1<=U0
    <- set`not-member-respects-geq N!<U0 U1<=U0 N!<U1
    <- clsmap-cxt-objset-respects-geq CM-B0-U0 U1<=U0 CM-B0-U1
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-objset CM-B0-U1
         N!<B0 (B0+N=B1 x) (CM-B1-U1 x))
    <- set`split-implies-leq M0-M2=M4 M2<=M0 M4<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M4<=M0 CM-B0-M4
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capset
         CM-B0-M4 N!<B0 (B0+N=B1 x) (CM-B1-M4 x))
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} nat+set2set-implies-clsmap-cxt-capset
         CML FM-DM (B1-L x) not-shared/unique N+FS=M3 (CM-B1-M3 x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-M3 x) (CM-B1-M4 x) M3+M4=M5 (CM-B1-M5 x))
    <- set`split-implies-permission-combine M0-M2=M4 B0+M0=>PiM0
      PiM2 PiM4 B0+M2=>PiM2 B0+M4=>PiM4 PiM0<=>PiM2+PiM4
    <- ({x} cxt-fresh-update-preserves-capset2perm
         B0+M4=>PiM4 N!<B0 (B0+N=B1 x) (B1+M4=>PiM4 x))
    <- letRefTyping-helper/base/unique/L1 _ SZ-S CM-B0-S S+FS=>M2 B0+M2=>PiM2
         B0+S=>GF N!<B0 ([x] B0+N=B1 x) M3Q
      ([x] PiM3 x) N+FS=>M3Q ([x] B1+M3Q=>PiM3 x) ([x] IMP x)
    <- nat+set2set-unique N+FS=>M3Q N+FS=M3 nat`eq/ set`eq/ M3Q=M3
    <- ({x} capset2perm-respects-eq (B1+M3Q=>PiM3 x) clsmap`eq/ predmap`eq/
         cxt`eq/ M3Q=M3 permission`eq/ (B1+M3=>PiM3 x))
    <- ({x} set`split-implies-permission-combine-converse
         (set`split/ M3^M4 M3+M4=M5) (B1+M3=>PiM3 x) (B1+M4=>PiM4 x) (PiM5 x)
         (B1+M5=>PiM5 x) (PiM3+PiM4<=>PiM5 x))
    <- letRefTyping-helper/base/unique/L5L2 _ SZ-S CM-B0-S B0+S=>GF B0=>PiB0
      PF3 T2PF-B ([x] IMP5 x)
    <- make-encumbered-intro S<=U0 U0-S=U1 B0+U0=>PiU0 PiS PiU1
      B0+S=>PiS B0+U1=>PiU1 (PiU0<=>PiS+PiU1:equiv PiU0 (PiS , PiU1))
    <- ({x} cxt-fresh-update-preserves-make-encumbered
         B0+U1=>PiU1 N!<B0 (B0+N=B1 x) (B1+U1=>PiU1 x))
    <- letRefTyping-helper/base/unique/L2** _ SZ-S T2PF-B
      CM-B0-S CML PML FM-DM B0+S=>PiS B0+S=>GF _ ([x] FS=>PF x) IMP2
    <- letRefTyping-helper/base/unique/L4L1* CM-CM CM2PM CML PML FM-DM FS=>PF
      (ty2perm/ PML NN2P annot2perm/unique) T2PF-B ([x] IMP3 x)
    <- letRefTyping-helper/base/unique/L4L2 CML FS=>PF B1-L M3P PiM3P N+FS=>M3P
      ([x] B1+M3P=>PiM3P x) ([x] IMP4 x) _
    <- nat+set2set-unique N+FS=>M3P N+FS=M3 nat`eq/ set`eq/ M3P=M3
    <- ({x} capset2perm-equiv (B1+M3P=>PiM3P x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ M3P=M3 (PiM3P<=>PiM3 x)).

- : letRefTyping-helper/base/unique/L5 SZ-S SZ-M
    CM-CM CM2PM (CM-B0:clsmap-cxt CM B0)
    (CML:clsmap`lookup CM C FM)
    (FM-DM:fldmap`domain FM FS)
    (S+FS=>M2: set+set2set S FS M2)
    (N!<B0: cxt`fresh B0 (s N))
    ([x] B0+N=B1 x)
    (M0-M2=M4:set`split M0 M2 M4)
    (S<=U0:set`leq S U0)
    (U0-S=U1: set`remove U0 S U1)
    (U1+SN=U2: set`add U1 (s N) U2)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (set`split/ M3^M4 M3+M4=M5)
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique (CML2:clsmap`lookup CM C FM2) CM-B0-S CM-B0-M1
        (wf-unique-targets/unique+fresh))
      (clsmap-cxt-env/ (CM-B0-U0: clsmap-cxt-objset CM B0 U0)
        (CM-B0-M0:clsmap-cxt-capset CM B0 M0)))
    (result2output/expr (B0=>PiB0:cxt2perm PM B0 PiB0)
      (env2input/ B0+U0=>PiU0 (B0+M0=>PiM0:capset2perm CM PM B0 M0 PiM0))
      (reftype2perm/unique+fresh
        (ty2perm/ (PML:predmap`lookup PM C CP)
          (NN2P:nn2perm _ _ PF) annot2perm/unique)
        ([x] B0+S=>GF x)
        (B0+M1=>PiM1:capset2perm CM PM B0 M1 PiM1))) _ _ _
    ([x] clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
    ([x] clsmap-cxt-env/
      (clsmap-cxt-objset/U (CM-B1-U1 x) (B1-L x) CML N!<U1 U1+SN=U2)
      (CM-B1-M5 x))
    ([x] env2input/
      (make-encumbered/U (B1+U1=>PiU1 x) (B1-L x) CML PML FM-DM FS=>PF
        N!<U1 U1+SN=U2) (B1+M5=>PiM5 x))
    ([x] cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/unique T2PF-B))
    (unique-encumbered-perm-format/unique+fresh SZ-S
      B0+S=>GF CML PML annot2perm/unique NN2P B0+M1=>PiM1
      B0+M2=>PiM2 B1+M3=>PiM3 B0+S=>PiS FM-DM FS=>PF)
    (transform/inside [x]
      (transform/inside [o]
        (transform/inside [p:permission]
          (transform/trans
            (transform/implies
              (implies/trans9
                (implies/equiv
                  (equiv/transitive
                    (equiv/identity)
                    (equiv/combine equiv/reflexive
                      (equiv/transitive
                        (equiv/symmetric equiv/associate)
                        (equiv/combine equiv/reflexive
                          (equiv/symmetric equiv/associate))))))
                (implies/combine
                  (implies/reflexive)
                  (implies/equiv (equiv/commute)))
                (implies/equiv (equiv/associate))
                (implies/equiv
                  (equiv/combine
                    (equiv/combine equiv/reflexive % PiB0
                      (equiv/combine equiv/reflexive % PF
                        (equiv/associate)))
                    (equiv/reflexive)))
                (implies/cond-push)
                (implies/cond-gen-inner)
                (implies/cond-inner
                  (bimplies/reflexive)
                  (bimplies/reflexive)
                  (implies/trans8
                    (implies/combine (implies/reflexive)
                      (implies/equiv
                        (equiv/transitive
                          (equiv/identity)
                          (equiv/roll2))))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans
                        (implies/combine
                          (implies/nonlinear bimplies/objequal-symmetric)
                          (implies/reflexive))
                        (implies/objequal ([v] (PF CP v))))
                      (implies/reflexive))
                    (implies/combine
                      (implies/trans (IMP3 x)
                        (implies/combine implies/reflexive (IMP4 x)))
                      (implies/combine
                        (implies/reflexive)
                        (implies/combine (implies/reflexive)
                          (implies/equiv
                            (equiv/transitive
                              (PiM0<=>PiM2+PiM4)
                              (equiv/commute))))))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine (implies/reflexive)
                      (implies/trans3
                        (implies/combine (implies/equiv (PiM3P<=>PiM3 x))
                          (implies/equiv (equiv/roll3)))
                        (implies/equiv equiv/associate)
                        (implies/combine (implies/equiv (PiM3+PiM4<=>PiM5 x))
                          (implies/reflexive))))
                    (implies/equiv
                      (equiv/transitive8
                        (equiv/combine equiv/reflexive % (X3 EC)
                          (equiv/transitive
                            (equiv/combine equiv/reflexive % PiM5
                              (equiv/combine equiv/reflexive % PiB0
                                (equiv/transitive
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/transitive3
                                      (equiv/combine PiU0<=>PiS+PiU1 equiv/reflexive)
                                      (equiv/symmetric equiv/associate)
                                      (equiv/combine equiv/reflexive equiv/commute))))))
                            (equiv/roll3)))
                        (equiv/symmetric equiv/associate)
                        (equiv/roll3)
                        (equiv/combine equiv/reflexive equiv/roll6)
                        (equiv/associate)
                        (equiv/combine equiv/reflexive equiv/roll5)
                        (equiv/associate)
                        (equiv/combine equiv/reflexive
                          (equiv/transitive3
                            (equiv/combine equiv/reflexive equiv/roll3)
                            (equiv/associate)
                            (equiv/combine equiv/reflexive
                              (equiv/transitive
                                (equiv/combine equiv/reflexive equiv/commute)
                                (equiv/associate)))))))
                    (implies/equiv equiv/commute))
                  (implies/trans9
                    (implies/combine
                      (implies/nonlinear2empty)
                      (implies/equiv (equiv/commute)))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/identity)))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/roll2)
                        (equiv/associate)))
                    (implies/combine (IMP5 x)
                      (implies/equiv
                        (equiv/combine equiv/reflexive
                          (equiv/symmetric equiv/associate))))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          (equiv/transitive
                            (equiv/combine equiv/reflexive equiv/commute)
                            (equiv/associate))
                          (equiv/transitive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/transitive
                                  (equiv/combine (PiU0<=>PiS+PiU1) (PiM0<=>PiM2+PiM4))
                                  (equiv/symmetric equiv/associate))))
                            (equiv/roll3)))
                        (equiv/swap-middle)))
                    (implies/trans3
                      (implies/combine
                        (implies/trans
                          (implies/equiv (equiv/symmetric equiv/associate))
                          (IMP2 x))
                        (implies/equiv equiv/roll5))
                      (implies/equiv (equiv/swap-middle))
                      (implies/combine (IMP x) implies/reflexive))
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/combine
                          (equiv/roll2)
                          (equiv/transitive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive % PiB0
                                (equiv/combine equiv/reflexive
                                  (equiv/combine equiv/reflexive equiv/commute))))
                            (equiv/roll5)))
                        (equiv/swap-middle)
                        (equiv/combine (PiM3+PiM4<=>PiM5 x) equiv/reflexive)))
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine equiv/reflexive % PiM5
                          (equiv/transitive
                            (equiv/combine equiv/reflexive % (GF , PiM3-+-PiM2)
                              (equiv/transitive
                                (equiv/combine (equiv/symmetric equiv/associate)
                                  (equiv/reflexive))
                                (equiv/symmetric equiv/associate)))
                            (equiv/symmetric equiv/associate)))
                        (equiv/combine equiv/reflexive
                          (equiv/combine equiv/reflexive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/transitive
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/combine equiv/reflexive
                                      (equiv/combine equiv/reflexive
                                        (equiv/combine equiv/reflexive
                                          (equiv/commute))))))))))))
                    (implies/equiv
                      (equiv/transitive7
                        (equiv/roll4)
                        (equiv/combine equiv/reflexive
                          (equiv/roll6))
                        (equiv/associate)
                        (equiv/combine equiv/reflexive
                          (equiv/transitive3
                            (equiv/roll4)
                            (equiv/combine equiv/reflexive equiv/roll6)
                            (equiv/associate)))
                        (equiv/associate)
                        (equiv/associate)
                        (equiv/combine (equiv/symmetric equiv/associate) equiv/reflexive)))))
                (implies/cond-pull)
                (implies/equiv equiv/commute)))
            (transform/reflexive)))))
    <- clsmap-cxt-objset-cxt-fresh-implies-not-member CM-B0-U0 N!<B0 N!<U0
    <- set`remove-implies-leq U0-S=U1 U1<=U0
    <- set`not-member-respects-geq N!<U0 U1<=U0 N!<U1
    <- clsmap-cxt-objset-respects-geq CM-B0-U0 U1<=U0 CM-B0-U1
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-objset CM-B0-U1
         N!<B0 (B0+N=B1 x) (CM-B1-U1 x))
    <- set`split-implies-leq M0-M2=M4 M2<=M0 M4<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M4<=M0 CM-B0-M4
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capset
         CM-B0-M4 N!<B0 (B0+N=B1 x) (CM-B1-M4 x))
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} nat+set2set-implies-clsmap-cxt-capset
         CML FM-DM (B1-L x) not-shared/unique N+FS=M3 (CM-B1-M3 x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-M3 x) (CM-B1-M4 x) M3+M4=M5 (CM-B1-M5 x))
    <- set`split-implies-permission-combine M0-M2=M4 B0+M0=>PiM0
      PiM2 PiM4 B0+M2=>PiM2 B0+M4=>PiM4 PiM0<=>PiM2+PiM4
    <- ({x} cxt-fresh-update-preserves-capset2perm
         B0+M4=>PiM4 N!<B0 (B0+N=B1 x) (B1+M4=>PiM4 x))
    <- letRefTyping-helper/base/unique/L1 _ SZ-S CM-B0-S S+FS=>M2 B0+M2=>PiM2
         B0+S=>GF N!<B0 ([x] B0+N=B1 x) M3Q
      ([x] PiM3 x) N+FS=>M3Q ([x] B1+M3Q=>PiM3 x) ([x] IMP x)
    <- nat+set2set-unique N+FS=>M3Q N+FS=M3 nat`eq/ set`eq/ M3Q=M3
    <- ({x} capset2perm-respects-eq (B1+M3Q=>PiM3 x) clsmap`eq/ predmap`eq/
         cxt`eq/ M3Q=M3 permission`eq/ (B1+M3=>PiM3 x))
    <- ({x} set`split-implies-permission-combine-converse
         (set`split/ M3^M4 M3+M4=M5) (B1+M3=>PiM3 x) (B1+M4=>PiM4 x) (PiM5 x)
         (B1+M5=>PiM5 x) (PiM3+PiM4<=>PiM5 x))
    <- letRefTyping-helper/base/unique/L5L2 _ SZ-S CM-B0-S B0+S=>GF B0=>PiB0
      PF3 T2PF-B ([x] IMP5 x)
    <- make-encumbered-intro S<=U0 U0-S=U1 B0+U0=>PiU0 PiS PiU1
      B0+S=>PiS B0+U1=>PiU1 (PiU0<=>PiS+PiU1:equiv PiU0 (PiS , PiU1))
    <- ({x} cxt-fresh-update-preserves-make-encumbered
         B0+U1=>PiU1 N!<B0 (B0+N=B1 x) (B1+U1=>PiU1 x))
    <- letRefTyping-helper/base/unique/L2** _ SZ-S T2PF-B
      CM-B0-S CML PML FM-DM B0+S=>PiS B0+S=>GF _ ([x] FS=>PF x) IMP2
    <- letRefTyping-helper/base/unique/L4L1* CM-CM CM2PM CML PML FM-DM FS=>PF
      (ty2perm/ PML NN2P annot2perm/unique) T2PF-B ([x] IMP3 x)
    <- letRefTyping-helper/base/unique/L4L2 CML FS=>PF B1-L M3P PiM3P N+FS=>M3P
      ([x] B1+M3P=>PiM3P x) ([x] IMP4 x) _
    <- nat+set2set-unique N+FS=>M3P N+FS=M3 nat`eq/ set`eq/ M3P=M3
    <- ({x} capset2perm-equiv (B1+M3P=>PiM3P x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ M3P=M3 (PiM3P<=>PiM3 x)).

%worlds (gtermvar)
  (letRefTyping-helper/base/unique/L5 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { }
  (letRefTyping-helper/base/unique/L5 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L
  : forall* {CM} {NN} {C} {FM} {FS} {S} {M2} {B0} {B1} {N} {M5}
    {M0} {M1} {M3} {M4} {PM} {Out} {U0} {U1} {U2} {W}
    forall {K1} {K2}
    {SZ-S: set`size S K1}
    {SZ-M1: set`size M1 K2}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B0: clsmap-cxt CM B0}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {S+FS=M2: set+set2set S FS M2}
    {N!<B1: cxt`fresh B0 (s N)}
    {B1+N=B2: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)}
    {S<=U0: set`leq S U0}
    {U0-S=U1: set`remove U0 S U1}
    {U1+N=U2: set`add U1 (s N) U2}
    {M0-M2=M4: set`split M0 M2 M4}
    {N+FS=M3: nat+set2set (s N) FS M3}
    {M5-M3=M4: set`split M5 M3 M4}
    {CM-Rslt: clsmap-result CM B0
              (result/expr (reftype/ NN C (targets/unique S M1 W)) (env/ U0 M0))}
    {Rslt=>Out: result2output CM PM B0
                (result/expr (reftype/ NN C (targets/unique S M1 W)) (env/ U0 M0)) Out}
    exists {Pi} {Pi2} {PiB1}
    {CM-B1: {x} clsmap-cxt CM (B1 x)}
    {CM-V: {x} clsmap-cxt-env CM (B1 x) (env/ U2 M5)}
    {V=>Pi: {x} env2input CM PM (B1 x) (env/ U2 M5) (Pi x)}
    {B1=>PiB1: {x} cxt2perm PM (B1 x) (PiB1 x)}
    {EC-FMT: unique-encumbered-perm-format CM PM B0 B1 S NN C M1 M2 M3 Pi2}
    {TRANS: transform Out
            (output/exists [x]
              (output/exists [o]
                (output/exists [p:permission]
                  (output/expr x ((Pi2 x o p) , ((PiB1 x) , Pi x))))))}
    true.

%%% This is the case where M1 is not empty:
%%% Two subcases: when S is empty and when S is not empty.
%%% If S is empty, all permissions for x come from M1, can we still register it
%%% as a unique variable?
- : letRefTyping-helper/base/unique/L z _ set`size/0 _
    CM-CM CM2PM CM-B0 CML FM-DM set+set2set/0
    N!<B0 B0+N=B1 S<=U0 (U0-S=U1:set`remove U0 set/0 U1)
    U1+N=U2 (M0-M2=M4:set`split M0 set/0 M4) N+FS=M3
    (M5-M3=M4:set`split M5 M3 M4)
    CM-Rslt Rslt=>Out _ _ _ CM-B1 CM-V V=>Pi B1=>PiB1 EC-FMT TRANS
    <- set`split-empty M0-M2=M4 (M4=M0:set`eq M4 M0)
    <- set`split-respects-eq M5-M3=M4 set`eq/ set`eq/ M4=M0 M5-M3=M0
    <- set`remove-empty-equal-self U0-S=U1 U0=U1
    <- set`eq-symmetric U0=U1 U1=U0
    <- set`add-respects-eq U1+N=U2 U1=U0 nat`eq/ set`eq/ U0+N=U2
    <- letRefTyping-helper/base/unique/L4 CM-CM CM2PM CM-B0 CML FM-DM N!<B0 B0+N=B1
      N+FS=M3 M5-M3=M0 U0+N=U2 CM-Rslt Rslt=>Out PiB1 Pi Pi2
      CM-B1 CM-V V=>Pi B1=>PiB1 EC-FMT TRANS.

- : letRefTyping-helper/base/unique/L (s _) _ SZ SZ-M
    CM-CM CM2PM CM-B0 CML FM-DM S+FS=M2 N!<B0 B0+N=B1 S<=U0 U0-S=U1 U1+N=U2 M0-M2=M4 N+FS=M3
    M5-M3=M4 CM-Rslt Rslt=>Out _ _ _ CM-B1 CM-V V=>Pi B1=>PiB1 EC-FMT TRANS
    <- letRefTyping-helper/base/unique/L5 SZ SZ-M CM-CM CM2PM CM-B0 CML FM-DM S+FS=M2
      N!<B0 B0+N=B1 M0-M2=M4 S<=U0 U0-S=U1 U1+N=U2 N+FS=M3 M5-M3=M4 CM-Rslt Rslt=>Out
      _ _ _ CM-B1 CM-V V=>Pi B1=>PiB1 EC-FMT TRANS.

%worlds (gtermvar)
  (letRefTyping-helper/base/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { }
  (letRefTyping-helper/base/unique/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique
  : forall* {CM} {NN} {C} {FM} {FS} {S} {M2} {B0} {B1} {N} {M5}
    {M0} {M1} {M3} {M4} {PM} {Out} {U0} {U1} {U2} {W}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B0: clsmap-cxt CM B0}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {S+FS=M2: set+set2set S FS M2}
    {N!<B1: cxt`fresh B0 (s N)}
    {B1+N=B2: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)}
    {S<=U0: set`leq S U0}
    {U0-S=U1: set`remove U0 S U1}
    {U1+N=U2: set`add U1 (s N) U2}
    {M0-M2=M4: set`split M0 M2 M4}
    {N+FS=M3: nat+set2set (s N) FS M3}
    {M5-M3=M4: set`split M5 M3 M4}
    {CM-Rslt: clsmap-result CM B0
              (result/expr (reftype/ NN C (targets/unique S M1 W)) (env/ U0 M0))}
    {Rslt=>Out: result2output CM PM B0
                (result/expr (reftype/ NN C (targets/unique S M1 W)) (env/ U0 M0)) Out}
    exists {Pi} {Pi2} {PiB1}
    {CM-B1: {x} clsmap-cxt CM (B1 x)}
    {CM-V: {x} clsmap-cxt-env CM (B1 x) (env/ U2 M5)}
    {V=>Pi: {x} env2input CM PM (B1 x) (env/ U2 M5) (Pi x)}
    {B1=>PiB1: {x} cxt2perm PM (B1 x) (PiB1 x)}
    {EC-FMT: unique-encumbered-perm-format CM PM B0 B1 S NN C M1 M2 M3 Pi2}
    {TRANS: transform Out
            (output/exists [x]
              (output/exists [o]
                (output/exists [p:permission]
                  (output/expr x ((Pi2 x o p) , ((PiB1 x) , Pi x))))))}
    true.

- : letRefTyping-helper/base/unique CM-CM CM2PM CM-B0 CML FM-DM S+FS=M2
    N!<B0 B0+N=B1 S<=U0 U0-S=U1 U1+N=U2 M0-M2=M4 N+FS=M3 M5-M3=M4
    CM-Rslt Rslt=>Out _ _ _ CM-B1 CM-V V=>Pi B1=>PiB1 EC-FMT TRANS
    <- set`size-total SZ-S
    <- set`size-total SZ-M1
    <- letRefTyping-helper/base/unique/L _ _ SZ-S SZ-M1 CM-CM CM2PM CM-B0 CML FM-DM S+FS=M2
    N!<B0 B0+N=B1 S<=U0 U0-S=U1 U1+N=U2 M0-M2=M4 N+FS=M3 M5-M3=M4
    CM-Rslt Rslt=>Out _ _ _ CM-B1 CM-V V=>Pi B1=>PiB1 EC-FMT TRANS.

%worlds (gtermvar)
  (letRefTyping-helper/base/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { }
  (letRefTyping-helper/base/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).




%theorem letRefTyping-helper/base/unique/L6L1L1
  : forall* {CM} {PM} {FM} {FS} {PiF} {BF} {N} {NN} {C} {M3} {PiM3}
    forall {CML: clsmap`lookup CM C FM}
    {FS=>PiF: {x} fldset2perm PM x FM FS (PiF x)}
    {BL: {x} cxt`lookup (BF x) (s N) (cxt-info/ x (ty/ NN annot/unique C))}
    {N+FS=M3: nat+set2set (s N) FS M3}
    {M3=>PiM3: {x} capset2perm CM PM (BF x) M3 (PiM3 x)}
    exists {IMP: {x} implies (PiM3 x) (unitperm (conditional (objequal x null) empty (PiF x)))}
    true.

- : letRefTyping-helper/base/unique/L6L1L1 CML BL FS=>PiF N+FS=>M3 M3=>PiM3
    ([x] implies/trans (implies/equiv (PiM3<=>PiM3P x)) (IMPP x))
    <- letRefTyping-helper/base/unique/L4L2 CML BL FS=>PiF M3P PiM3P N+FS=>M3P M3P=>PiM3P _ IMPP
    <- nat+set2set-unique N+FS=>M3 N+FS=>M3P nat`eq/ set`eq/ (M3=M3P:set`eq M3 M3P)
    <- ({x} capset2perm-equiv (M3=>PiM3 x) (M3P=>PiM3P x) clsmap`eq/ predmap`eq/ cxt`eq/
         M3=M3P (PiM3<=>PiM3P x)).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L1L1 _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L6L1L1 _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L6L1
  : forall* {CM} {PM} {BF} {N} {C} {NN} {FM} {FS} {CP} {M3} {PFB} {PiF} {PiM3}
    forall {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {NN2P: nn2perm NN ([_] empty) PFB}
    {DM: fldmap`domain FM FS}
    {BL: {x} cxt`lookup (BF x) (s N) (cxt-info/ x (ty/ NN annot/unique C))}
    {N+FS=M3: nat+set2set (s N) FS M3}
    {M3=>PiM3: {x} capset2perm CM PM (BF x) M3 (PiM3 x)}
    {FS=>PiF: {x} fldset2perm PM x FM FS (PiF x)}
    exists {PF} {T2PF: ty2perm PM (ty/ NN annot/unique C) PF}
    {IMP: {x} implies
          (combine (PiM3 x)
            (combine (PFB CP x)
              (unitperm
                (conditional (objequal x null)
                  (empty)
                  (unitperm (encumbered (PiF x) (combine (allperm x) (one-predcall CP x))))))))
          (PF x)}
    true.

%{
- : letRefTyping-helper/base/unique/L6L1 CML PML nn2perm/yes DM BL N+FS=M3
    M3=>PiM3 FS=>PiF _ (ty2perm/ PML nn2perm/yes annot2perm/unique)
    ([x] implies/trans6
      (KK x)
      (implies/combine (IMP x) (implies/reflexive))
      (implies/equiv equiv/roll2)
      (implies/combine
        (implies/trans
          (implies/combine implies/duplicate
            (implies/trans
              (implies/combine implies/reflexive implies/nonlinear2empty)
              (implies/equiv equiv/identity)))
          (implies/equiv equiv/identity))
        (implies/trans
          (implies/cond-factor)
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/equiv equiv/identity)
            (implies/linear-modus-ponens))))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive
        (implies/trans
          (implies/combine implies/reflexive implies/cond-neg)
          (implies/cond-elim))))
    <- letRefTyping-helper/base/unique/L6L1L1 CML FS=>PiF BL N+FS=M3 M3=>PiM3 IMP.

- : letRefTyping-helper/base/unique/L6L1 CML PML nn2perm/may DM BL N+FS=M3
    M3=>PiM3 FS=>PiF _ (ty2perm/ PML nn2perm/may annot2perm/unique)
    ([x] implies/trans4
      (implies/combine (IMP x) (implies/reflexive))
      (implies/equiv equiv/roll2)
      (implies/combine
        (implies/trans
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/equiv equiv/reflexive)
            (implies/trans
              (implies/combine implies/reflexive implies/nonlinear2empty)
              (implies/equiv equiv/identity)))
          (implies/cond-equal))
        (implies/trans
          (implies/cond-factor)
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/equiv equiv/identity)
            (implies/linear-modus-ponens))))
      (implies/equiv (equiv/transitive equiv/commute equiv/identity)))
    <- letRefTyping-helper/base/unique/L6L1L1 CML FS=>PiF BL N+FS=M3 M3=>PiM3 IMP.
}%

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L1 _ _ _ _ _ _ _ _ _ _ _).
%trustme %total { } (letRefTyping-helper/base/unique/L6L1 _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L6L2
  : forall* {CP1} {CP2}
    forall {PF: clspred -> object -> permission} {CPE: {x} clspred`eq (CP1 x) CP2}
    exists {PE: {x} equiv (PF (CP1 x) x) (PF CP2 x)}
    true.

- : letRefTyping-helper/base/unique/L6L2 _ ([_] clspred`eq/) ([_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L2 _ _ _).
%total { } (letRefTyping-helper/base/unique/L6L2 _ _ _).


%theorem letRefTyping-helper/base/unique/L6L3
  : forall* {PiFS3} {PiFS1} {CP3} {CP}
    forall {PiFS3=PiF: {x} permission`eq (PiFS3 x) (PiFS1 x)}
    {CPE: clspred`eq CP3 CP}
    exists {EQV: {x} equiv (unitperm
                   (conditional (objequal x null) empty
                     (unitperm
                       (encumbered (PiFS3 x)
                         (combine (allperm x)
                           (one-predcall CP3 x))))))
                 (unitperm
                   (conditional (objequal x null) empty
                     (unitperm
                       (encumbered (PiFS1 x)
                         (combine (allperm x)
                           (one-predcall CP x))))))}
    true.

- : letRefTyping-helper/base/unique/L6L3
    ([_] permission`eq/) clspred`eq/ ([_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L3 _ _ _).
%total { } (letRefTyping-helper/base/unique/L6L3 _ _ _).


%theorem letRefTyping-helper/base/unique/L6L4
  : forall* {CP1:object -> clspred} {CP2}
    forall {PF: clspred -> object -> permission} {CPE: {x} clspred`eq (CP1 x) CP2}
    exists {PE: {v}{x} equiv (PF (CP1 v) x) (PF CP2 x)}
    true.

- : letRefTyping-helper/base/unique/L6L4 _ ([_] clspred`eq/) ([_][_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L4 _ _ _).
%total { } (letRefTyping-helper/base/unique/L6L4 _ _ _).


%theorem letRefTyping-helper/base/unique/L6L5
  : forall* {OK: object -> object} {CP3} {PiU4'} {CP3F: object -> clspred}
    forall {PiFS3P: object -> object -> permission}
    {CPE: {x} clspred`eq (CP3F x) CP3} {OE: {x} object`eq (OK x) x}
    exists {EQV: {x} equiv (combine
                             (unitperm
                               (conditional (objequal (OK x) null)
                                 empty
                                 (unitperm
                                   (encumbered (PiFS3P x (OK x))
                                     (combine (allperm (OK x))
                                       (one-predcall (CP3F x)
                                         (OK x)))))))
                             (PiU4' x))
                 (combine
                   (unitperm
                     (conditional (objequal x null)
                       empty
                       (unitperm
                         (encumbered (PiFS3P x x)
                           (combine (allperm x)
                             (one-predcall CP3 x))))))
                   (PiU4' x))}
    true.

- : letRefTyping-helper/base/unique/L6L5
    _ ([_] clspred`eq/) ([_] object`eq/) ([_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L5 _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L6L5 _ _ _ _).


%theorem letRefTyping-helper/base/unique/L6L6
  : forall* {GFF: object -> object -> permission} {GF}
    forall {GFF=GF: {x}{o} permission`eq (GFF o x) (GF o)}
    exists {EQV: {x}{v}{u} equiv
                 (unitperm (conditional (objequal v u) empty (GFF v x)))
                 (unitperm (conditional (objequal v u) empty (GF v)))}
    true.

- : letRefTyping-helper/base/unique/L6L6 ([_][_] permission`eq/) ([_][_][_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L6 _ _).
%total { } (letRefTyping-helper/base/unique/L6L6 _ _).


%theorem letRefTyping-helper/base/unique/L6L7
  : forall* {CP2F: object -> clspred} {CP2} {PiM11F} {PiM11}
    forall {PF2: clspred -> object -> permission}
    {PEQ: {x} predicate`eq (CP2F x) CP2}
    {EQ: {x} permission`eq (PiM11F x) PiM11}
    exists
    {EQV: {x}{x2} equiv
          (combine (PF2 (CP2F x) x2)
            (unitperm
              (encumbered (PF2 (CP2F x) x2)
                (PiM11F x))))
          (combine (PF2 CP2 x2)
            (unitperm
              (encumbered (PF2 CP2 x2) PiM11)))}
    true.

- : letRefTyping-helper/base/unique/L6L7 _ ([_] clspred`eq/)
    ([_] permission`eq/) ([_][_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L7 _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L6L7 _ _ _ _).


%theorem letRefTyping-helper/base/unique/L6L8
  : forall* {OK: object -> object} {CP3F: object -> clspred}
    {PiFS1: object -> permission} {CP}
    forall {PiFS3P: object -> object -> permission}
    {EQ: {x}{o} permission`eq (PiFS3P x o) (PiFS1 o)}
    {CPE: {x} clspred`eq (CP3F x) CP} {OE: {x} object`eq (OK x) x}
    exists {EQV: {x:object} equiv
                        (unitperm
                          (conditional (objequal (OK x) null)
                            empty
                            (unitperm
                              (encumbered (PiFS3P x (OK x))
                                (combine (allperm (OK x))
                                  (one-predcall (CP3F x)
                                    (OK x)))))))
                 (unitperm
                   (conditional (objequal x null) empty
                     (unitperm
                       (encumbered (PiFS1 x)
                         (combine (allperm x)
                           (one-predcall CP x))))))}
    true.

- : letRefTyping-helper/base/unique/L6L8
    _ ([_][_] permission`eq/) ([_] clspred`eq/) ([_] object`eq/) ([_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L8 _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L6L8 _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L6L9
  : forall* {PiFS3P:object -> object -> permission}
    {PiFS3: object -> permission} {PiFS1: object -> permission}
    forall {PiFS3P=PiFS3:{x:gterm objectk} {x1:gterm objectk}
                       gterm#eq (PiFS3P x x1) (PiFS3 x1)}
    {P-EQ:{x:gterm objectk} gterm#eq (PiFS3 x) (PiFS1 x)}
    exists {PiFS3P=PiFS1:{x:gterm objectk} {x1:gterm objectk}
                          gterm#eq (PiFS3P x x1) (PiFS1 x1)}
    true.

- : letRefTyping-helper/base/unique/L6L9 ([_][_] permission`eq/)
    ([_] permission`eq/) ([_][_] permission`eq/).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L9 _ _ _).
%total { } (letRefTyping-helper/base/unique/L6L9 _ _ _).


%theorem letRefTyping-helper/base/unique/L6L10
  : forall* {GF1F} {GF1}
    forall {GF1F=GF1:{x:gterm objectk} {x1:gterm objectk} permission`eq (GF1F x1 x) (GF1 x1)}
    exists {EQV: {x}{x2}{x3} equiv
                 (unitperm
                   (conditional (objequal x2 x3) empty
                     (GF1F x2 x)))
                 (unitperm
                   (conditional (objequal x2 x3) empty
                     (GF1 x2)))}
    true.

- : letRefTyping-helper/base/unique/L6L10 ([_][_] permission`eq/) ([_][_][_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L10 _ _).
%total { } (letRefTyping-helper/base/unique/L6L10 _ _).


%theorem letRefTyping-helper/base/unique/L6L11
  : forall* {CP2F: object -> clspred} {CP2} {PiM11F} {PiM11}
    forall {PF2: clspred -> object -> permission}
    {PEQ: {x} predicate`eq (CP2F x) CP2}
    {EQ: {x} permission`eq (PiM11F x) PiM11}
    exists
    {EQV: {x}{x2}{p:permission} equiv
          (combine (PF2 (CP2F x) x2)
            (unitperm
              (encumbered (PF2 (CP2F x) x2)
                (combine (PiM11F x) p))))
          (combine (PF2 CP2 x2)
            (unitperm
              (encumbered (PF2 CP2 x2) (combine PiM11 p))))}
    true.

- : letRefTyping-helper/base/unique/L6L11 _ ([_] clspred`eq/)
    ([_] permission`eq/) ([_][_][_] equiv/reflexive).

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6L11 _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L6L11 _ _ _ _).


%theorem letRefTyping-helper/base/unique/L6/shared
  : forall* {CM} {PM} {B1:object -> cxt} {B0} {N} {U3} {U4} {U5}
    {M1} {M2} {M3} {M6} {M7} {M8} {M9} {Out}
    {Pi2} {S} {NN} {C} {NN1} {C1} {FM} {FS}
    forall {N!<B0: cxt`fresh B0 (s N)}
    {B0+SN=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {N+FS=>M3: nat+set2set (s N) FS M3}
    {EC-FMT: unique-encumbered-perm-format CM PM B0 B1 S NN C M1 M2 M3 Pi2}
    {R2=>Out2: {x} result2output CM PM (B1 x)
               (result/expr (reftype/ NN1 C1 targets/shared) (env/ U3 M6)) (Out x)}
    {M6-M3=M7: set`split M6 M3 M7}
    {M8=M2+M7: set`split M8 M2 M7}
    {M9=M1+M8: set`split M9 M1 M8}
    {SN!<U4: set`not-member U4 (s N)}
    {U4+SN=U3: set`add U4 (s N) U3}
    {U4+S=U5: set`union U4 S U5}
    exists {Out2} {Out3}
    {EA: {x}{o}{p:permission} envadd (Pi2 x o p) (Out x) (Out2 x o p)}
    {R2'=>Out3: result2output CM PM B0
                (result/expr (reftype/ NN1 C1 targets/shared) (env/ U5 M9)) Out3}
    {TRANS: transform
            (output/exists [x]
              (output/exists [o]
                (output/exists [p]
                  (Out2 x o p)))) Out3}
    true.

%%% case 1: fresh
- : letRefTyping-helper/base/unique/L6/shared
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/fresh set`size/0
      (ty2perm/ (PML1:predmap`lookup PM C CP) (NN2P1:nn2perm NN _ PF1) annot2perm/unique)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
    ([x] result2output/expr (B1=>PiB1 x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/shared
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/shared)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 set/0 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 set/0 U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU4:make-encumbered CM PM B0 U5 PiU4)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/shared
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/shared)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [x1]
            (transform/inside [o1]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans8
                      (implies/combine implies/reflexive
                        (implies/trans3
                          (implies/equiv equiv/identity)
                          (implies/combine implies/reflexive (implies/equiv equiv/commute))
                          (implies/equiv equiv/reorder)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/combine
                            (implies/trans
                              (implies/equiv (PiU3<=>PiFS3P+PiU4' x))
                              (implies/combine (implies/equiv (EQV5 x))
                                (implies/equiv (PiU4'<=>PiU4 x))))
                            (implies/equiv (PiM6F<=>PiM3F+PiM7F x))))
                        (implies/combine
                          (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                            (implies/combine implies/reflexive
                              (implies/equiv (PiB0F<=>PiB0 x))))
                          (implies/reflexive)))
                      (implies/combine implies/reflexive
                        (implies/equiv (equiv/symmetric equiv/associate)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans4
                          (implies/equiv (equiv/symmetric equiv/associate))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/equiv
                                (equiv/transitive5
                                  (equiv/commute)
                                  (equiv/combine equiv/reflexive
                                    (equiv/symmetric equiv/associate))
                                  (equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/reorder))
                                  (equiv/associate)))
                              (implies/combine
                                (implies/trans3
                                  (implies/equiv equiv/commute)
                                  (implies/combine implies/reflexive
                                    (implies/combine (implies/equiv (EQV x))
                                      (implies/reflexive)))
                                  (IMP x))
                                (implies/reflexive))))
                          (implies/trans3
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans3
                                (implies/equiv equiv/commute)
                                (implies/combine (implies/equiv (EQV2 x)) implies/reflexive)
                                (implies/linear-modus-ponens))
                              (implies/reflexive))
                            (implies/equiv equiv/reorder))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/combine implies/reflexive
                                (implies/equiv (PiM7F<=>PiM7 x)))
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/swap)
                                  (equiv/combine (PiM1+PiM7<=>PiM9) equiv/reflexive))))))
                        (implies/reflexive))
                      (implies/trans6
                        (implies/equiv equiv/commute)
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine implies/reflexive
                          (implies/combine (implies/equiv (EQV4 x x1)) implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/equiv equiv/commute))
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            (equiv/reflexive)
                            (equiv/transitive
                              (equiv/combine
                                (equiv/transitive
                                  (equiv/combine equiv/reflexive
                                    (equiv/combine equiv/reflexive
                                      (equiv/combine equiv/reflexive equiv/commute)))
                                  (equiv/roll4))
                                (equiv/reflexive))
                              (equiv/symmetric-associate)))
                          (equiv/associate)))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- set`union-unique set`union/R U4+S=U5 set`eq/ set`eq/ U4=U5
    <- make-encumbered-respects-eq U4=>PiU4 clsmap`eq/ predmap`eq/ cxt`eq/
      U4=U5 permission`eq/ U5=>PiU4
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-empty M8=M2+M7 M7=M8
    <- set`eq-symmetric M7=M8 M8=M7
    <- capset2perm-respects-eq M7=>PiM7 clsmap`eq/ predmap`eq/ cxt`eq/ M7=M8 permission`eq/
      M8=>PiM7
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM7 PiM9 M9=>PiM9 PiM1+PiM7<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS3 CP3F=CP3 OE EQV5
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 annot2perm/unique) predmap`eq/ ty`eq/ PF-EQ
  <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x)).

%%% case 2: borrow
- : letRefTyping-helper/base/unique/L6/shared
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/borrow set`size/0 _
      (ty2perm/ (PML1:predmap`lookup PM C CP) (NN2P1:nn2perm NN _ PF1) annot2perm/unique)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
    ([x] result2output/expr (B1=>PiB1 x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/shared
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/shared)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 set/0 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 set/0 U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU4:make-encumbered CM PM B0 U5 PiU4)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/shared
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/shared)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [x1]
            (transform/inside [o1]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans7
                      (implies/combine implies/reflexive
                        (implies/trans3
                          (implies/equiv equiv/identity)
                          (implies/combine implies/reflexive (implies/equiv equiv/commute))
                          (implies/equiv equiv/reorder)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/combine
                            (implies/trans
                              (implies/equiv (PiU3<=>PiFS3P+PiU4' x))
                              (implies/combine (implies/equiv (EQV5 x))
                                (implies/equiv (PiU4'<=>PiU4 x))))
                            (implies/equiv (PiM6F<=>PiM3F+PiM7F x))))
                        (implies/combine
                          (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                            (implies/combine implies/reflexive
                              (implies/equiv (PiB0F<=>PiB0 x))))
                          (implies/reflexive)))
                      (implies/combine implies/reflexive
                        (implies/equiv (equiv/symmetric equiv/associate)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans4
                          (implies/equiv (equiv/symmetric equiv/associate))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/equiv
                                (equiv/transitive5
                                  (equiv/commute)
                                  (equiv/combine equiv/reflexive
                                    (equiv/symmetric equiv/associate))
                                  (equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/reorder))
                                  (equiv/associate)))
                              (implies/combine
                                (implies/trans3
                                  (implies/equiv equiv/commute)
                                  (implies/combine implies/reflexive
                                    (implies/combine (implies/equiv (EQV x))
                                      (implies/reflexive)))
                                  (IMP x))
                                (implies/reflexive))))
                          (implies/trans3
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans3
                                (implies/equiv equiv/commute)
                                (implies/combine (implies/equiv (EQV2 x)) implies/reflexive)
                                (implies/linear-modus-ponens))
                              (implies/reflexive))
                            (implies/equiv equiv/reorder))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/combine implies/reflexive
                                (implies/equiv (PiM7F<=>PiM7 x)))
                              (implies/equiv (PiM1+PiM7<=>PiM9)))))
                        (implies/reflexive))
                      (implies/trans6
                        (implies/equiv equiv/commute)
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine implies/reflexive
                          (implies/combine (implies/equiv (EQV4 x x1)) implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/equiv equiv/commute))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- set`union-unique set`union/R U4+S=U5 set`eq/ set`eq/ U4=U5
    <- make-encumbered-respects-eq U4=>PiU4 clsmap`eq/ predmap`eq/ cxt`eq/
      U4=U5 permission`eq/ U5=>PiU4
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-empty M8=M2+M7 M7=M8
    <- set`eq-symmetric M7=M8 M8=M7
    <- capset2perm-respects-eq M7=>PiM7 clsmap`eq/ predmap`eq/ cxt`eq/ M7=M8 permission`eq/
      M8=>PiM7
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM7 PiM9 M9=>PiM9 PiM1+PiM7<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS3 CP3F=CP3 OE EQV5
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 annot2perm/unique) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x)).

%%% case 3: shared + unique
- : letRefTyping-helper/base/unique/L6/shared
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique _ _
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr (B1=>PiB1 x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/shared
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/shared)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/shared
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/shared)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [v]
              (transform/inside [u]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans5
                        (implies/combine implies/reflexive % FIRST HALF
                          (implies/trans3
                            (implies/equiv equiv/identity)
                            (implies/combine
                              (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                                (implies/combine implies/reflexive
                                  (implies/equiv (PiB0F<=>PiB0 x))))
                              (implies/combine implies/reflexive % PF1
                                (implies/trans
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive
                                          (PiU3<=>PiFS3P+PiU4' x)
                                          (EQV5 x)))
                                      (implies/combine
                                        (implies/cond-inner
                                          (bimplies/reflexive)
                                          (bimplies/reflexive)
                                          (implies/reflexive)
                                          (implies/equiv-encumbered
                                            (PiFS3P<=>PiFS3 x x)
                                            (equiv/reflexive)))
                                        (implies/equiv (PiU4'<=>PiU4 x))))
                                    (implies/trans
                                      (implies/equiv (PiM6<=>PiM3F+PiM7F x))
                                      (implies/combine implies/reflexive
                                        (implies/equiv (PiM7F<=>PiM7 x)))))
                                  (implies/equiv equiv/swap-middle))))
                            (implies/equiv
                              (equiv/transitive4
                                (equiv/combine equiv/reflexive equiv/roll2)
                                (equiv/associate)
                                (equiv/combine equiv/swap equiv/reflexive)
                                (equiv/symmetric equiv/associate)))))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans5
                            (implies/equiv equiv/commute)
                            (implies/cond-push)
                            (implies/cond-gen-inner)
                            (implies/cond-inner
                              (bimplies/reflexive)
                              (bimplies/reflexive)
                              (implies/trans6
                                (implies/combine implies/reflexive
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive3
                                          (equiv/combine equiv/reflexive equiv/commute)
                                          (equiv/roll2)
                                          (equiv/combine
                                            (equiv/reflexive)
                                            (equiv/combine (EQV x) equiv/reflexive))))
                                      (IMP x))
                                    (implies/reflexive)))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/objequal PF)
                                    (implies/equiv (EQV2 o)))
                                  (implies/reflexive))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/linear-modus-ponens)
                                      (implies/reflexive)))
                                  (implies/reflexive))
                                (implies/equiv (equiv/symmetric equiv/identity)))
                              (implies/trans5
                                (implies/combine (implies/nonlinear2empty)
                                  (implies/reflexive))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/commute)
                                    (equiv/identity)))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/symmetric equiv/associate)
                                    (equiv/combine equiv/reflexive
                                      (equiv/symmetric equiv/associate))))
                                (implies/combine
                                  (implies/reflexive)
                                  (implies/trans5
                                    (implies/combine implies/reflexive
                                      (implies/equiv equiv/roll4))
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/trans
                                        (implies/combine
                                          (implies/equiv (EQV3 x))
                                          (implies/reflexive))
                                        (implies/linear-modus-ponens))
                                      (implies/reflexive))
                                    (implies/combine implies/reflexive % PiS
                                      (implies/trans3
                                        (implies/combine implies/reflexive
                                          (implies/equiv equiv/reorder))
                                        (implies/equiv equiv/associate)
                                        (implies/combine
                                          (implies/trans
                                            (implies/combine
                                              (implies/equiv (PiM3F<=>PiM3 x))
                                              (implies/reflexive))
                                            (implies/linear-modus-ponens))
                                          (implies/combine implies/reflexive
                                            implies/linear-modus-ponens))))
                                    (implies/equiv
                                      (equiv/transitive3
                                        (equiv/combine equiv/reflexive
                                          (equiv/transitive3
                                            (equiv/combine equiv/reflexive equiv/commute)
                                            (equiv/associate)
                                            (equiv/combine equiv/commute equiv/reflexive)))
                                        (equiv/associate)
                                        (equiv/combine equiv/commute equiv/reflexive)))))
                                (implies/equiv equiv/roll2)))
                            (implies/cond-pull))
                          (implies/reflexive))
                        (implies/equiv
                          (equiv/transitive6
                            (equiv/symmetric equiv/associate)
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/combine equiv/reflexive
                                  (equiv/commute))))
                            (equiv/combine equiv/reflexive
                              (equiv/roll3))
                            (equiv/associate)
                            (equiv/combine
                              (equiv/transitive3
                                (equiv/commute)
                                (equiv/combine equiv/commute equiv/reflexive)
                                (equiv/swap-middle))
                              (equiv/reflexive))
                            (equiv/combine
                              (equiv/combine
                                (equiv/transitive4
                                  (equiv/commute)
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (PiM2+PiM7<=>PiM8))
                                  (PiM1+PiM8<=>PiM9))
                                (PiU4+PiS<=>PiU5))
                              (equiv/reflexive))))
                        (implies/equiv
                          (equiv/transitive
                            (equiv/roll2)
                            (equiv/combine equiv/reflexive
                              (equiv/transitive3
                                (equiv/roll2)
                                (equiv/combine equiv/reflexive
                                  (equiv/transitive
                                    (equiv/commute)
                                    (equiv/combine (EQV4 x v) equiv/commute)))
                                (equiv/symmetric equiv/identity)))))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- ({x}{o} permission`eq-implies-equiv (PiFS3P=PiFS3 x o) (PiFS3P<=>PiFS3 x o))
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6 x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM8 PiM9 M9=>PiM9 PiM1+PiM8<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L5 PiFS3P CP3F=CP3 OE EQV5.

%%% unique + fresh
- : letRefTyping-helper/base/unique/L6/shared
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique+fresh _
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr (B1=>PiB1 x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/shared
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/shared)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/shared
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/shared)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [v]
              (transform/inside [u]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans6
                        (implies/combine implies/reflexive % FIRST HALF
                          (implies/trans3
                            (implies/equiv equiv/identity)
                            (implies/combine
                              (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                                (implies/combine implies/reflexive
                                  (implies/equiv (PiB0F<=>PiB0 x))))
                              (implies/combine implies/reflexive % PF1
                                (implies/trans
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive
                                          (PiU3<=>PiFS3P+PiU4' x)
                                          (EQV5 x)))
                                      (implies/combine
                                        (implies/cond-inner
                                          (bimplies/reflexive)
                                          (bimplies/reflexive)
                                          (implies/reflexive)
                                          (implies/equiv-encumbered
                                            (PiFS3P<=>PiFS3 x x)
                                            (equiv/reflexive)))
                                        (implies/equiv (PiU4'<=>PiU4 x))))
                                    (implies/trans
                                      (implies/equiv (PiM6<=>PiM3F+PiM7F x))
                                      (implies/combine implies/reflexive
                                        (implies/equiv (PiM7F<=>PiM7 x)))))
                                  (implies/equiv equiv/swap-middle))))
                            (implies/equiv
                              (equiv/transitive4
                                (equiv/combine equiv/reflexive equiv/roll2)
                                (equiv/associate)
                                (equiv/combine equiv/swap equiv/reflexive)
                                (equiv/symmetric equiv/associate)))))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans5
                            (implies/equiv equiv/commute)
                            (implies/cond-push)
                            (implies/cond-gen-inner)
                            (implies/cond-inner
                              (bimplies/reflexive)
                              (bimplies/reflexive)
                              (implies/trans6
                                (implies/combine implies/reflexive
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive3
                                          (equiv/combine equiv/reflexive equiv/commute)
                                          (equiv/roll2)
                                          (equiv/combine
                                            (equiv/reflexive)
                                            (equiv/combine (EQV x) equiv/reflexive))))
                                      (IMP x))
                                    (implies/reflexive)))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/objequal PF)
                                    (implies/equiv (EQV2 o)))
                                  (implies/reflexive))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/linear-modus-ponens)
                                      (implies/reflexive)))
                                  (implies/reflexive))
                                (implies/equiv (equiv/symmetric equiv/identity)))
                              (implies/trans5
                                (implies/combine (implies/nonlinear2empty)
                                  (implies/reflexive))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/commute)
                                    (equiv/identity)))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/symmetric equiv/associate)
                                    (equiv/combine equiv/reflexive
                                      (equiv/symmetric equiv/associate))))
                                (implies/combine
                                  (implies/reflexive)
                                  (implies/trans5
                                    (implies/combine implies/reflexive
                                      (implies/equiv equiv/roll4))
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/trans
                                        (implies/combine
                                          (implies/equiv (EQV3 x))
                                          (implies/reflexive))
                                        (implies/linear-modus-ponens))
                                      (implies/reflexive))
                                    (implies/combine implies/reflexive % PiS
                                      (implies/trans3
                                        (implies/combine implies/reflexive
                                          (implies/equiv equiv/reorder))
                                        (implies/equiv equiv/associate)
                                        (implies/combine
                                          (implies/trans
                                            (implies/combine
                                              (implies/equiv (PiM3F<=>PiM3 x))
                                              (implies/reflexive))
                                            (implies/linear-modus-ponens))
                                          (implies/combine implies/reflexive
                                            implies/linear-modus-ponens))))
                                    (implies/equiv
                                      (equiv/transitive3
                                        (equiv/combine equiv/reflexive
                                          (equiv/transitive3
                                            (equiv/combine equiv/reflexive equiv/commute)
                                            (equiv/associate)
                                            (equiv/combine equiv/commute equiv/reflexive)))
                                        (equiv/associate)
                                        (equiv/combine equiv/commute equiv/reflexive)))))
                                (implies/equiv equiv/roll2)))
                            (implies/cond-pull))
                          (implies/reflexive))
                        (implies/equiv
                          (equiv/transitive6
                            (equiv/symmetric equiv/associate)
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/combine equiv/reflexive
                                  (equiv/commute))))
                            (equiv/combine equiv/reflexive
                              (equiv/roll3))
                            (equiv/associate)
                            (equiv/combine
                              (equiv/transitive3
                                (equiv/commute)
                                (equiv/combine equiv/commute equiv/reflexive)
                                (equiv/swap-middle))
                              (equiv/reflexive))
                            (equiv/combine
                              (equiv/combine
                                (equiv/transitive4
                                  (equiv/commute)
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (PiM2+PiM7<=>PiM8))
                                  (equiv/transitive equiv/swap
                                    (equiv/combine PiM1+PiM8<=>PiM9 equiv/reflexive)))
                                (PiU4+PiS<=>PiU5))
                              (equiv/reflexive))))
                        (implies/equiv
                          (equiv/transitive
                            (equiv/roll2)
                            (equiv/combine equiv/reflexive
                              (equiv/transitive3
                                (equiv/roll2)
                                (equiv/combine equiv/reflexive
                                  (equiv/transitive
                                    (equiv/commute)
                                    (equiv/combine (EQV4 x v) equiv/commute)))
                                (equiv/symmetric equiv/identity)))))
                        (implies/equiv
                          (equiv/transitive
                            (equiv/combine equiv/reflexive
                              (equiv/transitive
                                (equiv/combine
                                  (equiv/transitive
                                    (equiv/combine equiv/reflexive
                                      (equiv/combine equiv/reflexive
                                        (equiv/combine equiv/reflexive equiv/commute)))
                                    (equiv/roll4))
                                  (equiv/reflexive))
                                (equiv/symmetric-associate)))
                            (equiv/associate)))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- ({x}{o} permission`eq-implies-equiv (PiFS3P=PiFS3 x o) (PiFS3P<=>PiFS3 x o))
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6 x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM8 PiM9 M9=>PiM9 PiM1+PiM8<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L5 PiFS3P CP3F=CP3 OE EQV5.

%%% case 4: unique/2
- : letRefTyping-helper/base/unique/L6/shared
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique/2 _ set`size/0
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr (B1=>PiB1 x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/shared
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/shared)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 set/0 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] envadd/expr))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM8:capset2perm CM PM B0 M9 PiM8))
      (reftype2perm/shared
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/shared)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [x1]
            (transform/inside [o1]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans4
                      (implies/equiv
                        (equiv/transitive % TRANS 2ND part
                          (equiv/combine
                            (equiv/reflexive)
                            (equiv/transitive3
                              (equiv/identity)
                              (equiv/combine
                                (equiv/transitive (PiB1<=>PF1+PiB0F x)
                                  (equiv/combine equiv/reflexive (PiB0F<=>PiB0 x)))
                                (equiv/combine (equiv/reflexive)
                                  (equiv/combine
                                    (equiv/transitive
                                      (PiU3<=>PiFS3P+PiU4' x)
                                      (equiv/combine (EQV5 x) (PiU4'<=>PiU4 x)))
                                    (equiv/transitive
                                      (PiM6F<=>PiM3F+PiM7F x)
                                      (equiv/combine (PiM3F<=>PiM3 x) (PiM7F<=>PiM7 x))))))
                              (equiv/transitive
                                (equiv/combine equiv/reflexive equiv/commute)
                                (equiv/roll2))))
                          (equiv/associate)))
                      (implies/combine
                        (implies/trans5
                          (implies/combine implies/reflexive
                            (implies/equiv equiv/swap-middle))
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/trans
                              (implies/equiv equiv/swap)
                              (implies/combine
                                (implies/trans4
                                  (implies/equiv equiv/swap)
                                  (implies/combine
                                    (implies/trans % (S -|- PiS GF PiM3 -|- PiM2) (S PiM3)
                                      (implies/equiv equiv/associate)
                                      (implies/combine
                                        (implies/trans
                                          (implies/equiv equiv/commute)
                                          (implies/linear-modus-ponens))
                                        (implies/reflexive)))
                                    (implies/reflexive))
                                  (implies/equiv equiv/swap-middle)
                                  (implies/combine
                                    (implies/reflexive)
                                    (implies/linear-modus-ponens)))
                                (implies/reflexive)))
                            (implies/reflexive))
                          (implies/equiv equiv/swap)
                          (implies/combine
                            (implies/trans
                              (implies/equiv equiv/swap-middle)
                              (implies/combine
                                (implies/trans
                                  (implies/equiv equiv/swap)
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv equiv/commute)
                                      (implies/equiv (PiU4+PiS<=>PiU5)))
                                    (implies/reflexive)))
                                (implies/equiv
                                  (PiM2+PiM7<=>PiM8))))
                            (implies/reflexive)))
                        (implies/reflexive))
                      (implies/equiv
                        (equiv/transitive3
                          (equiv/combine
                            (equiv/transitive3
                              (equiv/combine equiv/swap equiv/reflexive)
                              (equiv/symmetric equiv/associate)
                              (equiv/commute))
                            (equiv/symmetric equiv/associate))
                          (equiv/swap-middle)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive
                              (equiv/reorder)
                              (equiv/combine equiv/reflexive equiv/commute)))))
                      (implies/combine (implies/reflexive)
                        (implies/trans
                          (implies/combine (implies/reflexive)
                            (implies/combine (implies/equiv (EQV4 x x1)) implies/reflexive))
                          (implies/equiv (equiv/symmetric equiv/identity))))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-empty M9=M1+M8 M8=M9
    <- capset2perm-respects-eq M8=>PiM8 clsmap`eq/ predmap`eq/ cxt`eq/ M8=M9 permission`eq/
      M9=>PiM8
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L9 (PiFS3P=PiFS3) (P-EQ) (PiFS3P=PiFS1)
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS1 CP3F=CP OE EQV5
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6/shared _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L6/shared _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).



%theorem letRefTyping-helper/base/unique/L6/unique/true
  : forall* {CM} {PM} {B1:object -> cxt} {B0} {N} {U3} {U4} {U5}
    {M1} {M2} {M3} {M6} {M7} {M8} {M9} {Out}
    {Pi2} {S} {NN} {C} {NN1} {C1} {FM} {FS} {S1} {M11}
    forall {N!<G1: not-in-targets (s N) (targets/unique S1 M11 true)}
    {N!<B0: cxt`fresh B0 (s N)}
    {B0+SN=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {N+FS=>M3: nat+set2set (s N) FS M3}
    {EC-FMT: unique-encumbered-perm-format CM PM B0 B1 S NN C M1 M2 M3 Pi2}
    {R2=>Out2: {x} result2output CM PM (B1 x)
               (result/expr (reftype/ NN1 C1 (targets/unique S1 M11 true)) (env/ U3 M6)) (Out x)}
    {M6-M3=M7: set`split M6 M3 M7}
    {M8=M2+M7: set`split M8 M2 M7}
    {M9=M1+M8: set`split M9 M1 M8}
    {SN!<U4: set`not-member U4 (s N)}
    {U4+SN=U3: set`add U4 (s N) U3}
    {U4+S=U5: set`union U4 S U5}
    exists {Out2} {Out3}
    {EA: {x}{o}{p:permission} envadd (Pi2 x o p) (Out x) (Out2 x o p)}
    {R2'=>Out3: result2output CM PM B0
                (result/expr (reftype/ NN1 C1 (targets/unique S1 M11 true)) (env/ U5 M9)) Out3}
    {TRANS: transform (output/exists [x]
                        (output/exists [o]
                          (output/exists [p:permission]
                            (Out2 x o p)))) Out3}
    true.

%%% 1. fresh + unique + fresh

- : letRefTyping-helper/base/unique/L6/unique/true
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) _)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/fresh set`size/0
      (ty2perm/ (PML1:predmap`lookup PM C CP) (NN2P1:nn2perm NN _ PF1) annot2perm/unique)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/unique+fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 set/0 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 set/0 U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU4:make-encumbered CM PM B0 U5 PiU4)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/unique+fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o) M11=>PiM11))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [x1]
              (transform/inside [o1]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans8
                        (implies/combine implies/reflexive
                          (implies/trans3
                            (implies/equiv equiv/identity)
                            (implies/combine implies/reflexive (implies/equiv equiv/commute))
                            (implies/equiv equiv/reorder)))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/trans
                                (implies/equiv (PiU3<=>PiFS3P+PiU4' x))
                                (implies/combine (implies/equiv (EQV5 x))
                                  (implies/equiv (PiU4'<=>PiU4 x))))
                              (implies/equiv (PiM6F<=>PiM3F+PiM7F x))))
                          (implies/combine
                            (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                              (implies/combine implies/reflexive
                                (implies/equiv (PiB0F<=>PiB0 x))))
                            (implies/reflexive)))
                        (implies/combine implies/reflexive
                          (implies/equiv (equiv/symmetric equiv/associate)))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans4
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine implies/reflexive
                              (implies/trans
                                (implies/equiv
                                  (equiv/transitive5
                                    (equiv/commute)
                                    (equiv/combine equiv/reflexive
                                      (equiv/symmetric equiv/associate))
                                    (equiv/associate)
                                    (equiv/combine equiv/reflexive
                                      (equiv/reorder))
                                    (equiv/associate)))
                                (implies/combine
                                  (implies/trans3
                                    (implies/equiv equiv/commute)
                                    (implies/combine implies/reflexive
                                      (implies/combine (implies/equiv (EQV x))
                                        (implies/reflexive)))
                                    (IMP x))
                                  (implies/reflexive))))
                            (implies/trans3
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans3
                                  (implies/equiv equiv/commute)
                                  (implies/combine (implies/equiv (EQV2 x)) implies/reflexive)
                                  (implies/linear-modus-ponens))
                                (implies/reflexive))
                              (implies/equiv equiv/reorder))
                            (implies/combine implies/reflexive
                              (implies/trans
                                (implies/combine implies/reflexive
                                  (implies/equiv (PiM7F<=>PiM7 x)))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/swap)
                                    (equiv/combine (PiM1+PiM7<=>PiM9) equiv/reflexive))))))
                          (implies/reflexive))
                        (implies/trans4
                          (implies/combine
                            (implies/trans implies/associate implies/commute)
                            (implies/combine implies/reflexive
                              (implies/combine implies/reflexive
                                (implies/combine (implies/equiv (EQV4 x o1))
                                  (implies/equiv-encumbered (EQV4 x o1)
                                    (equiv/combine (PiM11F<=>PiM11 x) equiv/reflexive))))))
                          (implies/symmetric-associate)
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/reorder)
                              (implies/combine implies/reflexive implies/commute)))
                          (implies/combine implies/reflexive
                            (implies/equiv
                              (equiv/symmetric equiv/identity))))
                        (implies/combine implies/reflexive
                          (implies/combine
                            (implies/combine implies/reflexive
                              (implies/combine
                                (implies/combine
                                  (implies/cond-inner
                                    (bimplies/reflexive)
                                    (bimplies/reflexive)
                                    (implies/reflexive)
                                    (implies/equiv (GF1F<=>GF1 x x1)))
                                  (implies/reflexive))
                                (implies/reflexive)))
                            (implies/reflexive)))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- set`union-unique set`union/R U4+S=U5 set`eq/ set`eq/ U4=U5
    <- make-encumbered-respects-eq U4=>PiU4 clsmap`eq/ predmap`eq/ cxt`eq/
      U4=U5 permission`eq/ U5=>PiU4
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M11=>PiM11F x)
      N!<B0 ([x] B0+N=B1 x) PiM11 M11=>PiM11 ([x] PiM11F=PiM11 x)
    <- ({x} permission`eq-implies-equiv (PiM11F=PiM11 x) (PiM11F<=>PiM11 x))
    <- set`split-empty M8=M2+M7 M7=M8
    <- set`eq-symmetric M7=M8 M8=M7
    <- capset2perm-respects-eq M7=>PiM7 clsmap`eq/ predmap`eq/
      cxt`eq/ M7=M8 permission`eq/ M8=>PiM7
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM7 PiM9 M9=>PiM9 PiM1+PiM7<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS3 CP3F=CP3 OE EQV5
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 annot2perm/unique)
      predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o)).


%%% 2. borrow + unique+fresh

- : letRefTyping-helper/base/unique/L6/unique/true
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) _)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/borrow set`size/0 _
      (ty2perm/ (PML1:predmap`lookup PM C CP) (NN2P1:nn2perm NN _ PF1) annot2perm/unique)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/unique+fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
         ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 set/0 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 set/0 U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU4:make-encumbered CM PM B0 U5 PiU4)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/unique+fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o) (M11=>PiM11:capset2perm CM PM B0 M11 PiM11)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [x1]
            (transform/inside [o1]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans8
                      (implies/combine implies/reflexive
                        (implies/trans3
                          (implies/equiv equiv/identity)
                          (implies/combine implies/reflexive (implies/equiv equiv/commute))
                          (implies/equiv equiv/reorder)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/combine
                            (implies/trans
                              (implies/equiv (PiU3<=>PiFS3P+PiU4' x))
                              (implies/combine (implies/equiv (EQV5 x))
                                (implies/equiv (PiU4'<=>PiU4 x))))
                            (implies/equiv (PiM6F<=>PiM3F+PiM7F x))))
                        (implies/combine
                          (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                            (implies/combine implies/reflexive
                              (implies/equiv (PiB0F<=>PiB0 x))))
                          (implies/reflexive)))
                      (implies/combine implies/reflexive
                        (implies/equiv (equiv/symmetric equiv/associate)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans4
                          (implies/equiv (equiv/symmetric equiv/associate))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/equiv
                                (equiv/transitive5
                                  (equiv/commute)
                                  (equiv/combine equiv/reflexive
                                    (equiv/symmetric equiv/associate))
                                  (equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/reorder))
                                  (equiv/associate)))
                              (implies/combine
                                (implies/trans3
                                  (implies/equiv equiv/commute)
                                  (implies/combine implies/reflexive
                                    (implies/combine (implies/equiv (EQV x))
                                      (implies/reflexive)))
                                  (IMP x))
                                (implies/reflexive))))
                          (implies/trans3
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans3
                                (implies/equiv equiv/commute)
                                (implies/combine (implies/equiv (EQV2 x)) implies/reflexive)
                                (implies/linear-modus-ponens))
                              (implies/reflexive))
                            (implies/equiv equiv/reorder))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/combine implies/reflexive
                                (implies/equiv (PiM7F<=>PiM7 x)))
                              (implies/equiv (PiM1+PiM7<=>PiM9)))))
                        (implies/reflexive))
                      (implies/trans6
                        (implies/combine implies/reflexive
                          (implies/combine implies/reflexive
                            (implies/combine implies/reflexive
                              (implies/combine (implies/equiv (EQV4 x o1))
                                (implies/equiv-encumbered (EQV4 x o1)
                                  (equiv/combine (PiM11F<=>PiM11 x) equiv/reflexive))))))
                        (implies/equiv equiv/reorder)
                        (implies/combine implies/reflexive implies/commute)
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/commute))
                      (implies/combine implies/reflexive
                        (implies/combine
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/combine
                                (implies/cond-inner
                                  (bimplies/reflexive)
                                  (bimplies/reflexive)
                                  (implies/reflexive)
                                  (implies/equiv (GF1F<=>GF1 x x1)))
                                (implies/reflexive))
                              (implies/reflexive)))
                          (implies/reflexive)))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- set`union-unique set`union/R U4+S=U5 set`eq/ set`eq/ U4=U5
    <- make-encumbered-respects-eq U4=>PiU4 clsmap`eq/ predmap`eq/ cxt`eq/
      U4=U5 permission`eq/ U5=>PiU4
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M11=>PiM11F x)
      N!<B0 ([x] B0+N=B1 x) PiM11 M11=>PiM11 ([x] PiM11F=PiM11 x)
    <- ({x} permission`eq-implies-equiv (PiM11F=PiM11 x) (PiM11F<=>PiM11 x))
    <- set`split-empty M8=M2+M7 M7=M8
    <- set`eq-symmetric M7=M8 M8=M7
    <- capset2perm-respects-eq M7=>PiM7 clsmap`eq/ predmap`eq/ cxt`eq/ M7=M8 permission`eq/
      M8=>PiM7
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM7 PiM9 M9=>PiM9 PiM1+PiM7<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS3 CP3F=CP3 OE EQV5
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 annot2perm/unique) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o)).

%%% 3. unique + unique+fresh
- : letRefTyping-helper/base/unique/L6/unique/true
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) N!<M11)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique _ _
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/unique+fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/unique+fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o) M11=>PiM11))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [v]
              (transform/inside [u]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans6
                        (implies/combine implies/reflexive % FIRST HALF
                          (implies/trans3
                            (implies/equiv equiv/identity)
                            (implies/combine
                              (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                                (implies/combine implies/reflexive
                                  (implies/equiv (PiB0F<=>PiB0 x))))
                              (implies/combine implies/reflexive
                                (implies/trans
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive
                                          (PiU3<=>PiFS3P+PiU4' x)
                                          (EQV5 x)))
                                      (implies/combine
                                        (implies/cond-inner
                                          (bimplies/reflexive)
                                          (bimplies/reflexive)
                                          (implies/reflexive)
                                          (implies/equiv-encumbered
                                            (PiFS3P<=>PiFS3 x x)
                                            (equiv/reflexive)))
                                        (implies/equiv (PiU4'<=>PiU4 x))))
                                    (implies/trans
                                      (implies/equiv (PiM6<=>PiM3F+PiM7F x))
                                      (implies/combine implies/reflexive
                                        (implies/equiv (PiM7F<=>PiM7 x)))))
                                  (implies/equiv equiv/swap-middle))))
                            (implies/equiv
                              (equiv/transitive4
                                (equiv/combine equiv/reflexive equiv/roll2)
                                (equiv/associate)
                                (equiv/combine equiv/swap equiv/reflexive)
                                (equiv/symmetric equiv/associate)))))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans5
                            (implies/equiv equiv/commute)
                            (implies/cond-push)
                            (implies/cond-gen-inner)
                            (implies/cond-inner
                              (bimplies/reflexive)
                              (bimplies/reflexive)
                              (implies/trans6
                                (implies/combine implies/reflexive
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive3
                                          (equiv/combine equiv/reflexive equiv/commute)
                                          (equiv/roll2)
                                          (equiv/combine
                                            (equiv/reflexive)
                                            (equiv/combine (EQV x) equiv/reflexive))))
                                      (IMP x))
                                    (implies/reflexive)))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/objequal PF)
                                    (implies/equiv (EQV2 o)))
                                  (implies/reflexive))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/linear-modus-ponens)
                                      (implies/reflexive)))
                                  (implies/reflexive))
                                (implies/equiv (equiv/symmetric equiv/identity)))
                              (implies/trans5
                                (implies/combine (implies/nonlinear2empty)
                                  (implies/reflexive))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/commute)
                                    (equiv/identity)))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/symmetric equiv/associate)
                                    (equiv/combine equiv/reflexive
                                      (equiv/symmetric equiv/associate))))
                                (implies/combine
                                  (implies/reflexive)
                                  (implies/trans5
                                    (implies/combine implies/reflexive
                                      (implies/equiv equiv/roll4))
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/trans
                                        (implies/combine
                                          (implies/equiv (EQV3 x))
                                          (implies/reflexive))
                                        (implies/linear-modus-ponens))
                                      (implies/reflexive))
                                    (implies/combine implies/reflexive % PiS
                                      (implies/trans3
                                        (implies/combine implies/reflexive
                                          (implies/equiv equiv/reorder))
                                        (implies/equiv equiv/associate)
                                        (implies/combine
                                          (implies/trans
                                            (implies/combine
                                              (implies/equiv (PiM3F<=>PiM3 x))
                                              (implies/reflexive))
                                            (implies/linear-modus-ponens))
                                          (implies/combine implies/reflexive
                                            implies/linear-modus-ponens))))
                                    (implies/equiv
                                      (equiv/transitive3
                                        (equiv/combine equiv/reflexive
                                          (equiv/transitive3
                                            (equiv/combine equiv/reflexive equiv/commute)
                                            (equiv/associate)
                                            (equiv/combine equiv/commute equiv/reflexive)))
                                        (equiv/associate)
                                        (equiv/combine equiv/commute equiv/reflexive)))))
                                (implies/equiv equiv/roll2)))
                            (implies/cond-pull))
                          (implies/reflexive))
                        (implies/equiv
                          (equiv/transitive6
                            (equiv/symmetric equiv/associate)
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/combine equiv/reflexive
                                  (equiv/commute))))
                            (equiv/combine equiv/reflexive
                              (equiv/roll3))
                            (equiv/associate)
                            (equiv/combine
                              (equiv/transitive3
                                (equiv/commute)
                                (equiv/combine equiv/commute equiv/reflexive)
                                (equiv/swap-middle))
                              (equiv/reflexive))
                            (equiv/combine
                              (equiv/combine
                                (equiv/transitive4
                                  (equiv/commute)
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (PiM2+PiM7<=>PiM8))
                                  (PiM1+PiM8<=>PiM9))
                                (PiU4+PiS<=>PiU5))
                              (equiv/reflexive))))
                        (implies/trans3
                          (implies/combine implies/commute
                            (implies/combine implies/reflexive
                              (implies/combine implies/reflexive
                                (implies/combine implies/reflexive
                                (implies/combine (implies/equiv (EQV4 x u))
                                  (implies/equiv-encumbered (EQV4 x u)
                                    (equiv/combine (PiM11F<=>PiM11 x) equiv/reflexive)))))))
                          (implies/equiv equiv/reorder)
                          (implies/combine implies/reflexive
                            (implies/trans3
                              (implies/equiv equiv/reorder)
                              (implies/combine implies/reflexive implies/commute)
                              (implies/equiv (equiv/symmetric equiv/identity)))))
                        (implies/combine implies/reflexive
                          (implies/combine
                            (implies/combine implies/reflexive
                              (implies/combine
                                (implies/combine
                                  (implies/cond-inner
                                    (bimplies/reflexive)
                                    (bimplies/reflexive)
                                    (implies/reflexive)
                                    (implies/equiv (GF1F<=>GF1 x v)))
                                  (implies/reflexive))
                                (implies/reflexive)))
                            (implies/reflexive)))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- ({x}{o} permission`eq-implies-equiv (PiFS3P=PiFS3 x o) (PiFS3P<=>PiFS3 x o))
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6 x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M11=>PiM11F x)
      N!<B0 ([x] B0+N=B1 x) PiM11 M11=>PiM11 ([x] PiM11F=PiM11 x)
    <- ({x} permission`eq-implies-equiv (PiM11F=PiM11 x) (PiM11F<=>PiM11 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM8 PiM9 M9=>PiM9 PiM1+PiM8<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- letRefTyping-helper/base/unique/L6L5 PiFS3P CP3F=CP3 OE EQV5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o)).


%%% 4. unique/2 + unique+fresh

- : letRefTyping-helper/base/unique/L6/unique/true
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) _)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique/2 _ set`size/0
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/unique+fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 set/0 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM8:capset2perm CM PM B0 M9 PiM8))
      (reftype2perm/unique+fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o) (M11=>PiM11:capset2perm CM PM B0 M11 PiM11)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [x1]
            (transform/inside [o1]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans5
                      (implies/equiv
                        (equiv/transitive % TRANS 2ND part
                          (equiv/combine
                            (equiv/reflexive)
                            (equiv/transitive3
                              (equiv/identity)
                              (equiv/combine
                                (equiv/transitive (PiB1<=>PF1+PiB0F x)
                                  (equiv/combine equiv/reflexive (PiB0F<=>PiB0 x)))
                                (equiv/combine (equiv/reflexive)
                                  (equiv/combine
                                    (equiv/transitive
                                      (PiU3<=>PiFS3P+PiU4' x)
                                      (equiv/combine (EQV5 x) (PiU4'<=>PiU4 x)))
                                    (equiv/transitive
                                      (PiM6F<=>PiM3F+PiM7F x)
                                      (equiv/combine (PiM3F<=>PiM3 x) (PiM7F<=>PiM7 x))))))
                              (equiv/transitive
                                (equiv/combine equiv/reflexive equiv/commute)
                                (equiv/roll2))))
                          (equiv/associate)))
                      (implies/combine
                        (implies/trans5
                          (implies/combine implies/reflexive
                            (implies/equiv equiv/swap-middle))
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/trans
                              (implies/equiv equiv/swap)
                              (implies/combine
                                (implies/trans4
                                  (implies/equiv equiv/swap)
                                  (implies/combine
                                    (implies/trans % (S -|- PiS GF PiM3 -|- PiM2) (S PiM3)
                                      (implies/equiv equiv/associate)
                                      (implies/combine
                                        (implies/trans
                                          (implies/equiv equiv/commute)
                                          (implies/linear-modus-ponens))
                                        (implies/reflexive)))
                                    (implies/reflexive))
                                  (implies/equiv equiv/swap-middle)
                                  (implies/combine
                                    (implies/reflexive)
                                    (implies/linear-modus-ponens)))
                                (implies/reflexive)))
                            (implies/reflexive))
                          (implies/equiv equiv/swap)
                          (implies/combine
                            (implies/trans
                              (implies/equiv equiv/swap-middle)
                              (implies/combine
                                (implies/trans
                                  (implies/equiv equiv/swap)
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv equiv/commute)
                                      (implies/equiv (PiU4+PiS<=>PiU5)))
                                    (implies/reflexive)))
                                (implies/equiv
                                  (PiM2+PiM7<=>PiM8))))
                            (implies/reflexive)))
                        (implies/reflexive))
                      (implies/equiv
                        (equiv/transitive3
                          (equiv/combine
                            (equiv/transitive3
                              (equiv/combine equiv/swap equiv/reflexive)
                              (equiv/symmetric equiv/associate)
                              (equiv/commute))
                            (equiv/symmetric equiv/associate))
                          (equiv/swap-middle)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive
                              (equiv/reorder)
                              (equiv/combine equiv/reflexive equiv/commute)))))
                      (implies/trans
                        (implies/combine implies/reflexive
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/combine implies/reflexive
                                (implies/combine (implies/equiv (EQV4 x o1))
                                  (implies/equiv-encumbered (EQV4 x o1)
                                    (equiv/combine (PiM11F<=>PiM11 x) equiv/reflexive))))
                              (implies/reflexive))))
                        (implies/combine implies/reflexive
                          (implies/equiv (equiv/symmetric equiv/identity))))
                      (implies/combine implies/reflexive
                        (implies/combine
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/combine
                                (implies/cond-inner
                                  (bimplies/reflexive)
                                  (bimplies/reflexive)
                                  (implies/reflexive)
                                  (implies/equiv (GF1F<=>GF1 x x1)))
                                (implies/reflexive))
                              (implies/reflexive)))
                          (implies/reflexive)))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M11=>PiM11F x)
      N!<B0 ([x] B0+N=B1 x) PiM11 M11=>PiM11 ([x] PiM11F=PiM11 x)
    <- ({x} permission`eq-implies-equiv (PiM11F=PiM11 x) (PiM11F<=>PiM11 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-empty M9=M1+M8 M8=M9
    <- capset2perm-respects-eq M8=>PiM8 clsmap`eq/ predmap`eq/ cxt`eq/ M8=M9 permission`eq/
      M9=>PiM8
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L9 (PiFS3P=PiFS3) (P-EQ) (PiFS3P=PiFS1)
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS1 CP3F=CP OE EQV5
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o)).


- : letRefTyping-helper/base/unique/L6/unique/true
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) N!<M11)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique+fresh _
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/unique+fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/unique+fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o) M11=>PiM11))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [v]
              (transform/inside [u]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans6
                        (implies/combine implies/reflexive % FIRST HALF
                          (implies/trans3
                            (implies/equiv equiv/identity)
                            (implies/combine
                              (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                                (implies/combine implies/reflexive
                                  (implies/equiv (PiB0F<=>PiB0 x))))
                              (implies/combine implies/reflexive
                                (implies/trans
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive
                                          (PiU3<=>PiFS3P+PiU4' x)
                                          (EQV5 x)))
                                      (implies/combine
                                        (implies/cond-inner
                                          (bimplies/reflexive)
                                          (bimplies/reflexive)
                                          (implies/reflexive)
                                          (implies/equiv-encumbered
                                            (PiFS3P<=>PiFS3 x x)
                                            (equiv/reflexive)))
                                        (implies/equiv (PiU4'<=>PiU4 x))))
                                    (implies/trans
                                      (implies/equiv (PiM6<=>PiM3F+PiM7F x))
                                      (implies/combine implies/reflexive
                                        (implies/equiv (PiM7F<=>PiM7 x)))))
                                  (implies/equiv equiv/swap-middle))))
                            (implies/equiv
                              (equiv/transitive4
                                (equiv/combine equiv/reflexive equiv/roll2)
                                (equiv/associate)
                                (equiv/combine equiv/swap equiv/reflexive)
                                (equiv/symmetric equiv/associate)))))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans5
                            (implies/equiv equiv/commute)
                            (implies/cond-push)
                            (implies/cond-gen-inner)
                            (implies/cond-inner
                              (bimplies/reflexive)
                              (bimplies/reflexive)
                              (implies/trans6
                                (implies/combine implies/reflexive
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive3
                                          (equiv/combine equiv/reflexive equiv/commute)
                                          (equiv/roll2)
                                          (equiv/combine
                                            (equiv/reflexive)
                                            (equiv/combine (EQV x) equiv/reflexive))))
                                      (IMP x))
                                    (implies/reflexive)))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/objequal PF)
                                    (implies/equiv (EQV2 o)))
                                  (implies/reflexive))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/linear-modus-ponens)
                                      (implies/reflexive)))
                                  (implies/reflexive))
                                (implies/equiv (equiv/symmetric equiv/identity)))
                              (implies/trans5
                                (implies/combine (implies/nonlinear2empty)
                                  (implies/reflexive))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/commute)
                                    (equiv/identity)))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/symmetric equiv/associate)
                                    (equiv/combine equiv/reflexive
                                      (equiv/symmetric equiv/associate))))
                                (implies/combine
                                  (implies/reflexive)
                                  (implies/trans5
                                    (implies/combine implies/reflexive
                                      (implies/equiv equiv/roll4))
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/trans
                                        (implies/combine
                                          (implies/equiv (EQV3 x))
                                          (implies/reflexive))
                                        (implies/linear-modus-ponens))
                                      (implies/reflexive))
                                    (implies/combine implies/reflexive % PiS
                                      (implies/trans3
                                        (implies/combine implies/reflexive
                                          (implies/equiv equiv/reorder))
                                        (implies/equiv equiv/associate)
                                        (implies/combine
                                          (implies/trans
                                            (implies/combine
                                              (implies/equiv (PiM3F<=>PiM3 x))
                                              (implies/reflexive))
                                            (implies/linear-modus-ponens))
                                          (implies/combine implies/reflexive
                                            implies/linear-modus-ponens))))
                                    (implies/equiv
                                      (equiv/transitive3
                                        (equiv/combine equiv/reflexive
                                          (equiv/transitive3
                                            (equiv/combine equiv/reflexive equiv/commute)
                                            (equiv/associate)
                                            (equiv/combine equiv/commute equiv/reflexive)))
                                        (equiv/associate)
                                        (equiv/combine equiv/commute equiv/reflexive)))))
                                (implies/equiv equiv/roll2)))
                            (implies/cond-pull))
                          (implies/reflexive))
                        (implies/equiv
                          (equiv/transitive6
                            (equiv/symmetric equiv/associate)
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/combine equiv/reflexive
                                  (equiv/commute))))
                            (equiv/combine equiv/reflexive
                              (equiv/roll3))
                            (equiv/associate)
                            (equiv/combine
                              (equiv/transitive3
                                (equiv/commute)
                                (equiv/combine equiv/commute equiv/reflexive)
                                (equiv/swap-middle))
                              (equiv/reflexive))
                            (equiv/combine
                              (equiv/combine
                                (equiv/transitive4
                                  (equiv/commute)
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (PiM2+PiM7<=>PiM8))
                                  (equiv/transitive equiv/swap
                                    (equiv/combine
                                      (PiM1+PiM8<=>PiM9)
                                      (equiv/reflexive))))
                                (PiU4+PiS<=>PiU5))
                              (equiv/reflexive))))
                        (implies/trans3
                          (implies/combine
                            (implies/equiv
                              (equiv/transitive3
                                (equiv/swap)
                                (equiv/commute)
                                (equiv/combine equiv/reflexive equiv/commute)))
                            (implies/combine implies/reflexive
                              (implies/combine implies/reflexive
                                (implies/combine implies/reflexive
                                  (implies/combine (implies/equiv (EQV4 x u))
                                    (implies/equiv-encumbered (EQV4 x u)
                                      (equiv/combine (PiM11F<=>PiM11 x) equiv/reflexive)))))))
                          (implies/equiv equiv/swap-middle)
                          (implies/combine implies/reflexive
                            (implies/trans3
                              (implies/equiv equiv/reorder)
                              (implies/combine implies/reflexive implies/commute)
                              (implies/equiv (equiv/symmetric equiv/identity)))))
                      (implies/combine implies/reflexive
                        (implies/combine
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/combine
                                (implies/cond-inner
                                  (bimplies/reflexive)
                                  (bimplies/reflexive)
                                  (implies/reflexive)
                                  (implies/equiv (GF1F<=>GF1 x v)))
                                (implies/reflexive))
                              (implies/reflexive)))
                          (implies/reflexive)))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- ({x}{o} permission`eq-implies-equiv (PiFS3P=PiFS3 x o) (PiFS3P<=>PiFS3 x o))
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6 x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M11=>PiM11F x)
      N!<B0 ([x] B0+N=B1 x) PiM11 M11=>PiM11 ([x] PiM11F=PiM11 x)
    <- ({x} permission`eq-implies-equiv (PiM11F=PiM11 x) (PiM11F<=>PiM11 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM8 PiM9 M9=>PiM9 PiM1+PiM8<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- letRefTyping-helper/base/unique/L6L5 PiFS3P CP3F=CP3 OE EQV5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o)).

%worlds (gtermvar)
(letRefTyping-helper/base/unique/L6/unique/true _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { }
(letRefTyping-helper/base/unique/L6/unique/true _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%%% For the case of reftype2perm/borrow and reftype2perm/unique
%theorem letRefTyping-helper/base/unique/L6/unique/false
  : forall* {CM} {PM} {B1:object -> cxt} {B0} {N} {U3} {U4} {U5}
    {M1} {M2} {M3} {M6} {M7} {M8} {M9} {Out}
    {Pi2} {S} {NN} {C} {NN1} {C1} {FM} {FS} {S1} {M11}
    forall {N!<G1: not-in-targets (s N) (targets/unique S1 M11 false)}
    {N!<B0: cxt`fresh B0 (s N)}
    {B0+SN=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {N+FS=>M3: nat+set2set (s N) FS M3}
    {EC-FMT: unique-encumbered-perm-format CM PM B0 B1 S NN C M1 M2 M3 Pi2}
    {R2=>Out2: {x} result2output CM PM (B1 x)
               (result/expr (reftype/ NN1 C1 (targets/unique S1 M11 false)) (env/ U3 M6)) (Out x)}
    {M6-M3=M7: set`split M6 M3 M7}
    {M8=M2+M7: set`split M8 M2 M7}
    {M9=M1+M8: set`split M9 M1 M8}
    {SN!<U4: set`not-member U4 (s N)}
    {U4+SN=U3: set`add U4 (s N) U3}
    {U4+S=U5: set`union U4 S U5}
    exists {Out2} {Out3}
    {EA: {x}{o}{p:permission} envadd (Pi2 x o p) (Out x) (Out2 x o p)}
    {R2'=>Out3: result2output CM PM B0
                (result/expr (reftype/ NN1 C1 (targets/unique S1 M11 false)) (env/ U5 M9)) Out3}
    {TRANS: transform (output/exists [x]
                        (output/exists [o]
                          (output/exists [p:permission]
                            (Out2 x o p)))) Out3}
    true.

%%% 1. fresh + borrow
- : letRefTyping-helper/base/unique/L6/unique/false
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) _)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/fresh set`size/0
      (ty2perm/ (PML1:predmap`lookup PM C CP) (NN2P1:nn2perm NN _ PF1) annot2perm/unique)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/borrow (SZ:set`size S1 (s _)) set`size/0
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/borrow)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 set/0 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 set/0 U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU4:make-encumbered CM PM B0 U5 PiU4)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/borrow SZ set`size/0
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/borrow)
        ([o] S1=>GF1 o)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [x1]
            (transform/inside [o1]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans7
                      (implies/combine implies/reflexive
                        (implies/trans3
                          (implies/equiv equiv/identity)
                          (implies/combine implies/reflexive (implies/equiv equiv/commute))
                          (implies/equiv equiv/reorder)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/combine
                            (implies/trans
                              (implies/equiv (PiU3<=>PiFS3P+PiU4' x))
                              (implies/combine (implies/equiv (EQV5 x))
                                (implies/equiv (PiU4'<=>PiU4 x))))
                            (implies/equiv (PiM6F<=>PiM3F+PiM7F x))))
                        (implies/combine
                          (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                            (implies/combine implies/reflexive
                              (implies/equiv (PiB0F<=>PiB0 x))))
                          (implies/reflexive)))
                      (implies/combine implies/reflexive
                        (implies/equiv (equiv/symmetric equiv/associate)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans4
                          (implies/equiv (equiv/symmetric equiv/associate))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/equiv
                                (equiv/transitive5
                                  (equiv/commute)
                                  (equiv/combine equiv/reflexive
                                    (equiv/symmetric equiv/associate))
                                  (equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/reorder))
                                  (equiv/associate)))
                              (implies/combine
                                (implies/trans3
                                  (implies/equiv equiv/commute)
                                  (implies/combine implies/reflexive
                                    (implies/combine (implies/equiv (EQV x))
                                      (implies/reflexive)))
                                  (IMP x))
                                (implies/reflexive))))
                          (implies/trans3
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans3
                                (implies/equiv equiv/commute)
                                (implies/combine (implies/equiv (EQV2 x)) implies/reflexive)
                                (implies/linear-modus-ponens))
                              (implies/reflexive))
                            (implies/equiv equiv/reorder))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/combine implies/reflexive
                                (implies/equiv (PiM7F<=>PiM7 x)))
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/swap)
                                  (equiv/combine (PiM1+PiM7<=>PiM9) equiv/reflexive))))))
                        (implies/reflexive))
                      (implies/equiv
                        (equiv/transitive4
                          (equiv/combine (equiv/transitive equiv/associate equiv/commute)
                            (equiv/combine equiv/reflexive
                              (equiv/combine (EQV4 x x1) (GF1F<=>GF1 x x1))))
                          (equiv/symmetric-associate)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive
                              (equiv/reorder)
                              (equiv/combine equiv/reflexive equiv/commute)))
                          (equiv/combine equiv/reflexive (equiv/symmetric equiv/identity))))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- set`union-unique set`union/R U4+S=U5 set`eq/ set`eq/ U4=U5
    <- make-encumbered-respects-eq U4=>PiU4 clsmap`eq/ predmap`eq/ cxt`eq/
      U4=U5 permission`eq/ U5=>PiU4
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-empty M8=M2+M7 M7=M8
    <- set`eq-symmetric M7=M8 M8=M7
    <- capset2perm-respects-eq M7=>PiM7 clsmap`eq/ predmap`eq/ cxt`eq/ M7=M8 permission`eq/
      M8=>PiM7
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM7 PiM9 M9=>PiM9 PiM1+PiM7<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS3 CP3F=CP3 OE EQV5
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o))
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 annot2perm/unique) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x)).


%%% 2. borrow + borrow
- : letRefTyping-helper/base/unique/L6/unique/false
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) _)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/borrow set`size/0 _
      (ty2perm/ (PML1:predmap`lookup PM C CP) (NN2P1:nn2perm NN _ PF1) annot2perm/unique)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/borrow (SZ:set`size S1 (s _)) set`size/0
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/borrow)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 set/0 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 set/0 U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU4:make-encumbered CM PM B0 U5 PiU4)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/borrow SZ set`size/0
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/borrow)
        ([o] S1=>GF1 o)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [x1]
            (transform/inside [o1]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans7
                      (implies/combine implies/reflexive
                        (implies/trans3
                          (implies/equiv equiv/identity)
                          (implies/combine implies/reflexive (implies/equiv equiv/commute))
                          (implies/equiv equiv/reorder)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/combine
                            (implies/trans
                              (implies/equiv (PiU3<=>PiFS3P+PiU4' x))
                              (implies/combine (implies/equiv (EQV5 x))
                                (implies/equiv (PiU4'<=>PiU4 x))))
                            (implies/equiv (PiM6F<=>PiM3F+PiM7F x))))
                        (implies/combine
                          (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                            (implies/combine implies/reflexive
                              (implies/equiv (PiB0F<=>PiB0 x))))
                          (implies/reflexive)))
                      (implies/combine implies/reflexive
                        (implies/equiv (equiv/symmetric equiv/associate)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans4
                          (implies/equiv (equiv/symmetric equiv/associate))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/equiv
                                (equiv/transitive5
                                  (equiv/commute)
                                  (equiv/combine equiv/reflexive
                                    (equiv/symmetric equiv/associate))
                                  (equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/reorder))
                                  (equiv/associate)))
                              (implies/combine
                                (implies/trans3
                                  (implies/equiv equiv/commute)
                                  (implies/combine implies/reflexive
                                    (implies/combine (implies/equiv (EQV x))
                                      (implies/reflexive)))
                                  (IMP x))
                                (implies/reflexive))))
                          (implies/trans3
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans3
                                (implies/equiv equiv/commute)
                                (implies/combine (implies/equiv (EQV2 x)) implies/reflexive)
                                (implies/linear-modus-ponens))
                              (implies/reflexive))
                            (implies/equiv equiv/reorder))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/combine implies/reflexive
                                (implies/equiv (PiM7F<=>PiM7 x)))
                              (implies/equiv (PiM1+PiM7<=>PiM9)))))
                        (implies/reflexive))
                      (implies/trans6
                        (implies/equiv equiv/commute)
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine implies/reflexive
                          (implies/combine
                            (implies/combine
                              (implies/equiv (EQV4 x x1))
                              (implies/equiv (GF1F<=>GF1 x x1)))
                            (implies/reflexive)))
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/equiv equiv/commute))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- set`union-unique set`union/R U4+S=U5 set`eq/ set`eq/ U4=U5
    <- make-encumbered-respects-eq U4=>PiU4 clsmap`eq/ predmap`eq/ cxt`eq/
      U4=U5 permission`eq/ U5=>PiU4
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-empty M8=M2+M7 M7=M8
    <- set`eq-symmetric M7=M8 M8=M7
    <- capset2perm-respects-eq M7=>PiM7 clsmap`eq/ predmap`eq/ cxt`eq/ M7=M8 permission`eq/
      M8=>PiM7
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM7 PiM9 M9=>PiM9 PiM1+PiM7<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS3 CP3F=CP3 OE EQV5
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o))
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 annot2perm/unique) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x)).

%%% 3. unique + borrow
- : letRefTyping-helper/base/unique/L6/unique/false
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) _)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique _ _
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/borrow (SZ:set`size S1 (s _)) set`size/0
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/borrow)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/borrow SZ set`size/0
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/borrow)
        ([o] S1=>GF1 o)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
        (transform/inside [p]
          (transform/inside [v]
            (transform/inside [u]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans5
                      (implies/combine implies/reflexive % FIRST HALF
                        (implies/trans3
                          (implies/equiv equiv/identity)
                          (implies/combine
                            (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                              (implies/combine implies/reflexive
                                (implies/equiv (PiB0F<=>PiB0 x))))
                            (implies/combine implies/reflexive
                              (implies/trans
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv
                                      (equiv/transitive
                                        (PiU3<=>PiFS3P+PiU4' x)
                                        (EQV5 x)))
                                    (implies/combine
                                      (implies/cond-inner
                                        (bimplies/reflexive)
                                        (bimplies/reflexive)
                                        (implies/reflexive)
                                        (implies/equiv-encumbered
                                          (PiFS3P<=>PiFS3 x x)
                                          (equiv/reflexive)))
                                      (implies/equiv (PiU4'<=>PiU4 x))))
                                  (implies/trans
                                    (implies/equiv (PiM6<=>PiM3F+PiM7F x))
                                    (implies/combine implies/reflexive
                                      (implies/equiv (PiM7F<=>PiM7 x)))))
                                (implies/equiv equiv/swap-middle))))
                          (implies/equiv
                            (equiv/transitive4
                              (equiv/combine equiv/reflexive equiv/roll2)
                              (equiv/associate)
                              (equiv/combine equiv/swap equiv/reflexive)
                              (equiv/symmetric equiv/associate)))))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans5
                          (implies/equiv equiv/commute)
                          (implies/cond-push)
                          (implies/cond-gen-inner)
                          (implies/cond-inner
                            (bimplies/reflexive)
                            (bimplies/reflexive)
                            (implies/trans6
                              (implies/combine implies/reflexive
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv
                                      (equiv/transitive3
                                        (equiv/combine equiv/reflexive equiv/commute)
                                        (equiv/roll2)
                                        (equiv/combine
                                          (equiv/reflexive)
                                          (equiv/combine (EQV x) equiv/reflexive))))
                                    (IMP x))
                                  (implies/reflexive)))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans
                                  (implies/objequal PF)
                                  (implies/equiv (EQV2 o)))
                                (implies/reflexive))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans
                                  (implies/equiv equiv/associate)
                                  (implies/combine
                                    (implies/linear-modus-ponens)
                                    (implies/reflexive)))
                                (implies/reflexive))
                              (implies/equiv (equiv/symmetric equiv/identity)))
                            (implies/trans5
                              (implies/combine (implies/nonlinear2empty)
                                (implies/reflexive))
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/commute)
                                  (equiv/identity)))
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/symmetric equiv/associate))))
                              (implies/combine
                                (implies/reflexive)
                                (implies/trans5
                                  (implies/combine implies/reflexive
                                    (implies/equiv equiv/roll4))
                                  (implies/equiv equiv/associate)
                                  (implies/combine
                                    (implies/trans
                                      (implies/combine
                                        (implies/equiv (EQV3 x))
                                        (implies/reflexive))
                                      (implies/linear-modus-ponens))
                                    (implies/reflexive))
                                  (implies/combine implies/reflexive % PiS
                                    (implies/trans3
                                      (implies/combine implies/reflexive
                                        (implies/equiv equiv/reorder))
                                      (implies/equiv equiv/associate)
                                      (implies/combine
                                        (implies/trans
                                          (implies/combine
                                            (implies/equiv (PiM3F<=>PiM3 x))
                                            (implies/reflexive))
                                          (implies/linear-modus-ponens))
                                        (implies/combine implies/reflexive
                                          implies/linear-modus-ponens))))
                                  (implies/equiv
                                    (equiv/transitive3
                                      (equiv/combine equiv/reflexive
                                        (equiv/transitive3
                                          (equiv/combine equiv/reflexive equiv/commute)
                                          (equiv/associate)
                                          (equiv/combine equiv/commute equiv/reflexive)))
                                      (equiv/associate)
                                      (equiv/combine equiv/commute equiv/reflexive)))))
                              (implies/equiv equiv/roll2)))
                          (implies/cond-pull))
                        (implies/reflexive))
                      (implies/equiv
                        (equiv/transitive6
                          (equiv/symmetric equiv/associate)
                          (equiv/combine equiv/reflexive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/commute))))
                          (equiv/combine equiv/reflexive
                            (equiv/roll3))
                          (equiv/associate)
                          (equiv/combine
                            (equiv/transitive3
                              (equiv/commute)
                              (equiv/combine equiv/commute equiv/reflexive)
                              (equiv/swap-middle))
                            (equiv/reflexive))
                          (equiv/combine
                            (equiv/combine
                              (equiv/transitive4
                                (equiv/commute)
                                (equiv/symmetric equiv/associate)
                                (equiv/combine equiv/reflexive
                                  (PiM2+PiM7<=>PiM8))
                                (PiM1+PiM8<=>PiM9))
                              (PiU4+PiS<=>PiU5))
                            (equiv/reflexive))))
                      (implies/equiv
                        (equiv/transitive
                          (equiv/roll2)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive3
                              (equiv/roll2)
                              (equiv/combine equiv/reflexive
                                (equiv/transitive
                                  (equiv/commute)
                                  (equiv/combine
                                    (equiv/combine (EQV4 x v) (GF1F<=>GF1 x v)) equiv/commute)))
                              (equiv/symmetric equiv/identity)))))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- ({x}{o} permission`eq-implies-equiv (PiFS3P=PiFS3 x o) (PiFS3P<=>PiFS3 x o))
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6 x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM8 PiM9 M9=>PiM9 PiM1+PiM8<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L5 PiFS3P CP3F=CP3 OE EQV5
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o)).

%%% 4. unique/2 + borrow
- : letRefTyping-helper/base/unique/L6/unique/false
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) _)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique/2 _ set`size/0
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/borrow (SZ:set`size S1 (s _)) set`size/0
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/borrow)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 set/0 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM8:capset2perm CM PM B0 M9 PiM8))
      (reftype2perm/borrow SZ set`size/0
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/borrow)
        ([o] S1=>GF1 o)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [x1]
              (transform/inside [o1]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans4
                        (implies/equiv
                          (equiv/transitive % TRANS 2ND part
                            (equiv/combine
                              (equiv/reflexive)
                              (equiv/transitive3
                                (equiv/identity)
                                (equiv/combine
                                  (equiv/transitive (PiB1<=>PF1+PiB0F x)
                                    (equiv/combine equiv/reflexive (PiB0F<=>PiB0 x)))
                                  (equiv/combine (equiv/reflexive)
                                    (equiv/combine
                                      (equiv/transitive
                                        (PiU3<=>PiFS3P+PiU4' x)
                                        (equiv/combine (EQV5 x) (PiU4'<=>PiU4 x)))
                                      (equiv/transitive
                                        (PiM6F<=>PiM3F+PiM7F x)
                                        (equiv/combine (PiM3F<=>PiM3 x) (PiM7F<=>PiM7 x))))))
                                (equiv/transitive
                                  (equiv/combine equiv/reflexive equiv/commute)
                                  (equiv/roll2))))
                            (equiv/associate)))
                        (implies/combine
                          (implies/trans5
                            (implies/combine implies/reflexive
                              (implies/equiv equiv/swap-middle))
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans
                                (implies/equiv equiv/swap)
                                (implies/combine
                                  (implies/trans4
                                    (implies/equiv equiv/swap)
                                    (implies/combine
                                      (implies/trans % (S -|- PiS GF PiM3 -|- PiM2) (S PiM3)
                                        (implies/equiv equiv/associate)
                                        (implies/combine
                                          (implies/trans
                                            (implies/equiv equiv/commute)
                                            (implies/linear-modus-ponens))
                                          (implies/reflexive)))
                                      (implies/reflexive))
                                    (implies/equiv equiv/swap-middle)
                                    (implies/combine
                                      (implies/reflexive)
                                      (implies/linear-modus-ponens)))
                                  (implies/reflexive)))
                              (implies/reflexive))
                            (implies/equiv equiv/swap)
                            (implies/combine
                              (implies/trans
                                (implies/equiv equiv/swap-middle)
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv equiv/swap)
                                    (implies/combine
                                      (implies/trans
                                        (implies/equiv equiv/commute)
                                        (implies/equiv (PiU4+PiS<=>PiU5)))
                                      (implies/reflexive)))
                                  (implies/equiv
                                    (PiM2+PiM7<=>PiM8))))
                              (implies/reflexive)))
                          (implies/reflexive))
                        (implies/equiv
                          (equiv/transitive3
                            (equiv/combine
                              (equiv/transitive3
                                (equiv/combine equiv/swap equiv/reflexive)
                                (equiv/symmetric equiv/associate)
                                (equiv/commute))
                              (equiv/symmetric equiv/associate))
                            (equiv/swap-middle)
                            (equiv/combine equiv/reflexive
                              (equiv/transitive
                                (equiv/reorder)
                                (equiv/combine equiv/reflexive equiv/commute)))))
                        (implies/combine implies/reflexive
                          (implies/trans
                            (implies/combine
                              (implies/reflexive)
                              (implies/combine
                                (implies/equiv
                                  (equiv/combine (EQV4 x x1) (GF1F<=>GF1 x x1)))
                                (implies/reflexive)))
                            (implies/equiv (equiv/symmetric equiv/identity))))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-empty M9=M1+M8 M8=M9
    <- capset2perm-respects-eq M8=>PiM8 clsmap`eq/ predmap`eq/ cxt`eq/ M8=M9 permission`eq/
      M9=>PiM8
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L9 (PiFS3P=PiFS3) (P-EQ) (PiFS3P=PiFS1)
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS1 CP3F=CP OE EQV5
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o)).

%%% 5. unique+fresh + borrow
- : letRefTyping-helper/base/unique/L6/unique/false
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) _)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique+fresh _
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/borrow (SZ:set`size S1 (s _)) set`size/0
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/borrow)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/borrow SZ set`size/0
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/borrow)
        ([o] S1=>GF1 o)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
        (transform/inside [p]
          (transform/inside [v]
            (transform/inside [u]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans5
                      (implies/combine implies/reflexive % FIRST HALF
                        (implies/trans3
                          (implies/equiv equiv/identity)
                          (implies/combine
                            (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                              (implies/combine implies/reflexive
                                (implies/equiv (PiB0F<=>PiB0 x))))
                            (implies/combine implies/reflexive
                              (implies/trans
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv
                                      (equiv/transitive
                                        (PiU3<=>PiFS3P+PiU4' x)
                                        (EQV5 x)))
                                    (implies/combine
                                      (implies/cond-inner
                                        (bimplies/reflexive)
                                        (bimplies/reflexive)
                                        (implies/reflexive)
                                        (implies/equiv-encumbered
                                          (PiFS3P<=>PiFS3 x x)
                                          (equiv/reflexive)))
                                      (implies/equiv (PiU4'<=>PiU4 x))))
                                  (implies/trans
                                    (implies/equiv (PiM6<=>PiM3F+PiM7F x))
                                    (implies/combine implies/reflexive
                                      (implies/equiv (PiM7F<=>PiM7 x)))))
                                (implies/equiv equiv/swap-middle))))
                          (implies/equiv
                            (equiv/transitive4
                              (equiv/combine equiv/reflexive equiv/roll2)
                              (equiv/associate)
                              (equiv/combine equiv/swap equiv/reflexive)
                              (equiv/symmetric equiv/associate)))))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans5
                          (implies/equiv equiv/commute)
                          (implies/cond-push)
                          (implies/cond-gen-inner)
                          (implies/cond-inner
                            (bimplies/reflexive)
                            (bimplies/reflexive)
                            (implies/trans6
                              (implies/combine implies/reflexive
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv
                                      (equiv/transitive3
                                        (equiv/combine equiv/reflexive equiv/commute)
                                        (equiv/roll2)
                                        (equiv/combine
                                          (equiv/reflexive)
                                          (equiv/combine (EQV x) equiv/reflexive))))
                                    (IMP x))
                                  (implies/reflexive)))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans
                                  (implies/objequal PF)
                                  (implies/equiv (EQV2 o)))
                                (implies/reflexive))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans
                                  (implies/equiv equiv/associate)
                                  (implies/combine
                                    (implies/linear-modus-ponens)
                                    (implies/reflexive)))
                                (implies/reflexive))
                              (implies/equiv (equiv/symmetric equiv/identity)))
                            (implies/trans5
                              (implies/combine (implies/nonlinear2empty)
                                (implies/reflexive))
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/commute)
                                  (equiv/identity)))
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/symmetric equiv/associate))))
                              (implies/combine
                                (implies/reflexive)
                                (implies/trans5
                                  (implies/combine implies/reflexive
                                    (implies/equiv equiv/roll4))
                                  (implies/equiv equiv/associate)
                                  (implies/combine
                                    (implies/trans
                                      (implies/combine
                                        (implies/equiv (EQV3 x))
                                        (implies/reflexive))
                                      (implies/linear-modus-ponens))
                                    (implies/reflexive))
                                  (implies/combine implies/reflexive % PiS
                                    (implies/trans3
                                      (implies/combine implies/reflexive
                                        (implies/equiv equiv/reorder))
                                      (implies/equiv equiv/associate)
                                      (implies/combine
                                        (implies/trans
                                          (implies/combine
                                            (implies/equiv (PiM3F<=>PiM3 x))
                                            (implies/reflexive))
                                          (implies/linear-modus-ponens))
                                        (implies/combine implies/reflexive
                                          implies/linear-modus-ponens))))
                                  (implies/equiv
                                    (equiv/transitive3
                                      (equiv/combine equiv/reflexive
                                        (equiv/transitive3
                                          (equiv/combine equiv/reflexive equiv/commute)
                                          (equiv/associate)
                                          (equiv/combine equiv/commute equiv/reflexive)))
                                      (equiv/associate)
                                      (equiv/combine equiv/commute equiv/reflexive)))))
                              (implies/equiv equiv/roll2)))
                          (implies/cond-pull))
                        (implies/reflexive))
                      (implies/equiv
                        (equiv/transitive6
                          (equiv/symmetric equiv/associate)
                          (equiv/combine equiv/reflexive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/commute))))
                          (equiv/combine equiv/reflexive
                            (equiv/roll3))
                          (equiv/associate)
                          (equiv/combine
                            (equiv/transitive3
                              (equiv/commute)
                              (equiv/combine equiv/commute equiv/reflexive)
                              (equiv/swap-middle))
                            (equiv/reflexive))
                          (equiv/combine
                            (equiv/combine
                              (equiv/transitive4
                                (equiv/commute)
                                (equiv/symmetric equiv/associate)
                                (equiv/combine equiv/reflexive
                                  (PiM2+PiM7<=>PiM8))
                                (equiv/transitive equiv/swap
                                  (equiv/combine
                                    (PiM1+PiM8<=>PiM9)
                                    (equiv/reflexive))))
                              (PiU4+PiS<=>PiU5))
                            (equiv/reflexive))))
                      (implies/equiv
                        (equiv/transitive4
                          (equiv/combine
                            (equiv/transitive
                              (equiv/swap)
                              (equiv/commute))
                            (equiv/reflexive))
                          (equiv/symmetric-associate)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive
                              (equiv/roll2)
                              (equiv/combine equiv/reflexive
                                (equiv/transitive3
                                  (equiv/roll2)
                                  (equiv/combine equiv/reflexive
                                    (equiv/transitive
                                      (equiv/commute)
                                      (equiv/combine
                                        (equiv/combine
                                          (EQV4 x v) (GF1F<=>GF1 x v)) equiv/commute)))
                                  (equiv/symmetric equiv/identity)))))
                          (equiv/associate)))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- ({x}{o} permission`eq-implies-equiv (PiFS3P=PiFS3 x o) (PiFS3P<=>PiFS3 x o))
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6 x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM8 PiM9 M9=>PiM9 PiM1+PiM8<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L5 PiFS3P CP3F=CP3 OE EQV5
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o)).

%%% 6. fresh + unique
- : letRefTyping-helper/base/unique/L6/unique/false
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) N!<M11)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/fresh set`size/0
      (ty2perm/ (PML1:predmap`lookup PM C CP) (NN2P1:nn2perm NN _ PF1) annot2perm/unique)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/unique (SZ-M11:set`size M11 (s _))
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) A2P1)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 set/0 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 set/0 U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU4:make-encumbered CM PM B0 U5 PiU4)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/unique SZ-M11
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o)
        (B0+M11=>PiM11: capset2perm CM PM B0 M11 PiM11)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [x1]
            (transform/inside [o1]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans7
                      (implies/combine implies/reflexive
                        (implies/trans3
                          (implies/equiv equiv/identity)
                          (implies/combine implies/reflexive (implies/equiv equiv/commute))
                          (implies/equiv equiv/reorder)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/combine
                            (implies/trans
                              (implies/equiv (PiU3<=>PiFS3P+PiU4' x))
                              (implies/combine (implies/equiv (EQV5 x))
                                (implies/equiv (PiU4'<=>PiU4 x))))
                            (implies/equiv (PiM6F<=>PiM3F+PiM7F x))))
                        (implies/combine
                          (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                            (implies/combine implies/reflexive
                              (implies/equiv (PiB0F<=>PiB0 x))))
                          (implies/reflexive)))
                      (implies/combine implies/reflexive
                        (implies/equiv (equiv/symmetric equiv/associate)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans4
                          (implies/equiv (equiv/symmetric equiv/associate))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/equiv
                                (equiv/transitive5
                                  (equiv/commute)
                                  (equiv/combine equiv/reflexive
                                    (equiv/symmetric equiv/associate))
                                  (equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/reorder))
                                  (equiv/associate)))
                              (implies/combine
                                (implies/trans3
                                  (implies/equiv equiv/commute)
                                  (implies/combine implies/reflexive
                                    (implies/combine (implies/equiv (EQV x))
                                      (implies/reflexive)))
                                  (IMP x))
                                (implies/reflexive))))
                          (implies/trans3
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans3
                                (implies/equiv equiv/commute)
                                (implies/combine (implies/equiv (EQV2 x)) implies/reflexive)
                                (implies/linear-modus-ponens))
                              (implies/reflexive))
                            (implies/equiv equiv/reorder))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/combine implies/reflexive
                                (implies/equiv (PiM7F<=>PiM7 x)))
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/swap)
                                  (equiv/combine (PiM1+PiM7<=>PiM9) equiv/reflexive))))))
                        (implies/reflexive))
                      (implies/trans3
                        (implies/combine
                          (implies/trans implies/associate implies/commute)
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/cond-inner
                                (bimplies/reflexive)
                                (bimplies/reflexive)
                                (implies/reflexive)
                                (implies/equiv (GF1F<=>GF1 x x1)))
                              (implies/equiv (EQV6 x o1)))))
                        (implies/symmetric-associate)
                        (implies/combine implies/reflexive
                          (implies/trans3
                            (implies/equiv equiv/reorder)
                            (implies/combine implies/reflexive implies/commute)
                            (implies/equiv (equiv/symmetric equiv/identity)))))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- set`union-unique set`union/R U4+S=U5 set`eq/ set`eq/ U4=U5
    <- make-encumbered-respects-eq U4=>PiU4 clsmap`eq/ predmap`eq/ cxt`eq/
      U4=U5 permission`eq/ U5=>PiU4
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-empty M8=M2+M7 M7=M8
    <- set`eq-symmetric M7=M8 M8=M7
    <- capset2perm-respects-eq M7=>PiM7 clsmap`eq/ predmap`eq/ cxt`eq/ M7=M8 permission`eq/
      M8=>PiM7
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM7 PiM9 M9=>PiM9 PiM1+PiM7<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS3 CP3F=CP3 OE EQV5
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o))
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M11=>PiM11F N!<B0 B0+N=B1 PiM11
      B0+M11=>PiM11 PiM11F=PiM11
    <- letRefTyping-helper/base/unique/L6L7 PF2 CP2F=CP2 PiM11F=PiM11 EQV6.

%%% 7. borrow + unique
- : letRefTyping-helper/base/unique/L6/unique/false
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) N!<M11)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/borrow set`size/0 _
      (ty2perm/ (PML1:predmap`lookup PM C CP) (NN2P1:nn2perm NN _ PF1) annot2perm/unique)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/unique (SZ-M11:set`size M11 (s _))
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) A2P1)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 set/0 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 set/0 U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU4:make-encumbered CM PM B0 U5 PiU4)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/unique SZ-M11
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o)
        (B0+M11=>PiM11: capset2perm CM PM B0 M11 PiM11)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [x1]
            (transform/inside [o1]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans7
                      (implies/combine implies/reflexive
                        (implies/trans3
                          (implies/equiv equiv/identity)
                          (implies/combine implies/reflexive (implies/equiv equiv/commute))
                          (implies/equiv equiv/reorder)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/combine
                            (implies/trans
                              (implies/equiv (PiU3<=>PiFS3P+PiU4' x))
                              (implies/combine (implies/equiv (EQV5 x))
                                (implies/equiv (PiU4'<=>PiU4 x))))
                            (implies/equiv (PiM6F<=>PiM3F+PiM7F x))))
                        (implies/combine
                          (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                            (implies/combine implies/reflexive
                              (implies/equiv (PiB0F<=>PiB0 x))))
                          (implies/reflexive)))
                      (implies/combine implies/reflexive
                        (implies/equiv (equiv/symmetric equiv/associate)))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans4
                          (implies/equiv (equiv/symmetric equiv/associate))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/equiv
                                (equiv/transitive5
                                  (equiv/commute)
                                  (equiv/combine equiv/reflexive
                                    (equiv/symmetric equiv/associate))
                                  (equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/reorder))
                                  (equiv/associate)))
                              (implies/combine
                                (implies/trans3
                                  (implies/equiv equiv/commute)
                                  (implies/combine implies/reflexive
                                    (implies/combine (implies/equiv (EQV x))
                                      (implies/reflexive)))
                                  (IMP x))
                                (implies/reflexive))))
                          (implies/trans3
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans3
                                (implies/equiv equiv/commute)
                                (implies/combine (implies/equiv (EQV2 x)) implies/reflexive)
                                (implies/linear-modus-ponens))
                              (implies/reflexive))
                            (implies/equiv equiv/reorder))
                          (implies/combine implies/reflexive
                            (implies/trans
                              (implies/combine implies/reflexive
                                (implies/equiv (PiM7F<=>PiM7 x)))
                              (implies/equiv (PiM1+PiM7<=>PiM9)))))
                        (implies/reflexive))
                      (implies/trans6
                        (implies/equiv equiv/commute)
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine implies/reflexive
                          (implies/combine
                            ((implies/combine
                               (implies/cond-inner
                                 (bimplies/reflexive)
                                 (bimplies/reflexive)
                                 (implies/reflexive)
                                 (implies/equiv (GF1F<=>GF1 x x1)))
                               (implies/equiv (EQV6 x o1))))
                            (implies/reflexive)))
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/equiv equiv/commute))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- set`union-unique set`union/R U4+S=U5 set`eq/ set`eq/ U4=U5
    <- make-encumbered-respects-eq U4=>PiU4 clsmap`eq/ predmap`eq/ cxt`eq/
      U4=U5 permission`eq/ U5=>PiU4
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-empty M8=M2+M7 M7=M8
    <- set`eq-symmetric M7=M8 M8=M7
    <- capset2perm-respects-eq M7=>PiM7 clsmap`eq/ predmap`eq/ cxt`eq/ M7=M8 permission`eq/
      M8=>PiM7
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM7 PiM9 M9=>PiM9 PiM1+PiM7<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS3 CP3F=CP3 OE EQV5
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o))
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M11=>PiM11F N!<B0 B0+N=B1 PiM11
      B0+M11=>PiM11 PiM11F=PiM11
    <- letRefTyping-helper/base/unique/L6L7 PF2 CP2F=CP2 PiM11F=PiM11 EQV6.

%%% 8. unique + unique
- : letRefTyping-helper/base/unique/L6/unique/false
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) N!<M11)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique _ _
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/unique (SZ-M11:set`size M11 (s _))
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/unique SZ-M11
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o)
        (B0+M11=>PiM11: capset2perm CM PM B0 M11 PiM11)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [v]
            (transform/inside [u]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans5
                      (implies/combine implies/reflexive % FIRST HALF
                        (implies/trans3
                          (implies/equiv equiv/identity)
                          (implies/combine
                            (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                              (implies/combine implies/reflexive
                                (implies/equiv (PiB0F<=>PiB0 x))))
                            (implies/combine implies/reflexive
                              (implies/trans
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv
                                      (equiv/transitive
                                        (PiU3<=>PiFS3P+PiU4' x)
                                        (EQV5 x)))
                                    (implies/combine
                                      (implies/cond-inner
                                        (bimplies/reflexive)
                                        (bimplies/reflexive)
                                        (implies/reflexive)
                                        (implies/equiv-encumbered
                                          (PiFS3P<=>PiFS3 x x)
                                          (equiv/reflexive)))
                                      (implies/equiv (PiU4'<=>PiU4 x))))
                                  (implies/trans
                                    (implies/equiv (PiM6<=>PiM3F+PiM7F x))
                                    (implies/combine implies/reflexive
                                      (implies/equiv (PiM7F<=>PiM7 x)))))
                                (implies/equiv equiv/swap-middle))))
                          (implies/equiv
                            (equiv/transitive4
                              (equiv/combine equiv/reflexive equiv/roll2)
                              (equiv/associate)
                              (equiv/combine equiv/swap equiv/reflexive)
                              (equiv/symmetric equiv/associate)))))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans5
                          (implies/equiv equiv/commute)
                          (implies/cond-push)
                          (implies/cond-gen-inner)
                          (implies/cond-inner
                            (bimplies/reflexive)
                            (bimplies/reflexive)
                            (implies/trans6
                              (implies/combine implies/reflexive
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv
                                      (equiv/transitive3
                                        (equiv/combine equiv/reflexive equiv/commute)
                                        (equiv/roll2)
                                        (equiv/combine
                                          (equiv/reflexive)
                                          (equiv/combine (EQV x) equiv/reflexive))))
                                    (IMP x))
                                  (implies/reflexive)))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans
                                  (implies/objequal PF)
                                  (implies/equiv (EQV2 o)))
                                (implies/reflexive))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans
                                  (implies/equiv equiv/associate)
                                  (implies/combine
                                    (implies/linear-modus-ponens)
                                    (implies/reflexive)))
                                (implies/reflexive))
                              (implies/equiv (equiv/symmetric equiv/identity)))
                            (implies/trans5
                              (implies/combine (implies/nonlinear2empty)
                                (implies/reflexive))
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/commute)
                                  (equiv/identity)))
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/symmetric equiv/associate))))
                              (implies/combine
                                (implies/reflexive)
                                (implies/trans5
                                  (implies/combine implies/reflexive
                                    (implies/equiv equiv/roll4))
                                  (implies/equiv equiv/associate)
                                  (implies/combine
                                    (implies/trans
                                      (implies/combine
                                        (implies/equiv (EQV3 x))
                                        (implies/reflexive))
                                      (implies/linear-modus-ponens))
                                    (implies/reflexive))
                                  (implies/combine implies/reflexive % PiS
                                    (implies/trans3
                                      (implies/combine implies/reflexive
                                        (implies/equiv equiv/reorder))
                                      (implies/equiv equiv/associate)
                                      (implies/combine
                                        (implies/trans
                                          (implies/combine
                                            (implies/equiv (PiM3F<=>PiM3 x))
                                            (implies/reflexive))
                                          (implies/linear-modus-ponens))
                                        (implies/combine implies/reflexive
                                          implies/linear-modus-ponens))))
                                  (implies/equiv
                                    (equiv/transitive3
                                      (equiv/combine equiv/reflexive
                                        (equiv/transitive3
                                          (equiv/combine equiv/reflexive equiv/commute)
                                          (equiv/associate)
                                          (equiv/combine equiv/commute equiv/reflexive)))
                                      (equiv/associate)
                                      (equiv/combine equiv/commute equiv/reflexive)))))
                              (implies/equiv equiv/roll2)))
                          (implies/cond-pull))
                        (implies/reflexive))
                      (implies/equiv
                        (equiv/transitive6
                          (equiv/symmetric equiv/associate)
                          (equiv/combine equiv/reflexive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/commute))))
                          (equiv/combine equiv/reflexive
                            (equiv/roll3))
                          (equiv/associate)
                          (equiv/combine
                            (equiv/transitive3
                              (equiv/commute)
                              (equiv/combine equiv/commute equiv/reflexive)
                              (equiv/swap-middle))
                            (equiv/reflexive))
                          (equiv/combine
                            (equiv/combine
                              (equiv/transitive4
                                (equiv/commute)
                                (equiv/symmetric equiv/associate)
                                (equiv/combine equiv/reflexive
                                  (PiM2+PiM7<=>PiM8))
                                (PiM1+PiM8<=>PiM9))
                              (PiU4+PiS<=>PiU5))
                            (equiv/reflexive))))
                      (implies/equiv
                        (equiv/transitive
                          (equiv/roll2)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive3
                              (equiv/roll2)
                              (equiv/combine equiv/reflexive
                                (equiv/transitive
                                  (equiv/commute)
                                  (equiv/combine
                                    (equiv/combine
                                      (GF1F<=>GF1 x v u)
                                      (EQV6 x u))
                                    (equiv/commute))))
                              (equiv/symmetric equiv/identity)))))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- ({x}{o} permission`eq-implies-equiv (PiFS3P=PiFS3 x o) (PiFS3P<=>PiFS3 x o))
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6 x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM8 PiM9 M9=>PiM9 PiM1+PiM8<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L5 PiFS3P CP3F=CP3 OE EQV5
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- letRefTyping-helper/base/unique/L6L6 GF1F=GF1 GF1F<=>GF1
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M11=>PiM11F N!<B0 B0+N=B1 PiM11
      B0+M11=>PiM11 PiM11F=PiM11
    <- letRefTyping-helper/base/unique/L6L7 PF2 CP2F=CP2 PiM11F=PiM11 EQV6.

%%% 9/ unique/2 + unique
- : letRefTyping-helper/base/unique/L6/unique/false
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) N!<M11)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique/2 _ set`size/0
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/unique (SZ-M11:set`size M11 (s _))
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 set/0 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM8:capset2perm CM PM B0 M9 PiM8))
      (reftype2perm/unique SZ-M11
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o)
        (B0+M11=>PiM11: capset2perm CM PM B0 M11 PiM11)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [x1]
              (transform/inside [o1]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans4
                        (implies/equiv
                          (equiv/transitive % TRANS 2ND part
                            (equiv/combine
                              (equiv/reflexive)
                              (equiv/transitive3
                                (equiv/identity)
                                (equiv/combine
                                  (equiv/transitive (PiB1<=>PF1+PiB0F x)
                                    (equiv/combine equiv/reflexive (PiB0F<=>PiB0 x)))
                                  (equiv/combine (equiv/reflexive)
                                    (equiv/combine
                                      (equiv/transitive
                                        (PiU3<=>PiFS3P+PiU4' x)
                                        (equiv/combine (EQV5 x) (PiU4'<=>PiU4 x)))
                                      (equiv/transitive
                                        (PiM6F<=>PiM3F+PiM7F x)
                                        (equiv/combine (PiM3F<=>PiM3 x) (PiM7F<=>PiM7 x))))))
                                (equiv/transitive
                                  (equiv/combine equiv/reflexive equiv/commute)
                                  (equiv/roll2))))
                            (equiv/associate)))
                        (implies/combine
                          (implies/trans5
                            (implies/combine implies/reflexive
                              (implies/equiv equiv/swap-middle))
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans
                                (implies/equiv equiv/swap)
                                (implies/combine
                                  (implies/trans4
                                    (implies/equiv equiv/swap)
                                    (implies/combine
                                      (implies/trans % (S -|- PiS GF PiM3 -|- PiM2) (S PiM3)
                                        (implies/equiv equiv/associate)
                                        (implies/combine
                                          (implies/trans
                                            (implies/equiv equiv/commute)
                                            (implies/linear-modus-ponens))
                                          (implies/reflexive)))
                                      (implies/reflexive))
                                    (implies/equiv equiv/swap-middle)
                                    (implies/combine
                                      (implies/reflexive)
                                      (implies/linear-modus-ponens)))
                                  (implies/reflexive)))
                              (implies/reflexive))
                            (implies/equiv equiv/swap)
                            (implies/combine
                              (implies/trans
                                (implies/equiv equiv/swap-middle)
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv equiv/swap)
                                    (implies/combine
                                      (implies/trans
                                        (implies/equiv equiv/commute)
                                        (implies/equiv (PiU4+PiS<=>PiU5)))
                                      (implies/reflexive)))
                                  (implies/equiv
                                    (PiM2+PiM7<=>PiM8))))
                              (implies/reflexive)))
                          (implies/reflexive))
                        (implies/equiv
                          (equiv/transitive3
                            (equiv/combine
                              (equiv/transitive3
                                (equiv/combine equiv/swap equiv/reflexive)
                                (equiv/symmetric equiv/associate)
                                (equiv/commute))
                              (equiv/symmetric equiv/associate))
                            (equiv/swap-middle)
                            (equiv/combine equiv/reflexive
                              (equiv/transitive
                                (equiv/reorder)
                                (equiv/combine equiv/reflexive equiv/commute)))))
                        (implies/combine
                          (implies/reflexive)
                          (implies/trans
                            (implies/combine implies/reflexive
                              (implies/combine
                                (implies/combine
                                  (implies/equiv (GF1F<=>GF1 x x1 o1))
                                  (implies/equiv (EQV6 x o1)))
                                (implies/reflexive)))
                            (implies/equiv (equiv/symmetric equiv/identity))))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-empty M9=M1+M8 M8=M9
    <- capset2perm-respects-eq M8=>PiM8 clsmap`eq/ predmap`eq/ cxt`eq/ M8=M9 permission`eq/
      M9=>PiM8
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L9 (PiFS3P=PiFS3) (P-EQ) (PiFS3P=PiFS1)
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS1 CP3F=CP OE EQV5
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- letRefTyping-helper/base/unique/L6L6 GF1F=GF1 GF1F<=>GF1
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M11=>PiM11F N!<B0 B0+N=B1 PiM11
      B0+M11=>PiM11 PiM11F=PiM11
    <- letRefTyping-helper/base/unique/L6L7 PF2 CP2F=CP2 PiM11F=PiM11 EQV6.

%%% 10. unique+fresh + unique
- : letRefTyping-helper/base/unique/L6/unique/false
    (not-in-targets/unique (N!<S1:set`not-member S1 (s N)) N!<M11)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique+fresh _
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/unique (SZ-M11:set`size M11 (s _))
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/unique SZ-M11
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o)
        (B0+M11=>PiM11: capset2perm CM PM B0 M11 PiM11)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [v]
            (transform/inside [u]
              (transform/inside [p1]
                (transform/trans
                  (transform/implies
                    (implies/trans5
                      (implies/combine implies/reflexive % FIRST HALF
                        (implies/trans3
                          (implies/equiv equiv/identity)
                          (implies/combine
                            (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                              (implies/combine implies/reflexive
                                (implies/equiv (PiB0F<=>PiB0 x))))
                            (implies/combine implies/reflexive
                              (implies/trans
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv
                                      (equiv/transitive
                                        (PiU3<=>PiFS3P+PiU4' x)
                                        (EQV5 x)))
                                    (implies/combine
                                      (implies/cond-inner
                                        (bimplies/reflexive)
                                        (bimplies/reflexive)
                                        (implies/reflexive)
                                        (implies/equiv-encumbered
                                          (PiFS3P<=>PiFS3 x x)
                                          (equiv/reflexive)))
                                      (implies/equiv (PiU4'<=>PiU4 x))))
                                  (implies/trans
                                    (implies/equiv (PiM6<=>PiM3F+PiM7F x))
                                    (implies/combine implies/reflexive
                                      (implies/equiv (PiM7F<=>PiM7 x)))))
                                (implies/equiv equiv/swap-middle))))
                          (implies/equiv
                            (equiv/transitive4
                              (equiv/combine equiv/reflexive equiv/roll2)
                              (equiv/associate)
                              (equiv/combine equiv/swap equiv/reflexive)
                              (equiv/symmetric equiv/associate)))))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans5
                          (implies/equiv equiv/commute)
                          (implies/cond-push)
                          (implies/cond-gen-inner)
                          (implies/cond-inner
                            (bimplies/reflexive)
                            (bimplies/reflexive)
                            (implies/trans6
                              (implies/combine implies/reflexive
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv
                                      (equiv/transitive3
                                        (equiv/combine equiv/reflexive equiv/commute)
                                        (equiv/roll2)
                                        (equiv/combine
                                          (equiv/reflexive)
                                          (equiv/combine (EQV x) equiv/reflexive))))
                                    (IMP x))
                                  (implies/reflexive)))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans
                                  (implies/objequal PF)
                                  (implies/equiv (EQV2 o)))
                                (implies/reflexive))
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans
                                  (implies/equiv equiv/associate)
                                  (implies/combine
                                    (implies/linear-modus-ponens)
                                    (implies/reflexive)))
                                (implies/reflexive))
                              (implies/equiv (equiv/symmetric equiv/identity)))
                            (implies/trans5
                              (implies/combine (implies/nonlinear2empty)
                                (implies/reflexive))
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/commute)
                                  (equiv/identity)))
                              (implies/equiv
                                (equiv/transitive
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (equiv/symmetric equiv/associate))))
                              (implies/combine
                                (implies/reflexive)
                                (implies/trans5
                                  (implies/combine implies/reflexive
                                    (implies/equiv equiv/roll4))
                                  (implies/equiv equiv/associate)
                                  (implies/combine
                                    (implies/trans
                                      (implies/combine
                                        (implies/equiv (EQV3 x))
                                        (implies/reflexive))
                                      (implies/linear-modus-ponens))
                                    (implies/reflexive))
                                  (implies/combine implies/reflexive % PiS
                                    (implies/trans3
                                      (implies/combine implies/reflexive
                                        (implies/equiv equiv/reorder))
                                      (implies/equiv equiv/associate)
                                      (implies/combine
                                        (implies/trans
                                          (implies/combine
                                            (implies/equiv (PiM3F<=>PiM3 x))
                                            (implies/reflexive))
                                          (implies/linear-modus-ponens))
                                        (implies/combine implies/reflexive
                                          implies/linear-modus-ponens))))
                                  (implies/equiv
                                    (equiv/transitive3
                                      (equiv/combine equiv/reflexive
                                        (equiv/transitive3
                                          (equiv/combine equiv/reflexive equiv/commute)
                                          (equiv/associate)
                                          (equiv/combine equiv/commute equiv/reflexive)))
                                      (equiv/associate)
                                      (equiv/combine equiv/commute equiv/reflexive)))))
                              (implies/equiv equiv/roll2)))
                          (implies/cond-pull))
                        (implies/reflexive))
                      (implies/equiv
                        (equiv/transitive6
                          (equiv/symmetric equiv/associate)
                          (equiv/combine equiv/reflexive
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/commute))))
                          (equiv/combine equiv/reflexive
                            (equiv/roll3))
                          (equiv/associate)
                          (equiv/combine
                            (equiv/transitive3
                              (equiv/commute)
                              (equiv/combine equiv/commute equiv/reflexive)
                              (equiv/swap-middle))
                            (equiv/reflexive))
                          (equiv/combine
                            (equiv/combine
                              (equiv/transitive4
                                (equiv/commute)
                                (equiv/symmetric equiv/associate)
                                (equiv/combine equiv/reflexive
                                  (PiM2+PiM7<=>PiM8))
                                (equiv/transitive equiv/swap
                                  (equiv/combine
                                    (PiM1+PiM8<=>PiM9)
                                    (equiv/reflexive))))
                              (PiU4+PiS<=>PiU5))
                            (equiv/reflexive))))
                      (implies/equiv
                        (equiv/transitive4
                          (equiv/combine
                            (equiv/transitive
                              (equiv/swap)
                              (equiv/commute))
                            (equiv/reflexive))
                          (equiv/symmetric-associate)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive
                              (equiv/roll2)
                              (equiv/combine equiv/reflexive
                                (equiv/transitive3
                                  (equiv/roll2)
                                  (equiv/combine equiv/reflexive
                                    (equiv/transitive
                                      (equiv/commute)
                                      (equiv/combine
                                        (equiv/combine
                                          (GF1F<=>GF1 x v u)
                                          (EQV6 x u))
                                        (equiv/commute))))
                                  (equiv/symmetric equiv/identity)))))
                          (equiv/associate)))))
                  (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- ({x}{o} permission`eq-implies-equiv (PiFS3P=PiFS3 x o) (PiFS3P<=>PiFS3 x o))
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6 x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM8 PiM9 M9=>PiM9 PiM1+PiM8<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L5 PiFS3P CP3F=CP3 OE EQV5
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- letRefTyping-helper/base/unique/L6L6 GF1F=GF1 GF1F<=>GF1
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M11=>PiM11F N!<B0 B0+N=B1 PiM11
      B0+M11=>PiM11 PiM11F=PiM11
    <- letRefTyping-helper/base/unique/L6L7 PF2 CP2F=CP2 PiM11F=PiM11 EQV6.

%worlds (gtermvar)
(letRefTyping-helper/base/unique/L6/unique/false _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { }
(letRefTyping-helper/base/unique/L6/unique/false _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%%% The case for reftype2perm/fresh
%theorem letRefTyping-helper/base/unique/L6/unique/fresh
  : forall* {CM} {PM} {B1:object -> cxt} {B0} {N} {U3} {U4} {U5}
    {M1} {M2} {M3} {M6} {M7} {M8} {M9} {Out}
    {Pi2} {S} {NN} {C} {NN1} {C1} {FM} {FS}
    forall {N!<G1: not-in-targets (s N) targets/fresh}
    {N!<B0: cxt`fresh B0 (s N)}
    {B0+SN=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {N+FS=>M3: nat+set2set (s N) FS M3}
    {EC-FMT: unique-encumbered-perm-format CM PM B0 B1 S NN C M1 M2 M3 Pi2}
    {R2=>Out2: {x} result2output CM PM (B1 x)
               (result/expr (reftype/ NN1 C1 targets/fresh) (env/ U3 M6)) (Out x)}
    {M6-M3=M7: set`split M6 M3 M7}
    {M8=M2+M7: set`split M8 M2 M7}
    {M9=M1+M8: set`split M9 M1 M8}
    {SN!<U4: set`not-member U4 (s N)}
    {U4+SN=U3: set`add U4 (s N) U3}
    {U4+S=U5: set`union U4 S U5}
    exists {Out2} {Out3}
    {EA: {x}{o}{p:permission} envadd (Pi2 x o p) (Out x) (Out2 x o p)}
    {R2'=>Out3: result2output CM PM B0
                (result/expr (reftype/ NN1 C1 targets/fresh) (env/ U5 M9)) Out3}
    {TRANS: transform (output/exists [x]
                        (output/exists [o]
                          (output/exists [p:permission]
                            (Out2 x o p)))) Out3}
    true.

%%% 1. fresh
- : letRefTyping-helper/base/unique/L6/unique/fresh
    (not-in-targets/fresh)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/fresh set`size/0
      (ty2perm/ (PML1:predmap`lookup PM C CP) (NN2P1:nn2perm NN _ PF1) annot2perm/unique)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 set/0 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 set/0 U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [p1] (envadd/exists [o1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU4:make-encumbered CM PM B0 U5 PiU4)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
          (transform/inside [x1]
            (transform/inside [o1]
              (transform/inside [p1]
              (transform/trans
                (transform/implies
                  (implies/trans4
                    (implies/combine implies/reflexive
                      (implies/trans3
                        (implies/equiv equiv/identity)
                        (implies/combine implies/reflexive (implies/equiv equiv/commute))
                        (implies/equiv equiv/reorder)))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/combine implies/reflexive
                        (implies/combine
                          (implies/trans
                            (implies/equiv (PiU3<=>PiFS3P+PiU4' x))
                            (implies/combine (implies/equiv (EQV5 x))
                              (implies/equiv (PiU4'<=>PiU4 x))))
                          (implies/equiv (PiM6F<=>PiM3F+PiM7F x))))
                      (implies/combine
                        (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                          (implies/combine implies/reflexive
                            (implies/equiv (PiB0F<=>PiB0 x))))
                        (implies/reflexive)))
                    (implies/trans8
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            (equiv/transitive
                              (equiv/combine equiv/reflexive equiv/swap)
                              (equiv/roll2))
                            (equiv/transitive
                              (equiv/symmetric-associate)
                              (equiv/combine equiv/reflexive
                                (equiv/combine equiv/reflexive (EQV4 x x1)))))
                          (equiv/swap-middle)))
                      (implies/combine
                        (implies/trans3
                          (implies/combine implies/associate
                            (implies/equiv (EQV6 x x)))
                          (implies/equiv equiv/swap)
                          (implies/combine
                            (implies/trans4
                              (implies/combine implies/commute implies/reflexive)
                              (implies/symmetric-associate)
                              (implies/combine implies/reflexive implies/commute)
                              (implies/trans (IMP x) (implies/equiv (EQV2 x))))
                            (implies/equiv (PiM7F<=>PiM7 x))))
                        (implies/reflexive))
                      (implies/equiv equiv/swap-middle)
                      (implies/combine
                        (implies/trans
                          (implies/associate)
                          (implies/combine implies/linear-modus-ponens implies/reflexive))
                        (implies/reflexive))
                      (implies/equiv equiv/swap-middle)
                      (implies/combine
                        (implies/trans
                          (implies/equiv equiv/swap)
                          (implies/combine (implies/equiv PiM1+PiM7<=>PiM9) implies/reflexive))
                        (implies/reflexive))
                      (implies/equiv
                        (equiv/transitive3
                          (equiv/combine equiv/commute equiv/reflexive)
                          (equiv/symmetric-associate)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive4
                              (equiv/associate)
                              (equiv/combine equiv/commute equiv/reflexive)
                              (equiv/reorder)
                              (equiv/combine equiv/reflexive equiv/commute)))))
                      (implies/combine implies/reflexive
                        (implies/equiv (equiv/symmetric equiv/identity))))))
                (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- set`union-unique set`union/R U4+S=U5 set`eq/ set`eq/ U4=U5
    <- make-encumbered-respects-eq U4=>PiU4 clsmap`eq/ predmap`eq/ cxt`eq/
      U4=U5 permission`eq/ U5=>PiU4
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-empty M8=M2+M7 M7=M8
    <- set`eq-symmetric M7=M8 M8=M7
    <- capset2perm-respects-eq M7=>PiM7 clsmap`eq/ predmap`eq/ cxt`eq/ M7=M8 permission`eq/
      M8=>PiM7
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM7 PiM9 M9=>PiM9 PiM1+PiM7<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS3 CP3F=CP3 OE EQV5
    <- letRefTyping-helper/base/unique/L6L4 PF4 CP4F=CP3 EQV6
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 annot2perm/unique) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x)).

%%% 2. borrow
- : letRefTyping-helper/base/unique/L6/unique/fresh
    (not-in-targets/fresh)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/borrow set`size/0 _
      (ty2perm/ (PML1:predmap`lookup PM C CP) (NN2P1:nn2perm NN _ PF1) annot2perm/unique)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 set/0 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 set/0 U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU4:make-encumbered CM PM B0 U5 PiU4)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [x1]
              (transform/inside [o1]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans7
                        (implies/combine implies/reflexive
                          (implies/trans3
                            (implies/equiv equiv/identity)
                            (implies/combine implies/reflexive (implies/equiv equiv/commute))
                            (implies/equiv equiv/reorder)))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/trans
                                (implies/equiv (PiU3<=>PiFS3P+PiU4' x))
                                (implies/combine (implies/equiv (EQV5 x))
                                  (implies/equiv (PiU4'<=>PiU4 x))))
                              (implies/equiv (PiM6F<=>PiM3F+PiM7F x))))
                          (implies/combine
                            (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                              (implies/combine implies/reflexive
                                (implies/equiv (PiB0F<=>PiB0 x))))
                            (implies/reflexive)))
                        (implies/combine implies/reflexive
                          (implies/equiv (equiv/symmetric equiv/associate)))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans4
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine implies/reflexive
                              (implies/trans
                                (implies/equiv
                                  (equiv/transitive5
                                    (equiv/commute)
                                    (equiv/combine equiv/reflexive
                                      (equiv/symmetric equiv/associate))
                                    (equiv/associate)
                                    (equiv/combine equiv/reflexive
                                      (equiv/reorder))
                                    (equiv/associate)))
                                (implies/combine
                                  (implies/trans3
                                    (implies/equiv equiv/commute)
                                    (implies/combine implies/reflexive
                                      (implies/combine (implies/equiv (EQV x))
                                        (implies/reflexive)))
                                    (IMP x))
                                  (implies/reflexive))))
                            (implies/trans3
                              (implies/equiv equiv/associate)
                              (implies/combine
                                (implies/trans3
                                  (implies/equiv equiv/commute)
                                  (implies/combine (implies/equiv (EQV2 x)) implies/reflexive)
                                  (implies/linear-modus-ponens))
                                (implies/reflexive))
                              (implies/equiv equiv/reorder))
                            (implies/combine implies/reflexive
                              (implies/trans
                                (implies/combine implies/reflexive
                                  (implies/equiv (PiM7F<=>PiM7 x)))
                                (implies/equiv (PiM1+PiM7<=>PiM9)))))
                          (implies/reflexive))
                        (implies/equiv
                          (equiv/transitive6
                            (equiv/commute)
                            (equiv/combine
                              (equiv/combine equiv/reflexive (EQV4 x x1))
                              (equiv/reflexive))
                            (equiv/symmetric equiv/associate)
                            (equiv/symmetric equiv/identity)
                            (equiv/symmetric equiv/identity)
                            (equiv/commute)))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- set`union-unique set`union/R U4+S=U5 set`eq/ set`eq/ U4=U5
    <- make-encumbered-respects-eq U4=>PiU4 clsmap`eq/ predmap`eq/ cxt`eq/
      U4=U5 permission`eq/ U5=>PiU4
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-empty M8=M2+M7 M7=M8
    <- set`eq-symmetric M7=M8 M8=M7
    <- capset2perm-respects-eq M7=>PiM7 clsmap`eq/ predmap`eq/ cxt`eq/ M7=M8 permission`eq/
      M8=>PiM7
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM7 PiM9 M9=>PiM9 PiM1+PiM7<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS3 CP3F=CP3 OE EQV5
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 annot2perm/unique) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x)).

%%% 3. unique
- : letRefTyping-helper/base/unique/L6/unique/fresh
    (not-in-targets/fresh)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique _ _
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [v]
              (transform/inside [u]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans5
                        (implies/combine implies/reflexive % FIRST HALF
                          (implies/trans3
                            (implies/equiv equiv/identity)
                            (implies/combine
                              (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                                (implies/combine implies/reflexive
                                  (implies/equiv (PiB0F<=>PiB0 x))))
                              (implies/combine implies/reflexive
                                (implies/trans
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive
                                          (PiU3<=>PiFS3P+PiU4' x)
                                          (EQV5 x)))
                                      (implies/combine
                                        (implies/cond-inner
                                          (bimplies/reflexive)
                                          (bimplies/reflexive)
                                          (implies/reflexive)
                                          (implies/equiv-encumbered
                                            (PiFS3P<=>PiFS3 x x)
                                            (equiv/reflexive)))
                                        (implies/equiv (PiU4'<=>PiU4 x))))
                                    (implies/trans
                                      (implies/equiv (PiM6<=>PiM3F+PiM7F x))
                                      (implies/combine implies/reflexive
                                        (implies/equiv (PiM7F<=>PiM7 x)))))
                                  (implies/equiv equiv/swap-middle))))
                            (implies/equiv
                              (equiv/transitive4
                                (equiv/combine equiv/reflexive equiv/roll2)
                                (equiv/associate)
                                (equiv/combine equiv/swap equiv/reflexive)
                                (equiv/symmetric equiv/associate)))))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans5
                            (implies/equiv equiv/commute)
                            (implies/cond-push)
                            (implies/cond-gen-inner)
                            (implies/cond-inner
                              (bimplies/reflexive)
                              (bimplies/reflexive)
                              (implies/trans6
                                (implies/combine implies/reflexive
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive3
                                          (equiv/combine equiv/reflexive equiv/commute)
                                          (equiv/roll2)
                                          (equiv/combine
                                            (equiv/reflexive)
                                            (equiv/combine (EQV x) equiv/reflexive))))
                                      (IMP x))
                                    (implies/reflexive)))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/objequal PF)
                                    (implies/equiv (EQV2 o)))
                                  (implies/reflexive))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/linear-modus-ponens)
                                      (implies/reflexive)))
                                  (implies/reflexive))
                                (implies/equiv (equiv/symmetric equiv/identity)))
                              (implies/trans5
                                (implies/combine (implies/nonlinear2empty)
                                  (implies/reflexive))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/commute)
                                    (equiv/identity)))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/symmetric equiv/associate)
                                    (equiv/combine equiv/reflexive
                                      (equiv/symmetric equiv/associate))))
                                (implies/combine
                                  (implies/reflexive)
                                  (implies/trans5
                                    (implies/combine implies/reflexive
                                      (implies/equiv equiv/roll4))
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/trans
                                        (implies/combine
                                          (implies/equiv (EQV3 x))
                                          (implies/reflexive))
                                        (implies/linear-modus-ponens))
                                      (implies/reflexive))
                                    (implies/combine implies/reflexive % PiS
                                      (implies/trans3
                                        (implies/combine implies/reflexive
                                          (implies/equiv equiv/reorder))
                                        (implies/equiv equiv/associate)
                                        (implies/combine
                                          (implies/trans
                                            (implies/combine
                                              (implies/equiv (PiM3F<=>PiM3 x))
                                              (implies/reflexive))
                                            (implies/linear-modus-ponens))
                                          (implies/combine implies/reflexive
                                            implies/linear-modus-ponens))))
                                    (implies/equiv
                                      (equiv/transitive3
                                        (equiv/combine equiv/reflexive
                                          (equiv/transitive3
                                            (equiv/combine equiv/reflexive equiv/commute)
                                            (equiv/associate)
                                            (equiv/combine equiv/commute equiv/reflexive)))
                                        (equiv/associate)
                                        (equiv/combine equiv/commute equiv/reflexive)))))
                                (implies/equiv equiv/roll2)))
                            (implies/cond-pull))
                          (implies/reflexive))
                        (implies/equiv
                          (equiv/transitive6
                            (equiv/symmetric equiv/associate)
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/combine equiv/reflexive
                                  (equiv/commute))))
                            (equiv/combine equiv/reflexive
                              (equiv/roll3))
                            (equiv/associate)
                            (equiv/combine
                              (equiv/transitive3
                                (equiv/commute)
                                (equiv/combine equiv/commute equiv/reflexive)
                                (equiv/swap-middle))
                              (equiv/reflexive))
                            (equiv/combine
                              (equiv/combine
                                (equiv/transitive4
                                  (equiv/commute)
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (PiM2+PiM7<=>PiM8))
                                  (PiM1+PiM8<=>PiM9))
                                (PiU4+PiS<=>PiU5))
                              (equiv/reflexive))))
                        (implies/equiv
                          (equiv/transitive
                            (equiv/reorder)
                            (equiv/combine equiv/reflexive
                              (equiv/transitive4
                                (equiv/combine equiv/commute
                                  (equiv/combine equiv/reflexive (EQV4 x v)))
                                (equiv/commute)
                                (equiv/symmetric equiv/associate)
                                (equiv/symmetric equiv/identity)))))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- ({x}{o} permission`eq-implies-equiv (PiFS3P=PiFS3 x o) (PiFS3P<=>PiFS3 x o))
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6 x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM8 PiM9 M9=>PiM9 PiM1+PiM8<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- letRefTyping-helper/base/unique/L6L5 PiFS3P CP3F=CP3 OE EQV5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4.

%%% 4. unique/2
- : letRefTyping-helper/base/unique/L6/unique/fresh
    (not-in-targets/fresh)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique/2 _ set`size/0
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6F:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 set/0 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM8:capset2perm CM PM B0 M9 PiM8))
      (reftype2perm/fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [x1]
              (transform/inside [o1]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans4
                        (implies/equiv
                          (equiv/transitive % TRANS 2ND part
                            (equiv/combine
                              (equiv/reflexive)
                              (equiv/transitive3
                                (equiv/identity)
                                (equiv/combine
                                  (equiv/transitive (PiB1<=>PF1+PiB0F x)
                                    (equiv/combine equiv/reflexive (PiB0F<=>PiB0 x)))
                                  (equiv/combine (equiv/reflexive)
                                    (equiv/combine
                                      (equiv/transitive
                                        (PiU3<=>PiFS3P+PiU4' x)
                                        (equiv/combine (EQV5 x) (PiU4'<=>PiU4 x)))
                                      (equiv/transitive
                                        (PiM6F<=>PiM3F+PiM7F x)
                                        (equiv/combine (PiM3F<=>PiM3 x) (PiM7F<=>PiM7 x))))))
                                (equiv/transitive
                                  (equiv/combine equiv/reflexive equiv/commute)
                                  (equiv/roll2))))
                            (equiv/associate)))
                        (implies/combine
                          (implies/trans5
                            (implies/combine implies/reflexive
                              (implies/equiv equiv/swap-middle))
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/trans
                                (implies/equiv equiv/swap)
                                (implies/combine
                                  (implies/trans4
                                    (implies/equiv equiv/swap)
                                    (implies/combine
                                      (implies/trans % (S -|- PiS GF PiM3 -|- PiM2) (S PiM3)
                                        (implies/equiv equiv/associate)
                                        (implies/combine
                                          (implies/trans
                                            (implies/equiv equiv/commute)
                                            (implies/linear-modus-ponens))
                                          (implies/reflexive)))
                                      (implies/reflexive))
                                    (implies/equiv equiv/swap-middle)
                                    (implies/combine
                                      (implies/reflexive)
                                      (implies/linear-modus-ponens)))
                                  (implies/reflexive)))
                              (implies/reflexive))
                            (implies/equiv equiv/swap)
                            (implies/combine
                              (implies/trans
                                (implies/equiv equiv/swap-middle)
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv equiv/swap)
                                    (implies/combine
                                      (implies/trans
                                        (implies/equiv equiv/commute)
                                        (implies/equiv (PiU4+PiS<=>PiU5)))
                                      (implies/reflexive)))
                                  (implies/equiv
                                    (PiM2+PiM7<=>PiM8))))
                              (implies/reflexive)))
                          (implies/reflexive))
                        (implies/equiv
                          (equiv/transitive3
                            (equiv/combine
                              (equiv/transitive3
                                (equiv/combine equiv/swap equiv/reflexive)
                                (equiv/symmetric equiv/associate)
                                (equiv/commute))
                              (equiv/symmetric equiv/associate))
                            (equiv/swap-middle)
                            (equiv/combine equiv/reflexive
                              (equiv/transitive
                                (equiv/reorder)
                                (equiv/combine equiv/reflexive equiv/commute)))))
                        (implies/equiv
                          (equiv/combine equiv/reflexive
                            (equiv/transitive
                              (equiv/combine equiv/reflexive
                                (equiv/combine (EQV4 x x1) equiv/reflexive))
                              (equiv/symmetric equiv/identity))))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6F x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6F<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-empty M9=M1+M8 M8=M9
    <- capset2perm-respects-eq M8=>PiM8 clsmap`eq/ predmap`eq/ cxt`eq/ M8=M9 permission`eq/
      M9=>PiM8
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L9 (PiFS3P=PiFS3) (P-EQ) (PiFS3P=PiFS1)
    <- ({x} predicate`eq-transitive (CP3F=CP3 x) (CP3=CP) (CP3F=CP x))
    <- letRefTyping-helper/base/unique/L6L8 PiFS3P PiFS3P=PiFS1 CP3F=CP OE EQV5
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4.

%%% 5. unique+fresh
- : letRefTyping-helper/base/unique/L6/unique/fresh
    (not-in-targets/fresh)
    (N!<B0:cxt`fresh B0 (s N)) ([x] B0+N=B1 x)
    (CML:clsmap`lookup CM C FM) (FM-DM: fldmap`domain FM FS)
    (N+FS=M3: nat+set2set (s N) FS M3)
    (unique-encumbered-perm-format/unique+fresh _
      ([x] (B0+S=>GF:{x} set2cond B0 x S (GF x)) x)
      (CML1:clsmap`lookup CM C FM1)
      (PML1:predmap`lookup PM C CP)
      A2P1 (NN2P1:nn2perm NN _ PF1)
      (M1=>PiM1:capset2perm CM PM B0 M1 PiM1)
      (M2=>PiM2:capset2perm CM PM B0 M2 PiM2)
      ([x] (B1+M3=>PiM3: {x} capset2perm CM PM (B1 x) M3 (PiM3 x)) x)
      (S=>PiS:make-encumbered CM PM B0 S PiS)
      (FM-DM1:fldmap`domain FM1 FS1)
      ([x] (FS1=>PiFS1:{x} fldset2perm PM x FM1 FS1 (PiFS1 x)) x))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U3=>PiU3:{x} make-encumbered CM PM (B1 x) U3 (PiU3F x)) x)
        ((B1+M6=>PiM6:{x} capset2perm CM PM (B1 x) M6 (PiM6F x)) x))
      (reftype2perm/fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)))
    (M6-M3=M7:set`split M6 M3 M7)
    (M8=M2+M7:set`split M8 M2 M7)
    (M9=M1+M8:set`split M9 M1 M8)
    (SN!<U4: set`not-member U4 (s N))
    (U4+SN=U3: set`add U4 (s N) U3)
    (U4+S=U5:set`union U4 S U5)
    _ _ ([x][o][p] (envadd/exists [x1] (envadd/exists [o1] (envadd/exists [p1] (envadd/expr)))))
    (result2output/expr B0=>PiB0
      (env2input/ (U5=>PiU5:make-encumbered CM PM B0 U5 PiU5)
        (M9=>PiM9:capset2perm CM PM B0 M9 PiM9))
      (reftype2perm/fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [v]
              (transform/inside [u]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans6
                        (implies/combine implies/reflexive % FIRST HALF
                          (implies/trans3
                            (implies/equiv equiv/identity)
                            (implies/combine
                              (implies/trans (implies/equiv (PiB1<=>PF1+PiB0F x))
                                (implies/combine implies/reflexive
                                  (implies/equiv (PiB0F<=>PiB0 x))))
                              (implies/combine implies/reflexive
                                (implies/trans
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive
                                          (PiU3<=>PiFS3P+PiU4' x)
                                          (EQV5 x)))
                                      (implies/combine
                                        (implies/cond-inner
                                          (bimplies/reflexive)
                                          (bimplies/reflexive)
                                          (implies/reflexive)
                                          (implies/equiv-encumbered
                                            (PiFS3P<=>PiFS3 x x)
                                            (equiv/reflexive)))
                                        (implies/equiv (PiU4'<=>PiU4 x))))
                                    (implies/trans
                                      (implies/equiv (PiM6<=>PiM3F+PiM7F x))
                                      (implies/combine implies/reflexive
                                        (implies/equiv (PiM7F<=>PiM7 x)))))
                                  (implies/equiv equiv/swap-middle))))
                            (implies/equiv
                              (equiv/transitive4
                                (equiv/combine equiv/reflexive equiv/roll2)
                                (equiv/associate)
                                (equiv/combine equiv/swap equiv/reflexive)
                                (equiv/symmetric equiv/associate)))))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans5
                            (implies/equiv equiv/commute)
                            (implies/cond-push)
                            (implies/cond-gen-inner)
                            (implies/cond-inner
                              (bimplies/reflexive)
                              (bimplies/reflexive)
                              (implies/trans6
                                (implies/combine implies/reflexive
                                  (implies/combine
                                    (implies/trans
                                      (implies/equiv
                                        (equiv/transitive3
                                          (equiv/combine equiv/reflexive equiv/commute)
                                          (equiv/roll2)
                                          (equiv/combine
                                            (equiv/reflexive)
                                            (equiv/combine (EQV x) equiv/reflexive))))
                                      (IMP x))
                                    (implies/reflexive)))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/objequal PF)
                                    (implies/equiv (EQV2 o)))
                                  (implies/reflexive))
                                (implies/equiv equiv/associate)
                                (implies/combine
                                  (implies/trans
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/linear-modus-ponens)
                                      (implies/reflexive)))
                                  (implies/reflexive))
                                (implies/equiv (equiv/symmetric equiv/identity)))
                              (implies/trans5
                                (implies/combine (implies/nonlinear2empty)
                                  (implies/reflexive))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/commute)
                                    (equiv/identity)))
                                (implies/equiv
                                  (equiv/transitive
                                    (equiv/symmetric equiv/associate)
                                    (equiv/combine equiv/reflexive
                                      (equiv/symmetric equiv/associate))))
                                (implies/combine
                                  (implies/reflexive)
                                  (implies/trans5
                                    (implies/combine implies/reflexive
                                      (implies/equiv equiv/roll4))
                                    (implies/equiv equiv/associate)
                                    (implies/combine
                                      (implies/trans
                                        (implies/combine
                                          (implies/equiv (EQV3 x))
                                          (implies/reflexive))
                                        (implies/linear-modus-ponens))
                                      (implies/reflexive))
                                    (implies/combine implies/reflexive % PiS
                                      (implies/trans3
                                        (implies/combine implies/reflexive
                                          (implies/equiv equiv/reorder))
                                        (implies/equiv equiv/associate)
                                        (implies/combine
                                          (implies/trans
                                            (implies/combine
                                              (implies/equiv (PiM3F<=>PiM3 x))
                                              (implies/reflexive))
                                            (implies/linear-modus-ponens))
                                          (implies/combine implies/reflexive
                                            implies/linear-modus-ponens))))
                                    (implies/equiv
                                      (equiv/transitive3
                                        (equiv/combine equiv/reflexive
                                          (equiv/transitive3
                                            (equiv/combine equiv/reflexive equiv/commute)
                                            (equiv/associate)
                                            (equiv/combine equiv/commute equiv/reflexive)))
                                        (equiv/associate)
                                        (equiv/combine equiv/commute equiv/reflexive)))))
                                (implies/equiv equiv/roll2)))
                            (implies/cond-pull))
                          (implies/reflexive))
                        (implies/equiv
                          (equiv/transitive6
                            (equiv/symmetric equiv/associate)
                            (equiv/combine equiv/reflexive
                              (equiv/combine equiv/reflexive
                                (equiv/combine equiv/reflexive
                                  (equiv/commute))))
                            (equiv/combine equiv/reflexive
                              (equiv/roll3))
                            (equiv/associate)
                            (equiv/combine
                              (equiv/transitive3
                                (equiv/commute)
                                (equiv/combine equiv/commute equiv/reflexive)
                                (equiv/swap-middle))
                              (equiv/reflexive))
                            (equiv/combine
                              (equiv/combine
                                (equiv/transitive4
                                  (equiv/commute)
                                  (equiv/symmetric equiv/associate)
                                  (equiv/combine equiv/reflexive
                                    (PiM2+PiM7<=>PiM8))
                                  (equiv/transitive
                                    (equiv/swap)
                                    (equiv/combine PiM1+PiM8<=>PiM9 equiv/reflexive)))
                                (PiU4+PiS<=>PiU5))
                              (equiv/reflexive))))
                        (implies/equiv
                          (equiv/transitive
                            (equiv/reorder)
                            (equiv/combine equiv/reflexive
                              (equiv/transitive4
                                (equiv/combine equiv/commute
                                  (equiv/combine equiv/reflexive (EQV4 x v)))
                                (equiv/commute)
                                (equiv/symmetric equiv/associate)
                                (equiv/symmetric equiv/identity)))))
                        (implies/equiv
                          (equiv/transitive
                            (equiv/combine equiv/reflexive
                              (equiv/transitive
                                (equiv/combine
                                  (equiv/transitive
                                    (equiv/combine equiv/reflexive
                                      (equiv/combine equiv/reflexive
                                        (equiv/transitive equiv/associate equiv/commute)))
                                    (equiv/roll3))
                                  (equiv/reflexive))
                                (equiv/symmetric-associate)))
                            (equiv/associate)))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/unique
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/borrow))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} make-encumbered/U-inversion (B1+U3=>PiU3 x) SN!<U4 U4+SN=U3
         (PiU4' x) (B1+U4=>PiU4' x) (OK x) NNK AK CK (B1-LK x) FM3 CML3K (CP3F x)
         (PML3K x) FS3 FM-DM3
         (PiFS3P x) (FS3=>PiFS3P x) (PiU3<=>PiFS3P+PiU4' x))
    <- fldset2perm-no-var FS3=>PiFS3P PiFS3 PiFS3P=PiFS3 FS3=>PiFS3
    <- ({x}{o} permission`eq-implies-equiv (PiFS3P=PiFS3 x o) (PiFS3P<=>PiFS3 x o))
    <- cxt`fresh-update-preserves-make-encumbered-converse ([x] B1+U4=>PiU4' x)
      N!<B0 ([x] B0+N=B1 x) SN!<U4 PiU4 U4=>PiU4 ([x] PiU4'<=>PiU4 x)
    <- ({x} set`split-implies-permission-combine M6-M3=M7 (B1+M6=>PiM6 x)
         (PiM3F x) (PiM7F x) (B1+M3=>PiM3F x) (B1+M7=>PiM7F x) (PiM6<=>PiM3F+PiM7F x))
    <- cxt`fresh-update-preserves-capset2perm-converse ([x] B1+M7=>PiM7F x)
         N!<B0 ([x] B0+N=B1 x) PiM7 M7=>PiM7 ([x] PiM7F=PiM7 x)
    <- ({x} permission`eq-implies-equiv (PiM7F=PiM7 x) (PiM7F<=>PiM7 x))
    <- set`split-implies-permission-combine-converse M8=M2+M7 M2=>PiM2
      M7=>PiM7 PiM8 M8=>PiM8 PiM2+PiM7<=>PiM8
    <- set`split-implies-permission-combine-converse M9=M1+M8 M1=>PiM1
      M8=>PiM8 PiM9 M9=>PiM9 PiM1+PiM8<=>PiM9
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} cxt`lookup-unique (B1-LK x) (B1-L x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE (NNE:nonnull`eq NNK NN) (AE:annot`eq AK annot/unique) (CE:nat`eq CK C)
    <- clsmap`lookup-respects-eq CML3K clsmap`eq/ CE fldmap`eq/ CML3
    <- predmap`no-variable-lookup PML3K CP3 PML3L CP3F=CP3
    <- predmap`lookup-respects-eq PML3L predmap`eq/ CE clspred`eq/ PML3
    <- clsmap`lookup-unique CML CML3 clsmap`eq/ nat`eq/ (FM=FM3:fldmap`eq FM FM3)
    <- clsmap`lookup-unique CML3 CML1 clsmap`eq/ nat`eq/ (FM3=FM1:fldmap`eq FM3 FM1)
    <- fldmap`domain-unique FM-DM FM-DM3 FM=FM3 (FS=FS3:set`eq FS FS3)
    <- fldmap`domain-unique FM-DM3 FM-DM1 FM3=FM1 FS3=FS1
    <- nat+set2set-respects-eq N+FS=M3 nat`eq/ FS=FS3 set`eq/ N+FS3=M3
    <- letRefTyping-helper/base/unique/L6L1 CML3 PML3 NN2P4 FM-DM3
      B1-L N+FS3=M3 B1+M3=>PiM3F FS3=>PiFS3 PF T2PF IMP
    <- predmap`no-variable-lookup PML4F CP4 PML4 ([x] CP4F=CP4 x)
    <- predmap`lookup-unique PML4 PML3 predmap`eq/ nat`eq/ CP4=CP3
    <- ({x} predicate`eq-transitive (CP4F=CP4 x) CP4=CP3 (CP4F=CP3 x))
    <- predmap`lookup-unique PML3 PML1 predmap`eq/ nat`eq/ CP3=CP
    <- letRefTyping-helper/base/unique/L6L2 PF4 CP4F=CP3 EQV
    <- ty2perm-deterministic T2PF (ty2perm/ PML1 NN2P1 A2P1) predmap`eq/ ty`eq/ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV2 x))
    <- ({x} fldset2perm-unique (FS3=>PiFS3 x) (FS1=>PiFS1 x)
         predmap`eq/ object`eq/ FM3=FM1 FS3=FS1 (P-EQ x))
    <- letRefTyping-helper/base/unique/L6L3 P-EQ CP3=CP ([x] EQV3 x)
    <- ({x} capset2perm-equiv (B1+M3=>PiM3F x) (B1+M3=>PiM3 x) clsmap`eq/
         predmap`eq/ cxt`eq/ set`eq/ (PiM3F<=>PiM3 x))
    <- make-encumbered-intro-reverse U4+S=U5 U4=>PiU4 S=>PiS PiU5
      U5=>PiU5 PiU4+PiS<=>PiU5
    <- letRefTyping-helper/base/unique/L6L5 PiFS3P CP3F=CP3 OE EQV5
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4.

%worlds (gtermvar)
(letRefTyping-helper/base/unique/L6/unique/fresh _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { }
(letRefTyping-helper/base/unique/L6/unique/fresh _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L6
  : forall* {CM} {PM} {B1:object -> cxt} {B0} {N} {U3} {U4} {U5}
    {M1} {M2} {M3} {M6} {M7} {M8} {M9} {Out}
    {Pi2} {S} {NN} {C} {NN1} {C1} {FM} {FS}
    forall {G1} {N!<G1: not-in-targets (s N) G1}
    {N!<B0: cxt`fresh B0 (s N)}
    {B0+SN=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {N+FS=>M3: nat+set2set (s N) FS M3}
    {EC-FMT: unique-encumbered-perm-format CM PM B0 B1 S NN C M1 M2 M3 Pi2}
    {R2=>Out2: {x} result2output CM PM (B1 x)
               (result/expr (reftype/ NN1 C1 G1) (env/ U3 M6)) (Out x)}
    {M6-M3=M7: set`split M6 M3 M7}
    {M8=M2+M7: set`split M8 M2 M7}
    {M9=M1+M8: set`split M9 M1 M8}
    {SN!<U4: set`not-member U4 (s N)}
    {U4+SN=U3: set`add U4 (s N) U3}
    {U4+S=U5: set`union U4 S U5}
    exists {Out2} {Out3}
    {EA: {x}{o}{p:permission} envadd (Pi2 x o p) (Out x) (Out2 x o p)}
    {R2'=>Out3: result2output CM PM B0
                (result/expr (reftype/ NN1 C1 G1) (env/ U5 M9)) Out3}
    {TRANS: transform (output/exists [x]
                        (output/exists [o]
                          (output/exists [p:permission]
                            (Out2 x o p)))) Out3}
    true.

- : letRefTyping-helper/base/unique/L6 targets/shared N!<G1 N!<B0 B0+SN=B1
    CML FM-DM N+FS=>M3 EC-FMT R2=>O2 M6-M3=M7 M8=M2+M7 M9=M1+M8 SN!<U4 U4+SN=U3 U4+S=U5
    _ _ EA R2=>O3 TRANS
    <- letRefTyping-helper/base/unique/L6/shared N!<B0 B0+SN=B1
    CML FM-DM N+FS=>M3 EC-FMT R2=>O2 M6-M3=M7 M8=M2+M7 M9=M1+M8 SN!<U4 U4+SN=U3 U4+S=U5
      _ _ EA R2=>O3 TRANS.

- : letRefTyping-helper/base/unique/L6 (targets/unique _ _ true) N!<G1 N!<B0 B0+SN=B1
    CML FM-DM N+FS=>M3 EC-FMT R2=>O2 M6-M3=M7 M8=M2+M7 M9=M1+M8 SN!<U4 U4+SN=U3 U4+S=U5
    _ _ EA R2=>O3 TRANS
    <- letRefTyping-helper/base/unique/L6/unique/true N!<G1 N!<B0 B0+SN=B1
    CML FM-DM N+FS=>M3 EC-FMT R2=>O2 M6-M3=M7 M8=M2+M7 M9=M1+M8 SN!<U4 U4+SN=U3 U4+S=U5
      _ _ EA R2=>O3 TRANS.

- : letRefTyping-helper/base/unique/L6 (targets/unique _ _ false) N!<G1 N!<B0 B0+SN=B1
    CML FM-DM N+FS=>M3 EC-FMT R2=>O2 M6-M3=M7 M8=M2+M7 M9=M1+M8 SN!<U4 U4+SN=U3 U4+S=U5
    _ _ EA R2=>O3 TRANS
    <- letRefTyping-helper/base/unique/L6/unique/false N!<G1 N!<B0 B0+SN=B1
    CML FM-DM N+FS=>M3 EC-FMT R2=>O2 M6-M3=M7 M8=M2+M7 M9=M1+M8 SN!<U4 U4+SN=U3 U4+S=U5
      _ _ EA R2=>O3 TRANS.

- : letRefTyping-helper/base/unique/L6 targets/fresh N!<G1 N!<B0 B0+SN=B1
    CML FM-DM N+FS=>M3 EC-FMT R2=>O2 M6-M3=M7 M8=M2+M7 M9=M1+M8 SN!<U4 U4+SN=U3 U4+S=U5
    _ _ EA R2=>O3 TRANS
    <- letRefTyping-helper/base/unique/L6/unique/fresh N!<G1 N!<B0 B0+SN=B1
    CML FM-DM N+FS=>M3 EC-FMT R2=>O2 M6-M3=M7 M8=M2+M7 M9=M1+M8 SN!<U4 U4+SN=U3 U4+S=U5
      _ _ EA R2=>O3 TRANS.

%worlds (gtermvar) (letRefTyping-helper/base/unique/L6 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/unique/L6 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/shared/before
  : forall* {CM} {PM} {NN} {C} {B0} {B1} {Out} {N} {V0}
    forall {N!<B0: cxt`fresh B0 N}
    {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)}
    {CM-B0: clsmap-cxt CM B0}
    {CM-Rslt: clsmap-result CM B0
              (result/expr (reftype/ NN C targets/shared) V0)}
    {Rslt=>Out: result2output CM PM B0
                (result/expr (reftype/ NN C targets/shared) V0) Out}
    exists {PiB1} {Pi}
    {CM-B1: {x} clsmap-cxt CM (B1 x)}
    {CM-V: {x} clsmap-cxt-env CM (B1 x) V0}
    {V=>Pi: {x} env2input CM PM (B1 x) V0 (Pi x)}
    {B1=>PiB1: {x} cxt2perm PM (B1 x) (PiB1 x)}
    {TRANS: transform Out
            (output/exists [x:object]
              (output/exists [o:object]
                (output/exists [p:permission]
                  (output/expr x (combine (PiB1 x) (Pi x))))))}
    true.

- : letRefTyping-helper/base/shared/before
    (N!<B0:cxt`fresh B0 N) ([x] B0+N=B1 x) CM-B0
    (clsmap-result/expr
      (clsmap-cxt-reftype/shared CML)
      (clsmap-cxt-env/ (CM-B0-U0:clsmap-cxt-objset CM B0 U0)
        (CM-B0-M:clsmap-cxt-capset CM B0 M0)))
    (result2output/expr (B0=>PiB0:cxt2perm PM B0 PiB0)
      (env2input/ (B0+U0=>PiU0: make-encumbered CM PM B0 U0 PiU0)
        (M0=>PiM0:capset2perm CM PM B0 M0 PiM0))
      (reftype2perm/shared (ty2perm/ PML NN2P annot2perm/shared))) _ _
    ([x] clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
    ([x] clsmap-cxt-env/ (CM-B1-U0 x) (CM-B1-M x))
    ([x] env2input/ (B1+U0=>PiU0 x) (B1+M0=>PiM0 x))
    ([x] cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x)
      (ty2perm2/shared (ty2perm/ PML NN2P annot2perm/shared)))
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/implies
            (implies/equiv
              (equiv/transitive3
                (equiv/identity)
                (equiv/associate)
                (equiv/combine (equiv/commute) (equiv/reflexive))))))))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capset CM-B0-M N!<B0 (B0+N=B1 x) (CM-B1-M x))
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-objset CM-B0-U0 N!<B0 (B0+N=B1 x) (CM-B1-U0 x))
    <- ({x} cxt-fresh-update-preserves-capset2perm M0=>PiM0 N!<B0 (B0+N=B1 x) (B1+M0=>PiM0 x))
    <- ({x} cxt-fresh-update-preserves-make-encumbered B0+U0=>PiU0 N!<B0 (B0+N=B1 x)
         (B1+U0=>PiU0 x)).

%worlds (gtermvar) (letRefTyping-helper/base/shared/before _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/shared/before _ _ _ _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/shared/after/L1
  : forall* {CM} {BF} {N} {NN} {U} {C}
    forall {BL: {x} cxt`lookup (BF x) N (cxt-info/ x (ty/ NN annot/shared C))}
    {CM-B1-U: {x} clsmap-cxt-objset CM (BF x) U}
    exists {N!<U: set`not-member U N}
    true.

%theorem letRefTyping-helper/base/shared/after/L1L1
  : forall* {BF: object -> cxt} {N} {NN} {C} {NN'} {C'} {OF2}
    forall {BL: {x} cxt`lookup (BF x) N (cxt-info/ x (ty/ NN annot/shared C))}
    {BL1: {x} cxt`lookup (BF x) N (cxt-info/ (OF2 x) (ty/ NN' annot/unique C'))}
    exists {F:void}
    true.

- : letRefTyping-helper/base/shared/after/L1L1 BL1 BL2 F
    <- ({x} cxt`lookup-unique (BL1 x) (BL2 x) cxt`eq/ nat`eq/ (CIE x))
    <- ({x} cxt-info-eq-inversion (CIE x) (OE x) TE)
    <- ty-eq-inversion TE NNE AE NE
    <- annot`shared-eq-unique-implies-false AE F.

%worlds (gtermvar) (letRefTyping-helper/base/shared/after/L1L1 _ _ _).
%total { } (letRefTyping-helper/base/shared/after/L1L1 _ _ _).


%theorem letRefTyping-helper/base/shared/after/L1L
  : forall* {CM} {BF} {N} {NN} {U} {C} {U'} {NN'} {C'} {N'} {K} {OF}
    forall {BL: {x} cxt`lookup (BF x) N (cxt-info/ x (ty/ NN annot/shared C))}
    {CM-B1-U': {x} clsmap-cxt-objset CM (BF x) U'}
    {BL1: {x} cxt`lookup (BF x) N' (cxt-info/ (OF x) (ty/ NN' annot/unique C'))}
    {N'!<U': set`not-member U' N'}
    {U'+N'=U: set`add U' N' U}
    {EQ?: nat`eq? N N' K}
    exists {N!<U: set`not-member U N}
    true.

- : letRefTyping-helper/base/shared/after/L1 ([x] BL x)
    ([_] clsmap-cxt-objset/0) set`not-member/0.

- : letRefTyping-helper/base/shared/after/L1L ([x] BL x)
    ([x] CM-B-U' x) ([x] BL1 x) N!<U' U'+N=U nat`eq?/yes N!<U
    <- letRefTyping-helper/base/shared/after/L1L1 ([x] BL x) ([x] BL1 x) V
    <- set`false-implies-not-member V N!<U.

- : letRefTyping-helper/base/shared/after/L1L ([x] BL x)
    ([x] CM-B-U' x) ([x] BL1 x) N'!<U' U'+N'=U (nat`eq?/no (N<>N':nat`ne N N')) N!<U
    <- letRefTyping-helper/base/shared/after/L1 BL CM-B-U' N!<U'
    <- set`add-preserves-not-member N!<U' U'+N'=U N<>N' N!<U.

- : letRefTyping-helper/base/shared/after/L1 ([x] BL x)
    ([x] clsmap-cxt-objset/U (CM-B-U' x) (BL1 x) CML N'!<U' U'+N'=U) N!<U
    <- nat`eq?-total N=N'?
    <- letRefTyping-helper/base/shared/after/L1L BL CM-B-U' BL1 N'!<U' U'+N'=U N=N'? N!<U.

%worlds (gtermvar) (letRefTyping-helper/base/shared/after/L1 _ _ _)
  (letRefTyping-helper/base/shared/after/L1L _ _ _ _ _ _ _).
%total (A AP) (letRefTyping-helper/base/shared/after/L1 _ A _)
  (letRefTyping-helper/base/shared/after/L1L _ AP _ _ _ _ _).


%theorem letRefTyping-helper/base/shared/after
  : forall* {CM} {PM} {B1:object -> cxt} {B0} {N} {Out} {NN} {C} {V1} {NN1} {C1}
    forall {G1} {N!<G1: not-in-targets (s N) G1}
    {N!<B0: cxt`fresh B0 (s N)}
    {B0+SN=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)}
    {CM-V: {x} clsmap-result CM (B1 x) (result/expr (reftype/ NN1 C1 G1) V1)}
    {R2=>Out2: {x} result2output CM PM (B1 x) (result/expr (reftype/ NN1 C1 G1) V1) (Out x)}
    exists {Out2}
    {R2=>Out3: result2output CM PM B0 (result/expr (reftype/ NN1 C1 G1) V1) Out2}
    {TRANS: transform
            (output/exists [x]
              (output/exists [o:object]
                (output/exists [p:permission]
                  (Out x)))) Out2}
    true.

%%% 1. targets/fresh
- : letRefTyping-helper/base/shared/after targets/fresh
    (not-in-targets/fresh) N!<B0 B0+N=B1
    ([x] clsmap-result/expr _ (clsmap-cxt-env/ (CM-B1-U1 x) _))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U1=>PiU1F:{x} make-encumbered CM PM (B1 x) U1 (PiU1F x)) x)
        ((B1+M1=>PiM1F:{x} capset2perm CM PM (B1 x) M1 (PiM1F x)) x))
      (reftype2perm/fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique))) _
    (result2output/expr B0=>PiB0
      (env2input/ (U1=>PiU1:make-encumbered CM PM B0 U1 PiU1)
        (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
      (reftype2perm/fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [x1]
              (transform/inside [o1]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            (equiv/transitive
                              (equiv/combine
                                (equiv/transitive
                                  (PiB1<=>PF1+PiB0F x)
                                  (equiv/combine equiv/reflexive (PiB0F<=>PiB0 x)))
                                (equiv/combine (EQV4 x x1)
                                  (equiv/combine (PiU1F<=>PiU1 x) (PiM1F<=>PiM1 x))))
                              (equiv/symmetric equiv/associate))
                            (equiv/reflexive))
                          (equiv/symmetric equiv/associate))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/shared
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/shared))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- letRefTyping-helper/base/shared/after/L1 B1-L CM-B1-U1 N!<U1
    <- cxt`fresh-update-preserves-make-encumbered-converse
      B1+U1=>PiU1F N!<B0 B0+N=B1 N!<U1 PiU1 U1=>PiU1 PiU1F<=>PiU1
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M1=>PiM1F N!<B0 B0+N=B1
      PiM1 M1=>PiM1 PiM1F=PiM1
    <- ({x} permission`eq-implies-equiv (PiM1F=PiM1 x) (PiM1F<=>PiM1 x)).

%%% 2. unique
- : letRefTyping-helper/base/shared/after (targets/unique S1 M11 _)
    (not-in-targets/unique N!<S1 N!<M11) N!<B0 B0+N=B1
    ([x] clsmap-result/expr _ (clsmap-cxt-env/ (CM-B1-U1 x) _))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U1=>PiU1F:{x} make-encumbered CM PM (B1 x) U1 (PiU1F x)) x)
        ((B1+M1=>PiM1F:{x} capset2perm CM PM (B1 x) M1 (PiM1F x)) x))
      (reftype2perm/unique (SZ-M11:set`size M11 (s _))
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x))) _
    (result2output/expr B0=>PiB0
      (env2input/ (U1=>PiU1:make-encumbered CM PM B0 U1 PiU1)
        (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
      (reftype2perm/unique SZ-M11
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o)
        (B0+M11=>PiM11: capset2perm CM PM B0 M11 PiM11)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [x1]
              (transform/inside [o1]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans4
                        (implies/equiv equiv/identity)
                        (implies/equiv
                          (equiv/combine
                            (equiv/transitive
                              (PiB1<=>PF1+PiB0F x)
                              (equiv/combine equiv/reflexive (PiB0F<=>PiB0 x)))
                            (equiv/combine
                              (equiv/combine (GF1F<=>GF1 x x1 o1) (EQV6 x o1))
                              (equiv/combine (PiU1F<=>PiU1 x) (PiM1F<=>PiM1 x)))))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/equiv
                          (equiv/combine equiv/reflexive
                            (equiv/symmetric equiv/identity)))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/shared
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/shared))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- letRefTyping-helper/base/shared/after/L1 B1-L CM-B1-U1 N!<U1
    <- cxt`fresh-update-preserves-make-encumbered-converse
      B1+U1=>PiU1F N!<B0 B0+N=B1 N!<U1 PiU1 U1=>PiU1 PiU1F<=>PiU1
    <- predmap`no-variable-lookup PML2F CP2 PML2 CP2F=CP2
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M1=>PiM1F N!<B0 B0+N=B1
      PiM1 M1=>PiM1 PiM1F=PiM1
    <- ({x} permission`eq-implies-equiv (PiM1F=PiM1 x) (PiM1F<=>PiM1 x))
    <- letRefTyping-helper/base/unique/L6L6 GF1F=GF1 GF1F<=>GF1
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M11=>PiM11F N!<B0 B0+N=B1 PiM11
      B0+M11=>PiM11 PiM11F=PiM11
    <- letRefTyping-helper/base/unique/L6L7 PF2 CP2F=CP2 PiM11F=PiM11 EQV6.


%%% 3. borrow
- : letRefTyping-helper/base/shared/after (targets/unique S1 set/0 _)
    (not-in-targets/unique N!<S1 _) N!<B0 B0+N=B1
    ([x] clsmap-result/expr _ (clsmap-cxt-env/ (CM-B1-U1 x) _))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U1=>PiU1F:{x} make-encumbered CM PM (B1 x) U1 (PiU1F x)) x)
        ((B1+M1=>PiM1F:{x} capset2perm CM PM (B1 x) M1 (PiM1F x)) x))
      (reftype2perm/borrow (SZ:set`size S1 (s _)) set`size/0
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/borrow)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o))) _
    (result2output/expr B0=>PiB0
      (env2input/ (U1=>PiU1:make-encumbered CM PM B0 U1 PiU1)
        (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
      (reftype2perm/borrow SZ set`size/0
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/borrow)
        ([o] S1=>GF1 o)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [x1]
              (transform/inside [o1]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans4
                        (implies/equiv equiv/identity)
                        (implies/equiv
                          (equiv/combine
                            (equiv/transitive
                              (PiB1<=>PF1+PiB0F x)
                              (equiv/combine equiv/reflexive (PiB0F<=>PiB0 x)))
                            (equiv/combine
                              (equiv/combine (EQV4 x x1) (GF1F<=>GF1 x x1))
                              (equiv/combine (PiU1F<=>PiU1 x) (PiM1F<=>PiM1 x)))))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/equiv
                          (equiv/combine equiv/reflexive
                            (equiv/symmetric equiv/identity)))))
                    (transform/drop))))))))
          (transform/trans3
            (transform/rem-unused)
            (transform/rem-unused)
            (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/shared
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/shared))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- letRefTyping-helper/base/shared/after/L1 B1-L CM-B1-U1 N!<U1
    <- cxt`fresh-update-preserves-make-encumbered-converse
      B1+U1=>PiU1F N!<B0 B0+N=B1 N!<U1 PiU1 U1=>PiU1 PiU1F<=>PiU1
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M1=>PiM1F N!<B0 B0+N=B1
      PiM1 M1=>PiM1 PiM1F=PiM1
    <- ({x} permission`eq-implies-equiv (PiM1F=PiM1 x) (PiM1F<=>PiM1 x))
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4
    <- ({x}{o} permission`eq-implies-equiv (GF1F=GF1 x o) (GF1F<=>GF1 x o)).

%%% 4. shared
- : letRefTyping-helper/base/shared/after targets/shared
    not-in-targets/shared N!<B0 B0+N=B1
    ([x] clsmap-result/expr _ (clsmap-cxt-env/ (CM-B1-U1 x) _))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U1=>PiU1F:{x} make-encumbered CM PM (B1 x) U1 (PiU1F x)) x)
        ((B1+M1=>PiM1F:{x} capset2perm CM PM (B1 x) M1 (PiM1F x)) x))
      (reftype2perm/shared
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/shared))) _
    (result2output/expr B0=>PiB0
      (env2input/ (U1=>PiU1:make-encumbered CM PM B0 U1 PiU1)
        (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
      (reftype2perm/shared
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/shared)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [x1]
              (transform/inside [o1]
                (transform/inside [o]
                  (transform/trans
                    (transform/implies
                      (implies/trans4
                        (implies/equiv equiv/identity)
                        (implies/equiv
                          (equiv/combine
                            (equiv/transitive (PiB1<=>PF1+PiB0F x)
                              (equiv/combine equiv/reflexive (PiB0F<=>PiB0 x)))
                            (equiv/combine
                              (EQV4 x x1)
                              (equiv/combine (PiU1F<=>PiU1 x) (PiM1F<=>PiM1 x)))))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/equiv
                          (equiv/combine equiv/reflexive
                            (equiv/symmetric equiv/identity)))))
                    (transform/drop))))))))
          (transform/trans3
            (transform/rem-unused)
            (transform/rem-unused)
            (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/shared
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/shared))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- letRefTyping-helper/base/shared/after/L1 B1-L CM-B1-U1 N!<U1
    <- cxt`fresh-update-preserves-make-encumbered-converse
      B1+U1=>PiU1F N!<B0 B0+N=B1 N!<U1 PiU1 U1=>PiU1 PiU1F<=>PiU1
    <- predmap`no-variable-lookup PML2F CP2 PML2 (CP2F=CP2)
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M1=>PiM1F N!<B0 B0+N=B1
      PiM1 M1=>PiM1 PiM1F=PiM1
    <- ({x} permission`eq-implies-equiv (PiM1F=PiM1 x) (PiM1F<=>PiM1 x))
    <- letRefTyping-helper/base/unique/L6L4 PF2 CP2F=CP2 EQV4.

%%% 5. unique+fresh
- : letRefTyping-helper/base/shared/after (targets/unique S1 M11 _)
    (not-in-targets/unique N!<S1 N!<M11) N!<B0 B0+N=B1
    ([x] clsmap-result/expr _ (clsmap-cxt-env/ (CM-B1-U1 x) _))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U1=>PiU1F:{x} make-encumbered CM PM (B1 x) U1 (PiU1F x)) x)
        ((B1+M1=>PiM1F:{x} capset2perm CM PM (B1 x) M1 (PiM1F x)) x))
      (reftype2perm/unique+fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x))) _
    (result2output/expr B0=>PiB0
      (env2input/ (U1=>PiU1:make-encumbered CM PM B0 U1 PiU1)
        (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
      (reftype2perm/unique+fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o)
        (B0+M11=>PiM11: capset2perm CM PM B0 M11 PiM11)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [x1]
              (transform/inside [o1]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans4
                        (implies/equiv equiv/identity)
                        (implies/equiv
                          (equiv/combine
                            (equiv/transitive
                              (PiB1<=>PF1+PiB0F x)
                              (equiv/combine equiv/reflexive (PiB0F<=>PiB0 x)))
                            (equiv/combine
                              (equiv/combine (GF1F<=>GF1 x x1 o1) (EQV6 x o1 p1))
                              (equiv/combine (PiU1F<=>PiU1 x) (PiM1F<=>PiM1 x)))))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/equiv
                          (equiv/combine equiv/reflexive
                            (equiv/symmetric equiv/identity)))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/shared
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/shared))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- letRefTyping-helper/base/shared/after/L1 B1-L CM-B1-U1 N!<U1
    <- cxt`fresh-update-preserves-make-encumbered-converse
      B1+U1=>PiU1F N!<B0 B0+N=B1 N!<U1 PiU1 U1=>PiU1 PiU1F<=>PiU1
    <- predmap`no-variable-lookup PML2F CP2 PML2 CP2F=CP2
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M1=>PiM1F N!<B0 B0+N=B1
      PiM1 M1=>PiM1 PiM1F=PiM1
    <- ({x} permission`eq-implies-equiv (PiM1F=PiM1 x) (PiM1F<=>PiM1 x))
    <- letRefTyping-helper/base/unique/L6L6 GF1F=GF1 GF1F<=>GF1
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M11=>PiM11F N!<B0 B0+N=B1 PiM11
      B0+M11=>PiM11 PiM11F=PiM11
    <- letRefTyping-helper/base/unique/L6L11 PF2 CP2F=CP2 PiM11F=PiM11 EQV6.

- : letRefTyping-helper/base/shared/after (targets/unique S1 M11 _)
    (not-in-targets/unique N!<S1 N!<M11) N!<B0 B0+N=B1
    ([x] clsmap-result/expr _ (clsmap-cxt-env/ (CM-B1-U1 x) _))
    ([x] result2output/expr ((B1=>PiB1:{x} cxt2perm PM (B1 x) (PiB1 x)) x)
      (env2input/ ((B1+U1=>PiU1F:{x} make-encumbered CM PM (B1 x) U1 (PiU1F x)) x)
        ((B1+M1=>PiM1F:{x} capset2perm CM PM (B1 x) M1 (PiM1F x)) x))
      (reftype2perm/unique+fresh
        (ty2perm/ ((PML2F:{x} predmap`lookup PM C1 (CP2F x)) x)
          (NN2P2:nn2perm _ _ PF2) annot2perm/unique)
        ([o] (S1=>GF1F:{x}{o} set2cond (B1 x) o S1 (GF1F o x)) x o)
        ((B1+M11=>PiM11F: {x} capset2perm CM PM (B1 x) M11 (PiM11F x)) x))) _
    (result2output/expr B0=>PiB0
      (env2input/ (U1=>PiU1:make-encumbered CM PM B0 U1 PiU1)
        (M1=>PiM1:capset2perm CM PM B0 M1 PiM1))
      (reftype2perm/unique+fresh
        (ty2perm/ (PML2:predmap`lookup PM C1 CP2) NN2P2 annot2perm/unique)
        ([o] S1=>GF1 o)
        (B0+M11=>PiM11: capset2perm CM PM B0 M11 PiM11)))
    (transform/trans
      (transform/inside [x]
        (transform/inside [o]
          (transform/inside [p]
            (transform/inside [x1]
              (transform/inside [o1]
                (transform/inside [p1]
                  (transform/trans
                    (transform/implies
                      (implies/trans4
                        (implies/equiv equiv/identity)
                        (implies/equiv
                          (equiv/combine
                            (equiv/transitive
                              (PiB1<=>PF1+PiB0F x)
                              (equiv/combine equiv/reflexive (PiB0F<=>PiB0 x)))
                            (equiv/combine
                              (equiv/combine (GF1F<=>GF1 x x1 o1) (EQV6 x o1 p1))
                              (equiv/combine (PiU1F<=>PiU1 x) (PiM1F<=>PiM1 x)))))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/equiv
                          (equiv/combine equiv/reflexive
                            (equiv/symmetric equiv/identity)))))
                    (transform/drop))))))))
      (transform/trans3
        (transform/rem-unused)
        (transform/rem-unused)
        (transform/rem-unused)))
    <- ({x} cxt2perm/U-inversion (B1=>PiB1 x) N!<B0 (B0+N=B1 x)
         (PiB0F x) (B0=>PiB0F x) _
         (ty2perm2/shared
           (ty2perm/ ((PML4F:{x}predmap`lookup PM C (CP4F x)) x)
             (NN2P4:nn2perm _ _ PF4) annot2perm/shared))
         (PiB1<=>PF1+PiB0F x))
    <- cxt2perm-no-var B0=>PiB0F PiB0 ([x] PiB0F=PiB0 x) B0=>PiB0
    <- ({x} permission`eq-implies-equiv (PiB0F=PiB0 x) (PiB0F<=>PiB0 x))
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- letRefTyping-helper/base/shared/after/L1 B1-L CM-B1-U1 N!<U1
    <- cxt`fresh-update-preserves-make-encumbered-converse
      B1+U1=>PiU1F N!<B0 B0+N=B1 N!<U1 PiU1 U1=>PiU1 PiU1F<=>PiU1
    <- predmap`no-variable-lookup PML2F CP2 PML2 CP2F=CP2
    <- cxt`fresh-update-preserves-set2cond-converse S1=>GF1F N!<B0 B0+N=B1 N!<S1 GF1
      S1=>GF1 GF1F=GF1
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M1=>PiM1F N!<B0 B0+N=B1
      PiM1 M1=>PiM1 PiM1F=PiM1
    <- ({x} permission`eq-implies-equiv (PiM1F=PiM1 x) (PiM1F<=>PiM1 x))
    <- letRefTyping-helper/base/unique/L6L6 GF1F=GF1 GF1F<=>GF1
    <- cxt`fresh-update-preserves-capset2perm-converse B1+M11=>PiM11F N!<B0 B0+N=B1 PiM11
      B0+M11=>PiM11 PiM11F=PiM11
    <- letRefTyping-helper/base/unique/L6L11 PF2 CP2F=CP2 PiM11F=PiM11 EQV6.

%worlds (gtermvar) (letRefTyping-helper/base/shared/after _ _ _ _ _ _ _ _ _).
%total { } (letRefTyping-helper/base/shared/after _ _ _ _ _ _ _ _ _).