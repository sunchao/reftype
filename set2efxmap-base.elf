%%% Converting a set of (obj,fld)s to a efxmap
%%% $Id$

efx-id : nat -> unit -> efx -> efx -> type.

efx-id/ : efx-id N _ X X.


%%% Theorems

%theorem efx-id-total*
  : forall {N} {U} {X1}
    exists {X2} {SE: efx-id N U X1 X2}
    true.

- : efx-id-total* _ _ _ _ efx-id/.

%worlds () (efx-id-total* _ _ _ _ _).
%total {} (efx-id-total* _ _ _ _ _).

%abbrev efx-id-total = efx-id-total* _ _ _ _.


%theorem efx-id-unique
  : forall* {N1} {U1} {X1} {Y1} {N2} {U2} {X2} {Y2}
    forall {SE1: efx-id N1 U1 X1 Y1}
    {SE2: efx-id N2 U2 X2 Y2}
    {E: nat`eq N1 N2} {E: unit`eq U1 U2}
    {E: efx`eq X1 X2}
    exists {E: efx`eq Y1 Y2}
    true.

- : efx-id-unique S1 S2 nat`eq/ unit`eq/ efx`eq/ efx`eq/.

%worlds () (efx-id-unique _ _ _ _ _ _).
%total {} (efx-id-unique _ _ _ _ _ _).


%theorem efx-id-right-cancels
  : forall* {N} {U1} {U2} {X1} {Y1} {X2} {Y2}
    forall {SE1: efx-id N U1 X1 Y1}
    {SE2: efx-id N U2 X2 Y2}
    {E: efx`eq X1 X2} {E: efx`eq Y1 Y2}
    exists {E: unit`eq U1 U2}
    true.

- : efx-id-right-cancels efx-id/ efx-id/ _ _ unit`eq/.

%worlds () (efx-id-right-cancels _ _ _ _ _).
%total {} (efx-id-right-cancels _ _ _ _ _).


%theorem efx-id-right-preserves-leq*
  : forall* {N} {U1} {U2} {X} {Y1} {Y2}
    forall {U1<=U2: unit`eq U1 U2}
    {SE1: efx-id N U1 X Y1}
    {SE2: efx-id N U2 X Y2}
    exists {Y1<=Y2: efx`leq Y1 Y2}
    true.

- : efx-id-right-preserves-leq* unit`eq/ efx-id/ efx-id/ Y1<=Y2
    <- efx`leq-reflexive _ Y1<=Y2.

%worlds () (efx-id-right-preserves-leq* _ _ _ _).
%total {} (efx-id-right-preserves-leq* _ _ _ _).


%theorem efx-id-left-preserves-leq*
  : forall* {N} {U} {X1} {X2} {Y1} {Y2}
    forall {X1<=X2: efx`leq X1 X2}
    {T1: efx-id N U X1 Y1}
    {T2: efx-id N U X2 Y2}
    exists {Y1<=Y2: efx`leq Y1 Y2}
    true.

- : efx-id-left-preserves-leq* L efx-id/ efx-id/ L.

%worlds () (efx-id-left-preserves-leq* _ _ _ _).
%total {} (efx-id-left-preserves-leq* _ _ _ _).

%{%
#define map1 set
#define data1 unit
#define map2 efxmap
#define data2 efx
#define trans efx-id
#define alltrans set2efxmap
#define arg efx
#define MAP_TRANS_CANCEL 1
#define MAP_LEQ 1
#define MAP_TRANS_LEQ 1
#define MAP_TRANS_TOTAL 1
BEGIN_ELF
#include "map-trans2.elf"
END_ELF
#undef data1
#undef data2
%}%

%theorem set2efxmap-implies-domain
  : forall* {S} {X} {M}
    forall {T: set2efxmap S X M}
    exists {DM: efxmap`domain M S}
    true.

- : set2efxmap-implies-domain set2efxmap/0 efxmap`domain/0.

- : set2efxmap-implies-domain
    (set2efxmap/U SP=>MP efx-id/ N!<SP SP+N=S MP+N=M) DM-M
    <- set2efxmap-implies-domain SP=>MP DM-MP
    <- efxmap`domain-commute-update DM-MP MP+N=M SP+N=S DM-M.

%worlds () (set2efxmap-implies-domain _ _).
%total (T) (set2efxmap-implies-domain T _).


%theorem set2efxmap-preserves-is-consume?
  : forall* {S} {X} {M} {B}
    forall {PX: efx`is-consume? X B}
    {S2M: set2efxmap S X M}
    exists {PM: efxmap`is-consume? M B}
    true.

- : set2efxmap-preserves-is-consume? PX set2efxmap/0 efxmap`is-consume?/0.

- : set2efxmap-preserves-is-consume? PX
    (set2efxmap/U T efx-id/ F U1 U2)
    (efxmap`is-consume?/U PA PX F2 U2)
    <- set2efxmap-preserves-fresh F T F2
    <- set2efxmap-preserves-is-consume? PX T PA.

%worlds () (set2efxmap-preserves-is-consume? _ _ _).
%total (T) (set2efxmap-preserves-is-consume? _ T _).