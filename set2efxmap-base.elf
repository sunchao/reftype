%%% Converting a set of objects to a set of (obj,fld)s.
%%% $Id$

%%% Definitions

2efx : nat -> unit -> efx -> efx -> type.

2efx/ : 2efx N _ X X.


%%% Theorems

%theorem 2efx-total*
  : forall {N} {U} {X1}
    exists {X2} {SE: 2efx N U X1 X2}
    true.

- : 2efx-total* _ _ _ _ 2efx/.

%worlds () (2efx-total* _ _ _ _ _).
%total {} (2efx-total* _ _ _ _ _).

%abbrev 2efx-total = 2efx-total* _ _ _ _.


%theorem 2efx-unique
  : forall* {N1} {U1} {X1} {Y1} {N2} {U2} {X2} {Y2}
    forall {SE1: 2efx N1 U1 X1 Y1}
    {SE2: 2efx N2 U2 X2 Y2}
    {E: nat`eq N1 N2} {E: unit`eq U1 U2}
    {E: efx`eq X1 X2}
    exists {E: efx`eq Y1 Y2}
    true.

- : 2efx-unique S1 S2 nat`eq/ unit`eq/ efx`eq/ efx`eq/.

%worlds () (2efx-unique _ _ _ _ _ _).
%total {} (2efx-unique _ _ _ _ _ _).


%theorem 2efx-right-cancels
  : forall* {N} {U1} {U2} {X1} {Y1} {X2} {Y2}
    forall {SE1: 2efx N U1 X1 Y1}
    {SE2: 2efx N U2 X2 Y2}
    {E: efx`eq X1 X2} {E: efx`eq Y1 Y2}
    exists {E: unit`eq U1 U2}
    true.

- : 2efx-right-cancels 2efx/ 2efx/ _ _ unit`eq/.

%worlds () (2efx-right-cancels _ _ _ _ _).
%total {} (2efx-right-cancels _ _ _ _ _).


%theorem 2efx-right-preserves-leq*
  : forall* {N} {U1} {U2} {X} {Y1} {Y2}
    forall {U1<=U2: unit`eq U1 U2}
    {SE1: 2efx N U1 X Y1}
    {SE2: 2efx N U2 X Y2}
    exists {Y1<=Y2: efx`leq Y1 Y2}
    true.

- : 2efx-right-preserves-leq* unit`eq/ 2efx/ 2efx/ Y1<=Y2
    <- efx`leq-reflexive _ Y1<=Y2.

%worlds () (2efx-right-preserves-leq* _ _ _ _).
%total {} (2efx-right-preserves-leq* _ _ _ _).


%theorem 2efx-left-preserves-leq*
  : forall* {N} {U} {X1} {X2} {Y1} {Y2}
    forall {X1<=X2: efx`leq X1 X2}
    {T1: 2efx N U X1 Y1}
    {T2: 2efx N U X2 Y2}
    exists {Y1<=Y2: efx`leq Y1 Y2}
    true.

- : 2efx-left-preserves-leq* L 2efx/ 2efx/ L.

%worlds () (2efx-left-preserves-leq* _ _ _ _).
%total {} (2efx-left-preserves-leq* _ _ _ _).

%{%
#define map1 set
#define data1 unit
#define map2 efxmap
#define data2 efx
#define trans 2efx
#define alltrans set2efxmap
#define arg efx
#define MAP_TRANS_CANCEL 1
#define MAP_LEQ 1
#define MAP_TRANS_LEQ 1
#define MAP_TRANS_TOTAL 1
BEGIN_ELF
#include "map-trans2.elf"
END_ELF
%}%

%theorem set2efxmap-implies-domain
  : forall* {S} {X} {M}
    forall {T: set2efxmap S X M}
    exists {DM: efxmap`domain M S}
    true.

- : set2efxmap-implies-domain set2efxmap/0 efxmap`domain/0.

- : set2efxmap-implies-domain
    (set2efxmap/U SP=>MP 2efx/ N!<SP SP+N=S MP+N=M) DM-M
    <- set2efxmap-implies-domain SP=>MP DM-MP
    <- efxmap`domain-commute-update DM-MP MP+N=M SP+N=S DM-M.

%worlds () (set2efxmap-implies-domain _ _).
%total (T) (set2efxmap-implies-domain T _).
