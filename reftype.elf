%%% Reference Type

%%% Definitions

% 1, non-nullness

nonnull : type. %name nonnull NN nn.

nonnull/yes : nonnull.

nonnull/may : nonnull.


nonnull`eq : nonnull -> nonnull -> type.

nonnull`eq/ : nonnull`eq NN NN.


nonnull`leq : nonnull -> nonnull -> type.

nonnull`leq/= : nonnull`leq NN1 NN2 <- nonnull`eq NN1 NN2.

nonnull`leq/< : nonnull`leq nonnull/may nonnull/yes.


% 2, annotation

annot : type.		%name annot A.

annot/unique : annot.

annot/shared : annot.

annot/borrow : annot.	% borrow CANNOT be used on fields


not-borrowed : annot -> type.

not-borrowed/unique : not-borrowed annot/unique.

not-borrowed/shared : not-borrowed annot/shared.


not-unique : annot -> type.

not-unique/borrow : not-unique annot/borrow.

not-unique/shared : not-unique annot/shared.


annot`eq : annot -> annot -> type.

annot`eq/ : annot`eq A A.


annot`lt : annot -> annot -> type.

annot`lt/su : annot`lt annot/shared annot/unique.

annot`lt/bu : annot`lt annot/borrow annot/unique.

annot`lt/bs : annot`lt annot/borrow annot/shared.


annot`leq : annot -> annot -> type.

annot`leq/= : annot`leq A A.

annot`leq/< : annot`leq A1 A2 <- annot`lt A1 A2.


% 3, annotated type

ty : type.		%name ty T.

ty/ : nonnull -> annot -> nat -> ty.

ty/null : ty.


% 4, targets

targets : type. %name targets G.

targets`eq : targets -> targets -> type.

targets`eq/ : targets`eq G G.


% targets of unique references:
%   first `set`: the set of all object targets,
%   second `set`: the set of all field targets,

targets/unique : set -> set -> targets.

% targets of shared references

targets/shared : targets.


% 5, reference type

reftype : type.	%name reftype RT.

% reftype for "normal" references:
%  `nonnull`: the nonnull information of this reference.
%  `nat`: class id for this reference.
%  `targets`: all the possible targets of this reference.

reftype/ : nonnull -> nat -> targets -> reftype.

reftype/null : reftype.


% equality on reference type

reftype`eq : reftype -> reftype -> type.

reftype`eq/ : reftype`eq RT RT.


%%% Theorems

%theorem nonnull`eq-symmetric
  : forall* {NN1} {NN2}
    forall {E: nonnull`eq NN1 NN2}
    exists {E: nonnull`eq NN2 NN1}
    true.

- : nonnull`eq-symmetric nonnull`eq/ nonnull`eq/.

%worlds () (nonnull`eq-symmetric _ _).
%total { } (nonnull`eq-symmetric _ _).


%theorem nonnull`eq-transitive
  : forall* {NN1} {NN2} {NN3}
    forall {NN1=NN2: nonnull`eq NN1 NN2}
    {NN2=NN3: nonnull`eq NN2 NN3}
    exists {NN1=NN3: nonnull`eq NN1 NN3}
    true.

%worlds () (nonnull`eq-transitive _ _ _).
%trustme %total { } (nonnull`eq-transitive _ _ _).


%theorem targets/unique-preserves-eq
  : forall* {S1} {S2} {R1} {R2}
    forall {E: set`eq S1 S2} {E: set`eq R1 R2}
    exists {E: targets`eq (targets/unique S1 R1) (targets/unique S2 R2)}
    true.

- : targets/unique-preserves-eq set`eq/ set`eq/ targets`eq/.

%worlds () (targets/unique-preserves-eq _ _ _).
%total {} (targets/unique-preserves-eq _ _ _).


%theorem nonnull`leq-respects-eq
  : forall* {NN} {NN'} {NN1} {NN1'}
    forall {LE: nonnull`leq NN NN1}
    {NN=NN': nonnull`eq NN NN'} {NN1=NN1': nonnull`eq NN1 NN1'}
    exists {LE: nonnull`leq NN' NN1'}
    true.

- : nonnull`leq-respects-eq LE nonnull`eq/ nonnull`eq/ LE.

%worlds () (nonnull`leq-respects-eq _ _ _ _).
%total { } (nonnull`leq-respects-eq _ _ _ _).


%theorem annot`leq-respects-eq
  : forall* {A} {A'} {A1} {A1'}
    forall {LE: annot`leq A A1}
    {A=A': annot`eq A A'} {A1=A1': annot`eq A1 A1'}
    exists {LE: annot`leq A' A1'}
    true.

- : annot`leq-respects-eq LE annot`eq/ annot`eq/ LE.

%worlds () (annot`leq-respects-eq _ _ _ _).
%total { } (annot`leq-respects-eq _ _ _ _).


%theorem not-unique-respects-eq
  : forall* {A} {A'}
    forall {NU: not-unique A} {AE: annot`eq A A'}
    exists {NU': not-unique A'}
    true.

- : not-unique-respects-eq NU annot`eq/ NU.

%worlds (objvar) (not-unique-respects-eq _ _ _).
%total { } (not-unique-respects-eq _ _ _).



%%% Exports

%abbrev nn	= nonnull.
%abbrev nn/yes	= nonnull/yes.
%abbrev nn/may	= nonnull/may.
%abbrev shared-ty = (ty/ nn/may annot/borrow z).