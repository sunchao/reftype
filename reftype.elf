%%% Reference Type

%%% Definitions

%%% Non-Nullness

nonnull : type. %name nonnull NN nn.

nonnull/yes : nonnull.

nonnull/may : nonnull.


%%% Equality for nonnull

nonnull`eq : nonnull -> nonnull -> type.

nonnull`eq/ : nonnull`eq NN NN.


%%% Less-eq relation for nonnull

nonnull`leq : nonnull -> nonnull -> type.

nonnull`leq/= : nonnull`leq NN1 NN2 <- nonnull`eq NN1 NN2.

nonnull`leq/< : nonnull`leq nonnull/may nonnull/yes.

%abbrev nonnull`sub = [NN1][NN2] nonnull`leq NN2 NN1.

%abbrev sub-nonnull = nonnull`sub.


%%% Annotation

annot : type.		%name annot A.

annot/unique : annot.

annot/shared : annot.

annot/borrow : annot.	% borrow CANNOT be used on fields


annot`eq : annot -> annot -> type.

annot`eq/ : annot`eq A A.


%%% Annotated Type

ty : type.		%name ty T.

ty/ : nonnull -> annot -> nat -> ty.

% ty/null : ty.



%%% Targets
%%% TODO: rename it

targets : type. %name targets G.

targets`eq : targets -> targets -> type.

targets`eq/ : targets`eq G G.


%%% Targets of Unique References:
%%%   first `set`: the set of all object targets - they should all be unique
%%%   second `set`: the capabilities needed for the targets
%%%   bool: whether the unique target also comes from a fresh (untracked) object
%%% Naming for the variables in order: U, M, W
targets/unique : set -> set -> bool -> targets.

targets/shared : targets.

targets/fresh : targets.


%%% Reference Type

reftype : type.	%name reftype RT.

% reftype for "normal" references:
%  `nonnull`: the nonnull information of this reference.
%  `nat`: class id for this reference.
%  `targets`: all the possible targets of this reference.

reftype/ : nonnull -> nat -> targets -> reftype.


%%% Equality on Reference Type

reftype`eq : reftype -> reftype -> type.

reftype`eq/ : reftype`eq RT RT.



%%% Not borrowed

not-borrow : annot -> type.

not-borrow/unique : not-borrow annot/unique.

not-borrow/shared : not-borrow annot/shared.


%%% Not unique

not-unique : annot -> type.

not-unique/borrow : not-unique annot/borrow.

not-unique/shared : not-unique annot/shared.


%%% Either unique or borrow

not-shared : annot -> type.

not-shared/unique : not-shared annot/unique.

not-shared/borrow : not-shared annot/borrow.



%%% Theorems

%theorem nonnull`eq-symmetric
  : forall* {NN1} {NN2}
    forall {E: nonnull`eq NN1 NN2}
    exists {E: nonnull`eq NN2 NN1}
    true.

- : nonnull`eq-symmetric nonnull`eq/ nonnull`eq/.

%worlds () (nonnull`eq-symmetric _ _).
%total { } (nonnull`eq-symmetric _ _).


%theorem nonnull`eq-transitive
  : forall* {NN1} {NN2} {NN3}
    forall {NN1=NN2: nonnull`eq NN1 NN2}
    {NN2=NN3: nonnull`eq NN2 NN3}
    exists {NN1=NN3: nonnull`eq NN1 NN3}
    true.

- : nonnull`eq-transitive nonnull`eq/ nonnull`eq/ nonnull`eq/.

%worlds () (nonnull`eq-transitive _ _ _).
%total { } (nonnull`eq-transitive _ _ _).


%theorem targets/unique-preserves-eq
  : forall* {U1} {M1} {W1} {U2} {M2} {W2}
    forall {E: set`eq U1 U2} {E: set`eq M1 M2} {E: bool`eq W1 W2}
    exists {E: targets`eq (targets/unique U1 M1 W1) (targets/unique U2 M2 W2)}
    true.

- : targets/unique-preserves-eq set`eq/ set`eq/ bool`eq/ targets`eq/.

%worlds () (targets/unique-preserves-eq _ _ _ _).
%total {} (targets/unique-preserves-eq _ _ _ _).


%theorem targets/unique-eq-inversion
  : forall* {U1} {M1} {W1} {U2} {M2} {W2}
    forall  {E: targets`eq (targets/unique U1 M1 W1) (targets/unique U2 M2 W2)}
    exists {E: set`eq U1 U2} {E: set`eq M1 M2} {E: bool`eq W1 W2}
    true.

- : targets/unique-eq-inversion targets`eq/ set`eq/ set`eq/ bool`eq/.

%worlds () (targets/unique-eq-inversion _ _ _ _).
%total {} (targets/unique-eq-inversion _ _ _ _).


%theorem nonnull`leq-respects-eq
  : forall* {NN} {NN'} {NN1} {NN1'}
    forall {LE: nonnull`leq NN NN1}
    {NN=NN': nonnull`eq NN NN'} {NN1=NN1': nonnull`eq NN1 NN1'}
    exists {LE: nonnull`leq NN' NN1'}
    true.

- : nonnull`leq-respects-eq LE nonnull`eq/ nonnull`eq/ LE.

%worlds () (nonnull`leq-respects-eq _ _ _ _).
%total { } (nonnull`leq-respects-eq _ _ _ _).


%theorem annot`shared-eq-unique-implies-false
  : forall {E: annot`eq annot/shared annot/unique}
    exists {F:void}
    true.

%worlds () (annot`shared-eq-unique-implies-false _ _).
%total { } (annot`shared-eq-unique-implies-false _ _).


%theorem not-unique-respects-eq
  : forall* {A} {A'}
    forall {NU: not-unique A} {AE: annot`eq A A'}
    exists {NU': not-unique A'}
    true.

- : not-unique-respects-eq NU annot`eq/ NU.

%worlds (gtermvar) (not-unique-respects-eq _ _ _).
%total { } (not-unique-respects-eq _ _ _).


%theorem reftype-eq-inversion
  : forall* {NN1} {NN2} {C1} {C2} {G1} {G2}
    forall {RT1=RT2: reftype`eq (reftype/ NN1 C1 G1) (reftype/ NN2 C2 G2)}
    exists {NE: nonnull`eq NN1 NN2}
    {CE: nat`eq C1 C2} {GE: targets`eq G1 G2}
    true.

- : reftype-eq-inversion reftype`eq/ nonnull`eq/ nat`eq/ targets`eq/.

%worlds (gtermvar) (reftype-eq-inversion _ _ _ _).
%total { } (reftype-eq-inversion _ _ _ _).


%%% Exports

%abbrev nn	= nonnull.
%abbrev nn/yes	= nonnull/yes.
%abbrev nn/may	= nonnull/may.
%abbrev shared-ty = (ty/ nn/may annot/borrow z).