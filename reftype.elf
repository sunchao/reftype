%%% Reference Type
%%% $Id: reftype.elf,v 1.1 2013/09/22 19:11:08 csun Exp csun $

%%% Definitions

% 1, non-nullness

nonnull : type. %name nonnull NN nn.

nonnull/yes : nonnull.

nonnull/may : nonnull.


nonnull`eq : nonnull -> nonnull -> type.

nonnull`eq/ : nonnull`eq NN NN.


nonnull`leq : nonnull -> nonnull -> type.

nonnull`leq/= : nonnull`leq NN1 NN2 <- nonnull`eq NN1 NN2.

nonnull`leq/< : nonnull`leq nonnull/may nonnull/yes.


% 2, annotation

annot : type.		%name annot A.

annot/unique : annot.

annot/shared : annot.

annot/borrow : annot.	% borrow CANNOT be used on fields


not-borrowed : annot -> type.

not-borrowed/unique : not-borrowed annot/unique.

not-borrowed/shared : not-borrowed annot/shared.


annot`eq : annot -> annot -> type.

annot`eq/ : annot`eq A A.


% 3, annotated type

ty : type.		%name ty T.

ty/ : nonnull -> annot -> nat -> ty.

ty/null : ty.


% 4, targets

targets : type. %name targets G.

targets`eq : targets -> targets -> type.

targets`eq/ : targets`eq G G.


targets/unique : set -> set -> bool -> targets.

targets/shared : targets.


% 5, reference type

reftype : type.	%name reftype RT.

reftype/ : nonnull -> nat -> targets -> reftype.

reftype/null : reftype.


% equality on reference type

reftype`eq : reftype -> reftype -> type.

reftype`eq/ : reftype`eq RT RT.


%%% Theorems

%theorem targets/unique-preserves-eq
  : forall* {S1} {S2} {R1} {R2} {B1} {B2}
    forall {E: set`eq S1 S2} {E: set`eq R1 R2}
    {E: bool`eq B1 B2}
    exists {E: targets`eq (targets/unique S1 R1 B1) (targets/unique S2 R2 B2)}
    true.

- : targets/unique-preserves-eq set`eq/ set`eq/ bool`eq/ targets`eq/.

%worlds () (targets/unique-preserves-eq _ _ _ _).
%total {} (targets/unique-preserves-eq _ _ _ _).


%%% Exports

%abbrev nn	= nonnull.
%abbrev nn/yes	= nonnull/yes.
%abbrev nn/may	= nonnull/may.