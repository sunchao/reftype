%%% mapping from field id to its type
%%% if the field is region, its type
%%% is ty/null.

eq : ty -> ty -> type.

eq/ : eq T T.


%{%
#define EQ eq
BEGIN_ELF
#include "EQ.i"
END_ELF
#undef EQ
%}%


%{%
#define data ty
BEGIN_ELF
%abbrev ty`eq = eq.
%abbrev ty`eq/ = eq/.
%abbrev ty`meta-eq = meta-eq.
%abbrev ty`false-implies-eq = false-implies-eq.
%abbrev ty`eq-reflexive = eq-reflexive.
%abbrev ty`eq-symmetric = eq-symmetric.
%abbrev ty`eq-transitive = eq-transitive.

%theorem ty-preserves-eq
  : forall* {NN1} {NN2} {A1} {A2} {C1} {C2}
    forall {NNE: nonnull`eq NN1 NN2} {AE: annot`eq A1 A2} {NE: nat`eq C1 C2}
    exists {TE: ty`eq (ty/ NN1 A1 C1) (ty/ NN2 A2 C2)}
    true.

- : ty-preserves-eq nonnull`eq/ annot`eq/ nat`eq/ ty`eq/.

%worlds () (ty-preserves-eq _ _ _ _).
%total { } (ty-preserves-eq _ _ _ _).


%theorem ty-eq-inversion :
    forall* {NN1} {NN2} {A1} {A2} {N1} {N2}
    forall  {T1=T2: ty`eq (ty/ NN1 A1 N1) (ty/ NN2 A2 N2)}
    exists  {EQ: nonnull`eq NN1 NN2} {EQ: annot`eq A1 A2}
            {EQ: nat`eq N1 N2}
    true.

- : ty-eq-inversion ty`eq/ nonnull`eq/ annot`eq/ nat`eq/.

%worlds () (ty-eq-inversion _ _ _ _).
%total  {} (ty-eq-inversion _ _ _ _).


%abbrev ty`leq = ty`eq.
%abbrev ty`false-implies-leq = ty`false-implies-eq.
%abbrev ty`leq-reflexive = ty`eq-reflexive.
%abbrev ty`leq-transitive = ty`eq-transitive.


%theorem ty`leq-anti-symmetric :
        forall* {T1:ty} {T2:ty}
        forall  {L12: ty`leq T1 T2} {L21: ty`leq T2 T1}
        exists  {E: ty`eq T1 T2}
        true.

- : ty`leq-anti-symmetric E _ E.

%worlds () (ty`leq-anti-symmetric _ _ _).
%total { } (ty`leq-anti-symmetric _ _ _).


%theorem ty`leq-respects-eq :
        forall* {T1:ty} {T2:ty} {T3:ty} {T4:ty}
        forall  {L1: ty`leq T1 T2}
                {E1: ty`eq T1 T3}
                {E2: ty`eq T2 T4}
        exists  {L3: ty`leq T3 T4}
        true.

- : ty`leq-respects-eq L _ _ L.

%worlds () (ty`leq-respects-eq _ _ _ _).
%total { } (ty`leq-respects-eq _ _ _ _).


#include "map-base.elf"
#include "map-leq.elf"
#include "map-domain.elf"
END_ELF
#undef data
%}%


%%% Exports

%abbrev fldmap = map.
%abbrev fldmap/0 = map/0.
%abbrev fldmap/+ = map/+.
%abbrev fldmap/1 : nat -> ty -> fldmap = [N][A] (fldmap/+ N A fldmap/0).
