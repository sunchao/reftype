%%%%% consistency-thms.elf
%%%%% theorems about consistency between clsmap, fldmap, methmap, and oflist
%%%%% Chao Sun
%%%%% $Id: consistency.thm,v 1.1 2013/05/07 16:20:10 csun Exp csun $
%%%%% Jun 17, 2010


clsmap-ty-respects-leq
  : clsmap-ty CM0 T
    -> clsmap`leq CM0 CM1
    -> clsmap-ty CM1 T
    -> type.

%mode clsmap-ty-respects-leq +CM0-T +CM0<=CM1 -CM1-T.

- : clsmap-ty-respects-leq (clsmap-ty/notnull (clsmap`domain?/in L0)) 
    CM0<=CM1 (clsmap-ty/notnull (clsmap`domain?/in L1))
    <- clsmap`lookup-respects-leq L0 CM0<=CM1 _ L1 _.

- : clsmap-ty-respects-leq clsmap-ty/null _ clsmap-ty/null.

%worlds () (clsmap-ty-respects-leq _ _ _).
%total { } (clsmap-ty-respects-leq _ _ _).


%theorem shift-preserves-clsmap-fldmap
  : forall* {CM} {FM} {FMP} {N}
    forall {CM-FM: clsmap-fldmap CM FM}
    {SH: fldmap`shift N FM FMP}
    exists {CM-FM: clsmap-fldmap CM FMP}
    true.

- : shift-preserves-clsmap-fldmap clsmap-fldmap/0 _ clsmap-fldmap/0.

- : shift-preserves-clsmap-fldmap
    (clsmap-fldmap/+ CM-FM CM-T) SH (clsmap-fldmap/+ CM-FM CM-T).

%worlds () (shift-preserves-clsmap-fldmap _ _ _).
%total {} (shift-preserves-clsmap-fldmap _ _ _).



clsmap-fldmap-respects-leq
  : clsmap-fldmap CM0 FM
    -> clsmap`leq CM0 CM1
    -> clsmap-fldmap CM1 FM
    -> type.

%mode clsmap-fldmap-respects-leq +CM0-FM +CM0<=CM1 -CM1-FM.

- : clsmap-fldmap-respects-leq clsmap-fldmap/0 _ clsmap-fldmap/0.

- : clsmap-fldmap-respects-leq (clsmap-fldmap/+ CM0-FM CM0-T)
    CM0<=CM1 (clsmap-fldmap/+ CM1-FM CM1-T)
    <- clsmap-ty-respects-leq CM0-T CM0<=CM1 CM1-T
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM.

%worlds () (clsmap-fldmap-respects-leq _ _ _).
%total (CM-FM) (clsmap-fldmap-respects-leq CM-FM _ _).


clsmap-clsmap-respects-leq
  : clsmap-clsmap CM0 CM
    -> clsmap`leq CM0 CM1
    -> clsmap-clsmap CM1 CM
    -> type.

%mode clsmap-clsmap-respects-leq +CM-CM1 +LE -CM-CM2.

- : clsmap-clsmap-respects-leq clsmap-clsmap/0 _ clsmap-clsmap/0.

- : clsmap-clsmap-respects-leq (clsmap-clsmap/+ CM0-CMS SH CM0-FM CM0-L)
    CM0<=CM1 (clsmap-clsmap/+ CM1-CMS SH CM1-FM CM1-L)
    <- clsmap`lookup-respects-leq CM0-L CM0<=CM1 _ CM1-LP EQ
    <- fldmap`eq-symmetric EQ EQP
    <- clsmap`lookup-respects-eq CM1-LP clsmap`eq/ nat`eq/ EQP CM1-L
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM
    <- clsmap-clsmap-respects-leq CM0-CMS CM0<=CM1 CM1-CMS.

%worlds () (clsmap-clsmap-respects-leq _ _ _).
%total (CM-CM) (clsmap-clsmap-respects-leq CM-CM _ _).


% fldmap-inner-efxmap

%theorem shift-preserves-fldmap-inner-efxmap :
    forall* {N} {FM} {FMP} {M} {MP}
    forall  {FM-M: fldmap-inner-efxmap FM M}
            {SH: fldmap`shift N FM FMP}
            {SH: inner-efxmap`shift N M MP}
    exists  {FMP-MP: fldmap-inner-efxmap FMP MP}
    true.

%worlds () (shift-preserves-fldmap-inner-efxmap _ _ _ _).
%trustme %total (I) (shift-preserves-fldmap-inner-efxmap I _ _ _).


%theorem leq-preserves-fldmap-inner-efxmap :
    forall* {M} {MP} {FM}
    forall  {M<=MP: inner-efxmap`leq M MP}
            {FM-MP: fldmap-inner-efxmap FM MP}
    exists  {FM-M: fldmap-inner-efxmap FM M}
    true.

%worlds () (leq-preserves-fldmap-inner-efxmap _ _ _).
%trustme %total (L) (leq-preserves-fldmap-inner-efxmap _ L _).
      

%theorem fldmap-inner-efxmap-respects-eq :
    forall* {FM1} {FM2} {M1} {M2}
    forall  {FM1-M1: fldmap-inner-efxmap FM1 M1}
            {EQ: fldmap`eq FM1 FM2} {EQ: inner-efxmap`eq M1 M2}
    exists  {FM2-M2: fldmap-inner-efxmap FM2 M2}
    true.

- : fldmap-inner-efxmap-respects-eq FM-M fldmap`eq/ inner-efxmap`eq/ FM-M.

%worlds () (fldmap-inner-efxmap-respects-eq _ _ _ _).
%total  {} (fldmap-inner-efxmap-respects-eq _ _ _ _).



% cxt-efxmap

%theorem cxt-efxmap-respects-eq :
    forall* {B1} {B2} {CM1} {CM2} {XM1} {XM2} 
    forall  {B1-XM1: cxt-efxmap B1 CM1 XM1}
            {EQ: cxt`eq B1 B2} {EQ: clsmap`eq CM1 CM2} {EQ: efxmap`eq XM1 XM2}
    exists  {B2-XM2: cxt-efxmap B2 CM2 XM2}
    true.

- : cxt-efxmap-respects-eq B-XM cxt`eq/ clsmap`eq/ efxmap`eq/ B-XM.
        
%worlds () (cxt-efxmap-respects-eq _ _ _ _ _).
%total  {} (cxt-efxmap-respects-eq _ _ _ _ _).


%theorem leq-preserves-cxt-efxmap :
    forall* {XM} {XMP} {CM} {B}
    forall  {B-XMP: cxt-efxmap B CM XMP}
            {XM1<=XM2: efxmap`leq XM XMP}
    exists  {B-XM: cxt-efxmap B CM XM}
    true.

%worlds (objvar | fracvar) (leq-preserves-cxt-efxmap _ _ _).    
%trustme %total (L) (leq-preserves-cxt-efxmap L _ _).


% theorems about shift

%theorem shift-preserves-clsmap-fldmap :
    forall* {CM} {FM1} {FM2} {N}
    forall  {CM-FM1: clsmap-fldmap CM FM1}
        		{SH: fldmap`shift N FM1 FM2}
    exists  {CM-FM2: clsmap-fldmap CM FM2}
    true.

- : shift-preserves-clsmap-fldmap clsmap-fldmap/0 _ clsmap-fldmap/0.

- : shift-preserves-clsmap-fldmap 
    (clsmap-fldmap/+ CM-FM1 IN) _ (clsmap-fldmap/+ CM-FM1 IN).

%worlds () (shift-preserves-clsmap-fldmap _ _ _).
%total  {} (shift-preserves-clsmap-fldmap _ _ _).


% This theorem says if under a "bigger" clsmap CM0, CM 
% is well-defined, and class C in CM has fldmap FM, then all
% classes in FM is well-defined under CM0

%theorem lookup-implies-clsmap-fldmap : 
    forall* {M} {CM} {FM} {C}
    forall  {M-CM: clsmap-clsmap M CM}
            {L: clsmap`lookup CM C FM}
    exists  {M-FM: clsmap-fldmap M FM}
    true.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ _ _ M-FM _)
     (clsmap`lookup/= _) M-FM.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ M-CMP SH _ _)
     (clsmap`lookup/> L P0) M-FM
     <- nat`plus-swap-succ P0 P1
     <- nat`plus-commutative P1 P2
     <- clsmap`shift-preserves-lookup* L SH P2 L2
     <- lookup-implies-clsmap-fldmap M-CMP L2 M-FM.

%worlds () (lookup-implies-clsmap-fldmap _ _ _).
%total  (M-CM) (lookup-implies-clsmap-fldmap M-CM _ _).


%theorem lookup-implies-clsmap-ty :
    forall* {CM} {FM} {F} {T}
    forall  {CM-FM: clsmap-fldmap CM FM}
            {FML: fldmap`lookup FM F T}
    exists  {CM-NT : clsmap-ty CM T}
    true.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM CM-T) 
    (fldmap`lookup/= _) CM-T.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM _) 
    (fldmap`lookup/> LP _) CM-T
    <- lookup-implies-clsmap-ty CM-FM LP CM-T.

%worlds () (lookup-implies-clsmap-ty _ _ _).
%total  (CM-FM) (lookup-implies-clsmap-ty CM-FM _ _).


%theorem lookup-implies-clsmap-methty :
    forall* {CM} {MM} {MT} {M}
    forall  {CM-MM: clsmap-methmap CM MM}
            {MM-LP: methmap`lookup MM M MT}
    exists  {CM-MT: clsmap-methty CM MT}
    true.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth _ _ CM-MT _) (methmap`lookup/= _) CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const _ _ (CM-MT) CML) (methmap`lookup/= _) 
     (clsmap-methty/args CM-MT (clsmap-ty/notnull (clsmap`domain?/in CML))).

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth CM-MMP N<<MM=MMP _ _) 
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

%worlds (objvar) (lookup-implies-clsmap-methty _ _ _).
%total  (L) (lookup-implies-clsmap-methty L _ _).


clsmap-ty-respects-eq
  : clsmap-ty CM1 T1
    -> clsmap`eq CM1 CM2
    -> ty`eq T1 T2
    -> clsmap-ty CM2 T2
    -> type.

%mode clsmap-ty-respects-eq +T1 +E1 +E2 -T2.

- : clsmap-ty-respects-eq D clsmap`eq/ ty`eq/ D.

%worlds () (clsmap-ty-respects-eq _ _ _ _).
%total {}  (clsmap-ty-respects-eq _ _ _ _).


cxt-lookup-implies-clsmap-ty
  : clsmap-cxt CM B
    -> cxt`lookup-object B O T N
    -> clsmap-ty CM T
    -> type.

%mode cxt-lookup-implies-clsmap-ty +CM-B +L -CM-T.

cxt-lookup-implies-clsmap-ty/L
  : cxt`fresh BP N1
    -> cxt`update BP N1 (cxtv/ O1 T1) B
    -> clsmap-ty CM T1
    -> clsmap-cxt CM BP
    -> cxt`lookup B N2 (cxtv/ O2 T2)
    -> nat`eq? N1 N2 P
    -> clsmap-ty CM T2
    -> type.

%mode cxt-lookup-implies-clsmap-ty/L +F +U +T1 +T2 +L +E? -T3.

- : cxt-lookup-implies-clsmap-ty/L FS U CM-T CM-BP B-L2 nat`eq?/yes CM-T2
    <- cxt`update-implies-lookup U B-L1
    <- cxt`lookup-unique B-L1 B-L2 cxt`eq/ nat`eq/ CV-EQ
    <- cxtv-eq-inversion CV-EQ O-EQ T-EQ
    <- clsmap-ty-respects-eq CM-T clsmap`eq/ T-EQ CM-T2.

- : cxt-lookup-implies-clsmap-ty/L _ U _ CM-BP B-L (nat`eq?/no NE) CM-T2
    <- nat`ne-symmetric NE NE2
    <- cxt`update-preserves-lookup-converse B-L U NE2 BP-L
    <- cxt-lookup-implies-clsmap-ty CM-BP (cxt`lookup-object/ BP-L) CM-T2.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons F U CM-T CM-BP)
    (cxt`lookup-object/ B-L) CM-T2
    <- nat`eq?-total EQ?
    <- cxt-lookup-implies-clsmap-ty/L F U CM-T CM-BP B-L EQ? CM-T2.

%worlds (objvar)
(cxt-lookup-implies-clsmap-ty _ _ _)
(cxt-lookup-implies-clsmap-ty/L _ _ _ _ _ _ _).
%total (CM-B CM-BP) (cxt-lookup-implies-clsmap-ty CM-B _ _)
(cxt-lookup-implies-clsmap-ty/L _ _ _ CM-BP _ _ _).


%{
%theorem reftyping-implies-cxt-set
  : forall* {L1} {L2} {CM} {MM} {B} {E} {T} {S} {GM} {XM}
    forall {RTYP: reftyping L1 CM MM B E (out/expr (reftype/ T S GM) XM) L2}
    exists {B-S: cxt-set B S}
    true.

- : reftyping-implies-cxt-set
    (reftyping/lit (cxt`lookup-object/ B-L))
    (cxt-set/U set`not-member/0 set`update/0 
      B-L cxt-set/0).

- : reftyping-implies-cxt-set reftyping/null cxt-set/0.

- : reftyping-implies-cxt-set (reftyping/read/shared _ _ _ _) cxt-set/0.

- : reftyping-implies-cxt-set
    (reftyping/read/unique _ _ _ _ _ _ _ _) cxt-set/0.

- : reftyping-implies-cxt-set
    (reftyping/read/borrow _ _ _ _ _ _ _) cxt-set/0.

- : reftyping-implies-cxt-set
    (reftyping/write _ _ _ _ _ _ _ _ _ _ _ _) cxt-set/0.

%worlds () (reftyping-implies-cxt-set _ _).
%trustme %total {} (reftyping-implies-cxt-set _ _).



%theorem reftyping-implies-cxt-efxmap
  : forall* {L1} {L2} {CM} {MM} {B} {E} {RT} {XM}
    forall {RTYP: reftyping L1 CM MM B E (out/expr RT XM) L2}
    exists {B-XM: cxt-efxmap B CM XM}
    true.

%worlds () (reftyping-implies-cxt-efxmap _ _).
%trustme %total {} (reftyping-implies-cxt-efxmap _ _).

}%