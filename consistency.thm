%%%%% consistency-thms.elf
%%%%% theorems about consistency between clsmap, fldmap, methmap, and oflist


%% ===================
%% XX-respects-eq
%% ===================

%theorem clsmap-ty-respects-eq
  : forall* {CM1} {CM2} {T1} {T2}
    forall {CM1-T1: clsmap-ty CM1 T1}
    {E: clsmap`eq CM1 CM2} {E: ty`eq T1 T2}
    exists {CM2-T2: clsmap-ty CM2 T2}
    true.

- : clsmap-ty-respects-eq D clsmap`eq/ ty`eq/ D.

%worlds () (clsmap-ty-respects-eq _ _ _ _).
%total {} (clsmap-ty-respects-eq _ _ _ _).


%theorem clsmap-cxt-tgtmap-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {XM1} {XM2}
    forall {B1-XM1: clsmap-cxt-tgtmap CM1 B1 XM1}
    {EQ: cxt`eq B1 B2} {EQ: clsmap`eq CM1 CM2} {EQ: tgtmap`eq XM1 XM2}
    exists {B2-XM2: clsmap-cxt-tgtmap CM2 B2 XM2}
    true.

- : clsmap-cxt-tgtmap-respects-eq B-XM cxt`eq/ clsmap`eq/ tgtmap`eq/ B-XM.

%worlds () (clsmap-cxt-tgtmap-respects-eq _ _ _ _ _).
%total {} (clsmap-cxt-tgtmap-respects-eq _ _ _ _ _).


%% ====================
%% XX-respects-leq
%% ====================

%theorem clsmap-ty-respects-leq
  : forall* {CM0} {CM1} {T}
    forall {CM0-T: clsmap-ty CM0 T}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-T: clsmap-ty CM1 T}
    true.

- : clsmap-ty-respects-leq (clsmap-ty/notnull L0)
    CM0<=CM1 (clsmap-ty/notnull L1)
    <- clsmap`lookup-respects-leq L0 CM0<=CM1 _ L1 _.

- : clsmap-ty-respects-leq clsmap-ty/null _ clsmap-ty/null.

%worlds () (clsmap-ty-respects-leq _ _ _).
%total {} (clsmap-ty-respects-leq _ _ _).


%theorem clsmap-fldmap-respects-leq
  : forall* {CM0} {CM1} {FM}
    forall {CM0-FM: clsmap-fldmap CM0 FM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-FM: clsmap-fldmap CM1 FM}
    true.

- : clsmap-fldmap-respects-leq clsmap-fldmap/0 _ clsmap-fldmap/0.

- : clsmap-fldmap-respects-leq (clsmap-fldmap/+ CM0-FM CM0-T)
    CM0<=CM1 (clsmap-fldmap/+ CM1-FM CM1-T)
    <- clsmap-ty-respects-leq CM0-T CM0<=CM1 CM1-T
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM.

%worlds () (clsmap-fldmap-respects-leq _ _ _).
%total (CM-FM) (clsmap-fldmap-respects-leq CM-FM _ _).


%theorem clsmap-clsmap-respects-leq
  : forall* {CM0} {CM1} {CM}
    forall {CM0-CM: clsmap-clsmap CM0 CM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-CM: clsmap-clsmap CM1 CM}
    true.

- : clsmap-clsmap-respects-leq clsmap-clsmap/0 _ clsmap-clsmap/0.

- : clsmap-clsmap-respects-leq (clsmap-clsmap/+ CM0-CMS SH CM0-FM CM0-L)
    CM0<=CM1 (clsmap-clsmap/+ CM1-CMS SH CM1-FM CM1-L)
    <- clsmap`lookup-respects-leq CM0-L CM0<=CM1 _ CM1-LP EQ
    <- fldmap`eq-symmetric EQ EQP
    <- clsmap`lookup-respects-eq CM1-LP clsmap`eq/ nat`eq/ EQP CM1-L
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM
    <- clsmap-clsmap-respects-leq CM0-CMS CM0<=CM1 CM1-CMS.

%worlds () (clsmap-clsmap-respects-leq _ _ _).
%total (CM-CM) (clsmap-clsmap-respects-leq CM-CM _ _).



%% ===========================
%% leq-preserves-XX
%% ===========================

%theorem leq-preserves-clsmap-cxt-tgtmap
  : forall* {XM} {XMP} {CM} {B}
    forall {B-XMP: clsmap-cxt-tgtmap CM B XMP}
    {XM1<=XM2: tgtmap`leq XM XMP}
    exists {B-XM: clsmap-cxt-tgtmap CM B XM}
    true.

- : leq-preserves-clsmap-cxt-tgtmap
    clsmap-cxt-tgtmap/0 tgtmap`leq/0 clsmap-cxt-tgtmap/0.

%theorem leq-preserves-clsmap-cxt-tgtmap/U
  : forall* {CM} {FM} {XM} {XMS} {XMP} {N} {B}
    {NN} {A} {C} {S} {FS}
    forall {P} {IN?: tgtmap`domain? XM N P}
    {F: tgtmap`fresh XMS N}
    {U: tgtmap`update XMS N S XMP}
    {B-L: cxt`lookup B (object/ N) (ty/ NN A C)}
    {CM-L: clsmap`lookup CM C FM}
    {DM-FM: fldmap`domain FM FS}
    {LE: set`leq S FS} {CM-B-XMS: clsmap-cxt-tgtmap CM B XMS}
    {XM<=XMP: tgtmap`leq XM XMP}
    exists {CM-B-XM: clsmap-cxt-tgtmap CM B XM}
    true.

- : leq-preserves-clsmap-cxt-tgtmap/U true (tgtmap`domain?/in XM->N=M)
    N!<XMS XMS+N+MP=XMP B->N=C CM->C=FM DM-FM=FS MPS<=FS
    CM-B-XMS XM<=XMP
    (clsmap-cxt-tgtmap/U CM-B-XMT N!<XMT XMT+N+M=XM B->N=C CM->C=FM DM-FM=FS
      MS<=FS)
    <- tgtmap`lookup-implies-fresh-update XM->N=M XMT N!<XMT XMT+N+M=XM
    <- tgtmap`fresh-update-preserves-leq-converse
      XM<=XMP N!<XMT XMT+N+M=XM N!<XMS XMS+N+MP=XMP XMT<=XMS M<=MP
    <- leq-preserves-clsmap-cxt-tgtmap CM-B-XMS XMT<=XMS CM-B-XMT
    <- set`leq-transitive M<=MP MPS<=FS MS<=FS.

- : leq-preserves-clsmap-cxt-tgtmap/U false (tgtmap`domain?/out N!<XM)
    N!<XMS XMS+N+MP=XMP B->N=C CM->C=FM DM-FM=FS MPS<=FS
    CM-B-XMS XM<=XMP CM-B-XM
    <- tgtmap`fresh-update2-preserves-leq-converse
      XM<=XMP N!<XM N!<XMS XMS+N+MP=XMP XM<=XMS
    <- leq-preserves-clsmap-cxt-tgtmap CM-B-XMS XM<=XMS CM-B-XM.

- : leq-preserves-clsmap-cxt-tgtmap
    (clsmap-cxt-tgtmap/U CM-B-XMS N!<XMS XMS+N+M=XMP
      B->N=C CM->C=FM DM-FM=FS MS<=FS) XM<=XMP CM-B-XM
    <- tgtmap`domain?-total N-in-XM?
    <- leq-preserves-clsmap-cxt-tgtmap/U _ N-in-XM?
      N!<XMS XMS+N+M=XMP B->N=C CM->C=FM DM-FM=FS
      MS<=FS CM-B-XMS XM<=XMP CM-B-XM.

%worlds (objvar | fracvar) (leq-preserves-clsmap-cxt-tgtmap _ _ _)
(leq-preserves-clsmap-cxt-tgtmap/U _ _ _ _ _ _ _ _ _ _ _).
%total (L1 L2) (leq-preserves-clsmap-cxt-tgtmap L1 _ _)
(leq-preserves-clsmap-cxt-tgtmap/U _ _ _ _ _ _ _ _ L2 _ _).


%theorem leq-preserves-clsmap-cxt-efxmap
  : forall* {XM} {XMP} {CM} {B}
    forall {B-XMP: clsmap-cxt-efxmap CM B XMP}
    {XM1<=XM2: efxmap`leq XM XMP}
    exists {B-XM: clsmap-cxt-efxmap CM B XM}
    true.

- : leq-preserves-clsmap-cxt-efxmap
    clsmap-cxt-efxmap/0 efxmap`leq/0 clsmap-cxt-efxmap/0.

%worlds (objvar | fracvar) (leq-preserves-clsmap-cxt-efxmap _ _ _).
%trustme %total {} (leq-preserves-clsmap-cxt-efxmap L1 _ _).


%% ==========================
%% shift-preserves-XX
%% ==========================

%theorem shift-preserves-clsmap-fldmap
  : forall* {CM} {FM} {FMP} {N}
    forall {CM-FM: clsmap-fldmap CM FM}
    {SH: fldmap`shift N FM FMP}
    exists {CM-FM: clsmap-fldmap CM FMP}
    true.

- : shift-preserves-clsmap-fldmap clsmap-fldmap/0 _ clsmap-fldmap/0.

- : shift-preserves-clsmap-fldmap
    (clsmap-fldmap/+ CM-FM CM-T) SH (clsmap-fldmap/+ CM-FM CM-T).

%worlds () (shift-preserves-clsmap-fldmap _ _ _).
%total {} (shift-preserves-clsmap-fldmap _ _ _).



%% ========================
%% lookup-implies-XX
%% ========================

% This theorem says if under a "bigger" clsmap CM0, CM
% is well-defined, and class C in CM has fldmap FM, then all
% classes in FM is well-defined under CM0

%theorem lookup-implies-clsmap-fldmap
  : forall* {M} {CM} {FM} {C}
    forall {M-CM: clsmap-clsmap M CM}
    {L: clsmap`lookup CM C FM}
    exists {M-FM: clsmap-fldmap M FM}
    true.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ _ _ M-FM _)
     (clsmap`lookup/= _) M-FM.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ M-CMP SH _ _)
     (clsmap`lookup/> L P0) M-FM
     <- nat`plus-swap-succ P0 P1
     <- nat`plus-commutative P1 P2
     <- clsmap`shift-preserves-lookup* L SH P2 L2
     <- lookup-implies-clsmap-fldmap M-CMP L2 M-FM.

%worlds () (lookup-implies-clsmap-fldmap _ _ _).
%total (M-CM) (lookup-implies-clsmap-fldmap M-CM _ _).


%theorem lookup-implies-clsmap-ty
  : forall* {CM} {FM} {F} {T}
    forall {CM-FM: clsmap-fldmap CM FM}
    {FM-L: fldmap`lookup FM F T}
    exists {CM-NT: clsmap-ty CM T}
    true.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM CM-T)
    (fldmap`lookup/= _) CM-T.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM _)
    (fldmap`lookup/> LP _) CM-T
    <- lookup-implies-clsmap-ty CM-FM LP CM-T.

%worlds () (lookup-implies-clsmap-ty _ _ _).
%total (CM-FM) (lookup-implies-clsmap-ty CM-FM _ _).


%theorem lookup-implies-clsmap-methty
  : forall* {CM} {MM} {MT} {M}
    forall {CM-MM: clsmap-methmap CM MM}
    {MM-LP: methmap`lookup MM M MT}
    exists {CM-MT: clsmap-methty CM MT}
    true.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth _ _ CM-MT _) (methmap`lookup/= _) CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const _ _ (CM-MT) CML) (methmap`lookup/= _)
     (clsmap-methty/args CM-MT (clsmap-ty/notnull CML)).

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

%worlds (objvar) (lookup-implies-clsmap-methty _ _ _).
%total (L) (lookup-implies-clsmap-methty L _ _).


%theorem cxt-lookup-implies-clsmap-ty
  : forall* {CM} {B} {T} {O}
    forall {CM-B: clsmap-cxt CM B}
    {B-L: cxt`lookup B O T}
    exists {CM-T: clsmap-ty CM T}
    true.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons _ CM-T) cxt`lookup/hit CM-T.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons CM-B _) (cxt`lookup/miss B-L _) CM-T
    <- cxt-lookup-implies-clsmap-ty CM-B B-L CM-T.

%worlds () (cxt-lookup-implies-clsmap-ty _ _ _).
%total (CM-B) (cxt-lookup-implies-clsmap-ty CM-B _ _).


%theorem set+nat2tgtmap-implies-clsmap-cxt-tgtmap
  : forall* {CM} {B} {S} {F} {G} {C} {FM} {T}
    forall {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    {SOC: same-class B S C}
    {S+F=>G: set+nat2tgtmap S F G}
    exists {CM-B-G: clsmap-cxt-tgtmap CM B G}
    true.

- : set+nat2tgtmap-implies-clsmap-cxt-tgtmap
    _ _ same-class/0 set+nat2tgtmap/0 clsmap-cxt-tgtmap/0.

- : set+nat2tgtmap-implies-clsmap-cxt-tgtmap CML FML
    (same-class/U S-SP NM A BL) S=>G
    (clsmap-cxt-tgtmap/U CM-B-GP F U BL CML DM LE)
    <- set+nat2tgtmap/U-inversion S=>G NM A _ SP=>GP U
    <- set+nat2tgtmap-implies-clsmap-cxt-tgtmap CML FML S-SP SP=>GP CM-B-GP
    <- fldmap`domain-total DM
    <- fldmap`domain-preserves-lookup FML DM SL
    <- set`member-implies-unit-leq SL LE
    <- set+nat2tgtmap-preserves-fresh SP=>GP NM F.

%worlds () (set+nat2tgtmap-implies-clsmap-cxt-tgtmap _ _ _ _ _).
%total (T) (set+nat2tgtmap-implies-clsmap-cxt-tgtmap _ _ T _ _).


%theorem deep-disjoint-join-preserves-clsmap-cxt-tgtmap
  : forall* {CM} {B} {G1} {G2} {G}
    forall {CM-B-G1: clsmap-cxt-tgtmap CM B G1}
    {CM-B-G2: clsmap-cxt-tgtmap CM B G2}
    {X: tgtmap`deep-disjoint G1 G2}
    {J: tgtmap`join G1 G2 G}
    exists {CM-B-G: clsmap-cxt-tgtmap CM B G}
    true.

%worlds () (deep-disjoint-join-preserves-clsmap-cxt-tgtmap _ _ _ _ _).
%trustme %total {} (deep-disjoint-join-preserves-clsmap-cxt-tgtmap _ _ _ _ _).


%theorem join-preserves-clsmap-cxt-efxmap
  : forall* {CM} {B} {M1} {M2} {M}
    forall {CM-B-M1: clsmap-cxt-efxmap CM B M1}
    {CM-B-M2: clsmap-cxt-efxmap CM B M2}
    {J: efxmap`join M1 M2 M}
    exists {CM-B-M: clsmap-cxt-efxmap CM B M}
    true.

%worlds () (join-preserves-clsmap-cxt-efxmap _ _ _ _).
%trustme %total {} (join-preserves-clsmap-cxt-efxmap _ _ _ _).


%theorem tgtmap2efxmap-preserves-consistency
  : forall* {CM} {B} {G} {X} {M}
    forall {G2M: tgtmap2efxmap G X M}
    {CM-B-G: clsmap-cxt-tgtmap CM B G}
    exists {CM-B-M: clsmap-cxt-efxmap CM B M}
    true.

- : tgtmap2efxmap-preserves-consistency
    tgtmap2efxmap/0 clsmap-cxt-tgtmap/0 clsmap-cxt-efxmap/0.

- : tgtmap2efxmap-preserves-consistency
    G=>M (clsmap-cxt-tgtmap/U CM-B-GP F U BL CML DM LE)
    (clsmap-cxt-efxmap/U CM-B-MP F2 U2 BL CML DM SDM LE)
    <- tgtmap2efxmap/U-inversion G=>M F U _ _ GP=>MP S=>D U2
    <- tgtmap2efxmap-preserves-fresh F GP=>MP F2
    <- tgtmap2efxmap-preserves-consistency GP=>MP CM-B-GP CM-B-MP
    <- set2inner-efxmap-implies-domain S=>D SDM.

%worlds () (tgtmap2efxmap-preserves-consistency _ _ _).
%total (A) (tgtmap2efxmap-preserves-consistency _ A _).


%theorem make-targets-and-effects-preserves-clsmap-cxt-targets
  : forall* {CM} {B} {GS} {A} {X} {GSP} {XM} {MX} {F} {C} {FM} {NN} {FC}
    forall {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {CM-B-GS: clsmap-cxt-targets CM B C GS}
    {MG: make-targets-and-effects GS A F X GSP (effects/ XM MX)}
    exists {CM-B-GSP: clsmap-cxt-targets CM B FC GSP}
    {CM-B-XM: clsmap-cxt-efxmap CM B XM}
    true.

- : make-targets-and-effects-preserves-clsmap-cxt-targets
    _ _ clsmap-cxt-targets/shared
    (make-targets-and-effects/shared consider-ftype/shared)
    clsmap-cxt-targets/shared clsmap-cxt-efxmap/0.

- : make-targets-and-effects-preserves-clsmap-cxt-targets
    _ _ clsmap-cxt-targets/shared
    (make-targets-and-effects/shared consider-ftype/unique)
    (clsmap-cxt-targets/unique clsmap-cxt-tgtmap/0 same-class/0)
    clsmap-cxt-efxmap/0.

- : make-targets-and-effects-preserves-clsmap-cxt-targets
    CML FML (clsmap-cxt-targets/unique CM-B-G1 SOC)
    (make-targets-and-effects/unique
      S=>G2 G1^G2 G1+G2=G G=>M _ consider-ftype/shared)
    clsmap-cxt-targets/shared CM-B-M
    <- set+nat2tgtmap-implies-clsmap-cxt-tgtmap CML FML SOC S=>G2 CM-B-G2
    <- deep-disjoint-join-preserves-clsmap-cxt-tgtmap
      CM-B-G1 CM-B-G2 G1^G2 G1+G2=G CM-B-G
    <- tgtmap2efxmap-preserves-consistency G=>M CM-B-G CM-B-M.

- : make-targets-and-effects-preserves-clsmap-cxt-targets
    CML FML (clsmap-cxt-targets/unique CM-B-G1 SOC)
    (make-targets-and-effects/unique
      S=>G2 G1^G2 G1+G2=G G=>M _ consider-ftype/unique)
    (clsmap-cxt-targets/unique CM-B-G same-class/0) CM-B-M
    <- set+nat2tgtmap-implies-clsmap-cxt-tgtmap CML FML SOC S=>G2 CM-B-G2
    <- deep-disjoint-join-preserves-clsmap-cxt-tgtmap
      CM-B-G1 CM-B-G2 G1^G2 G1+G2=G CM-B-G
    <- tgtmap2efxmap-preserves-consistency G=>M CM-B-G CM-B-M.

%worlds () (make-targets-and-effects-preserves-clsmap-cxt-targets _ _ _ _ _ _).
%total {} (make-targets-and-effects-preserves-clsmap-cxt-targets _ _ _ _ _ _).


%theorem reftyping-consistent
  : forall* {CM} {MM} {B} {E} {NN} {C} {GS} {XM} {MX}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-B: clsmap-cxt CM B}
    {RTYP: reftyping CM MM B E (out/expr (reftype/ NN C GS) (effects/ XM MX))}
    exists {FM} {CML: clsmap`lookup CM C FM}
    {CM-B-GS: clsmap-cxt-targets CM B C GS}
    {CM-B-XM: clsmap-cxt-efxmap CM B XM}
    true.

- : reftyping-consistent CM-CM CM-B
    (reftyping/lit ty2reftype/unique object-index/ BL)
    _ CML (clsmap-cxt-targets/unique
            clsmap-cxt-tgtmap/0
          (same-class/U same-class/0 set`not-member/0 set`update/0 BL))
    clsmap-cxt-efxmap/0
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/notnull CML).

- : reftyping-consistent _ CM-B
    (reftyping/lit ty2reftype/shared object-index/ BL) _ CML
    (clsmap-cxt-targets/shared) clsmap-cxt-efxmap/0
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/notnull CML).

- : reftyping-consistent _ CM-B
    (reftyping/lit ty2reftype/borrow object-index/ BL)
    _ CML (clsmap-cxt-targets/unique clsmap-cxt-tgtmap/0
            (same-class/U same-class/0 set`not-member/0 set`update/0 BL))
    clsmap-cxt-efxmap/0
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/notnull CML).

- : reftyping-consistent CM-CM CM-B
    (reftyping/read RTYP CML FML MG (effects`join/ J _)) _ CML2 CM-B-GSP CM-B-M
    <- reftyping-consistent CM-CM CM-B RTYP _ _ CM-B-GS CM-B-M1
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/notnull CML2)
    <- make-targets-and-effects-preserves-clsmap-cxt-targets
      CML FML CM-B-GS MG CM-B-GSP CM-B-M2
    <- join-preserves-clsmap-cxt-efxmap CM-B-M1 CM-B-M2 J CM-B-M.

%worlds () (reftyping-consistent _ _ _ _ _ _ _).
%total (T) (reftyping-consistent _ _ T _ _ _ _).

