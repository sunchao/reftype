%%%%% consistency-thms.elf
%%%%% theorems about consistency between clsmap, fldmap, methmap, and oflist


%% ===================
%% XX-respects-eq
%% ===================

%theorem clsmap-ty-respects-eq
  : forall* {CM1} {CM2} {T1} {T2}
    forall {CM1-T1: clsmap-ty CM1 T1}
    {E: clsmap`eq CM1 CM2} {E: ty`eq T1 T2}
    exists {CM2-T2: clsmap-ty CM2 T2}
    true.

- : clsmap-ty-respects-eq D clsmap`eq/ ty`eq/ D.

%worlds () (clsmap-ty-respects-eq _ _ _ _).
%total {} (clsmap-ty-respects-eq _ _ _ _).


%theorem clsmap-cxt-efxmap-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {XM1} {XM2}
    forall {B1-XM1: clsmap-cxt-efxmap CM1 B1 XM1}
    {EQ: cxt`eq B1 B2} {EQ: clsmap`eq CM1 CM2} {EQ: efxmap`eq XM1 XM2}
    exists {B2-XM2: clsmap-cxt-efxmap CM2 B2 XM2}
    true.

- : clsmap-cxt-efxmap-respects-eq B-XM cxt`eq/ clsmap`eq/ efxmap`eq/ B-XM.

%worlds () (clsmap-cxt-efxmap-respects-eq _ _ _ _ _).
%total {} (clsmap-cxt-efxmap-respects-eq _ _ _ _ _).




%% ====================
%% XX-respects-leq
%% ====================

%theorem clsmap-ty-respects-leq
  : forall* {CM0} {CM1} {T}
    forall {CM0-T: clsmap-ty CM0 T}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-T: clsmap-ty CM1 T}
    true.

- : clsmap-ty-respects-leq (clsmap-ty/notnull L0)
    CM0<=CM1 (clsmap-ty/notnull L1)
    <- clsmap`lookup-respects-leq L0 CM0<=CM1 _ L1 _.

- : clsmap-ty-respects-leq clsmap-ty/null _ clsmap-ty/null.

%worlds () (clsmap-ty-respects-leq _ _ _).
%total {} (clsmap-ty-respects-leq _ _ _).


%theorem clsmap-fldmap-respects-leq
  : forall* {CM0} {CM1} {FM}
    forall {CM0-FM: clsmap-fldmap CM0 FM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-FM: clsmap-fldmap CM1 FM}
    true.

- : clsmap-fldmap-respects-leq clsmap-fldmap/0 _ clsmap-fldmap/0.

- : clsmap-fldmap-respects-leq (clsmap-fldmap/+ CM0-FM CM0-T)
    CM0<=CM1 (clsmap-fldmap/+ CM1-FM CM1-T)
    <- clsmap-ty-respects-leq CM0-T CM0<=CM1 CM1-T
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM.

%worlds () (clsmap-fldmap-respects-leq _ _ _).
%total (CM-FM) (clsmap-fldmap-respects-leq CM-FM _ _).


%theorem clsmap-clsmap-respects-leq
  : forall* {CM0} {CM1} {CM}
    forall {CM0-CM: clsmap-clsmap CM0 CM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-CM: clsmap-clsmap CM1 CM}
    true.

- : clsmap-clsmap-respects-leq clsmap-clsmap/0 _ clsmap-clsmap/0.

- : clsmap-clsmap-respects-leq (clsmap-clsmap/+ CM0-CMS SH CM0-FM CM0-L)
    CM0<=CM1 (clsmap-clsmap/+ CM1-CMS SH CM1-FM CM1-L)
    <- clsmap`lookup-respects-leq CM0-L CM0<=CM1 _ CM1-LP EQ
    <- fldmap`eq-symmetric EQ EQP
    <- clsmap`lookup-respects-eq CM1-LP clsmap`eq/ nat`eq/ EQP CM1-L
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM
    <- clsmap-clsmap-respects-leq CM0-CMS CM0<=CM1 CM1-CMS.

%worlds () (clsmap-clsmap-respects-leq _ _ _).
%total (CM-CM) (clsmap-clsmap-respects-leq CM-CM _ _).



%% ===========================
%% leq-preserves-XX
%% ===========================

%theorem leq-preserves-clsmap-cxt-efxmap
  : forall* {XM} {XMP} {CM} {B}
    forall {B-XMP: clsmap-cxt-efxmap CM B XMP}
    {XM1<=XM2: efxmap`leq XM XMP}
    exists {B-XM: clsmap-cxt-efxmap CM B XM}
    true.

- : leq-preserves-clsmap-cxt-efxmap
    clsmap-cxt-efxmap/0 efxmap`leq/0 clsmap-cxt-efxmap/0.

%theorem leq-preserves-clsmap-cxt-efxmap/U
  : forall* {CM} {FM} {XM} {XMS} {XMP} {O} {N} {B}
    {NN} {A} {C} {M} {MS} {FS}
    forall {P} {IN?: efxmap`domain? XM N P}
    {F: efxmap`fresh XMS N}
    {U: efxmap`update XMS N M XMP}
    {B-L: cxt`lookup B N (cxtv/ O (ty/ NN A C))}
    {CM-L: clsmap`lookup CM C FM}
    {DM-FM: fldmap`domain FM FS}
    {DM-M: inner-efxmap`domain M MS}
    {LE: set`leq MS FS} {CM-B-XMS: clsmap-cxt-efxmap CM B XMS}
    {XM<=XMP: efxmap`leq XM XMP}
    exists {CM-B-XM: clsmap-cxt-efxmap CM B XM}
    true.

- : leq-preserves-clsmap-cxt-efxmap/U true (efxmap`domain?/in XM->N=M)
    N!<XMS XMS+N+MP=XMP B->N=C CM->C=FM DM-FM=FS DM-MP=MPS MPS<=FS
    CM-B-XMS XM<=XMP
    (clsmap-cxt-efxmap/U N!<XMT XMT+N+M=XM B->N=C CM->C=FM DM-FM=FS
      DM-M=MS MS<=FS CM-B-XMT)
    <- efxmap`lookup-implies-fresh-update XM->N=M XMT N!<XMT XMT+N+M=XM
    <- efxmap`fresh-update-preserves-leq-converse
      XM<=XMP N!<XMT XMT+N+M=XM N!<XMS XMS+N+MP=XMP XMT<=XMS M<=MP
    <- leq-preserves-clsmap-cxt-efxmap CM-B-XMS XMT<=XMS CM-B-XMT
    <- inner-efxmap`domain-total DM-M=MS
    <- inner-efxmap`domain-preserves-leq* M<=MP DM-M=MS DM-MP=MPS MS<=MPS
    <- set`leq-transitive MS<=MPS MPS<=FS MS<=FS.

- : leq-preserves-clsmap-cxt-efxmap/U false (efxmap`domain?/out N!<XM)
    N!<XMS XMS+N+MP=XMP B->N=C CM->C=FM DM-FM=FS DM-MP=MPS MPS<=FS
    CM-B-XMS XM<=XMP CM-B-XM
    <- efxmap`fresh-update2-preserves-leq-converse
      XM<=XMP N!<XM N!<XMS XMS+N+MP=XMP XM<=XMS
    <- leq-preserves-clsmap-cxt-efxmap CM-B-XMS XM<=XMS CM-B-XM.

- : leq-preserves-clsmap-cxt-efxmap
    (clsmap-cxt-efxmap/U N!<XMS XMS+N+M=XMP B->N=C CM->C=FM DM-FM=FS
      DM-M=MS MS<=FS CM-B-XMS) XM<=XMP CM-B-XM
    <- efxmap`domain?-total N-in-XM?
    <- leq-preserves-clsmap-cxt-efxmap/U _ N-in-XM?
      N!<XMS XMS+N+M=XMP B->N=C CM->C=FM DM-FM=FS DM-M=MS
      MS<=FS CM-B-XMS XM<=XMP CM-B-XM.

%worlds (objvar | fracvar) (leq-preserves-clsmap-cxt-efxmap _ _ _)
(leq-preserves-clsmap-cxt-efxmap/U _ _ _ _ _ _ _ _ _ _ _ _).
%total (L1 L2) (leq-preserves-clsmap-cxt-efxmap L1 _ _)
(leq-preserves-clsmap-cxt-efxmap/U _ _ _ _ _ _ _ _ _ L2 _ _).



%% ==========================
%% shift-preserves-XX
%% ==========================

%theorem shift-preserves-clsmap-fldmap
  : forall* {CM} {FM} {FMP} {N}
    forall {CM-FM: clsmap-fldmap CM FM}
    {SH: fldmap`shift N FM FMP}
    exists {CM-FM: clsmap-fldmap CM FMP}
    true.

- : shift-preserves-clsmap-fldmap clsmap-fldmap/0 _ clsmap-fldmap/0.

- : shift-preserves-clsmap-fldmap
    (clsmap-fldmap/+ CM-FM CM-T) SH (clsmap-fldmap/+ CM-FM CM-T).

%worlds () (shift-preserves-clsmap-fldmap _ _ _).
%total {} (shift-preserves-clsmap-fldmap _ _ _).



%% ========================
%% lookup-implies-XX
%% ========================

% This theorem says if under a "bigger" clsmap CM0, CM
% is well-defined, and class C in CM has fldmap FM, then all
% classes in FM is well-defined under CM0

%theorem lookup-implies-clsmap-fldmap
  : forall* {M} {CM} {FM} {C}
    forall {M-CM: clsmap-clsmap M CM}
    {L: clsmap`lookup CM C FM}
    exists {M-FM: clsmap-fldmap M FM}
    true.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ _ _ M-FM _)
     (clsmap`lookup/= _) M-FM.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ M-CMP SH _ _)
     (clsmap`lookup/> L P0) M-FM
     <- nat`plus-swap-succ P0 P1
     <- nat`plus-commutative P1 P2
     <- clsmap`shift-preserves-lookup* L SH P2 L2
     <- lookup-implies-clsmap-fldmap M-CMP L2 M-FM.

%worlds () (lookup-implies-clsmap-fldmap _ _ _).
%total (M-CM) (lookup-implies-clsmap-fldmap M-CM _ _).


%theorem lookup-implies-clsmap-ty
  : forall* {CM} {FM} {F} {T}
    forall {CM-FM: clsmap-fldmap CM FM}
    {FM-L: fldmap`lookup FM F T}
    exists {CM-NT: clsmap-ty CM T}
    true.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM CM-T)
    (fldmap`lookup/= _) CM-T.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM _)
    (fldmap`lookup/> LP _) CM-T
    <- lookup-implies-clsmap-ty CM-FM LP CM-T.

%worlds () (lookup-implies-clsmap-ty _ _ _).
%total (CM-FM) (lookup-implies-clsmap-ty CM-FM _ _).


%theorem lookup-implies-clsmap-methty
  : forall* {CM} {MM} {MT} {M}
    forall {CM-MM: clsmap-methmap CM MM}
    {MM-LP: methmap`lookup MM M MT}
    exists {CM-MT: clsmap-methty CM MT}
    true.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth _ _ CM-MT _) (methmap`lookup/= _) CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const _ _ (CM-MT) CML) (methmap`lookup/= _)
     (clsmap-methty/args CM-MT (clsmap-ty/notnull CML)).

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

%worlds (objvar) (lookup-implies-clsmap-methty _ _ _).
%total (L) (lookup-implies-clsmap-methty L _ _).


%theorem cxt-lookup-implies-clsmap-ty
  : forall* {CM} {B} {N} {T} {O}
    forall {CM-B: clsmap-cxt CM B}
    {B-L: cxt`lookup B N (cxtv/ O T)}
    exists {CM-T: clsmap-ty CM T}
    true.

%theorem cxt-lookup-implies-clsmap-ty/L
  : forall* {B} {BP} {N1} {N2} {T1} {T2} {O1} {O2} {CM} {P}
    forall {FS: cxt`fresh BP N1}
    {U: cxt`update BP N1 (cxtv/ O1 T1) B}
    {CM-T1: clsmap-ty CM T1}
    {CM-BP: clsmap-cxt CM BP}
    {B-L: cxt`lookup B N2 (cxtv/ O2 T2)}
    {E?: nat`eq? N1 N2 P}
    exists {CM-T2: clsmap-ty CM T2}
    true.

- : cxt-lookup-implies-clsmap-ty/L FS U CM-T CM-BP B-L2 nat`eq?/yes CM-T2
    <- cxt`update-implies-lookup U B-L1
    <- cxt`lookup-unique B-L1 B-L2 cxt`eq/ nat`eq/ CV-EQ
    <- cxtv-eq-inversion CV-EQ O-EQ T-EQ
    <- clsmap-ty-respects-eq CM-T clsmap`eq/ T-EQ CM-T2.

- : cxt-lookup-implies-clsmap-ty/L _ U _ CM-BP B-L (nat`eq?/no NE) CM-T2
    <- nat`ne-symmetric NE NE2
    <- cxt`update-preserves-lookup-converse B-L U NE2 BP-L
    <- cxt-lookup-implies-clsmap-ty CM-BP BP-L CM-T2.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons F U CM-T CM-BP) B-L CM-T2
    <- nat`eq?-total EQ?
    <- cxt-lookup-implies-clsmap-ty/L F U CM-T CM-BP B-L EQ? CM-T2.

%worlds (objvar) (cxt-lookup-implies-clsmap-ty _ _ _)
(cxt-lookup-implies-clsmap-ty/L _ _ _ _ _ _ _).
%total (CM-B CM-BP) (cxt-lookup-implies-clsmap-ty CM-B _ _)
(cxt-lookup-implies-clsmap-ty/L _ _ _ CM-BP _ _ _).