%%%%% consistency-thms.elf
%%%%% theorems about consistency between clsmap, fldmap, methmap, and oflist
%%%%% Chao Sun
%%%%% $Id: consistency.thm,v 1.2 2013/03/22 23:08:53 csun Exp $
%%%%% Jun 17, 2010


% theorems about shift

%theorem shift-preserves-clsmap-fldmap :
        forall* {CM} {FM1} {FM2} {N}
        forall  {CM-FM1: clsmap-fldmap CM FM1}
            		{SH: fldmap`shift N FM1 FM2}
        exists  {CM-FM2: clsmap-fldmap CM FM2}
        true.

- : shift-preserves-clsmap-fldmap clsmap-fldmap/0 _ clsmap-fldmap/0.

- : shift-preserves-clsmap-fldmap
     (clsmap-fldmap/null CM-FM1) _ (clsmap-fldmap/null CM-FM1).

- : shift-preserves-clsmap-fldmap 
     (clsmap-fldmap/+ CM-FM1 IN) _ (clsmap-fldmap/+ CM-FM1 IN).

%worlds () (shift-preserves-clsmap-fldmap _ _ _).
%total  {} (shift-preserves-clsmap-fldmap _ _ _).


% This theorem says if under a "bigger" clsmap CM0, CM 
% is well-defined, and class C in CM has fldmap FM, then all
% classes in FM is well-defined under CM0

%theorem lookup-implies-clsmap-fldmap : 
        forall* {M} {CM} {FM} {C}
        forall  {M-CM: clsmap-clsmap M CM}
                {L: clsmap`lookup CM C FM}
        exists  {M-FM: clsmap-fldmap M FM}
        true.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ _ _ M-FM _)
     (clsmap`lookup/= _) M-FM.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ M-CMP SH _ _)
     (clsmap`lookup/> L P0) M-FM
     <- nat`plus-swap-succ P0 P1
     <- nat`plus-commutative P1 P2
     <- clsmap`shift-preserves-lookup* L SH P2 L2
     <- lookup-implies-clsmap-fldmap M-CMP L2 M-FM.

%worlds () (lookup-implies-clsmap-fldmap _ _ _).
%total  (M-CM) (lookup-implies-clsmap-fldmap M-CM _ _).


%theorem lookup-implies-clsmap-ty :
        forall* {CM} {FM} {F} {T}
        forall  {CM-FM: clsmap-fldmap CM FM}
                {FML: fldmap`lookup FM F T}
        exists  {CM-NT : clsmap-ty CM T}
        true.

- : lookup-implies-clsmap-ty (clsmap-fldmap/null _) _ clsmap-ty/null.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM N1-IN) 
     (fldmap`lookup/= _) (clsmap-ty/notnull N1-IN).

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM _) 
     (fldmap`lookup/> LP _) CM-T
     <- lookup-implies-clsmap-ty CM-FM LP CM-T.

- : lookup-implies-clsmap-ty (clsmap-fldmap/null CM-FM)
     (fldmap`lookup/> LP _) CM-T
     <- lookup-implies-clsmap-ty CM-FM LP CM-T.

%worlds () (lookup-implies-clsmap-ty _ _ _).
%total  (CM-FM) (lookup-implies-clsmap-ty CM-FM _ _).


%theorem lookup-implies-clsmap-methty :
        forall* {CM} {MM} {MT} {M}
        forall  {CM-MM: clsmap-methmap CM MM}
                {MM-LP: methmap`lookup MM M MT}
        exists  {CM-MT: clsmap-methty CM MT}
        true.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth _ _ CM-MT _) (methmap`lookup/= _) CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const _ _ (CM-MT) CML) (methmap`lookup/= _) 
     (clsmap-methty/args CM-MT (clsmap-ty/notnull (clsmap`domain?/in CML))).

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth CM-MMP N<<MM=MMP _ _) 
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

%worlds (objvar) (lookup-implies-clsmap-methty _ _ _).
%total  (L) (lookup-implies-clsmap-methty L _ _).


%theorem cxt-lookup-implies-clsmap-ty : 
    forall* {CM} {B: cxt} {T} {O} {VT}
    forall  {CM-B: clsmap-cxt CM B}
            {B-L: cxt-lookup B O VT T}
    exists  {CM-T: clsmap-ty CM T}
    true.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons CM-T _) cxt-lookup/hit CM-T.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons _ CM-B) (cxt-lookup/miss B-L) CM-T
    <- cxt-lookup-implies-clsmap-ty CM-B B-L CM-T.

%worlds (objvar) (cxt-lookup-implies-clsmap-ty _ _ _).
%total (CM-B) (cxt-lookup-implies-clsmap-ty CM-B _ _).


%theorem calltyping-implies-clsmap-ty :
    forall* {CM} {L} {AO} {MT} {T} {XM} {MX}
    forall  {CM-MT: clsmap-methty CM MT}
            {RCTYP: ref-calltyping L CM AO MT (out/expr T XM MX)}
    exists  {CM-T: clsmap-reftype CM T}
    true.

%worlds () (calltyping-implies-clsmap-ty _ _ _).
%trustme %total (CM-MT) (calltyping-implies-clsmap-ty CM-MT _ _).

    
%theorem typing-implies-clsmap-ty :
    forall* {CM} {MM} {B: cxt} {E} {T} {L1} {L2} {XM} {MX}
    forall  {CM-CM: clsmap-clsmap CM CM}
            {CM-MM: clsmap-methmap CM MM}
            {CM-B : clsmap-cxt CM B}
            {TYP: ref-typing L1 CM MM B E (out/expr T XM MX) L2}
    exists  {CM-T: clsmap-reftype CM T}
    true.

%worlds (objvar) (typing-implies-clsmap-ty _ _ _ _ _).
%trustme %total  (TYP) (typing-implies-clsmap-ty _ _ _ TYP _).


%{ A "good out" should have the following properties:
  1, the GM should be leq than XM
  2, either S or GM is NOT empty. }%

good-targets : set -> tgtmap -> type.

good-targets/set : good-targets S _ <- set`size S (s _).

good-targets/tgtmap : good-targets _ GM <- tgtmap`size GM (s _).


good-out : out K -> type.

good-out/expr/null : good-out (out/expr reftype/null _ _).

good-out/expr/shared : good-out (out/expr (reftype/ _ reftgts/shared) _ _).

good-out/expr/unique
  : good-out (out/expr (reftype/ _ (reftgts/unique S GM)) XM _)
    <- good-targets S GM
    <- tgtmap-leq-efxmap GM XM.

good-out/cond : good-out (out/cond _ _).

good-out/args/0 : good-out out/args/0.

good-out/args/+
  : good-out (out/args/+ EO AO)
    <- good-out EO
    <- good-out AO.


%theorem read-type-preserves-good-targets :
    forall* {N} {A} {X} {S} {SP} {GM} {GMP} {XM} {MX}
    forall  {RT: read-type
                 (reftgts/unique S GM) N A X (reftgts/unique SP GMP) XM MX}
            {G-GIN: good-targets S GM}
    exists  {G-GOUT: good-targets SP GMP}
    true.

%theorem nat`ge-succ-implies-succ :
    forall* {N1} {N2}
    forall  {GE: nat`ge N1 (s N2)}
    exists  {N3} {EQ: nat`eq N1 (s N3)}
    true.

- : nat`ge-succ-implies-succ (nat`ge/= EQ) _ EQ.

- : nat`ge-succ-implies-succ (nat`ge/> GT) _ EQ
    <- nat`gt-implies-positive GT _ EQ.

%worlds () (nat`ge-succ-implies-succ _ _ _).
%total  {} (nat`ge-succ-implies-succ _ _ _).


- : read-type-preserves-good-targets 
    (read-type/uu _ GMUGMP=GMS S=>GMP _ _)
    (good-targets/set S-SZ) (good-targets/tgtmap SZ-GMS)
    <- set+nat2tgtmap-implies-domain S=>GMP DM-GMP=S
    <- tgtmap`domain-preserves-size-converse S-SZ DM-GMP=S SZ-GMP
    <- tgtmap`join-implies-leq GMUGMP=GMS _ GMP<=GMS
    <- tgtmap`size-total SZ-GMSP
    <- tgtmap`leq-implies-size-le GMP<=GMS SZ-GMP SZ-GMSP GE
    <- nat`ge-succ-implies-succ GE _ EQ
    <- tgtmap`size-respects-eq SZ-GMSP tgtmap`eq/ EQ SZ-GMS.

- : read-type-preserves-good-targets
    (read-type/uu _ GMUGMP=GMS _ _ _)
    (good-targets/tgtmap SZ-GM) (good-targets/tgtmap SZ-GMS)
    <- tgtmap`join-implies-leq GMUGMP=GMS GM<=GMS _
    <- tgtmap`size-total SZ-GMSP
    <- tgtmap`leq-implies-size-le GM<=GMS SZ-GM SZ-GMSP GE
    <- nat`ge-succ-implies-succ GE _ EQ
    <- tgtmap`size-respects-eq SZ-GMSP tgtmap`eq/ EQ SZ-GMS.

%worlds () (read-type-preserves-good-targets _ _ _).
%total  {} (read-type-preserves-good-targets _ _ _).


%theorem bigger-efxmap-preserves-good-out/expr :
    forall* {RT} {XM1} {XM2} {MX1} {MX2}
    forall  {GO: good-out (out/expr RT XM1 MX1)}
            {XM1<=XM2: efxmap`leq XM1 XM2}
    exists  {GO: good-out (out/expr RT XM2 MX2)}
    true.

- : bigger-efxmap-preserves-good-out/expr 
    good-out/expr/shared _ good-out/expr/shared.

- : bigger-efxmap-preserves-good-out/expr
    (good-out/expr/unique GM<=XM1 G-G) XM1<=XM2
    (good-out/expr/unique GM<=XM2 G-G)
    <- tgtmap-leq-efxmap-right-transitive GM<=XM1 XM1<=XM2 GM<=XM2.

- : bigger-efxmap-preserves-good-out/expr 
    good-out/expr/null _ good-out/expr/null.

%worlds () (bigger-efxmap-preserves-good-out/expr _ _ _).
%total  {} (bigger-efxmap-preserves-good-out/expr _ _ _).


%theorem calltyping-implies-good-out :
    forall* {L} {CM} {AO} {EO} {MT}
    forall  {G-AO: good-out AO}
            {CTYP: ref-calltyping L CM AO MT EO}
    exists  {G-EO: good-out EO}
    true.

- : calltyping-implies-good-out 
    _ ref-calltyping/call/shared good-out/expr/shared.

- : calltyping-implies-good-out
    _ ref-calltyping/call/unique
    (good-out/expr/unique
      (tgtmap-leq-efxmap/ tgtmap`leq/0 efxmap2tgtmap/0)
      (good-targets/set (set`size/+ set`size/0))).

- : calltyping-implies-good-out
    (good-out/args/+ G-AO _)
    (ref-calltyping/args _ XMPURWXM=OXM XMUAXM=XMP _ ATYP) GEOP
    <- calltyping-implies-good-out G-AO ATYP GEO
    <- efxmap`join-implies-leq XMPURWXM=OXM XMP<=OXM _
    <- efxmap`join-implies-leq XMUAXM=XMP _ AXM<=XMP
    <- efxmap`leq-transitive AXM<=XMP XMP<=OXM AXM<=OXM
    <- bigger-efxmap-preserves-good-out/expr GEO AXM<=OXM GEOP.

%worlds () (calltyping-implies-good-out _ _ _).
%total (T)  (calltyping-implies-good-out _ T _).


%theorem typing-implies-good-out : 
    forall* {L1} {L2} {CM} {MM} {B} {K} {E} {O: out K}
    forall  {RTYP: ref-typing L1 CM MM B E O L2} 
    exists  {GO: good-out O}
    true.

- : typing-implies-good-out 
    (ref-typing/lit/unique _)
    (good-out/expr/unique
      (tgtmap-leq-efxmap/ tgtmap`leq/0 efxmap2tgtmap/0)
      (good-targets/set (set`size/+ set`size/0))).

- : typing-implies-good-out
    (ref-typing/lit/shared _) (good-out/expr/shared).

- : typing-implies-good-out
    (ref-typing/read MX1UMX2=MX XM1UXM2=XM
      (read-type/uu GMS=>XM2 GMUGMP=GMS S=>GMP A B) _ _ RTYP) 
    (good-out/expr/unique GMS<=XM G-GP)
    <- typing-implies-good-out RTYP (good-out/expr/unique _ G-G)
    <- tgtmap2efxmap-implies-tgtmap-leq-efxmap GMS=>XM2 GMS<=XM2
    <- efxmap`join-implies-leq XM1UXM2=XM XM1<=XM XM2<=XM
    <- tgtmap-leq-efxmap-right-transitive GMS<=XM2 XM2<=XM GMS<=XM
    <- read-type-preserves-good-targets
      (read-type/uu GMS=>XM2 GMUGMP=GMS S=>GMP A B) G-G G-GP.

- : typing-implies-good-out
    (ref-typing/read _ _ (read-type/us _ _ _ _ _ ) _ _ _) good-out/expr/shared.
    
- : typing-implies-good-out
    (ref-typing/read _ _ read-type/s_ _ _ _) good-out/expr/shared.

- : typing-implies-good-out
    (ref-typing/write _ _ XM4UXM3=XM5 XM1UXM2=XM4 _ _ _ _ RTYP-E2 RTYP-E1)
    GM<=XM5
    <- typing-implies-good-out RTYP-E2 GM<=XM2
    <- efxmap`join-implies-leq XM1UXM2=XM4 XM1<=XM4 XM2<=XM4
    <- efxmap`join-implies-leq XM4UXM3=XM5 XM4<=XM5 XM3<=XM5
    <- efxmap`leq-transitive XM2<=XM4 XM4<=XM5 XM2<=XM5
    <- bigger-efxmap-preserves-good-out/expr GM<=XM2 XM2<=XM5 GM<=XM5.

- : typing-implies-good-out
    (ref-typing/let/shared _ XM1UXM2=XM ([o] RTYP o) _) GM<=XM
      <- ({o} typing-implies-good-out (RTYP o) GM<=XM2)
      <- efxmap`join-implies-leq XM1UXM2=XM _ XM2<=XM
      <- bigger-efxmap-preserves-good-out/expr GM<=XM2 XM2<=XM GM<=XM.

- : typing-implies-good-out
    (ref-typing/let/unique _ XM1UXM2=XM ([o] RTYP o) _) GM<=XM
    <- ({o} typing-implies-good-out (RTYP o) GM<=XM2)
    <- efxmap`join-implies-leq XM1UXM2=XM _ XM2<=XM
    <- bigger-efxmap-preserves-good-out/expr GM<=XM2 XM2<=XM GM<=XM.

- : typing-implies-good-out
    (ref-typing/if _ XM0UXM1=XM2 RTYP-E2 RTYP-E1 RTYP-C) GM<=XM
    <- typing-implies-good-out RTYP-E2 GM<=XM1
    <- efxmap`join-implies-leq XM0UXM1=XM2 _ XM1<=XM
    <- bigger-efxmap-preserves-good-out/expr GM<=XM1 XM1<=XM GM<=XM.

- : typing-implies-good-out
    (ref-typing/call CTYP ATYP _ _) G-EO
    <- typing-implies-good-out ATYP G-AO
    <- calltyping-implies-good-out G-AO CTYP G-EO.

- : typing-implies-good-out  
    (ref-typing/const CTYP ATYP _ _ _) G-EO
    <- typing-implies-good-out ATYP G-AO
    <- calltyping-implies-good-out G-AO CTYP G-EO.

- : typing-implies-good-out (ref-typing/eq _ _ _) good-out/cond.

- : typing-implies-good-out (ref-typing/not _) good-out/cond.

- : typing-implies-good-out (ref-typing/and _ _ _ _) good-out/cond.

- : typing-implies-good-out ref-typing/args/0 good-out/args/0.

- : typing-implies-good-out
    (ref-typing/args/+ ATYP ETYP) (good-out/args/+ G-AO G-EO)
    <- typing-implies-good-out ETYP G-EO 
    <- typing-implies-good-out ATYP G-AO.

- : typing-implies-good-out ref-typing/null good-out/expr/null.

%worlds (objvar) (typing-implies-good-out _ _).
%total (TYP) (typing-implies-good-out TYP _).