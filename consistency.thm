%%%%% consistency-thms.elf
%%%%% theorems about consistency between clsmap, fldmap, methmap, and oflist


% =========================================================================
% =========================== XX-respects-eq ==============================
% =========================================================================

%theorem clsmap-ty-respects-eq
  : forall* {CM1} {CM2} {T1} {T2}
    forall {CM1-T1: clsmap-ty CM1 T1}
    {E: clsmap`eq CM1 CM2} {E: ty`eq T1 T2}
    exists {CM2-T2: clsmap-ty CM2 T2}
    true.

- : clsmap-ty-respects-eq D clsmap`eq/ ty`eq/ D.

%worlds () (clsmap-ty-respects-eq _ _ _ _).
%total {} (clsmap-ty-respects-eq _ _ _ _).


% =========================================================================
% ============================ XX-respects-leq ============================
% =========================================================================

%theorem clsmap-ty-respects-leq
  : forall* {CM0} {CM1} {T}
    forall {CM0-T: clsmap-ty CM0 T}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-T: clsmap-ty CM1 T}
    true.

- : clsmap-ty-respects-leq (clsmap-ty/notnull L0)
    CM0<=CM1 (clsmap-ty/notnull L1)
    <- clsmap`lookup-respects-leq L0 CM0<=CM1 _ L1 _.

- : clsmap-ty-respects-leq clsmap-ty/null _ clsmap-ty/null.

%worlds () (clsmap-ty-respects-leq _ _ _).
%total {} (clsmap-ty-respects-leq _ _ _).


%theorem clsmap-fldmap-respects-leq
  : forall* {CM0} {CM1} {FM}
    forall {CM0-FM: clsmap-fldmap CM0 FM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-FM: clsmap-fldmap CM1 FM}
    true.

- : clsmap-fldmap-respects-leq clsmap-fldmap/0 _ clsmap-fldmap/0.

- : clsmap-fldmap-respects-leq (clsmap-fldmap/+ CM0-FM CM0-T)
    CM0<=CM1 (clsmap-fldmap/+ CM1-FM CM1-T)
    <- clsmap-ty-respects-leq CM0-T CM0<=CM1 CM1-T
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM.

%worlds () (clsmap-fldmap-respects-leq _ _ _).
%total (CM-FM) (clsmap-fldmap-respects-leq CM-FM _ _).


%theorem clsmap-clsmap-respects-leq
  : forall* {CM0} {CM1} {CM}
    forall {CM0-CM: clsmap-clsmap CM0 CM}
    {CM0<=CM1: clsmap`leq CM0 CM1}
    exists {CM1-CM: clsmap-clsmap CM1 CM}
    true.

- : clsmap-clsmap-respects-leq clsmap-clsmap/0 _ clsmap-clsmap/0.

- : clsmap-clsmap-respects-leq (clsmap-clsmap/+ CM0-CMS SH CM0-FM CM0-L)
    CM0<=CM1 (clsmap-clsmap/+ CM1-CMS SH CM1-FM CM1-L)
    <- clsmap`lookup-respects-leq CM0-L CM0<=CM1 _ CM1-LP EQ
    <- fldmap`eq-symmetric EQ EQP
    <- clsmap`lookup-respects-eq CM1-LP clsmap`eq/ nat`eq/ EQP CM1-L
    <- clsmap-fldmap-respects-leq CM0-FM CM0<=CM1 CM1-FM
    <- clsmap-clsmap-respects-leq CM0-CMS CM0<=CM1 CM1-CMS.

%worlds () (clsmap-clsmap-respects-leq _ _ _).
%total (CM-CM) (clsmap-clsmap-respects-leq CM-CM _ _).



% =========================================================================
% ============================ leq-preserves-XX ===========================
% =========================================================================


% =========================================================================
% ============================ shift-preserves-XX =========================
% =========================================================================

%theorem shift-preserves-clsmap-fldmap
  : forall* {CM} {FM} {FMP} {N}
    forall {CM-FM: clsmap-fldmap CM FM}
    {SH: fldmap`shift N FM FMP}
    exists {CM-FM: clsmap-fldmap CM FMP}
    true.

- : shift-preserves-clsmap-fldmap clsmap-fldmap/0 _ clsmap-fldmap/0.

- : shift-preserves-clsmap-fldmap
    (clsmap-fldmap/+ CM-FM CM-T) SH (clsmap-fldmap/+ CM-FM CM-T).

%worlds () (shift-preserves-clsmap-fldmap _ _ _).
%total {} (shift-preserves-clsmap-fldmap _ _ _).



% =========================================================================
% ============================ lookup-implies-XX ==========================
% =========================================================================

% This theorem says if under a "bigger" clsmap CM0, CM
% is well-defined, and class C in CM has fldmap FM, then all
% classes in FM is well-defined under CM0

%theorem lookup-implies-clsmap-fldmap
  : forall* {M} {CM} {FM} {C}
    forall {M-CM: clsmap-clsmap M CM}
    {L: clsmap`lookup CM C FM}
    exists {M-FM: clsmap-fldmap M FM}
    true.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ _ _ M-FM _)
     (clsmap`lookup/= _) M-FM.

- : lookup-implies-clsmap-fldmap (clsmap-clsmap/+ M-CMP SH _ _)
     (clsmap`lookup/> L P0) M-FM
     <- nat`plus-swap-succ P0 P1
     <- nat`plus-commutative P1 P2
     <- clsmap`shift-preserves-lookup* L SH P2 L2
     <- lookup-implies-clsmap-fldmap M-CMP L2 M-FM.

%worlds () (lookup-implies-clsmap-fldmap _ _ _).
%total (M-CM) (lookup-implies-clsmap-fldmap M-CM _ _).


%theorem lookup-implies-clsmap-ty
  : forall* {CM} {FM} {F} {T}
    forall {CM-FM: clsmap-fldmap CM FM}
    {FM-L: fldmap`lookup FM F T}
    exists {CM-NT: clsmap-ty CM T}
    true.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM CM-T)
    (fldmap`lookup/= _) CM-T.

- : lookup-implies-clsmap-ty (clsmap-fldmap/+ CM-FM _)
    (fldmap`lookup/> LP _) CM-T
    <- lookup-implies-clsmap-ty CM-FM LP CM-T.

%worlds () (lookup-implies-clsmap-ty _ _ _).
%total (CM-FM) (lookup-implies-clsmap-ty CM-FM _ _).


%theorem lookup-implies-clsmap-methty
  : forall* {CM} {MM} {MT} {M}
    forall {CM-MM: clsmap-methmap CM MM}
    {MM-LP: methmap`lookup MM M MT}
    exists {CM-MT: clsmap-methty CM MT}
    true.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth _ _ CM-MT _) (methmap`lookup/= _) CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const _ _ (CM-MT) CML) (methmap`lookup/= _)
     (clsmap-methty/args CM-MT (clsmap-ty/notnull CML)).

- : lookup-implies-clsmap-methty
     (clsmap-methmap/meth CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

- : lookup-implies-clsmap-methty
     (clsmap-methmap/const CM-MMP N<<MM=MMP _ _)
     (methmap`lookup/> MML P1) CM-MT
     <- nat`plus-swap-succ P1 P2
     <- nat`plus-commutative P2 P3
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P3 MMPL
     <- lookup-implies-clsmap-methty CM-MMP MMPL CM-MT.

%worlds (objvar) (lookup-implies-clsmap-methty _ _ _).
%total (L) (lookup-implies-clsmap-methty L _ _).


%theorem cxt-lookup-implies-clsmap-ty
  : forall* {CM} {B} {T} {O}
    forall {CM-B: clsmap-cxt CM B}
    {B-L: cxt`lookup B O T}
    exists {CM-T: clsmap-ty CM T}
    true.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons/s _ CM-T) cxt`lookup/hit CM-T.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons/b _ CM-T) cxt`lookup/hit CM-T.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons/s CM-B _) (cxt`lookup/miss B-L _) CM-T
    <- cxt-lookup-implies-clsmap-ty CM-B B-L CM-T.

- : cxt-lookup-implies-clsmap-ty
    (clsmap-cxt/cons/b CM-B _) (cxt`lookup/miss B-L _) CM-T
    <- cxt-lookup-implies-clsmap-ty CM-B B-L CM-T.

%worlds () (cxt-lookup-implies-clsmap-ty _ _ _).
%total (CM-B) (cxt-lookup-implies-clsmap-ty CM-B _ _).


% =========================================================================
% ================= THEOREMS ABOUT RESULT CONSISTENCY =====================
% =========================================================================

% First, a few theorems about the relations we defined earlier.

%theorem clsmap-cxt-tgtmap-respects-eq
  : forall* {B1} {B2} {CM1} {CM2} {XM1} {XM2}
    forall {B1-XM1: clsmap-cxt-tgtmap CM1 B1 XM1}
    {EQ: cxt`eq B1 B2} {EQ: clsmap`eq CM1 CM2} {EQ: tgtmap`eq XM1 XM2}
    exists {B2-XM2: clsmap-cxt-tgtmap CM2 B2 XM2}
    true.

- : clsmap-cxt-tgtmap-respects-eq B-XM cxt`eq/ clsmap`eq/ tgtmap`eq/ B-XM.

%worlds () (clsmap-cxt-tgtmap-respects-eq _ _ _ _ _).
%total {} (clsmap-cxt-tgtmap-respects-eq _ _ _ _ _).


%theorem same-class-respects-eq
  : forall* {B} {BP} {S} {SP} {C} {CP}
    forall {SOC: same-class B S C}
    {E: cxt`eq B BP} {E: set`eq S SP}
    {E: nat`eq C CP}
    exists {SOC: same-class BP SP CP}
    true.

- : same-class-respects-eq SOC cxt`eq/ set`eq/ nat`eq/ SOC.

%worlds () (same-class-respects-eq _ _ _ _ _).
%total {} (same-class-respects-eq _ _ _ _ _).


%theorem same-class/U-inversion
  : forall* {B} {S} {SP} {C} {N}
    forall {SOC: same-class B S C}
    {NM: set`not-member SP N}
    {AD: set`add SP N S}
    exists {NN} {A} {SOC: same-class B SP C}
    {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    true.

%theorem same-class/U-inversion/L
  : forall* {B} {S} {SP1} {C} {N1} {A1} {NN1} {SP} {N} {P}
    forall {SOC: same-class B SP1 C}
    {NM1: set`not-member SP1 N1}
    {AD1: set`add SP1 N1 S}
    {BL1: cxt`lookup B (object/ N1) (ty/ NN1 A1 C)}
    {NM: set`not-member SP N}
    {AD: set`add SP N S}
    {EQ?: nat`eq? N N1 P}
    exists {NN} {A} {SOC: same-class B SP C}
    {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    true.

- : same-class/U-inversion/L
    SOC0 F0 U0 BL0 F1 U1 nat`eq?/yes _ _ SOC1 BL0
    <- set`not-member-add-cancels F0 U0 F1 U1 nat`eq/ set`eq/ S0=S1
    <- same-class-respects-eq SOC0 cxt`eq/ S0=S1 nat`eq/ SOC1.

- : same-class/U-inversion/L
    SOC0 F0 U0 BL0 F1 U1 (nat`eq?/no N<>N1) _ _ 
    (same-class/U BL0 U3 F3 SOC2) BL2
    <- set`update-commutes-converse U1 U0 N<>N1 _ U3 U2
    <- set`add-preserves-not-member-converse F1 U3 F2
    <- set`add-preserves-not-member-converse F0 U2 F3
    <- same-class/U-inversion SOC0 F2 U2 _ _ SOC2 BL2.

- : same-class/U-inversion
    (same-class/U BL0 A0 F0 SOC0) F1 A1 _ _ SOC1 BL1
    <- nat`eq?-total E?
    <- same-class/U-inversion/L SOC0 F0 A0 BL0 F1 A1 E? _ _ SOC1 BL1.

%worlds () (same-class/U-inversion _ _ _ _ _ _ _)
(same-class/U-inversion/L _ _ _ _ _ _ _ _ _ _ _).
%total (C0 C1) (same-class/U-inversion C0 _ _ _ _ _ _)
(same-class/U-inversion/L C1 _ _ _ _ _ _ _ _ _ _).


% ============================ LEQ-PRESERVES-XX ===========================
% =========================================================================

%theorem leq-preserves-clsmap-cxt-tgtmap
  : forall* {XM} {XMP} {CM} {B}
    forall {B-XMP: clsmap-cxt-tgtmap CM B XMP}
    {XM1<=XM2: tgtmap`leq XM XMP}
    exists {B-XM: clsmap-cxt-tgtmap CM B XM}
    true.

- : leq-preserves-clsmap-cxt-tgtmap
    clsmap-cxt-tgtmap/0 tgtmap`leq/0 clsmap-cxt-tgtmap/0.

%theorem leq-preserves-clsmap-cxt-tgtmap/U
  : forall* {CM} {FM} {XM} {XMS} {XMP} {N} {B}
    {NN} {A} {C} {S} {FS}
    forall {P} {IN?: tgtmap`domain? XM N P}
    {F: tgtmap`fresh XMS N}
    {U: tgtmap`update XMS N S XMP}
    {B-L: cxt`lookup B (object/ N) (ty/ NN A C)}
    {CM-L: clsmap`lookup CM C FM}
    {DM-FM: fldmap`domain FM FS}
    {LE: set`leq S FS} {CM-B-XMS: clsmap-cxt-tgtmap CM B XMS}
    {XM<=XMP: tgtmap`leq XM XMP}
    exists {CM-B-XM: clsmap-cxt-tgtmap CM B XM}
    true.

- : leq-preserves-clsmap-cxt-tgtmap/U true (tgtmap`domain?/in XM->N=M)
    N!<XMS XMS+N+MP=XMP B->N=C CM->C=FM DM-FM=FS MPS<=FS
    CM-B-XMS XM<=XMP
    (clsmap-cxt-tgtmap/U MS<=FS DM-FM=FS CM->C=FM B->N=C XMT+N+M=XM N!<XMT CM-B-XMT)
    <- tgtmap`lookup-implies-fresh-update XM->N=M XMT N!<XMT XMT+N+M=XM
    <- tgtmap`fresh-update-preserves-leq-converse
      XM<=XMP N!<XMT XMT+N+M=XM N!<XMS XMS+N+MP=XMP XMT<=XMS M<=MP
    <- leq-preserves-clsmap-cxt-tgtmap CM-B-XMS XMT<=XMS CM-B-XMT
    <- set`leq-transitive M<=MP MPS<=FS MS<=FS.

- : leq-preserves-clsmap-cxt-tgtmap/U false (tgtmap`domain?/out N!<XM)
    N!<XMS XMS+N+MP=XMP B->N=C CM->C=FM DM-FM=FS MPS<=FS
    CM-B-XMS XM<=XMP CM-B-XM
    <- tgtmap`fresh-update2-preserves-leq-converse
      XM<=XMP N!<XM N!<XMS XMS+N+MP=XMP XM<=XMS
    <- leq-preserves-clsmap-cxt-tgtmap CM-B-XMS XM<=XMS CM-B-XM.

- : leq-preserves-clsmap-cxt-tgtmap
    (clsmap-cxt-tgtmap/U MS<=FS DM-FM=FS CM->C=FM B->N=C
      XMS+N+M=XMP N!<XMS CM-B-XMS) XM<=XMP CM-B-XM
    <- tgtmap`domain?-total N-in-XM?
    <- leq-preserves-clsmap-cxt-tgtmap/U _ N-in-XM?
      N!<XMS XMS+N+M=XMP B->N=C CM->C=FM DM-FM=FS
      MS<=FS CM-B-XMS XM<=XMP CM-B-XM.

%worlds (objvar | fracvar) (leq-preserves-clsmap-cxt-tgtmap _ _ _)
(leq-preserves-clsmap-cxt-tgtmap/U _ _ _ _ _ _ _ _ _ _ _).
%total (L1 L2) (leq-preserves-clsmap-cxt-tgtmap L1 _ _)
(leq-preserves-clsmap-cxt-tgtmap/U _ _ _ _ _ _ _ _ L2 _ _).


%theorem leq-preserves-clsmap-cxt-efxmap
  : forall* {XM} {XMP} {CM} {B}
    forall {B-XMP: clsmap-cxt-efxmap CM B XMP}
    {XM1<=XM2: efxmap`leq XM XMP}
    exists {B-XM: clsmap-cxt-efxmap CM B XM}
    true.

- : leq-preserves-clsmap-cxt-efxmap
    clsmap-cxt-efxmap/0 efxmap`leq/0 clsmap-cxt-efxmap/0.

%worlds (objvar | fracvar) (leq-preserves-clsmap-cxt-efxmap _ _ _).
%trustme %total {} (leq-preserves-clsmap-cxt-efxmap L1 _ _).


%theorem leq-preserves-clsmap-cxt-effects
  : forall* {XX} {XX'} {CM} {B}
    forall {CM-B-XX: clsmap-cxt-effects CM B XX'}
    {LE: effects`leq XX XX'}
    exists {CM-B-XX: clsmap-cxt-effects CM B XX}
    true.

%worlds (objvar | fracvar) (leq-preserves-clsmap-cxt-effects _ _ _).
%trustme %total {} (leq-preserves-clsmap-cxt-effects _ _ _).


% we need to change targets-effects - not only tgtmap should
% be less-equal than the efxmap, but also the sub-efxmap it maps
% to should be no-consume.

%theorem leq-preserves-targets-effects
  : forall* {GS} {XX} {XX1}
    forall {C: targets-effects GS XX}
    {J: effects`leq XX XX1}
    exists {C: targets-effects GS XX1}
    true.

%worlds () (leq-preserves-targets-effects _ _ _).
%trustme %total {} (leq-preserves-targets-effects _ _ _).


% ============================ JOIN-PRESERVES-XX ==========================
% =========================================================================

%theorem join-preserves-clsmap-cxt-tgtmap
  : forall* {CM} {B} {G1} {G2} {G}
    forall {CM-B-G1: clsmap-cxt-tgtmap CM B G1}
    {CM-B-G2: clsmap-cxt-tgtmap CM B G2}
    {J: tgtmap`join G1 G2 G}
    exists {CM-B-G: clsmap-cxt-tgtmap CM B G}
    true.

%worlds () (join-preserves-clsmap-cxt-tgtmap _ _ _ _).
%trustme %total {} (join-preserves-clsmap-cxt-tgtmap _ _ _ _).


%theorem join-preserves-clsmap-cxt-efxmap
  : forall* {CM} {B} {M1} {M2} {M}
    forall {CM-B-M1: clsmap-cxt-efxmap CM B M1}
    {CM-B-M2: clsmap-cxt-efxmap CM B M2}
    {J: efxmap`join M1 M2 M}
    exists {CM-B-M: clsmap-cxt-efxmap CM B M}
    true.

%worlds () (join-preserves-clsmap-cxt-efxmap _ _ _ _).
%trustme %total {} (join-preserves-clsmap-cxt-efxmap _ _ _ _).


%theorem join-preserves-clsmap-cxt-effects
  : forall* {CM} {B} {XX1} {XX2} {XX}
    forall {C1: clsmap-cxt-effects CM B XX1}
    {C2: clsmap-cxt-effects CM B XX2}
    {J: effects`join XX1 XX2 XX}
    exists {C: clsmap-cxt-effects CM B XX}
    true.

%worlds () (join-preserves-clsmap-cxt-effects _ _ _ _).
%trustme %total {} (join-preserves-clsmap-cxt-effects _ _ _ _).


%theorem join-preserves-cxt-set
  : forall* {B} {S1} {S2} {S}
    forall {B-S1: cxt-set B S1}
    {B-S2: cxt-set B S2}
    {U: set`union S1 S2 S}
    exists {B-S: cxt-set B S}
    true.

%worlds () (join-preserves-cxt-set _ _ _ _).
%trustme %total {} (join-preserves-cxt-set _ _ _ _).


% Some "constructive" theorems.
% =========================================================================

%theorem set+nat2tgtmap-implies-clsmap-cxt-tgtmap
  : forall* {CM} {B} {S} {F} {G} {C} {FM} {T}
    forall {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    {SOC: same-class B S C}
    {S+F=>G: set+nat2tgtmap S F G}
    exists {CM-B-G: clsmap-cxt-tgtmap CM B G}
    true.

- : set+nat2tgtmap-implies-clsmap-cxt-tgtmap
    _ _ same-class/0 set+nat2tgtmap/0 clsmap-cxt-tgtmap/0.

- : set+nat2tgtmap-implies-clsmap-cxt-tgtmap CML FML
    (same-class/U BL A NM S-SP) S=>G
    (clsmap-cxt-tgtmap/U LE DM CML BL U F CM-B-GP)
    <- set+nat2tgtmap/U-inversion S=>G NM A _ SP=>GP U
    <- set+nat2tgtmap-implies-clsmap-cxt-tgtmap CML FML S-SP SP=>GP CM-B-GP
    <- fldmap`domain-total DM
    <- fldmap`domain-preserves-lookup FML DM SL
    <- set`member-implies-unit-leq SL LE
    <- set+nat2tgtmap-preserves-fresh SP=>GP NM F.

%worlds () (set+nat2tgtmap-implies-clsmap-cxt-tgtmap _ _ _ _ _).
%total (T) (set+nat2tgtmap-implies-clsmap-cxt-tgtmap _ _ T _ _).


%theorem set+set2tgtmap-implies-clsmap-cxt-tgtmap
  : forall* {CM} {B} {S} {R} {G} {C} {FM} {FS}
    forall {SOC: same-class B S C}
    {S+S=>G: set+set2tgtmap S R G}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS}
    {LE: set`leq R FS}
    exists {CM-B-G: clsmap-cxt-tgtmap CM B G}
    true.

- : set+set2tgtmap-implies-clsmap-cxt-tgtmap
    _ set+set2tgtmap/0 _ _ _ clsmap-cxt-tgtmap/0.

- : set+set2tgtmap-implies-clsmap-cxt-tgtmap
    SOC (set+set2tgtmap/U N!<SP SP+N=S SP+R=>GP GP+N+R=>G)
    CML DM-FM=FS R<=FS
    (clsmap-cxt-tgtmap/U R<=FS DM-FM=FS CML BL GP+N+R=>G N!<GP CM-B-GP)
    <- same-class/U-inversion SOC N!<SP SP+N=S _ _ SOC1 BL
    <- set+set2tgtmap-preserves-fresh SP+R=>GP N!<SP N!<GP
    <- set+set2tgtmap-implies-clsmap-cxt-tgtmap
      SOC1 SP+R=>GP CML DM-FM=FS R<=FS CM-B-GP.

%worlds () (set+set2tgtmap-implies-clsmap-cxt-tgtmap _ _ _ _ _ _ ).
%total (S) (set+set2tgtmap-implies-clsmap-cxt-tgtmap _ S _ _ _ _ ).


%theorem clsmap-cxt-effects-implies-effects-wf
  : forall* {CM} {B} {XX}
    forall {CM-B-XX: clsmap-cxt-effects CM B XX}
    exists {WF-XX: effects`wf XX}
    true.

- : clsmap-cxt-effects-implies-effects-wf
    (clsmap-cxt-effects/ _ _ X DM) (effects`wf/ X DM).

%worlds () (clsmap-cxt-effects-implies-effects-wf _ _).
%total {} (clsmap-cxt-effects-implies-effects-wf _ _).
 

%theorem tgtmap2efxmap-preserves-consistency
  : forall* {CM} {B} {G} {X} {M}
    forall {G2M: tgtmap2efxmap G X M}
    {CM-B-G: clsmap-cxt-tgtmap CM B G}
    exists {CM-B-M: clsmap-cxt-efxmap CM B M}
    true.

- : tgtmap2efxmap-preserves-consistency
    tgtmap2efxmap/0 clsmap-cxt-tgtmap/0 clsmap-cxt-efxmap/0.

- : tgtmap2efxmap-preserves-consistency
    G=>M (clsmap-cxt-tgtmap/U LE DM CML BL U F CM-B-GP)
    (clsmap-cxt-efxmap/U LE SDM DM CML BL U2 F2 CM-B-MP)
    <- tgtmap2efxmap/U-inversion G=>M F U _ _ GP=>MP S=>D U2
    <- tgtmap2efxmap-preserves-fresh F GP=>MP F2
    <- tgtmap2efxmap-preserves-consistency GP=>MP CM-B-GP CM-B-MP
    <- set2inner-efxmap-implies-domain S=>D SDM.

%worlds () (tgtmap2efxmap-preserves-consistency _ _ _).
%total (A) (tgtmap2efxmap-preserves-consistency _ A _).


%theorem create-shared-efx-not-none
  : forall* {SX} {X}
    forall {CX: create-shared-efx X SX}
    exists {SN: shared-efx-not-none SX}
    true.

- : create-shared-efx-not-none create-shared-efx/read shared-efx-not-none/read.

- : create-shared-efx-not-none create-shared-efx/write shared-efx-not-none/write.

%worlds () (create-shared-efx-not-none _ _).
%total {} (create-shared-efx-not-none _ _).


%theorem create-shared-efx-requires-not-consume
  : forall* {SX} {X}
    forall {CX: create-shared-efx X SX}
    exists {NC-X: efx`not-consume X}
    true.

- : create-shared-efx-requires-not-consume create-shared-efx/read efx`not-consume/read.

- : create-shared-efx-requires-not-consume create-shared-efx/write efx`not-consume/write.

%worlds () (create-shared-efx-requires-not-consume _ _).
%total {} (create-shared-efx-requires-not-consume _ _). 


%theorem shared-efx-not-none-implies-shared-efx2efx
  : forall* {SX}
    forall {NN: shared-efx-not-none SX}
    exists {X} {SX2X: shared-efx2efx SX X} {NC-X: efx`not-consume X}
    true.

- : shared-efx-not-none-implies-shared-efx2efx
    shared-efx-not-none/read efx/read shared-efx2efx/read efx`not-consume/read.

- : shared-efx-not-none-implies-shared-efx2efx
    shared-efx-not-none/write efx/write shared-efx2efx/write efx`not-consume/write.

%worlds () (shared-efx-not-none-implies-shared-efx2efx _ _ _ _).
%total {} (shared-efx-not-none-implies-shared-efx2efx _ _ _ _).

 
%theorem efx-on-shared-implies-shared-efx-relation
  : forall* {B} {SX} {SX'}
    forall {NN: shared-efx-not-none SX} {EOS: efx-on-shared B SX SX'}
    exists {B-SX: shared-efx-relation B SX'}
    true.

- : efx-on-shared-implies-shared-efx-relation NN efx-on-shared/true
    (shared-efx-relation/t NN).

- : efx-on-shared-implies-shared-efx-relation _ efx-on-shared/false
    shared-efx-relation/f.

%worlds () (efx-on-shared-implies-shared-efx-relation _ _ _).
%total {} (efx-on-shared-implies-shared-efx-relation _ _ _).
 
 
%theorem make-targets-and-effects-consistent
  : forall* {CM} {B} {GS} {A} {X} {GSP} {XX} {F} {C} {FM} {NN} {FC}
    forall {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {CM-B-GS: clsmap-cxt-targets CM B C GS}
    {MG: make-targets-and-effects GS A F X GSP XX}
    exists {CM-B-GSP: clsmap-cxt-targets CM B FC GSP}
    {CM-B-M: clsmap-cxt-effects CM B XX}
    {GS-XX: targets-effects GSP XX}
    true.

- : make-targets-and-effects-consistent
    _ _ clsmap-cxt-targets/shared
    (make-targets-and-effects/shared consider-ftype/shared _)
    clsmap-cxt-targets/shared
    (clsmap-cxt-effects/ clsmap-cxt-efxmap/0 cxt-set/0 set`disjoint/R efxmap`domain/0)
    (targets-effects/shared).

- : make-targets-and-effects-consistent
    _ _ clsmap-cxt-targets/shared
    (make-targets-and-effects/shared consider-ftype/unique CX)
    (clsmap-cxt-targets/unique clsmap-cxt-tgtmap/0 same-class/0
      cxt-set/0 set`disjoint/L tgtmap`domain/0)
    (clsmap-cxt-effects/ clsmap-cxt-efxmap/0 cxt-set/0 set`disjoint/R efxmap`domain/0)
    (targets-effects/unique (shared-efx-relation/t SN) efxmap`no-consume/0 select-tgtmap/0
      (tgtmap`leq-efxmap/ tgtmap`leq/0 efxmap2tgtmap/0))
    <- create-shared-efx-not-none CX SN.

- : make-targets-and-effects-consistent
    CML FML (clsmap-cxt-targets/unique CM-B-G1 SOC _ _ _)
    (make-targets-and-effects/unique
      S=>G2 G1^G2 G1+G2=G G=>M _ _ consider-ftype/shared)
    clsmap-cxt-targets/shared
    (clsmap-cxt-effects/ CM-B-M cxt-set/0 set`disjoint/R DM)
    (targets-effects/shared)
    <- set+nat2tgtmap-implies-clsmap-cxt-tgtmap CML FML SOC S=>G2 CM-B-G2
    <- join-preserves-clsmap-cxt-tgtmap CM-B-G1 CM-B-G2 G1+G2=G CM-B-G
    <- tgtmap2efxmap-preserves-consistency G=>M CM-B-G CM-B-M
    <- tgtmap`join-implies-leq G1+G2=G G1<=G _
    <- tgtmap2efxmap-implies-leq-efxmap G=>M G<=M
    <- tgtmap`leq-efxmap-left-transitive G1<=G G<=M G1<=M
    <- efxmap`domain-total DM.

- : make-targets-and-effects-consistent
    CML FML (clsmap-cxt-targets/unique CM-B-G1 SOC _ _ _)
    (make-targets-and-effects/unique
      S=>G2 G1^G2 G1+G2=G G=>M CSE EOS consider-ftype/unique)
    (clsmap-cxt-targets/unique CM-B-G same-class/0 cxt-set/0 set`disjoint/L DM')
    (clsmap-cxt-effects/ CM-B-M cxt-set/0 set`disjoint/R DM)
    (targets-effects/unique B-SX NC-M' SG G<=M)
    <- create-shared-efx-not-none CSE NN
    <- efx-on-shared-implies-shared-efx-relation NN EOS B-SX
    <- set+nat2tgtmap-implies-clsmap-cxt-tgtmap CML FML SOC S=>G2 CM-B-G2
    <- join-preserves-clsmap-cxt-tgtmap CM-B-G1 CM-B-G2 G1+G2=G CM-B-G
    <- tgtmap2efxmap-preserves-consistency G=>M CM-B-G CM-B-M
    <- tgtmap2efxmap-implies-leq-efxmap G=>M G<=M
    <- create-shared-efx-requires-not-consume CSE NC-X
    <- tgtmap2efxmap-no-consume NC-X G=>M NC-M
    <- select-tgtmap-total SG
    <- select-tgtmap-implies-leq SG _ LE
    <- efxmap`no-consume-respects-geq NC-M LE NC-M'
    <- efxmap`domain-total DM
    <- tgtmap`domain-total DM'.

%worlds () (make-targets-and-effects-consistent _ _ _ _ _ _ _).
%total {} (make-targets-and-effects-consistent _ _ _ _ _ _ _).


%theorem subtyping-consistent
  : forall* {CM} {B} {NN1} {C1} {GS} {NN2} {A2} {C2} {S1} {S2} {XX}
    forall {CM-B-GS: clsmap-cxt-targets CM B C1 GS}
    {STYP: subtype CM (reftype/ NN1 C1 GS) (ty/ NN2 A2 C2) S1 S2 XX}
    exists {CM-B-XX: clsmap-cxt-effects CM B XX}
    true.

- : subtyping-consistent (clsmap-cxt-targets/unique CM-B-G SOC B-S S^Gs DM-G=Gs)
    (subtype/ (sub-annot/unique2shared G=>M) _ _ _ _ nat`eq/)
    (clsmap-cxt-effects/ CM-B-M B-S Gs^S DM-M=Gs)
    <- tgtmap2efxmap-preserves-consistency G=>M CM-B-G CM-B-M
    <- tgtmap2efxmap-preserves-domain DM-G=Gs G=>M DM-M=Gs
    <- set`disjoint-symmetric S^Gs Gs^S.

- : subtyping-consistent (clsmap-cxt-targets/unique CM-B-G SOC B-S S^Gs DM-G=Gs)
    (subtype/
      (sub-annot/unique2borrow
        B+SX1=SX S1+S2=SX1 M1+M2=M G2x=>M2 G1x=>M1
        G+G2=G2x G+G1=G1x S+WS=>G2 S+RS=>G1) (WS<=FS:set`leq WS FS)
      (RS<=FS:set`leq RS FS) DM CML nat`eq/)
    (clsmap-cxt-effects/ CM-B-M cxt-set/0 set`disjoint/R DM-M=Ms)
    <- set+set2tgtmap-implies-clsmap-cxt-tgtmap SOC S+RS=>G1 CML DM RS<=FS CM-B-G1
    <- set+set2tgtmap-implies-clsmap-cxt-tgtmap SOC S+WS=>G2 CML DM WS<=FS CM-B-G2
    <- join-preserves-clsmap-cxt-tgtmap CM-B-G CM-B-G1 G+G1=G1x CM-B-G1x 
    <- join-preserves-clsmap-cxt-tgtmap CM-B-G CM-B-G2 G+G2=G2x CM-B-G2x
    <- tgtmap2efxmap-preserves-consistency G1x=>M1 CM-B-G1x CM-B-M1
    <- tgtmap2efxmap-preserves-consistency G2x=>M2 CM-B-G2x CM-B-M2
    <- join-preserves-clsmap-cxt-efxmap CM-B-M1 CM-B-M2 M1+M2=M CM-B-M
    <- efxmap`domain-total DM-M=Ms.

- : subtyping-consistent (clsmap-cxt-targets/unique CM-B-G SOC B-S S^Gs DM-G=Gs)
    (subtype/ (sub-annot/unique2unique G=>M) WS<=FS RS<=FS
      DM CML nat`eq/) (clsmap-cxt-effects/ CM-B-M B-S Gs^S DM-M=Gs)
    <- tgtmap2efxmap-preserves-consistency G=>M CM-B-G CM-B-M
    <- tgtmap2efxmap-preserves-domain DM-G=Gs G=>M DM-M=Gs
    <- set`disjoint-symmetric S^Gs Gs^S.

- : subtyping-consistent clsmap-cxt-targets/shared
    (subtype/ (sub-annot/shared2borrow _) _ _ _ _ _)
    (clsmap-cxt-effects/ clsmap-cxt-efxmap/0 cxt-set/0 set`disjoint/R efxmap`domain/0).

- : subtyping-consistent clsmap-cxt-targets/shared
    (subtype/ sub-annot/shared2shared _ _ _ _ _)
    (clsmap-cxt-effects/ clsmap-cxt-efxmap/0 cxt-set/0 set`disjoint/R efxmap`domain/0).

%worlds () (subtyping-consistent _ _ _).
%total {} (subtyping-consistent _ _ _).


% =========================================================================
% This theorem says if a term in our language can be type checked, then
% the resultput (especially for unique resultput) must be in a good format.
% =========================================================================

%theorem reftyping-implies-good-result
  : forall* {CM} {MM} {B} {E: expr} {Rslt}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-B: clsmap-cxt CM B}
    {TYP: reftyping CM MM B E Rslt}
    exists {G-Rslt: good-result CM B Rslt}
    true.

- : reftyping-implies-good-result _ CM-B
    (reftyping/lit ty2reftype/shared _ BL)
    (good-result/expr targets-effects/shared
      (clsmap-cxt-effects/ clsmap-cxt-efxmap/0 cxt-set/0
        set`disjoint/R efxmap`domain/0)
      (clsmap-cxt-targets/shared) CML)
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/notnull CML).

- : reftyping-implies-good-result _ CM-B
    (reftyping/lit ty2reftype/borrow _ BL)
    (good-result/expr
      (targets-effects/unique shared-efx-relation/f efxmap`no-consume/0 select-tgtmap/0
        (tgtmap`leq-efxmap/ tgtmap`leq/0 efxmap2tgtmap/0))
      (clsmap-cxt-effects/ clsmap-cxt-efxmap/0 cxt-set/0
        set`disjoint/R efxmap`domain/0)
      (clsmap-cxt-targets/unique clsmap-cxt-tgtmap/0
        (same-class/U BL set`update/0 set`not-member/0 same-class/0)
        (cxt-set/U cxt-set/0 BL set`update/0 set`not-member/0)
        set`disjoint/R tgtmap`domain/0) CML)
    <- cxt-lookup-implies-clsmap-ty CM-B BL (clsmap-ty/notnull CML).

- : reftyping-implies-good-result CM-CM CM-B
    (reftyping/read TYP-E CML FML MG XJ) (good-result/expr GSP-XX CM-B-XX CM-B-GSP CML2)
    <- reftyping-implies-good-result CM-CM CM-B TYP-E
      (good-result/expr G-XX1 CM-B-XX1 CM-B-GS CML3)
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/notnull CML2)
    <- make-targets-and-effects-consistent CML FML CM-B-GS MG CM-B-GSP CM-B-XX2 GSP-XX2
    <- join-preserves-clsmap-cxt-effects CM-B-XX1 CM-B-XX2 XJ CM-B-XX
    <- clsmap-cxt-effects-implies-effects-wf CM-B-XX1 WF-XX1
    <- clsmap-cxt-effects-implies-effects-wf CM-B-XX2 WF-XX2
    <- effects`join-implies-leq WF-XX1 WF-XX2 XJ _ LE2
    <- leq-preserves-targets-effects GSP-XX2 LE2 GSP-XX.

- : reftyping-implies-good-result CM-CM CM-B
    (reftyping/write RTYP-E1 RTYP-E2 CML FML MG SUB J12 J53 J64)
    %{=>}% (good-result/expr GS-XX7 CM-B-XX7 CM-B-GS CML3)
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML (clsmap-ty/notnull CML3)
    <- reftyping-implies-good-result CM-CM CM-B RTYP-E1
      (good-result/expr GS-XX1 CM-B-XX1  CM-B-GS1 CML4) 
    <- reftyping-implies-good-result CM-CM CM-B RTYP-E2
      (good-result/expr GS-XX2 CM-B-XX2 CM-B-GS2 CML5) 
    <- make-targets-and-effects-consistent CML FML CM-B-GS1 MG CM-B-GS CM-B-XX4 GS-XX4
    <- subtyping-consistent CM-B-GS2 SUB CM-B-XX3
    <- join-preserves-clsmap-cxt-effects CM-B-XX1 CM-B-XX2 J12 CM-B-XX5
    <- join-preserves-clsmap-cxt-effects CM-B-XX5 CM-B-XX4 J53 CM-B-XX6
    <- join-preserves-clsmap-cxt-effects CM-B-XX6 CM-B-XX3 J64 CM-B-XX7
    <- clsmap-cxt-effects-implies-effects-wf CM-B-XX5 WF1
    <- clsmap-cxt-effects-implies-effects-wf CM-B-XX6 WF2
    <- clsmap-cxt-effects-implies-effects-wf CM-B-XX3 WF3
    <- clsmap-cxt-effects-implies-effects-wf CM-B-XX4 WF4
    <- clsmap-cxt-effects-implies-effects-wf CM-B-XX7 WF5
    <- effects`join-implies-leq WF1 WF4 J53 _ LE4
    <- effects`join-implies-leq WF2 WF3 J64 LE5 _
    <- effects`leq-transitive WF4 WF2 WF5 LE4 LE5 LE
    <- leq-preserves-targets-effects GS-XX4 LE GS-XX7.

%worlds () (reftyping-implies-good-result _ _ _ _).
%total (T) (reftyping-implies-good-result _ _ T _).