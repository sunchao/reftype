%theorem letRefTyping-helper/base/unique/L1L2L1
  : forall* {O2} {O2P} {N} {F} {PF} {PiF} {NN1} {NN2} {NNP}
    forall {Q} {EQ: object`eq O2 O2P} {EQ: nat`eq F N}
    {AN2:apply-nn NNP
          ([x:gterm objectk]
          scale Q (unitperm (precise-exists x N ([x1:gterm objectk] PF x1))))
          ([x:gterm objectk] PiF x)}
    {NNP=NN2: nonnull`eq NNP NN2}
    {NN1<=NN2: nonnull`leq NN1 NN2}
    exists {PiF2}
    {AN2:apply-nn NN1
          ([x:gterm objectk]
            scale Q (unitperm (precise-exists x F ([x1:gterm objectk] PF x1))))
          ([x:gterm objectk] PiF2 x)}
    {IMP: {x} implies (combine (unitperm (nonlinear (objequal x O2))) (PiF O2P))
                 (combine (PiF2 x) (unitperm (encumbered (PiF2 x) (PiF O2P))))}
    true.

- : letRefTyping-helper/base/unique/L1L2L1 Q
    (object`eq/:object`eq O2 O2) (nat`eq/:nat`eq N N)
    apply-nn/yes nonnull`eq/ (nonnull`leq/= nonnull`eq/) _ apply-nn/yes
    ([x] implies/trans
      (implies/combine (implies/nonlinear bimplies/objequal-symmetric)
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine implies/reflexive implies/self-implication)))
      (implies/objequal
        ([y] combine
          (combine (unitperm (nonlinear (neg (objequal y null))))
            (scale Q (unitperm (precise-exists y N PF))))
          (unitperm
            (encumbered
              (combine (unitperm (nonlinear (neg (objequal y null))))
                (scale Q (unitperm (precise-exists y N PF))))
              (combine (unitperm (nonlinear (neg (objequal O2 null))))
                (scale Q (unitperm (precise-exists O2 N PF))))))))).

- : letRefTyping-helper/base/unique/L1L2L1 Q
    (object`eq/:object`eq O2 O2) (nat`eq/:nat`eq N N)
    apply-nn/may nonnull`eq/ (nonnull`leq/= nonnull`eq/) _ apply-nn/may
    ([x] implies/trans
      (implies/combine (implies/nonlinear bimplies/objequal-symmetric)
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine implies/reflexive implies/self-implication)))
      (implies/objequal
        ([y] combine (unitperm (conditional (objequal y null) empty
                                 (scale Q (unitperm (precise-exists y N PF)))))
          (unitperm (encumbered
                      (unitperm (conditional (objequal y null) empty
                                  (scale Q (unitperm (precise-exists y N PF)))))
                      (unitperm (conditional (objequal O2 null) empty
                                  (scale Q (unitperm (precise-exists O2 N PF)))))))))).

% - : letRefTyping-helper/base/unique/L1L2L1 Q
%     (object`eq/:object`eq O2 O2) (nat`eq/:nat`eq N N)
%     apply-nn/yes nonnull`eq/ nonnull`leq/< _ apply-nn/may
%     ([x] implies/trans3
%       (implies/combine (implies/nonlinear bimplies/objequal-symmetric)
%         (implies/trans
%           (implies/equiv (equiv/symmetric equiv/identity))
%           (implies/combine implies/reflexive implies/self-implication)))
%       (implies/objequal
%         ([y] combine
%           (combine (unitperm (nonlinear (neg (objequal y null))))
%             (scale Q (unitperm (precise-exists y N PF))))
%           (unitperm
%             (encumbered
%               (combine (unitperm (nonlinear (neg (objequal y null))))
%                 (scale Q (unitperm (precise-exists y N PF))))
%               (combine (unitperm (nonlinear (neg (objequal O2 null))))
%                 (scale Q (unitperm (precise-exists O2 N PF))))))))
%       (KKK x)).

%worlds (objvar) (letRefTyping-helper/base/unique/L1L2L1 _ _ _ _ _ _ _ _ _).
%trustme %total { } (letRefTyping-helper/base/unique/L1L2L1 _ _ _ _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L1L2
  : forall* {CM} {PM} {B} {O} {N1} {MF} {M2} {Pi2} {BF} {A} {C} {N2} {X} {A1} {NN1} {NN2}
    forall {L: cxt`lookup B N2 (cxt-info/ O (ty/ NN2 A1 C))}
    {N1!<B: cxt`fresh B N1}
    {B+N1=BF: {x} cxt`update B N1 (cxt-info/ x (ty/ NN1 A C)) (BF x)}
    {N2+MF=M2: nat+set2capmap N2 MF X M2}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    {NN1<=NN2: nonnull`leq NN1 NN2}
    exists {M1} {Pi1}
    {N1+MF=M1: nat+set2capmap N1 MF X M1}
    {M1=>Pi1: {x} capmap2perm CM PM (BF x) M1 (Pi1 x)}
    {IMP: {x} implies (combine (unitperm (nonlinear (objequal x O))) Pi2)
          (combine (Pi1 x) (unitperm (encumbered (Pi1 x) Pi2)))}
    true.

- : letRefTyping-helper/base/unique/L1L2 _ _ _ nat+set2capmap/0 capmap2perm/0 LEQ %{=>}%
    _ _ (nat+set2capmap/0) ([_] capmap2perm/0)
    ([x] implies/combine implies/nonlinear2empty implies/self-implication).

- : {B+N=BF:{x} cxt`update B Nx1 (cxt-info/ x (ty/ NNx1 A C)) (BF x)}
    letRefTyping-helper/base/unique/L1L2
    (BL:cxt`lookup B Nx2 (cxt-info/ O2 (ty/ NNx2 A1 C)))
    (N1!<B:cxt`fresh B Nx1) B+N=BF
    (nat+set2capmap/U (N2+MFP=M2P:nat+set2capmap Nx2 MFP Xx M2P)
      (N2+F=K2:pair2nat (pair/ Nx2 F) K2)
      F!<MFP MFP+F+X=MF (M2P+K2+X=M2:capmap`update M2P K2 Xx M2))
    M2=>Pi2 (LEQ:nonnull`leq NNx1 NNx2)
    %{=>}% _ _
    (nat+set2capmap/U N1+MFP=M1P (N1+F=K1:pair2nat (pair/ Nx1 F) K1) F!<MFP
      (MFP+F+X=MF:set`add MFP F MF)
      (M1P+K1+X=M1:capmap`update M1P K1 Xx M1))
    ([x] capmap2perm/U (M1P=>Pi12 x) N1+F=K1 (BFL x)
      (create-fldperm/ CML FML T2PF) X2Q AN3 K1!<M1P M1P+K1+X=M1)
    ([x] implies/trans7
      (implies/combine
        (implies/duplicate)
        (implies/equiv (equiv/symmetric (Pi21+Pi22<=>Pi2))))
      (implies/equiv
        (equiv/transitive
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive equiv/roll2)))
      (implies/combine
        (implies/reflexive)
        (implies/combine
          (implies/reflexive)
          (IMPP x)))
      (implies/equiv equiv/associate)
      (implies/combine (IMPP2 x) (implies/reflexive))
      (implies/equiv
        (equiv/transitive3
          (equiv/symmetric equiv/associate)
          (equiv/combine equiv/reflexive equiv/roll2)
          (equiv/associate)))
      (implies/combine implies/reflexive
        (implies/trans
          (implies/combine-merge-encumbered)
          (implies/equiv-encumbered
            (equiv/reflexive)
            (Pi21+Pi22<=>Pi2)))))
     <- nat+set2capmap-preserves-fresh N2+MFP=M2P F!<MFP N2+F=K2 K2!<M2P
     <- capmap2perm/U-inversion M2=>Pi2 K2!<M2P M2P+K2+X=M2 %{=>}%
       N2P FP N2P+FP=K2 O2P NNP AP CP BL2 _ (create-fldperm/ CML2 FML2 T2PF)
       Q X2Q KK AN2 Pi22 M2P=>Pi22 (Pi21+Pi22<=>Pi2)
     <- letRefTyping-helper/base/unique/L1L2 BL N1!<B B+N=BF N2+MFP=M2P
       M2P=>Pi22 LEQ %{=>}% M1P Pi12 N1+MFP=M1P ([x] M1P=>Pi12 x) ([x] IMPP x)
     <- pair2nat-total (N1+F=K1: pair2nat (pair/ Nx1 F) K1)
     <- capmap`update-total M1P+K1+X=M1
     <- ({x} cxt`update-implies-lookup (B+N=BF x) (BFL x))
     <- nat+set2capmap-preserves-fresh N1+MFP=M1P F!<MFP N1+F=K1 K1!<M1P
     <- nat2pair-unique N2+F=K2 N2P+FP=K2 nat`eq/ N2+F=N2P+FP
     <- pair-eq-implies-eq N2+F=N2P+FP N2=N2P F=FP
     <- cxt`lookup-unique BL BL2 cxt`eq/ N2=N2P CIE
     <- cxt-info-eq-inversion CIE O2=O2P TE
     <- ty-eq-inversion TE NN=NNP A=AP C=CP
     <- nat`eq-symmetric C=CP CP=C
     <- nat`eq-symmetric F=FP FP=F
     <- nonnull`eq-symmetric NN=NNP NNP=NN
     <- clsmap`lookup-respects-eq CML2 clsmap`eq/ CP=C fldmap`eq/ CML
     <- fldmap`lookup-respects-eq FML2 fldmap`eq/ FP=F ty`eq/ FML
     <- letRefTyping-helper/base/unique/L1L2L1 _ O2=O2P F=FP AN2 NNP=NN LEQ _ AN3 IMPP2.

% - : letRefTyping-helper/base/unique/L1L2
%     (BL:cxt`lookup B Nx2 (cxt-info/ O2 (ty/ NN A C)))
%     (N1!<B:cxt`fresh B Nx1) B+N=BF
%     (nat+set2capmap/U (N2+MFP=M2P:nat+set2capmap Nx2 MFP Xx M2P)
%       (N2+F=K2:pair2nat (pair/ Nx2 F) K2)
%       F!<MFP MFP+F+X=MF (M2P+K2+X=M2:capmap`update M2P K2 Xx M2))
%     M2=>Pi2
%     %{=>}% _ _
%     (nat+set2capmap/U N1+MFP=M1P (N1+F=K1:pair2nat (pair/ Nx1 F) K1) F!<MFP
%       (MFP+F+X=MF:set`add MFP F MF)
%       (M1P+K1+X=M1:capmap`update M1P K1 Xx M1))
%     ([x] capmap2perm/U (M1P=>Pi12 x) N1+F=K1 (BFL x)
%       (create-fldperm/ CML FML T2PF) X2Q AN3 K1!<M1P M1P+K1+X=M1)
%     ([x] implies/trans7
%       (implies/combine
%         (implies/duplicate)
%         (implies/equiv (equiv/symmetric (Pi21+Pi22<=>Pi2))))
%       (implies/equiv
%         (equiv/transitive
%           (equiv/symmetric equiv/associate)
%           (equiv/combine equiv/reflexive equiv/roll2)))
%       (implies/combine
%         (implies/reflexive)
%         (implies/combine
%           (implies/reflexive)
%           (IMPP x)))
%       (implies/equiv equiv/associate)
%       (implies/combine (IMPP2 x) (implies/reflexive))
%       (implies/equiv
%         (equiv/transitive3
%           (equiv/symmetric equiv/associate)
%           (equiv/combine equiv/reflexive equiv/roll2)
%           (equiv/associate)))
%       (implies/combine implies/reflexive
%         (implies/trans
%           (implies/combine-merge-encumbered)
%           (implies/equiv-encumbered
%             (equiv/reflexive)
%             (Pi21+Pi22<=>Pi2)))))
%      <- nat+set2capmap-preserves-fresh N2+MFP=M2P F!<MFP N2+F=K2 K2!<M2P
%      <- capmap2perm/U-inversion M2=>Pi2 K2!<M2P M2P+K2+X=M2 %{=>}%
%        N2P FP N2P+FP=K2 O2P NNP AP CP BL2 _ (create-fldperm/ CML2 FML2 T2PF)
%        Q X2Q _ AN2 Pi22 M2P=>Pi22 (Pi21+Pi22<=>Pi2)
%      <- letRefTyping-helper/base/unique/L1L2 BL N1!<B B+N=BF N2+MFP=M2P
%        M2P=>Pi22 %{=>}% M1P Pi12 N1+MFP=M1P ([x] M1P=>Pi12 x) ([x] IMPP x)
%      <- pair2nat-total (N1+F=K1: pair2nat (pair/ Nx1 F) K1)
%      <- capmap`update-total M1P+K1+X=M1
%      <- ({x} cxt`update-implies-lookup (B+N=BF x) (BFL x))
%      <- nat+set2capmap-preserves-fresh N1+MFP=M1P F!<MFP N1+F=K1 K1!<M1P
%      <- nat2pair-unique N2+F=K2 N2P+FP=K2 nat`eq/ N2+F=N2P+FP
%      <- pair-eq-implies-eq N2+F=N2P+FP N2=N2P F=FP
%      <- cxt`lookup-unique BL BL2 cxt`eq/ N2=N2P CIE
%      <- cxt-info-eq-inversion CIE O2=O2P TE
%      <- ty-eq-inversion TE NN=NNP A=AP C=CP
%      <- nat`eq-symmetric C=CP CP=C
%      <- nat`eq-symmetric F=FP FP=F
%      <- nonnull`eq-symmetric NN=NNP NNP=NN
%      <- clsmap`lookup-respects-eq CML2 clsmap`eq/ CP=C fldmap`eq/ CML
%      <- fldmap`lookup-respects-eq FML2 fldmap`eq/ FP=F ty`eq/ FML
%      <- letRefTyping-helper/base/unique/L1L2L1 Q O2=O2P F=FP AN2 _ AN3 IMPP2.

%worlds (objvar) (letRefTyping-helper/base/unique/L1L2 _ _ _ _ _ _ _ _ _ _ _).
%total (M) (letRefTyping-helper/base/unique/L1L2 _ _ _ M _ _ _ _ _ _ _ ).


%theorem letRefTyping-helper/base/unique/L1L3
  : forall* {O1} {O2} {Pi2} {Pi2P}
    forall {O1=O2: {x} object`eq (O1 x) O2}
    {IMP2:{x:gterm objectk}
           implies (combine (unitperm (nonlinear (objequal x O2))) Pi2)
           (combine (Pi2P x) (unitperm (encumbered (Pi2P x) Pi2)))}
    exists {IMP2:{x:gterm objectk}
                  implies
                  (combine (unitperm (nonlinear (objequal x (O1 x)))) Pi2)
                  (combine (Pi2P x) (unitperm (encumbered (Pi2P x) Pi2)))}
    true.

- : letRefTyping-helper/base/unique/L1L3 ([_] object`eq/) IMP IMP.

%worlds (objvar) (letRefTyping-helper/base/unique/L1L3 _ _ _).
%total { } (letRefTyping-helper/base/unique/L1L3 _ _ _).


%theorem letRefTyping-helper/base/unique/L1
  : forall* {S} {B} {GF} {FS} {M1} {N} {C} {B1} {CM} {PM} {PiM1} {A} {NN}
    forall {SN} {SZ-S: set`size S (s SN)}
    {CM-B-S: clsmap-cxt-unique-objset CM B NN C S}
    {S+FS=M1: set+set2capmap S FS cap/write M1}
    {M1=>PiM1: capmap2perm CM PM B M1 PiM1}
    {S=>GF: {x} set2cond B x S (GF x)}
    {BF: cxt`fresh B N}
    {BL: {x} cxt`update B N (cxt-info/ x (ty/ NN A C)) (B1 x)}
    exists {M2} {PiM2}
    {N+FS=M2: nat+set2capmap N FS cap/write M2}
    {M2=>PiM2: {x} capmap2perm CM PM (B1 x) M2 (PiM2 x)}
    {PiM1+GF=>PiM2: {x} implies (combine (GF x) PiM1)
                    (combine (GF x)
                      (combine (PiM2 x) (unitperm (encumbered (PiM2 x) PiM1))))}
    true.

 - : letRefTyping-helper/base/unique/L1 z SZ CM-B-S
     (set+set2capmap/U SP+MF=MP1 NP+MF=>MP2 NP!<SP (SP+NP=S:set`add SP NP S)
       (MP1+MP2=M:capmap`join MP1 MP2 M))
     M=>Pi ([x] S=>GF x) BF BU %{=>}% _ _
     (N+MF=>MN:nat+set2capmap N MF _ MN) MN=>Pf
     ([x] implies/trans8
       (implies/combine (GIMP1 x) implies/reflexive)
       (implies/equiv equiv/commute)
       (implies/cond-push)
       (implies/cond-gen-inner)
       (implies/cond-inner
         (bimplies/reflexive)
         (bimplies/reflexive)
         (implies/trans3
           (implies/combine
             (implies/reflexive)
             ((implies/equiv equiv/identity)))
           (IMPP2 x)
           (implies/equiv (equiv/symmetric equiv/identity)))
         (implies/trans5
           (implies/combine implies/nonlinear2empty
             (implies/combine implies/reflexive (GFP=>F x)))
           (implies/equiv (equiv/transitive equiv/commute equiv/identity))
           (implies/combine implies/reflexive implies/duplicate)
           (implies/equiv equiv/associate)
           (implies/combine
             (implies/trans3
               (implies/equiv equiv/commute)
               (implies/combine (implies/contradiction) implies/reflexive)
               (IMPP2 x))
             (F=>GFP x))))
       (implies/cond-pull)
       (implies/equiv equiv/commute)
       (implies/combine (GIMP2 x) implies/reflexive))
     <- set`not-member-add-size-implies-empty NP!<SP SP+NP=S SZ SP=0
     <- ({x} set2cond/U-inversion (S=>GF x) NP!<SP SP+NP=S (GFP x) (SP=>GFP x)
       (OF x) _ (BL x) (GIMP1 x) (GIMP2 x))
     <- letRefTyping-helper/base/unique/L1L BL _ _ BL1 ([x] OF=O2 x)
     <- clsmap-cxt-unique-objset/U-inversion CM-B-S NP!<SP SP+NP=S
       CM-B-SP O1 A1 _ BLP (LEQ:nonnull`leq NNx1 NNx2)
     <- set+set2capmap-unique SP+MF=MP1 set+set2capmap/0 SP=0 set`eq/ cap`eq/ MP1=0
     <- capmap`join-unique MP1+MP2=M capmap`join/L MP1=0 capmap`eq/ M=MP2
     <- capmap2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/ cxt`eq/ M=MP2
       permission`eq/ MP2=>Pi
     <- cxt`lookup-unique BL1 BLP cxt`eq/ nat`eq/ CIE
     <- ({x} cxt`update-implies-lookup (BU x) (BL2 x))
     <- letRefTyping-helper/base/unique/L1L2
       BLP BF BU NP+MF=>MP2 MP2=>Pi LEQ _ _ N+MF=>MN MN=>Pf IMPP
     <- capmap`eq-symmetric M=MP2 MP2=M
     <- cxt-info-eq-inversion CIE O2=O1 TE
     <- ({x:object} object`eq-transitive (OF=O2 x) O2=O1 (OF=O1 x))
     <- letRefTyping-helper/base/unique/L1L3 OF=O1 IMPP IMPP2
     <- ({x} set2cond-implies (SP=>GFP x) set2cond/0 object`eq/ SP=0 (GFP=>F x) (F=>GFP x)).

- : {S=>GF: {x} set2cond B x S (GF x)}
    letRefTyping-helper/base/unique/L1 _ SZ S-NN-C
    (set+set2capmap/U SP+MF=M1 N1+MF=M2 (N1!<SP:set`not-member SP Nx1)
      SP+N1=S (M1+M2=M:capmap`join M1 M2 M)) M=>Pi ([x] S=>GF x) BF ([x] BU x)
    %{=>}% MN _ (N+MF=MN:nat+set2capmap Nx MF _ MN) ([x] MN=>Pf x)
    ([x] implies/trans7
      (implies/combine (GF=>EQ+GFP x) (implies/equiv (Pi<=>Pi1+Pi2)))
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans7
          (implies/combine implies/reflexive (implies/equiv equiv/identity))
          (implies/equiv
            (equiv/transitive
              (equiv/combine equiv/reflexive equiv/commute)
              (equiv/associate)))
          (implies/combine (IMP2P x)
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/self-implication)
                  (implies/equiv-encumbered
                    (Pi<=>Pi1+Pi2)
                    (equiv/reflexive))
                  (implies/combine-assoc-encumbered)))
              (implies/linear-modus-ponens)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive implies/chain-implication)
          (implies/combine (implies/equiv (Pi2P<=>Pf x))
            (implies/equiv-encumbered (Pi2P<=>Pf x) equiv/reflexive))
          (implies/equiv
            (equiv/transitive (equiv/symmetric equiv/identity) (equiv/commute))))
        (implies/trans4
          (implies/combine
            (implies/nonlinear2empty)
            (implies/trans3
              (implies/equiv equiv/commute)
              (implies/equiv equiv/associate)
              (implies/combine
                (GFP+Pi1=>Pf+Pf-Pi1 x)
                (implies/reflexive))))
          (implies/equiv
            (equiv/transitive equiv/commute equiv/identity))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine implies/reflexive
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/transitive
                          (Pi<=>Pi1+Pi2)
                          (equiv/commute))
                        (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive implies/chain-implication)))))
      (implies/cond-distribute)
      (implies/combine (EQ+GFP=>GF x) (implies/cond-equal)))
     <- ({x} set2cond/U-inversion (S=>GF x) N1!<SP SP+N1=S (GFP x)
          (SP=>GFP x) (OF x) T (BL1 x) (GF=>EQ+GFP x) (EQ+GFP=>GF x))
     <- letRefTyping-helper/base/unique/L1L BL1 _ _ BL1P ([x] OF=O1 x)
     <- clsmap-cxt-unique-objset/U-inversion S-NN-C N1!<SP SP+N1=S
       SP-NN-C O2 _ _ BL2 LEQ
     <- cxt`lookup-unique BL1P BL2 cxt`eq/ nat`eq/ CIE
     <- cxt-info-eq-inversion CIE O1=O2 TE
     <- ({x} object`eq-transitive (OF=O1 x) O1=O2 (OF=O2 x))
     <- not-member-nat+set2capmap-implies-disjoint SP+MF=M1 N1+MF=M2 N1!<SP M1^M2
     <- capmap`disjoint-join-implies-equiv M1^M2 M1+M2=M M=>Pi
       Pi1 Pi2 M1=>Pi1 M2=>Pi2 (Pi<=>Pi1+Pi2:equiv Pi (combine Pi1 Pi2))
     <- set`not-member-add-increases-size-converse SZ N1!<SP SP+N1=S SZP
     <- letRefTyping-helper/base/unique/L1 _ SZP SP-NN-C SP+MF=M1 M1=>Pi1 ([x] SP=>GFP x)
       BF ([x] BU x) _ _ N+MF=MN ([x] MN=>Pf x) (GFP+Pi1=>Pf+Pf-Pi1)
     <- letRefTyping-helper/base/unique/L1L2 BL2 BF ([x] BU x) N1+MF=M2 M2=>Pi2 LEQ
       _ _ N+MF=M2P ([x] BF+M2P=>Pi2P x) ([x] IMP2 x)
     <- nat+set2capmap-unique N+MF=M2P N+MF=MN nat`eq/ set`eq/ cap`eq/ M2P=MN
    <- ({x} capmap2perm-equiv (BF+M2P=>Pi2P x) (MN=>Pf x) clsmap`eq/
         predmap`eq/ cxt`eq/ M2P=MN (Pi2P<=>Pf x))
    <- letRefTyping-helper/base/unique/L1L3 OF=O2 IMP2 IMP2P.

%worlds (objvar) (letRefTyping-helper/base/unique/L1 _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N) (letRefTyping-helper/base/unique/L1 N _ _ _ _ _ _ _ _ _ _ _ _).
