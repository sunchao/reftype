%theorem fldmap2perm-eq
  : forall* {PM} {O} {FM} {FS} {Pi}
    {PM'} {O'} {FM'} {FS'} {Pi'}
    forall {MF1: fldmap2perm PM O FM FS Pi}
    {MF1': fldmap2perm PM' O' FM' FS' Pi'}
    {PME: predmap`eq PM PM'} {OE: object`eq O O'}
    {FME: fldmap`eq FM FM'} {FSE: set`eq FS FS'}
    exists {EQV: permission`eq Pi Pi'}
    true.

%theorem fldmap2perm-eq/L
  : forall* {O0} {O1} {PF0:object -> permission} {PF1} {F}
    forall {PFE: {x} permission`eq (PF0 x) (PF1 x)}
    {FE: object`eq O0 O1}
    exists {PE: permission`eq (unitperm (precise-exists O0 F PF0))
                (unitperm (precise-exists O1 F PF1))}
    true.

- : fldmap2perm-eq/L ([_] permission`eq/) object`eq/ permission`eq/.

- : fldmap2perm-eq fldmap2perm/0 fldmap2perm/0 _ _ _ _ permission`eq/.

    (equiv/transitive
      (equiv/combine PFEQV EQV2)
      (equiv/symmetric EQV1))

- : fldmap2perm-eq (fldmap2perm/U MF1 F1 U1 L1 R1) MF PME OE FME SE
    KKK
    <- fldmap2perm/U-inversion MF F1 U1 _ MF2 _ L2 _ R2 EQV1
    <- fldmap2perm-eq MF1 MF2 PME OE FME set`eq/ EQV2
    <- fldmap`lookup-unique L1 L2 FME nat`eq/ TE
    <- ty2perm-deterministic R1 R2 PME TE ([x] PFE x)
    <- fldmap2perm-eq/L PFE OE PFE'.


%worlds (objvar) (fldmap2perm-eq/L _ _ _).
%total { } (fldmap2perm-eq/L _ _ _).

%worlds (objvar) (fldmap2perm-eq _ _ _ _ _ _ _).
%total (M) (fldmap2perm-eq M _ _ _ _ _ _).


%theorem letRefTyping-helper/base/unique/L2
  : forall* {CM} {B} {NN} {C} {FM} {PM} {S} {CP} {FS} {Pi} {GF} {PF}
    forall {N} {SZ: set`size S (s N)}
    {CM-B-S: clsmap-cxt-unique-objset CM B NN C S}
    {CML: clsmap`lookup CM C FM}
    {PML: predmap`lookup PM C CP}
    {FM-DM: fldmap`domain FM FS}
    {ME: make-encumbered CM PM B S Pi}
    {S=>GF: {x} set2cond B x S (GF x)}
    {FM2P2: {x} fldmap2perm2 PM x FM (PF x)}
    exists {IMP: {x} implies (combine (GF x) Pi)
          (combine (GF x)
            (combine (encumbered-fldperm x PF CP)
              (unitperm (encumbered (encumbered-fldperm x PF CP) Pi))))}
    true.

- : {FS2=>Pi: {x} fldmap2perm PM x FM FS2 (PF2 x)}
    {FS1=>Pi: {x} fldmap2perm PM x FM1 FS1 (PF1 x)}
    letRefTyping-helper/base/unique/L2 z SZ
    (CM-B-S:clsmap-cxt-unique-objset CM B NNx C S)
    (CML:clsmap`lookup CM C FM)
    (PML:predmap`lookup PM C CP)
    (FM-DM:fldmap`domain FM FS)
    (make-encumbered/U ME-SP (BL1:cxt`lookup B Nx (cxt-info/ O1 (ty/ NNx1 A1 C1)))
      (CML1:clsmap`lookup CM C1 FM1)
      (PML1:predmap`lookup PM C1 CP1)
      (FM1-DM:fldmap`domain FM1 FS1)
      ([x] FS1=>Pi x)
      N!<SP (SP+N=S:set`add SP Nx S))
    ([x] S=>GF x) ([x] fldmap2perm2/ (DM-FM2:fldmap`domain FM FS2) (FS2=>Pi x))
    ([x] implies/trans9
      (implies/combine (GIMP1 x)
        (implies/trans
          (implies/combine implies/reflexive Pi2=>E)
          (implies/equiv equiv/identity)))
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans4
          (implies/combine
            (implies/trans
              (implies/equiv (EQV x))
              (implies/nonlinear bimplies/objequal-symmetric))
            (implies/combine implies/reflexive implies/self-implication))
          (implies/objequal
              ([v] (combine (encumbered-fldperm v PF1 CP1)
                     (unitperm (encumbered (encumbered-fldperm v PF1 CP1)
                                 (encumbered-fldperm O1 PF1 CP1))))))
          (implies/combine implies/reflexive
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine implies/reflexive E=>Pi2)
              (add-encumber)))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans3
          (implies/combine implies/nonlinear2empty
            (implies/trans3
              (implies/combine implies/reflexive
                (implies/trans (GIMP3 x) implies/duplicate))
              (implies/equiv
                (equiv/transitive equiv/commute (equiv/symmetric equiv/associate)))
              (implies/combine (GIMP4 x)
                (implies/trans3
                  (implies/combine (implies/contradiction)
                    (implies/trans
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine implies/reflexive implies/self-implication)))
                  (implies/objequal
                    ([v] (combine (encumbered-fldperm v PF1 CP1)
                           (unitperm (encumbered (encumbered-fldperm v PF1 CP1)
                                       (encumbered-fldperm O1 PF1 CP1))))))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine implies/reflexive (E=>Pi2))
                      (add-encumber)))))))
          (implies/equiv (equiv/transitive equiv/commute equiv/identity))
          (implies/equiv equiv/commute)))
      (implies/cond-pull)
      (implies/combine implies/reflexive (GIMP2 x))
      (implies/combine
        (implies/combine (implies/equiv (EQV2 x))
          (implies/equiv-encumbered (EQV2 x) (equiv/reflexive)))
        (implies/reflexive))
      (implies/equiv equiv/commute))
    <- set`not-member-add-size-implies-empty N!<SP SP+N=S SZ (SP=E:set`eq SP set/0)
    <- ({x} set2cond/U-inversion (S=>GF x) N!<SP SP+N=S (GFP x) (SP=>GFP x)
         (O2 x) T2 (BL2 x) (GIMP1 x) (GIMP2 x))
    <- clsmap-cxt-unique-objset/U-inversion CM-B-S N!<SP SP+N=S CM-B-SP O3 A3 NNx3 BL3 _
    <- cxt`lookup-unique BL1 BL3 cxt`eq/ nat`eq/ CI1=CI3
    <- cxt-info-eq-inversion CI1=CI3 O1=O3 T1=T3
    <- ty-eq-inversion T1=T3 NN1=NN3 A1=A3 C1=C
    <- clsmap`lookup-unique CML1 CML clsmap`eq/ C1=C FM1=FM
    <- predmap`lookup-unique PML1 PML predmap`eq/ C1=C CP1=CP
    <- fldmap`domain-unique FM1-DM FM-DM FM1=FM FS1=FS
    <- ({x} fldmap2perm-respects-eq (FS1=>Pi x) predmap`eq/ object`eq/ FM1=FM
         FS1=FS permission`eq/ (FS=>Pi x))
    <- make-encumbered-implies ME-SP make-encumbered/0 clsmap`eq/ predmap`eq/
      cxt`eq/ SP=E Pi2=>E E=>Pi2
    <- ({x} set2cond-implies (SP=>GFP x) set2cond/0 object`eq/ SP=E (GIMP3 x) (GIMP4 x))
    <- ({x} cxt`lookup-unique BL1 (BL2 x) cxt`eq/ nat`eq/ (CI1=CI2 x))
    <- ({x} cxt-info-eq-inversion (CI1=CI2 x) (O1=O2 x) TEQ)
    <- ({x} object`eq-symmetric (O1=O2 x) (O2=O1 x))
    <- ({x} permission-respects-object-eq
         ([y] (unitperm (nonlinear (objequal x y)))) (O2=O1 x) (EQV x))
    <- letRefTyping-helper/base/unique/L2L CP1=CP ([x] EQV2 x).

- : letRefTyping-helper/base/unique/L2 (s N) SZ
    (CM-B-S:clsmap-cxt-unique-objset CM B NNx C S)
    (CML:clsmap`lookup CM C FM)
    (PML:predmap`lookup PM C CP)
    (FM-DM:fldmap`domain FM FS)
    (make-encumbered/U
      (ME-SP:make-encumbered CM PM B SP PiBP)
      (BL1:cxt`lookup B Nx (cxt-info/ O1 (ty/ NNx1 A1 C1)))
      (CML1:clsmap`lookup CM C1 FM1)
      (PML1:predmap`lookup PM C1 CP1)
      (FM1-DM:fldmap`domain FM1 FS1)
      ([x] FS1=>Pi x)
      N!<SP (SP+N=S:set`add SP Nx S))
    ([x] S=>GF x) %{=>}% _ ([x] fldmap2perm2/ FM-DM2 (FS2=>Pi x))
    ([x] implies/trans8
      (implies/combine (GIMP1 x) implies/reflexive)
      (implies/equiv equiv/commute)
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans8
          (implies/combine
            (implies/trans
              (implies/equiv (EQV x))
              (implies/nonlinear bimplies/objequal-symmetric))
            (implies/equiv equiv/identity))
          (implies/combine (implies/reflexive)
            (implies/combine
              (implies/trans
                (implies/equiv (equiv/symmetric equiv/identity))
                (implies/combine implies/reflexive (implies/self-implication)))
              (implies/reflexive)))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/objequal
              ([v] (combine (encumbered-fldperm v PF1 CP1)
                     (unitperm (encumbered (encumbered-fldperm v PF1 CP1)
                                 (encumbered-fldperm O1 PF1 CP1))))))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine implies/reflexive add-encumber)
          (implies/equiv (EQV3 x))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans5
          (implies/combine implies/nonlinear2empty
            (implies/trans
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive
                (implies/trans (implies/equiv equiv/commute) (IMPP x)))))
          (implies/equiv (equiv/transitive equiv/commute equiv/identity))
          (implies/equiv (equiv/roll2))
          (implies/combine (implies/reflexive)
            (implies/trans
              (implies/equiv equiv/roll2)
              (implies/combine (implies/reflexive)
                (implies/trans3
                  (implies/equiv equiv/commute)
                  (add-encumber)
                  (implies/equiv-encumbered
                    (equiv/reflexive) (equiv/commute))))))
          (implies/equiv equiv/commute)))
      (implies/cond-pull)
      (implies/combine (implies/reflexive) (GIMP2 x))
      (implies/equiv equiv/commute))
    <- ({x} set2cond/U-inversion (S=>GF x) N!<SP SP+N=S (GFP x) (SP=>GFP x)
         (O2 x) T2 (BL2 x) (GIMP1 x) (GIMP2 x))
    <- clsmap-cxt-unique-objset/U-inversion CM-B-S N!<SP SP+N=S CM-B-SP O3 A3 NNx3 BL3 _
    <- cxt`lookup-unique BL1 BL3 cxt`eq/ nat`eq/ CI1=CI3
    <- cxt-info-eq-inversion CI1=CI3 O1=O3 T1=T3
    <- ty-eq-inversion T1=T3 NN1=NN3 A1=A3 C1=C
    <- clsmap`lookup-unique CML1 CML clsmap`eq/ C1=C FM1=FM
    <- predmap`lookup-unique PML1 PML predmap`eq/ C1=C CP1=CP
    <- fldmap`domain-unique FM1-DM FM-DM FM1=FM FS1=FS
    <- ({x} fldmap2perm-respects-eq (FS1=>Pi x) predmap`eq/ object`eq/ FM1=FM
         FS1=FS permission`eq/ (FS=>Pi x))
    <- ({x} cxt`lookup-unique BL1 (BL2 x) cxt`eq/ nat`eq/ (CI1=CI2 x))
    <- ({x} cxt-info-eq-inversion (CI1=CI2 x) (O1=O2 x) TE)
    <- ({x} object`eq-symmetric (O1=O2 x) (O2=O1 x))
    <- ({x} permission-respects-object-eq
         ([y] (unitperm (nonlinear (objequal x y)))) (O2=O1 x) (EQV x))
    <- set`not-member-add-increases-size-converse SZ N!<SP SP+N=S SZP
    <- letRefTyping-helper/base/unique/L2 N SZP CM-B-SP CML PML FM-DM ME-SP SP=>GFP
      _ ([x] fldmap2perm2/ (FM-DM2:fldmap`domain FM FS2)
          (FS2=>Pi x)) IMPP
    <- fldmap`domain-unique FM-DM FM-DM2 fldmap`eq/ FS=FS2
    <- set`eq-transitive FS1=FS FS=FS2 FS1=FS2
    <- ({x} fldmap2perm-equiv (FS1=>Pi x) (FS2=>Pi x) predmap`eq/
         object`eq/ FM1=FM FS1=FS2 (EQV2 x))
    <- letRefTyping-helper/base/unique/L2L4 EQV2 CP1=CP ([x] EQV3 x).

%worlds (objvar) (letRefTyping-helper/base/unique/L2 _ _ _ _ _ _ _ _ _ _ _).
%total (ME) (letRefTyping-helper/base/unique/L2 _ _ _ _ _ _ ME _ _ _ _).

