%theorem reftyping-ok/eq/L1
  : forall* {CM} {PM} {B} {RT1} {PiB}
    {RT2} {V0} {V1} {V2} {PF1} {PF2} {PiV0}
    forall {RCT1: restore-cap-targets V0 RT1 V1}
    {RCT2: restore-cap-targets V1 RT2 V2}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    {RT1=>PF1: reftype2perm CM PM B RT1 PF1}
    {RT2=>PF2: reftype2perm CM PM B RT2 PF2}
    exists {PiV2} {V2=>PiV2: env2input CM PM B V2 PiV2}
    {TRANS: {o1}{r1}{p1}{o2}{r2}{p2}
            transform
            (output/expr o2
              (combine (PF1 o1 r1 p1)
                (combine
                  (combine PiB (combine (PF2 o2 r2 p2) PiV0))
                  (empty))))
            (output/expr o2
              (combine PiB PiV2))}
    true.

%%% fresh - fresh
- : reftyping-ok/eq/L1
    restore-cap-targets/fresh restore-cap-targets/fresh
    (V0=>PiV0:env2input CM PM B V0 PiV0)
    (reftype2perm/fresh T2PF1) (reftype2perm/fresh T2PF2)
    _ V0=>PiV0
    ([_][_][_][_][_][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop))).

%%% fresh - shared
- : reftyping-ok/eq/L1
    restore-cap-targets/fresh restore-cap-targets/shared
    (V0=>PiV0:env2input CM PM B V0 PiV0)
    (reftype2perm/fresh T2PF1) (reftype2perm/shared T2PF2)
    _ V0=>PiV0
    ([_][_][_][_][_][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop))).

%%% shared - shared
- : reftyping-ok/eq/L1
    restore-cap-targets/shared restore-cap-targets/shared
    (V0=>PiV0:env2input CM PM B V0 PiV0)
    (reftype2perm/shared T2PF1) (reftype2perm/shared T2PF2)
    _ V0=>PiV0
    ([_][_][_][_][_][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop))).

%%% shared - fresh
- : reftyping-ok/eq/L1
    restore-cap-targets/shared restore-cap-targets/fresh
    (V0=>PiV0:env2input CM PM B V0 PiV0)
    (reftype2perm/shared T2PF1) (reftype2perm/fresh T2PF2)
    _ V0=>PiV0
    ([_][_][_][_][_][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop))).

%%% borrow - shared
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 set/0 M))
    (restore-cap-targets/shared)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 S2G1) (reftype2perm/shared T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([_][_][_][_][_][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

%%% borrow - fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 set/0 M))
    (restore-cap-targets/fresh)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 S2G1) (reftype2perm/fresh T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([_][_][_][_][_][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

%%% unique - shared
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 H0 M))
    (restore-cap-targets/shared)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 S2G1 H0=>PiH0) (reftype2perm/shared T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([_][_][_][_][_][_]
      (transform/trans
        (transform/implies
          (implies/trans5
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive (PiM0+PiH0<=>PiM)))))))
            (implies/equiv equiv/associate)))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% unique - fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 H0 M))
    (restore-cap-targets/fresh)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 S2G1 H0=>PiH0) (reftype2perm/fresh T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([_][_][_][_][_][_]
      (transform/trans
        (transform/implies
          (implies/trans5
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive (PiM0+PiH0<=>PiM)))))))
            (implies/equiv equiv/associate)))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% unique+fresh - shared
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 H0 M))
    (restore-cap-targets/shared)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique+fresh T2PF1 S2G1 H0=>PiH0) (reftype2perm/shared T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([_][_][_][_][_][_]
      (transform/trans
        (transform/implies
          (implies/trans6
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/associate)
                          (equiv/combine (PiM0+PiH0<=>PiM) equiv/reflexive))))))))
            (implies/equiv equiv/associate)
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% unique+fresh - fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 H0 M))
    (restore-cap-targets/fresh)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique+fresh T2PF1 S2G1 H0=>PiH0) (reftype2perm/fresh T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([_][_][_][_][_][_]
      (transform/trans
        (transform/implies
          (implies/trans6
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/associate)
                          (equiv/combine (PiM0+PiH0<=>PiM) equiv/reflexive))))))))
            (implies/equiv equiv/associate)
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% shared - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/shared)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/shared T2PF1) (reftype2perm/borrow _ set`size/0 T2PF2 B2G2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H1=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

%%% fresh - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/fresh)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/fresh T2PF1) (reftype2perm/borrow _ set`size/0 T2PF2 B2G2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H1=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

%%% shared - unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/shared)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/shared T2PF1) (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute (PiM0+PiH1<=>PiM))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% fresh unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/fresh)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/fresh T2PF1) (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute (PiM0+PiH1<=>PiM))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% shared - unique+fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/shared)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/shared T2PF1) (reftype2perm/unique+fresh T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans3
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute
                              (equiv/transitive
                                (equiv/associate)
                                (equiv/combine (PiM0+PiH1<=>PiM) equiv/reflexive)))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% fresh - unique+fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/fresh)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/fresh T2PF1) (reftype2perm/unique+fresh T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans3
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute
                              (equiv/transitive
                                (equiv/associate)
                                (equiv/combine (PiM0+PiH1<=>PiM) equiv/reflexive)))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% borrow - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 S2G1)
    (reftype2perm/borrow _ set`size/0 T2PF2 S2G2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`eq-transitive M0=M' M'=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.


%%% borrow - unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 B2G1)
    (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute (PiM0+PiH1<=>PiM))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`eq-symmetric M0=M' M'=M0
    <- set`split-respects-eq M'+H1=M set`eq/ M'=M0 set`eq/ M0+H1=M
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% borrow - unique+fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 B2G1)
    (reftype2perm/unique+fresh T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans3
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute
                              (equiv/transitive
                                (equiv/associate)
                                (equiv/combine (PiM0+PiH1<=>PiM) equiv/reflexive)))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`eq-symmetric M0=M' M'=M0
    <- set`split-respects-eq M'+H1=M set`eq/ M'=M0 set`eq/ M0+H1=M
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% unique - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 S2G1 H0=>PiH0)
    (reftype2perm/borrow _ set`size/0 T2PF2 B2G2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/trans5
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive (PiM0+PiH0<=>PiM)))))))
            (implies/equiv equiv/associate)))
        (transform/drop)))
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`split-respects-eq M0+H0=M' M'=M set`eq/ set`eq/ M0+H0=M
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% unique+fresh - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique+fresh T2PF1 S2G1 H0=>PiH0)
    (reftype2perm/borrow _ set`size/0 T2PF2 B2G2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans6
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/associate)
                          (equiv/combine (PiM0+PiH0<=>PiM) equiv/reflexive))))))))
            (implies/equiv equiv/associate)
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`split-respects-eq M0+H0=M' M'=M set`eq/ set`eq/ M0+H0=M
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% unique - unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 B2G1 H0=>PiH0)
    (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute equiv/reflexive)))))))))
            (implies/equiv
              (equiv/transitive5
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)
                (equiv/combine equiv/swap equiv/reflexive)
                (equiv/symmetric equiv/associate)
                (equiv/combine equiv/reflexive
                  (equiv/transitive5
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive equiv/commute PiM0+PiH0<=>PiM')
                      (equiv/reflexive))
                    (equiv/move-to-back-4)
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive equiv/commute PiM'+PiH1<=>PiM)))))))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M'
      M0=>PiM0 H0=>PiH0 PiM' M'=>PiM' PiM0+PiH0<=>PiM'
    <- set`split-implies-permission-combine-converse M'+H1=M
      M'=>PiM' H1=>PiH1 PiM M=>PiM PiM'+PiH1<=>PiM.

%%% unique+fresh - unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique+fresh T2PF1 B2G1 H0=>PiH0)
    (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans3
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute equiv/reflexive)))))))))
            (implies/equiv
              (equiv/transitive5
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)
                (equiv/combine equiv/swap equiv/reflexive)
                (equiv/symmetric equiv/associate)
                (equiv/combine equiv/reflexive
                  (equiv/transitive5
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive3
                        (equiv/commute)
                        (equiv/associate)
                        (equiv/combine PiM0+PiH0<=>PiM' equiv/reflexive))
                      (equiv/reflexive))
                    (equiv/move-to-back-4)
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive equiv/commute
                          (equiv/transitive
                            (equiv/swap)
                            (equiv/combine PiM'+PiH1<=>PiM equiv/reflexive)))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M'
      M0=>PiM0 H0=>PiH0 PiM' M'=>PiM' PiM0+PiH0<=>PiM'
    <- set`split-implies-permission-combine-converse M'+H1=M
      M'=>PiM' H1=>PiH1 PiM M=>PiM PiM'+PiH1<=>PiM.

%%% unique - unique+fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 B2G1 H0=>PiH0)
    (reftype2perm/unique+fresh T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute equiv/reflexive)))))))))
            (implies/equiv
              (equiv/transitive7
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)
                (equiv/combine equiv/swap equiv/reflexive)
                (equiv/symmetric equiv/associate)
                (equiv/combine equiv/reflexive
                  (equiv/transitive5
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive equiv/commute (PiM0+PiH0<=>PiM'))
                      (equiv/reflexive))
                    (equiv/move-to-back-4)
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive3
                          (equiv/commute)
                          (equiv/associate)
                          (equiv/combine
                            (PiM'+PiH1<=>PiM)
                            (equiv/reflexive)))))))
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M'
      M0=>PiM0 H0=>PiH0 PiM' M'=>PiM' PiM0+PiH0<=>PiM'
    <- set`split-implies-permission-combine-converse M'+H1=M
      M'=>PiM' H1=>PiH1 PiM M=>PiM PiM'+PiH1<=>PiM.

%%% unique+fresh - unique+fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique+fresh T2PF1 B2G1 H0=>PiH0)
    (reftype2perm/unique+fresh T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute equiv/reflexive)))))))))
            (implies/equiv
              (equiv/transitive7
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)
                (equiv/combine equiv/swap equiv/reflexive)
                (equiv/symmetric equiv/associate)
                (equiv/combine equiv/reflexive
                  (equiv/transitive5
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive3
                        (equiv/commute)
                        (equiv/associate)
                        (equiv/combine PiM0+PiH0<=>PiM' equiv/reflexive))
                      (equiv/reflexive))
                    (equiv/move-to-back-4)
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/swap-middle)
                          (equiv/combine
                            (equiv/transitive equiv/commute PiM'+PiH1<=>PiM)
                            (equiv/reflexive)))))))
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M'
      M0=>PiM0 H0=>PiH0 PiM' M'=>PiM' PiM0+PiH0<=>PiM'
    <- set`split-implies-permission-combine-converse M'+H1=M
      M'=>PiM' H1=>PiH1 PiM M=>PiM PiM'+PiH1<=>PiM.

%worlds (gtermvar) (reftyping-ok/eq/L1 _ _ _ _ _ _ _ _).
%total { } (reftyping-ok/eq/L1 _ _ _ _ _ _ _ _).


%theorem reftyping-ok/eq
  : forall* {W} {CM} {PM} {B} {PiB} {V0} {PiV0} {V1} {PiV1}
    {E1} {E2} {Out1} {Out2} {RT1} {RT2} {V2} {V3} {V4}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B=>PiB: cxt2perm PM B PiB}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    {TYP1: typing W (PiB , PiV0) E1 Out1}
    {R1=>Out1: result2output CM PM B (result/expr RT1 V1) Out1}
    {TYP2: typing W (PiB , PiV1) E2 Out2}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {R2=>Out2: result2output CM PM B (result/expr RT2 V2) Out2}
    {RCT1: restore-cap-targets V2 RT1 V3}
    {RCT2: restore-cap-targets V3 RT2 V4}
    exists {Out3} {TYP: typing W (PiB , PiV0) (eql E1 E2) Out3}
    {V4=>Out3: result2output CM PM B (result/cond V4) Out3}
    true.

- : reftyping-ok/eq CM-CM CM2PM (B=>PiB:cxt2perm PM B PiB)
    (V0=>PiV0:env2input CM PM B V0 PiV0)
    TYP1 (result2output/expr (B=>PiB1:cxt2perm PM B PiB1)
      (V1=>PiV1':env2input CM PM B V1 PiV1') RTYP1)
    TYP2 (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/expr (B=>PiB2:cxt2perm PM B PiB2)
      (V2=>PiV2:env2input CM PM B V2 PiV2) RTYP2)
    RCT1 RCT2 _
    (tTrans2
      (tEql1
        (tTrans2
          (TYP1)
          (transform/inside [o1]
            (transform/inside [r1]
              (transform/inside [p1]
                (transform/implies
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/identity)
                      (equiv/reorder)
                      (equiv/combine equiv/reflexive
                        (equiv/combine PiB1<=>PiB PiV1'<=>PiV1)))))))))
        (letTyping/exists [o1]
          (letTyping/exists [r1]
            (letTyping/exists [p1]
              (letTyping/base o1
                (tEql2
                  (tTrans2
                    (TYP2' o1 r1 p1)
                    (transform/inside [o2]
                      (transform/inside [r2]
                        (transform/inside [p2]
                          (TRANS o1 r1 p1 o2 r2 p2)))))
                  (letTyping/exists [o2]
                    (letTyping/exists [r2]
                      (letTyping/exists [p2]
                        (letTyping/base o2 (tEql)))))))))))
      (transform/inside [o1]
        (transform/trans3
          (transform/inside [r1]
            (transform/inside [p1]
              (transform/inside [o2]
                (transform/trans
                  (transform/inside [r2]
                    (transform/inside [p2]
                      (transform/cond
                        (bimplies/reflexive)
                        (bimplies/reflexive)
                        (implies/trans
                          (implies/combine implies/nonlinear2empty implies/reflexive)
                          (implies/equiv
                            (equiv/transitive equiv/commute equiv/identity)))
                        (implies/trans
                          (implies/combine implies/nonlinear2empty implies/reflexive)
                          (implies/equiv
                            (equiv/transitive equiv/commute equiv/identity))))))
                  (transform/rem-unused)))))
          (transform/rem-unused))
        (transform/rem-unused)))
      (result2output/exists [o]
        (result2output/exists [r]
          (result2output/exists [p:permission]
            (result2output/cond B=>PiB2 V4=>PiV4))))
    <- cxt2perm-equiv B=>PiB1 B=>PiB predmap`eq/ cxt`eq/ PiB1<=>PiB
    <- env2input-unique V1=>PiV1' V1=>PiV1 env`eq/ PiV1'<=>PiV1
    <- ({o1:object}{r1:object}{p1:permission} typing-frame* TYP2
         (envadd/exists [o1] (envadd/exists [r2] (envadd/exists [p2] envadd/expr)))
         (TYP2' o1 r1 p1))
    <- reftyping-ok/eq/L1 RCT1 RCT2 V2=>PiV2 RTYP1 RTYP2 PiV4 V4=>PiV4 TRANS.

%worlds (gtermvar) (reftyping-ok/eq _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (reftyping-ok/eq _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/not/L
  : forall* {CM} {PM} {B} {Out} {V}
    forall {R=>O: result2output CM PM B (result/cond V) Out}
    exists {Out'} {N: notEnv Out Out'}
    {R=>O': result2output CM PM B (result/cond V) Out'}
    true.

- : reftyping-ok/not/L (result2output/cond B=>PiB V=>PiV)
    _ notEnv/base (result2output/cond B=>PiB V=>PiV).

- : reftyping-ok/not/L (result2output/exists [v] (R=>O v))
    _ (notEnv/exists [v] (NV v)) (result2output/exists [v] (R=>O' v))
    <- ({v} reftyping-ok/not/L (R=>O v) _ (NV v) (R=>O' v)).

%worlds (gtermvar) (reftyping-ok/not/L _ _ _ _).
%total (A) (reftyping-ok/not/L A _ _ _).


%%% AND

%theorem reftyping-ok/and/L
  : forall* {G} {CM} {PM} {B} {V1} {COut1} {PiB} {PiV1}
    forall {B=>PiB: cxt2perm PM B PiB}
    {V=>PiV: env2input CM PM B V1 PiV1}
    {R=>O1: result2output CM PM B (result/cond V1) COut1}
    exists {COut1'} {COut2'} {AND-HELP: andHelp2 G COut1 (PiB , PiV1) COut1'}
    {COut1'=>COut2: transform COut1' COut2'}
    {R=>O: result2output CM PM B (result/cond V1) COut2'}
    true.

- : reftyping-ok/and/L (B=>PiB:cxt2perm PM B PiB)
    (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/exists ([x] R2O x))
    _ _
    (andHelp2/exists [x] (AH x))
    (transform/inside [x] (TRANS x))
    (result2output/exists [x] (R2O' x))
    <- ({x: gterm V} reftyping-ok/and/L B=>PiB V1=>PiV1 (R2O x) _ _ (AH x) (TRANS x) (R2O' x)).

- : reftyping-ok/and/L (B=>PiB:cxt2perm PM B PiB)
    (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/cond (B=>PiB0:cxt2perm PM B PiB0) (V1=>PiV1':env2input CM PM B V1 PiV1'))
    _ _
    (andHelp2/base)
    (transform/cond
      (bimplies/reflexive)
      (bimplies/reflexive)
      (implies/equiv (equiv/combine PiB0<=>PiB PiV1'<=>PiV1))
      (implies/trans
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/equiv (equiv/combine PiB0<=>PiB PiV1'<=>PiV1))
          (implies/reflexive))
        (implies/cond-equal)))
    (result2output/cond B=>PiB V1=>PiV1)
    <- cxt2perm-equiv B=>PiB0 B=>PiB predmap`eq/ cxt`eq/ PiB0<=>PiB
    <- env2input-unique V1=>PiV1' V1=>PiV1 env`eq/ PiV1'<=>PiV1.

%worlds (gtermvar) (reftyping-ok/and/L _ _ _ _ _ _ _ _).
%total (A) (reftyping-ok/and/L _ _ A _ _ _ _ _).


%theorem reftyping-ok/and
  : forall* {W} {CM} {PM} {B} {V1} {C1} {COut1} {PiB} {PiV1} {COut2}
    forall {B=>PiB: cxt2perm PM B PiB}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {R=>O1: result2output CM PM B (result/cond V1) COut1}
    {R=>O1: result2output CM PM B (result/cond V1) COut2}
    {TYP-C1: typing W (PiB , PiV1) C1 COut2}
    exists {COut1'} {COut2'} {AND-HELP: andHelp1 W COut1 C1 COut1'}
    {COut1'=>COut2: transform COut1' COut2'}
    {R=>O: result2output CM PM B (result/cond V1) COut2'}
    true.

- : reftyping-ok/and B=>PiB V1=>PiV1
    (result2output/exists [x] (R2O1 x))
    R2O2 TYP-C1 _ _
    (andHelp1/exists [x] (AH1 x))
    (transform/inside [x] (TRANS x))
    (result2output/exists [x] (R2O x))
    <- ({x} reftyping-ok/and B=>PiB V1=>PiV1 (R2O1 x)
         R2O2 TYP-C1 _ _ (AH1 x) (TRANS x) (R2O x)).

- : reftyping-ok/and (B=>PiB:cxt2perm PM B PiB)
    (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/cond (B=>PiB':cxt2perm PM B PiB')
      (V1=>PiV1':env2input CM PM B V1 PiV1'))
    R2O1 TYP-C1
    _ _
    (andHelp1/base
      (tTrans
        (transform/implies
          (implies/equiv
            (equiv/combine PiB'<=>PiB PiV1'<=>PiV1)))
        (letTyping/base null TYP-C1)
        (transform/reflexive))
      AH2) TRANS R2O
    <- reftyping-ok/and/L B=>PiB' V1=>PiV1' R2O1 _ _ AH2 TRANS R2O
    <- cxt2perm-equiv B=>PiB' B=>PiB predmap`eq/ cxt`eq/ PiB'<=>PiB
    <- env2input-unique V1=>PiV1' V1=>PiV1 env`eq/ PiV1'<=>PiV1.

%worlds (gtermvar) (reftyping-ok/and _ _ _ _ _ _ _ _ _ _).
%total (A) (reftyping-ok/and _ _ A _ _ _ _ _ _ _).


%theorem reftyping-ok/if
  : forall* {W} {CM} {PM} {B} {V1} {E1: expr} {E2} {COut} {PiB} {PiV1} {EOut}
    forall {B=>PiB: cxt2perm PM B PiB}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {R=>O1: result2output CM PM B (result/cond V1) COut}
    {TYP-E1: typing W (PiB , PiV1) E1 EOut}
    {TYP-E2: typing W (PiB , PiV1) E2 EOut}
    exists {EOut'} {TYP-IF: ifTyping W COut E1 E2 EOut'}
    {EOut'=>EOut: transform EOut' EOut}
    true.

- : reftyping-ok/if (B=>PiB:cxt2perm PM B PiB)
    (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/cond (B=>PiB':cxt2perm PM B PiB')
      (V1=>PiV1':env2input CM PM B V1 PiV1'))
    TYP-E1 TYP-E2 _
    (ifTyping/base
      (tTrans
        (transform/implies
          (implies/equiv
            (equiv/combine PiB'<=>PiB PiV1'<=>PiV1)))
        (letTyping/base null TYP-E1)
        (transform/reflexive))
      (tTrans
        (transform/implies
          (implies/equiv
            (equiv/combine PiB'<=>PiB PiV1'<=>PiV1)))
        (letTyping/base null TYP-E2)
        (transform/reflexive)))
    (transform/reflexive)
    <- cxt2perm-equiv B=>PiB' B=>PiB predmap`eq/ cxt`eq/ PiB'<=>PiB
    <- env2input-unique V1=>PiV1' V1=>PiV1 env`eq/ PiV1'<=>PiV1.

- : reftyping-ok/if (B=>PiB:cxt2perm PM B PiB)
    (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/exists [x] (R2O x)) TYP-E1 TYP-E2 _
    (ifTyping/exists [x] (TYP-IF x))
    (transform/trans (transform/inside [x] (TRANS x)) (transform/rem-unused))
    <- ({x} reftyping-ok/if B=>PiB V1=>PiV1 (R2O x) TYP-E1 TYP-E2 _ (TYP-IF x) (TRANS x)).

%worlds (gtermvar) (reftyping-ok/if _ _ _ _ _ _ _ _).
%total (A) (reftyping-ok/if _ _ A _ _ _ _ _).


%%% Theorems about ifNull

%theorem cxt-update-nn-no-effect
  : forall* {B0} {N} {O} {A} {C} {B1} {O0} {NN0} {C0} {N0} {A0}
    forall {B0-L: cxt`lookup B0 N (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 N (cxt-info/ O (ty/ nn/yes A C)) B1}
    {B0-L-N0: cxt`lookup B0 N0 (cxt-info/ O0 (ty/ NN0 A0 C0))}
    exists {NN1} {B1-L-N0: cxt`lookup B1 N0 (cxt-info/ O0 (ty/ NN1 A0 C0))}
    true.

%theorem cxt-update-nn-no-effect/L
  : forall* {B0} {N} {O} {A} {C} {B1} {O0} {NN0} {C0} {N0} {P} {A0}
    forall {B0-L: cxt`lookup B0 N (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 N (cxt-info/ O (ty/ nn/yes A C)) B1}
    {B0-L-N0: cxt`lookup B0 N0 (cxt-info/ O0 (ty/ NN0 A0 C0))}
    {EQ?: nat`eq? N0 N P}
    exists {NN1} {B1-L-N0: cxt`lookup B1 N0 (cxt-info/ O0 (ty/ NN1 A0 C0))}
    true.

- : cxt-update-nn-no-effect/L
    (B0-L:cxt`lookup B0 _ (cxt-info/ O (ty/ nn/may A C)))
    (B0-U:cxt`update B0 _ (cxt-info/ O (ty/ nn/yes A C)) B1)
    (B0-L-N0:cxt`lookup B0 _ (cxt-info/ O0 (ty/ NN0 _ C0)))
    nat`eq?/yes _ B1-L2
    <- cxt`update-implies-lookup B0-U B1-L
    <- cxt`lookup-unique B0-L B0-L-N0 cxt`eq/ nat`eq/ CI-EQ
    <- cxt-info-eq-inversion CI-EQ O-EQ TY-EQ
    <- ty-eq-inversion TY-EQ NN-EQ A-EQ C-EQ
    <- ty-preserves-eq nonnull`eq/ A-EQ C-EQ TY-EQ2
    <- cxt-info-preserves-eq O-EQ TY-EQ2 CI-EQ2
    <- cxt`lookup-respects-eq B1-L cxt`eq/ nat`eq/ CI-EQ2 B1-L2.

- : cxt-update-nn-no-effect/L
    (B0-L:cxt`lookup B0 _ (cxt-info/ O (ty/ nn/may A C)))
    (B0-U:cxt`update B0 _ (cxt-info/ O (ty/ nn/yes A C)) B1)
    (B0-L-N0:cxt`lookup B0 _ (cxt-info/ O0 (ty/ NN0 _ C0)))
    (nat`eq?/no N0<>SN) _ B1-L-N0
    <- cxt`update-preserves-lookup B0-L-N0 B0-U N0<>SN B1-L-N0.

- : cxt-update-nn-no-effect B0-L B0-U B0-L-N0 _  B1-L-N0
    <- nat`eq?-total EQ?
    <- cxt-update-nn-no-effect/L B0-L B0-U B0-L-N0 EQ? _ B1-L-N0.

%worlds (gtermvar) (cxt-update-nn-no-effect/L _ _ _ _ _ _).
%total { } (cxt-update-nn-no-effect/L _ _ _ _ _ _).

%worlds (gtermvar) (cxt-update-nn-no-effect _ _ _ _ _).
%total { } (cxt-update-nn-no-effect _ _ _ _ _).


%theorem reftyping-ok/ifnull/helper/L1/L1
  : forall* {CM} {B0} {B1} {A} {C} {N} {O}
    forall {B0-L: cxt`lookup B0 (s N) (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 (s N) (cxt-info/ O (ty/ nn/yes A C)) B1}
    {CM-B0: clsmap-cxt CM B0}
    exists {CM-B1: clsmap-cxt CM B1}
    true.

- : reftyping-ok/ifnull/helper/L1/L1
    B0-L B0+N+T1=B1 CM-B0 (clsmap-cxt/U CM-B0' (clsmap-ty/ CML) N!<B0' B0'+N+T1=B1)
    <- cxt`lookup-implies-fresh-update B0-L B0' N!<B0' B0'+N+T0=B0
    <- clsmap-cxt/U-inversion CM-B0 N!<B0' B0'+N+T0=B0 CM-B0'
      (clsmap-ty/ CML)
    <- cxt`update-overwrites B0'+N+T0=B0 B0+N+T1=B1 nat`eq/ B0'+N+T1=B1.

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L1/L1 _ _ _ _).
%total { } (reftyping-ok/ifnull/helper/L1/L1 _ _ _ _).


%theorem reftyping-ok/ifnull/helper/L1/L2
  : forall* {CM} {B0} {U} {N} {O} {A} {C} {B1}
    forall {B0-L: cxt`lookup B0 (s N) (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 (s N) (cxt-info/ O (ty/ nn/yes A C)) B1}
    {CM-B0-U: clsmap-cxt-objset CM B0 U}
    exists {CM-B1-U: clsmap-cxt-objset CM B1 U}
    true.

- : reftyping-ok/ifnull/helper/L1/L2 B0-L B0+N+T1=B1
    clsmap-cxt-objset/0 clsmap-cxt-objset/0.

- : reftyping-ok/ifnull/helper/L1/L2 B0-L B0-U
    (clsmap-cxt-objset/U CM-B0-U' B0-L-N0 CML N!<U' U'+N0=U)
    (clsmap-cxt-objset/U CM-B1-U' B1-L-N0 CML N!<U' U'+N0=U)
    <- reftyping-ok/ifnull/helper/L1/L2 B0-L B0-U CM-B0-U' CM-B1-U'
    <- cxt-update-nn-no-effect B0-L B0-U B0-L-N0 _ B1-L-N0.

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L1/L2 _ _ _ _).
%total (A) (reftyping-ok/ifnull/helper/L1/L2 _ _ A _).


%theorem reftyping-ok/ifnull/helper/L1/L3
  : forall* {CM} {B0} {M} {N} {O} {A} {C} {B1}
    forall {B0-L: cxt`lookup B0 (s N) (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 (s N) (cxt-info/ O (ty/ nn/yes A C)) B1}
    {CM-B0-M: clsmap-cxt-capset CM B0 M}
    exists {CM-B1-U: clsmap-cxt-capset CM B1 M}
    true.

- : reftyping-ok/ifnull/helper/L1/L3 B0-L B0-U
    clsmap-cxt-capset/0 clsmap-cxt-capset/0.

- : reftyping-ok/ifnull/helper/L1/L3 B0-L B0-U
    (clsmap-cxt-capset/U CM-B0-M' N+F=K B0-L-N0 NA CML FML N!<M' M'+N0=M)
    (clsmap-cxt-capset/U CM-B1-M' N+F=K B1-L-N0 NA CML FML N!<M' M'+N0=M)
    <- reftyping-ok/ifnull/helper/L1/L3 B0-L B0-U CM-B0-M' CM-B1-M'
    <- cxt-update-nn-no-effect B0-L B0-U B0-L-N0 _ B1-L-N0.

- : reftyping-ok/ifnull/helper/L1/L3 B0-L B0-U
    (clsmap-cxt-capset/z CM-B0-M' N!<M' M'+N0=M)
    (clsmap-cxt-capset/z CM-B1-M' N!<M' M'+N0=M)
    <- reftyping-ok/ifnull/helper/L1/L3 B0-L B0-U CM-B0-M' CM-B1-M'.

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L1/L3 _ _ _ _).
%total (A) (reftyping-ok/ifnull/helper/L1/L3 _ _ A _).


%theorem reftyping-ok/ifnull/helper/L1
  : forall* {CM} {B0} {B1} {A} {C} {N} {O} {V}
    forall {B0-L: cxt`lookup B0 (s N) (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 (s N) (cxt-info/ O (ty/ nn/yes A C)) B1}
    {CM-B0: clsmap-cxt CM B0}
    {CM-B0-V: clsmap-cxt-env CM B0 V}
    exists {CM-B1: clsmap-cxt CM B1}
    {CM-B1-V: clsmap-cxt-env CM B1 V}
    true.

- : reftyping-ok/ifnull/helper/L1 B0-L B0-U CM-B0 (clsmap-cxt-env/ CM-B0-U CM-B0-M)
    CM-B1 (clsmap-cxt-env/ CM-B1-U CM-B1-M)
    <- reftyping-ok/ifnull/helper/L1/L1 B0-L B0-U CM-B0 CM-B1
    <- reftyping-ok/ifnull/helper/L1/L2 B0-L B0-U CM-B0-U CM-B1-U
    <- reftyping-ok/ifnull/helper/L1/L3 B0-L B0-U CM-B0-M CM-B1-M.

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L1 _ _ _ _ _ _).
%total { } (reftyping-ok/ifnull/helper/L1 _ _ _ _ _ _).


%theorem reftyping-ok/ifnull/helper/L2/L1
  : forall* {CM} {PM} {N} {O} {A} {C} {B1} {B0} {U} {PiU}
    forall {B0-L: cxt`lookup B0 (s N) (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 (s N) (cxt-info/ O (ty/ nn/yes A C)) B1}
    {B0+U=>PiU: make-encumbered CM PM B0 U PiU}
    exists {B1+U=>PiU: make-encumbered CM PM B1 U PiU}
    true.

- : reftyping-ok/ifnull/helper/L2/L1 B0-L B0-U make-encumbered/0 make-encumbered/0.

- : reftyping-ok/ifnull/helper/L2/L1 B0-L B0-U
    (make-encumbered/U B0+U'=>PiU' B0-L-N0 CML PML DM FS2P FS UD)
    (make-encumbered/U B1+U'=>PiU' B1-L-N0 CML PML DM FS2P FS UD)
    <- reftyping-ok/ifnull/helper/L2/L1 B0-L B0-U B0+U'=>PiU' B1+U'=>PiU'
    <- cxt-update-nn-no-effect B0-L B0-U B0-L-N0 _ B1-L-N0.

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L2/L1 _ _ _ _).
%total (A) (reftyping-ok/ifnull/helper/L2/L1 _ _ A _).


%theorem reftyping-ok/ifnull/helper/L2/L2
  : forall* {CM} {PM} {N} {O} {A} {C} {B1} {B0} {M} {PiM}
    forall {B0-L: cxt`lookup B0 (s N) (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 (s N) (cxt-info/ O (ty/ nn/yes A C)) B1}
    {B0+M=>PiM: capset2perm CM PM B0 M PiM}
    exists {B1+M=>PiM: capset2perm CM PM B1 M PiM}
    true.

- : reftyping-ok/ifnull/helper/L2/L2 B0-L B0-U capset2perm/0 capset2perm/0.

- : reftyping-ok/ifnull/helper/L2/L2 B0-L B0-U
    (capset2perm/U B0+M'=>PiM' N+F=K B0-L-N0 CF FS UD)
    (capset2perm/U B1+M'=>PiM' N+F=K B1-L-N0 CF FS UD)
    <- reftyping-ok/ifnull/helper/L2/L2 B0-L B0-U B0+M'=>PiM' B1+M'=>PiM'
    <- cxt-update-nn-no-effect B0-L B0-U B0-L-N0 _ B1-L-N0.

- : reftyping-ok/ifnull/helper/L2/L2 B0-L B0-U
    (capset2perm/z B0+M'=>PiM' FS UD) (capset2perm/z B1+M'=>PiM' FS UD)
    <- reftyping-ok/ifnull/helper/L2/L2 B0-L B0-U B0+M'=>PiM' B1+M'=>PiM'.

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L2/L2 _ _ _ _).
%total (A) (reftyping-ok/ifnull/helper/L2/L2 _ _ A _).


%theorem reftyping-ok/ifnull/helper/L2/L3
  : forall*  {N} {O} {A} {C} {B1} {B0} {S} {GF}
    forall {B0-L: cxt`lookup B0 N (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 N (cxt-info/ O (ty/ nn/yes A C)) B1}
    {B0+S=>GF: {x} set2cond B0 x S (GF x)}
    exists {B1+S=>GF: {x} set2cond B1 x S (GF x)}
    true.

- : reftyping-ok/ifnull/helper/L2/L3 B0-L B0-U ([_] set2cond/0) ([_] set2cond/0).

- : reftyping-ok/ifnull/helper/L2/L3 B0-L B0-U
    ([x] set2cond/U (B0+S'=>GF' x) U F
      ((B0-L-N0:{x} cxt`lookup B0 Nx (cxt-info/ (OF x) (ty/ NN0 A C))) x))
    ([x] set2cond/U (B1+S'=>GF' x) U F
      ((B1-L-N0:{x} cxt`lookup B1 Nx (cxt-info/ (OF x) (ty/ NN1 A C))) x))
    <- reftyping-ok/ifnull/helper/L2/L3 B0-L B0-U B0+S'=>GF' B1+S'=>GF'
    <- ({x} cxt-update-nn-no-effect B0-L B0-U (B0-L-N0 x) _ (B1-L-N0 x)).

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L2/L3 _ _ _ _).
%total (A) (reftyping-ok/ifnull/helper/L2/L3 _ _ A _).


%theorem reftyping-ok/ifnull/helper/L2/L4
  : forall* {CM} {PM} {N} {O} {A} {C} {B1} {B0} {RT} {PF}
    forall {B0-L: cxt`lookup B0 (s N) (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 (s N) (cxt-info/ O (ty/ nn/yes A C)) B1}
    {B0+RT=>PF: reftype2perm CM PM B0 RT PF}
    exists {B1+RT=>PF: reftype2perm CM PM B1 RT PF}
    true.

- : reftyping-ok/ifnull/helper/L2/L4 B0-L B0-U
    (reftype2perm/shared T2PF) (reftype2perm/shared T2PF).

- : reftyping-ok/ifnull/helper/L2/L4 B0-L B0-U
    (reftype2perm/borrow SZ-S SZ-M T2PF B0+S2GF)
    (reftype2perm/borrow SZ-S SZ-M T2PF B1+S2GF)
    <- reftyping-ok/ifnull/helper/L2/L3 B0-L B0-U B0+S2GF B1+S2GF.

- : reftyping-ok/ifnull/helper/L2/L4 B0-L B0-U
    (reftype2perm/unique SZ-M T2PF B0+S2GF B0+M2PF)
    (reftype2perm/unique SZ-M T2PF B1+S2GF B1+M2PF)
    <- reftyping-ok/ifnull/helper/L2/L3 B0-L B0-U B0+S2GF B1+S2GF
    <- reftyping-ok/ifnull/helper/L2/L2 B0-L B0-U B0+M2PF B1+M2PF.

- : reftyping-ok/ifnull/helper/L2/L4 B0-L B0-U
    (reftype2perm/unique+fresh T2PF B0+S2GF B0+M2PF)
    (reftype2perm/unique+fresh T2PF B1+S2GF B1+M2PF)
    <- reftyping-ok/ifnull/helper/L2/L3 B0-L B0-U B0+S2GF B1+S2GF
    <- reftyping-ok/ifnull/helper/L2/L2 B0-L B0-U B0+M2PF B1+M2PF.

- : reftyping-ok/ifnull/helper/L2/L4 B0-L B0-U
    (reftype2perm/fresh T2PF) (reftype2perm/fresh T2PF).

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L2/L4 _ _ _ _).
%total { } (reftyping-ok/ifnull/helper/L2/L4 _ _ _ _).


%theorem reftyping-ok/ifnull/helper/L2
  : forall* {CM} {PM} {N} {O} {B0} {B1} {A} {C} {V} {PiV}
    forall {B0-L: cxt`lookup B0 (s N) (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 (s N) (cxt-info/ O (ty/ nn/yes A C)) B1}
    {B0+V=>PiV: env2input CM PM B0 V PiV}
    exists {B1+V=>PiV: env2input CM PM B1 V PiV}
    true.

- : reftyping-ok/ifnull/helper/L2 B0-L B0-U (env2input/ B0+U=>PiU B0+M=>PiM)
    (env2input/ B1+U=>PiU B1+M=>PiM)
    <- reftyping-ok/ifnull/helper/L2/L1 B0-L B0-U B0+U=>PiU B1+U=>PiU
    <- reftyping-ok/ifnull/helper/L2/L2 B0-L B0-U B0+M=>PiM B1+M=>PiM.

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L2 _ _ _ _).
%total { } (reftyping-ok/ifnull/helper/L2 _ _ _ _).


%theorem reftyping-ok/ifnull/helper/L3/LL
  : forall* {PM} {A} {C} {PF}
    forall {T2PF: ty2perm PM (ty/ nn/may A C) PF}
    exists {PF2} {T2PF: ty2perm PM (ty/ nn/yes A C) PF2}
    {EQV: {x} equiv ((unitperm (nonlinear (neg (objequal x null)))) , (PF x)) (PF2 x)}
    true.

- : reftyping-ok/ifnull/helper/L3/LL
    (ty2perm/ PML nn2perm/may A2P) _ (ty2perm/ PML nn2perm/yes A2P) ([_] equiv/reflexive).

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L3/LL _ _ _ _).
%total { } (reftyping-ok/ifnull/helper/L3/LL _ _ _ _).


%theorem reftyping-ok/ifnull/helper/L3/L
  : forall* {PM} {A} {C} {PF}
    forall {T2PF: ty2perm2 PM (ty/ nn/may A C) PF}
    exists {PF2} {T2PF: ty2perm2 PM (ty/ nn/yes A C) PF2}
    {EQV: {x} equiv ((unitperm (nonlinear (neg (objequal x null)))) , (PF x)) (PF2 x)}
    true.

- : reftyping-ok/ifnull/helper/L3/L (ty2perm2/borrow T2PF) _ (ty2perm2/borrow T2PF2) EQV
    <- reftyping-ok/ifnull/helper/L3/LL T2PF _ T2PF2 EQV.

- : reftyping-ok/ifnull/helper/L3/L (ty2perm2/unique T2PF) _ (ty2perm2/unique T2PF2) EQV
    <- reftyping-ok/ifnull/helper/L3/LL T2PF _ T2PF2 EQV.

- : reftyping-ok/ifnull/helper/L3/L (ty2perm2/shared T2PF) _ (ty2perm2/shared T2PF2) EQV
    <- reftyping-ok/ifnull/helper/L3/LL T2PF _ T2PF2 EQV.

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L3/L _ _ _ _).
%total { } (reftyping-ok/ifnull/helper/L3/L _ _ _ _).


%theorem reftyping-ok/ifnull/helper/L3
  : forall* {PM} {B0} {N} {O} {A} {C} {B1} {PiB0}
    forall {B0-L: cxt`lookup B0 (s N) (cxt-info/ O (ty/ nn/may A C))}
    {B0-U: cxt`update B0 (s N) (cxt-info/ O (ty/ nn/yes A C)) B1}
    {B0=>PiB0: cxt2perm PM B0 PiB0}
    exists {PiB1} {B1=>PiB1: cxt2perm PM B1 PiB1}
    {EQV: equiv ((unitperm (nonlinear (neg (objequal O null)))) , PiB0) PiB1}
    true.

- : reftyping-ok/ifnull/helper/L3
    B0-L B0+N+T1=B1 B0=>PiB0 _
    (cxt2perm/U B0'=>PiB0' N!<B0' B0'+N+T1=B1 T2PF2)
    (equiv/transitive3
      (equiv/combine equiv/reflexive EQV0)
      (equiv/associate)
      (equiv/combine (EQV1 _) equiv/reflexive))
    <- cxt`lookup-implies-fresh-update B0-L B0' N!<B0' B0'+N+T0=B0
    <- cxt`update-overwrites B0'+N+T0=B0 B0+N+T1=B1 nat`eq/ B0'+N+T1=B1
    <- cxt2perm/U-inversion B0=>PiB0 N!<B0' B0'+N+T0=B0 PiB0' B0'=>PiB0' _ T2PF EQV0
    <- reftyping-ok/ifnull/helper/L3/L T2PF _ T2PF2 EQV1.

%worlds (gtermvar) (reftyping-ok/ifnull/helper/L3 _ _ _ _ _ _).
%total { } (reftyping-ok/ifnull/helper/L3 _ _ _ _ _ _).


%theorem reftyping-ok/loop/helper/L1
  : forall* {CM} {PM} {B} {H} {PF} {K} {PiK} {K'} {RT}
    forall {RT2P: reftype2perm CM PM B RT PF}
    {K=>PiK: capset2perm CM PM B K PiK}
    {RPC: restore-cap-targets (env/ H K) RT (env/ H K')}
    exists {PF'} {PiK'} {K'=>PiK': capset2perm CM PM B K' PiK'}
    {IMP: {o}{r}{v} implies (PiK , (PF o r v)) (PiK' , (PF' o r v))}
    true.

- : reftyping-ok/loop/helper/L1
    (reftype2perm/shared _) K=>PiK
    restore-cap-targets/shared _ _ K=>PiK ([_][_][_] implies/reflexive).

- : reftyping-ok/loop/helper/L1
    (reftype2perm/borrow _ set`size/0 _ _) K=>PiK
    (restore-cap-targets/unique K+E=K') _ _ K'=>PiK ([_][_][_] implies/reflexive)
    <- set`combine-empty-right K+E=K' K=K'
    <- capset2perm-respects-eq K=>PiK clsmap`eq/ predmap`eq/ cxt`eq/ K=K' permission`eq/ K'=>PiK.

- : reftyping-ok/loop/helper/L1
    (reftype2perm/fresh _) K=>PiK
    (restore-cap-targets/fresh) _ _ K=>PiK ([_][_][_] implies/reflexive).

- : reftyping-ok/loop/helper/L1
    (reftype2perm/unique _ _ _ K2=>PiK2) K=>PiK
    (restore-cap-targets/unique (K+K2=K':set`combine K K2 K'))
    _ _ K'=>PiK'
    ([o][r][v] implies/trans4
      (implies/combine implies/reflexive
        (implies/combine implies/reflexive
          (implies/linear-modus-ponens)))
      (implies/reorder)
      (implies/combine implies/reflexive (implies/equiv PiK+PiK2<=>PiK'))
      (implies/commute))
    <- set`split-implies-permission-combine-converse K+K2=K' K=>PiK K2=>PiK2
      PiK' K'=>PiK' PiK+PiK2<=>PiK'.

- : reftyping-ok/loop/helper/L1
    (reftype2perm/unique+fresh _ _ K2=>PiK2) K=>PiK
    (restore-cap-targets/unique (K+K2=K':set`combine K K2 K'))
    _ _ K'=>PiK'
    ([o][r][v] implies/trans4
      (implies/combine implies/reflexive
        (implies/trans
          (implies/combine implies/reflexive
            (implies/trans
              (implies/linear-modus-ponens)
              (implies/commute)))
          (implies/associate)))
      (implies/reorder)
      (implies/combine implies/reflexive (implies/equiv PiK+PiK2<=>PiK'))
      (implies/commute))
    <- set`split-implies-permission-combine-converse K+K2=K' K=>PiK K2=>PiK2
      PiK' K'=>PiK' PiK+PiK2<=>PiK'.

%worlds (gtermvar) (reftyping-ok/loop/helper/L1 _ _ _ _ _ _ _).
%total { } (reftyping-ok/loop/helper/L1 _ _ _ _ _ _ _).


%theorem reftyping-ok/loop/helper/L2
  : forall* {CM} {PM} {B} {W} {PiB0} {V1} {COut} {PiV1'} {PiB2} {E} {PF}
    forall {B=>PiB0: cxt2perm PM B PiB0}
    {Rslt-Out: result2output CM PM B (result/cond V1) COut}
    {V1=>PiV1': env2input CM PM B V1 PiV1'}
    {PiB0<=>PiB2: equiv PiB0 PiB2}
    {TYP-E: typing W (combine PiB2 PiV1') E
            (output/exists [o:object]
              (output/exists [r:object]
                (output/exists [v:permission]
                  (output/expr o (PF o r v)))))}
    exists {Out1} {Out1'} {Out2} {TYP: whileTyping W COut E Out1 Out2}
    {DV: discard-value Out1 Out1'}
    {TRANS12: transform Out1'
         (output/exists [o]
           (output/exists [r]
             (output/exists [v:permission]
               (output/expr null (PF o r v)))))}
    {TRANS2: transform Out2 (output/expr null (combine PiB0 PiV1'))}
    true.

- : reftyping-ok/loop/helper/L2 (B=>PiB0:cxt2perm PM B PiB0)
    (result2output/cond (B=>PiB0':cxt2perm PM B PiB0')
      (V1=>PiV1:env2input CM PM B V1 PiV1))
    (V1=>PiV1':env2input CM PM B V1 PiV1')
    (PiB0<=>PiB2:equiv PiB0 PiB2) TYP-E _ _ _
    (whileTyping/base
      (tTrans
        (transform/implies
          (implies/equiv
            (equiv/combine (equiv/transitive PiB0'<=>PiB0 PiB0<=>PiB2)
              (PiV1<=>PiV1'))))
        (letTyping/base null TYP-E)
        (transform/reflexive)))
    (discard-value/exists [o]
      (discard-value/exists [r]
        (discard-value/exists [v]
          (discard-value/base))))
    (transform/reflexive)
    (transform/implies
      (implies/equiv (equiv/combine PiB0'<=>PiB0 PiV1<=>PiV1')))
    <- cxt2perm-equiv B=>PiB0' B=>PiB0 predmap`eq/ cxt`eq/ PiB0'<=>PiB0
    <- env2input-unique V1=>PiV1 V1=>PiV1' env`eq/ PiV1<=>PiV1'.

- : reftyping-ok/loop/helper/L2 (B=>PiB0:cxt2perm PM B PiB0)
    (result2output/exists ([x] Rslt=>Out x))
    (V1=>PiV1':env2input CM PM B V1 PiV1')
    (PiB0<=>PiB2:equiv PiB0 PiB2) TYP-E _ _ _
    (whileTyping/exists [x]
      (TYP-W x))
    (discard-value/exists [x] (DV x))
    (transform/trans (transform/inside [x] (TRANS1 x)) (transform/rem-unused))
    (transform/trans (transform/inside [x] (TRANS2 x)) transform/rem-unused)
    <- ({x} reftyping-ok/loop/helper/L2 B=>PiB0 (Rslt=>Out x)
         V1=>PiV1' PiB0<=>PiB2 TYP-E _ _ _ (TYP-W x) (DV x) (TRANS1 x) (TRANS2 x)).

%worlds (gtermvar) (reftyping-ok/loop/helper/L2 _ _ _ _ _ _ _ _ _ _ _ _).
%total (A) (reftyping-ok/loop/helper/L2 _ A _ _ _ _ _ _ _ _ _ _).