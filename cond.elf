%theorem reftyping-ok/eq/L1
  : forall* {CM} {PM} {B} {NN1} {C1} {G1} {PiB}
    {NN2} {C2} {G2} {V0} {V1} {V2} {PF1} {PF2} {PiV0}
    forall {RCT1: restore-cap-targets V0 G1 V1}
    {RCT2: restore-cap-targets V1 G2 V2}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    {RT1=>PF1: reftype2perm CM PM B (reftype/ NN1 C1 G1) PF1}
    {RT2=>PF2: reftype2perm CM PM B (reftype/ NN2 C2 G2) PF2}
    exists {PiV2} {V2=>PiV2: env2input CM PM B V2 PiV2}
    {TRANS: {o1}{r1}{o2}{r2}
            transform
            (output/expr o2
              (combine (PF1 o1 r1)
                (combine
                  (combine PiB (combine (PF2 o2 r2) PiV0))
                  (empty))))
            (output/expr o2
              (combine PiB PiV2))}
    true.

- : reftyping-ok/eq/L1
    restore-cap-targets/shared restore-cap-targets/shared
    (V0=>PiV0:env2input CM PM B V0 PiV0)
    (reftype2perm/shared T2PF1) (reftype2perm/shared T2PF2)
    _ V0=>PiV0
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop))).

- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 set/0 M))
    (restore-cap-targets/shared)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/fresh T2PF1) (reftype2perm/shared T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 set/0 M))
    (restore-cap-targets/shared)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 S2G1) (reftype2perm/shared T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 H0 M))
    (restore-cap-targets/shared)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 S2G1 H0=>PiH0) (reftype2perm/shared T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/trans5
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive (PiM0+PiH0<=>PiM)))))))
            (implies/equiv equiv/associate)))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

- : reftyping-ok/eq/L1
    (restore-cap-targets/shared)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/shared T2PF1) (reftype2perm/fresh T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H1=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

- : reftyping-ok/eq/L1
    (restore-cap-targets/shared)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/shared T2PF1) (reftype2perm/borrow _ set`size/0 T2PF2 B2G2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H1=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

- : reftyping-ok/eq/L1
    (restore-cap-targets/shared)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/shared T2PF1) (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute (PiM0+PiH1<=>PiM))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% fresh - fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/fresh T2PF1) (reftype2perm/fresh T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`eq-transitive M0=M' M'=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

%%% fresh - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/fresh T2PF1) (reftype2perm/borrow _ set`size/0 T2PF2 B2G2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`eq-transitive M0=M' M'=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

%%% fresh - unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/fresh T2PF1) (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute (PiM0+PiH1<=>PiM))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`eq-symmetric M0=M' M'=M0
    <- set`split-respects-eq M'+H1=M set`eq/ M'=M0 set`eq/ M0+H1=M
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% borrow - fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 S2G1) (reftype2perm/fresh T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`eq-transitive M0=M' M'=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

%%% borrow - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 S2G1)
    (reftype2perm/borrow _ set`size/0 T2PF2 S2G2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`eq-transitive M0=M' M'=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.


%%% borrow - unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 B2G1)
    (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute (PiM0+PiH1<=>PiM))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`eq-symmetric M0=M' M'=M0
    <- set`split-respects-eq M'+H1=M set`eq/ M'=M0 set`eq/ M0+H1=M
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% unique - fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 S2G1 H0=>PiH0)
    (reftype2perm/fresh T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/trans5
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive (PiM0+PiH0<=>PiM)))))))
            (implies/equiv equiv/associate)))
        (transform/drop)))
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`split-respects-eq M0+H0=M' M'=M set`eq/ set`eq/ M0+H0=M
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% unique - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 S2G1 H0=>PiH0)
    (reftype2perm/borrow _ set`size/0 T2PF2 B2G2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/trans5
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive (PiM0+PiH0<=>PiM)))))))
            (implies/equiv equiv/associate)))
        (transform/drop)))
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`split-respects-eq M0+H0=M' M'=M set`eq/ set`eq/ M0+H0=M
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% unique - unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 B2G1 H0=>PiH0)
    (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][o2][r2]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute equiv/reflexive)))))))))
            (implies/equiv
              (equiv/transitive5
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)
                (equiv/combine equiv/swap equiv/reflexive)
                (equiv/symmetric equiv/associate)
                (equiv/combine equiv/reflexive
                  (equiv/transitive5
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive equiv/commute PiM0+PiH0<=>PiM')
                      (equiv/reflexive))
                    (equiv/move-to-back-4)
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive equiv/commute PiM'+PiH1<=>PiM)))))))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M'
      M0=>PiM0 H0=>PiH0 PiM' M'=>PiM' PiM0+PiH0<=>PiM'
    <- set`split-implies-permission-combine-converse M'+H1=M
      M'=>PiM' H1=>PiH1 PiM M=>PiM PiM'+PiH1<=>PiM.

%worlds (objvar) (reftyping-ok/eq/L1 _ _ _ _ _ _ _ _).
%total { } (reftyping-ok/eq/L1 _ _ _ _ _ _ _ _).


%theorem reftyping-ok/eq
  : forall* {W} {CM} {PM} {B} {PiB} {V0} {PiV0} {V1} {PiV1}
    {E1} {E2} {Out1} {Out2} {NN1} {NN2} {C1} {C2} {G1} {G2} {V2} {V3} {V4}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B=>PiB: cxt2perm PM B PiB}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    {TYP1: typing W (PiB , PiV0) E1 Out1}
    {R1=>Out1: result2output CM PM B (result/expr (reftype/ NN1 C1 G1) V1) Out1}
    {TYP2: typing W (PiB , PiV1) E2 Out2}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {R2=>Out2: result2output CM PM B (result/expr (reftype/ NN2 C2 G2) V2) Out2}
    {RCT1: restore-cap-targets V2 G1 V3}
    {RCT2: restore-cap-targets V3 G2 V4}
    exists {Out3} {TYP: typing W (PiB , PiV0) (eql E1 E2) Out3}
    {V4=>Out3: result2output CM PM B (result/cond V4) Out3}
    true.

- : reftyping-ok/eq CM-CM CM2PM (B=>PiB:cxt2perm PM B PiB)
    (V0=>PiV0:env2input CM PM B V0 PiV0)
    TYP1 (result2output/expr (B=>PiB1:cxt2perm PM B PiB1)
      (V1=>PiV1':env2input CM PM B V1 PiV1') RTYP1)
    TYP2 (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/expr (B=>PiB2:cxt2perm PM B PiB2)
      (V2=>PiV2:env2input CM PM B V2 PiV2) RTYP2)
    RCT1 RCT2 _
    (tTrans2
      (tEql1
        (tTrans2
          (TYP1)
          (transform/inside [o1]
            (transform/inside [r1]
              (transform/implies
                (implies/equiv
                  (equiv/transitive3
                    (equiv/identity)
                    (equiv/reorder)
                    (equiv/combine equiv/reflexive
                      (equiv/combine PiB1<=>PiB PiV1'<=>PiV1))))))))
        (letTyping/exists [o1]
          (letTyping/exists [r1]
            (letTyping/base o1
              (tEql2
                (tTrans2
                  (TYP2' o1 r1)
                  (transform/inside [o2]
                    (transform/inside [r2]
                      (TRANS o1 r1 o2 r2))))
                (letTyping/exists [o2]
                  (letTyping/exists [r2]
                    (letTyping/base o2 (tEql)))))))))
      (transform/inside [o1]
        (transform/trans
          (transform/inside [r1]
            (transform/inside [o2]
              (transform/trans
                (transform/inside [r2]
                  (transform/cond
                    (bimplies/reflexive)
                    (bimplies/reflexive)
                    (implies/trans
                      (implies/combine implies/nonlinear2empty implies/reflexive)
                      (implies/equiv
                        (equiv/transitive equiv/commute equiv/identity)))
                    (implies/trans
                      (implies/combine implies/nonlinear2empty implies/reflexive)
                      (implies/equiv
                        (equiv/transitive equiv/commute equiv/identity)))))
                (transform/rem-unused))))
          (transform/rem-unused))))
      (result2output/exists [o]
        (result2output/exists [r]
          (result2output/cond B=>PiB2 V4=>PiV4)))
    <- cxt2perm-equiv B=>PiB1 B=>PiB predmap`eq/ cxt`eq/ PiB1<=>PiB
    <- env2input-unique V1=>PiV1' V1=>PiV1 env`eq/ PiV1'<=>PiV1
    <- ({o1:object}{r1:object} typing-frame* TYP2
         (envadd/exists [o1] (envadd/exists [r2] envadd/expr)) (TYP2' o1 r1))
    <- reftyping-ok/eq/L1 RCT1 RCT2 V2=>PiV2 RTYP1 RTYP2 PiV4 V4=>PiV4 TRANS.

%worlds (objvar) (reftyping-ok/eq _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (reftyping-ok/eq _ _ _ _ _ _ _ _ _ _ _ _ _ _).