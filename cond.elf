%theorem reftyping-ok/eq/L1
  : forall* {CM} {PM} {B} {NN1} {C1} {G1} {PiB}
    {NN2} {C2} {G2} {V0} {V1} {V2} {PF1} {PF2} {PiV0}
    forall {RCT1: restore-cap-targets V0 G1 V1}
    {RCT2: restore-cap-targets V1 G2 V2}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    {RT1=>PF1: reftype2perm CM PM B (reftype/ NN1 C1 G1) PF1}
    {RT2=>PF2: reftype2perm CM PM B (reftype/ NN2 C2 G2) PF2}
    exists {PiV2} {V2=>PiV2: env2input CM PM B V2 PiV2}
    {TRANS: {o1}{r1}{p1}{o2}{r2}{p2}
            transform
            (output/expr o2
              (combine (PF1 o1 r1 p1)
                (combine
                  (combine PiB (combine (PF2 o2 r2 p2) PiV0))
                  (empty))))
            (output/expr o2
              (combine PiB PiV2))}
    true.

%%% shared - shared
- : reftyping-ok/eq/L1
    restore-cap-targets/shared restore-cap-targets/shared
    (V0=>PiV0:env2input CM PM B V0 PiV0)
    (reftype2perm/shared T2PF1) (reftype2perm/shared T2PF2)
    _ V0=>PiV0
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop))).

%%% borrow - shared
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 set/0 M))
    (restore-cap-targets/shared)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 S2G1) (reftype2perm/shared T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

%%% unique - shared
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 H0 M))
    (restore-cap-targets/shared)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 S2G1 H0=>PiH0) (reftype2perm/shared T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/trans5
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive (PiM0+PiH0<=>PiM)))))))
            (implies/equiv equiv/associate)))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% unique+fresh - shared
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M:set`combine M0 H0 M))
    (restore-cap-targets/shared)
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique+fresh T2PF1 S2G1 H0=>PiH0) (reftype2perm/shared T2PF2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans6
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/associate)
                          (equiv/combine (PiM0+PiH0<=>PiM) equiv/reflexive))))))))
            (implies/equiv equiv/associate)
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% shared - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/shared)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/shared T2PF1) (reftype2perm/borrow _ set`size/0 T2PF2 B2G2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H1=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.

%%% shared - unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/shared)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/shared T2PF1) (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute (PiM0+PiH1<=>PiM))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% shared - unique+fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/shared)
    (restore-cap-targets/unique (M0+H1=M:set`combine M0 H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/shared T2PF1) (reftype2perm/unique+fresh T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans3
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute
                              (equiv/transitive
                                (equiv/associate)
                                (equiv/combine (PiM0+PiH1<=>PiM) equiv/reflexive)))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% borrow - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 S2G1)
    (reftype2perm/borrow _ set`size/0 T2PF2 S2G2)
    _ (env2input/ U0=>PiU0 M=>PiM0)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/equiv
            (equiv/transitive3
              (equiv/combine equiv/reflexive equiv/identity)
              (equiv/combine equiv/reflexive equiv/reorder)
              (equiv/associate))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`eq-transitive M0=M' M'=M M0=M
    <- capset2perm-respects-eq M0=>PiM0 clsmap`eq/ predmap`eq/
      cxt`eq/ M0=M permission`eq/ M=>PiM0.


%%% borrow - unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 B2G1)
    (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute (PiM0+PiH1<=>PiM))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`eq-symmetric M0=M' M'=M0
    <- set`split-respects-eq M'+H1=M set`eq/ M'=M0 set`eq/ M0+H1=M
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% borrow - unique+fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 set/0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/borrow _ set`size/0 T2PF1 B2G1)
    (reftype2perm/unique+fresh T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans3
            (implies/combine implies/reflexive
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute
                              (equiv/transitive
                                (equiv/associate)
                                (equiv/combine (PiM0+PiH1<=>PiM) equiv/reflexive)))))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`combine-empty-right M0+H0=M' M0=M'
    <- set`eq-symmetric M0=M' M'=M0
    <- set`split-respects-eq M'+H1=M set`eq/ M'=M0 set`eq/ M0+H1=M
    <- set`split-implies-permission-combine-converse M0+H1=M
      M0=>PiM0 H1=>PiH1 PiM M=>PiM PiM0+PiH1<=>PiM.

%%% unique - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 S2G1 H0=>PiH0)
    (reftype2perm/borrow _ set`size/0 T2PF2 B2G2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/trans5
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive (PiM0+PiH0<=>PiM)))))))
            (implies/equiv equiv/associate)))
        (transform/drop)))
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`split-respects-eq M0+H0=M' M'=M set`eq/ set`eq/ M0+H0=M
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% unique+fresh - borrow
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' set/0 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique+fresh T2PF1 S2G1 H0=>PiH0)
    (reftype2perm/borrow _ set`size/0 T2PF2 B2G2)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans6
            (implies/equiv
              (equiv/combine equiv/reflexive equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/equiv
                (equiv/transitive3
                  (equiv/move-to-back-5)
                  (equiv/reorder)
                  (equiv/combine equiv/reflexive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/associate)
                          (equiv/combine (PiM0+PiH0<=>PiM) equiv/reflexive))))))))
            (implies/equiv equiv/associate)
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`combine-empty-right M'+H1=M M'=M
    <- set`split-respects-eq M0+H0=M' M'=M set`eq/ set`eq/ M0+H0=M
    <- set`split-implies-permission-combine-converse M0+H0=M
      M0=>PiM0 H0=>PiH0 PiM M=>PiM PiM0+PiH0<=>PiM.

%%% unique - unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 B2G1 H0=>PiH0)
    (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][_][o2][r2][_]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute equiv/reflexive)))))))))
            (implies/equiv
              (equiv/transitive5
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)
                (equiv/combine equiv/swap equiv/reflexive)
                (equiv/symmetric equiv/associate)
                (equiv/combine equiv/reflexive
                  (equiv/transitive5
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive equiv/commute PiM0+PiH0<=>PiM')
                      (equiv/reflexive))
                    (equiv/move-to-back-4)
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive equiv/commute PiM'+PiH1<=>PiM)))))))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M'
      M0=>PiM0 H0=>PiH0 PiM' M'=>PiM' PiM0+PiH0<=>PiM'
    <- set`split-implies-permission-combine-converse M'+H1=M
      M'=>PiM' H1=>PiH1 PiM M=>PiM PiM'+PiH1<=>PiM.

%%% unique+fresh - unique
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique+fresh T2PF1 B2G1 H0=>PiH0)
    (reftype2perm/unique _ T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans3
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute equiv/reflexive)))))))))
            (implies/equiv
              (equiv/transitive5
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)
                (equiv/combine equiv/swap equiv/reflexive)
                (equiv/symmetric equiv/associate)
                (equiv/combine equiv/reflexive
                  (equiv/transitive5
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive3
                        (equiv/commute)
                        (equiv/associate)
                        (equiv/combine PiM0+PiH0<=>PiM' equiv/reflexive))
                      (equiv/reflexive))
                    (equiv/move-to-back-4)
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive equiv/commute
                          (equiv/transitive
                            (equiv/swap)
                            (equiv/combine PiM'+PiH1<=>PiM equiv/reflexive)))))))))
            (implies/equiv
              (equiv/transitive
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M'
      M0=>PiM0 H0=>PiH0 PiM' M'=>PiM' PiM0+PiH0<=>PiM'
    <- set`split-implies-permission-combine-converse M'+H1=M
      M'=>PiM' H1=>PiH1 PiM M=>PiM PiM'+PiH1<=>PiM.

%%% unique - unique+fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique _ T2PF1 B2G1 H0=>PiH0)
    (reftype2perm/unique+fresh T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute equiv/reflexive)))))))))
            (implies/equiv
              (equiv/transitive7
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)
                (equiv/combine equiv/swap equiv/reflexive)
                (equiv/symmetric equiv/associate)
                (equiv/combine equiv/reflexive
                  (equiv/transitive5
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive equiv/commute (PiM0+PiH0<=>PiM'))
                      (equiv/reflexive))
                    (equiv/move-to-back-4)
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive3
                          (equiv/commute)
                          (equiv/associate)
                          (equiv/combine
                            (PiM'+PiH1<=>PiM)
                            (equiv/reflexive)))))))
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M'
      M0=>PiM0 H0=>PiH0 PiM' M'=>PiM' PiM0+PiH0<=>PiM'
    <- set`split-implies-permission-combine-converse M'+H1=M
      M'=>PiM' H1=>PiH1 PiM M=>PiM PiM'+PiH1<=>PiM.

%%% unique+fresh - unique+fresh
- : reftyping-ok/eq/L1
    (restore-cap-targets/unique (M0+H0=M':set`combine M0 H0 M'))
    (restore-cap-targets/unique (M'+H1=M:set`combine M' H1 M))
    (env2input/ (U0=>PiU0:make-encumbered CM PM B U0 PiU0)
      (M0=>PiM0:capset2perm CM PM B M0 PiM0))
    (reftype2perm/unique+fresh T2PF1 B2G1 H0=>PiH0)
    (reftype2perm/unique+fresh T2PF2 B2G2 H1=>PiH1)
    _ (env2input/ U0=>PiU0 M=>PiM)
    ([o1][r1][p1][o2][r2][p2]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/combine implies/reflexive implies/linear-modus-ponens)
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/combine implies/reflexive
                  (implies/trans3
                    (implies/combine
                      (implies/combine implies/reflexive implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/transitive
                          (equiv/reorder)
                          (equiv/combine equiv/reflexive
                            (equiv/transitive equiv/commute equiv/reflexive)))))))))
            (implies/equiv
              (equiv/transitive7
                (equiv/combine equiv/reflexive equiv/reorder)
                (equiv/associate)
                (equiv/combine equiv/swap equiv/reflexive)
                (equiv/symmetric equiv/associate)
                (equiv/combine equiv/reflexive
                  (equiv/transitive5
                    (equiv/combine equiv/reflexive equiv/roll3)
                    (equiv/associate)
                    (equiv/combine
                      (equiv/transitive3
                        (equiv/commute)
                        (equiv/associate)
                        (equiv/combine PiM0+PiH0<=>PiM' equiv/reflexive))
                      (equiv/reflexive))
                    (equiv/move-to-back-4)
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/swap-middle)
                          (equiv/combine
                            (equiv/transitive equiv/commute PiM'+PiH1<=>PiM)
                            (equiv/reflexive)))))))
                (equiv/combine equiv/reflexive
                  (equiv/transitive
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute))
                    (equiv/roll3)))
                (equiv/associate)))))
        (transform/drop)))
    <- set`split-implies-permission-combine-converse M0+H0=M'
      M0=>PiM0 H0=>PiH0 PiM' M'=>PiM' PiM0+PiH0<=>PiM'
    <- set`split-implies-permission-combine-converse M'+H1=M
      M'=>PiM' H1=>PiH1 PiM M=>PiM PiM'+PiH1<=>PiM.

%worlds (gtermvar) (reftyping-ok/eq/L1 _ _ _ _ _ _ _ _).
%total { } (reftyping-ok/eq/L1 _ _ _ _ _ _ _ _).


%theorem reftyping-ok/eq
  : forall* {W} {CM} {PM} {B} {PiB} {V0} {PiV0} {V1} {PiV1}
    {E1} {E2} {Out1} {Out2} {NN1} {NN2} {C1} {C2} {G1} {G2} {V2} {V3} {V4}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B=>PiB: cxt2perm PM B PiB}
    {V0=>PiV0: env2input CM PM B V0 PiV0}
    {TYP1: typing W (PiB , PiV0) E1 Out1}
    {R1=>Out1: result2output CM PM B (result/expr (reftype/ NN1 C1 G1) V1) Out1}
    {TYP2: typing W (PiB , PiV1) E2 Out2}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {R2=>Out2: result2output CM PM B (result/expr (reftype/ NN2 C2 G2) V2) Out2}
    {RCT1: restore-cap-targets V2 G1 V3}
    {RCT2: restore-cap-targets V3 G2 V4}
    exists {Out3} {TYP: typing W (PiB , PiV0) (eql E1 E2) Out3}
    {V4=>Out3: result2output CM PM B (result/cond V4) Out3}
    true.

- : reftyping-ok/eq CM-CM CM2PM (B=>PiB:cxt2perm PM B PiB)
    (V0=>PiV0:env2input CM PM B V0 PiV0)
    TYP1 (result2output/expr (B=>PiB1:cxt2perm PM B PiB1)
      (V1=>PiV1':env2input CM PM B V1 PiV1') RTYP1)
    TYP2 (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/expr (B=>PiB2:cxt2perm PM B PiB2)
      (V2=>PiV2:env2input CM PM B V2 PiV2) RTYP2)
    RCT1 RCT2 _
    (tTrans2
      (tEql1
        (tTrans2
          (TYP1)
          (transform/inside [o1]
            (transform/inside [r1]
              (transform/inside [p1]
                (transform/implies
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/identity)
                      (equiv/reorder)
                      (equiv/combine equiv/reflexive
                        (equiv/combine PiB1<=>PiB PiV1'<=>PiV1)))))))))
        (letTyping/exists [o1]
          (letTyping/exists [r1]
            (letTyping/exists [p1]
              (letTyping/base o1
                (tEql2
                  (tTrans2
                    (TYP2' o1 r1 p1)
                    (transform/inside [o2]
                      (transform/inside [r2]
                        (transform/inside [p2]
                          (TRANS o1 r1 p1 o2 r2 p2)))))
                  (letTyping/exists [o2]
                    (letTyping/exists [r2]
                      (letTyping/exists [p2]
                        (letTyping/base o2 (tEql)))))))))))
      (transform/inside [o1]
        (transform/trans3
          (transform/inside [r1]
            (transform/inside [p1]
              (transform/inside [o2]
                (transform/trans
                  (transform/inside [r2]
                    (transform/inside [p2]
                      (transform/cond
                        (bimplies/reflexive)
                        (bimplies/reflexive)
                        (implies/trans
                          (implies/combine implies/nonlinear2empty implies/reflexive)
                          (implies/equiv
                            (equiv/transitive equiv/commute equiv/identity)))
                        (implies/trans
                          (implies/combine implies/nonlinear2empty implies/reflexive)
                          (implies/equiv
                            (equiv/transitive equiv/commute equiv/identity))))))
                  (transform/rem-unused)))))
          (transform/rem-unused))
        (transform/rem-unused)))
      (result2output/exists [o]
        (result2output/exists [r]
          (result2output/exists [p:permission]
            (result2output/cond B=>PiB2 V4=>PiV4))))
    <- cxt2perm-equiv B=>PiB1 B=>PiB predmap`eq/ cxt`eq/ PiB1<=>PiB
    <- env2input-unique V1=>PiV1' V1=>PiV1 env`eq/ PiV1'<=>PiV1
    <- ({o1:object}{r1:object}{p1:permission} typing-frame* TYP2
         (envadd/exists [o1] (envadd/exists [r2] (envadd/exists [p2] envadd/expr)))
         (TYP2' o1 r1 p1))
    <- reftyping-ok/eq/L1 RCT1 RCT2 V2=>PiV2 RTYP1 RTYP2 PiV4 V4=>PiV4 TRANS.

%worlds (gtermvar) (reftyping-ok/eq _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (reftyping-ok/eq _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/not/L
  : forall* {CM} {PM} {B} {Out} {V}
    forall {R=>O: result2output CM PM B (result/cond V) Out}
    exists {Out'} {N: notEnv Out Out'}
    {R=>O': result2output CM PM B (result/cond V) Out'}
    true.

- : reftyping-ok/not/L (result2output/cond B=>PiB V=>PiV)
    _ notEnv/base (result2output/cond B=>PiB V=>PiV).

- : reftyping-ok/not/L (result2output/exists [v] (R=>O v))
    _ (notEnv/exists [v] (NV v)) (result2output/exists [v] (R=>O' v))
    <- ({v} reftyping-ok/not/L (R=>O v) _ (NV v) (R=>O' v)).

%worlds (gtermvar) (reftyping-ok/not/L _ _ _ _).
%total (A) (reftyping-ok/not/L A _ _ _).


%%% AND

%theorem reftyping-ok/and/L
  : forall* {G} {CM} {PM} {B} {V1} {COut1} {PiB} {PiV1}
    forall {B=>PiB: cxt2perm PM B PiB}
    {V=>PiV: env2input CM PM B V1 PiV1}
    {R=>O1: result2output CM PM B (result/cond V1) COut1}
    exists {COut1'} {COut2'} {AND-HELP: andHelp2 G COut1 (PiB , PiV1) COut1'}
    {COut1'=>COut2: transform COut1' COut2'}
    {R=>O: result2output CM PM B (result/cond V1) COut2'}
    true.

- : reftyping-ok/and/L (B=>PiB:cxt2perm PM B PiB)
    (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/exists ([x] R2O x))
    _ _
    (andHelp2/exists [x] (AH x))
    (transform/inside [x] (TRANS x))
    (result2output/exists [x] (R2O' x))
    <- ({x: gterm V} reftyping-ok/and/L B=>PiB V1=>PiV1 (R2O x) _ _ (AH x) (TRANS x) (R2O' x)).

- : reftyping-ok/and/L (B=>PiB:cxt2perm PM B PiB)
    (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/cond (B=>PiB0:cxt2perm PM B PiB0) (V1=>PiV1':env2input CM PM B V1 PiV1'))
    _ _
    (andHelp2/base)
    (transform/cond
      (bimplies/reflexive)
      (bimplies/reflexive)
      (implies/equiv (equiv/combine PiB0<=>PiB PiV1'<=>PiV1))
      (implies/trans
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/equiv (equiv/combine PiB0<=>PiB PiV1'<=>PiV1))
          (implies/reflexive))
        (implies/cond-equal)))
    (result2output/cond B=>PiB V1=>PiV1)
    <- cxt2perm-equiv B=>PiB0 B=>PiB predmap`eq/ cxt`eq/ PiB0<=>PiB
    <- env2input-unique V1=>PiV1' V1=>PiV1 env`eq/ PiV1'<=>PiV1.

%worlds (gtermvar) (reftyping-ok/and/L _ _ _ _ _ _ _ _).
%total (A) (reftyping-ok/and/L _ _ A _ _ _ _ _).


%theorem reftyping-ok/and
  : forall* {W} {CM} {PM} {B} {V1} {C1} {COut1} {PiB} {PiV1} {COut2}
    forall {B=>PiB: cxt2perm PM B PiB}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {R=>O1: result2output CM PM B (result/cond V1) COut1}
    {R=>O1: result2output CM PM B (result/cond V1) COut2}
    {TYP-C1: typing W (PiB , PiV1) C1 COut2}
    exists {COut1'} {COut2'} {AND-HELP: andHelp1 W COut1 C1 COut1'}
    {COut1'=>COut2: transform COut1' COut2'}
    {R=>O: result2output CM PM B (result/cond V1) COut2'}
    true.

- : reftyping-ok/and B=>PiB V1=>PiV1
    (result2output/exists [x] (R2O1 x))
    R2O2 TYP-C1 _ _
    (andHelp1/exists [x] (AH1 x))
    (transform/inside [x] (TRANS x))
    (result2output/exists [x] (R2O x))
    <- ({x} reftyping-ok/and B=>PiB V1=>PiV1 (R2O1 x)
         R2O2 TYP-C1 _ _ (AH1 x) (TRANS x) (R2O x)).

- : reftyping-ok/and (B=>PiB:cxt2perm PM B PiB)
    (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/cond (B=>PiB':cxt2perm PM B PiB')
      (V1=>PiV1':env2input CM PM B V1 PiV1'))
    R2O1 TYP-C1
    _ _
    (andHelp1/base
      (tTrans
        (transform/implies
          (implies/equiv
            (equiv/combine PiB'<=>PiB PiV1'<=>PiV1)))
        (letTyping/base null TYP-C1)
        (transform/reflexive))
      AH2) TRANS R2O
    <- reftyping-ok/and/L B=>PiB' V1=>PiV1' R2O1 _ _ AH2 TRANS R2O
    <- cxt2perm-equiv B=>PiB' B=>PiB predmap`eq/ cxt`eq/ PiB'<=>PiB
    <- env2input-unique V1=>PiV1' V1=>PiV1 env`eq/ PiV1'<=>PiV1.

%worlds (gtermvar) (reftyping-ok/and _ _ _ _ _ _ _ _ _ _).
%total (A) (reftyping-ok/and _ _ A _ _ _ _ _ _ _).


%theorem reftyping-ok/if
  : forall* {W} {CM} {PM} {B} {V1} {E1: expr} {E2} {COut} {PiB} {PiV1} {EOut}
    forall {B=>PiB: cxt2perm PM B PiB}
    {V1=>PiV1: env2input CM PM B V1 PiV1}
    {R=>O1: result2output CM PM B (result/cond V1) COut}
    {TYP-E1: typing W (PiB , PiV1) E1 EOut}
    {TYP-E2: typing W (PiB , PiV1) E2 EOut}
    exists {EOut'} {TYP-IF: ifTyping W COut E1 E2 EOut'}
    {EOut'=>EOut: transform EOut' EOut}
    true.

- : reftyping-ok/if (B=>PiB:cxt2perm PM B PiB)
    (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/cond (B=>PiB':cxt2perm PM B PiB')
      (V1=>PiV1':env2input CM PM B V1 PiV1'))
    TYP-E1 TYP-E2 _
    (ifTyping/base
      (tTrans
        (transform/implies
          (implies/equiv
            (equiv/combine PiB'<=>PiB PiV1'<=>PiV1)))
        (letTyping/base null TYP-E1)
        (transform/reflexive))
      (tTrans
        (transform/implies
          (implies/equiv
            (equiv/combine PiB'<=>PiB PiV1'<=>PiV1)))
        (letTyping/base null TYP-E2)
        (transform/reflexive)))
    (transform/reflexive)
    <- cxt2perm-equiv B=>PiB' B=>PiB predmap`eq/ cxt`eq/ PiB'<=>PiB
    <- env2input-unique V1=>PiV1' V1=>PiV1 env`eq/ PiV1'<=>PiV1.

- : reftyping-ok/if (B=>PiB:cxt2perm PM B PiB)
    (V1=>PiV1:env2input CM PM B V1 PiV1)
    (result2output/exists [x] (R2O x)) TYP-E1 TYP-E2 _
    (ifTyping/exists [x] (TYP-IF x))
    (transform/trans (transform/inside [x] (TRANS x)) (transform/rem-unused))
    <- ({x} reftyping-ok/if B=>PiB V1=>PiV1 (R2O x) TYP-E1 TYP-E2 _ (TYP-IF x) (TRANS x)).

%worlds (gtermvar) (reftyping-ok/if _ _ _ _ _ _ _ _).
%total (A) (reftyping-ok/if _ _ A _ _ _ _ _).