%%% shortcut
%abbrev fldperm-fun
  : object -> nat -> (object -> permission) -> permission
 = [o][F][PF] unitperm (precise-exists o F ([v] PF v)).


%%% auxiliary theorems that are not included in 
%%% library signatures.

%theorem implies-respects-permission-eq :
    forall* {P1} {P2} {P3} {P4}
    forall  {IMP: implies P1 P2}
            {E: permission`eq P1 P3}
            {E: permission`eq P2 P4}
    exists  {IMP: implies P3 P4}
    true.

- : implies-respects-permission-eq I permission`eq/ permission`eq/ I.

%worlds () (implies-respects-permission-eq _ _ _ _).
%total  {} (implies-respects-permission-eq _ _ _ _).


%theorem false-implies-transform :
    forall* {K} {O1:output K} {O2:output K}
    forall  {F:void}
    exists  {TS: transform O1 O2}
    true.

%worlds () (false-implies-transform _ _).
%total  {} (false-implies-transform _ _).


%theorem false-implies-predmap-lookup :
    forall* {PM} {N}
    forall  {F:void}
    exists  {CJ} {PM-L: predmap`lookup PM N (conj2pred CJ)}
    true.

%worlds () (false-implies-predmap-lookup _ _ _).
%total  {} (false-implies-predmap-lookup _ _ _).


%theorem fldperm-can-lookup/false-imply :
        forall* {PM} {NN} {C} {F:nat} {G} {A}
        forall  {V:void}
        exists  {AF} {PF:clspred -> object -> permission} {FCP} 
                {A=>AF: annot=>perm A AF}
                {F2P: nn=>perm NN AF PF}
                {L: predmap`lookup PM C FCP}
                {I: {o} implies (unitperm (nonlinear (G o)))
                    (unitperm
		       (nonlinear
			  (nested ((fldperm F PF) FCP o) o all)))}
        true.

%worlds (objvar) (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).
%total  {} (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).


%theorem fldperm-can-lookup/L :
        forall* {CM} {PM} {FM} {F} {NN} {A} {G} {C}
        forall  {FM=>G: fldmap=>conj CM PM FM ([r] G r) PM}
                {FM-L: fldmap`lookup FM F (ty/ NN A C)}
        exists  {AF} {PF} {FCP} 
                {A=>AF: annot=>perm A AF}
                {FNN=>P: nn=>perm NN AF PF}
                {PM-L: predmap`lookup PM C FCP}
                {IMP: {o} implies (unitperm (nonlinear (G o)))
                      (unitperm
                        (nonlinear
                          (nested ((fldperm F PF) FCP o) o all)))}
        true.

- : fldperm-can-lookup/L (fldmap=>conj/null FMP=>G F<=FM=FMP)
    (fldmap`lookup/> FM->F P) AF PF CP A=>AF FNN=>PF PM->C IMP
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- fldmap`shift-preserves-lookup* FM->F F<=FM=FMP P2 FMP->F
    <- fldperm-can-lookup/L FMP=>G FMP->F AF PF CP A=>AF FNN=>PF PM->C IMP.

- : fldperm-can-lookup/L (fldmap=>conj/in _ FNN2P A=>AF _ PM-L) 
     (fldmap`lookup/= _) _ _ _ A=>AF FNN2P PM-L 
    ([o] implies/trans3
      (implies/conj2combine)
      (implies/combine
        (implies/reflexive)
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
      (implies/equiv equiv/identity)).

- : fldperm-can-lookup/L (fldmap=>conj/in FM=>G _ _ FM-SH _)
    (fldmap`lookup/> FM-L P) AF PF CP A=>AF FNN=>P PM-L
    ([o] implies/trans4
      (implies/conj2combine)
      (implies/combine 
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
        (I o))
      (implies/equiv equiv/commute)
      (implies/equiv equiv/identity))
    <- nat`plus-swap-succ P P'
    <- nat`plus-commutative P' P''
    <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
    <- fldperm-can-lookup/L FM=>G FM-L' AF PF CP A=>AF FNN=>P PM-L I.

- : fldperm-can-lookup/L 
    (fldmap=>conj/out F2C
      (F2CF:{f} fldmap=>conj _ _ _ ([r] CJ f r) _) 
      ([f] PM-U f) _ _ _ _ PM-FS) _ AF PF PD A=>AF FNN2P PM-L I
    <- predmap`size-total SZ-PM
    <- predmap`fresh-update-increases-size
      SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
    <- fldmap=>conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
    <- predmap`size-total SZ-PMF
    <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
    <- fldmap=>conj-implies-predmap-leq F2C PMF<=PM
    <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
    <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
    <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
    <- nat`gt-anti-reflexive SZ-PM>PM F
    <- fldperm-can-lookup/false-imply F AF PF PD A=>AF FNN2P PM-L I.

%worlds (objvar) (fldperm-can-lookup/L _ _ _ _ _ _ _ _ _).
%total  (FM=>G) (fldperm-can-lookup/L FM=>G _ _ _ _ _ _ _ _).


%%% This theorem says if we have a class predicate and we 
%%% know that this class has a field F, then we can pull out
%%% the nesting fact about F from the predicate.

%%% STRANGE: here I have to use (conj2pred CJ) instead of CP. 

%theorem fldperm-can-lookup :
        forall* {CM} {PM} {C} {FM} {F} {NN} {A} {FC} {CJ}
        forall  {CM=>PM: clsmap=>predmap CM PM}
                {PM-L: predmap`lookup PM C (conj2pred CJ)}
                {CM-L: clsmap`lookup CM C FM}
                {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
        exists  {AF} {PF} {CP:clspred} 
                {A=>AF: annot=>perm A AF}
                {FNN=>P: nn=>perm NN AF PF}
                {PM-L: predmap`lookup PM FC CP}
                {IMP: {o} implies
                      (unitperm
                        (nonlinear
                          (predcall (conj2pred CJ) (predargs/1 o))))
                      (unitperm
                        (nonlinear
                          (nested ((fldperm F PF) CP o) o all)))}
        true.

- : fldperm-can-lookup
    CM=>PM PM-L CM-L FM-L AF PF CP A=>AF FNN=>PF PM->FC 
    ([o] implies/trans
      (implies/nonlinear
        (bimplies/trans
          (bimplies/predcall/Y/inline)
          (bimplies/trans
            (bimplies/predcall/+/inline o)
            (bimplies/predcall/0/inline))))
      (IMP o))
     <- clsmap=>predmap-implies-fldmap=>conj CM=>PM PM-L CM-L FM=>G
     <- fldperm-can-lookup/L FM=>G FM-L AF PF CP A=>AF FNN=>PF PM->FC IMP.

%worlds (objvar) (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).
%total  {} (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).


%%% This relation says all (unique) locations
%%% in this set are of the same class.
%%% The set should only has positive numbers.

set-one-class : cxt N -> set -> nat -> type.

set-one-class/0 : set-one-class _ set/0 _.

set-one-class/obj : cxt N -> set -> nat -> type.

set-one-class/obj/0 : set-one-class/obj _ set/0 _.

set-one-class/obj/+
  : set-one-class/obj B (set/+ (s L) S) C
    <- set`shift (s L) S S'
    <- cxt-lookup-ty B (s L) _ C
    <- set-one-class/obj B S' C.


set-one-class/+/z
  : set-one-class B (set/+ z S) C
    <- set`shift z S S'
    <- set-one-class/obj B S' C.

set-one-class/+/s
  : set-one-class B (set/+ (s L) S) C
    <- set-one-class/obj B (set/+ (s L) S) C.


%theorem typing-read/L1 :
    forall* {CM} {FM} {PM} {XM} {N} {B: cxt N} 
            {C} {NN} {A} {FC} {S} {O} {PF}
    forall  {F} {K} {S-SZ: set`size S (s K)}
            {S-C: set-one-class/obj B S C}
            {CM-L: clsmap`lookup CM C FM}
            {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
            {T=>PF: ty=>perm PM (ty/ NN A FC) PF}
            {S+F=>GM: set+nat=>efxmap S F efx/write XM}
    exists  {G} {Pi} {Pi'}
            {S=>G: set=>fact/objequal B O S G}
            {XM=>Pi: efxmap=>input/obj CM PM B XM Pi}
            {IMP: implies
                  ((unitperm (nonlinear G)) , Pi)
                  ((unitperm (precise-exists O F ([v] (PF v))) , 
                     (unitperm
                       (encumbered 
                         (unitperm
                           (precise-exists O F ([v] (PF v)))) Pi))) , Pi') }
    true.

- : typing-read/L1 F z (set`size/+ set`size/0)
    (set-one-class/obj/+ set-one-class/obj/0 B->SL=C set`shift/0)
    CM-L FM-L T=>PF (set+nat=>efxmap/+ set+nat=>efxmap/0)
    %{=>}% _ _ _
    (set=>fact/objequal/+ set=>fact/objequal/0 B->SL=C set`update/0)
    (efxmap=>input/obj/+ efxmap=>input/obj/0 
      (efxmap=>perm-helper/+/out
        efxmap=>perm-helper/0 T=>PF FM-L 
        set`not-member/0 inner-efxmap`fresh/0 inner-efxmap`update/0)
      CM-L B->SL=C efxmap`fresh/0 efxmap`update/0)
    (implies/trans3
      (implies/combine
        (implies/nonlinear
          (bimplies/trans
            (bimplies/neg
              (bimplies/trans
                (bimplies/conj/XX
                  (bimplies/reflexive)
                  (bimplies/rem-negneg))
                (bimplies/conj-true))
              (bool`ne/FT))
            (bimplies/trans
              (bimplies/rem-negneg)
              (bimplies/objequal-symmetric))))
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/equiv
              (equiv/transitive
                (equiv/identity)
                (equiv/identity)))
            (implies/trans
              (implies/self-implication)
              (implies/equiv-encumbered
                (equiv/transitive
                  (equiv/identity)
                  (equiv/identity))
                (equiv/reflexive))))))
      (implies/objequal
        ([o] (fldperm-fun o F ([v] PF v)) , 
          (unitperm
            (encumbered (fldperm-fun o F ([v] PF v))
              (combine (combine (fldperm-fun R F ([v] PF v)) empty) empty)))))
      (implies/equiv (equiv/symmetric equiv/identity))).

- : typing-read/L1 F (s N) (set`size/+ SZ-S)
    (set-one-class/obj/+ SOC-SS B->SL=C SL<<S=SS)
    CM-L FM-L T=>PF (set+nat=>efxmap/+ S1+FX=XM1)
    %{=>}% _ _ _ 
    (set=>fact/objequal/+ SS=>GS B->SL=C SS+SL=S)
    (efxmap=>input/obj/+ XMS=>PiS 
      (efxmap=>perm-helper/+/out
        efxmap=>perm-helper/0 T=>PF FM-L 
        set`not-member/0 inner-efxmap`fresh/0 inner-efxmap`update/0)
      CM-L B->SL=C SL!<XMS XMS+S=LSXM)
    (implies/trans6
      (implies/equiv equiv/commute)
      (implies/combine
        (implies/combine
          (implies/equiv equiv/identity)
          (implies/reflexive))
        (implies/disj2cond))
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans6
          (implies/combine
            (implies/reflexive)
            (implies/equiv equiv/identity))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (implies/nonlinear bimplies/objequal-symmetric)
                (implies/trans
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/self-implication))))
              (implies/objequal
                ([o] (fldperm-fun o F ([v] PF v)) , 
                  (unitperm
                    (encumbered (fldperm-fun o F ([v] PF v))
                      (fldperm-fun R F ([v] PF v)))))))
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine
                (implies/reflexive)
                (implies/trans3
                  (implies/self-implication)
                  (implies/equiv-encumbered
                    (equiv/commute)
                    (equiv/combine
                      (equiv/symmetric equiv/identity)
                      (equiv/reflexive)))
                  (implies/combine-assoc-encumbered)))
              (implies/linear-modus-ponens)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/chain-implication))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans2
          (implies/combine
            (implies/reflexive)
            (implies/trans3
              (implies/equiv 
                (equiv/transitive
                  (equiv/symmetric equiv/associate)
                  (equiv/combine
                    (equiv/reflexive)
                    (equiv/commute))))
              (implies/combine
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/reflexive)
                        (equiv/combine
                          (equiv/symmetric equiv/identity)
                          (equiv/reflexive)))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens))
                (IMP))
              (implies/trans
                (implies/equiv
                  (equiv/associate))
                (implies/combine
                  (implies/trans
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/symmetric equiv/associate)))
                    (implies/combine
                      (implies/reflexive)
                      (implies/chain-implication)))
                  (implies/reflexive)))))
          (implies/equiv 
            (equiv/transitive
              (equiv/commute)
              (equiv/symmetric equiv/associate)))))
      (implies/cond-pull))
    <- set`shift-implies-update SL<<S=SS SS+SL=S
    <- efxmap`shift-total SL<<XM=XMS
    <- efxmap`shift-implies-update SL<<XM=XMS XMS+S=LSXM
    <- efxmap`shift-implies-fresh SL<<XM=XMS SL!<XMS
    <- shift-preserves-set+nat=>efxmap
      S1+FX=XM1 SL<<S=SS SL<<XM=XMS SS+FX=XMS
    <- set`shift-preserves-size SZ-S SL<<S=SS SZ-SS
    <- typing-read/L1 F N SZ-SS SOC-SS CM-L FM-L T=>PF
      SS+FX=XMS %{=>}% _ _ _ SS=>GS XMS=>PiS IMP.

%worlds () (typing-read/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (K) (typing-read/L1 _ K _ _ _ _ _ _ _ _ _ _ _ _).



%theorem typing-read/L2L :
    forall* {PF1: object -> permission} {PF2} {F} {O:object}
    forall  {E: {o} permission`eq (PF1 o) (PF2 o)}
    exists  {IMP: implies
                  (unitperm
                    (nonlinear
                      (nested
                        (unitperm
                          (precise-exists O F ([o] PF1 o))) O all)))
                  (unitperm
                    (nonlinear
                      (nested
                        (unitperm
                          (precise-exists O F ([o] PF2 o))) O all)))}
    true.

- : typing-read/L2L ([_] permission`eq/) implies/reflexive.
    
%worlds () (typing-read/L2L _ _).
%total  {} (typing-read/L2L _ _).


%theorem typing-read/L2 :
    forall* {CM} {FM} {PM} {XM} {N} {B: cxt N} 
            {C} {NN} {A} {FC} {S} {O} {PF} {CJ}
    forall  {F} {K} {S-SZ: set`size S (s K)}
            {S-C: set-one-class B S C}
            {CM=>PM: clsmap=>predmap CM PM}
            {CM-L: clsmap`lookup CM C FM}
            {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
            {PM-L: predmap`lookup PM C (conj2pred CJ)}
            {T=>PF: ty=>perm PM (ty/ NN A FC) PF}
            {S+F=>GM: set+nat=>efxmap S F efx/write XM}
    exists  {PG} {Pi} {Pi'}
            {S=>G: set=>fact B O S PG}
            {XM=>Pi: efxmap=>input CM PM B XM Pi}
            {IMP: implies ((one-predcall (conj2pred CJ) O) , (PG , Pi))
                  ((unitperm (precise-exists O F ([v] (PF v))) , 
                     (unitperm
                       (encumbered 
                         (unitperm
                           (precise-exists O F ([v] (PF v)))) Pi))) , Pi') }
    true.

- : typing-read/L2 _ _ SZ
    (set-one-class/+/s SOC)
    CM=>PM CM-L FM-L PM-L T=>PF S+FX=>XM %{=>}%
    _ _ _ (set=>fact/+/s S=>G) (efxmap=>input/+/s XM=>Pi)
    (implies/trans
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/combine 
            (implies/trans3
              (implies/equiv
                (equiv/transitive
                  (equiv/symmetric equiv/identity)
                  (equiv/commute)))
              (implies/combine
                (implies/trans
                  (implies/empty2true)
                  (implies/nonlinear bimplies/add-negneg))
                (implies/cond-neg))
              (implies/cond-elim))
            (implies/reflexive))
          (IMP)))
      (implies/equiv equiv/roll2))
    <- typing-read/L1 _ _ SZ SOC CM-L FM-L T=>PF S+FX=>XM
      _ _ _ S=>G XM=>Pi IMP.

- : typing-read/L2 _ z (set`size/+ set`size/0)
    (set-one-class/+/z set-one-class/obj/0 set`shift/0) CM=>PM
    CM-L FM-L PM-L T=>PF (set+nat=>efxmap/+ set+nat=>efxmap/0)
    %{=>}% _ _ _ 
    (set=>fact/+/z set=>fact/objequal/0 set`shift/0)
    (efxmap=>input/+/z efxmap=>input/obj/0 efxmap`shift/0)
    (implies/trans3
      (implies/combine
        (implies/trans
          (IMP-CP O)
          (IMP-PF))
        (implies/trans3
          (implies/combine
            (implies/trans3
              (implies/cond-gen-inner)
              (implies/cond-inner
                (bimplies/reflexive)
                (bimplies/reflexive)
                (implies/reflexive)
                (implies/trans
                  (implies/equiv equiv/commute)
                  (implies/combine
                    (implies/nonlinear
                      (bimplies/ft))
                    (implies/reflexive))))
              (implies/cond-pull))
            (implies/equiv equiv/identity))
          (implies/equiv 
            (equiv/transitive3
              (equiv/symmetric equiv/associate)
              (equiv/combine
                (equiv/reflexive) (equiv/commute))
              (equiv/associate)))
          (implies/combine
            (implies/carve) (implies/reflexive))))
      (implies/equiv equiv/associate)
      (implies/combine
        (implies/trans4
          (implies/equiv equiv/associate)
          (implies/combine 
            (implies/carve) (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/trans
              (implies/chain-implication)
              (implies/equiv-encumbered
                (equiv/reflexive) (equiv/symmetric equiv/identity)))))
        (implies/reflexive)))
    <- fldperm-can-lookup CM=>PM PM-L CM-L FM-L _ _ _ 
      A=>AF FNN=>P PM-L=CP IMP-CP
    <- ty=>perm-deterministic (ty=>perm/ PM-L=CP FNN=>P A=>AF) T=>PF 
      predmap`eq/ nonnull`eq/ annot`eq/ nat`eq/ PF1=PF2
    <- typing-read/L2L PF1=PF2 IMP-PF.
    
- : typing-read/L2 _ (s N) (set`size/+ SZ-S)
    (set-one-class/+/z SCO Z<<S=SS) CM=>PM CM-L FM-L PM-L T=>PF
    (set+nat=>efxmap/+ S+FX=XM) %{=>}% _ _ _
    (set=>fact/+/z SS=>G Z<<S=SS)
    (efxmap=>input/+/z XMS=>Pi Z<<XM=XMS)
    (implies/trans5
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/equiv equiv/commute)
          (implies/cond-push)))
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans7
          (implies/equiv equiv/roll2)
          (implies/combine
            (IMP-CP O)
            (implies/trans5
              (implies/combine
                (implies/reflexive)
                (implies/equiv equiv/identity))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/carve) 
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/commute) (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/reflexive) (implies/chain-implication))))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (IMP-PF)
                (implies/reflexive))
              (implies/carve))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/chain-implication))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans5
          (implies/combine
            (implies/reflexive)
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/trans3
                    (implies/equiv (equiv/symmetric equiv/identity))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans
                        (implies/self-implication)
                        (implies/combine-assoc-encumbered)))
                    (implies/linear-modus-ponens))
                  (implies/trans
                    (implies/equiv equiv/commute) (IMP))))))
          (implies/equiv equiv/roll4)
          (implies/combine
            (implies/reflexive)
            (implies/equiv equiv/roll3))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/reflexive) (implies/chain-implication)))
            (implies/reflexive))))
      (implies/cond-pull))
    <- set`shift-preserves-size SZ-S Z<<S=SS SZ-SS
    <- fldperm-can-lookup CM=>PM PM-L CM-L FM-L _ _ _ 
      A=>AF FNN=>P PM-L=CP IMP-CP
    <- efxmap`shift-total Z<<XM=XMS
    <- shift-preserves-set+nat=>efxmap S+FX=XM Z<<S=SS Z<<XM=XMS SS+FX=XMS
    <- typing-read/L1 F N SZ-SS SCO CM-L FM-L T=>PF SS+FX=XMS _ _ _
      SS=>G XMS=>Pi IMP
    <- ty=>perm-deterministic (ty=>perm/ PM-L=CP FNN=>P A=>AF) T=>PF 
      predmap`eq/ nonnull`eq/ annot`eq/ nat`eq/ PF1=PF2
    <- typing-read/L2L PF1=PF2 IMP-PF.

%worlds () (typing-read/L2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {K} (typing-read/L2 _ K _ _ _ _ _ _ _ _ _ _ _ _ _ _).