
%%% Shortcuts

%abbrev fldperm-fun
  : object -> nat -> (object -> permission) -> permission
 = [o][F][PF] unitperm (precise-exists o F ([v] PF v)).

%abbrev nonnull-unique-perm : object -> clspred -> permission
    = [x][p] (combine (unitperm (nonlinear (neg (objequal x null))))
               (combine (allperm x)
                 (one-predcall p x))).

%abbrev ffperm
  : fraction -> object -> nat
   -> (object -> permission) -> permission
  = [f][r][n][fp] (scale f (unitperm (precise-exists r n ([o] fp o)))).

% ============================ about 1/2 + 1/2 = 1 ========================
% =========================================================================

%abbrev 0 = z.
%abbrev 1 = (s z).
%abbrev 2 = (s 1).
%abbrev 4 = (s (s 2)).
%abbrev 1/2=1/2
  : rat`abs (rat`frac z one) 1 2
    = rat`abs/frac nat`plus/z nat`times/z (nat`plus/s nat`plus/z) rat`abs/whole.
%abbrev 1*2=2 : nat`times 1 2 2 = nat`times/s* nat`plus/z nat`times/z.
%abbrev 2+2=4 : nat`plus 2 2 4 = nat`plus/s (nat`plus/s nat`plus/z).
%abbrev 2*2=4 : nat`times 2 2 4 = nat`times/s* 2+2=4 1*2=2.
%abbrev 4/4=1 : rat`rep 4 4 one = rat`rep/=.

%abbrev 1/2+1/2=1
  : rat`add (rat`frac z one) (rat`frac z one) one
    = rat`add/ 4/4=1 2+2=4 2*2=4 1*2=2 1*2=2 1/2=1/2 1/2=1/2.

% =========================================================================

%%% Lemmas

%theorem pullout-fldperm
  : forall* {CP} {PF} {Pi1} {Pi2} {Q}
    forall {IMP: {x:object} implies (one-predcall CP x)
                 (unitperm (nonlinear (nested (PF x) x all)))}
    exists {IMP: {x:object}
                 implies
                 (combine (scale Q (nonnull-unique-perm x CP))
                   (combine
                     (unitperm
                       (encumbered (scale Q (nonnull-unique-perm x CP)) Pi1)) Pi2))
                 (combine (scale Q (PF x))
                   (combine (unitperm (encumbered (scale Q (PF x)) Pi1)) Pi2))}
    true.

- : pullout-fldperm IMP
    ([r] implies/trans9
      (implies/combine
        (implies/equiv
          (equiv/transitive
            (equiv/distribute)
            (equiv/commute)))
        (implies/combine
          (implies/trans
            (implies/equiv-encumbered
              (equiv/transitive
                (equiv/distribute)
                (equiv/combine
                  (equiv/reflexive)
                  (equiv/transitive
                    (equiv/distribute)
                    (equiv/commute))))
              (equiv/reflexive))
            (implies/combine-assoc-encumbered))
          (implies/reflexive)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/linear-modus-ponens)
            (implies/reflexive))))
      (implies/combine
        (implies/trans3
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/reflexive)
            (implies/trans
              (implies/scale-from-formula)
              (implies/duplicate)))
          (implies/equiv equiv/associate))
        (implies/combine
          (implies/combine-assoc-encumbered)
          (implies/reflexive)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (implies/scale-into-formula)
                (implies/reflexive))
              (implies/linear-modus-ponens))
            (implies/reflexive))))
      (implies/combine
        (implies/trans6
          (implies/equiv equiv/commute)
          (implies/combine
            (implies/trans
              (IMP r)
              (implies/scale-into-formula))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/distribute))
          (implies/scale implies/carve)
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/reflexive)
            (implies/scale-distribute-encumbered)))
        (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/chain-implication)
            (implies/reflexive))))).

%worlds () (pullout-fldperm _ _).
%total {} (pullout-fldperm _ _).


%abbrev gen-objequal-self
  : {o} implies empty (unitperm (nonlinear (disj (objequal o o) (neg t))))
    = [o] implies/trans
      (implies/empty2true)
      (implies/nonlinear
        (bimplies/trans
          (bimplies/objequal-reflexive)
          (bimplies/trans
            (bimplies/add-negneg)
            (bimplies/neg
              (bimplies/conj-weaken/false)
              (bool`ne/FT))))).

%abbrev add-encumber
  : implies (combine (unitperm (encumbered Pi1 Pi2)) Pi3)
              (unitperm (encumbered Pi1 (Pi2 , Pi3)))
    = (implies/trans
        (implies/combine
          (implies/reflexive)
          (implies/trans3
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/combine
              (implies/reflexive)
              (implies/trans3
                (implies/self-implication)
                (implies/equiv-encumbered
                  (equiv/commute)
                  (equiv/reflexive))
                (implies/combine-assoc-encumbered)))
            (implies/linear-modus-ponens)))
        (implies/chain-implication)).

%abbrev repack-fldperm
  : {v} implies (scale Q (unitperm (basic O F v)))
    (unitperm (encumbered (scale Q (Pi v))
                (scale Q (unitperm (precise-exists O F ([v] (Pi v)))))))
    = [v]
      (implies/trans3
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/combine
          (implies/reflexive)
          (implies/trans5
            (implies/equiv (equiv/symmetric equiv/zero))
            (implies/scale (implies/gen-pack-encumber v))
            (implies/scale-distribute-encumbered)
            (implies/equiv-encumbered
              (equiv/distribute)
              (equiv/reflexive))
            (implies/combine-assoc-encumbered)))
        (implies/linear-modus-ponens)).

%abbrev disj-to-objequal
  : {o}{r} bimplies true (disj (objequal o r) f) (objequal o r)
    = ([o][r] bimplies/trans
        (bimplies/neg
          (bimplies/trans
            (bimplies/conj/XX
              (bimplies/reflexive)
              (bimplies/rem-negneg))
            (bimplies/conj-true))
          (bool`ne/FT))
        (bimplies/rem-negneg)).


%theorem implies-respects-permission-eq
  : forall* {P1} {P2} {P3} {P4}
    forall {Pi1=>Pi2: implies P1 P2}
    {P1=P3: permission`eq P1 P3}
    {P2=P4: permission`eq P2 P4}
    exists {P3=>P4: implies P3 P4}
    true.

- : implies-respects-permission-eq I permission`eq/ permission`eq/ I.

%worlds () (implies-respects-permission-eq _ _ _ _).
%total {} (implies-respects-permission-eq _ _ _ _).


%theorem false-implies-transform
  : forall* {K} {O1:output K} {O2:output K}
    forall {F:void}
    exists {T: transform O1 O2}
    true.

%worlds () (false-implies-transform _ _).
%total {} (false-implies-transform _ _).



%{ This theorem says if we have a class predicate and we
know that this class has a field F, then we can pull out
the nesting fact about F from the predicate. }%


%theorem fldperm-can-lookup
  : forall* {CM} {PM} {C} {FM} {F} {NN} {A} {FC} {CP}
    forall {CM2PM: clsmap2predmap CM PM}
    {PM-L: predmap`lookup PM C CP}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    exists {AF} {PF} {FCP}
    {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM FC FCP}
    {IMP: {o} implies
          (unitperm
            (nonlinear
              (predcall CP (predargs/1 o))))
          (unitperm
            (nonlinear
              (nested ((fldperm F PF) FCP o) o all)))}
    true.

%theorem fldperm-can-lookup/false-imply
  : forall* {PM} {NN} {C} {F:nat} {G} {A}
    forall {V:void}
    exists {AF} {PF:clspred -> object -> permission}
    {CP} {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    {IMP: {o} implies (unitperm (nonlinear (G o)))
        (unitperm
          (nonlinear
            (nested ((fldperm F PF) CP o) o all)))}
    true.

%theorem fldperm-can-lookup/L
  : forall* {CM} {PM} {FM} {F} {NN} {A} {G} {C}
    forall {FM=>G: fldmap2conj CM PM FM ([r] G r) PM}
    {FM-L: fldmap`lookup FM F (ty/ NN A C)}
    exists {AF} {PF} {CP}
    {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    {IMP: {o} implies (unitperm (nonlinear (G o)))
        (unitperm
            (nonlinear
              (nested ((fldperm F PF) CP o) o all)))}
    true.

- : fldperm-can-lookup/L (fldmap2conj/null FMP2G F<=FM=FMP)
    (fldmap`lookup/> FM->F P) AF PF CP A2AF FNN2PF PM->C IMP
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- fldmap`shift-preserves-lookup* FM->F F<=FM=FMP P2 FMP->F
    <- fldperm-can-lookup/L FMP2G FMP->F AF PF CP A2AF FNN2PF PM->C IMP.

- : fldperm-can-lookup/L (fldmap2conj/in _ FNN2P A2AF _ PM-L)
     (fldmap`lookup/= nat`eq/) _ _ _ A2AF FNN2P PM-L
    ([o] implies/trans3
      (implies/conj2combine)
      (implies/combine
        (implies/reflexive)
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
      (implies/equiv equiv/identity)).

- : fldperm-can-lookup/L (fldmap2conj/in FM2G _ _ FM-SH _)
    (fldmap`lookup/> FM-L P) AF PF CP A2AF FNN2P PM-L
    ([o] implies/trans4
      (implies/conj2combine)
      (implies/combine
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
        (I o))
      (implies/equiv equiv/commute)
      (implies/equiv equiv/identity))
    <- nat`plus-swap-succ P P'
    <- nat`plus-commutative P' P''
    <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
    <- fldperm-can-lookup/L FM2G FM-L' AF PF CP A2AF FNN2P PM-L I.

- : fldperm-can-lookup/L
    (fldmap2conj/out F2C
      (F2CF:{f} fldmap2conj _ _ _ ([r] CJ f r) _)
      ([f] PM-U f) _ _ _ _ PM-FS) _ AF PF PD A2AF FNN2P PM-L I
    <- predmap`size-total SZ-PM
    <- predmap`fresh-update-increases-size
      SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
    <- fldmap2conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
    <- predmap`size-total SZ-PMF
    <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
    <- fldmap2conj-implies-predmap-leq F2C PMF<=PM
    <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
    <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
    <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
    <- nat`gt-anti-reflexive SZ-PM>PM F
    <- fldperm-can-lookup/false-imply F AF PF PD A2AF FNN2P PM-L I.

- : fldperm-can-lookup
    CM2PM PM-L CM-L FM-L AF PF CP A2AF FNN2PF PM->FC
    ([o] implies/trans3
      (implies/equiv (EQV o))
      (implies/nonlinear
        (bimplies/trans
          (bimplies/predcall/Y/inline)
          (bimplies/trans
            (bimplies/predcall/+/inline o)
            (bimplies/predcall/0/inline))))
      (IMP o))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- clsmap-predmap-implies-lookup-format CM-PM PM-L _ PM-LP ([o] (PEQ o))
    <- ({o} permission`eq-implies-equiv (PEQ o) (EQV o))
    <- clsmap2predmap-implies-fldmap2conj CM2PM PM-LP CM-L FM2G
    <- fldperm-can-lookup/L FM2G FM-L AF PF CP A2AF FNN2PF PM->FC IMP.

%worlds (objvar) (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).
%total {} (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).

%worlds (objvar) (fldperm-can-lookup/L _ _ _ _ _ _ _ _ _).
%total (FM2G) (fldperm-can-lookup/L FM2G _ _ _ _ _ _ _ _).

%worlds (objvar) (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).
%total {} (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).



%theorem sharedperm-can-be-duplicated
  : forall* {NN} {C} {AF} {PF} {PM} {CP}
    forall {A2AF: annot2perm annot/shared AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    exists {IMP: {r} implies (PF CP r) ((PF CP r) , (PF CP r))}
    true.

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/yes _
    ([r]
      (implies/trans4
        (implies/combine
          (implies/reflexive)
          (implies/combine2conj))
        (implies/combine2conj)
        (implies/duplicate)
        (implies/combine
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))))).

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/may _
    ([r]
      (implies/trans3
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/trans
            (implies/combine2conj)
            (implies/duplicate)))
        (implies/cond-distribute)
        (implies/combine
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/conj2combine))
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/conj2combine))))).

%worlds () (sharedperm-can-be-duplicated _ _ _ _).
%total {} (sharedperm-can-be-duplicated _ _ _ _).


%theorem sharedperm-can-be-duplicated*
  : forall* {NN} {C} {PF} {PM}
    forall {T2PF: ty2perm PM (ty/ NN annot/shared C) PF}
    exists {IMP: {r} implies (PF r) ((PF r) , (PF r))}
    true.

- : sharedperm-can-be-duplicated*
    (ty2perm/ PM-L NN2PF A2AF) IMP
    <- sharedperm-can-be-duplicated A2AF NN2PF PM-L IMP.

%worlds () (sharedperm-can-be-duplicated* _ _).
%total {} (sharedperm-can-be-duplicated* _ _).