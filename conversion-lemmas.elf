%%%% lemmas about type checking
%abbrev fldperm-fun
  : object -> nat -> (object -> permission) -> permission
 = [o][F][PF] unitperm (precise-exists o F ([v] PF v)).

%theorem cxt2facts-implies-permission :
    forall* {PM} {N} {B:cxt N} {Pi} {L} {O} {NN} {A} {C}
    forall  {B2G: cxt2facts PM B Pi}
            {B-L: cxt-lookup B L O (ty/ NN A C)}
    exists  {AF} {A2AF: annot2perm2 A AF}
            {PF} {NN2PF: nn2perm NN AF PF}
            {CP} {PM-L: predmap`lookup PM C CP}
            {Pi2} {IMP: implies Pi ((PF CP O) , Pi2)}
    true.

- : cxt2facts-implies-permission
    (cxt2facts/cons B2G (ty2perm2/ PM-L NN2PF A2AF))
    cxt-lookup/hit _ A2AF _ NN2PF _ PM-L _ implies/reflexive.

- : cxt2facts-implies-permission
    (cxt2facts/cons B2G _) (cxt-lookup/miss B-L _) 
    AF A2AF PF T2PF CP PM-L _
    (implies/trans
      (implies/combine
	implies/reflexive IMP)
      (implies/equiv equiv/roll2))
    <- cxt2facts-implies-permission
      B2G B-L AF A2AF PF T2PF CP PM-L _ IMP.


%worlds () (cxt2facts-implies-permission _ _ _ _ _ _ _ _ _ _).
%total (B-L) (cxt2facts-implies-permission _ B-L _ _ _ _ _ _ _ _).
    


%theorem annot2perm2-total* :
    forall {A}
    exists {AF} {A2AF: annot2perm2 A AF}
    true.

- : annot2perm2-total* annot/unique _ annot2perm2/unique.
- : annot2perm2-total* annot/shared _ annot2perm2/shared.
- : annot2perm2-total* annot/borrow _ annot2perm2/borrow.

%worlds () (annot2perm2-total* _ _ _).
%total  (A) (annot2perm2-total* A _ _).

%abbrev annot2perm2-total = annot2perm2-total* _ _.


%theorem cxt2facts-total :
    forall* {CM} {PM} {N} {B: cxt N}
    forall  {CM-B: clsmap-cxt CM B}
            {CM2PM: clsmap2predmap CM PM}
    exists  {G} {B2G: cxt2facts PM B G}
    true.

- : cxt2facts-total clsmap-cxt/nil _ _ cxt2facts/nil.

- : cxt2facts-total
    (clsmap-cxt/cons (clsmap-ty/notnull IN) CM-B) CM2PM _
    (cxt2facts/cons B2G (ty2perm2/ PM-L NN2PF A2AF))
    <- annot2perm2-total A2AF
    <- nn2perm-total NN2PF
    <- clsmap`in-implies-lookup IN _ CM-L
    <- clsmap2predmap-implies-predmap-lookup CM2PM CM-L _ PM-L
    <- cxt2facts-total CM-B CM2PM G B2G.

- : cxt2facts-total
    (clsmap-cxt/cons clsmap-ty/null CM-B) CM2PM _
    (cxt2facts/cons B2G ty2perm2/null)
    <- cxt2facts-total CM-B CM2PM G B2G.

%worlds () (cxt2facts-total _ _ _ _).
%total (CM-B) (cxt2facts-total CM-B _ _ _).


% %theorem ref-typing-tgtmap<=efxmap :
%     forall* {L1} {L2} {CM} {MM} {N} {B: cxt N}
%             {E: expr} {GM} {XM} {T}
%     forall  {RTYP: ref-typing L1 CM MM B E (out/expr T GM XM) L2}
%     exists  {S} {GM'} {SP: tgtmap`split GM S GM'} 
%             {GM<=XM: tgtmap<=efxmap GM' XM}
%     true.

% - : ref-typing-tgtmap<=efxmap (ref-typing/lit _) _ _
%     (tgtmap`split/+/empty 
%       set`update/0
%       tgtmap`split/0
%       tgtmap`fresh/0
%       tgtmap`update/0)
%     tgtmap<=efxmap/0.

% - : ref-typing-tgtmap<=efxmap ref-typing/null _ _ 
%     tgtmap`split/0 tgtmap<=efxmap/0.

% %worlds () (ref-typing-tgtmap<=efxmap _ _ _ _ _).
% %trustme %total {} (ref-typing-tgtmap<=efxmap _ _ _ _ _).


%theorem ref-typing-ok/lit :
    forall* {L1} {L2} {CM} {MM} {N} {B: cxt N}
            {C} {N1} {PM} {W} {A} {O} {NN}
    forall  {CM-CM : clsmap-clsmap CM CM}
            {CM-MM: clsmap-methmap CM MM}
            {CM-B:  clsmap-cxt CM B}
            {CM2PM: clsmap2predmap CM PM}
            {B-L: cxt-lookup B N1 O (ty/ NN A C)}
            {R-TYP: ref-typing L1 CM MM B (lit O) 
                    (out/expr (ty/ NN A C) (tgtmap/1 N1) efxmap/0) L2}
    exists  {G} {Out}
            {B2G: cxt2facts PM B G}
            {XM2Out: efxmap2output 
                     CM PM B efxmap/0 (ty/ NN A C) (tgtmap/1 N1) Out}
            {P-TYP:  typing W (G , empty) (lit O) Out}
    true.

- : ref-typing-ok/lit CM-CM CM-MM CM-B CM2PM B-L
    (RTYP: ref-typing _ _ _ _ (lit O) _ _) %{=>}% _ _
    B2G (efxmap2output/
          (tgtmap2perm/0 tgtmap`size/0)
          T2PF
          ([o] set2facts/+ set2facts/0 B-L set`update/0)
          (efxmap2perm/0)
          (tgtmap`split/+/empty
            set`update/0
            tgtmap`split/0
            tgtmap`fresh/0
            tgtmap`update/0))
    (tTrans
      (transform/drop)
      (letTyping/base null tObjLoc)
      (transform/trans
        (transform/implies
          (implies/trans3
            (implies/empty2true)
            (implies/nonlinear 
              (bimplies/trans
                (bimplies/objequal-reflexive)
                (bimplies/trans
                  (bimplies/add-negneg)
                  (bimplies/neg
                    (bimplies/conj-weaken/false)
                    (bool`ne/FT)))))
            (implies/equiv (equiv/symmetric equiv/identity))))
        (transform/gen-exists _)))
    <- typing-implies-clsmap-ty CM-CM CM-MM CM-B RTYP CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- cxt2facts-total CM-B CM2PM _ B2G.
    
%worlds () (ref-typing-ok/lit _ _ _ _ _ _ _ _ _ _ _).
%total  {} (ref-typing-ok/lit _ _ _ _ _ _ _ _ _ _ _).


% %theorem tgtmap=>efxmap-can-split :
%     forall* {GM} {GM1} {GM2} {XM} {X}
%     forall  {GM2XM: tgtmap=>efxmap GM X XM}
%             {J: tgtmap`deep-disjoint GM1 GM2}
%             {U: tgtmap`join GM1 GM2 GM}
%     exists  {XM1} {XM2} 
%             {GM12XM1: tgtmap=>efxmap GM1 X XM1}
%             {GM22XM2: tgtmap=>efxmap GM2 X XM2}
%             {J: efxmap`deep-disjoint XM1 XM2}
%             {U: efxmap`join XM1 XM2 XM}
%     true.

% - : tgtmap=>efxmap-can-split
%     GM=>XM tgtmap`deep-disjoint/L tgtmap`join/L
%     _ _ tgtmap=>efxmap/0 GM=>XM efxmap`deep-disjoint/L efxmap`join/L.

% - : tgtmap=>efxmap-can-split
%     GM=>XM tgtmap`deep-disjoint/R tgtmap`join/R
%     _ _ GM=>XM tgtmap=>efxmap/0 efxmap`deep-disjoint/R efxmap`join/R.

% %worlds () (tgtmap=>efxmap-can-split _ _ _ _ _ _ _ _ _).
% %trustme %total  {} (tgtmap=>efxmap-can-split _ _ _ _ _ _ _ _ _).
    


set-one-class : cxt N -> set -> nat -> type.

set-one-class/0 : set-one-class _ set/0 _.

set-one-class/+
  : set-one-class B (set/+ L S) C
    <- set`shift L S S'
    <- cxt-lookup B L _ (ty/ _ _ C)
    <- set-one-class B S' C.


%theorem typing-read/L1 :
    forall* {CM} {FM} {PM} {XM} {N} {B: cxt N} 
            {C} {NN} {A} {FC} {S} {O} {PF}
    forall  {F} {K} {S-SZ: set`size S (s K)}
            {S-C: set-one-class B S C}
            {CM-L: clsmap`lookup CM C FM}
            {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
            {T=>PF: ty2perm PM (ty/ NN A FC) PF}
            {S=>XM: set+nat=>efxmap S F efx/write XM}
    exists  {G} {Pi} {Pi'} {Pi2}
            {S=>G: set2facts B O S G}
            {XM=>Pi: efxmap2perm CM PM B XM tgtmap/0 Pi2 Pi}
            {IMP: implies
                  ((unitperm (nonlinear G)) , Pi)
                  ((unitperm (precise-exists O F ([v] (PF v))) , 
                     (unitperm
                       (encumbered 
                         (unitperm
                           (precise-exists O F ([v] (PF v)))) Pi))) , Pi') }
    true.

- : typing-read/L1 F (s N) (set`size/+ SZ-S)
    (set-one-class/+ SOC-SS B-L SL<<S=SS)
    CM-L FM-L T2PF (set+nat=>efxmap/+ S1+FX=XM1)
    %{=>}% _ _ _ _
    (set2facts/+ SS=>GS B-L SS+SL=S)
    (efxmap2perm/+/out
      XMS=>PiS
      (efxmap2perm-helper/+/out
        efxmap2perm-helper/0
        T2PF
        FM-L
        set`not-member/0
        inner-efxmap`fresh/0
        inner-efxmap`update/0)
      CM-L B-L tgtmap`fresh/0 SL!<XMS XMS+S=LSXM)
    (implies/trans6
      (implies/equiv equiv/commute)
      (implies/combine
        (implies/combine
          (implies/equiv equiv/identity)
          (implies/reflexive))
        (implies/disj2cond))
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans6
          (implies/combine
            (implies/reflexive)
            (implies/equiv equiv/identity))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (implies/nonlinear bimplies/objequal-symmetric)
                (implies/trans
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/self-implication))))
              (implies/objequal
                ([o] (fldperm-fun o F ([v] PF v)) , 
                  (unitperm
                    (encumbered (fldperm-fun o F ([v] PF v))
                      (fldperm-fun R F ([v] PF v)))))))
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine
                (implies/reflexive)
                (implies/trans3
                  (implies/self-implication)
                  (implies/equiv-encumbered
                    (equiv/commute)
                    (equiv/combine
                      (equiv/symmetric equiv/identity)
                      (equiv/reflexive)))
                  (implies/combine-assoc-encumbered)))
              (implies/linear-modus-ponens)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/chain-implication))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans2
          (implies/combine
            (implies/reflexive)
            (implies/trans3
              (implies/equiv 
                (equiv/transitive
                  (equiv/symmetric equiv/associate)
                  (equiv/combine
                    (equiv/reflexive)
                    (equiv/commute))))
              (implies/combine
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/reflexive)
                        (equiv/combine
                          (equiv/symmetric equiv/identity)
                          (equiv/reflexive)))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens))
                (IMP))
              (implies/trans
                (implies/equiv
                  (equiv/associate))
                (implies/combine
                  (implies/trans
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/symmetric equiv/associate)))
                    (implies/combine
                      (implies/reflexive)
                      (implies/chain-implication)))
                  (implies/reflexive)))))
          (implies/equiv 
            (equiv/transitive
              (equiv/commute)
              (equiv/symmetric equiv/associate)))))
      (implies/cond-pull))
    <- set`shift-implies-update SL<<S=SS SS+SL=S
    <- efxmap`shift-total SL<<XM=XMS
    <- efxmap`shift-implies-update SL<<XM=XMS XMS+S=LSXM
    <- efxmap`shift-implies-fresh SL<<XM=XMS SL!<XMS
    <- shift-preserves-set+nat=>efxmap
      S1+FX=XM1 SL<<S=SS SL<<XM=XMS SS+FX=XMS
    <- set`shift-preserves-size SZ-S SL<<S=SS SZ-SS
    <- typing-read/L1 F N SZ-SS SOC-SS CM-L FM-L T2PF
      SS+FX=XMS %{=>}% _ _ _ _ SS=>GS XMS=>PiS IMP.

- : typing-read/L1 F z (set`size/+ set`size/0)
    (set-one-class/+ set-one-class/0 B-L set`shift/0)
    CM-L FM-L T2PF (set+nat=>efxmap/+ set+nat=>efxmap/0)
    %{=>}% _ _ _ _
    (set2facts/+ set2facts/0 B-L set`update/0)
    (efxmap2perm/+/out
      (efxmap2perm/0)
      (efxmap2perm-helper/+/out
        efxmap2perm-helper/0
        T2PF
        FM-L
        set`not-member/0
        inner-efxmap`fresh/0
        inner-efxmap`update/0)
      CM-L
      B-L
      tgtmap`fresh/0
      efxmap`fresh/0
      efxmap`update/0)
    (implies/trans3
      (implies/combine
        (implies/nonlinear
          (bimplies/trans
            (bimplies/neg
              (bimplies/trans
                (bimplies/conj/XX
                  (bimplies/reflexive)
                  (bimplies/rem-negneg))
                (bimplies/conj-true))
              (bool`ne/FT))
            (bimplies/trans
              (bimplies/rem-negneg)
              (bimplies/objequal-symmetric))))
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/equiv
              (equiv/transitive
                (equiv/identity)
                (equiv/identity)))
            (implies/trans
              (implies/self-implication)
              (implies/equiv-encumbered
                (equiv/transitive
                  (equiv/identity)
                  (equiv/identity))
                (equiv/reflexive))))))
      (implies/objequal
        ([o] (fldperm-fun o F ([v] PF v)) , 
          (unitperm
            (encumbered (fldperm-fun o F ([v] PF v))
              (combine
		(combine (fldperm-fun R F ([v] PF v)) empty) empty)))))
      (implies/equiv (equiv/symmetric equiv/identity))).
    
%worlds () (typing-read/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (K) (typing-read/L1 _ K _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem set=>inner-efxmap-write-no-consume/L :
    forall* {S} {M}
    forall  {N} {SZ: set`size S N}
            {S=>M: set=>inner-efxmap S efx/write M}
    exists  {FI: filter-non-consume/inner M M}
    true.

- : set=>inner-efxmap-write-no-consume/L _ _ 
    set=>inner-efxmap/0 filter-non-consume/inner/0.

- : set=>inner-efxmap-write-no-consume/L _ (set`size/+ SZ)
    (set=>inner-efxmap/+ S=>M) 
    (filter-non-consume/inner/write U FI SH-M)
    <- set`shift-total SH-S
    <- set`shift-preserves-size SZ SH-S SZS 
    <- inner-efxmap`shift-total SH-M
    <- shift-preserves-set=>inner-efxmap S=>M SH-S SH-M SS=>MS
    <- set=>inner-efxmap-write-no-consume/L _ SZS SS=>MS FI
    <- inner-efxmap`shift-implies-update SH-M U.

%worlds () (set=>inner-efxmap-write-no-consume/L _ _ _ _).
%total (N) (set=>inner-efxmap-write-no-consume/L N _ _ _).

%theorem set=>inner-efxmap-write-no-consume :
    forall* {S} {M}
    forall  {S=>M: set=>inner-efxmap S efx/write M}
    exists  {FI: filter-non-consume/inner M M}
    true.

- : set=>inner-efxmap-write-no-consume
    S=>M FI
    <- set`size-total SZ
    <- set=>inner-efxmap-write-no-consume/L _ SZ S=>M FI.

%worlds () (set=>inner-efxmap-write-no-consume _ _).
%total  {} (set=>inner-efxmap-write-no-consume _ _).


%theorem tgtmap=>efxmap-write-no-consume/L :
    forall* {GM} {XM} 
    forall  {N} {SZ: tgtmap`size GM N}
            {GM=>XM: tgtmap=>efxmap GM efx/write XM}
    exists  {FC: filter-non-consume XM XM}
    true.

- : tgtmap=>efxmap-write-no-consume/L _ _ 
    tgtmap=>efxmap/0 filter-non-consume/0.

- : tgtmap=>efxmap-write-no-consume/L _ (tgtmap`size/+ SZ)
    (tgtmap=>efxmap/+ GM=>XM S=>M)
    (filter-non-consume/+ UD FC FI SH-XM=XMS)
    <- tgtmap`shift-total SH-GM=GMS
    <- efxmap`shift-total SH-XM=XMS
    <- shift-preserves-tgtmap=>efxmap 
      GM=>XM SH-GM=GMS SH-XM=XMS GMS=>XMS
    <- tgtmap`shift-preserves-size SZ SH-GM=GMS SZS
    <- tgtmap=>efxmap-write-no-consume/L _ SZS GMS=>XMS FC
    <- set=>inner-efxmap-write-no-consume S=>M FI
    <- efxmap`shift-implies-update SH-XM=XMS UD.
    
%worlds () (tgtmap=>efxmap-write-no-consume/L _ _ _ _).
%total (N) (tgtmap=>efxmap-write-no-consume/L N _ _ _).


%theorem tgtmap=>efxmap-write-no-consume :
    forall* {GM} {XM} 
    forall  {GM=>XM: tgtmap=>efxmap GM efx/write XM}
    exists  {FC: filter-non-consume XM XM}
    true.

- : tgtmap=>efxmap-write-no-consume GM=>XM FC
    <- tgtmap`size-total SZ
    <- tgtmap=>efxmap-write-no-consume/L _ SZ GM=>XM FC.

%worlds () (tgtmap=>efxmap-write-no-consume _ _).
%total  {} (tgtmap=>efxmap-write-no-consume _ _).


%{
  (look ref-typing/read/shared in typing.elf for reference)
  from XM1 U XM3 = XM2 we can see XM3 <= XM2
  then since XM3 comes from S, we can prove that:
  if XM3 => Pi3, and Pi3 + Pi4 |- e => G + (Pi5, Pi6)
  then Pi3 "<=" Pi5.
}%

