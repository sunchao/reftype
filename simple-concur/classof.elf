%%%%% classof.elf
%%%%% infinite numbers of infinite families of objects
%%%%% John Boyland

%{%
We map each object-id to a pair (class-id,ob2).
We piggyback on natpair.elf.  Other than this, we try to
be completely agnostic about objects and classes.
%}%


%%%% Abbreviations


%abbrev classof* = [O] [C] [O'] (nat2pair O (natpair`pair/ C O')).

%abbrev classof = [O] [C] (nat2pair O (natpair`pair/ C O')).

%abbrev threadclass = z.

%abbrev threadnormals = set`map/0.

%abbrev threadvolatiles = set`map/0.




%%%% Theorems


%%% theorems about classof


%abbrev false-implies-classof = false-implies-pair2nat.


%theorem classof-deterministic :
	forall* {O1} {C1} {O1'} {O2} {C2} {O2'}
	forall {CO1:nat2pair O1 (natpair`pair/ C1 O1')}
	       {CO2:nat2pair O2 (natpair`pair/ C2 O2')}
	       {EO:nat`eq O1 O2}
	exists {CE:nat`eq C1 C2}
	true.

- : classof-deterministic CO1 CO2 nat`eq/ C1=C2
    <- nat2pair-deterministic CO1 CO2 nat`eq/ P1=P2
    <- natpair`pair-eq-implies-eq P1=P2 C1=C2 _.

%worlds () (classof-deterministic _ _ _ _).
%total { } (classof-deterministic _ _ _ _).


%theorem fresh-object-of-class-total* :
	forall {M} {C}
	exists {O} {O'} {F:mem`fresh M O} {CO:classof* O C O'}
	true.

%abbrev fresh-object-of-class-total = fresh-object-of-class-total* _ _ _ _.

- : fresh-object-of-class-total F C
    <- mem`bound-total B
    <- constrained1-pair2nat-unbounded _ _ _ _ C N>X
    <- mem`ge-bound-implies-fresh B (nat`ge/> N>X) F.

%worlds () (fresh-object-of-class-total* _ _ _ _ _ _).
%total { } (fresh-object-of-class-total* _ _ _ _ _ _).


