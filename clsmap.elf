%%% $Id: clsmap-base.elf,v 1.2 2012/10/15 19:59:52 csun Exp $
%%% Classes
%%% nat => fields
%%% Author: Chao Sun
%%% Auto-generated file

%abbrev fldmap`leq = fldmap`eq.
%abbrev fldmap`false-implies-leq = fldmap`false-implies-eq.
%abbrev fldmap`leq-reflexive = fldmap`eq-reflexive.
%abbrev fldmap`leq-transitive = fldmap`eq-transitive.


%theorem fldmap`leq-anti-symmetric :
        forall* {M1} {M2} 
        forall  {L12: fldmap`leq M1 M2} {L21: fldmap`leq M2 M1}
        exists  {E: fldmap`eq M1 M2}
        true.

- : fldmap`leq-anti-symmetric E _ E.

%worlds () (fldmap`leq-anti-symmetric _ _ _).
%total { } (fldmap`leq-anti-symmetric _ _ _).


%theorem fldmap`leq-respects-eq :
        forall* {M1} {M2} {M3} {M4}
        forall  {L1: fldmap`leq M1 M2}
                {E1: fldmap`eq M1 M3}
                {E2: fldmap`eq M2 M4}
        exists  {L3: fldmap`leq M3 M4}
        true.

- : fldmap`leq-respects-eq L _ _ L.

%worlds () (fldmap`leq-respects-eq _ _ _ _).
%total { } (fldmap`leq-respects-eq _ _ _ _).


%%%% Definitions of Maps

map : type.


map/0 : map.

map/+ : nat -> fldmap -> map -> map.

%abbrev map/1 : nat -> fldmap -> map = [N] [D] (map/+ N D map/0).


%%%% Relations on maps


% equality is defined assuming "ne" is available,
% but 'ne' may be isufficiently inhabited to
% prove things about.


eq? : map -> map -> bool -> type.

%abbrev eq : map -> map -> type = [M1] [M2] eq? M1 M2 true.

%abbrev ne : map -> map -> type = [M1] [M2] eq? M1 M2 false.


eq?/yes : eq M M.

%abbrev eq/ = eq?/yes.

%abbrev eq?/no : ne M1 M2 -> eq? M1 M2 false = [x] x.



lookup : map -> nat -> fldmap -> type.


lookup/= : lookup (map/+ N1 D _) N2 D
    <- nat`eq N1 N2.

lookup/> : lookup (map/+ N1 _ F) N2 D
    <- plus (s N0) N1 N2
    <- lookup F N0 D.


fresh : map -> nat -> type.


fresh/0 : fresh map/0 M.

fresh/< : fresh (map/+ N _ F) M
    <- gt N M.

fresh/> : fresh (map/+ N _ F) M
    <- plus (s M1) N M
    <- fresh F M1.



ne/< : lookup M1 N D -> fresh M2 N -> ne M1 M2.

ne/> : fresh M1 N -> lookup M2 N D -> ne M1 M2.



domain? : map -> nat -> bool -> type.


domain?/in : domain? M N true
    <- lookup M N _.

domain?/out : domain? M N false
    <- fresh M N.



disjoint : map -> map -> type.


disjoint/L : disjoint map/0 M.

disjoint/R : disjoint M map/0.

disjoint/< : disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N0) N1 N2
    <- disjoint M1 (map/+ N0 D2 M2).

disjoint/> : disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N3) N2 N1
    <- disjoint (map/+ N3 D1 M1) M2.



disjoint? : map -> map -> bool -> type.


disjoint?/yes : disjoint M1 M2 -> disjoint? M1 M2 true.

disjoint?/no :
	lookup M1 N D1 ->
	lookup M2 N D2 ->
    disjoint? M1 M2 false.



size : map -> nat -> type.


size/0 : size map/0 z.

size/+ : size (map/+ _ _ M) (s N)
    <- size M N.



%% useful for proving termination on map operations:

bound : map -> nat -> type.


bound/0 : bound map/0 z.

bound/+ : bound (map/+ N1 D M) N3
    <- bound M N2
    <- plus (s N1) N2 N3.


%worlds () (bound _ _).
%unique bound +B -1N.



shift : nat -> map -> map -> type.


shift/0 : shift _ map/0 map/0.

shift/+ : shift N1 (map/+ N2 D M) (map/+ N3 D M)
    <- plus (s N1) N2 N3.


%worlds () (shift _ _ _).
%unique shift +N +M -1M3.



update : map -> nat -> fldmap -> map -> type.


update/0 : update map/0 N D (map/+ N D map/0).

update/= : update (map/+ N1 _ F) N2 D (map/+ N2 D F)
    <- nat`eq N1 N2.

update/< : update (map/+ N1 D1 F) N2 D2 (map/+ N2 D2 (map/+ N3 D1 F))
    <- plus (s N3) N2 N1.

update/> : update (map/+ N1 D1 F1) N2 D2 (map/+ N1 D1 F2)
    <- plus (s N0) N1 N2
    <- update F1 N0 D2 F2.




%%%% Theorems



%%% Theorems about eq


%theorem meta-eq :
	forall {M} {N} {E:eq M N}
	true.
- : meta-eq M M eq/.
%worlds () (meta-eq _ _ _).
%total {} (meta-eq _ _ _).
%reduces M = N (meta-eq M N _).


%theorem false-implies-eq? :
	forall*	{M1} {M2} {B}
	forall	{F:void}
	exists	{E: eq? M1 M2 B}
	true.

%worlds () (false-implies-eq? _ _).
%total { } (false-implies-eq? _ _).

%abbrev false-implies-eq = false-implies-eq?.

%abbrev false-implies-ne = false-implies-eq?.


%theorem eq-reflexive : forall {M} exists {E:eq M M} true.

- : eq-reflexive _ eq/.

%worlds () (eq-reflexive M %{=>}% M=M).
%total {} (eq-reflexive _ _).


%theorem eq?-symmetric :
	forall*	{M1} {M2} {B}
	forall	{E1: eq? M1 M2 B}
	exists	{E2: eq? M2 M1 B}
	true.

- : eq?-symmetric eq/ eq/.

- : eq?-symmetric (ne/< L F) (ne/> F L).

- : eq?-symmetric (ne/> F L) (ne/< L F).


%worlds () (eq?-symmetric _ _).
%total { } (eq?-symmetric _ _).

%abbrev eq-symmetric = eq?-symmetric.

%abbrev ne-symmetric = eq?-symmetric.


%theorem eq-transitive:
	forall* {M1} {M2} {M3}
	forall {E12:eq M1 M2} {E23:eq M2 M3}
	exists {E13:eq M1 M3}
	true.

- : eq-transitive eq/ eq/ eq/.

%worlds () (eq-transitive M1=M2 M2=M3 %{=>}% M1=M3).
%total {} (eq-transitive _ _ _).


%theorem map/+-preserves-eq? :
	forall* {N} {NP} {D} {DP} {F} {FP} {B}
	forall {EN:nat`eq N NP} {ED:fldmap`eq D DP} {EF:eq? F FP B}
	exists {E:eq? (map/+ N D F) (map/+ NP DP FP) B}
	true.

- : map/+-preserves-eq? nat`eq/ fldmap`eq/ eq/ eq/.

- : map/+-preserves-eq? nat`eq/ fldmap`eq/ (ne/< L F) 
	(ne/< (lookup/> L P) (fresh/> F P))
    <- plus-total P.

- : map/+-preserves-eq? nat`eq/ fldmap`eq/ (ne/> F L) 
	(ne/> (fresh/> F P) (lookup/> L P))
    <- plus-total P.


%worlds () (map/+-preserves-eq? _ _ _ _).
%total { } (map/+-preserves-eq? _ _ _ _).

%abbrev map/+-preserves-eq = map/+-preserves-eq?.

%abbrev map/+-preserves-ne = map/+-preserves-eq?.


%theorem map/+-preserves-eq-converse :
	forall* {N} {NP} {D} {DP} {F} {FP}
	forall {E:eq (map/+ N D F) (map/+ NP DP FP)}
	exists {EN:nat`eq N NP} {ED:fldmap`eq D DP} {EF:eq F FP}
	true.

- : map/+-preserves-eq-converse eq/ nat`eq/ fldmap`eq/ eq/.

%worlds () (map/+-preserves-eq-converse _ _ _ _).
%total {} (map/+-preserves-eq-converse _ _ _ _).


%theorem eq-no-occur :
	forall*  {M} {N} {D}
	forall {E:eq M (map/+ N D M)}
	exists {F:void}
	true.

%worlds () (eq-no-occur _ _).
%total {} (eq-no-occur _ _).


%theorem eq-contradiction :
	forall* {N} {D} {M}
	forall {E:eq map/0 (map/+ N D M)}
	exists {F:void}
	true.

%worlds () (eq-contradiction _ _).
%total {} (eq-contradiction _ _).



%%% Theorems about lookup


%theorem false-implies-lookup : 
	forall* {M} {N} {D}
	forall {F:void}
	exists {L:lookup M N D}
	true.

%worlds () (false-implies-lookup _ %{=>}% F^N=D).
%total {} (false-implies-lookup _ _).


%theorem lookup-respects-eq :
	forall* {M} {N} {D} {MP} {NP} {DP}
	forall {L:lookup M N D} {EM:eq M MP} {EN:nat`eq N NP} {ED:fldmap`eq D DP}
	exists {LP:lookup MP NP DP}
	true.

- : lookup-respects-eq L eq/ nat`eq/ fldmap`eq/ L.

%worlds () (lookup-respects-eq M^N=D M=MP N=NP D=DP %{=>}% MP^NP=DP).
%total {} (lookup-respects-eq _ _ _ _ _).
%reduces X = Y (lookup-respects-eq X _ _ _ Y).


%theorem meta-reduces-lookup :
	forall*	{M1} {M2} {N1} {N2} {D1} {D2}
	forall	{F: void}
		{L1: lookup M1 N1 D1}
		{L2: lookup M2 N2 D2}
	true.

%worlds () (meta-reduces-lookup _ _ _).
%total { } (meta-reduces-lookup _ _ _).
%reduces X < Y (meta-reduces-lookup _ X Y).


%theorem lookup/>-inversion :
	forall*	{N1} {D1} {M1} {N2} {D2} {N0}
	forall	{L: lookup (map/+ N1 D1 M1) N2 D2}
		{P: plus (s N0) N1 N2}
	exists	{LP: lookup M1 N0 D2}
	true. 

- : lookup/>-inversion (LEQ:lookup (map/+ N _ _) N _) P L
    <- plus-implies-gt P nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-lookup F L
    <- meta-reduces-lookup F L LEQ.

- : lookup/>-inversion (lookup/> LP P) PX LPX
    <- plus-right-cancels P PX nat`eq/ nat`eq/ SN0=SNX
    <- succ-cancels SN0=SNX N0=NX
    <- lookup-respects-eq LP eq/ N0=NX fldmap`eq/ LPX.

%worlds () (lookup/>-inversion _ _ _).
%total { } (lookup/>-inversion _ _ _).
%reduces Y < X (lookup/>-inversion X _ Y).


%theorem lookup-deterministic :
	forall* {M} {N} {D} {MP} {NP} {DP}
	forall {L:lookup M N D} {LP:lookup MP NP DP}
               {EM:eq M MP} {EN:nat`eq N NP}
	exists {ED:fldmap`eq D DP}
	true.

%abbrev lookup-unique = lookup-deterministic.

- : lookup-deterministic (lookup/= nat`eq/) (lookup/= nat`eq/) eq/ nat`eq/ fldmap`eq/.

- : lookup-deterministic (lookup/> F^N0=D   N0+1+N1=N2) 
                         (lookup/> F^N0P=DP N0P+1+N1=N2) eq/ nat`eq/ D=DP
    <- plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- lookup-deterministic F^N0=D F^N0P=DP eq/ N0=N0P D=DP.

%% contradiction cases
- : lookup-deterministic (lookup/= nat`eq/) (lookup/> _ N0+1+N=N) 
                         eq/ nat`eq/ D=DP
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N FALSE
    <- fldmap`false-implies-eq FALSE D=DP.

- : lookup-deterministic (lookup/> _ N0+1+N=N) (lookup/= nat`eq/)
                         eq/ nat`eq/ D=DP
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N FALSE
    <- fldmap`false-implies-eq FALSE D=DP.

%worlds () (lookup-deterministic M^N=D MP^NP=DP M=MP N=NP %{=>}% D=DP).
%total (L) (lookup-deterministic L _ _ _ _).


%% lookup is NOT total


%theorem lookup-contradiction :
	forall* {N} {D}
	forall {L:lookup map/0 N D}
	exists {F:void}
	true.

%worlds () (lookup-contradiction _ _).
%total { } (lookup-contradiction _ _).


%theorem lookup-one-choice :
	forall* {N1} {D1} {N2} {D2}
	forall  {L:lookup (map/+ N1 D1 map/0) N2 D2}
	exists  {NE:nat`eq N1 N2} {DE:fldmap`eq D1 D2}
	true.

- : lookup-one-choice (lookup/= nat`eq/) nat`eq/ fldmap`eq/.

%worlds () (lookup-one-choice _ _ _).
%total { } (lookup-one-choice _ _ _).


%theorem lookup-implies-ge :
        forall* {N1} {D1} {M1} {N} {D}
        forall  {L: lookup (map/+ N1 D1 M1) N D}
        exists  {G: nat`ge N N1}
        true.

- : lookup-implies-ge (lookup/= nat`eq/) (nat`ge/= nat`eq/).

- : lookup-implies-ge (lookup/> _ P) (nat`ge/> GT)
    <- plus-implies-gt P nat`eq/ GT.
    
%worlds () (lookup-implies-ge _ _).
%total { } (lookup-implies-ge _ _).



%%% Theorems about fresh


%theorem false-implies-fresh : 
	forall* {M} {N} forall {F:void} exists {D:fresh M N} true.

%worlds () (false-implies-fresh _ %{=>}% N-not-in-domain-M).
%total {} (false-implies-fresh _ _).


%theorem fresh-respects-eq :
	forall* {M} {N} {MP} {NP}
	forall {D:fresh M N} {EM:eq M MP} {EN:nat`eq N NP}
	exists {DP:fresh MP NP}
	true.

- : fresh-respects-eq D eq/ nat`eq/ D.

%worlds () (fresh-respects-eq _ _ _ _).
%total {} (fresh-respects-eq _ _ _ _).


%theorem fresh/>-inversion :
	forall*	{M} {N} {D} {N1} {N2}
	forall	{F: fresh (map/+ N D M) N1}
		{P: plus (s N2) N N1}
	exists	{F1: fresh M N2}
	true.

- : fresh/>-inversion (fresh/< G1) P FR
    <- plus-implies-gt P nat`eq/ G
    <- gt-anti-symmetric G1 G F
    <- false-implies-fresh F FR.

- : fresh/>-inversion (fresh/> F1 P1) P F
    <- plus-right-cancels P1 P nat`eq/ nat`eq/ SEQ
    <- succ-cancels SEQ EQ
    <- fresh-respects-eq F1 eq/ EQ F.

%worlds () (fresh/>-inversion _ _ _).
%total { } (fresh/>-inversion _ _ _).


%% fresh is NOT deterministic

%theorem fresh-total* :
	forall {M}
	exists {N} {F:fresh M N}
	true.

- : fresh-total* map/0 z fresh/0.

- : fresh-total* (map/+ N1 _ M) N3 (fresh/> F N+1+N1=N3)
    <- fresh-total* M N F
    <- plus-total* (s N) N1 N3 N+1+N1=N3.

%worlds () (fresh-total* M %{=>}% N N-not-in-domain-of-M).
%total (M) (fresh-total* M _ _).

%abbrev fresh-total = fresh-total* _ _.


%theorem fresh-lookup-not-equal :
	forall* {M} {N1} {N2} {D2}
	forall {F:fresh M N1} {L:lookup M N2 D2}
	exists {NE:nat`ne N1 N2}
	true.

- : fresh-lookup-not-equal (fresh/< N2>N1) (lookup/= nat`eq/) (nat`ne/< N2>N1).

- : fresh-lookup-not-equal (fresh/< N1>N3) (lookup/> _ N0+1+N1=N2) 
                           (nat`ne/< N2>N3)
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- gt-transitive N2>N1 N1>N3 N2>N3.

- : fresh-lookup-not-equal (fresh/> _ X+1+N2=N1) (lookup/= nat`eq/) (nat`ne/> N1>N2)
    <- plus-implies-gt X+1+N2=N1 nat`eq/ N1>N2.

- : fresh-lookup-not-equal (fresh/> F N4+1+N1=N3) (lookup/> L N0+1+N1=N2)
                           N3<>N2
    <- fresh-lookup-not-equal F L N4<>N0
    <- succ-preserves-ne N4<>N0 N4+1<>N0+1
    <- plus-right-preserves-ne* N4+1<>N0+1 N4+1+N1=N3 N0+1+N1=N2 N3<>N2.

%worlds () (fresh-lookup-not-equal N1-not-in-domain-of-M M^N2=D %{=>}% N1<>N2).
%total (F) (fresh-lookup-not-equal F _ _).


%theorem fresh-contradiction :
	forall* {M} {N} {D}
	forall {F:fresh (map/+ N D M) N}
        exists {V:void}
	true.

- : fresh-contradiction (fresh/< N>N) V
    <- nat`gt-anti-reflexive N>N V.

- : fresh-contradiction (fresh/> _ N0+1+N=N) V
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N V.

%worlds () (fresh-contradiction _ _).
%total {} (fresh-contradiction _ _).


%theorem ne-implies-unit-map-fresh :
	forall* {N1} {D} {N2}
	forall {NE:nat`ne N1 N2}
	exists {F:fresh (map/+ N1 D map/0) N2}
	true.

- : ne-implies-unit-map-fresh 
     (nat`ne/< N1<N2) (fresh/> fresh/0 N0+1+N1=N2)
    <- nat`gt-implies-plus N1<N2 N0 N0+1+N1=N2.

- : ne-implies-unit-map-fresh
     (nat`ne/> N1>N2) (fresh/< N1>N2).

%worlds () (ne-implies-unit-map-fresh _ _).
%total { } (ne-implies-unit-map-fresh _ _).


%theorem plus-right-preserves-fresh* :
	forall* {M} {N1} {D} {N2} {N} {N3} {N4}
        forall {F:fresh (map/+ N1 D M) N2}
               {P1:plus N1 N N3} {P2:plus N2 N N4}
        exists {FP:fresh (map/+ N3 D M) N4}
	true.

- : plus-right-preserves-fresh* (fresh/< N2>N1) N1+N=N3 N2+N=N4 (fresh/< N4>N3)
    <- nat`plus-right-preserves-gt* N2>N1 N1+N=N3 N2+N=N4 N4>N3.

- : plus-right-preserves-fresh* (fresh/> F10 N0+1+N1=N2) N1+N=N3 N2+N=N4
                                (fresh/> F10 N0+1+N3=N4)
    <- nat`plus-associative* N0+1+N1=N2 N2+N=N4 N1+N=N3 N0+1+N3=N4.

%worlds () (plus-right-preserves-fresh* _ _ _ _).
%total {} (plus-right-preserves-fresh* _ _ _ _).


%theorem fresh-lookup-implies-ne :
	forall* {M1} {N1} {M2} {N2} {D2}
	forall {L1:fresh M1 N1}
	       {L2:lookup M2 N2 D2}
	       {EN:nat`eq N1 N2}
	exists {NM:ne M1 M2}
	true.

- : fresh-lookup-implies-ne F L nat`eq/ (ne/> F L).

%worlds () (fresh-lookup-implies-ne _ _ _ _).
%total { } (fresh-lookup-implies-ne _ _ _ _).



%%% Theorems about eq?/ne


%% false-implies-eq? already done

%theorem eq?-respects-eq :
	forall* {M11} {M12} {M21} {M22} {B}
	forall {N1:eq? M11 M12 B} {E1:eq M11 M21} {E2:eq M12 M22}
	exists {N2:eq? M21 M22 B}
	true.

%abbrev ne-respects-eq = eq?-respects-eq.


%theorem ne-anti-reflexive :
	forall* {M}
	forall {N:ne M M}
	exists {F:void}
	true.

- : ne-anti-reflexive (ne/< L F) V
    <- fresh-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N V.

- : ne-anti-reflexive (ne/> F L) V
    <- fresh-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N V.


%worlds () (ne-anti-reflexive _ _).
%total (N) (ne-anti-reflexive N _).


%theorem eq-ne-implies-false :
        forall* {X} {Y}
        forall {D1:eq X Y} {D2:ne X Y}
        exists {F:void}
        true.

- : eq-ne-implies-false eq/ X<>X F
    <- ne-anti-reflexive X<>X F.

%worlds () (eq-ne-implies-false _ _ _).
%total { } (eq-ne-implies-false _ _ _).




%%% Theorems about map/domain


%theorem false-implies-domain? :
	forall* {M} {N} {D}
	forall {F:void}
	exists {MD:domain? M N D}
	true.

%worlds () (false-implies-domain? _ _).
%total {} (false-implies-domain? _ _).


%theorem domain?-respects-eq :
	forall* {M1} {N1} {B1} {M2} {N2} {B2}
	forall  {MD1:domain? M1 N1 B1}
		{EM:eq M1 M2}
		{EN:nat`eq N1 N2}
		{BE:bool`eq B1 B2}
	exists  {MD2:domain? M2 N2 B2}
	true.

- : domain?-respects-eq MD eq/ nat`eq/ bool`eq/ MD.

%worlds () (domain?-respects-eq _ _ _ _ _).
%total { } (domain?-respects-eq _ _ _ _ _).


%theorem domain?-deterministic :
	forall* {M1} {N1} {B1} {M2} {N2} {B2}
	forall  {MD1:domain? M1 N1 B1}
		{MD2:domain? M2 N2 B2}
		{EM:eq M1 M2}
		{EN:nat`eq N1 N2}
	exists	{BE:bool`eq B1 B2}
	true.

%abbrev domain?-unique = domain?-deterministic.

- : domain?-deterministic _ _ _ _ bool`eq/.

- : domain?-deterministic (domain?/in L) (domain?/out F) eq/ nat`eq/ BE
    <- fresh-lookup-not-equal F L NE
    <- nat`ne-anti-reflexive NE V
    <- bool`false-implies-eq V BE.

- : domain?-deterministic (domain?/out F) (domain?/in L) eq/ nat`eq/ BE
    <- fresh-lookup-not-equal F L NE
    <- nat`ne-anti-reflexive NE V
    <- bool`false-implies-eq V BE.

%worlds () (domain?-deterministic _ _ _ _ _).
%total { } (domain?-deterministic _ _ _ _ _).


%theorem domain?-total* :
	forall {M} {N}
	exists {B} {MD:domain? M N B}
	true.

%% we need a lemma
%theorem domain?-map/+-total :
	forall {N1} {D1} {M1} {N2} {C} {CMP:nat`compare N1 N2 C}
	exists {B} {MD:domain? (map/+ N1 D1 M1) N2 B}
	true.

%% and this lemma needs a lemma
%theorem domain?-map/+-complete :
	forall {N1} {D1} {M1} {N2} {N0} {P:plus (s N0) N1 N2}
               {B} {MD1:domain? M1 N0 B}
	exists {MD:domain? (map/+ N1 D1 M1) N2 B}
	true.

- : domain?-total* map/0 N false (domain?/out fresh/0).

- : domain?-total* (map/+ N1 D1 M1) N2 B MD
    <- nat`compare-total* N1 N2 C CMP
    <- domain?-map/+-total N1 D1 M1 N2 C CMP B MD.

- : domain?-map/+-total N1 D1 M1 N2 equal CMP true 
                           (domain?/in (lookup/= N1=N2))
    <- equal-implies-eq CMP N1=N2.

- : domain?-map/+-total N1 D1 M1 N2 greater CMP false 
                           (domain?/out (fresh/< N1>N2))
    <- greater-implies-gt CMP N1>N2.

- : domain?-map/+-total N1 D1 M1 N2 less CMP B MD
    <- less-implies-lt CMP N2>N1
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- domain?-total* M1 N0 B MD1
    <- domain?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 B MD1 MD.

- : domain?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 true (domain?/in L1)
                              (domain?/in (lookup/> L1 N0+1+N1=N2)).

- : domain?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 false (domain?/out F1)
                              (domain?/out (fresh/> F1 N0+1+N1=N2)).

%worlds () (domain?-map/+-complete _ _ _ _ _ _ _ _ _).
%total {} (domain?-map/+-complete _ _ _ _ _ _ _ _ _).

%worlds () (domain?-total* _ _ _ _)
           (domain?-map/+-total _ _ _ _ _ _ _ _).
%total (M M1) (domain?-total* M _ _ _) 
              (domain?-map/+-total _ _ M1 _ _ _ _ _).

%abbrev domain?-total = domain?-total* _ _ _.


%theorem in-implies-lookup :
	forall* {M} {N}
	forall {MD:domain? M N true}
	exists {D} {L:lookup M N D}
	true.

- : in-implies-lookup (domain?/in L) _ L.

%worlds () (in-implies-lookup _ _ _).
%total {} (in-implies-lookup _ _ _).


%theorem out-implies-fresh :
	forall* {M} {N}
	forall {MD:domain? M N false}
	exists {F:fresh M N}
	true.

- : out-implies-fresh (domain?/out F) F.

%worlds () (out-implies-fresh _ _).
%total {} (out-implies-fresh _ _).



%%% Theorems about disjoint


%theorem false-implies-disjoint :
	forall* {M1} {M2}
	forall {F:void}
	exists {D:disjoint M1 M2}
	true.

%worlds () (false-implies-disjoint _ _).
%total { } (false-implies-disjoint _ _).


%theorem disjoint-respects-eq :
	forall* {M1} {M2} {M1P} {M2P}
	forall {A:disjoint M1 M2} {E1:eq M1 M1P} {E2:eq M2 M2P} 
	exists {AP:disjoint M1P M2P}
	true.

- : disjoint-respects-eq A eq/ eq/ A.

%worlds () (disjoint-respects-eq _ _ _ _).
%total {} (disjoint-respects-eq _ _ _ _).
%reduces A = AP (disjoint-respects-eq A _ _ AP).


%theorem disjoint/=-contradiction :
	forall* {N1} {D1} {M1} {N2} {D2} {M2}
	forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
	       {G:nat`eq N1 N2}
	exists {F:void}
	true.

- : disjoint/=-contradiction (disjoint/< _ N0+1+N=N) nat`eq/ F
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F.

- : disjoint/=-contradiction (disjoint/> _ N3+1+N=N) nat`eq/ F
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F.

%worlds () (disjoint/=-contradiction _ _ _).
%total { } (disjoint/=-contradiction _ _ _).


%theorem disjoint/<-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}
	forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
               {P:plus (s N0) N1 N2} 	       
	exists {AP:disjoint M1 (map/+ N0 D2 M2)}
	true.

- : disjoint/<-inversion (disjoint/< A P) PP AP
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P fldmap`eq/ eq/ M022=M022P
    <- disjoint-respects-eq A eq/ M022=M022P AP.

- : disjoint/<-inversion (disjoint/> AP N3+1+N2=N1) N0+1+N1=N2 A
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M311=M1
    <- false-implies-eq F M2=M022
    <- disjoint-respects-eq AP M311=M1 M2=M022 A.

%worlds () (disjoint/<-inversion _ _ _).
%total {}  (disjoint/<-inversion _ _ _).
%reduces AP < A (disjoint/<-inversion A _ AP).


%theorem disjoint/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
	forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
	       {P:plus (s N3) N2 N1}
	exists {AP:disjoint (map/+ N3 D1 M1) M2}
	true.

- : disjoint/>-inversion (disjoint/> A P) PP AP
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P fldmap`eq/ eq/ M311=M311P
    <- disjoint-respects-eq A M311=M311P eq/ AP.

- : disjoint/>-inversion (disjoint/< AP N0+1+N1=N2) N3+1+N2=N1 A
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M1=M311
    <- false-implies-eq F M022=M2
    <- disjoint-respects-eq AP M1=M311 M022=M2 A.

%worlds () (disjoint/>-inversion _ _ _).
%total { } (disjoint/>-inversion _ _ _).
%reduces AP < A (disjoint/>-inversion A _ AP).


%theorem disjoint-anti-reflexive :
	forall* {M}
	forall {D:disjoint M M}
	exists {E:eq map/0 M}
	true.

- : disjoint-anti-reflexive disjoint/L eq/.

- : disjoint-anti-reflexive disjoint/R eq/.

- : disjoint-anti-reflexive (A:disjoint (map/+ N D M) (map/+ N D M)) E
    <- disjoint/=-contradiction A nat`eq/ F
    <- false-implies-eq F E.

%worlds () (disjoint-anti-reflexive _ _).
%total { } (disjoint-anti-reflexive _ _).


%theorem disjoint-symmetric :
	forall* {M1} {M2}
	forall {D:disjoint M1 M2} 
	exists {D:disjoint M2 M1}
	true.

- : disjoint-symmetric disjoint/L disjoint/R.

- : disjoint-symmetric disjoint/R disjoint/L.

- : disjoint-symmetric (disjoint/< D P) (disjoint/> DP P)
    <- disjoint-symmetric D DP.

- : disjoint-symmetric (disjoint/> D P) (disjoint/< DP P)
    <- disjoint-symmetric D DP.

%worlds () (disjoint-symmetric _ _).
%total (D) (disjoint-symmetric D _).


%theorem disjoint-lookup-contradiction :
	forall* {M1} {M2} {N} {D1} {D2}
	forall {A:disjoint M1 M2}
               {L1:lookup M1 N D1} {L2:lookup M2 N D2}
	exists {F:void}
	true.

- : disjoint-lookup-contradiction disjoint/L L _ F
    <- lookup-contradiction L F.

- : disjoint-lookup-contradiction disjoint/R _ L F
    <- lookup-contradiction L F.

- : disjoint-lookup-contradiction (disjoint/< _ N0+1+N=N)
                                  (lookup/= nat`eq/) (lookup/= nat`eq/) F
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : disjoint-lookup-contradiction (disjoint/< _ N0+1+N1=N2)
                                  (lookup/= nat`eq/) 
                                  (lookup/> _ N3+1+N2=N1) F
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- gt-anti-symmetric N2>N1 N1>N2 F.
    
- : disjoint-lookup-contradiction (disjoint/< D N0+1+N1=N2)
                                  (lookup/> L1P N0P+1+N1=N2)
                                  (lookup/= nat`eq/) F
    <- plus-right-cancels N0P+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N0P+1=N0+1
    <- succ-cancels N0P+1=N0+1 N0P=N0
    <- lookup-respects-eq L1P eq/ N0P=N0 fldmap`eq/ L1
    <- disjoint-lookup-contradiction D L1 (lookup/= nat`eq/) F.

- : disjoint-lookup-contradiction (disjoint/< D N0+1+N1=N2)
                                  (lookup/> L1 N1P+1+N1=N) 
                                  (lookup/> L2 N2P+1+N2=N) F
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N2P+1+N2=N NX
                                 N2P+1+N0=NX NX+N1+1=N
    <- plus-swap-succ N1P+1+N1=N N1P+N1+1=N
    <- plus-right-cancels NX+N1+1=N N1P+N1+1=N nat`eq/ nat`eq/ NX=N1P
    <- plus-respects-eq N2P+1+N0=NX nat`eq/ nat`eq/ NX=N1P N2P+1+N0=N1P
    <- disjoint-lookup-contradiction D L1 (lookup/> L2 N2P+1+N0=N1P) F.

- : disjoint-lookup-contradiction (disjoint/> _ N3+1+N=N)
                                  (lookup/= nat`eq/) (lookup/= nat`eq/) F
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : disjoint-lookup-contradiction (disjoint/> _ N3+1+N2=N1)
                                  (lookup/> _ N3+1+N1=N2)
                                  (lookup/= nat`eq/) F
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- plus-implies-gt N3+1+N1=N2 nat`eq/ N2>N1
    <- gt-anti-symmetric N1>N2 N2>N1 F.
    
- : disjoint-lookup-contradiction (disjoint/> D N3+1+N2=N1)
                                  (lookup/= nat`eq/)
                                  (lookup/> L2P N3P+1+N2=N1) F
    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- succ-cancels N3P+1=N3+1 N3P=N3
    <- lookup-respects-eq L2P eq/ N3P=N3 fldmap`eq/ L2
    <- disjoint-lookup-contradiction D (lookup/= nat`eq/) L2 F.

- : disjoint-lookup-contradiction (disjoint/> D N3+1+N2=N1)
                                  (lookup/> L1 N1P+1+N1=N)
                                  (lookup/> L2 N2P+1+N2=N) F 
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N1P+1+N1=N NX
                                 N1P+1+N3=NX NX+N2+1=N
    <- plus-swap-succ N2P+1+N2=N N2P+N2+1=N
    <- plus-right-cancels NX+N2+1=N N2P+N2+1=N nat`eq/ nat`eq/ NX=N2P
    <- plus-respects-eq N1P+1+N3=NX nat`eq/ nat`eq/ NX=N2P N1P+1+N3=N2P
    <- disjoint-lookup-contradiction D (lookup/> L1 N1P+1+N3=N2P) L2 F.

%worlds () (disjoint-lookup-contradiction _ _ _ _).
%total (D) (disjoint-lookup-contradiction D _ _ _).


%theorem disjoint-lookup-implies-fresh :
	forall*	{M1} {N} {D} {M2}
	forall	{L: lookup M1 N D}
		{A: disjoint M1 M2}
	exists	{F: fresh M2 N}
	true.

%theorem disjoint-lookup-implies-fresh/L :
	forall*	{M1} {N} {D} {M2} {B}
	forall	{L: lookup M1 N D}
		{A: disjoint M1 M2}
		{D?: domain? M2 N B}
	exists	{F: fresh M2 N}
	true.

- : disjoint-lookup-implies-fresh/L
	L1 A (domain?/in L2) FR
    <- disjoint-lookup-contradiction A L1 L2 F
    <- false-implies-fresh F FR.

- : disjoint-lookup-implies-fresh/L
	_ _ (domain?/out FR) FR.

%worlds () (disjoint-lookup-implies-fresh/L _ _ _ _).
%total { } (disjoint-lookup-implies-fresh/L _ _ _ _).

- : disjoint-lookup-implies-fresh L D F
    <- domain?-total D?
    <- disjoint-lookup-implies-fresh/L L D D? F.

%worlds () (disjoint-lookup-implies-fresh _ _ _).
%total { } (disjoint-lookup-implies-fresh _ _ _).


%theorem shift-left-preserves-disjoint :
	forall* {N} {D} {M1} {M2} {SM1}
	forall {A:disjoint M1 M2} {S1:shift N M1 SM1}
        exists {SA:disjoint SM1 (map/+ N D M2)}
        true.

- : shift-left-preserves-disjoint _ shift/0 disjoint/L.

- : shift-left-preserves-disjoint M111*M2 (shift/+ N+1+N1=N1P)
                              (disjoint/> M111*M2 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-disjoint _ _ _).
%total { } (shift-left-preserves-disjoint _ _ _).


%theorem shift-left-preserves-disjoint-converse :
	forall* {N} {D} {M1} {M2} {SM1}
	forall {SA:disjoint SM1 (map/+ N D M2)} {S1:shift N M1 SM1}
        exists {A:disjoint M1 M2}
	true.

- : shift-left-preserves-disjoint-converse _ shift/0 disjoint/L.

- : shift-left-preserves-disjoint-converse M111*M222 (shift/+ N2+1+N3=N1)
                                           M311*M2
    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1
    <- disjoint/>-inversion M111*M222 N3+1+N2=N1 M311*M2.

%worlds () (shift-left-preserves-disjoint-converse _ _ _).
%total { } (shift-left-preserves-disjoint-converse _ _ _).


%theorem shift-right-preserves-disjoint :
	forall* {N} {D} {M1} {M2} {SM2}
	forall {A:disjoint M1 M2} {S2:shift N M2 SM2}
        exists {SA:disjoint (map/+ N D M1) SM2}
	true.

- : shift-right-preserves-disjoint _ shift/0 disjoint/R.

- : shift-right-preserves-disjoint M1*M222 (shift/+ N+1+N2=N2P)
                               (disjoint/< M1*M222 N2+1+N=N2P)
    <- plus-swap-succ N+1+N2=N2P N+N2+1=N2P
    <- plus-commutative N+N2+1=N2P N2+1+N=N2P.

%worlds () (shift-right-preserves-disjoint _ _ _).
%total { } (shift-right-preserves-disjoint _ _ _).


%theorem shift-right-preserves-disjoint-converse :
	forall* {N} {D} {M1} {M2} {SM2}
	forall {SA:disjoint (map/+ N D M1) SM2} {S2:shift N M2 SM2}
        exists {A:disjoint M1 M2}
	true.

- : shift-right-preserves-disjoint-converse _ shift/0 disjoint/R.

- : shift-right-preserves-disjoint-converse M111*M322 (shift/+ N1+1+N2=N3)
                                            M1*M222
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- disjoint/<-inversion M111*M322 N2+1+N1=N3 M1*M222.

%worlds () (shift-right-preserves-disjoint-converse _ _ _).
%total { } (shift-right-preserves-disjoint-converse _ _ _).


%theorem shift-preserves-disjoint :
	forall* {N} {M1} {M2} {SM1} {SM2}
	forall {A:disjoint M1 M2} 
               {S1:shift N M1 SM1} {S2:shift N M2 SM2}
	exists {SA:disjoint SM1 SM2}
	true.

- : shift-preserves-disjoint _ shift/0 _ disjoint/L.

- : shift-preserves-disjoint _ _ shift/0 disjoint/R.

- : shift-preserves-disjoint (disjoint/< M1*M022 N0+1+N1=N2)
                             (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                             (disjoint/< M1*M022 N0+1+N4=N5)
    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4
    <- plus-commutative N+N1+1=N4 N1+1+N=N4
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.

- : shift-preserves-disjoint (disjoint/> M311*M2 N3+1+N2=N1)
                             (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                             (disjoint/> M311*M2 N3+1+N5=N4)
    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5
    <- plus-commutative N+N2+1=N5 N2+1+N=N5
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4.

%worlds () (shift-preserves-disjoint _ _ _ _).
%total { } (shift-preserves-disjoint _ _ _ _).


%theorem shift-preserves-disjoint-converse :
	forall* {N} {M1} {M2} {SM1} {SM2}
	forall {SA:disjoint SM1 SM2}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	exists {A:disjoint M1 M2}
	true.

- : shift-preserves-disjoint-converse _ shift/0 _ disjoint/L.

- : shift-preserves-disjoint-converse _ _ shift/0 disjoint/R.

- : shift-preserves-disjoint-converse (disjoint/< M1*M055 N0+1+N4=N5)
                                      (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
				      (disjoint/< M1*M055 N0+1+N1=N2)
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4
    <- plus-associative-converse N1+N+1=N4 N0+1+N4=N5 N2P N0+1+N1=N2P N2P+N+1=N5
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-right-cancels N2P+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2P=N2
    <- plus-respects-eq N0+1+N1=N2P nat`eq/ nat`eq/ N2P=N2 N0+1+N1=N2.
                                  
- : shift-preserves-disjoint-converse (disjoint/> M611*M2 N6+1+N5=N4)
                                      (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                                      (disjoint/> M611*M2 N6+1+N2=N1)
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5
    <- plus-associative-converse N2+N+1=N5 N6+1+N5=N4 N1P N6+1+N2=N1P N1P+N+1=N4
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-right-cancels N1P+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1P=N1
    <- plus-respects-eq N6+1+N2=N1P nat`eq/ nat`eq/ N1P=N1 N6+1+N2=N1.

%worlds () (shift-preserves-disjoint-converse _ _ _ _).
%total { } (shift-preserves-disjoint-converse _ _ _ _).


%theorem can-construct-unit-disjoint:
	forall*	{N} {D} {M1} {M}
	forall	{S: shift N M1 M}
	exists	{A: disjoint M (map/+ N D map/0)}
	true.

- : can-construct-unit-disjoint shift/0 disjoint/L.

- : can-construct-unit-disjoint (shift/+ P) (disjoint/> disjoint/R PPP)
    <- plus-swap-succ P PP
    <- plus-commutative PP PPP.

%worlds () (can-construct-unit-disjoint _ _).
%total { } (can-construct-unit-disjoint _ _).


%theorem ne-implies-disjoint :
	forall* {N1} {D1} {N2} {D2}
	forall	{NE:nat`ne N1 N2}
	exists	{D:disjoint (map/+ N1 D1 map/0) (map/+ N2 D2 map/0)}
	true.

- : ne-implies-disjoint (nat`ne/< N1<N2) 
	(disjoint/< disjoint/L N0+1+N1=N2)
    <- gt-implies-plus N1<N2 _ N0+1+N1=N2.

- : ne-implies-disjoint (nat`ne/> N1>N2) 
	(disjoint/> disjoint/R N3+1+N2=N1)
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1.

%worlds () (ne-implies-disjoint _ _).
%total { } (ne-implies-disjoint _ _).


%theorem fresh-implies-unit-disjoint :
	forall*	{N} {M} {D}
	forall	{F:fresh M N}
	exists	{D: disjoint M (map/+ N D map/0)}
	true.

- : fresh-implies-unit-disjoint fresh/0 disjoint/L.

- : fresh-implies-unit-disjoint (fresh/< G) (disjoint/> disjoint/R P)
    <- gt-implies-plus G _ P.

- : fresh-implies-unit-disjoint (fresh/> F P) (disjoint/< D P)
    <- fresh-implies-unit-disjoint F D.

%worlds () (fresh-implies-unit-disjoint _ _).
%total (F) (fresh-implies-unit-disjoint F _).



%%% Theorems about size


%theorem false-implies-size :
	forall* {M} {N}
	forall {F:void}
	exists {SZ:size M N}
	true.

%worlds () (false-implies-size _ _).
%total { } (false-implies-size _ _).


%theorem size-total* :
	forall {M} 
	exists {N} {MX:size M N}
	true.

- : size-total* map/0 _ size/0.

- : size-total* _ _ (size/+ SZ)
    <- size-total* _ _ SZ.

%worlds () (size-total* _ _ _).
%total (M) (size-total* M _ _).


%abbrev size-total = size-total* _ _.


%theorem size-respects-eq :
	forall* {M1} {M2} {N1} {N2}
	forall  {SZ1:size M1 N1} 
		{EM:eq M1 M2}
        	{EN:nat`eq N1 N2}
	exists	{SZ2:size M2 N2} 
	true.

- : size-respects-eq S eq/ nat`eq/ S.

%worlds () (size-respects-eq _ _ _ _).
%total { } (size-respects-eq _ _ _ _).


%theorem size-deterministic :
	forall* {M1} {M2} {N1} {N2}
	forall {SZ1:size M1 N1} {SZ2:size M2 N2} {EM:eq M1 M2}
        exists {EN:nat`eq N1 N2}
	true.

%abbrev size-unique = size-deterministic.

- : size-deterministic size/0 size/0 eq/ nat`eq/.

- : size-deterministic (size/+ N1=|M1|) (size/+ N2=|M2|) eq/ N1+1=N2+1
    <- size-deterministic N1=|M1| N2=|M2| eq/ N1=N2
    <- succ-deterministic N1=N2 N1+1=N2+1.

%worlds () (size-deterministic _ _ _ _).
%total (S) (size-deterministic S _ _ _).


%theorem shift-preserves-size :
	forall* {M1} {N1} {M2} {N}
	forall	{SZ1: size M1 N1}
		{SH: shift N M1 M2}
	exists	{SZ2: size M2 N1}
	true.

- : shift-preserves-size (size/0) (shift/0) (size/0).

- : shift-preserves-size (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size _ _ _).
%total { } (shift-preserves-size _ _ _).


%theorem shift-preserves-size-converse:
	forall* {M1} {N1} {M2} {N}
	forall	{SZ2: size M2 N1}
		{SH: shift N M1 M2}
	exists	{SZ1: size M1 N1}
	true.

- : shift-preserves-size-converse (size/0) (shift/0) (size/0).

- : shift-preserves-size-converse (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size-converse _ _ _).
%total { } (shift-preserves-size-converse _ _ _).



%%% Theorems about bound

%theorem false-implies-bound :
	forall* {M} {N}
	forall {F:void}
	exists {MX:bound M N}
	true.

%worlds () (false-implies-bound _ _).
%total { } (false-implies-bound _ _).


%theorem bound-respects-eq :
	forall*	{M1} {N1} {M2} {N2}
	forall	{B1: bound M1 N1}
		{EM: eq M1 M2}
		{EN: nat`eq N1 N2}
	exists	{B2: bound M2 N2}
	true.

- : bound-respects-eq B _ _ B.

%worlds () (bound-respects-eq _ _ _ _).
%total { } (bound-respects-eq _ _ _ _).


%theorem bound-unique :
	forall*	{M1} {N1} {M2} {N2}
	forall	{B1: bound M1 N1}
		{B2: bound M2 N2}
		{EM: eq M1 M2}
	exists	{EN: nat`eq N1 N2}
	true.

%abbrev bound-deterministic = bound-unique.

- : bound-unique bound/0 bound/0 _ nat`eq/.

- : bound-unique (bound/+ P1 B1) (bound/+ P2 B2) eq/ EQ2
    <- bound-unique B1 B2 eq/ EQ1
    <- plus-unique P1 P2 nat`eq/ EQ1 EQ2.

%worlds () (bound-unique _ _ _ _).
%total (B) (bound-unique B _ _ _).


%theorem bound-total* :
	forall {M} 
	exists {N} {MX:bound M N}
	true.

- : bound-total* map/0 _ bound/0.

- : bound-total* _ _ (bound/+ P MX)
    <- bound-total* _ _ MX
    <- plus-total P.

%worlds () (bound-total* _ _ _).
%total (M) (bound-total* M _ _).


%abbrev bound-total = bound-total* _ _.


%theorem bound-lookup-implies-gt :
        forall* {M} {N} {D} {X}
        forall  {B: bound M X}
                {L: lookup M N D}
        exists  {G: gt X N}
        true.

- : bound-lookup-implies-gt (bound/+ P _) (lookup/= nat`eq/) G
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- plus-implies-gt Psc (nat`eq/) G.

- : bound-lookup-implies-gt (bound/+ P1 B) (lookup/> L P2) G
    <- bound-lookup-implies-gt B L G1
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- plus-left-preserves-gt* G1 P1 P2sc G.

%worlds () (bound-lookup-implies-gt _ _ _).
%total (B) (bound-lookup-implies-gt B _ _).


%theorem ge-bound-implies-fresh :
	forall* {M} {X} {N}
	forall {B:bound M X} {G:nat`ge N X}
	exists {F:fresh M N}
	true.

- : ge-bound-implies-fresh bound/0 _ fresh/0.

- : ge-bound-implies-fresh (bound/+ M1+1+X1=X B) N>=X (fresh/> F1 N1+1+M1=N)
    <- nat`ge-implies-plus N>=X Y1 Y1+X=N
    <- nat`plus-commutative M1+1+X1=X X1+M1+1=X
    <- nat`plus-associative-converse X1+M1+1=X Y1+X=N N1 Y1+X1=N1 N1+M1+1=N
    <- plus-swap-succ-converse N1+M1+1=N N1+1+M1=N
    <- plus-implies-ge Y1+X1=N1 N1>=X1
    <- ge-bound-implies-fresh B N1>=X1 F1.

%worlds () (ge-bound-implies-fresh _ _ _).
%total (B) (ge-bound-implies-fresh B _ _).



%%% Theorems about shift

%theorem false-implies-shift :
	forall* {M} {N} {MP}
	forall {F:void}
	exists {S:shift N M MP}
	true.
%worlds () (false-implies-shift _ _).
%total { } (false-implies-shift _ _).


%theorem shift-respects-eq :
	forall* {N} {M1} {M2} {NP} {M1P} {M2P}
	forall {S:shift N M1 M2} 
               {EN:nat`eq N NP} {E1:eq M1 M1P} {E2:eq M2 M2P}
        exists {SP:shift NP M1P M2P}
	true.

- : shift-respects-eq S nat`eq/ eq/ eq/ S.

%worlds () (shift-respects-eq _ _ _ _ _).
%total { } (shift-respects-eq _ _ _ _ _).


%theorem shift-total* :
	forall {N} {M1}
	exists {M2} {S:shift N M1 M2}
	true.

- : shift-total* N map/0 map/0 shift/0.

- : shift-total* N1 (map/+ N2 D M) (map/+ N3 D M) (shift/+ N1+1+N2=N3)
    <- plus-total N1+1+N2=N3.

%worlds () (shift-total* _ _ _ _).
%total { } (shift-total* _ _ _ _).

%abbrev shift-total = shift-total* _ _ _.


%theorem shift-deterministic :
	forall* {N} {M1} {M2} {NP} {M1P} {M2P}
	forall {S:shift N M1 M2} {SP:shift NP M1P M2P}
	       {EN:nat`eq N NP} {EM1:eq M1 M1P}
	exists {EM2:eq M2 M2P}
	true.

%abbrev shift-unique = shift-deterministic.

- : shift-deterministic shift/0 shift/0 nat`eq/ eq/ eq/.

- : shift-deterministic (shift/+ N1+1+N2=N3) (shift/+ N1+1+N2=N3P) nat`eq/ eq/ E
    <- plus-deterministic N1+1+N2=N3 N1+1+N2=N3P nat`eq/ nat`eq/ N3=N3P
    <- map/+-preserves-eq N3=N3P fldmap`eq/ eq/ E.

%worlds () (shift-deterministic _ _ _ _ _).
%total { } (shift-deterministic _ _ _ _ _).


%theorem shift-cancels :
	forall* {N} {M1} {M2} {NP} {M1P} {M2P}
	forall {S:shift N M1 M2} {SP:shift NP M1P M2P}
	       {EN:nat`eq N NP} {EM1:eq M2 M2P}
	exists {EM2:eq M1 M1P}
	true.

- : shift-cancels shift/0 shift/0 nat`eq/ eq/ eq/.

- : shift-cancels (shift/+ N1+1+N2=N3) (shift/+ N1+1+N2P=N3) nat`eq/ eq/ E
    <- plus-left-cancels N1+1+N2=N3 N1+1+N2P=N3 nat`eq/ nat`eq/ N2=N2P
    <- map/+-preserves-eq N2=N2P fldmap`eq/ eq/ E.

%worlds () (shift-cancels _ _ _ _ _).
%total { } (shift-cancels _ _ _ _ _).


%theorem shifts-add :
	forall* {N1} {N2} {N3} {M0} {M1} {M3}
	forall {S1:shift N1 M0 M1} {S2:shift N2 M1 M3} {P:plus (s N1) N2 N3}
        exists {S3:shift N3 M0 M3}
	true.

- : shifts-add shift/0 shift/0 _ shift/0.

- : shifts-add (shift/+ N1+1+N4=N5) (shift/+ N2+1+N5=N7) N1+1+N2=N3
               (shift/+ N3+1+N4=N7)          
    <- plus-total N3+1+N4=N7P
    <- plus-swap-succ N3+1+N4=N7P N3+N4+1=N7P
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-swap-succ N1+1+N4=N5 N1+N4+1=N5
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- plus-associative* N2+1+N1=N3 N3+N4+1=N7P N1+N4+1=N5 N2+1+N5=N7P
    <- plus-deterministic N2+1+N5=N7P N2+1+N5=N7 nat`eq/ nat`eq/ N7P=N7
    <- plus-respects-eq N3+1+N4=N7P nat`eq/ nat`eq/ N7P=N7 N3+1+N4=N7.

%worlds () (shifts-add _ _ _ _).
%total { } (shifts-add _ _ _ _).


%theorem shifts-add-converse :
	forall* {N1} {N2} {N3} {M0} {M3}
	forall {S3:shift N3 M0 M3} {P:plus (s N1) N2 N3}
	exists {M1} {S1:shift N1 M0 M1} {S2:shift N2 M1 M3}
        true.

- : shifts-add-converse S3 P M1 S1 S2
    <- shift-total S1
    <- shift-total S2P
    <- shifts-add S1 S2P P S3P
    <- shift-deterministic S3P S3 nat`eq/ eq/ M3P=M3
    <- shift-respects-eq S2P nat`eq/ eq/ M3P=M3 S2.

%worlds () (shifts-add-converse _ _ _ _ _).
%total { } (shifts-add-converse _ _ _ _ _).


%theorem shift-preserves-fresh :
        forall* {M1} {N1} {N2} {N0}
        forall	{L1:fresh M1 N1}
        	{P:plus (s N0) N1 N2} 
	exists	{M2} {S:shift N0 M1 M2}
		{L2:fresh M2 N2} 
	true.
	
- : shift-preserves-fresh fresh/0 P _ shift/0 fresh/0.

- : shift-preserves-fresh 
	(fresh/< G) P _ (shift/+ PP)
	(fresh/< GP)
    <- plus-total PP
    <- plus-left-preserves-gt* G PP P GP.

- : shift-preserves-fresh
	(fresh/> F D+1+N3=N1) N0+1+N1=N2 _ (shift/+ N0+1+N3=N4)
	(fresh/> F D+1+N4=N2)
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative D+1+N3=N1 N1+N0+1=N2 N4 N3+N0+1=N4 D+1+N4=N2
    <- plus-commutative N3+N0+1=N4 N0+1+N3=N4.

%worlds () (shift-preserves-fresh _ _ _ _ _).
%total (F) (shift-preserves-fresh F _ _ _ _).


%theorem shift-preserves-fresh* :
        forall* {M1} {N1} {N2} {N0} {M2}
        forall	{L1:fresh M1 N1}
        	{P:plus (s N0) N1 N2} 
		{S:shift N0 M1 M2}
	exists	{L2:fresh M2 N2} 
	true.
	
- : shift-preserves-fresh* F P S1 FP1
    <- shift-preserves-fresh F P _ S2 FP2
    <- shift-deterministic S2 S1 nat`eq/ eq/ EQ
    <- fresh-respects-eq FP2 EQ nat`eq/ FP1.

%worlds () (shift-preserves-fresh* _ _ _ _).
%total { } (shift-preserves-fresh* _ _ _ _).


%theorem shift-preserves-fresh-converse* :
        forall* {M1} {N1} {N2} {M2} {N0}
	forall {L2:fresh M2 N2} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2} 
        exists {L1:fresh M1 N1}
	true.

- : shift-preserves-fresh-converse* fresh/0 shift/0 _ fresh/0.

- : shift-preserves-fresh-converse* 
	(fresh/< N1>N) (shift/+ S+1+N2=N1) S+1+NP=N
	(fresh/< N2>NP)
    <- plus-left-cancels-gt S+1+N2=N1 S+1+NP=N nat`eq/ N1>N N2>NP.

- : shift-preserves-fresh-converse* 
	(fresh/> F NX+1+N2=N) (shift/+ S+1+N1=N2) S+1+NP=N
        (fresh/> F NX+1+N1=NP)
    <- plus-commutative S+1+N1=N2 N1+S+1=N2
    <- plus-associative-converse N1+S+1=N2 NX+1+N2=N NPP NX+1+N1=NPP NPP+S+1=N
    <- plus-commutative NPP+S+1=N S+1+NPP=N
    <- plus-left-cancels S+1+NPP=N S+1+NP=N nat`eq/ nat`eq/ NPP=NP
    <- plus-respects-eq NX+1+N1=NPP nat`eq/ nat`eq/ NPP=NP NX+1+N1=NP.

%worlds () (shift-preserves-fresh-converse* _ _ _ _).
%total { } (shift-preserves-fresh-converse* _ _ _ _).


%theorem shift-preserves-lookup :
        forall* {M1} {N1} {D} {N0} {M2}
	forall {L1:lookup M1 N1 D} {S:shift N0 M1 M2}
        exists {N2} {P:plus (s N0) N1 N2} {L2:lookup M2 N2 D}
	true.

- : shift-preserves-lookup (lookup/= nat`eq/) (shift/+ N0+1+N1=N2) _
                           N0+1+N1=N2 (lookup/= nat`eq/).

- : shift-preserves-lookup (lookup/> L N3+1+N1=N4) (shift/+ N0+1+N1=N2) _
                           N0+1+N4=N5 (lookup/> L N3+1+N2=N5)
    <- plus-total N0+1+N4=N5
    <- plus-commutative N3+1+N1=N4 N1+N3+1=N4
    <- plus-associative-converse* N1+N3+1=N4 N0+1+N4=N5 N0+1+N1=N2 N2+N3+1=N5
    <- plus-commutative N2+N3+1=N5 N3+1+N2=N5.

%worlds () (shift-preserves-lookup _ _ _ _ _).
%total { } (shift-preserves-lookup _ _ _ _ _).


%theorem shift-preserves-lookup* :
        forall* {M1} {N1} {D} {N0} {M2} {N2}
	forall {L1:lookup M1 N1 D} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2} 
        exists {L2:lookup M2 N2 D}
	true.

- : shift-preserves-lookup* L1 S P L2
    <- shift-preserves-lookup L1 S _ PP L2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- lookup-respects-eq L2P eq/ N2P=N2 fldmap`eq/ L2.

%worlds () (shift-preserves-lookup* _ _ _ _).
%total { } (shift-preserves-lookup* _ _ _ _).


%theorem shift-preserves-lookup-converse :
        forall* {M1} {N0} {D} {N2} {M2}
	forall {L2:lookup M2 N2 D} {S:shift N0 M1 M2}
        exists {N1} {P:plus (s N0) N1 N2} {L1:lookup M1 N1 D}
	true.

- : shift-preserves-lookup-converse (lookup/= nat`eq/) (shift/+ N0+1+N1=N2) _
                                    N0+1+N1=N2 (lookup/= nat`eq/).

- : shift-preserves-lookup-converse (lookup/> L N3+1+N2=N5) (shift/+ N0+1+N1=N2)
                                    _ N0+1+N4=N5 (lookup/> L N3+1+N1=N4)
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse N1+N0+1=N2 N3+1+N2=N5 N4 N3+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.

%worlds () (shift-preserves-lookup-converse _ _ _ _ _).
%total { } (shift-preserves-lookup-converse _ _ _ _ _).


%theorem shift-preserves-lookup-converse* :
        forall* {M1} {N1} {D} {N2} {M2} {N0}
	forall {L2:lookup M2 N2 D} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2} 
        exists {L1:lookup M1 N1 D}
	true.

- : shift-preserves-lookup-converse* L2 S P L1
    <- shift-preserves-lookup-converse L2 S _ PP L1P
    <- plus-left-cancels PP P nat`eq/ nat`eq/ N1P=N1
    <- lookup-respects-eq L1P eq/ N1P=N1 fldmap`eq/ L1.

%worlds () (shift-preserves-lookup-converse* _ _ _ _).
%total { } (shift-preserves-lookup-converse* _ _ _ _).


%theorem shift-implies-fresh* :
	forall* {M} {N1} {N} {NM}
	forall	{SH:shift N M NM}
		{GE:nat`ge N N1}
	exists	{F:fresh NM N1}
	true.

- : shift-implies-fresh* shift/0 _ fresh/0.

- : shift-implies-fresh* 
     (shift/+ SN+N1=N1P) N>=NP
     (fresh/< N1P>NP)
    <- plus-commutative SN+N1=N1P N1+SN=N1P
    <- plus-implies-ge N1+SN=N1P N1P>=SN
    <- ge-succ-implies-gt N1P>=SN N1P>N
    <- gt-transitive-ge N1P>N N>=NP N1P>NP.

%worlds () (shift-implies-fresh* _ _ _).
%total { } (shift-implies-fresh* _ _ _).


%theorem shift-implies-fresh :
	forall* {M} {N} {NM}
	forall	{SH:shift N M NM}
	exists	{F:fresh NM N}
	true.

- : shift-implies-fresh SH F
    <- shift-implies-fresh* SH (nat`ge/= nat`eq/) F.

%worlds () (shift-implies-fresh _ _).
%total { } (shift-implies-fresh _ _).


%theorem removal-preserves-fresh :
	forall*	{N1} {D} {M1} {N2} {M2}
	forall	{F1: fresh (map/+ N1 D M1) N2}
		{S: shift N1 M1 M2}
	exists	{F2: fresh M2 N2}
	true.

- : removal-preserves-fresh _ _ fresh/0.

- : removal-preserves-fresh (fresh/< GT1) (shift/+ P) (fresh/< GT2)
    <- plus-swap-succ P PS
    <- plus-commutative PS PSC
    <- plus-implies-gt PSC nat`eq/ GT3
    <- gt-transitive GT3 GT1 GT2.

- : removal-preserves-fresh (fresh/> F1 P1) (shift/+ P2) F2
    <- plus-swap-succ P1 PS1
    <- plus-commutative PS1 PSC1
    <- shift-preserves-fresh* F1 PSC1 
	(shift/+ P2) F2.

%worlds () (removal-preserves-fresh _ _ _).
%total { } (removal-preserves-fresh _ _ _).


%theorem shift-preserves-size :
	forall* {M} {N1} {N2} {S2M}
	forall {SZ:size M N1} {SH:shift N2 M S2M}
	exists {SHSZ:size S2M N1}
	true.

- : shift-preserves-size size/0 shift/0 size/0.

- : shift-preserves-size (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size _ _ _).
%total { } (shift-preserves-size _ _ _).



%%% Theorems about disjoint?


%theorem disjoint?-total* :
	forall {M1} {M2}
	exists {B} {D:disjoint? M1 M2 B}
	true.

- : disjoint?-total* _ _ _ (disjoint?/yes disjoint/L).

- : disjoint?-total* _ _ _ (disjoint?/yes disjoint/R).

%theorem disjoint?-total*/+ :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {C}
	forall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2} {CMP:nat`compare N1 N2 C}
	exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

%theorem disjoint?-total*/< :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0} {B1}
	forall {P:plus (s N0) N1 N2}
               {D?1:disjoint? M1 (map/+ N0 D2 M2) B1}
	exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

%theorem disjoint?-total*/> :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {B1}
	forall {P:plus (s N3) N2 N1}
               {D?1:disjoint? (map/+ N3 D1 M1) M2 B1}
	exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

- : disjoint?-total* _ _ _ D?
    <- size-total SZ1
    <- size-total SZ2
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?.

- : disjoint?-total*/+ _ _ _ _ (nat`compare/=) _ 
                       (disjoint?/no (lookup/= nat`eq/) (lookup/= nat`eq/)).

- : disjoint?-total*/+ _ _ _ _ (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- disjoint?-total*/< N0+1+N1=N2 (disjoint?/yes disjoint/L) _ D?.

- : disjoint?-total*/+ _ _ (size/+ SZ1) SZ2 (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- disjoint?-total*/< N0+1+N1=N2 D?1 _ D?.

- : disjoint?-total*/< N0+1+N1=N2 (disjoint?/yes M1*M022) _
                       (disjoint?/yes (disjoint/< M1*M022 N0+1+N1=N2)).

- : disjoint?-total*/< N0+1+N1=N2 (disjoint?/no M1^N3=D1 M022^N3=D2) _
                       (disjoint?/no (lookup/> M1^N3=D1 N3+1+N1=N4) M222^N4=D2)
    <- plus-total N3+1+N1=N4
    <- plus-swap-succ N3+1+N1=N4 N3+N1+1=N4
    <- plus-commutative N3+N1+1=N4 N1+1+N3=N4
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-preserves-lookup* M022^N3=D2 (shift/+ N1+1+N0=N2) N1+1+N3=N4
                               M222^N4=D2.

%worlds () (disjoint?-total*/< _ _ _ _).
%total { } (disjoint?-total*/< _ _ _ _).

- : disjoint?-total*/+ _ _ _ _ (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- disjoint?-total*/> N3+1+N2=N1 (disjoint?/yes disjoint/R) _ D?.

- : disjoint?-total*/+ _ _ SZ1 (size/+ SZ2) (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- disjoint?-total*/> N3+1+N2=N1 D?1 _ D?.

- : disjoint?-total*/> P (disjoint?/yes D) _ (disjoint?/yes (disjoint/> D P)).

- : disjoint?-total*/> N3+1+N2=N1 (disjoint?/no M311^N4=D1 M2^N4=D2) _
                       (disjoint?/no M111^N5=D1 (lookup/> M2^N4=D2 N4+1+N2=N5))
    <- plus-total N4+1+N2=N5
    <- plus-swap-succ N4+1+N2=N5 N4+N2+1=N5
    <- plus-commutative N4+N2+1=N5 N2+1+N4=N5
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- shift-preserves-lookup* M311^N4=D1 (shift/+ N2+1+N3=N1) N2+1+N4=N5
                               M111^N5=D1.

%worlds () (disjoint?-total*/> _ _ _ _).
%total { } (disjoint?-total*/> _ _ _ _).

%worlds () (disjoint?-total*/+ _ _ _ _ _ _ _).
%total [S1 S2] (disjoint?-total*/+ S1 S2 _ _ _ _ _).

%worlds () (disjoint?-total* _ _ _ _).
%total { } (disjoint?-total* _ _ _ _).

%abbrev disjoint?-total = disjoint?-total* _ _ _.



%%% Theorems about update


%theorem false-implies-update :
	forall* {M} {N} {D} {MP} 
	forall {F:void} 
	exists {U:update M N D MP} 
	true.
%worlds () (false-implies-update _ %{=>}% M^N=D->MP).
%total {} (false-implies-update _ _).


%theorem update-respects-eq :
	forall* {M1} {N} {D} {M2} {M1P} {NP} {DP} {M2P}
	forall {U:update M1 N D M2} {EM1:eq M1 M1P} 
               {EN:nat`eq N NP} {ED:fldmap`eq D DP} {EM2:eq M2 M2P}
	exists {UP:update M1P NP DP M2P} 
	true.
- : update-respects-eq U eq/ nat`eq/ fldmap`eq/ eq/ U.
%worlds () (update-respects-eq M1^N=D->M2 M1=M1P N=NP D=DP M2=M2P 
                        %{=>}% M1P^NP=DP->M2P).
%total {} (update-respects-eq _ _ _ _ _ _).
%reduces U = UP (update-respects-eq U _ _ _ _ UP).


%% a technical lemma to help prove reduction arguments

%theorem meta-reduces-update :
	forall*	{M1} {M2} {N1} {N2} {D1} {D2} {M1P} {M2P}
	forall	{F: void}
		{L1: update M1 N1 D1 M1P}
		{L2: update M2 N2 D2 M2P}
	true.

%worlds () (meta-reduces-update _ _ _).
%total { } (meta-reduces-update _ _ _).
%reduces X < Y (meta-reduces-update _ X Y).


%theorem update/=-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2}
	forall {U:update (map/+ N1 D1 M1) N2 D2 M2} {E:nat`eq N1 N2}
        exists {EM:eq (map/+ N2 D2 M1) M2}
	true.

- : update/=-inversion (update/= nat`eq/) nat`eq/ eq/.

- : update/=-inversion (update/< N3+1+N=N) nat`eq/ E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update/=-inversion (update/> U1022 N3+1+N=N) nat`eq/ E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

%worlds () (update/=-inversion _ _ _).
%total { } (update/=-inversion _ _ _).


%theorem update/<-inversion:
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
	forall {U:update (map/+ N1 D1 M1) N2 D2 M2} {P:plus (s N3) N2 N1}
	exists {E:eq (map/+ N2 D2 (map/+ N3 D1 M1)) M2}
	true.

- : update/<-inversion (update/= nat`eq/) N3+1+N=N E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update/<-inversion (update/< N3+1+N2=N1) N3P+1+N2=N1 E
    <- nat`plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- nat`succ-cancels N3P+1=N3+1 N3P=N3
    <- map/+-preserves-eq N3P=N3 fldmap`eq/ eq/ M311P=M311
    <- map/+-preserves-eq nat`eq/ fldmap`eq/ M311P=M311 E.

- : update/<-inversion (update/> _ N0+1+N1=N2) N3+1+N2=N1 E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (update/<-inversion _ _ _).
%total { } (update/<-inversion _ _ _).


%theorem update/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M} {N0}
	forall {U:update (map/+ N1 D1 M1) N2 D2 M} {P:plus (s N0) N1 N2}
	exists {M2} {UP:update M1 N0 D2 M2} {E:eq (map/+ N1 D1 M2) M}
	true.

% a little more complex than might be expected
% because we want to prove reduction
- : update/>-inversion (U: update (map/+ N D1 M1) N D2 (map/+ N D2 M1))
                       N0+1+N=N M1 UP E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E
    <- false-implies-update F UP
    <- meta-reduces-update F UP U.

- : update/>-inversion 
	(update/< N3+1+N2=N1: update (map/+ N1 D1 M1) N2 D2 _) 
        N0+1+N1=N2 M1 UP E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-update F UP
    <- false-implies-eq F E
    <- meta-reduces-update 
	F UP (update/< N3+1+N2=N1: update (map/+ N1 D1 M1) N2 D2 _).

- : update/>-inversion (update/> U N0+1+N1=N2) N0P+1+N1=N2 _ UP eq/ 
    <- nat`plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- nat`succ-cancels N0+1=N0P+1 N0=N0P
    <- update-respects-eq U eq/ N0=N0P fldmap`eq/ eq/ UP.

%worlds () (update/>-inversion _ _ _ _ _).
%total { } (update/>-inversion _ _ _ _ _).
%reduces UP < U (update/>-inversion U _ _ UP _).


%theorem update-contradiction :
	forall* {M} {N} {D}
	forall	{U: update M N D map/0}
	exists	{F: void}
	true.

%worlds () (update-contradiction _ _).
%total { } (update-contradiction _ _).


%theorem update-deterministic :
	forall* {M1} {N1} {D1} {M1P} {M2} {N2} {D2} {M2P}
	forall {U1:update M1 N1 D1 M1P} {U2:update M2 N2 D2 M2P}
	       {EM:eq M1 M2} {EN:nat`eq N1 N2} {ED:fldmap`eq D1 D2}
	exists {EMP:eq M1P M2P}
	true.

%abbrev update-unique = update-deterministic.

- : update-deterministic update/0 update/0 eq/ nat`eq/ fldmap`eq/ eq/.

- : update-deterministic (update/= nat`eq/) (update/= nat`eq/) eq/ nat`eq/ fldmap`eq/ eq/.

- : update-deterministic (update/< N3+1+N2=N1) (update/< N3P+1+N2=N1)
                         eq/ nat`eq/ fldmap`eq/ M1P=M2P
    <- plus-right-cancels N3+1+N2=N1 N3P+1+N2=N1 nat`eq/ nat`eq/ SN3=SN3P
    <- succ-cancels SN3=SN3P N3E
    <- map/+-preserves-eq N3E fldmap`eq/ eq/ MM1=MM2
    <- map/+-preserves-eq nat`eq/ fldmap`eq/ MM1=MM2 M1P=M2P.

- : update-deterministic (update/> F1^N0=D2->F2 N0+1+N1=N2)
                         (update/> F1^N0P=D2->F2P N0P+1+N1=N2)
                         eq/ nat`eq/ fldmap`eq/ M1P=M2P
    <- plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- update-deterministic F1^N0=D2->F2 F1^N0P=D2->F2P eq/ N0=N0P 
                            fldmap`eq/ F2=F2P
    <- map/+-preserves-eq nat`eq/ fldmap`eq/ F2=F2P M1P=M2P.

%% contradiction cases:
- : update-deterministic (update/= nat`eq/) (update/< N3+1+N=N) eq/ nat`eq/ fldmap`eq/ E
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/= nat`eq/) (update/> _ N0+1+N=N) eq/ nat`eq/ fldmap`eq/ E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/< N3+1+N=N) (update/= nat`eq/) eq/ nat`eq/ fldmap`eq/ E
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/< N3+1+N2=N1) (update/> _ N0+1+N1=N2)
                         eq/ nat`eq/ fldmap`eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

- : update-deterministic (update/> _ N0+1+N=N) (update/= nat`eq/) eq/ nat`eq/ fldmap`eq/ E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/> _ N0+1+N1=N2) (update/< N3+1+N2=N1)
                         eq/ nat`eq/ fldmap`eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (update-deterministic M1^N1=D1->M1P M2^N2=D2->M2P M1=M2 N1=N2 D1=D2
                          %{=>}% M1P=M2P).
%total (U) (update-deterministic U _ _ _ _ _).


%theorem update-total* :
	forall {M} {N} {D}
	exists {MP} {U:update M N D MP}
	true.

%% we need a mutually recursive lemma
%theorem update-map/+-total :
	forall {N1} {D1} {M1} {N2} {D2} {C} {CMP:nat`compare N1 N2 C}
	exists {M2} {U:update (map/+ N1 D1 M1) N2 D2 M2}
	true.

- : update-total* map/0 N D (map/+ N D map/0) update/0.

- : update-total* (map/+ N1 D1 M1) N2 D2 M2 U
    <- nat`compare-total* N1 N2 C CMP
    <- update-map/+-total N1 D1 M1 N2 D2 C CMP M2 U.

- : update-map/+-total N1 D1 M1 N2 D2 equal CMP (map/+ N2 D2 M1) (update/= N1=N2)
    <- equal-implies-eq CMP N1=N2.

- : update-map/+-total N1 D1 M1 N2 D2 less CMP (map/+ N1 D1 M1P)
                       (update/> U1 N0+1+N1=N2)
    <- less-implies-lt CMP N2>N1
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- update-total* M1 N0 D2 M1P U1.

- : update-map/+-total N1 D1 M1 N2 D2 greater CMP (map/+ N2 D2 (map/+ N3 D1 M1))
                       (update/< N3+1+N2=N1)
    <- greater-implies-gt CMP N1>N2
    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1.

%worlds () (update-total* M N D %{=>}% MP M^N=D->MP)
           (update-map/+-total _ _ _ _ _ _ _ _ _).
%total (M1 M2) (update-total* M1 _ _ _ _) (update-map/+-total _ _ M2 _ _ _ _ _ _).

%abbrev update-total = update-total* _ _ _ _.


%theorem lookup-implies-update :
        forall* {F} {N} {D}
        forall {L:lookup F N D}
        exists {U:update F N D F} 
        true.
        
- : lookup-implies-update (lookup/= nat`eq/) (update/= nat`eq/).

- : lookup-implies-update (lookup/> L P) (update/> U P)
    <- lookup-implies-update L U.

%worlds () (lookup-implies-update _ _).
%total (L) (lookup-implies-update L _).


%theorem lookup-implies-fresh-update :
        forall* {M2} {N} {D}
        forall	{L:lookup M2 N D}
	exists	{M1}
		{F: fresh M1 N} 
        	{U:update M1 N D M2} 
        true.

- : lookup-implies-fresh-update (lookup/= nat`eq/) _ fresh/0 update/0.

- : lookup-implies-fresh-update (lookup/= nat`eq/) _ (fresh/< GT) (update/< P)
    <- plus-total P
    <- plus-implies-gt P nat`eq/ GT.

- : lookup-implies-fresh-update (lookup/> L P) _ (fresh/> F P) (update/> U P)
    <- lookup-implies-fresh-update L _ F U.

%worlds () (lookup-implies-fresh-update _ _ _ _).
%total (L) (lookup-implies-fresh-update L _ _ _).


%theorem update-implies-lookup :
	forall* {F} {N} {D} {FP}
	forall {U:update F N D FP} 
	exists {L:lookup FP N D}
	true.

- : update-implies-lookup update/0 (lookup/= nat`eq/).

- : update-implies-lookup (update/= nat`eq/) (lookup/= nat`eq/).

- : update-implies-lookup (update/< _) (lookup/= nat`eq/).

- : update-implies-lookup (update/> F^N0=D2->FP N0+1+N1=N2)
                          (lookup/> FP^N0=D2    N0+1+N1=N2)
    <- update-implies-lookup F^N0=D2->FP FP^N0=D2.

%worlds () (update-implies-lookup F^N=D->FP %{=>}% FP^N=D).
%total (U) (update-implies-lookup U _).


%theorem update-preserves-lookup :
	forall* {F} {N1} {D1} {FP} {N2} {D2}
	forall {L:lookup F N2 D2} {U:update F N1 D1 FP} {X:nat`ne N2 N1}
        exists {LP:lookup FP N2 D2}
	true.

%% update/0 is impossible

- : update-preserves-lookup (lookup/= nat`eq/) (update/= nat`eq/) N<>N LP
    <- nat`ne-anti-reflexive N<>N FALSE
    <- false-implies-lookup FALSE LP.

- : update-preserves-lookup (lookup/> L1 P1) (update/= nat`eq/) _ (lookup/> L1 P1).

- : update-preserves-lookup (lookup/= nat`eq/) (update/< N3+1+N2=N1) _ 
                            (lookup/> (lookup/= nat`eq/) N3+1+N2=N1).

- : update-preserves-lookup (lookup/> L N0+1+N1=N2P) (update/< N3+1+N2=N1) _
			    (lookup/> (lookup/> L N0+1+N3=N4)
			              N4+1+N2=N2P)
    <- plus-left-decrease N3+1+N2=N1 N1-1 N1=N1-1+1 N3+N2=N1-1
    <- plus-right-increase N3+N2=N1-1 N3+N2+1=N1-1+1
    <- nat`eq-symmetric N1=N1-1+1 N1-1+1=N1
    <- plus-respects-eq N3+N2+1=N1-1+1 nat`eq/ nat`eq/ N1-1+1=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N0+1+N1=N2P N4 N0+1+N3=N4
                                N4+N2+1=N2P
    <- plus-swap-succ-converse N4+N2+1=N2P N4+1+N2=N2P.

- : update-preserves-lookup (lookup/= nat`eq/) (update/> _ _) _ (lookup/= nat`eq/).

- : update-preserves-lookup (lookup/> L N0+1+N1=N2) 
                            ((update/> U N0P+1+N1=N2P) 
                             : update (map/+ N1 D1 M1) N2P DP 
                                      (map/+ N1 D1 M1P))
                            N2<>N2P 
                            ((lookup/> LP N0+1+N1=N2) 
                             : lookup (map/+ N1 D1 M1P) N2 D)
    <- plus-right-cancels-ne N0+1+N1=N2 N0P+1+N1=N2P nat`eq/ N2<>N2P N0+1<>N0P+1
    <- succ-preserves-ne-converse N0+1<>N0P+1 N0<>N0P
    <- update-preserves-lookup L U N0<>N0P LP.

%worlds () (update-preserves-lookup F^N2=D2 F^N1=D1->FP N1<>N2 FP^N2=D2).
%total (L) (update-preserves-lookup L _ _ _).


%theorem update-preserves-lookup-converse :
	forall* {F1} {N1} {D1} {F2} {N2} {D2}
	forall {L2:lookup F2 N2 D2} {U:update F1 N1 D1 F2} {X:nat`ne N2 N1}
        exists {L1:lookup F1 N2 D2}
	true.

- : update-preserves-lookup-converse (lookup/= nat`eq/) update/0 N<>N L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/= nat`eq/) N<>N
                                     L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/< N3+1+N2=N1)
                                     N<>N L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/> _ _) _
                                     (lookup/= nat`eq/).

- : update-preserves-lookup-converse (lookup/> L1 P) (update/= nat`eq/) _
                                     (lookup/> L1 P).

- : update-preserves-lookup-converse (lookup/> (lookup/= nat`eq/) N3+1+N2=N4)
                                     (update/< N3+1+N2=N1) _
                                     (lookup/= N1=N4)
    <- plus-deterministic N3+1+N2=N1 N3+1+N2=N4 nat`eq/ nat`eq/ N1=N4.

- : update-preserves-lookup-converse (lookup/> (lookup/> L1 N6+1+N3=N5) 
                                               N5+1+N2=N4)
                                     (update/< N3+1+N2=N1) _
                                     (lookup/> L1 N6+1+N1=N4)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-swap-succ N5+1+N2=N4 N5+N2+1=N4
    <- plus-associative* N6+1+N3=N5 N5+N2+1=N4 N3+N2+1=N1 N6+1+N1=N4.

- : update-preserves-lookup-converse (lookup/> L2 N5+1+N1=N4)
                                     (update/> U1 N0+1+N1=N2) N4<>N2
                                     (lookup/> L1 N5+1+N1=N4)
    <- plus-right-cancels-ne N5+1+N1=N4 N0+1+N1=N2 nat`eq/ N4<>N2 N5+1<>N0+1
    <- succ-preserves-ne-converse N5+1<>N0+1 N5<>N0
    <- update-preserves-lookup-converse L2 U1 N5<>N0 L1.

%worlds () (update-preserves-lookup-converse _ _ _ _).
%total (L) (update-preserves-lookup-converse L _ _ _).


%theorem update-preserves-fresh :
	forall* {M1} {N1} {N2} {D} {M2}
	forall {F1:fresh M1 N1} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
	exists {F2:fresh M2 N1}
	true.

- : update-preserves-fresh fresh/0 update/0 (nat`ne/< N>M) (fresh/< N>M).

- : update-preserves-fresh fresh/0 update/0 (nat`ne/> M>N) 
                           (fresh/> fresh/0 M1+1+N=M)
    <- gt-implies-plus M>N M1 M1+1+N=M.

- : update-preserves-fresh (fresh/< N>M) (update/= nat`eq/) _ (fresh/< N>M).

- : update-preserves-fresh (fresh/< N1>M) (update/< N3+1+N2=N1) (nat`ne/< N2>M)
                           (fresh/< N2>M).

- : update-preserves-fresh (fresh/< N1>M) (update/< N3+1+N2=N1) (nat`ne/> M>N2)
                           (fresh/> (fresh/< N3>M1) M1+1+N2=M)
    <- gt-implies-plus M>N2 M1 M1+1+N2=M
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-swap-succ M1+1+N2=M  M1+N2+1=M
    <- plus-right-cancels-gt N3+N2+1=N1 M1+N2+1=M nat`eq/ N1>M N3>M1.

- : update-preserves-fresh (fresh/< N1>M) (update/> _ _) _ (fresh/< N1>M).

- : update-preserves-fresh (fresh/> F P) (update/= nat`eq/) _ (fresh/> F P).

- : update-preserves-fresh (fresh/> F M1+1+N1=M) (update/< N3+1+N2=N1) _
                           (fresh/> (fresh/> F M1+1+N3=MM) MM+1+N2=M)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 M1+1+N1=M MM M1+1+N3=MM
                                 MM+N2+1=M
    <- plus-swap-succ-converse MM+N2+1=M MM+1+N2=M.

- : update-preserves-fresh (fresh/> F M1+1+N1=M) (update/> U N0+1+N1=N2) M<>N2
                           (fresh/> FP M1+1+N1=M)
    <- plus-right-cancels-ne M1+1+N1=M N0+1+N1=N2 nat`eq/ M<>N2 M1+1<>N0+1
    <- succ-preserves-ne-converse M1+1<>N0+1 M1<>N0
    <- update-preserves-fresh F U M1<>N0 FP.

%worlds () (update-preserves-fresh N1-fresh-M1 M1^N2=D->M2 N1<>N2 N1-fresh-M2).
%total (F) (update-preserves-fresh F _ _ _).


%theorem update-preserves-fresh-converse :
	forall* {M1} {N1} {N2} {D} {M2}
	forall {F1:fresh M2 N1} {U:update M1 N2 D M2}
	exists {F2:fresh M1 N1}
	true.

%theorem update-preserves-fresh-converse-helper :
	forall* {M1} {N1} {N2} {D} {M2} {B} {B2}
	forall {F1:fresh M2 N1} {U:update M1 N2 D M2}
               {D:domain? M1 N1 B} {E:nat`eq? N1 N2 B2}
	exists {F2:fresh M1 N1}
	true.

- : update-preserves-fresh-converse-helper _ _ (domain?/out F) _ F.

- : update-preserves-fresh-converse-helper F2 U (domain?/in L1) (nat`eq?/no N) F1
    <- update-preserves-lookup L1 U N L2
    <- fresh-lookup-not-equal F2 L2 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-fresh F F1.

- : update-preserves-fresh-converse-helper F2 U _ nat`eq?/yes F1
    <- update-implies-lookup U L2
    <- fresh-lookup-not-equal F2 L2 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-fresh F F1.

%worlds () (update-preserves-fresh-converse-helper _ _ _ _ _).
%total { } (update-preserves-fresh-converse-helper _ _ _ _ _).

- : update-preserves-fresh-converse F2 U F1
    <- domain?-total D
    <- nat`eq?-total E
    <- update-preserves-fresh-converse-helper F2 U D E F1.

%worlds () (update-preserves-fresh-converse _ _ _).
%total { } (update-preserves-fresh-converse _ _ _).


%theorem update-is-cause-of-change :
	forall* {M1} {N1} {N2} {M2} {D1} {D2}
	forall {F:fresh M1 N1}
	       {U:update M1 N2 D2 M2}
	       {L:lookup M2 N1 D1}
	exists {EN:nat`eq N1 N2} {ED:fldmap`eq D1 D2}
	true.

%theorem update-is-cause-of-change/L :
	forall* {M1} {N1} {N2} {M2} {D1} {D2} {B}
	forall {F:fresh M1 N1}
	       {U:update M1 N2 D2 M2}
	       {L:lookup M2 N1 D1}
	       {E:nat`eq? N1 N2 B}
	exists {EN:nat`eq N1 N2} {ED:fldmap`eq D1 D2}
	true.

- : update-is-cause-of-change F U L EN ED
     <- nat`eq?-total E?
     <- update-is-cause-of-change/L F U L E? EN ED.

- : update-is-cause-of-change/L F U L (nat`eq?/yes) nat`eq/ ED
    <- update-implies-lookup U LP
    <- lookup-deterministic L LP eq/ nat`eq/ ED.

- : update-is-cause-of-change/L F U L (nat`eq?/no N1<>N2) EN ED
    <- update-preserves-fresh F U N1<>N2 FP
    <- fresh-lookup-not-equal FP L N1<>N1
    <- nat`ne-anti-reflexive N1<>N1 V
    <- nat`false-implies-eq V EN
    <- fldmap`false-implies-eq V ED.
    
%worlds () (update-is-cause-of-change/L _ _ _ _ _ _).
%total { } (update-is-cause-of-change/L _ _ _ _ _ _).

%worlds () (update-is-cause-of-change _ _ _ _ _).
%total { } (update-is-cause-of-change _ _ _ _ _).


%theorem update-preserves-membership :
	forall* {M1} {N1} {B} {N2} {D} {M2}
	forall {MD1:domain? M1 N1 B} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
	exists {MD2:domain? M2 N1 B}
	true.

- : update-preserves-membership (domain?/in L) U NE (domain?/in LP)
    <- update-preserves-lookup L U NE LP.

- : update-preserves-membership (domain?/out F) U NE (domain?/out FP)
    <- update-preserves-fresh F U NE FP.

%worlds () (update-preserves-membership _ _ _ _).
%total {} (update-preserves-membership _ _ _ _).


%theorem update-preserves-membership-converse :
	forall* {M1} {N1} {B} {N2} {D} {M2}
	forall {MD2:domain? M2 N1 B} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
	exists {MD1:domain? M1 N1 B}
	true.

- : update-preserves-membership-converse (domain?/in L2) U NE (domain?/in L1)
    <- update-preserves-lookup-converse L2 U NE L1.

- : update-preserves-membership-converse (domain?/out F2) U NE (domain?/out F1)
    <- update-preserves-fresh-converse F2 U F1.

%worlds () (update-preserves-membership-converse _ _ _ _).
%total { } (update-preserves-membership-converse _ _ _ _).


%theorem lookup-update-preserves-membership :
	forall* {M1} {N1} {B} {N2} {D1} {D2} {M2}
	forall {MD1:domain? M1 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
	exists {MD2:domain? M2 N1 B}
	true.

%theorem lookup-update-preserves-membership/L :
	forall* {M1} {N1} {B} {N2} {D1} {D2} {M2} {B2}
	forall {MD1:domain? M1 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
	       {EQ?:nat`eq? N1 N2 B2}
	exists {MD2:domain? M2 N1 B}
	true.

- : lookup-update-preserves-membership/L MD1 _ Ux1 (nat`eq?/no N1<>N2) MD2 
    <- update-preserves-membership MD1 Ux1 N1<>N2 MD2.

- : lookup-update-preserves-membership/L
	(domain?/in _) _ U (nat`eq?/yes) (domain?/in L2)
    <- update-implies-lookup U L2.

- : lookup-update-preserves-membership/L
	(domain?/out F1) L1 _ nat`eq?/yes (domain?/out F2)
    <- fresh-lookup-not-equal F1 L1 NE
    <- nat`ne-anti-reflexive NE F
    <- false-implies-fresh F F2.

%worlds () (lookup-update-preserves-membership/L _ _ _ _ _).
%total { } (lookup-update-preserves-membership/L _ _ _ _ _).

- : lookup-update-preserves-membership MD1 L1 U MD2
    <- nat`eq?-total EQUAL?
    <- lookup-update-preserves-membership/L MD1 L1 U EQUAL? MD2.

%worlds () (lookup-update-preserves-membership _ _ _ _).
%total { } (lookup-update-preserves-membership _ _ _ _).


%theorem lookup-update-preserves-membership-converse :
	forall* {M1} {N1} {B} {N2} {D1} {D2} {M2}
	forall {MD1:domain? M2 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
	exists {MD2:domain? M1 N1 B}
	true.

- : lookup-update-preserves-membership-converse MD2 ML MU MD1
    <- domain?-total MD1P
    <- lookup-update-preserves-membership MD1P ML MU MD2P
    <- domain?-deterministic MD2P MD2 eq/ nat`eq/ BP=B
    <- domain?-respects-eq MD1P eq/ nat`eq/ BP=B MD1.

%worlds () (lookup-update-preserves-membership-converse _ _ _ _).
%total { } (lookup-update-preserves-membership-converse _ _ _ _).


%theorem update-preserves-in-domain :
	forall* {M1} {N1} {N2} {D} {M2}
	forall {MD1:domain? M1 N1 true} {U:update M1 N2 D M2}
	exists {MD2:domain? M2 N1 true}
	true.

%theorem update-preserves-in-domain/L :
	forall* {M1} {N1} {N2} {D} {M2} {B}
	forall {MD1:domain? M1 N1 true} {U:update M1 N2 D M2}
	       {E: nat`eq? N1 N2 B}
	exists {MD2:domain? M2 N1 true}
	true.

- : update-preserves-in-domain/L
	(domain?/in ML1) U (nat`eq?/no N1<>N2) (domain?/in ML2)
    <- update-preserves-lookup ML1 U N1<>N2 ML2.

- : update-preserves-in-domain/L _ U (nat`eq?/yes) (domain?/in ML)
    <- update-implies-lookup U ML.

%worlds () (update-preserves-in-domain/L _ _ _ _).
%total { } (update-preserves-in-domain/L _ _ _ _).

- : update-preserves-in-domain MD1 U MD2
    <- nat`eq?-total E
    <- update-preserves-in-domain/L MD1 U E MD2.

%worlds () (update-preserves-in-domain _ _ _).
%total { } (update-preserves-in-domain _ _ _).


%theorem shift-preserves-update :
	forall* {M1} {N1} {D} {M1P} {N0} {M2}
	forall {U1:update M1 N1 D M1P}
               {S:shift N0 M1 M2}
        exists {N2} {M2P} 
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
               {U2:update M2 N2 D M2P}
	true.

- : shift-preserves-update update/0 shift/0 _ _ P (shift/+ P) update/0
    <- plus-total P.

- : shift-preserves-update (update/= nat`eq/) (shift/+ P) _ _ P (shift/+ P)
                           (update/= nat`eq/).

- : shift-preserves-update (update/< N4+1+N1=N3) (shift/+ N0+1+N3=N5) _ _
                           N0+1+N1=N2 (shift/+ N0+1+N1=N2) 
                           (update/< N4+1+N2=N5)
    <- plus-commutative N4+1+N1=N3 N1+N4+1=N3
    <- plus-associative-converse N1+N4+1=N3 N0+1+N3=N5 _ N0+1+N1=N2 N2+N4+1=N5
    <- plus-commutative N2+N4+1=N5 N4+1+N2=N5.

- : shift-preserves-update (update/> U N4+1+N3=N1) (shift/+ N0+1+N3=N5) _ _
                           N0+1+N1=N2 (shift/+ N0+1+N3=N5)
                           (update/> U N4+1+N5=N2)
   <- plus-total N0+1+N1=N2
   <- plus-commutative N4+1+N3=N1 N3+N4+1=N1
   <- plus-associative-converse* N3+N4+1=N1 N0+1+N1=N2 N0+1+N3=N5 N5+N4+1=N2
   <- plus-commutative N5+N4+1=N2 N4+1+N5=N2.

%worlds () (shift-preserves-update _ _ _ _ _ _ _).
%total { } (shift-preserves-update _ _ _ _ _ _ _).


%theorem shift-preserves-update* :
	forall* {M1} {N1} {D} {M1P} {N0} {M2} {N2} {M2P}
	forall {U1:update M1 N1 D M1P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
        exists {U2:update M2 N2 D M2P}
	true.

- : shift-preserves-update* U1 S P SS U2
    <- shift-preserves-update U1 S _ _ PP SSP U2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- shift-deterministic SSP SS nat`eq/ eq/ M2P=M2
    <- update-respects-eq U2P eq/ N2P=N2 fldmap`eq/ M2P=M2 U2.

%worlds () (shift-preserves-update* _ _ _ _ _).
%total { } (shift-preserves-update* _ _ _ _ _).


%theorem shift-preserves-update-converse :
	forall* {M1} {N1} {D} {N0} {M2} {N2} {M2P}
        forall {U2:update M2 N2 D M2P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
        exists {M1P} {SS:shift N0 M1P M2P}
	       {U1:update M1 N1 D M1P}
	true.

- : shift-preserves-update-converse U2 S P _ SS U1
    <- update-total U1
    <- shift-preserves-update U1 S _ _ PP SSP U2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- update-deterministic U2P U2 eq/ N2P=N2 fldmap`eq/ M2P=M2
    <- shift-respects-eq SSP nat`eq/ eq/ M2P=M2 SS.

%worlds () (shift-preserves-update-converse _ _ _ _ _ _).
%total { } (shift-preserves-update-converse _ _ _ _ _ _).


%theorem shift-preserves-update-converse* :
	forall* {M1} {N1} {D} {N0} {M2} {N2} {M2P} {M1P}
        forall {U2:update M2 N2 D M2P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
	exists {U1:update M1 N1 D M1P}
	true.

- : shift-preserves-update-converse* U2 S P SS U1
    <- shift-preserves-update-converse U2 S P _ SSP U1P
    <- shift-cancels SSP SS nat`eq/ eq/ E
    <- update-respects-eq U1P eq/ nat`eq/ fldmap`eq/ E U1.

%worlds () (shift-preserves-update-converse* _ _ _ _ _).
%total { } (shift-preserves-update-converse* _ _ _ _ _).

%theorem update-commutes-shift-converse :
	forall* {M2} {N2} {D} {M2P} {N0} {M1P}
        forall {U2:update M2 N2 D M2P}
               {SS:shift N0 M1P M2P}
        exists {N1} {M1}
               {P:plus (s N0) N1 N2}
               {S:shift N0 M1 M2}
	       {U1:update M1 N1 D M1P}
	true.

- : update-commutes-shift-converse
	update/0 (shift/+ P) _ _ P shift/0 update/0.

- : update-commutes-shift-converse
	(update/= nat`eq/) (shift/+ P) _ _ P (shift/+ P)
	(update/= nat`eq/).

- : update-commutes-shift-converse
	(update/< D1+1+N=N1) (shift/+ D2+1+N2=N) _ _ D2+1+N2=N 
	(shift/+ D2+1+N0=N1) (update/< D1+1+N2=N0)
    <- plus-commutative D2+1+N2=N N2+D2+1=N
    <- plus-associative-converse N2+D2+1=N D1+1+N=N1 N0 D1+1+N2=N0 N0+D2+1=N1
    <- plus-commutative N0+D2+1=N1 D2+1+N0=N1.

- : update-commutes-shift-converse
	(update/> U D1+1+N=N1) (shift/+ D2+1+N2=N) _ _ D2+1+N0=N1
	(shift/+ D2+1+N2=N) (update/> U D1+1+N2=N0)
    <- plus-commutative D2+1+N2=N N2+D2+1=N
    <- plus-associative-converse N2+D2+1=N D1+1+N=N1 N0 D1+1+N2=N0 N0+D2+1=N1
    <- plus-commutative N0+D2+1=N1 D2+1+N0=N1.

%worlds () (update-commutes-shift-converse _ _ _ _ _ _ _).
%total { } (update-commutes-shift-converse _ _ _ _ _ _ _).


%theorem fresh-update-preserves-lookup :
	forall* {M} {N1} {D1} {MP} {N2} {D2}
	forall {L:lookup M N2 D2} {F: fresh M N1} {U:update M N1 D1 MP}
        exists {LP:lookup MP N2 D2}
	true.

- : fresh-update-preserves-lookup L F U LP
    <- fresh-lookup-not-equal F L NE
    <- nat`ne-symmetric NE NEs
    <- update-preserves-lookup L U NEs LP.

%worlds () (fresh-update-preserves-lookup _ _ _ _).
%total { } (fresh-update-preserves-lookup _ _ _ _).


%theorem fresh-update-increases-size :
	forall* {M1} {S} {N} {D} {M2}
	forall	{S1: size M1 S}
		{F: fresh M1 N}
		{U: update M1 N D M2}
	exists	{S2: size M2 (s S)}
	true.

- : fresh-update-increases-size size/0 fresh/0 update/0 (size/+ size/0).

- : fresh-update-increases-size (size/+ S) (fresh/< G) U SP
    <- gt-implies-plus G _ P
    <- update/<-inversion U P E
    <- size-respects-eq (size/+ (size/+ S)) E nat`eq/ SP.

- : fresh-update-increases-size (size/+ S) (fresh/> F P) U SPP
    <- update/>-inversion U P _ UP E
    <- fresh-update-increases-size S F UP SP
    <- size-respects-eq (size/+ SP) E nat`eq/ SPP.

%worlds () (fresh-update-increases-size _ _ _ _).
%total (F) (fresh-update-increases-size F _ _ _).

				       
%theorem fresh-update-increases-size-converse :
	forall* {M1} {S} {N} {D} {M2}
	forall	{S2: size M2 (s S)}
		{F: fresh M1 N}
		{U: update M1 N D M2}
	exists	{S1: size M1 S}
	true.

- : fresh-update-increases-size-converse S2 F U S1
    <- size-total S1P
    <- fresh-update-increases-size S1P F U S2P
    <- size-deterministic S2P S2 eq/ SNP=SN
    <- succ-cancels SNP=SN NP=N 
    <- size-respects-eq S1P eq/ NP=N S1.

%worlds () (fresh-update-increases-size-converse _ _ _ _).
%total { } (fresh-update-increases-size-converse _ _ _ _).


%theorem fresh-update-preserves-disjoint :
	forall* {M1} {M2} {N} {D} {M2P}
	forall	{I: disjoint M1 M2}
		{F: fresh M1 N}
		{U: update M2 N D M2P}
	exists	{DP: disjoint M1 M2P}
	true.

%theorem fresh-update-preserves-disjoint/L :
	forall* {M1} {M2} {N} {D} {M2P} {B}
	forall	{I: disjoint M1 M2}
		{F: fresh M1 N}
		{U: update M2 N D M2P}
		{D?: disjoint? M1 M2P B}
	exists	{DP: disjoint M1 M2P}
	true.

- : fresh-update-preserves-disjoint/L _ _ _ (disjoint?/yes DJ) DJ.

- : fresh-update-preserves-disjoint/L D FR U (disjoint?/no L1 L2P) DP
    <- fresh-lookup-not-equal FR L1 NE
    <- nat`ne-symmetric NE NEs
    <- update-preserves-lookup-converse L2P U NEs L2
    <- disjoint-lookup-contradiction D L1 L2 F
    <- false-implies-disjoint F DP.

%worlds () (fresh-update-preserves-disjoint/L _ _ _ _ _).
%total { } (fresh-update-preserves-disjoint/L _ _ _ _ _).

- : fresh-update-preserves-disjoint D F U DP
    <- disjoint?-total D?
    <- fresh-update-preserves-disjoint/L D F U D? DP.

%worlds () (fresh-update-preserves-disjoint _ _ _ _).
%total { } (fresh-update-preserves-disjoint _ _ _ _).


%theorem update-overwrites :
	forall* {M1} {N1} {D1} {M2} {N2} {D2} {M3}
	forall {U1:update M1 N1 D1 M2} {U2:update M2 N2 D2 M3}
	       {E:nat`eq N1 N2}
	exists {U12:update M1 N1 D2 M3}
	true.

- : update-overwrites (update/0) (update/= nat`eq/) nat`eq/ (update/0).

- : update-overwrites (update/= nat`eq/) (update/= nat`eq/) nat`eq/ (update/= nat`eq/).

- : update-overwrites (update/< P) (update/= nat`eq/) nat`eq/ (update/< P).

- : update-overwrites (update/> U1 P) (update/> U2 PP) nat`eq/ (update/> U3 P)
    <- plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- update-overwrites U1 U2 N0=N0P U3.

%% contradiction cases
- : update-overwrites (update/0) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/0) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/= nat`eq/) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/= nat`eq/) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/< _) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/< _) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/> _ N0+1+N=N) (update/= nat`eq/) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/> _ N0+1+N1=N2) (update/< N3+1+N2=N1) nat`eq/ U
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-update F U.

%worlds () (update-overwrites M1^N1=D1->M2 M2^N2=D2->M3 N1=N2 
                       %{=>}% M1^N1=D2->M3).
%total (U) (update-overwrites U _ _ _).


%theorem update-overwrites-converse :
	forall* {M1} {N1} {D1} {M2} {D2} {M3}
	forall {U12:update M1 N1 D1 M3} {U1:update M1 N1 D2 M2}
	exists {U2:update M2 N1 D1 M3}
	true.

- : update-overwrites-converse U12 U1 U2
    <- update-total U2P 
    <- update-overwrites U1 U2P nat`eq/ U12P
    <- update-deterministic U12P U12 eq/ nat`eq/ fldmap`eq/ M2P=M2
    <- update-respects-eq U2P eq/ nat`eq/ fldmap`eq/ M2P=M2 U2.

%worlds () (update-overwrites-converse _ _ _).
%total { } (update-overwrites-converse _ _ _).


%theorem update-may-have-no-effect :
	forall* {M1} {N} {D} {M2}
	forall {L:lookup M1 N D} {U:update M1 N D M2}
	exists {E:eq M1 M2}
	true.

- : update-may-have-no-effect (lookup/= nat`eq/) U E
    <- update/=-inversion U nat`eq/ E.

- : update-may-have-no-effect (lookup/> L1 N0+1+N1=N2) U E
    <- update/>-inversion U N0+1+N1=N2 _ U1 M112=M2
    <- update-may-have-no-effect L1 U1 M1=M2
    <- map/+-preserves-eq nat`eq/ fldmap`eq/ M1=M2 M111=M112
    <- eq-transitive M111=M112 M112=M2 E.

%worlds () (update-may-have-no-effect _ _ _).
%total (L) (update-may-have-no-effect L _ _).


%theorem update-idempotent :
	forall* {M1} {N1} {D1} {M2} {N2} {D2} {M3}
	forall {U1:update M1 N1 D1 M2} {U2:update M2 N2 D2 M3}
	       {EN:nat`eq N1 N2} {ED:fldmap`eq D1 D2}
	exists {EM:eq M2 M3}
	true.

- : update-idempotent U1 U2 nat`eq/ fldmap`eq/ M2=M3
    <- update-overwrites U1 U2 nat`eq/ M1^N=D->M3
    <- update-deterministic U1 M1^N=D->M3 eq/ nat`eq/ fldmap`eq/ M2=M3.

%worlds () (update-idempotent M1^N1=D1->M2 M2^N2=D2->M3 N1=N2 D1=D2
                       %{=>}% M2=M3).
%total {} (update-idempotent _ _ _ _ _).


%theorem update-commutes :
	forall* {M} {N1} {D1} {M1} {N2} {D2} {M12}
	forall {U1:update M N1 D1 M1} {U12:update M1 N2 D2 M12}
               {NE:nat`ne N1 N2}
        exists {M2} {U2:update M N2 D2 M2} {U21:update M2 N1 D1 M12}
	true.

- : update-commutes update/0 (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes update/0 (update/< NP+1+N2=N1) _ _ update/0
                    (update/> update/0 NP+1+N2=N1).

- : update-commutes update/0 (update/> update/0 NP+1+N1=N2) _ _ update/0
                    (update/< NP+1+N1=N2).

- : update-commutes (update/= nat`eq/) (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes (update/= nat`eq/) (update/< NP+1+N2=N1) _ _ 
                    (update/< NP+1+N2=N1) (update/> (update/= nat`eq/) NP+1+N2=N1).

- : update-commutes (update/= nat`eq/) (update/> U NP+1+N1=N2) _ _ 
                    (update/> U NP+1+N1=N2) (update/= nat`eq/).

- : update-commutes (update/< _) (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes (update/< N1P+1+N1=N) (update/< N2P+1+N2=N1) _ _ 
                    (update/< N2PP+1+N2=N) 
                    (update/> (update/< N1P+1+N2P=N2PP) N2P+1+N2=N1)
    <- plus-swap-succ N2P+1+N2=N1 N2P+N2+1=N1
    <- plus-associative-converse N2P+N2+1=N1 N1P+1+N1=N 
                                 N2PP N1P+1+N2P=N2PP N2PP+N2+1=N
    <- plus-swap-succ-converse N2PP+N2+1=N N2PP+1+N2=N.

- : update-commutes ((update/< N11+1+N1=N):update (map/+ N D M) _ _ _)
                  (update/> (update/= nat`eq/) N11+1+N1=N2) _
                    (map/+ N2 D2 M)
                    (update/= N=N2)
                    ((update/< N11+1+N1=N2):update _ N1 D1 _)
    <- plus-deterministic N11+1+N1=N N11+1+N1=N2 nat`eq/ nat`eq/ N=N2.

- : update-commutes (update/< N11+1+N1=N) 
                    (update/> (update/< N2PP+1+N2P=N11) N2P+1+N1=N2) _ _
                    (update/< N2PP+1+N2=N) (update/< N2P+1+N1=N2)
    <- plus-swap-succ N11+1+N1=N N11+N1+1=N
    <- plus-swap-succ N2P+1+N1=N2 N2P+N1+1=N2
    <- plus-associative* N2PP+1+N2P=N11 N11+N1+1=N N2P+N1+1=N2
                         N2PP+1+N2=N.

- : update-commutes (update/< N11+1+N1=N) 
                    (update/> (update/> U N2PP+1+N11=N2P) N2P+1+N1=N2) _ _
                    (update/> U N2PP+1+N=N2) (update/< N11+1+N1=N)
    <- plus-swap-succ N11+1+N1=N N11+N1+1=N
    <- plus-swap-succ N2P+1+N1=N2 N2P+N1+1=N2
    <- plus-associative* N2PP+1+N11=N2P N2P+N1+1=N2 N11+N1+1=N N2PP+1+N=N2.

- : update-commutes (update/> U N11+1+N=N1) (update/= nat`eq/) _ _
                    (update/= nat`eq/) (update/> U N11+1+N=N1).

- : update-commutes (update/> U N11+1+N=N1) (update/< N2P+1+N2=N) _ _
                    (update/< N2P+1+N2=N)
		    (update/> (update/> U N11+1+N2P=N11P) N11P+1+N2=N1)
    <- plus-swap-succ N2P+1+N2=N N2P+N2+1=N
    <- plus-associative-converse N2P+N2+1=N N11+1+N=N1 
                                 N11P N11+1+N2P=N11P N11P+N2+1=N1
    <- plus-swap-succ-converse N11P+N2+1=N1 N11P+1+N2=N1.

- : update-commutes (update/> U1 N11+1+N=N1) (update/> U12 N2P+1+N=N2) N1<>N2
                    (map/+ N D M2) 
     		    (update/> U2 N2P+1+N=N2) (update/> U21 N11+1+N=N1)
    <- plus-right-cancels-ne N11+1+N=N1 N2P+1+N=N2 nat`eq/ N1<>N2 N11+1<>N2P+1
    <- succ-preserves-ne-converse N11+1<>N2P+1 N11<>N2P
    <- update-commutes U1 U12 N11<>N2P M2 U2 U21.

%worlds () (update-commutes M^N1=D1->M1 M1^D2=N2->M12 N1<>N2
                     %{=>}% M2 M^N2=D2->M2 M2^N1=D1->M12).
%total (U1) (update-commutes U1 _ _ _ _ _).


%theorem update-commutes* :
	forall* {M} {N1} {D1} {M1} {N2} {D2} {M12} {M2}
	forall {U1:update M N1 D1 M1} {U12:update M1 N2 D2 M12}
               {NE:nat`ne N1 N2} {U2:update M N2 D2 M2} 
        exists {U21:update M2 N1 D1 M12}
	true.

- : update-commutes* M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 M^N2=D2->M2 M2^N1=D1->M12
    <- update-commutes M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 
                       M2P M^N2=D2->M2P M2P^N1=D1->M12
    <- update-deterministic M^N2=D2->M2P M^N2=D2->M2 eq/ nat`eq/ 
                            fldmap`eq/ M2P=M2
    <- update-respects-eq M2P^N1=D1->M12 M2P=M2 nat`eq/ 
                            fldmap`eq/ eq/ M2^N1=D1->M12.

%worlds () (update-commutes* M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 M^N2=D2->M2
                      %{=>}% M2^N1=D1->M12).
%total {} (update-commutes* _ _ _ _ _). 


%theorem fresh-update-cancels :
	forall* {M1} {N1} {D1} {M1P}
		{M2} {N2} {D2} {M2P}
	forall	{F1: fresh M1 N1}
		{U1: update M1 N1 D1 M1P}
		{F2: fresh M2 N2}
		{U2: update M2 N2 D2 M2P}
		{NE: nat`eq N1 N2}
		{EQP: eq M1P M2P}
	exists	{DE: fldmap`eq D1 D2}
		{EQ: eq M1 M2}
	true.

% can never be update/=
- : fresh-update-cancels _ _ FR (update/= nat`eq/) _ eq/ DE E
    <- fresh-contradiction FR F
    <- fldmap`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels FR (update/= nat`eq/) _ _ _ eq/ DE E
    <- fresh-contradiction FR F
    <- fldmap`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels fresh/0 update/0 _ update/0 nat`eq/ eq/ fldmap`eq/ eq/.

- : fresh-update-cancels fresh/0 update/0 
	FR (update/> _ P) nat`eq/ eq/ DE E
    <- plus-implies-gt P nat`eq/ GT
    <- gt-anti-reflexive GT F
    <- fldmap`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels 
     (fresh/< GT1) U1 (fresh/< GT2) U2 nat`eq/ eq/ DEX E
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 _ DEX EQ12R
    <- map/+-preserves-eq-converse EQ12R NP1=NP2 DE RE
    <- succ-deterministic NP1=NP2 SNP1=SNP2
    <- plus-deterministic P1 P2 SNP1=SNP2 nat`eq/ N1=N2
    <- map/+-preserves-eq N1=N2 DE RE E.
    
- : fresh-update-cancels 
     (fresh/< GT1) U1 (fresh/> _ P2) U2 nat`eq/ eq/ DE E
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- update/>-inversion U2 P2 _ _ EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 _ _
    <- plus-implies-gt P2 nat`eq/ NP1>NP2
    <- gt-respects-eq NP1>NP2 NP1=NP2 nat`eq/ NP2>NP2
    <- gt-anti-reflexive NP2>NP2 F
    <- fldmap`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels 
	(fresh/> F1 P1) UP1 (fresh/> F2 P2) UP2 nat`eq/ eq/ DE E
    <- update/>-inversion UP1 P1 _ U1 EQ1
    <- update/>-inversion UP2 P2 _ U2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 D1=D2 MP1=MP2
    <- plus-right-cancels P1 P2 NP1=NP2 nat`eq/ SN1=SN2
    <- succ-cancels SN1=SN2 N1=N2
    <- fresh-update-cancels F1 U1 F2 U2 N1=N2 MP1=MP2 DE M1=M2
    <- map/+-preserves-eq NP1=NP2 D1=D2 M1=M2 E.

- :  fresh-update-cancels 
	(fresh/> F1 P1) UP1 (fresh/< GT2) UP2 nat`eq/ eq/ DE E
    <- update/>-inversion UP1 P1 _ _ EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion UP2 P2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 _ _
    <- plus-implies-gt P1 nat`eq/ NP2>NP1
    <- gt-respects-eq NP2>NP1 nat`eq/ NP1=NP2 NP2>NP2
    <- gt-anti-reflexive NP2>NP2 F
    <- fldmap`false-implies-eq F DE
    <- false-implies-eq F E.

%worlds () (fresh-update-cancels _ _ _ _ _ _ _ _).
%total (F) (fresh-update-cancels F _ _ _ _ _ _ _).


% not exactly a converse, but very useful nonetheless
%theorem update-commutes-converse :
	forall* {M2} {N1} {D1} {M1} {N2} {D2} {M3}
	forall	{U1:update M2 N1 D1 M3} {U2:update M1 N2 D2 M3}
        	{NE:nat`ne N1 N2}
        exists	{M0} 
		{UX1:update M0 N2 D2 M2} {UX2:update M0 N1 D1 M1}
	true.

%theorem update-commutes-converse/L :
	forall* {M2} {N1} {D1} {M1} {N2} {D2} {M3} {B}
	forall	{U1:update M2 N1 D1 M3} {U2:update M1 N2 D2 M3}
        	{NE:nat`ne N1 N2}
		{MD?: domain? M2 N1 B}
        exists	{M0} 
		{UX1:update M0 N2 D2 M2} {UX2:update M0 N1 D1 M1}
	true.

- : update-commutes-converse/L U23 U13 N1<>N2 (domain?/out F2) _ U02 U01
    <- update-implies-lookup U23 L31
    <- update-preserves-lookup-converse L31 U13 N1<>N2 L11
    <- lookup-implies-fresh-update L11 M0 F01 U01
    <- update-commutes U01 U13 N1<>N2 M2X U02X U2X3
    <- update-preserves-fresh F01 U02X N1<>N2 F2X
    <- fresh-update-cancels F2X U2X3 F2 U23 nat`eq/ eq/ _ M2X=M2
    <- update-respects-eq U02X eq/ nat`eq/ fldmap`eq/ M2X=M2 U02.

- : update-commutes-converse/L U23 U13 N1<>N2 (domain?/in L2) _ U02 U01
    <- update-implies-lookup U23 L31
    <- update-preserves-lookup-converse L31 U13 N1<>N2 L11
    <- lookup-implies-fresh-update L11 M0X F0X1 U0X1
    <- update-commutes U0X1 U13 N1<>N2 M2X U0X2X U2X3
    <- lookup-implies-update L2 U22
    <- update-overwrites-converse U22 U23 U32
    <- update-overwrites U2X3 U32 nat`eq/ U2X2
    <- nat`ne-symmetric N1<>N2 N2<>N1
    <- update-commutes U0X2X U2X2 N2<>N1 M0 U0X0 U02
    <- update-overwrites-converse U0X1 U0X0 U01.

%worlds () (update-commutes-converse/L _ _ _ _ _ _ _).
%total { } (update-commutes-converse/L _ _ _ _ _ _ _).

- : update-commutes-converse U23 U13 N1<>N2 M0 U02 U01
    <- domain?-total D?
    <- update-commutes-converse/L U23 U13 N1<>N2 D? M0 U02 U01.

%worlds () (update-commutes-converse _ _ _ _ _ _).
%total { } (update-commutes-converse _ _ _ _ _ _).


%% The following theorem is needed if you want to iteratively
%% do something with a set.  It says that you can take out an element 
%% and (using the update-preserves-X-converse theorems) get a smaller set
%% that differs only for this element:

%theorem can-remove :
        forall* {M} {S} {N} {D}
	forall {SZ:size M S} {L:lookup M N D}
	exists {M-} {S-} {SZ-:size M- S-} {E:nat`eq (s S-) S}
               {U:update M- N D M} {F:fresh M- N}
	true.

- : can-remove (size/+ _) (lookup/= _) _ _ size/0 nat`eq/ update/0 fresh/0.

- : can-remove (size/+ (size/+ SZ)) (lookup/= nat`eq/) _ _ (size/+ SZ) nat`eq/
               (update/< N3+1+N2=N1) (fresh/< N1>N2)
    <- plus-total N3+1+N2=N1
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2.

- : can-remove (size/+ SZ) (lookup/> LK N0+1+N1=N2) _ _
               (size/+ SZ2) E
               (update/> U2 N0+1+N1=N2) (fresh/> F2 N0+1+N1=N2)
    <- can-remove SZ LK M- S- SZ2 E2 U2 F2
    <- succ-deterministic E2 E.

%worlds () (can-remove _ _ _ _ _ _ _ _).
%total (L) (can-remove _ L _ _ _ _ _ _).


% another version, which requires that you "know" the set is non-empty

%theorem can-remove* :
        forall* {M} {S}
	forall	{SZ:size M (s S)}
	exists	{MP} {N} {D}
		{SZP:size MP S} 
                {U:update MP N D M} 
		{F:fresh MP N}
	true.

- : can-remove* (size/+ SZ) MP N D SZP U F
    <- can-remove (size/+ SZ) (lookup/= nat`eq/) MP NP SZPP EQ U F
    <- succ-cancels EQ EQP
    <- size-respects-eq SZPP eq/ EQP SZP.

%worlds () (can-remove* _ _ _ _ _ _ _).
%total { } (can-remove* _ _ _ _ _ _ _).


%theorem shift-implies-update :
	forall*	{M1} {N} {M2} {D}
	forall	{SH: shift N M1 M2}
	exists	{U: update M2 N D (map/+ N D M1)}
	true.

- : shift-implies-update shift/0 update/0.

- : shift-implies-update (shift/+ P) (update/< PSC)
    <- plus-swap-succ P PS
    <- plus-commutative PS PSC.

%worlds () (shift-implies-update _ _).
%total { } (shift-implies-update _ _).


%theorem fresh-update-implies-shift:
	forall* {M} {N} {D} {M1}
	forall	{F: fresh M N}
		{U: update M N D (map/+ N D M1)}
	exists	{S: shift N M1 M}
	true.

- : fresh-update-implies-shift F U S
    <- shift-total SP
    <- shift-implies-update SP UP
    <- shift-implies-fresh SP FP
    <- fresh-update-cancels FP UP F U nat`eq/ eq/ fldmap`eq/ MEQ
    <- shift-respects-eq SP nat`eq/ eq/ MEQ S.

%worlds () (fresh-update-implies-shift _ _ _).
%total { } (fresh-update-implies-shift _ _ _).





%%%% Map comparison



%%% Definition of leq

%{%
We always define leq? and nle even if we do not have these things in fldmap.
This is simply for uniformity.  The relations are crippled if
fldmap does not have the required relation.
%}%


leq? : map -> map -> bool -> type.

%abbrev leq : map -> map -> type = [M1] [M2] leq? M1 M2 true.

%abbrev nle : map -> map -> type = [M1] [M2] leq? M1 M2 false.


leq/0 : leq map/0 M.

leq/= : leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`eq N1 N2
    <- fldmap`leq D1 D2
    <- leq M1 M2.

leq/> : leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N3) N2 N1
    <- leq (map/+ N3 D1 M1) M2.


nle/< : lookup M1 N D1 -> fresh M2 N -> nle M1 M2.


%abbrev leq?/yes : leq M1 M2 -> leq? M1 M2 true = [x] x.

%abbrev leq?/no : nle M1 M2 -> leq? M1 M2 false = [x] x.



%%% Theorems about leq


%theorem false-implies-leq? :
	forall* {M1} {M2} {B}
	forall {F:void}
	exists {L:leq? M1 M2 B}
	true.

%worlds () (false-implies-leq? _ _).
%total {} (false-implies-leq? _ _).

%abbrev false-implies-leq : void -> leq M1 M2 -> type = false-implies-leq?.

%abbrev false-implies-nle : void -> nle M1 M2 -> type = false-implies-leq?.


%theorem leq?-respects-eq :
	forall* {M1} {M2} {M1P} {M2P} {B}
	forall {L:leq? M1 M2 B} {E1:eq M1 M1P} {E2:eq M2 M2P}
	exists {LP:leq? M1P M2P B}
	true.

- : leq?-respects-eq L eq/ eq/ L.

%worlds () (leq?-respects-eq _ _ _ _).
%total { } (leq?-respects-eq _ _ _ _).
%reduces L1 = L2 (leq?-respects-eq L1 _ _ L2).

%abbrev leq-respects-eq = leq?-respects-eq.

%abbrev nle-respects-eq = leq?-respects-eq.


%theorem leq/0-inversion :
	forall* {M1} {M2}
	forall {L:leq M1 M2} {E2:eq M2 map/0}
	exists {E1:eq M1 map/0}
	true.

- : leq/0-inversion leq/0 eq/ eq/.

%worlds () (leq/0-inversion _ _ _).
%total { } (leq/0-inversion _ _ _).


%theorem leq/=-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2}
	forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} {EN:nat`eq N1 N2}
	exists {ED:fldmap`leq D1 D2} {EM:leq M1 M2}
	true.

- : leq/=-inversion (leq/= M1<=M2 D1<=D2 nat`eq/) nat`eq/ D1<=D2 M1<=M2.

- : leq/=-inversion (leq/> M311<=M2 N3+1+N=N) nat`eq/ ED M1<=M2
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- fldmap`false-implies-leq F ED
    <- false-implies-eq F M311=M1
    <- leq-respects-eq M311<=M2 M311=M1 eq/ M1<=M2.

%worlds () (leq/=-inversion _ _ _ _).
%total { } (leq/=-inversion _ _ _ _).
%reduces L1 < L (leq/=-inversion L _ _ L1).


%theorem leq/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
	forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} 
               {P:plus (s N3) N2 N1}
	exists {EM:leq (map/+ N3 D1 M1) M2}
	true.

- : leq/>-inversion (leq/= M1<=M2 D1<=D2 nat`eq/) N3+1+N=N M311<=M2
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M1=M311
    <- leq-respects-eq M1<=M2 M1=M311 eq/ M311<=M2.

- : leq/>-inversion (leq/> M311P<=M2 N3P+1+N2=N1) N3+1+N2=N1 M311<=M2
    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- succ-cancels N3P+1=N3+1 N3P=N3
    <- map/+-preserves-eq N3P=N3 fldmap`eq/ eq/ M311P=M311
    <- leq-respects-eq M311P<=M2 M311P=M311 eq/ M311<=M2.

%worlds () (leq/>-inversion _ _ _).
%total { } (leq/>-inversion _ _ _).
%reduces LP < L (leq/>-inversion L _ LP).


%theorem leq-contradiction :
	forall*	{N} {D} {M}
	forall	{L: leq (map/+ N D M) map/0}
	exists	{F: void}
	true.

%worlds () (leq-contradiction _ _).
%total { } (leq-contradiction _ _).


%theorem leq/<-contradiction :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}
	forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} 
               {P:plus (s N0) N1 N2}
	exists {F:void}
	true.

- : leq/<-contradiction (leq/= _ _ nat`eq/) N0+1+N=N F
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : leq/<-contradiction (leq/> _ N3+1+N2=N1) N0+1+N1=N2 F
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F.

%worlds () (leq/<-contradiction _ _ _).
%total { } (leq/<-contradiction _ _ _).


%theorem leq-reflexive :
	forall {M}
	exists {L:leq M M}
	true.

- : leq-reflexive map/0 leq/0.

- : leq-reflexive (map/+ N D M) (leq/= M<=M D<=D nat`eq/)
    <- fldmap`leq-reflexive D D<=D
    <- leq-reflexive M M<=M.

%worlds () (leq-reflexive _ _).
%total (M) (leq-reflexive M _).


%theorem leq-anti-symmetric :
	forall* {M1} {M2}
	forall {L1: leq M1 M2} {L2:leq M2 M1}
	exists {E: eq M1 M2}
	true.

- : leq-anti-symmetric leq/0 leq/0 eq/.

- : leq-anti-symmetric (leq/= M1<=M2 D1<=D2 nat`eq/) 
                       (leq/= M2<=M1 D2<=D1 nat`eq/) E
    <- fldmap`leq-anti-symmetric D1<=D2 D2<=D1 D1=D2
    <- leq-anti-symmetric M1<=M2 M2<=M1 M1=M2
    <- map/+-preserves-eq nat`eq/ D1=D2 M1=M2 E.

- : leq-anti-symmetric (leq/= _ _ nat`eq/) (leq/> _ N3+1+N=N) E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : leq-anti-symmetric (leq/> _ N3+1+N=N) (leq/= _ _ nat`eq/) E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : leq-anti-symmetric (leq/> _ N3+1+N2=N1) (leq/> _ N0+1+N1=N2) E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (leq-anti-symmetric _ _ _).
%total (L) (leq-anti-symmetric L _ _).


%theorem leq-transitive :
	forall* {M1} {M2} {M3}
	forall {L1:leq M1 M2} {L2:leq M2 M3}
	exists {L3:leq M1 M3}
	true.

- : leq-transitive leq/0 _ leq/0.

- : leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) (leq/= M2<=M3 D2<=D3 nat`eq/)
                   (leq/= M1<=M3 D1<=D3 nat`eq/)
    <- fldmap`leq-transitive D1<=D2 D2<=D3 D1<=D3
    <- leq-transitive M1<=M2 M2<=M3 M1<=M3.

- : leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) (leq/> M522<=M3 N5+1+N3=N2)
                   (leq/> M511<=M3 N5+1+N3=N2)
    <- leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) M522<=M3 M511<=M3.

- : leq-transitive (leq/> M011<=M2 N0+1+N=N1) (leq/= M2<=M3 D2<=D3 nat`eq/)
                   (leq/> M011<=M3 N0+1+N=N1)
    <- leq-transitive M011<=M2 M2<=M3 M011<=M3.

- : leq-transitive (leq/> M011<=M2 N0+1+N2=N1) (leq/> M522<=M3 N5+1+N3=N2)
                   (leq/> M411<=M3 N4+1+N3=N1)
    <- nat`plus-swap-succ N5+1+N3=N2 N5+N3+1=N2 
    <- nat`plus-associative-converse N5+N3+1=N2 N0+1+N2=N1 N4 N0+1+N5=N4
                                     N4+N3+1=N1
    <- nat`plus-swap-succ-converse N4+N3+1=N1 N4+1+N3=N1
    <- leq-transitive (leq/> M011<=M2 N0+1+N5=N4) M522<=M3 M411<=M3.

%worlds () (leq-transitive _ _ _).
%total (L) (leq-transitive _ L _).


%theorem map/+-preserves-leq? :
	forall* {N1} {N2} {D1} {D2} {M1} {M2} {B}
	forall {E:nat`eq N1 N2} {LD:fldmap`leq D1 D2} {LM:leq? M1 M2 B}
        exists {L:leq? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

- : map/+-preserves-leq? N1=N2 D1<=D2 M1<=M2 (leq/= M1<=M2 D1<=D2 N1=N2).

- : map/+-preserves-leq? nat`eq/ _ (nle/< L1 F2)
	(nle/< (lookup/> L1 P) (fresh/> F2 P))
    <- plus-total P.


%worlds () (map/+-preserves-leq? _ _ _ _).
%total { } (map/+-preserves-leq? _ _ _ _).

%abbrev map/+-preserves-leq = map/+-preserves-leq?.

%abbrev map/+-preserves-nle = map/+-preserves-leq?.


%theorem lookup-respects-leq :
	forall* {M} {N} {D} {MP}
	forall {L:lookup M N D} {ME:leq M MP}
        exists {DP} {L:lookup MP N DP} {DE:fldmap`leq D DP}
	true.

- : lookup-respects-leq (lookup/= nat`eq/) (leq/= _ D1<=D2 nat`eq/) 
                         _ (lookup/= nat`eq/) D1<=D2.

- : lookup-respects-leq (lookup/= nat`eq/) (leq/> M311<=M2 N3+1+N2=N1)
                         D2 (lookup/> L13 N3+1+N2=N1) D1<=D2
    <- lookup-respects-leq (lookup/= nat`eq/) M311<=M2 D2 L13 D1<=D2.

- : lookup-respects-leq (lookup/> L13 N3+1+N2=N1) (leq/= M1<=M2 _ nat`eq/)
                        D2 (lookup/> L13P N3+1+N2=N1) D1<=D2
    <- lookup-respects-leq L13 M1<=M2 D2 L13P D1<=D2.

- : lookup-respects-leq (lookup/> L10 N0+1+N1=N) (leq/> M311<=M2 N3+1+N2=N1)
                        D2 (lookup/> L14P N4+1+N2=N) D1<=D2
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- nat`plus-associative-converse N3+N2+1=N1 N0+1+N1=N 
                                     N4 N0+1+N3=N4 N4+N2+1=N
    <- nat`plus-swap-succ-converse N4+N2+1=N N4+1+N2=N
    <- lookup-respects-leq (lookup/> L10 N0+1+N3=N4) M311<=M2 D2 L14P D1<=D2.

%worlds () (lookup-respects-leq _ _ _ _ _).
%total (L) (lookup-respects-leq _ L _ _ _).


%theorem lookup-respects-leq* :
	forall* {M} {N} {D} {MP} {DP}
	forall {L:lookup M N D} {ME:leq M MP}
               {LP:lookup MP N DP} 
	exists {DE:fldmap`leq D DP}
	true.

- : lookup-respects-leq* L ME LP DL
    <- lookup-respects-leq L ME _ LPP DLP
    <- lookup-unique LPP LP eq/ nat`eq/ DE
    <- fldmap`leq-respects-eq DLP fldmap`eq/ DE DL.

%worlds () (lookup-respects-leq* _ _ _ _).
%total { } (lookup-respects-leq* _ _ _ _).


%theorem lookup-implies-unit-leq :
	forall*	{M} {N} {D}
	forall	{L: lookup M N D}
	exists	{L: leq (map/+ N D map/0) M}
	true.

- : lookup-implies-unit-leq (lookup/= nat`eq/) (leq/= leq/0 D<=D nat`eq/)
    <- fldmap`leq-reflexive _ D<=D.

- : lookup-implies-unit-leq (lookup/> LO P) (leq/> LE P)
    <- lookup-implies-unit-leq LO LE.

%worlds () (lookup-implies-unit-leq _ _).
%total (L) (lookup-implies-unit-leq L _).


%theorem fresh-respects-geq :
	forall* {M} {MP} {N}
	forall {FP:fresh MP N} {L:leq M MP}
	exists {F:fresh M N}
	true.

- : fresh-respects-geq F leq/0 fresh/0.

- : fresh-respects-geq (fresh/< R) (leq/= _ _ nat`eq/) (fresh/< R).

- : fresh-respects-geq (fresh/< N2>N) (leq/> _ N3+1+N2=N1) (fresh/< N1>N)
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- gt-transitive N1>N2 N2>N N1>N.

- : fresh-respects-geq (fresh/> F20 N0+1+N2=N) (leq/= M1<=M2 _ nat`eq/)
                       (fresh/> F10 N0+1+N2=N) 
    <- fresh-respects-geq F20 M1<=M2 F10.

- : {F3110:fresh (map/+ N3 D1 M1) N0}
    {N0+1+N2=N:plus (s N0) N2 N}
    {N3+1+N2=N1:plus (s N3) N2 N1}
    fresh-respects-geq 
       (fresh/> F20 N0+1+N2=N: fresh (map/+ N2 D2 M2) N) 
       (leq/> M311<=M2 N3+1+N2=N1) FP
    <- fresh-respects-geq F20 M311<=M2 F3110
    <- nat`plus-swap-succ N0+1+N2=N N0+N2+1=N
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-right-preserves-fresh* F3110 N3+N2+1=N1 N0+N2+1=N FP.

%worlds () (fresh-respects-geq _ _ _).
%total (F) (fresh-respects-geq F _ _).


%theorem leq-implies-size-le:
	forall* {M1} {M2} {N1} {N2}
	forall {L:leq M1 M2} {SZ1:size M1 N1} {SZ2:size M2 N2}
	exists {G:ge N2 N1}
	true.

- : leq-implies-size-le leq/0 size/0 N2=|M2| N2>=0
    <- plus-commutative (plus/z:plus z N2 N2) N2+0=N2    
    <- plus-implies-ge N2+0=N2 N2>=0.

- : leq-implies-size-le (leq/= M1<=M2 _ _) (size/+ N1=|M1|) (size/+ N2=|M2|)
                        N2+1>=N1+1
    <- leq-implies-size-le M1<=M2 N1=|M1| N2=|M2| N2>=N1
    <- succ-preserves-ge N2>=N1 N2+1>=N1+1.

- : leq-implies-size-le (leq/> M311<=M2 _) (size/+ N1=|M1|) (size/+ N2=|M2|)
                        (ge/> N2+1>N1+1)
    <- leq-implies-size-le M311<=M2 (size/+ N1=|M1|) N2=|M2| N2>=N1+1
    <- succ-implies-gt nat`eq/ N2+1>N2
    <- gt-transitive-ge N2+1>N2 N2>=N1+1 N2+1>N1+1.

%worlds () (leq-implies-size-le _ _ _ _).
%total (L) (leq-implies-size-le L _ _ _).


%theorem leq-implies-bound-le:
	forall* {M1} {M2} {N1} {N2}
	forall {L:leq M1 M2} {BD1:bound M1 N1} {BD2:bound M2 N2}
	exists {G:ge N2 N1}
	true.

- : leq-implies-bound-le leq/0 bound/0 _ N2>=0
    <- plus-commutative plus/z N2+0=N2    
    <- plus-implies-ge N2+0=N2 N2>=0.

- : leq-implies-bound-le (leq/= M1<=M2 _ nat`eq/) 
                         (bound/+ N+1+N1=N3 DM1<N1) 
                         (bound/+ N+1+N2=N4 DM2<N2)
                         N4>=N3
    <- leq-implies-bound-le M1<=M2 DM1<N1 DM2<N2 N2>=N1
    <- plus-left-preserves-ge* N2>=N1 N+1+N2=N4 N+1+N1=N3 N4>=N3.

- : leq-implies-bound-le (leq/> M311<=M2 N3+1+N2=N1) 
                         (bound/+ N1+1+N10=N11 DM1<N10) 
                         (bound/+ N2+1+N20=N22 DM2<N20)
                         N22>=N11
    <- plus-total N3+1+N10=N13
    <- leq-implies-bound-le M311<=M2 (bound/+ N3+1+N10=N13 DM1<N10) DM2<N20
                            N20>=N13 
    <- plus-swap-succ N1+1+N10=N11 N1+N10+1=N11
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- plus-swap-succ N3+1+N10=N13 N3+N10+1=N13
    <- plus-associative* N2+1+N3=N1 N1+N10+1=N11 N3+N10+1=N13 N2+1+N13=N11
    <- plus-left-preserves-ge* N20>=N13 N2+1+N20=N22 N2+1+N13=N11 N22>=N11.

%worlds () (leq-implies-bound-le _ _ _ _).
%total (L) (leq-implies-bound-le L _ _ _).


%theorem shift-left-preserves-leq*:
	forall* {M1} {M2} {N} {SM1} {D}
	forall {L:leq M1 M2}
	       {S1:shift N M1 SM1}
	exists {SL:leq SM1 (map/+ N D M2)}
	true.

- : shift-left-preserves-leq* _ shift/0 leq/0.

- : shift-left-preserves-leq* M111<=M2 (shift/+ N+1+N1=N1P) 
                              (leq/> M111<=M2 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-leq* _ _ _).
%total { } (shift-left-preserves-leq* _ _ _).


%theorem shift-preserves-leq*:
	forall* {M1} {M2} {N} {SM1} {SM2} 
	forall {L:leq M1 M2}
               {S1:shift N M1 SM1}
	       {S1:shift N M2 SM2}
	exists {SL:leq SM1 SM2}
	true.

- : shift-preserves-leq* _ shift/0 _ leq/0.

- : shift-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                         (shift/+ N+1+N1=N1P) 
                         (shift/+ N+1+N1=N2P)
                         (leq/= M1<=M2 D1<=D2 N1P=N2P)
    <- plus-deterministic N+1+N1=N1P N+1+N1=N2P nat`eq/ nat`eq/ N1P=N2P.

- : shift-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                         (shift/+ N+1+N1=N1P) 
                         (shift/+ N+1+N2=N2P)
                         (leq/> M311<=M2 N3+1+N2P=N1P)
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N1P N+1+N2=N2P N2P+N3+1=N1P
    <- plus-commutative N2P+N3+1=N1P N3+1+N2P=N1P.

%worlds () (shift-preserves-leq* _ _ _ _).
%total { } (shift-preserves-leq* _ _ _ _).

%abbrev shift-preserves-leq = shift-preserves-leq*.

%theorem shift-preserves-leq-converse:
	forall* {M1} {M2} {N} {SM1} {SM2} 
	forall {L:leq SM1 SM2}
               {S1:shift N M1 SM1}
	       {S1:shift N M2 SM2}
	exists {SL:leq M1 M2}
	true.

- : shift-preserves-leq-converse _ shift/0 _ leq/0.

- : shift-preserves-leq-converse (leq/= M1<=M2 D1<=D2 nat`eq/)
     				 (shift/+ N+1+N1P=N1) 
                         	 (shift/+ N+1+N2P=N1)
                         	 (leq/= M1<=M2 D1<=D2 N1P=N2P)
    <- plus-left-cancels N+1+N1P=N1 N+1+N2P=N1 nat`eq/ nat`eq/ N1P=N2P.

- : shift-preserves-leq-converse (leq/> M311<=M2 N3+1+N2P=N1P)
                         	 (shift/+ N+1+N1=N1P) 
                        	 (shift/+ N+1+N2=N2P)
                        	 (leq/> M311<=M2 N3+1+N2=N1)
    <- plus-commutative N3+1+N2P=N1P N2P+N3+1=N1P
    <- plus-associative N+1+N2=N2P N2P+N3+1=N1P M1 N2+N3+1=M1 N+1+M1=N1P
    <- plus-left-cancels N+1+M1=N1P N+1+N1=N1P nat`eq/ nat`eq/ M1=N1
    <- plus-respects-eq N2+N3+1=M1 nat`eq/ nat`eq/ M1=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1.

%worlds () (shift-preserves-leq-converse _ _ _ _).
%total { } (shift-preserves-leq-converse _ _ _ _).


%theorem disjoint-respects-geq* :
	forall* {M1} {M2} {M1P}
	forall {A:disjoint M1 M2} {E1:leq M1P M1}
	exists {AP:disjoint M1P M2}
	true.

- : disjoint-respects-geq* _ leq/0 disjoint/L.
	
- : disjoint-respects-geq* disjoint/R _ disjoint/R.

- : disjoint-respects-geq* 
	(disjoint/< D1 P) (leq/= L _ nat`eq/)
	(disjoint/< D1P P)
    <- disjoint-respects-geq* D1 L D1P.

- : disjoint-respects-geq*
	(disjoint/> D1 P) (leq/= L DL nat`eq/)
	(disjoint/> D1P P)
    <- disjoint-respects-geq* D1 (leq/= L DL nat`eq/) D1P.

- : disjoint-respects-geq*
	(disjoint/< D1 P1) (leq/> L P2) DP
    <- disjoint-respects-geq* D1 L D1P
    <- plus-swap-succ P1 P1S
    <- plus-swap-succ P2 P2S
    <- plus-commutative P1S P1SC
    <- plus-commutative P2S P2SC
    <- shift-preserves-disjoint D1P (shift/+ P2SC) (shift/+ P1SC) DP.

- : disjoint-respects-geq*
	(disjoint/> D1 N0+1+N1=N2) (leq/> L N3+1+N2=N4) DP
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N3+1+N2=N4 N5 N3+1+N0=N5 N5+N1+1=N4
    <- disjoint-respects-geq* D1 (leq/> L N3+1+N0=N5) D1P
    <- plus-commutative N5+N1+1=N4 N1+1+N5=N4
    <- shift-left-preserves-disjoint D1P (shift/+ N1+1+N5=N4) DP.

%worlds () (disjoint-respects-geq* _ _ _).
%total (D) (disjoint-respects-geq* D _ _).


%theorem disjoint-respects-geq :
	forall* {M1} {M2} {M1P} {M2P}
	forall {A:disjoint M1 M2} {E1:leq M1P M1} {E2:leq M2P M2} 
	exists {AP:disjoint M1P M2P}
	true.

- : disjoint-respects-geq M1^M2 M1P<=M1 M2P<=M2 M1P^M2P
    <- disjoint-respects-geq* M1^M2 M1P<=M1 M1P^M2
    <- disjoint-symmetric M1P^M2 M2^M1P
    <- disjoint-respects-geq* M2^M1P M2P<=M2 M2P^M1P
    <- disjoint-symmetric M2P^M1P M1P^M2P.

%worlds () (disjoint-respects-geq _ _ _ _).
%total { } (disjoint-respects-geq _ _ _ _).


%theorem disjoint-leq-implies-empty :
        forall* {M1} {M2}
        forall  {D: disjoint M1 M2}
                {L: leq M1 M2}
        exists  {E: eq map/0 M1}
        true.


- : disjoint-leq-implies-empty D L E
    <- leq-reflexive _ M<=M
    <- disjoint-respects-geq D M<=M L DD
    <- disjoint-anti-reflexive DD E.

%worlds () (disjoint-leq-implies-empty _ _ _).
%total { } (disjoint-leq-implies-empty _ _ _).


%theorem update-left-preserves-leq*:
	forall* {M1} {M2} {N} {D} {M1P} {M2P}
	forall {L:leq M1 M2} 
               {U1:update M1 N D M1P}
	       {U2:update M2 N D M2P}
	exists {LP:leq M1P M2P}
	true.

- : update-left-preserves-leq* leq/0 update/0 update/0 (leq/= leq/0 D<=D nat`eq/)
    <- fldmap`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/= nat`eq/) 
                          (leq/= leq/0 D<=D nat`eq/)
    <- fldmap`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/< _)
                          (leq/= leq/0 D<=D nat`eq/)
    <- fldmap`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/> U2505 N5+1+N2=N)
                          (leq/> M500<=M5 N5+1+N2=N)
    <- update-left-preserves-leq* leq/0 update/0 U2505 M500<=M5.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/= nat`eq/) 
                          (U2:update (map/+ N D2 M2) N D M)
                          M001<=M
    <- update/=-inversion U2 nat`eq/ M002=M
    <- fldmap`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= M1<=M2 D<=D nat`eq/) eq/ M002=M M001<=M.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/< N3+1+N=N1)
                          (U2:update (map/+ N1 D2 M2) N D M)
                          M00M311<=M
    <- update/<-inversion U2 N3+1+N=N1 M00M322=M
    <- fldmap`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= (leq/= M1<=M2 D1<=D2 nat`eq/) D<=D nat`eq/) eq/ 
                       M00M322=M M00M311<=M.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/> U1303 N3+1+N1=N)
                          (U2:update (map/+ N1 D2 M2) N D M)
                          M113<=M
    <- update/>-inversion U2 N3+1+N1=N M4 U2304 M124=M
    <- update-left-preserves-leq* M1<=M2 U1303 U2304 M3<=M4
    <- leq-respects-eq (leq/= M3<=M4 D1<=D2 nat`eq/) eq/ M124=M M113<=M.

- : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                          (update/= nat`eq/)
			  (U2:update (map/+ N2 D2 M2) N1 D M)
                          M101<=M
    <- update/>-inversion U2 N3+1+N2=N1 M4 U2304 M224=M
    <- update-left-preserves-leq* M311<=M2 (update/= nat`eq/) U2304 M301<=M4
    <- leq-respects-eq (leq/> M301<=M4 N3+1+N2=N1) eq/ M224=M M101<=M.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N=N1)
                           (update/< N4+1+N=N1)   
                           (update/= nat`eq/) %% hence N=N2
                           (leq/= M411<=M2 D<=D nat`eq/)
     <- nat`plus-right-cancels N3+1+N=N1 N4+1+N=N1 nat`eq/ nat`eq/ N3+1=N4+1
     <- nat`succ-cancels N3+1=N4+1 N3=N4
     <- map/+-preserves-eq N3=N4 fldmap`eq/ eq/ M311=M411
     <- leq-respects-eq M311<=M2 M311=M411 eq/ M411<=M2
     <- fldmap`leq-reflexive _ D<=D.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                           (update/< N4+1+N=N1)
                           (update/< N5+1+N=N2)
                           (leq/= (leq/> M311<=M2 N3+1+N5=N4) D<=D nat`eq/)
     <- nat`plus-swap-succ N5+1+N=N2 N5+N+1=N2
     <- nat`plus-associative-converse N5+N+1=N2 N3+1+N2=N1 
                                      N4P N3+1+N5=N4P N4P+N+1=N1
     <- nat`plus-swap-succ N4+1+N=N1 N4+N+1=N1
     <- nat`plus-right-cancels N4P+N+1=N1 N4+N+1=N1 nat`eq/ nat`eq/ N4P=N4
     <- nat`plus-respects-eq N3+1+N5=N4P nat`eq/ nat`eq/ N4P=N4 N3+1+N5=N4
     <- fldmap`leq-reflexive _ D<=D.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                           (update/< N4+1+N=N1)   
                           (update/> U2505 N5+1+N2=N)
                           (leq/> M50M411<=M5 N5+1+N2=N)
     <- nat`plus-swap-succ N5+1+N2=N N5+N2+1=N
     <- nat`plus-associative-converse N5+N2+1=N N4+1+N=N1
                                      N3P N4+1+N5=N3P N3P+N2+1=N1
     <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
     <- nat`plus-right-cancels N3P+N2+1=N1 N3+N2+1=N1 nat`eq/ nat`eq/ N3P=N3
     <- nat`plus-respects-eq N4+1+N5=N3P nat`eq/ nat`eq/ N3P=N3 N4+1+N5=N3
     <- update-left-preserves-leq* M311<=M2 (update/< N4+1+N5=N3) U2505 
                              M50M411<=M5.

- : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                          (update/> U1404 N4+1+N1=N)
                          (U2:update (map/+ N2 D2 M2) N D M)
                          M114<=M
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- nat`plus-associative-converse N3+N2+1=N1 N4+1+N1=N 
                                     N5 N4+1+N3=N5 N5+N2+1=N
    <- nat`plus-swap-succ-converse N5+N2+1=N N5+1+N2=N
    <- update/>-inversion U2 N5+1+N2=N M5 U2505 M225=M
    <- update-left-preserves-leq* M311<=M2 (update/> U1404 N4+1+N3=N5) U2505
                             M314<=M5
    <- leq-respects-eq (leq/> M314<=M5 N3+1+N2=N1) eq/ M225=M M114<=M.

%worlds () (update-left-preserves-leq* _ _ _ _).
%total (U) (update-left-preserves-leq* _ _ U _).


%theorem update-right-preserves-leq*:
	forall* {M} {N} {D1} {D2} {M1P} {M2P}
	forall {L:fldmap`leq D1 D2} 
               {U1:update M N D1 M1P}
	       {U2:update M N D2 M2P}
	exists {LP:leq M1P M2P}
	true.

- : update-right-preserves-leq* D1<=D2 update/0 update/0 
                                (leq/= leq/0 D1<=D2 nat`eq/).

- : update-right-preserves-leq* D1<=D2 (update/= nat`eq/) U2 L
    <- update/=-inversion U2 nat`eq/ M221=M2P
    <- leq-reflexive _ M1<=M1
    <- leq-respects-eq (leq/= M1<=M1 D1<=D2 nat`eq/) eq/ M221=M2P L.

- : update-right-preserves-leq* D1<=D2 (update/< P) U2 L
    <- update/<-inversion U2 P M22311=M2P
    <- leq-reflexive _ M311<=M311
    <- leq-respects-eq (leq/= M311<=M311 D1<=D2 nat`eq/) eq/ M22311=M2P L.

- : update-right-preserves-leq* D1<=D2 (update/> U1 P) U22 L
    <- update/>-inversion U22 P M2P U2 M112=M
    <- update-right-preserves-leq* D1<=D2 U1 U2 M1P<=M2P
    <- fldmap`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= M1P<=M2P D<=D nat`eq/) eq/ M112=M L.

%worlds () (update-right-preserves-leq* _ _ _ _).
%total (U) (update-right-preserves-leq* _ U _ _).


%theorem update-preserves-leq* :
	forall* {M1} {M2} {N} {D1} {D2} {M1P} {M2P}
	forall {L:leq M1 M2} {L:fldmap`leq D1 D2} 
               {U1:update M1 N D1 M1P}
	       {U2:update M2 N D2 M2P}
	exists {LP:leq M1P M2P}
	true.

- : update-preserves-leq* M1<=M2 D1<=D2 M1^N=D1->M1P M2^N=D2->M2P M1P<=M2P
    <- update-total M2^N=D1->MM
    <- update-left-preserves-leq* M1<=M2 M1^N=D1->M1P M2^N=D1->MM M1P<=MM
    <- update-right-preserves-leq* D1<=D2 M2^N=D1->MM M2^N=D2->M2P MM<=M2P
    <- leq-transitive M1P<=MM MM<=M2P M1P<=M2P.

%worlds () (update-preserves-leq* _ _ _ _ _).
%total { } (update-preserves-leq* _ _ _ _ _).


%theorem fresh-update-preserves-leq-converse :
	forall* {M1} {M2} {N} {D1} {D2} {M1P} {M2P}
	forall	{LP:leq M1P M2P}
		{F1:fresh M1 N}
        	{U1:update M1 N D1 M1P}
		{F2:fresh M2 N}
		{U2:update M2 N D2 M2P}
	exists	{L:leq M1 M2} 
		{L:fldmap`leq D1 D2} 
	true.

- : fresh-update-preserves-leq-converse
	_ _ _ FR (update/= nat`eq/) L DL
    <- fresh-contradiction FR F
    <- false-implies-leq F L
    <- fldmap`false-implies-leq F DL.

- : fresh-update-preserves-leq-converse 
	M1P<=M2P fresh/0 update/0 _ U2 leq/0 D1<=D2
    <- update-implies-lookup U2 L2
    <- lookup-respects-leq* (lookup/= nat`eq/) M1P<=M2P L2 D1<=D2.

- : fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/< GT1) U1 (fresh/< GT2) U2 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U1 P1 EQ1
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1P<=M2Px
    <- leq/=-inversion M1P<=M2Px nat`eq/ D1<=D2 M1s<=M2s
    <- plus-swap-succ P1 P1s
    <- plus-swap-succ P2 P2s
    <- plus-commutative P1s P1sc
    <- plus-commutative P2s P2sc
    <- shift-preserves-leq* M1s<=M2s (shift/+ P1sc) (shift/+ P2sc) M1<=M2.

- : fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/< GT1) U1 fresh/0 update/0 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- eq-symmetric EQ1 EQ1s
    <- leq-respects-eq M1P<=M2P EQ1s eq/ M1Px<=M2P
    <- leq/=-inversion M1Px<=M2P nat`eq/ D1<=D2 M1s<=M2s
    <- leq-contradiction M1s<=M2s F
    <- false-implies-leq F M1<=M2.

- : fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/< GT1) U1 (fresh/> F2R P2) U2 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- update/>-inversion U2 P2 _ U2R EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1P<=M2Px
    <- leq/>-inversion M1P<=M2Px P2 M1PR<=M2PR
    <- plus-swap-succ P2 P2s
    <- plus-associative-converse P2s P1 _ P1R P2Rc
    <- plus-commutative P2Rc P2R
    <- plus-implies-gt P1R nat`eq/ GT1R
    <- fresh-update-preserves-leq-converse
	M1PR<=M2PR (fresh/< GT1R) (update/< P1R) F2R U2R M1R<=M2R D1<=D2
    <- shift-left-preserves-leq* M1R<=M2R (shift/+ P2R) M1<=M2.

%theorem fresh-update-preserves-leq-converse/> :
	forall*	{N1} {X1} {M1} {C1} {R1} {D1} {N}
		{N2} {X2} {M2} {C2} {R2} {D2} {CC}
	forall	{LP: leq (map/+ N1 X1 M1) (map/+ N2 X2 M2)}
		{P1: plus (s C1) N1 N}
		{F1: fresh R1 C1}
		{U1: update R1 C1 D1 M1}
		{P2: plus (s C2) N2 N}
		{F2: fresh R2 C2}
		{U2: update R2 C2 D2 M2}
		{C12: nat`compare C1 C2 CC}
	exists	{L: leq (map/+ N1 X1 R1) (map/+ N2 X2 R2)}
		{DL: fldmap`leq D1 D2}
	true.

- : fresh-update-preserves-leq-converse/> 
	LP P1 F1 U1 P2 F2 U2 nat`compare/= 
	(leq/= LR XL N1=N2) DL
    <- plus-left-cancels P1 P2 nat`eq/ nat`eq/ N1=N2
    <- leq/=-inversion LP N1=N2 XL LRP
    <- fresh-update-preserves-leq-converse LRP F1 U1 F2 U2 LR DL.

- : fresh-update-preserves-leq-converse/>
	LP C1+1+N1=N F1 U1 C2+1+N2=N F2 U2 (nat`compare/< C2>C1)
	(leq/> LR D+1+N2=N1) DL
    <- gt-implies-plus C2>C1 D D+1+C1=C2
    <- plus-swap-succ C2+1+N2=N C2+N2+1=N
    <- plus-swap-succ D+1+C1=C2 D+C1+1=C2
    <- plus-commutative D+C1+1=C2 C1+1+D=C2
    <- plus-associative C1+1+D=C2 C2+N2+1=N X D+N2+1=X C1+1+X=N
    <- plus-left-cancels C1+1+X=N C1+1+N1=N nat`eq/ nat`eq/ X=N1
    <- plus-swap-succ-converse D+N2+1=X D+1+N2=X
    <- plus-respects-eq D+1+N2=X nat`eq/ nat`eq/ X=N1 D+1+N2=N1
    <- leq/>-inversion LP D+1+N2=N1 LRP
    <- fresh-update-preserves-leq-converse 
	LRP (fresh/> F1 C1+1+D=C2) (update/> U1 C1+1+D=C2) F2 U2 LR DL.

- : fresh-update-preserves-leq-converse/>
	LP P1 F1 U1 P2 F2 U2 (nat`compare/> C1>C2) L DL
    <- succ-preserves-gt C1>C2 SC1>SC2
    <- plus-left-reverses-gt P1 P2 SC1>SC2 nat`eq/ N2>N1
    <- gt-implies-plus N2>N1 _ P
    <- leq/<-contradiction LP P F
    <- false-implies-leq F L
    <- fldmap`false-implies-leq F DL.

- : {U1R: update R1 C1 D1 M1} fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/> F1R P1) U1 (fresh/> F2R P2) U2 M1<=M2 D1<=D2
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- update/>-inversion U2 P2 _ U2R EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1PR<=M2PR
    <- nat`compare-total C
    <- fresh-update-preserves-leq-converse/>
	M1PR<=M2PR P1 F1R U1R P2 F2R U2R C M1<=M2 D1<=D2.

- : fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/> F1R P1) U1 fresh/0 update/0 L DL
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- eq-symmetric EQ1 EQ1s
    <- leq-respects-eq M1P<=M2P EQ1s eq/ M1Px<=M2P
    <- leq/<-contradiction M1Px<=M2P P1 F
    <- false-implies-leq F L
    <- fldmap`false-implies-leq F DL.

- : fresh-update-preserves-leq-converse
	M1P<=M2P (fresh/> F1R P1) U1 (fresh/< GT2) U2 L DL
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1PR<=M2PR
    <- leq/<-contradiction M1PR<=M2PR P1 F
    <- false-implies-leq F L
    <- fldmap`false-implies-leq F DL.

%worlds () (fresh-update-preserves-leq-converse _ _ _ _ _ _ _)
                 (fresh-update-preserves-leq-converse/> _ _ _ _ _ _ _ _ _ _).
%total (F2a F2b)
 	(fresh-update-preserves-leq-converse _ F1a _ F2a _ _ _)
        (fresh-update-preserves-leq-converse/> _ _ F1b _ _ F2b _ _ _ _).

%theorem fresh-update-implies-leq :
	forall* {M1} {N} {D} {M2}
	forall {F:fresh M1 N} {U:update M1 N D M2}
	exists {L:leq M1 M2}
	true.

- : fresh-update-implies-leq fresh/0 U leq/0.

- : fresh-update-implies-leq (fresh/< N2<N1) U L
    <- gt-implies-plus N2<N1 _ N3+1+N2=N1
    <- update/<-inversion U N3+1+N2=N1 M22311=M2
    <- leq-reflexive _ M311<=M311
    <- leq-respects-eq (leq/> M311<=M311 N3+1+N2=N1) eq/ M22311=M2 L.

- : fresh-update-implies-leq (fresh/> F1 N0+1+N1=N2) U L
    <- update/>-inversion U N0+1+N1=N2 _ U1 M112=M
    <- fresh-update-implies-leq F1 U1 L1
    <- fldmap`leq-reflexive _ DL
    <- leq-respects-eq (leq/= L1 DL nat`eq/) eq/ M112=M L.

%worlds () (fresh-update-implies-leq _ _ _).
%total (F) (fresh-update-implies-leq F _ _).


%theorem lookup-update-preserves-leq :
	forall* {M1} {N} {D1} {D2} {M2}
	forall {L:lookup M1 N D1} {U:update M1 N D2 M2}
               {L:fldmap`leq D1 D2}
	exists {L:leq M1 M2}
	true.

- : lookup-update-preserves-leq (lookup/= nat`eq/) U D1<=D2 L
    <- update/=-inversion U nat`eq/ M221=M2
    <- leq-reflexive _ M1<=M1
    <- leq-respects-eq (leq/= M1<=M1 D1<=D2 nat`eq/) eq/ M221=M2 L.

- : lookup-update-preserves-leq (lookup/> L1 N0+1+N1=N2) U D1<=D2 L
    <- update/>-inversion U N0+1+N1=N2 M2 U1 M112=M
    <- lookup-update-preserves-leq L1 U1 D1<=D2 L1P
    <- fldmap`leq-reflexive _ D1<=D1
    <- leq-respects-eq (leq/= L1P D1<=D1 nat`eq/) eq/ M112=M L.

%worlds () (lookup-update-preserves-leq _ _ _ _).
%total (L) (lookup-update-preserves-leq L _ _ _).



%%% Theorems about nle


%theorem nle-anti-reflexive :
	forall* {M}
	forall {N:nle M M}
	exists {F:void}
	true.

- : nle-anti-reflexive (nle/< L F) FALSE
    <- fresh-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N FALSE.


%worlds () (nle-anti-reflexive _ _).
%total { } (nle-anti-reflexive _ _).


%theorem nle-implies-ne :
	forall* {M1} {M2}
	forall {N1:nle M1 M2}
	exists {N2:ne M1 M2}
	true.

- : nle-implies-ne (nle/< L F) (ne/< L F).


%worlds () (nle-implies-ne _ _).
%total (N) (nle-implies-ne N _).


%theorem leq-nle-contradiction :
	forall* {M1} {M2}
	forall {L:leq M1 M2} {N1:nle M1 M2}
	exists {F:void}
	true.

- : leq-nle-contradiction M1<=M2 (nle/< L1 F2) FALSE
    <- lookup-respects-leq L1 M1<=M2 _ L2 _
    <- fresh-lookup-not-equal F2 L2 N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N FALSE.


%worlds () (leq-nle-contradiction _ _ _).
%total { } (leq-nle-contradiction _ _ _).




%%%% Map domain

%{%
We define the domain of a map as a set.
This functor can be used with any "map" type.
It should be included after "map-base.elf".
For theorems connecting domains with join and add,
please see the corresponding files.
%}%



%%% Definition of domain


domain : map -> set -> type.


domain/0 : domain map/0 set`map/0.

domain/+ : domain M S ->
	domain (map/+ N _ M) (set`map/+ N unit/ S).

%abbrev domain/1 : domain (map/1 N D) (set/1 N) = (domain/+ domain/0).

%worlds () (domain _ _).
%unique domain +M -1S.



%%% Theorems about domain


%theorem false-implies-domain :
	forall* {M} {S}
	forall {F:void}
	exists {D:domain M S}
	true.

%worlds () (false-implies-domain _ _).
%total {} (false-implies-domain _ _).


%theorem domain-respects-eq :
	forall* {M1} {M2} {S1} {S2}
	forall {A1:domain M1 S1} {E1:eq M1 M2} {E2:set`eq S1 S2}
	exists {A2:domain M2 S2}
	true.

- : domain-respects-eq A eq/ set`eq/ A.

%worlds () (domain-respects-eq _ _ _ _).
%total {} (domain-respects-eq _ _ _ _).
%reduces A = AP (domain-respects-eq A _ _ AP).


%theorem domain-deterministic :
	forall* {M1} {M2} {S1} {S2}
	forall  {A1:domain M1 S1}
		{A2:domain M2 S2}
                {E1:eq M1 M2}
	exists	{E3:set`eq S1 S2}
	true.

%abbrev domain-unique = domain-deterministic.

- : domain-deterministic domain/0 domain/0 eq/ set`eq/.

- : domain-deterministic (domain/+ D1) (domain/+ D2) eq/ SEP
    <- domain-deterministic D1 D2 eq/ SE
    <- set`map/+-preserves-eq nat`eq/ unit`eq/ SE SEP.

%worlds () (domain-deterministic _ _ _ _).
%total (A) (domain-deterministic A _ _ _).


%theorem domain-total* :
	forall {M}
	exists {S} {A:domain M S}
	true.

%abbrev domain-total = domain-total* _ _.

- : domain-total domain/0.

- : domain-total* _ (set/+ _ _) (domain/+ D)
    <- domain-total D.

%worlds () (domain-total* _ _ _).

%total (M) (domain-total* M _ _).


%theorem domain-empty-implies-empty :
	forall* {M}
	forall {A:domain M set`set/0}
	exists {E1:eq M map/0}
	true.

- : domain-empty-implies-empty domain/0 eq/.

%worlds () (domain-empty-implies-empty _ _).
%total { } (domain-empty-implies-empty _ _).


%theorem domain-preserves-lookup :
	forall* {M} {S} {I} {D}
	forall	{DM: lookup M I D}
		{D: domain M S}
	exists	{SM: set`lookup S I unit/}
	true.

- : domain-preserves-lookup 
	(lookup/= nat`eq/) (domain/+ _) 
	(set`lookup/= nat`eq/).

- : domain-preserves-lookup
	(lookup/> ML P) (domain/+ D)
	(set`lookup/> MS P)
    <- domain-preserves-lookup ML D MS.

%worlds () (domain-preserves-lookup _ _ _).
%total (L) (domain-preserves-lookup L _ _).



%theorem domain-preserves-lookup-converse :
	forall* {M} {S} {I}
	forall	{SM: set`lookup S I unit/}
		{D: domain M S}
	exists	{D} {DM: lookup M I D}
	true.

- : domain-preserves-lookup-converse
	(set`lookup/= nat`eq/) (domain/+ _) _
	(lookup/= nat`eq/).

- : domain-preserves-lookup-converse
	(set`lookup/> SL P) (domain/+ D) _
	(lookup/> ML P)
    <- domain-preserves-lookup-converse SL D _ ML.

%worlds () (domain-preserves-lookup-converse _ _ _ _).
%total (L) (domain-preserves-lookup-converse L _ _ _).



%theorem domain-preserves-fresh :
	forall* {M} {S} {I}
	forall	{DM: fresh M I}
		{D: domain M S}
	exists	{SM: set`not-member S I}
	true.

- : domain-preserves-fresh 
	(fresh/0) domain/0
	(set`not-member/0).

- : domain-preserves-fresh
	(fresh/< P) (domain/+ _)
	(set`not-member/< P).

- : domain-preserves-fresh
	(fresh/> ML P) (domain/+ D)
	(set`not-member/> MS P)
    <- domain-preserves-fresh ML D MS.

%worlds () (domain-preserves-fresh _ _ _).
%total (L) (domain-preserves-fresh L _ _).



%theorem domain-preserves-fresh-converse :
	forall* {M} {S} {I}
	forall	{SM: set`not-member S I}
		{D: domain M S}
	exists	{DM: fresh M I}
	true.

- : domain-preserves-fresh-converse
	(set`not-member/0) domain/0
	(fresh/0).

- : domain-preserves-fresh-converse
	(set`not-member/< G) (domain/+ _)
	(fresh/< G).

- : domain-preserves-fresh-converse
	(set`not-member/> SL P) (domain/+ D)
	(fresh/> ML P)
    <- domain-preserves-fresh-converse SL D ML.

%worlds () (domain-preserves-fresh-converse _ _ _).
%total (L) (domain-preserves-fresh-converse L _ _).


%theorem domain-preserves-domain? :
	forall* {M} {S} {I} {B}
	forall	{DM: domain? M I B}
		{D: domain M S}
	exists	{SM: set`member? S I B}
	true.

- : domain-preserves-domain? (domain?/in ML) D (set`member?/in SL)
    <- domain-preserves-lookup ML D SL.

- : domain-preserves-domain? (domain?/out MF) D (set`member?/out SF)
    <- domain-preserves-fresh MF D SF.

%worlds () (domain-preserves-domain? _ _ _).
%total { } (domain-preserves-domain? _ _ _).


%theorem domain-preserves-domain?-converse:
	forall* {M} {S} {I} {B}
	forall	{SM: set`member? S I B}
		{D: domain M S}
	exists	{DM: domain? M I B}
	true.

- : domain-preserves-domain?-converse (set`member?/in SL) D (domain?/in ML)
    <- domain-preserves-lookup-converse SL D _ ML.

- : domain-preserves-domain?-converse (set`member?/out SF) D (domain?/out MF)
    <- domain-preserves-fresh-converse SF D MF.

%worlds () (domain-preserves-domain?-converse _ _ _).
%total { } (domain-preserves-domain?-converse _ _ _).
					     

%theorem domain-preserves-size :
	forall* {M} {N} {S}
	forall	{MS: size M N}
		{D: domain M S}
	exists	{SS: set`size S N}
	true.

- : domain-preserves-size (size/0) domain/0 (set`size/0).

- : domain-preserves-size (size/+ MS) (domain/+ D) (set`size/+ SS)
    <- domain-preserves-size MS D SS.

%worlds () (domain-preserves-size _ _ _).
%total (D) (domain-preserves-size _ D _).


%theorem domain-preserves-size-converse :
	forall* {M} {N} {S}
	forall	{SS: set`size S N}
		{D: domain M S}
	exists	{MS: size M N}
	true.

- : domain-preserves-size-converse (set`size/0) domain/0 (size/0).

- : domain-preserves-size-converse (set`size/+ SS) (domain/+ D) (size/+ MS)
    <- domain-preserves-size-converse SS D MS.

%worlds () (domain-preserves-size-converse _ _ _).
%total (D) (domain-preserves-size-converse _ D _).


%theorem domain-preserves-disjoint :
	forall*	{M1} {M2} {S1} {S2}
	forall	{D: disjoint M1 M2}
		{DM1: domain M1 S1}
		{DM2: domain M2 S2}
	exists	{DP: set`disjoint S1 S2}
	true.

- : domain-preserves-disjoint disjoint/L _ _ set`disjoint/L.

- : domain-preserves-disjoint disjoint/R _ _ set`disjoint/R.

- : domain-preserves-disjoint 
	(disjoint/< D P) (domain/+ D1) (domain/+ D2)
	(set`disjoint/< DP P)
    <- domain-preserves-disjoint D D1 (domain/+ D2) DP.

- : domain-preserves-disjoint
	(disjoint/> D P) (domain/+ D1) (domain/+ D2)
	(set`disjoint/> DP P)
    <- domain-preserves-disjoint D (domain/+ D1) D2 DP.

%worlds () (domain-preserves-disjoint _ _ _ _).
%total (D) (domain-preserves-disjoint D _ _ _).


%theorem domain-preserves-disjoint-converse :
	forall*	{M1} {M2} {S1} {S2}
	forall	{D: set`disjoint S1 S2}
		{DM1: domain M1 S1}
		{DM2: domain M2 S2}
	exists	{DP: disjoint M1 M2}
	true.

- : domain-preserves-disjoint-converse set`disjoint/L _ _ disjoint/L.

- : domain-preserves-disjoint-converse set`disjoint/R _ _ disjoint/R.

- : domain-preserves-disjoint-converse 
	(set`disjoint/< D P) (domain/+ D1) (domain/+ D2)
	(disjoint/< DP P)
    <- domain-preserves-disjoint-converse D D1 (domain/+ D2) DP.

- : domain-preserves-disjoint-converse
	(set`disjoint/> D P) (domain/+ D1) (domain/+ D2)
	(disjoint/> DP P)
    <- domain-preserves-disjoint-converse D (domain/+ D1) D2 DP.

%worlds () (domain-preserves-disjoint-converse _ _ _ _).
%total (D) (domain-preserves-disjoint-converse D _ _ _).


%theorem domain-preserves-bound :
	forall* {M} {N} {S}
	forall	{MS: bound M N}
		{D: domain M S}
	exists	{SS: set`bound S N}
	true.

- : domain-preserves-bound (bound/0) domain/0 (set`bound/0).

- : domain-preserves-bound (bound/+ P MS) (domain/+ D) (set`bound/+ P SS)
    <- domain-preserves-bound MS D SS.

%worlds () (domain-preserves-bound _ _ _).
%total (D) (domain-preserves-bound _ D _).


%theorem domain-preserves-bound-converse :
	forall* {M} {N} {S}
	forall	{SS: set`bound S N}
		{D: domain M S}
	exists	{MS: bound M N}
	true.

- : domain-preserves-bound-converse (set`bound/0) domain/0 (bound/0).

- : domain-preserves-bound-converse 
	(set`bound/+ P SS) (domain/+ D) (bound/+ P MS)
    <- domain-preserves-bound-converse SS D MS.

%worlds () (domain-preserves-bound-converse _ _ _).
%total (D) (domain-preserves-bound-converse _ D _).


%theorem shift-preserves-domain* :
	forall* {N} {M1} {M2} {S1} {S2}
	forall  {D1:domain M1 S1}
		{S:shift N M1 M2}
		{S:set`shift N S1 S2}
        exists  {D2:domain M2 S2}
        true.

- : shift-preserves-domain* domain/0 shift/0 set`shift/0 domain/0.

- : shift-preserves-domain* 
	(domain/+ D1) (shift/+ P1) (set`shift/+ P2) D2
    <- plus-deterministic P1 P2 nat`eq/ nat`eq/ N1=N2
    <- set`map/+-preserves-eq N1=N2 unit`eq/ set`eq/ S1=S2
    <- domain-respects-eq (domain/+ D1) eq/ S1=S2 D2.

%worlds () (shift-preserves-domain* _ _ _ _).
%total { } (shift-preserves-domain* _ _ _ _).


%theorem shift-preserves-domain :
	forall* {N} {M1} {M2} {S1}
	forall  {D1:domain M1 S1}
		{S:shift N M1 M2}
	exists	{S2}
		{S:set`shift N S1 S2}
        	{D2:domain M2 S2}
        true.

- : shift-preserves-domain D1 S _ SS D2
    <- set`shift-total SS
    <- shift-preserves-domain* D1 S SS D2.

%worlds () (shift-preserves-domain _ _ _ _ _).
%total { } (shift-preserves-domain _ _ _ _ _).


%theorem shift-preserves-domain-converse :
	forall* {N} {M1} {M2} {S2}
	forall  {D1:domain M2 S2}
		{S:shift N M1 M2}
	exists	{S1}
		{S:set`shift N S1 S2}
        	{D2:domain M1 S1}
        true.

- : shift-preserves-domain-converse domain/0 shift/0 _ set`shift/0 domain/0.

- : shift-preserves-domain-converse
	(domain/+ D) (shift/+ P) _ (set`shift/+ P) (domain/+ D).

%worlds () (shift-preserves-domain-converse _ _ _ _ _).
%total { } (shift-preserves-domain-converse _ _ _ _ _).


%theorem shift-preserves-domain-converse* :
	forall* {N} {M1} {M2} {S1} {S2}
	forall  {D1:domain M2 S2}
		{S:shift N M1 M2}
		{S:set`shift N S1 S2}
        exists  {D2:domain M1 S1}
        true.

- : shift-preserves-domain-converse* domain/0 shift/0 set`shift/0 domain/0.

- : shift-preserves-domain-converse*
	(domain/+ D1) (shift/+ P1) (set`shift/+ P2) D2
    <- plus-left-cancels P1 P2 nat`eq/ nat`eq/ N1=N2
    <- set`map/+-preserves-eq N1=N2 unit`eq/ set`eq/ S1=S2
    <- domain-respects-eq (domain/+ D1) eq/ S1=S2 D2.

%worlds () (shift-preserves-domain-converse* _ _ _ _).
%total { } (shift-preserves-domain-converse* _ _ _ _).


%abbrev domain-commute-shift = shift-preserves-domain*.

%theorem shift-commute-domain :
	forall*	{N} {M1} {M2} {S1} {S2}
	forall	{MS: shift N M1 M2}
		{D1: domain M1 S1}
		{D2: domain M2 S2}
	exists	{SS: set`shift N S1 S2}
	true.

- : shift-commute-domain shift/0 domain/0 domain/0 set`shift/0.

- : shift-commute-domain (shift/+ P) (domain/+ D1) (domain/+ D2) (set`shift/+ P).

%worlds () (shift-commute-domain _ _ _ _).
%total { } (shift-commute-domain _ _ _ _).


%theorem update-commute-domain:
	forall*	{M1} {N} {D} {M2} {S1} {S2}
	forall	{U1: update M1 N D M2}
		{D1: domain M1 S1}
		{D2: domain M2 S2}
	exists	{U2: set`add S1 N S2}
	true.

- : update-commute-domain (update/0) domain/0 (domain/+ domain/0)
	(set`update/0).

% NB: we cannot use %unique for coverage for both this and the next case.
- : update-commute-domain (update/= nat`eq/) (domain/+ D1) (domain/+ D2) SU
    <- domain-deterministic D1 D2 eq/ S1=S2
    <- set`map/+-preserves-eq nat`eq/ unit`eq/ S1=S2 SE
    <- set`add-respects-eq 
	(set`update/= nat`eq/) set`eq/ nat`eq/ SE SU.

% depends on %unique for coverage.
- : update-commute-domain (update/< P) (domain/+ _) (domain/+ (domain/+ _))
	(set`update/< P).

- : update-commute-domain (update/> U1 P) (domain/+ D1) (domain/+ D2)
	(set`update/> U2 P)
    <- update-commute-domain U1 D1 D2 U2.

%worlds () (update-commute-domain _ _ _ _).
%total (U) (update-commute-domain U _ _ _).


%theorem domain-commute-update:
	forall*	{M1} {N} {D} {M2} {S1} {S2}
	forall	{D1: domain M1 S1}
		{U1: update M1 N D M2}
		{U2: set`add S1 N S2}
	exists	{D2: domain M2 S2}
	true.

- : domain-commute-update domain/0 update/0 set`update/0 (domain/+ domain/0).

- : domain-commute-update (domain/+ D) U1 (set`update/= nat`eq/) D2
    <- update/=-inversion U1 nat`eq/ ME
    <- domain-respects-eq (domain/+ D) ME set`eq/ D2.

- : domain-commute-update (domain/+ D) U1 (set`update/< P) D2
    <- update/<-inversion U1 P ME
    <- domain-respects-eq (domain/+ (domain/+ D)) ME set`eq/ D2.

- : domain-commute-update (domain/+ D) U1 (set`update/> SA P) D2P
    <- update/>-inversion U1 P _ U ME
    <- domain-commute-update D U SA D2
    <- domain-respects-eq (domain/+ D2) ME set`eq/ D2P.

%worlds () (domain-commute-update _ _ _ _).
%total (U) (domain-commute-update U _ _ _).


%theorem domain-preserves-leq*:
	forall*	{M1} {M2} {S1} {S2}
	forall	{U1: leq M1 M2}
		{D1: domain M1 S1}
		{D2: domain M2 S2}
	exists	{U2: set`leq S1 S2}
	true.

- : domain-preserves-leq* leq/0 domain/0 _ set`leq/0.

- : domain-preserves-leq* (leq/= L1 _ nat`eq/) (domain/+ D1) (domain/+ D2) 
	(set`leq/= L2 unit`eq/ nat`eq/)
    <- domain-preserves-leq* L1 D1 D2 L2.

- : domain-preserves-leq* (leq/> L1 P) (domain/+ D1) (domain/+ D2)
	(set`leq/> L2 P)
    <- domain-preserves-leq* L1 (domain/+ D1) D2 L2.

%worlds () (domain-preserves-leq* _ _ _ _).
%total (L) (domain-preserves-leq* L _ _ _).


%theorem domain-preserves-leq:
	forall*	{M1} {M2} {S1}
	forall	{L1: leq M1 M2}
		{D1: domain M1 S1}
	exists	{S2}
		{D2: domain M2 S2}
		{L2: set`leq S1 S2}
	true.

- : domain-preserves-leq L1 D1 _ D2 L2
    <- domain-total D2
    <- domain-preserves-leq* L1 D1 D2 L2.

%worlds () (domain-preserves-leq _ _ _ _ _).
%total { } (domain-preserves-leq _ _ _ _ _).




%%% Renamings

%abbrev clsmap = map.
%abbrev clsmap/0 = map/0.
%abbrev clsmap/+ = map/+.
%abbrev clsmap`map = map.
%abbrev clsmap`map/0 = map/0.
%abbrev clsmap`map/+ = map/+.
%abbrev clsmap`map/1 = map/1.
%abbrev clsmap`eq? = eq?.
%abbrev clsmap`eq = eq.
%abbrev clsmap`ne = ne.
%abbrev clsmap`eq?/yes = eq?/yes.
%abbrev clsmap`eq/ = eq/.
%abbrev clsmap`eq?/no = eq?/no.
%abbrev clsmap`lookup = lookup.
%abbrev clsmap`lookup/= = lookup/=.
%abbrev clsmap`lookup/> = lookup/>.
%abbrev clsmap`fresh = fresh.
%abbrev clsmap`fresh/0 = fresh/0.
%abbrev clsmap`fresh/< = fresh/<.
%abbrev clsmap`fresh/> = fresh/>.
%abbrev clsmap`ne/< = ne/<.
%abbrev clsmap`ne/> = ne/>.
%abbrev clsmap`domain? = domain?.
%abbrev clsmap`domain?/in = domain?/in.
%abbrev clsmap`domain?/out = domain?/out.
%abbrev clsmap`disjoint = disjoint.
%abbrev clsmap`disjoint/L = disjoint/L.
%abbrev clsmap`disjoint/R = disjoint/R.
%abbrev clsmap`disjoint/< = disjoint/<.
%abbrev clsmap`disjoint/> = disjoint/>.
%abbrev clsmap`disjoint? = disjoint?.
%abbrev clsmap`disjoint?/yes = disjoint?/yes.
%abbrev clsmap`disjoint?/no = disjoint?/no.
%abbrev clsmap`size = size.
%abbrev clsmap`size/0 = size/0.
%abbrev clsmap`size/+ = size/+.
%abbrev clsmap`bound = bound.
%abbrev clsmap`bound/0 = bound/0.
%abbrev clsmap`bound/+ = bound/+.
%abbrev clsmap`shift = shift.
%abbrev clsmap`shift/0 = shift/0.
%abbrev clsmap`shift/+ = shift/+.
%abbrev clsmap`update = update.
%abbrev clsmap`update/0 = update/0.
%abbrev clsmap`update/= = update/=.
%abbrev clsmap`update/< = update/<.
%abbrev clsmap`update/> = update/>.
%abbrev clsmap`meta-eq = meta-eq.
%abbrev clsmap`false-implies-eq? = false-implies-eq?.
%abbrev clsmap`false-implies-eq = false-implies-eq.
%abbrev clsmap`false-implies-ne = false-implies-ne.
%abbrev clsmap`eq-reflexive = eq-reflexive.
%abbrev clsmap`eq?-symmetric = eq?-symmetric.
%abbrev clsmap`eq-symmetric = eq-symmetric.
%abbrev clsmap`ne-symmetric = ne-symmetric.
%abbrev clsmap`eq-transitive = eq-transitive.
%abbrev clsmap`map/+-preserves-eq? = map/+-preserves-eq?.
%abbrev clsmap`map/+-preserves-eq = map/+-preserves-eq.
%abbrev clsmap`map/+-preserves-ne = map/+-preserves-ne.
%abbrev clsmap`map/+-preserves-eq-converse = map/+-preserves-eq-converse.
%abbrev clsmap`eq-no-occur = eq-no-occur.
%abbrev clsmap`eq-contradiction = eq-contradiction.
%abbrev clsmap`false-implies-lookup = false-implies-lookup.
%abbrev clsmap`lookup-respects-eq = lookup-respects-eq.
%abbrev clsmap`meta-reduces-lookup = meta-reduces-lookup.
%abbrev clsmap`lookup/>-inversion = lookup/>-inversion.
%abbrev clsmap`lookup-deterministic = lookup-deterministic.
%abbrev clsmap`lookup-unique = lookup-unique.
%abbrev clsmap`lookup-contradiction = lookup-contradiction.
%abbrev clsmap`lookup-one-choice = lookup-one-choice.
%abbrev clsmap`lookup-implies-ge = lookup-implies-ge.
%abbrev clsmap`false-implies-fresh = false-implies-fresh.
%abbrev clsmap`fresh-respects-eq = fresh-respects-eq.
%abbrev clsmap`fresh/>-inversion = fresh/>-inversion.
%abbrev clsmap`fresh-total* = fresh-total*.
%abbrev clsmap`fresh-total = fresh-total.
%abbrev clsmap`fresh-lookup-not-equal = fresh-lookup-not-equal.
%abbrev clsmap`fresh-contradiction = fresh-contradiction.
%abbrev clsmap`ne-implies-unit-map-fresh = ne-implies-unit-map-fresh.
%abbrev clsmap`plus-right-preserves-fresh* = plus-right-preserves-fresh*.
%abbrev clsmap`fresh-lookup-implies-ne = fresh-lookup-implies-ne.
%abbrev clsmap`eq?-respects-eq = eq?-respects-eq.
%abbrev clsmap`ne-respects-eq = ne-respects-eq.
%abbrev clsmap`ne-anti-reflexive = ne-anti-reflexive.
%abbrev clsmap`eq-ne-implies-false = eq-ne-implies-false.
%abbrev clsmap`false-implies-domain? = false-implies-domain?.
%abbrev clsmap`domain?-respects-eq = domain?-respects-eq.
%abbrev clsmap`domain?-deterministic = domain?-deterministic.
%abbrev clsmap`domain?-unique = domain?-unique.
%abbrev clsmap`domain?-total* = domain?-total*.
%abbrev clsmap`domain?-map/+-total = domain?-map/+-total.
%abbrev clsmap`domain?-map/+-complete = domain?-map/+-complete.
%abbrev clsmap`domain?-total = domain?-total.
%abbrev clsmap`in-implies-lookup = in-implies-lookup.
%abbrev clsmap`out-implies-fresh = out-implies-fresh.
%abbrev clsmap`false-implies-disjoint = false-implies-disjoint.
%abbrev clsmap`disjoint-respects-eq = disjoint-respects-eq.
%abbrev clsmap`disjoint/=-contradiction = disjoint/=-contradiction.
%abbrev clsmap`disjoint/<-inversion = disjoint/<-inversion.
%abbrev clsmap`disjoint/>-inversion = disjoint/>-inversion.
%abbrev clsmap`disjoint-anti-reflexive = disjoint-anti-reflexive.
%abbrev clsmap`disjoint-symmetric = disjoint-symmetric.
%abbrev clsmap`disjoint-lookup-contradiction = disjoint-lookup-contradiction.
%abbrev clsmap`disjoint-lookup-implies-fresh = disjoint-lookup-implies-fresh.
%abbrev clsmap`disjoint-lookup-implies-fresh/L = disjoint-lookup-implies-fresh/L.
%abbrev clsmap`shift-left-preserves-disjoint = shift-left-preserves-disjoint.
%abbrev clsmap`shift-left-preserves-disjoint-converse = shift-left-preserves-disjoint-converse.
%abbrev clsmap`shift-right-preserves-disjoint = shift-right-preserves-disjoint.
%abbrev clsmap`shift-right-preserves-disjoint-converse = shift-right-preserves-disjoint-converse.
%abbrev clsmap`shift-preserves-disjoint = shift-preserves-disjoint.
%abbrev clsmap`shift-preserves-disjoint-converse = shift-preserves-disjoint-converse.
%abbrev clsmap`can-construct-unit-disjoint = can-construct-unit-disjoint.
%abbrev clsmap`ne-implies-disjoint = ne-implies-disjoint.
%abbrev clsmap`fresh-implies-unit-disjoint = fresh-implies-unit-disjoint.
%abbrev clsmap`false-implies-size = false-implies-size.
%abbrev clsmap`size-total* = size-total*.
%abbrev clsmap`size-total = size-total.
%abbrev clsmap`size-respects-eq = size-respects-eq.
%abbrev clsmap`size-deterministic = size-deterministic.
%abbrev clsmap`size-unique = size-unique.
%abbrev clsmap`shift-preserves-size = shift-preserves-size.
%abbrev clsmap`shift-preserves-size-converse = shift-preserves-size-converse.
%abbrev clsmap`false-implies-bound = false-implies-bound.
%abbrev clsmap`bound-respects-eq = bound-respects-eq.
%abbrev clsmap`bound-unique = bound-unique.
%abbrev clsmap`bound-deterministic = bound-deterministic.
%abbrev clsmap`bound-total* = bound-total*.
%abbrev clsmap`bound-total = bound-total.
%abbrev clsmap`bound-lookup-implies-gt = bound-lookup-implies-gt.
%abbrev clsmap`ge-bound-implies-fresh = ge-bound-implies-fresh.
%abbrev clsmap`false-implies-shift = false-implies-shift.
%abbrev clsmap`shift-respects-eq = shift-respects-eq.
%abbrev clsmap`shift-total* = shift-total*.
%abbrev clsmap`shift-total = shift-total.
%abbrev clsmap`shift-deterministic = shift-deterministic.
%abbrev clsmap`shift-unique = shift-unique.
%abbrev clsmap`shift-cancels = shift-cancels.
%abbrev clsmap`shifts-add = shifts-add.
%abbrev clsmap`shifts-add-converse = shifts-add-converse.
%abbrev clsmap`shift-preserves-fresh = shift-preserves-fresh.
%abbrev clsmap`shift-preserves-fresh* = shift-preserves-fresh*.
%abbrev clsmap`shift-preserves-fresh-converse* = shift-preserves-fresh-converse*.
%abbrev clsmap`shift-preserves-lookup = shift-preserves-lookup.
%abbrev clsmap`shift-preserves-lookup* = shift-preserves-lookup*.
%abbrev clsmap`shift-preserves-lookup-converse = shift-preserves-lookup-converse.
%abbrev clsmap`shift-preserves-lookup-converse* = shift-preserves-lookup-converse*.
%abbrev clsmap`shift-implies-fresh* = shift-implies-fresh*.
%abbrev clsmap`shift-implies-fresh = shift-implies-fresh.
%abbrev clsmap`removal-preserves-fresh = removal-preserves-fresh.
%abbrev clsmap`shift-preserves-size = shift-preserves-size.
%abbrev clsmap`disjoint?-total* = disjoint?-total*.
%abbrev clsmap`disjoint?-total*/+ = disjoint?-total*/+.
%abbrev clsmap`disjoint?-total*/< = disjoint?-total*/<.
%abbrev clsmap`disjoint?-total*/> = disjoint?-total*/>.
%abbrev clsmap`disjoint?-total = disjoint?-total.
%abbrev clsmap`false-implies-update = false-implies-update.
%abbrev clsmap`update-respects-eq = update-respects-eq.
%abbrev clsmap`meta-reduces-update = meta-reduces-update.
%abbrev clsmap`update/=-inversion = update/=-inversion.
%abbrev clsmap`update/<-inversion = update/<-inversion.
%abbrev clsmap`update/>-inversion = update/>-inversion.
%abbrev clsmap`update-contradiction = update-contradiction.
%abbrev clsmap`update-deterministic = update-deterministic.
%abbrev clsmap`update-unique = update-unique.
%abbrev clsmap`update-total* = update-total*.
%abbrev clsmap`update-map/+-total = update-map/+-total.
%abbrev clsmap`update-total = update-total.
%abbrev clsmap`lookup-implies-update = lookup-implies-update.
%abbrev clsmap`lookup-implies-fresh-update = lookup-implies-fresh-update.
%abbrev clsmap`update-implies-lookup = update-implies-lookup.
%abbrev clsmap`update-preserves-lookup = update-preserves-lookup.
%abbrev clsmap`update-preserves-lookup-converse = update-preserves-lookup-converse.
%abbrev clsmap`update-preserves-fresh = update-preserves-fresh.
%abbrev clsmap`update-preserves-fresh-converse = update-preserves-fresh-converse.
%abbrev clsmap`update-preserves-fresh-converse-helper = update-preserves-fresh-converse-helper.
%abbrev clsmap`update-is-cause-of-change = update-is-cause-of-change.
%abbrev clsmap`update-is-cause-of-change/L = update-is-cause-of-change/L.
%abbrev clsmap`update-preserves-membership = update-preserves-membership.
%abbrev clsmap`update-preserves-membership-converse = update-preserves-membership-converse.
%abbrev clsmap`lookup-update-preserves-membership = lookup-update-preserves-membership.
%abbrev clsmap`lookup-update-preserves-membership/L = lookup-update-preserves-membership/L.
%abbrev clsmap`lookup-update-preserves-membership-converse = lookup-update-preserves-membership-converse.
%abbrev clsmap`update-preserves-in-domain = update-preserves-in-domain.
%abbrev clsmap`update-preserves-in-domain/L = update-preserves-in-domain/L.
%abbrev clsmap`shift-preserves-update = shift-preserves-update.
%abbrev clsmap`shift-preserves-update* = shift-preserves-update*.
%abbrev clsmap`shift-preserves-update-converse = shift-preserves-update-converse.
%abbrev clsmap`shift-preserves-update-converse* = shift-preserves-update-converse*.
%abbrev clsmap`update-commutes-shift-converse = update-commutes-shift-converse.
%abbrev clsmap`fresh-update-preserves-lookup = fresh-update-preserves-lookup.
%abbrev clsmap`fresh-update-increases-size = fresh-update-increases-size.
%abbrev clsmap`fresh-update-increases-size-converse = fresh-update-increases-size-converse.
%abbrev clsmap`fresh-update-preserves-disjoint = fresh-update-preserves-disjoint.
%abbrev clsmap`fresh-update-preserves-disjoint/L = fresh-update-preserves-disjoint/L.
%abbrev clsmap`update-overwrites = update-overwrites.
%abbrev clsmap`update-overwrites-converse = update-overwrites-converse.
%abbrev clsmap`update-may-have-no-effect = update-may-have-no-effect.
%abbrev clsmap`update-idempotent = update-idempotent.
%abbrev clsmap`update-commutes = update-commutes.
%abbrev clsmap`update-commutes* = update-commutes*.
%abbrev clsmap`fresh-update-cancels = fresh-update-cancels.
%abbrev clsmap`update-commutes-converse = update-commutes-converse.
%abbrev clsmap`update-commutes-converse/L = update-commutes-converse/L.
%abbrev clsmap`can-remove = can-remove.
%abbrev clsmap`can-remove* = can-remove*.
%abbrev clsmap`shift-implies-update = shift-implies-update.
%abbrev clsmap`fresh-update-implies-shift = fresh-update-implies-shift.
%abbrev clsmap`leq? = leq?.
%abbrev clsmap`leq = leq.
%abbrev clsmap`nle = nle.
%abbrev clsmap`leq/0 = leq/0.
%abbrev clsmap`leq/= = leq/=.
%abbrev clsmap`leq/> = leq/>.
%abbrev clsmap`nle/< = nle/<.
%abbrev clsmap`leq?/yes = leq?/yes.
%abbrev clsmap`leq?/no = leq?/no.
%abbrev clsmap`false-implies-leq? = false-implies-leq?.
%abbrev clsmap`false-implies-leq = false-implies-leq.
%abbrev clsmap`false-implies-nle = false-implies-nle.
%abbrev clsmap`leq?-respects-eq = leq?-respects-eq.
%abbrev clsmap`leq-respects-eq = leq-respects-eq.
%abbrev clsmap`nle-respects-eq = nle-respects-eq.
%abbrev clsmap`leq/0-inversion = leq/0-inversion.
%abbrev clsmap`leq/=-inversion = leq/=-inversion.
%abbrev clsmap`leq/>-inversion = leq/>-inversion.
%abbrev clsmap`leq-contradiction = leq-contradiction.
%abbrev clsmap`leq/<-contradiction = leq/<-contradiction.
%abbrev clsmap`leq-reflexive = leq-reflexive.
%abbrev clsmap`leq-anti-symmetric = leq-anti-symmetric.
%abbrev clsmap`leq-transitive = leq-transitive.
%abbrev clsmap`map/+-preserves-leq? = map/+-preserves-leq?.
%abbrev clsmap`map/+-preserves-leq = map/+-preserves-leq.
%abbrev clsmap`map/+-preserves-nle = map/+-preserves-nle.
%abbrev clsmap`lookup-respects-leq = lookup-respects-leq.
%abbrev clsmap`lookup-respects-leq* = lookup-respects-leq*.
%abbrev clsmap`lookup-implies-unit-leq = lookup-implies-unit-leq.
%abbrev clsmap`fresh-respects-geq = fresh-respects-geq.
%abbrev clsmap`leq-implies-size-le = leq-implies-size-le.
%abbrev clsmap`leq-implies-bound-le = leq-implies-bound-le.
%abbrev clsmap`shift-left-preserves-leq* = shift-left-preserves-leq*.
%abbrev clsmap`shift-preserves-leq* = shift-preserves-leq*.
%abbrev clsmap`shift-preserves-leq = shift-preserves-leq.
%abbrev clsmap`shift-preserves-leq-converse = shift-preserves-leq-converse.
%abbrev clsmap`disjoint-respects-geq* = disjoint-respects-geq*.
%abbrev clsmap`disjoint-respects-geq = disjoint-respects-geq.
%abbrev clsmap`disjoint-leq-implies-empty = disjoint-leq-implies-empty.
%abbrev clsmap`update-left-preserves-leq* = update-left-preserves-leq*.
%abbrev clsmap`update-right-preserves-leq* = update-right-preserves-leq*.
%abbrev clsmap`update-preserves-leq* = update-preserves-leq*.
%abbrev clsmap`fresh-update-preserves-leq-converse = fresh-update-preserves-leq-converse.
%abbrev clsmap`fresh-update-preserves-leq-converse/> = fresh-update-preserves-leq-converse/>.
%abbrev clsmap`fresh-update-implies-leq = fresh-update-implies-leq.
%abbrev clsmap`lookup-update-preserves-leq = lookup-update-preserves-leq.
%abbrev clsmap`nle-anti-reflexive = nle-anti-reflexive.
%abbrev clsmap`nle-implies-ne = nle-implies-ne.
%abbrev clsmap`leq-nle-contradiction = leq-nle-contradiction.
%abbrev clsmap`domain = domain.
%abbrev clsmap`domain/0 = domain/0.
%abbrev clsmap`domain/+ = domain/+.
%abbrev clsmap`domain/1 = domain/1.
%abbrev clsmap`false-implies-domain = false-implies-domain.
%abbrev clsmap`domain-respects-eq = domain-respects-eq.
%abbrev clsmap`domain-deterministic = domain-deterministic.
%abbrev clsmap`domain-unique = domain-unique.
%abbrev clsmap`domain-total* = domain-total*.
%abbrev clsmap`domain-total = domain-total.
%abbrev clsmap`domain-empty-implies-empty = domain-empty-implies-empty.
%abbrev clsmap`domain-preserves-lookup = domain-preserves-lookup.
%abbrev clsmap`domain-preserves-lookup-converse = domain-preserves-lookup-converse.
%abbrev clsmap`domain-preserves-fresh = domain-preserves-fresh.
%abbrev clsmap`domain-preserves-fresh-converse = domain-preserves-fresh-converse.
%abbrev clsmap`domain-preserves-domain? = domain-preserves-domain?.
%abbrev clsmap`domain-preserves-domain?-converse = domain-preserves-domain?-converse.
%abbrev clsmap`domain-preserves-size = domain-preserves-size.
%abbrev clsmap`domain-preserves-size-converse = domain-preserves-size-converse.
%abbrev clsmap`domain-preserves-disjoint = domain-preserves-disjoint.
%abbrev clsmap`domain-preserves-disjoint-converse = domain-preserves-disjoint-converse.
%abbrev clsmap`domain-preserves-bound = domain-preserves-bound.
%abbrev clsmap`domain-preserves-bound-converse = domain-preserves-bound-converse.
%abbrev clsmap`shift-preserves-domain* = shift-preserves-domain*.
%abbrev clsmap`shift-preserves-domain = shift-preserves-domain.
%abbrev clsmap`shift-preserves-domain-converse = shift-preserves-domain-converse.
%abbrev clsmap`shift-preserves-domain-converse* = shift-preserves-domain-converse*.
%abbrev clsmap`domain-commute-shift = domain-commute-shift.
%abbrev clsmap`shift-commute-domain = shift-commute-domain.
%abbrev clsmap`update-commute-domain = update-commute-domain.
%abbrev clsmap`domain-commute-update = domain-commute-update.
%abbrev clsmap`domain-preserves-leq* = domain-preserves-leq*.
%abbrev clsmap`domain-preserves-leq = domain-preserves-leq.
%abbrev clsmap`clsmap = clsmap.
%abbrev clsmap`clsmap/0 = clsmap/0.
%abbrev clsmap`clsmap/+ = clsmap/+.
