%abbrev set`fresh = set`not-member.
%abbrev set`fresh/0 = set`not-member/0.
%abbrev set`fresh/< = set`not-member/<.
%abbrev set`fresh/> = set`not-member/>.
%abbrev set`domain? = set`member?.
%abbrev set`domain?/in = set`member?/in.
%abbrev set`domain?/out = set`member?/out.
%abbrev set`false-implies-fresh = set`false-implies-not-member.
%abbrev set`fresh-respects-eq = set`not-member-respects-eq.
%abbrev set`fresh/>-inversion = set`not-member/>-inversion.
%abbrev set`fresh-total* = set`not-member-total*.
%abbrev set`fresh-total = set`not-member-total.
%abbrev set`fresh-lookup-not-equal = set`not-member-lookup-not-equal.
%abbrev set`fresh-contradiction = set`not-member-contradiction.
%abbrev set`ne-implies-unit-map-fresh = set`ne-implies-unit-map-not-member.
%abbrev set`plus-right-preserves-fresh* = set`plus-right-preserves-not-member*.
%abbrev set`fresh-lookup-implies-ne = set`not-member-lookup-implies-ne.
%abbrev set`false-implies-domain? = set`false-implies-member?.
%abbrev set`domain?-respects-eq = set`member?-respects-eq.
%abbrev set`domain?-deterministic = set`member?-deterministic.
%abbrev set`domain?-unique = set`member?-unique.
%abbrev set`domain?-total* = set`member?-total*.
%abbrev set`domain?-map/+-total = set`member?-map/+-total.
%abbrev set`domain?-map/+-complete = set`member?-map/+-complete.
%abbrev set`domain?-total = set`member?-total.
%abbrev set`out-implies-fresh = set`out-implies-not-member.
%abbrev set`disjoint-lookup-implies-fresh = set`disjoint-lookup-implies-not-member.
%abbrev set`disjoint-lookup-implies-fresh/L = set`disjoint-lookup-implies-not-member/L.
%abbrev set`fresh-implies-unit-disjoint = set`not-member-implies-unit-disjoint.
%abbrev set`ge-bound-implies-fresh = set`ge-bound-implies-not-member.
%abbrev set`shift-preserves-fresh = set`shift-preserves-not-member.
%abbrev set`shift-preserves-fresh* = set`shift-preserves-not-member*.
%abbrev set`shift-preserves-fresh-converse* = set`shift-preserves-not-member-converse*.
%abbrev set`shift-implies-fresh* = set`shift-implies-not-member*.
%abbrev set`shift-implies-fresh = set`shift-implies-not-member.
%abbrev set`removal-preserves-fresh = set`removal-preserves-not-member.
%abbrev set`lookup-implies-fresh-update = set`lookup-implies-not-member-update.
%abbrev set`update-preserves-fresh = set`update-preserves-not-member.
%abbrev set`update-preserves-fresh-converse = set`update-preserves-not-member-converse.
%abbrev set`update-preserves-fresh-converse-helper = set`update-preserves-not-member-converse-helper.
%abbrev set`fresh-update-preserves-lookup = set`not-member-update-preserves-lookup.
%abbrev set`fresh-update-increases-size = set`not-member-update-increases-size.
%abbrev set`fresh-update-increases-size-converse = set`not-member-update-increases-size-converse.
%abbrev set`fresh-update-preserves-disjoint = set`not-member-update-preserves-disjoint.
%abbrev set`fresh-update-preserves-disjoint/L = set`not-member-update-preserves-disjoint/L.
%abbrev set`fresh-update-cancels = set`not-member-update-cancels.
%abbrev set`fresh-update-commutes-converse* = set`not-member-update-commutes-converse*.
%abbrev set`fresh-update-implies-shift = set`not-member-update-implies-shift.
%abbrev set`fresh-respects-geq = set`not-member-respects-geq.
%abbrev set`fresh-update-preserves-leq-converse = set`not-member-update-preserves-leq-converse.
%abbrev set`fresh-update-preserves-leq-converse/> = set`not-member-update-preserves-leq-converse/>.
%abbrev set`fresh-update2-preserves-leq-converse = set`not-member-update2-preserves-leq-converse.
%abbrev set`fresh-update-implies-leq = set`not-member-update-implies-leq.
%abbrev set`join = set`union.
%abbrev set`join/L = set`union/L.
%abbrev set`join/R = set`union/R.
%abbrev set`join/= = set`union/=.
%abbrev set`join/< = set`union/<.
%abbrev set`join/> = set`union/>.
%abbrev set`false-implies-join = set`false-implies-union.
%abbrev set`join-respects-eq = set`union-respects-eq.
%abbrev set`can-construct-unit-join = set`can-construct-unit-union.
%abbrev set`join/=-inversion = set`union/=-inversion.
%abbrev set`join/<-inversion = set`union/<-inversion.
%abbrev set`join/>-inversion = set`union/>-inversion.
%abbrev set`false-implies-join-reduces = set`false-implies-union-reduces.
%abbrev set`join/<-inversion* = set`union/<-inversion*.
%abbrev set`join/>-inversion* = set`union/>-inversion*.
%abbrev set`join-deterministic = set`union-deterministic.
%abbrev set`join-unique = set`union-unique.
%abbrev set`join-total* = set`union-total*.
%abbrev set`join-map/+-M-total* = set`union-map/+-M-total*.
%abbrev set`join-M-map/+-total* = set`union-M-map/+-total*.
%abbrev set`join-map/+-map/+-total* = set`union-map/+-map/+-total*.
%abbrev set`join-total = set`union-total.
%abbrev set`disjoint-join-total = set`disjoint-union-total.
%abbrev set`disjoint-join-commutative = set`disjoint-union-commutative.
%abbrev set`join-empty-implies-empty = set`union-empty-implies-empty.
%abbrev set`join-preserves-disjoint* = set`union-preserves-disjoint*.
%abbrev set`join-preserves-disjoint*/L = set`union-preserves-disjoint*/L.
%abbrev set`join-left-preserves-disjoint* = set`union-left-preserves-disjoint*.
%abbrev set`join-right-preserves-disjoint* = set`union-right-preserves-disjoint*.
%abbrev set`join-preserves-disjoint-converse = set`union-preserves-disjoint-converse.
%abbrev set`disjoint-join-right-cancels = set`disjoint-union-right-cancels.
%abbrev set`disjoint-join-right-cancels/L = set`disjoint-union-right-cancels/L.
%abbrev set`disjoint-join-left-cancels = set`disjoint-union-left-cancels.
%abbrev set`shift-left-preserves-join = set`shift-left-preserves-union.
%abbrev set`shift-left-preserves-join-converse = set`shift-left-preserves-union-converse.
%abbrev set`shift-right-preserves-join = set`shift-right-preserves-union.
%abbrev set`shift-right-preserves-join-converse = set`shift-right-preserves-union-converse.
%abbrev set`shift-preserves-join* = set`shift-preserves-union*.
%abbrev set`shift-preserves-join = set`shift-preserves-union.
%abbrev set`shift-preserves-join-converse = set`shift-preserves-union-converse.
%abbrev set`shift-preserves-join-converse* = set`shift-preserves-union-converse*.
%abbrev set`shift-preserves-join-converse** = set`shift-preserves-union-converse**.
%abbrev set`join-commutative = set`union-commutative.
%abbrev set`join-associative = set`union-associative.
%abbrev set`join-associative-join/<-join/< = set`union-associative-union/<-union/<.
%abbrev set`join-associative* = set`union-associative*.
%abbrev set`join-associative-converse = set`union-associative-converse.
%abbrev set`join-associative-converse* = set`union-associative-converse*.
%abbrev set`join-assoc-commutative* = set`union-assoc-commutative*.
%abbrev set`join-assoc-commutative = set`union-assoc-commutative.
%abbrev set`join-double-associative* = set`union-double-associative*.
%abbrev set`join-double-associative = set`union-double-associative.
%abbrev set`lookup-implies-join = set`lookup-implies-union.
%abbrev set`join-joins-lookup = set`union-joins-lookup.
%abbrev set`join-joins-lookup* = set`union-joins-lookup*.
%abbrev set`join-commutes-lookup = set`union-commutes-lookup.
%abbrev set`join-preserves-fresh* = set`union-preserves-not-member*.
%abbrev set`fresh-join-left-preserves-lookup* = set`not-member-union-left-preserves-lookup*.
%abbrev set`fresh-join-left-preserves-lookup-converse = set`not-member-union-left-preserves-lookup-converse.
%abbrev set`fresh-join-left-preserves-lookup-converse/L = set`not-member-union-left-preserves-lookup-converse/L.
%abbrev set`join-left-affects-lookup = set`union-left-affects-lookup.
%abbrev set`join-left-affects-lookup/L = set`union-left-affects-lookup/L.
%abbrev set`fresh-join-right-preserves-lookup = set`not-member-union-right-preserves-lookup.
%abbrev set`fresh-join-right-preserves-lookup* = set`not-member-union-right-preserves-lookup*.
%abbrev set`fresh-join-right-preserves-lookup-converse = set`not-member-union-right-preserves-lookup-converse.
%abbrev set`fresh-join-right-preserves-lookup-converse/L = set`not-member-union-right-preserves-lookup-converse/L.
%abbrev set`join-right-affects-lookup = set`union-right-affects-lookup.
%abbrev set`join-right-affects-lookup/L = set`union-right-affects-lookup/L.
%abbrev set`join-preserves-fresh-converse* = set`union-preserves-not-member-converse*.
%abbrev set`join-preserves-fresh-converse/L = set`union-preserves-not-member-converse/L.
%abbrev set`disjoint-join-cross-comparable = set`disjoint-union-cross-comparable.
%abbrev set`disjoint-join-left-preserves-lookup* = set`disjoint-union-left-preserves-lookup*.
%abbrev set`disjoint-join-left-preserves-lookup*/L = set`disjoint-union-left-preserves-lookup*/L.
%abbrev set`disjoint-join-right-preserves-lookup* = set`disjoint-union-right-preserves-lookup*.
%abbrev set`disjoint-join-right-preserves-lookup*/L = set`disjoint-union-right-preserves-lookup*/L.
%abbrev set`fresh-update-implies-unit-join = set`not-member-update-implies-unit-union.
%abbrev set`lookup-update-left-implies-unit-join = set`lookup-update-left-implies-unit-union.
%abbrev set`lookup-update-right-implies-unit-join = set`lookup-update-right-implies-unit-union.
%abbrev set`fresh-unit-join-implies-update = set`not-member-unit-union-implies-update.
%abbrev set`join-commute-update-left* = set`union-commute-update-left*.
%abbrev set`join-commute-update-left = set`union-commute-update-left.
%abbrev set`join-commute-update-right* = set`union-commute-update-right*.
%abbrev set`join-commute-update-right = set`union-commute-update-right.
%abbrev set`join-commute-update* = set`union-commute-update*.
%abbrev set`join-commute-update = set`union-commute-update.
%abbrev set`join-preserves-fresh-update-left = set`union-preserves-not-member-update-left.
%abbrev set`fresh-update-left-preserves-join-converse = set`not-member-update-left-preserves-union-converse.
%abbrev set`fresh-update-left-preserves-join-converse/L = set`not-member-update-left-preserves-union-converse/L.
%abbrev set`fresh-update-left-preserves-join-converse* = set`not-member-update-left-preserves-union-converse*.
%abbrev set`fresh-update-right-preserves-join-converse = set`not-member-update-right-preserves-union-converse.
%abbrev set`fresh-update-right-preserves-join-converse/L = set`not-member-update-right-preserves-union-converse/L.
%abbrev set`fresh-update-right-preserves-join-converse* = set`not-member-update-right-preserves-union-converse*.
%abbrev set`fresh-update-preserves-join-converse = set`not-member-update-preserves-union-converse.
%abbrev set`fresh-update-preserves-join-converse/L = set`not-member-update-preserves-union-converse/L.
%abbrev set`fresh-update-preserves-join-converse* = set`not-member-update-preserves-union-converse*.
%abbrev set`bound-commute-join* = set`bound-commute-union*.
%abbrev set`size-commute-disjoint-join* = set`size-commute-disjoint-union*.
%abbrev set`join-implies-leq* = set`union-implies-leq*.
%abbrev set`join-implies-leq = set`union-implies-leq.
%abbrev set`join-is-lub = set`union-is-lub.
%abbrev set`join-idempotent = set`union-idempotent.
%abbrev set`leq-implies-join = set`leq-implies-union.
%abbrev set`disjoint-leq-implies-join-leq* = set`disjoint-leq-implies-union-leq*.
%abbrev set`join-left-preserves-leq* = set`union-left-preserves-leq*.
%abbrev set`join-left-preserves-leq = set`union-left-preserves-leq.
%abbrev set`join-right-preserves-leq* = set`union-right-preserves-leq*.
%abbrev set`join-right-preserves-leq = set`union-right-preserves-leq.
%abbrev set`join-preserves-leq* = set`union-preserves-leq*.
%abbrev set`join-preserves-leq = set`union-preserves-leq.
%abbrev set`disjoint-join-left-preserves-leq-converse = set`disjoint-union-left-preserves-leq-converse.
%abbrev set`disjoint-join-right-preserves-leq-converse = set`disjoint-union-right-preserves-leq-converse.
%abbrev set`intersection-right-preserves-fresh = set`intersection-right-preserves-not-member.
%abbrev set`intersection-right-preserves-fresh/L = set`intersection-right-preserves-not-member/L.
%abbrev set`intersection-left-preserves-fresh = set`intersection-left-preserves-not-member.
%abbrev set`intersection-left-preserves-fresh/L = set`intersection-left-preserves-not-member/L.
%abbrev set`intersection-right-distributes-over-join = set`intersection-right-distributes-over-union.
%abbrev set`intersection-right-distributes-over-join* = set`intersection-right-distributes-over-union*.
%abbrev set`intersection-left-distributes-over-join* = set`intersection-left-distributes-over-union*.
%abbrev set`intersection-left-distributes-over-join = set`intersection-left-distributes-over-union.
%abbrev set`intersection-right-factors-over-join* = set`intersection-right-factors-over-union*.
%abbrev set`intersection-left-factors-over-join* = set`intersection-left-factors-over-union*.
%abbrev set`gt-max-implies-fresh = set`gt-max-implies-not-member.
%abbrev set`min-gt-implies-fresh = set`min-gt-implies-not-member.
%abbrev set`max-commute-join* = set`max-commute-union*.
%abbrev set`min-commute-join* = set`min-commute-union*.
%abbrev set`join/= = set`union/=.
%abbrev set`fresh-member-implies-ne = set`not-member-member-implies-ne.
%abbrev set`fresh-member-not-equal = set`not-member-member-not-equal.
%abbrev set`disjoint-member-implies-fresh = set`disjoint-member-implies-not-member.
%abbrev set`fresh-join-left-preserves-member-converse = set`not-member-union-left-preserves-member-converse.
%abbrev set`fresh-join-right-preserves-member-converse = set`not-member-union-right-preserves-member-converse.
%abbrev set`member-implies-fresh-add = set`member-implies-not-member-add.
%abbrev set`add-preserves-fresh = set`add-preserves-not-member.
%abbrev set`add-preserves-fresh-converse = set`add-preserves-not-member-converse.
%abbrev set`fresh-add-commutes-converse* = set`not-member-add-commutes-converse*.
%abbrev set`fresh-add-preserves-disjoint = set`not-member-add-preserves-disjoint.
%abbrev set`fresh-add-increases-size = set`not-member-add-increases-size.
%abbrev set`fresh-add-increases-size-converse = set`not-member-add-increases-size-converse.
%abbrev set`fresh-add-cancels = set`not-member-add-cancels.
%abbrev set`fresh-add-preserves-leq-converse = set`not-member-add-preserves-leq-converse.
%abbrev set`fresh-add2-preserves-leq-converse = set`not-member-add2-preserves-leq-converse.
%abbrev set`member-fresh-contradiction = set`member-not-member-contradiction.
%abbrev set`join-right-distributes-over-intersection = set`union-right-distributes-over-intersection.
%abbrev set`join-right-distributes-over-intersection* = set`union-right-distributes-over-intersection*.
%abbrev set`join-left-distributes-over-intersection* = set`union-left-distributes-over-intersection*.
%abbrev set`join-left-distributes-over-intersection = set`union-left-distributes-over-intersection.
%abbrev set`join-right-factors-over-intersection = set`union-right-factors-over-intersection.
%abbrev set`join-right-factors-over-intersection* = set`union-right-factors-over-intersection*.
%abbrev set`join-left-factors-over-intersection = set`union-left-factors-over-intersection.
%abbrev set`join-left-factors-over-intersection* = set`union-left-factors-over-intersection*.
%abbrev set`leq-join-implies-leq-intersection-join = set`leq-union-implies-leq-intersection-union.
%abbrev set`leq-join-disjoint-implies-leq = set`leq-union-disjoint-implies-leq.
%abbrev set`add-implies-unit-join = set`add-implies-unit-union.
%abbrev set`add-implies-unit-join/L = set`add-implies-unit-union/L.
%abbrev set`unit-join-implies-add = set`unit-union-implies-add.
%abbrev set`unit-join-implies-add/L = set`unit-union-implies-add/L.
%abbrev set`join-left-preserves-member* = set`union-left-preserves-member*.
%abbrev set`join-right-preserves-member* = set`union-right-preserves-member*.
%abbrev set`add-member-right-preserves-join = set`add-member-right-preserves-union.
%abbrev set`join-preserves-disjoint-converse = set`union-preserves-disjoint-converse.
%abbrev set`join-preserves-disjoint-converse/L = set`union-preserves-disjoint-converse/L.
%abbrev set`join-intersection-size = set`union-intersection-size.
%abbrev set`remove-implies-leq-join = set`remove-implies-leq-union.
%abbrev set`disjoint-join-implies-remove = set`disjoint-union-implies-remove.
%abbrev set`remove-associates-join* = set`remove-associates-union*.
%abbrev set`remove-associates-join = set`remove-associates-union.
%abbrev set`remove-associates-join-converse* = set`remove-associates-union-converse*.
%abbrev set`remove-associates-join-converse = set`remove-associates-union-converse.
%abbrev set`remove-subset-implies-join = set`remove-subset-implies-union.
%abbrev set`join-right-commutes-remove* = set`union-right-commutes-remove*.
%abbrev set`join-right-commutes-remove = set`union-right-commutes-remove.
%abbrev set`join-right-preserves-remove = set`union-right-preserves-remove.
%abbrev set`remove-right-distributes-over-join* = set`remove-right-distributes-over-union*.
%abbrev set`remove-right-distributes-over-join/L = set`remove-right-distributes-over-union/L.
%abbrev set`remove-right-distributes-over-join/L/< = set`remove-right-distributes-over-union/L/<.
%abbrev set`remove-right-distributes-over-join = set`remove-right-distributes-over-union.
%abbrev set`fresh-add-implies-remove = set`not-member-add-implies-remove.
%%% Converting a set of (obj,fld)s to a capmap

cap-id : nat -> unit -> cap -> cap -> type.

cap-id/ : cap-id N _ X X.


%%% Theorems

%theorem cap-id-eq
  : forall* {N} {U} {X1} {X2}
    forall {ID: cap-id N U X1 X2}
    exists {E: cap`eq X1 X2}
    true.

- : cap-id-eq cap-id/ cap`eq/.

%worlds () (cap-id-eq _ _).
%total {} (cap-id-eq _ _).


%theorem cap-id-total*
  : forall {N} {U} {X1}
    exists {X2} {SE: cap-id N U X1 X2}
    true.

- : cap-id-total* _ _ _ _ cap-id/.

%worlds () (cap-id-total* _ _ _ _ _).
%total {} (cap-id-total* _ _ _ _ _).

%abbrev cap-id-total = cap-id-total* _ _ _ _.


%theorem cap-id-unique
  : forall* {N1} {U1} {X1} {Y1} {N2} {U2} {X2} {Y2}
    forall {SE1: cap-id N1 U1 X1 Y1}
    {SE2: cap-id N2 U2 X2 Y2}
    {E: nat`eq N1 N2} {E: unit`eq U1 U2}
    {E: cap`eq X1 X2}
    exists {E: cap`eq Y1 Y2}
    true.

- : cap-id-unique S1 S2 nat`eq/ unit`eq/ cap`eq/ cap`eq/.

%worlds () (cap-id-unique _ _ _ _ _ _).
%total {} (cap-id-unique _ _ _ _ _ _).


%theorem cap-id-right-cancels
  : forall* {N} {U1} {U2} {X1} {Y1} {X2} {Y2}
    forall {SE1: cap-id N U1 X1 Y1}
    {SE2: cap-id N U2 X2 Y2}
    {E: cap`eq X1 X2} {E: cap`eq Y1 Y2}
    exists {E: unit`eq U1 U2}
    true.

- : cap-id-right-cancels cap-id/ cap-id/ _ _ unit`eq/.

%worlds () (cap-id-right-cancels _ _ _ _ _).
%total {} (cap-id-right-cancels _ _ _ _ _).


%theorem cap-id-right-preserves-leq*
  : forall* {N} {U1} {U2} {X} {Y1} {Y2}
    forall {U1<=U2: unit`eq U1 U2}
    {SE1: cap-id N U1 X Y1}
    {SE2: cap-id N U2 X Y2}
    exists {Y1<=Y2: cap`leq Y1 Y2}
    true.

- : cap-id-right-preserves-leq* unit`eq/ cap-id/ cap-id/ Y1<=Y2
    <- cap`leq-reflexive _ Y1<=Y2.

%worlds () (cap-id-right-preserves-leq* _ _ _ _).
%total {} (cap-id-right-preserves-leq* _ _ _ _).


%theorem cap-id-left-preserves-leq*
  : forall* {N} {U} {X1} {X2} {Y1} {Y2}
    forall {X1<=X2: cap`leq X1 X2}
    {T1: cap-id N U X1 Y1}
    {T2: cap-id N U X2 Y2}
    exists {Y1<=Y2: cap`leq Y1 Y2}
    true.

- : cap-id-left-preserves-leq* L cap-id/ cap-id/ L.

%worlds () (cap-id-left-preserves-leq* _ _ _ _).
%total {} (cap-id-left-preserves-leq* _ _ _ _).

% map-cap-id between different types



set2capmap : set -> cap -> capmap -> type.

set2capmap/0 : set2capmap set/0 S capmap/0.

set2capmap/U :
 set2capmap M1 X M2 ->
 cap-id N D1 X D2 ->
        set`fresh M1 N ->
 set`update M1 N D1 M1P ->
 capmap`update M2 N D2 M2P ->
    set2capmap M1P X M2P.




%%%% Theorems



%%% Extra Theorems about cap-id


%theorem cap-id-respects-eq :
 forall* {N1} {D1} {X1} {D1P}
  {N2} {D2} {X2} {D2P}
 forall {R1: cap-id N1 D1 X1 D1P}
  {EN: nat`eq N1 N2}
  {ED: unit`eq D1 D2}
  {EX: cap`eq X1 X2}
  {ED: cap`eq D1P D2P}
 exists {R2: cap-id N2 D2 X2 D2P}
 true.

- : cap-id-respects-eq R _ _ _ _ R.

%worlds () (cap-id-respects-eq _ _ _ _ _ _).
%total { } (cap-id-respects-eq _ _ _ _ _ _).



%%% Theorems about set2capmap


%theorem false-implies-set2capmap :
 forall* {M} {X} {MP}
 forall {F: void}
 exists {A: set2capmap M X MP}
 true.

%worlds () (false-implies-set2capmap _ _).
%total { } (false-implies-set2capmap _ _).


%theorem set2capmap-respects-eq :
 forall* {M1} {X1} {M2} {X2} {M1P} {M2P}
 forall {A1: set2capmap M1 X1 M1P}
  {ME: set`eq M1 M2}
  {XE: cap`eq X1 X2}
  {EP: capmap`eq M1P M2P}
 exists {A2: set2capmap M2 X2 M2P}
 true.

- : set2capmap-respects-eq A _ _ _ A.

%worlds () (set2capmap-respects-eq _ _ _ _ _).
%total { } (set2capmap-respects-eq _ _ _ _ _).


%theorem set2capmap/U-inversion :
 forall* {M1} {M2} {X} {N} {D} {M2P}
 forall {A2: set2capmap M2 X M2P}
  {F: set`fresh M1 N}
  {U: set`update M1 N D M2}
 exists {M1P} {DP}
  {A1: set2capmap M1 X M1P}
  {R: cap-id N D X DP}
  {U: capmap`update M1P N DP M2P}
 true.

%theorem set2capmap/U-inversion/L :
 forall* {N0} {D0} {M0} {X} {N} {D} {B} {M1} {M2} {M0P} {D0P} {M2P}
 forall {A0: set2capmap M0 X M0P}
  {R1: cap-id N0 D0 X D0P}
  {F0: set`fresh M0 N0}
  {U0: set`update M0 N0 D0 M2}
  {UP: capmap`update M0P N0 D0P M2P}
  {F1: set`fresh M1 N}
  {U1: set`update M1 N D M2}
  {EQ?: nat`eq? N N0 B}
 exists {M1P} {DP}
  {A1: set2capmap M1 X M1P}
  {R: cap-id N D X DP}
  {U: capmap`update M1P N DP M2P}
 true.

- : set2capmap/U-inversion/L A0 R0 F0 U0 U0P F1 U1 nat`eq?/yes _ _
 A1 R1 U0P
    <- set`fresh-update-cancels F0 U0 F1 U1 (nat`eq/:nat`eq N N) set`eq/ D0=D1 M0=M1
    <- set2capmap-respects-eq A0 M0=M1 cap`eq/ capmap`eq/ A1
    <- cap-id-respects-eq R0 (nat`eq/: nat`eq N N) D0=D1 cap`eq/ cap`eq/ R1.

- : set2capmap/U-inversion/L A0 R0 F0 U0 U0P F1 U1 (nat`eq?/no N<>N1) _ _
 (set2capmap/U A2 R0 F3 U3 U3P) R1 U1P
    <- set`update-commutes-converse U1 U0 N<>N1 _ U3 U2
    <- set`update-preserves-fresh-converse F1 U3 F2
    <- set`update-preserves-fresh-converse F0 U2 F3
    <- set2capmap/U-inversion A0 F2 U2 _ _ A2 R1 U2P
    <- capmap`update-commutes U2P U0P N<>N1 _ U3P U1P.

- : set2capmap/U-inversion (set2capmap/U A0 R0 F0 U0 U0P) F U _ _ A1 R U1P
    <- nat`eq?-total EQ?
    <- set2capmap/U-inversion/L A0 R0 F0 U0 U0P F U EQ? _ _ A1 R U1P.

%worlds () (set2capmap/U-inversion _ _ _ _ _ _ _ _)
           (set2capmap/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A B)
    (set2capmap/U-inversion A _ _ _ _ _ _ _)
           (set2capmap/U-inversion/L B _ _ _ _ _ _ _ _ _ _ _ _).


%theorem set2capmap-lookup-implies-cap-id-lookup :
 forall* {M} {X} {N} {D} {MP}
 forall {A: set2capmap M X MP}
  {L: set`lookup M N D}
 exists {DP}
  {R: cap-id N D X DP}
  {L: capmap`lookup MP N DP}
 true.

- : set2capmap-lookup-implies-cap-id-lookup A L DP T LP
    <- set`lookup-implies-fresh-update L _ F U
    <- set2capmap/U-inversion A F U _ _ AP T UP
    <- capmap`update-implies-lookup UP LP.

%worlds () (set2capmap-lookup-implies-cap-id-lookup _ _ _ _ _).
%total { } (set2capmap-lookup-implies-cap-id-lookup _ _ _ _ _).


%theorem set2capmap-preserves-fresh:
 forall* {M} {X} {N} {MP}
 forall {F: set`fresh M N}
  {A: set2capmap M X MP}
 exists {F: capmap`fresh MP N}
 true.

- : set2capmap-preserves-fresh _ set2capmap/0 capmap`fresh/0.

- : set2capmap-preserves-fresh F1 (set2capmap/U A _ _ U UP) F4
    <- set`update-implies-lookup U L
    <- set`fresh-lookup-not-equal F1 L NE
    <- set`update-preserves-fresh-converse F1 U F2
    <- set2capmap-preserves-fresh F2 A F3
    <- capmap`update-preserves-fresh F3 UP NE F4.

%worlds () (set2capmap-preserves-fresh _ _ _).
%total (A) (set2capmap-preserves-fresh _ A _).


%theorem set2capmap-preserves-fresh-converse:
 forall* {M} {X} {N} {MP}
 forall {F: capmap`fresh MP N}
  {A: set2capmap M X MP}
 exists {F: set`fresh M N}
 true.

- : set2capmap-preserves-fresh-converse _ set2capmap/0 set`fresh/0.

- : set2capmap-preserves-fresh-converse F1 (set2capmap/U A _ _ U UP) F4
    <- capmap`update-implies-lookup UP L
    <- capmap`fresh-lookup-not-equal F1 L NE
    <- capmap`update-preserves-fresh-converse F1 UP F2
    <- set2capmap-preserves-fresh-converse F2 A F3
    <- set`update-preserves-fresh F3 U NE F4.

%worlds () (set2capmap-preserves-fresh-converse _ _ _).
%total (A) (set2capmap-preserves-fresh-converse _ A _).


%theorem set2capmap-lookup-implies-cap-id-lookup-converse :
 forall* {M} {X} {N} {DP} {MP}
 forall {A: set2capmap M X MP}
  {L: capmap`lookup MP N DP}
 exists {D}
  {R: cap-id N D X DP}
  {L: set`lookup M N D}
 true.

%theorem set2capmap-lookup-implies-cap-id-lookup-converse/L :
 forall* {M} {X} {N} {DP} {MP} {B}
 forall {A: set2capmap M X MP}
  {L: capmap`lookup MP N DP}
  {D?: set`domain? M N B}
 exists {D}
  {R: cap-id N D X DP}
  {L: set`lookup M N D}
 true.

- : set2capmap-lookup-implies-cap-id-lookup-converse/L
 A LP (set`domain?/in L) _ T L
    <- set`lookup-implies-fresh-update L _ F U
    <- capmap`lookup-implies-fresh-update LP _ FP UP
    <- set2capmap/U-inversion A F U _ _ _ T1 UP1
    <- capmap`update-implies-lookup UP1 LP1
    <- capmap`lookup-unique LP1 LP capmap`eq/ (nat`eq/:nat`eq N N) DP1=DP
    <- cap-id-respects-eq T1 (nat`eq/:nat`eq N N) unit`eq/ cap`eq/ DP1=DP T.

%theorem set2capmap-lookup-implies-cap-id-lookup-converse/F :
 forall* {M} {N} {DP}
 forall {X} {F: void}
 exists {D} {R: cap-id N D X DP}
  {L: set`lookup M N D}
 true.

%worlds () (set2capmap-lookup-implies-cap-id-lookup-converse/F _ _ _ _ _).
%total { } (set2capmap-lookup-implies-cap-id-lookup-converse/F _ _ _ _ _).

- : set2capmap-lookup-implies-cap-id-lookup-converse/L
 (A:set2capmap M X MP) (LP:capmap`lookup MP N DP) (set`domain?/out F) D T L
    <- set2capmap-preserves-fresh F A FP
    <- capmap`fresh-lookup-not-equal FP LP N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- set2capmap-lookup-implies-cap-id-lookup-converse/F X V D T L.

%worlds () (set2capmap-lookup-implies-cap-id-lookup-converse/L _ _ _ _ _ _).
%total { } (set2capmap-lookup-implies-cap-id-lookup-converse/L _ _ _ _ _ _).

- : set2capmap-lookup-implies-cap-id-lookup-converse A LP DP T L
    <- set`domain?-total D?
    <- set2capmap-lookup-implies-cap-id-lookup-converse/L A LP D? DP T L.

%worlds () (set2capmap-lookup-implies-cap-id-lookup-converse _ _ _ _ _).
%total { } (set2capmap-lookup-implies-cap-id-lookup-converse _ _ _ _ _).



%theorem set2capmap-preserves-domain?
  : forall* {M} {N} {B} {X} {MP}
    forall {D1: set`domain? M N B}
  {A: set2capmap M X MP}
    exists {D2: capmap`domain? MP N B}
    true.

- : set2capmap-preserves-domain? (set`domain?/in L) A (capmap`domain?/in LP)
    <- set`lookup-implies-fresh-update L _ F U
    <- set2capmap/U-inversion A F U _ _ _ _ UP
    <- capmap`update-implies-lookup UP LP.

- : set2capmap-preserves-domain? (set`domain?/out F) A (capmap`domain?/out FP)
    <- set2capmap-preserves-fresh F A FP.

%worlds () (set2capmap-preserves-domain? _ _ _).
%total { } (set2capmap-preserves-domain? _ _ _).


%theorem set2capmap-preserves-domain?-converse
 : forall* {M} {N} {B} {X} {MP}
   forall {D1: capmap`domain? MP N B}
   {A: set2capmap M X MP}
   exists {D2: set`domain? M N B}
   true.

- : set2capmap-preserves-domain?-converse (capmap`domain?/in LP) A (set`domain?/in L)
    <- set2capmap-lookup-implies-cap-id-lookup-converse A LP _ _ L.

- : set2capmap-preserves-domain?-converse (capmap`domain?/out FP) A (set`domain?/out F)
    <- set2capmap-preserves-fresh-converse FP A F.

%worlds () (set2capmap-preserves-domain?-converse _ _ _).
%total {} (set2capmap-preserves-domain?-converse _ _ _).


%theorem update-preserves-set2capmap :
 forall* {M1} {N} {D} {M2} {M1P} {M2P} {DP} {X}
 forall {A1: set2capmap M1 X M1P}
  {T: cap-id N D X DP}
  {UD: set`update M1 N D M2}
  {UDP:capmap`update M1P N DP M2P}
 exists {A2: set2capmap M2 X M2P}
 true.

%theorem update-preserves-set2capmap/L :
 forall* {M1} {N} {D} {M2} {M1P} {M2P} {DP} {B} {X}
 forall {A1: set2capmap M1 X M1P}
  {R: cap-id N D X DP}
  {D?: set`domain? M1 N B}
  {UD: set`update M1 N D M2}
  {UDP:capmap`update M1P N DP M2P}
 exists {A2: set2capmap M2 X M2P}
 true.

- : update-preserves-set2capmap/L
    A T (set`domain?/out F) U UP (set2capmap/U A T F U UP).

- : update-preserves-set2capmap/L
    A T (set`domain?/in L) U UP (set2capmap/U A1 T F U3 UP3)
    <- set`lookup-implies-fresh-update L _ F U1
    <- set2capmap/U-inversion A F U1 _ _ A1 TX U2
    <- set`update-overwrites U1 U nat`eq/ U3
    <- capmap`update-overwrites U2 UP nat`eq/ UP3.

%worlds () (update-preserves-set2capmap/L _ _ _ _ _ _).
%total { } (update-preserves-set2capmap/L _ _ _ _ _ _).

- : update-preserves-set2capmap A T U UP AP
    <- set`domain?-total D?
    <- update-preserves-set2capmap/L A T D? U UP AP.

%worlds () (update-preserves-set2capmap _ _ _ _ _).
%total { } (update-preserves-set2capmap _ _ _ _ _).


%theorem set2capmap/UP-inversion
  : forall* {M1P} {M2} {X} {N} {DP} {M2P}
    forall {A2: set2capmap M2 X M2P}
  {F: capmap`fresh M1P N}
  {U: capmap`update M1P N DP M2P}
    exists {M1} {D}
  {A1: set2capmap M1 X M1P}
  {R: cap-id N D X DP}
  {U: set`update M1 N D M2}
    true.

- : set2capmap/UP-inversion A FP UP _ _ A1 T U
    <- capmap`update-implies-lookup UP LP
    <- set2capmap-lookup-implies-cap-id-lookup-converse A LP _ _ L
    <- set`lookup-implies-fresh-update L _ F U
    <- set2capmap/U-inversion A F U _ _ A2 T2 UP2
    <- set2capmap-preserves-fresh F A2 FP2
    <- capmap`fresh-update-cancels FP2 UP2 FP UP (nat`eq/:nat`eq N N) capmap`eq/ DP2=DP M2P=MP
    <- cap-id-respects-eq T2 (nat`eq/:nat`eq N N) unit`eq/ cap`eq/ DP2=DP T
    <- set2capmap-respects-eq A2 set`eq/ cap`eq/ M2P=MP A1.

%worlds () (set2capmap/UP-inversion _ _ _ _ _ _ _ _).
%total { } (set2capmap/UP-inversion _ _ _ _ _ _ _ _).


%theorem set2capmap-preserves-size :
 forall* {M1} {N} {X} {M2}
 forall {Z1: set`size M1 N}
  {A: set2capmap M1 X M2}
 exists {Z2: capmap`size M2 N}
 true.

- : set2capmap-preserves-size set`size/0 set2capmap/0 capmap`size/0.

- : set2capmap-preserves-size Z (set2capmap/U A T F U UP) ZP
    <- set`fresh-update-increases-size-converse Z F U Z1
    <- set2capmap-preserves-size Z1 A ZP1
    <- set2capmap-preserves-fresh F A FP
    <- capmap`fresh-update-increases-size ZP1 FP UP ZP.

%worlds () (set2capmap-preserves-size _ _ _).
%total (A) (set2capmap-preserves-size _ A _).


%theorem set2capmap-preserves-size-converse :
 forall* {M1} {N} {X} {M2}
 forall {Z1: capmap`size M2 N}
  {A: set2capmap M1 X M2}
 exists {Z2: set`size M1 N}
 true.

- : set2capmap-preserves-size-converse capmap`size/0 set2capmap/0 set`size/0.

- : set2capmap-preserves-size-converse ZP (set2capmap/U A T F U UP) Z
    <- set2capmap-preserves-fresh F A FP
    <- capmap`fresh-update-increases-size-converse ZP FP UP ZP1
    <- set2capmap-preserves-size-converse ZP1 A Z1
    <- set`fresh-update-increases-size Z1 F U Z.

%worlds () (set2capmap-preserves-size-converse _ _ _).
%total (A) (set2capmap-preserves-size-converse _ A _).


%theorem set2capmap-total* :
 forall {M} {X}
 exists {MP}
  {A: set2capmap M X MP}
 true.

%abbrev set2capmap-total = set2capmap-total* _ _ _.

%theorem set2capmap-total/L :
 forall* {M}
 forall {N} {Z: set`size M N}
  {X}
 exists {MP}
  {A: set2capmap M X MP}
 true.

- : set2capmap-total/L _ _ _ _ set2capmap/0.

- : set2capmap-total/L _ Z _ _ (set2capmap/U A1 T F U UP)
    <- set`lookup-implies-fresh-update (set`lookup/= (nat`eq/:nat`eq N N)) _ F U
    <- set`fresh-update-increases-size-converse Z F U Z1
    <- set2capmap-total/L _ Z1 _ _ A1
    <- cap-id-total T
    <- capmap`update-total UP.

%worlds () (set2capmap-total/L _ _ _ _ _).
%total (N) (set2capmap-total/L N _ _ _ _).

- : set2capmap-total A
    <- set`size-total Z
    <- set2capmap-total/L _ Z _ _ A.

%worlds () (set2capmap-total* _ _ _ _).
%total { } (set2capmap-total* _ _ _ _).


%theorem set2capmap-unique :
 forall* {M1} {X1} {M2} {X2} {M1P} {M2P}
 forall {A1: set2capmap M1 X1 M1P}
  {A2: set2capmap M2 X2 M2P}
  {ME: set`eq M1 M2}
  {XE: cap`eq X1 X2}
 exists {EP: capmap`eq M1P M2P}
 true.

%theorem set2capmap-unique/L :
 forall* {M} {X} {M1P} {M2P}
 forall {N} {Z: set`size M N}
  {A1: set2capmap M X M1P}
  {A2: set2capmap M X M2P}
 exists {EP: capmap`eq M1P M2P}
 true.

- : set2capmap-unique/L _ _ set2capmap/0 set2capmap/0 capmap`eq/.

- : set2capmap-unique/L _ Z A1 A2 MEQ
    <- set`lookup-implies-fresh-update (set`lookup/= nat`eq/) _ F U
    <- set`fresh-update-increases-size-converse Z F U ZR
    <- set2capmap/U-inversion A1 F U _ _ A1R T1 U1
    <- set2capmap/U-inversion A2 F U _ _ A2R T2 U2
    <- set2capmap-unique/L _ ZR A1R A2R MEQR
    <- cap-id-unique T1 T2 nat`eq/ unit`eq/ cap`eq/ DEQ
    <- capmap`update-unique U1 U2 MEQR nat`eq/ DEQ MEQ.

%worlds () (set2capmap-unique/L _ _ _ _ _).
%total (N) (set2capmap-unique/L N _ _ _ _).

- : set2capmap-unique A1 A2 _ _ MEQ
    <- set`size-total Z
    <- set2capmap-unique/L _ Z A1 A2 MEQ.

%worlds () (set2capmap-unique _ _ _ _ _).
%total { } (set2capmap-unique _ _ _ _ _).



%theorem set2capmap-right-cancels :
 forall* {M1} {X1} {M1P}
  {M2} {X2} {M2P}
 forall {A1: set2capmap M1 X1 M1P}
  {A2: set2capmap M2 X2 M2P}
  {EX: cap`eq X1 X2}
  {EP: capmap`eq M1P M2P}
 exists {E: set`eq M1 M2}
 true.

- : set2capmap-right-cancels set2capmap/0 set2capmap/0 _ _ set`eq/.

- : set2capmap-right-cancels
    (set2capmap/U A1R T1 F1 U1 UP1) A2 XEQ capmap`eq/ M1=M2
    <- set2capmap-preserves-fresh F1 A1R FP1
    <- set2capmap/UP-inversion A2 FP1 UP1 _ _ A2R T2 U2
    <- set2capmap-right-cancels A1R A2R XEQ capmap`eq/ M1R=M2R
    <- cap-id-right-cancels T1 T2 XEQ cap`eq/ D1=D2
    <- set`update-unique U1 U2 M1R=M2R nat`eq/ D1=D2 M1=M2.

%worlds () (set2capmap-right-cancels _ _ _ _ _).
%total (A) (set2capmap-right-cancels A _ _ _ _).



%theorem set2capmap-right-preserves-leq* :
 forall* {M1} {X} {M1P} {M2} {M2P}
 forall {L: set`leq M1 M2}
  {A1: set2capmap M1 X M1P}
  {A2: set2capmap M2 X M2P}
 exists {LP: capmap`leq M1P M2P}
 true.

- : set2capmap-right-preserves-leq* _ set2capmap/0 _ capmap`leq/0.

- : set2capmap-right-preserves-leq* M1<=M2
    (set2capmap/U A1R T1 F1 U1 U1P) A2 M1P<=M2P
    <- set`update-implies-lookup U1 L1
    <- set`lookup-respects-leq L1 M1<=M2 _ L2 _
    <- set`lookup-implies-fresh-update L2 _ F2 U2
    <- set2capmap/U-inversion A2 F2 U2 _ _ A2R T2 U2P
    <- set`fresh-update-preserves-leq-converse M1<=M2 F1 U1 F2 U2 M1R<=M2R D1<=D2
    <- set2capmap-right-preserves-leq* M1R<=M2R A1R A2R M1PR<=M2PR
    <- cap-id-right-preserves-leq* D1<=D2 T1 T2 D1P<=D2P
    <- capmap`update-preserves-leq* M1PR<=M2PR D1P<=D2P U1P U2P M1P<=M2P.

%worlds () (set2capmap-right-preserves-leq* _ _ _ _).
%total (A) (set2capmap-right-preserves-leq* _ A _ _).


%theorem set2capmap-left-preserves-leq* :
 forall* {M} {X1} {M1P} {X2} {M2P}
 forall {L: cap`leq X1 X2}
  {A1: set2capmap M X1 M1P}
  {A2: set2capmap M X2 M2P}
 exists {LP: capmap`leq M1P M2P}
 true.

- : set2capmap-left-preserves-leq* _ set2capmap/0 _ capmap`leq/0.

- : set2capmap-left-preserves-leq* X1<=X2
 (set2capmap/U A1R T1 F U U1P) A2 M1P<=M2P
    <- set2capmap/U-inversion A2 F U _ _ A2R T2 U2P
    <- set2capmap-left-preserves-leq* X1<=X2 A1R A2R M1PR<=M2PR
    <- cap-id-left-preserves-leq* X1<=X2 T1 T2 D1P<=D2P
    <- capmap`update-preserves-leq* M1PR<=M2PR D1P<=D2P U1P U2P M1P<=M2P.

%worlds () (set2capmap-left-preserves-leq* _ _ _ _).
%total (A) (set2capmap-left-preserves-leq* _ A _ _).


%theorem set2capmap-preserves-leq*
 : forall* {M1} {X1} {M1P} {M2} {X2} {M2P}
    forall {LM: set`leq M1 M2}
    {LX: cap`leq X1 X2}
  {A1: set2capmap M1 X1 M1P}
  {A2: set2capmap M2 X2 M2P}
    exists {LP: capmap`leq M1P M2P}
    true.

- : set2capmap-preserves-leq* M1<=M2 X1<=X2 A1 A2 M1P<=M2P
    <- set2capmap-total AH
    <- set2capmap-right-preserves-leq* M1<=M2 A1 AH M1P<=MH
    <- set2capmap-left-preserves-leq* X1<=X2 AH A2 MH<=M2P
    <- capmap`leq-transitive M1P<=MH MH<=M2P M1P<=M2P.

%worlds () (set2capmap-preserves-leq* _ _ _ _ _).
%total {} (set2capmap-preserves-leq* _ _ _ _ _).



%theorem fresh-update-preserves-set2capmap-converse
  : forall* {M} {G} {GP} {X} {F} {S}
    forall {T: set2capmap G X M}
    {FS: set`fresh GP F} {U: set`update GP F S G}
    exists {MP} {D} {TP: cap-id F S X D}
    {FS: capmap`fresh MP F} {U: capmap`update MP F D M}
    {T: set2capmap GP X MP}
    true.

%theorem fresh-update-preserves-set2capmap-converse/L
  : forall* {M} {MS} {G} {GP} {GS} {X} {F1} {F2} {B} {D1} {S1} {S2}
    forall {T: set2capmap GS X MS} {TP: cap-id F1 S1 X D1}
    {FS: set`fresh GS F1} {U: set`update GS F1 S1 G}
    {U: capmap`update MS F1 D1 M}
    {FS: set`fresh GP F2} {U: set`update GP F2 S2 G}
    {EQ?: nat`eq? F1 F2 B}
    exists {MP} {D2} {TP: cap-id F2 S2 X D2}
    {U: capmap`update MP F2 D2 M} {FS: capmap`fresh MP F2} {T: set2capmap GP X MP}
    true.

- : fresh-update-preserves-set2capmap-converse/L
    SS=>MS S1=>D1 F1!<SS SS+F1=S MS+F1=M F2!<SP SP+F2=S (nat`eq?/no F1<>F2)
    MP D2 S2=>D2 MP+F2=M F2!<MP (set2capmap/U SK=>MK S1=>D1 F1!<SK SK+F1=SP MK+F1=MP)
    <- set`update-commutes-converse SS+F1=S SP+F2=S F1<>F2 SK SK+F2=SS SK+F1=SP
    <- set`update-preserves-fresh-converse F2!<SP SK+F1=SP F2!<SK
    <- fresh-update-preserves-set2capmap-converse
      SS=>MS F2!<SK SK+F2=SS MK D2 S2=>D2 F2!<MK MK+F2=MS SK=>MK
    <- nat`ne-symmetric F1<>F2 F2<>F1
    <- capmap`update-commutes MK+F2=MS MS+F1=M F2<>F1 MP MK+F1=MP MP+F2=M
    <- capmap`update-preserves-fresh F2!<MK MK+F1=MP F2<>F1 F2!<MP
    <- set`update-preserves-fresh-converse F1!<SS SK+F2=SS F1!<SK.

- : fresh-update-preserves-set2capmap-converse/L
    SS=>MS S1=>D1 F!<SS SS+F=S MS+F=M F!<SP SP+F=S (nat`eq?/yes)
    MS _ S2=>D1 MS+F=M F!<MS SP=>MS
    <- set`fresh-update-cancels F!<SS SS+F=S F!<SP SP+F=S (nat`eq/:nat`eq N N) set`eq/ S1=S2 SS=SP
    <- set2capmap-respects-eq SS=>MS SS=SP cap`eq/ capmap`eq/ SP=>MS
    <- set2capmap-preserves-fresh F!<SS SS=>MS F!<MS
    <- cap-id-respects-eq S1=>D1 (nat`eq/:nat`eq N N) S1=S2 cap`eq/ cap`eq/ S2=>D1.

- : fresh-update-preserves-set2capmap-converse
    (set2capmap/U T TK F1 U1 UP1) F2 U2 MP D TU U F TP
    <- nat`eq?-total EQ?
    <- fresh-update-preserves-set2capmap-converse/L
      T TK F1 U1 UP1 F2 U2 EQ? MP D TU F U TP.

%worlds () (fresh-update-preserves-set2capmap-converse _ _ _ _ _ _ _ _ _)
 (fresh-update-preserves-set2capmap-converse/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (T1 T2) (fresh-update-preserves-set2capmap-converse T1 _ _ _ _ _ _ _ _)
 (fresh-update-preserves-set2capmap-converse/L T2 _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem fresh-update-preserves-set2capmap-converse*
  : forall* {M} {MP} {N} {D} {G} {GP} {S} {X}
    forall {T: set2capmap M X G}
    {FS: set`fresh MP N}
    {U: set`update MP N D M}
    {FS: capmap`fresh GP N}
    {U: capmap`update GP N S G}
    exists {T: set2capmap MP X GP}
    true.

- : fresh-update-preserves-set2capmap-converse* M=>G MF MU GF GU MP=>GP
    <- fresh-update-preserves-set2capmap-converse M=>G MF MU _ _ _ GFx GUx MP=>GPx
    <- capmap`fresh-update-cancels GFx GUx GF GU nat`eq/ capmap`eq/ DE ME
    <- set2capmap-respects-eq MP=>GPx set`eq/ cap`eq/ ME MP=>GP.

%worlds () (fresh-update-preserves-set2capmap-converse* _ _ _ _ _ _).
%total {} (fresh-update-preserves-set2capmap-converse* _ _ _ _ _ _).


%theorem set2capmap-preserves-disjoint-join
  : forall* {G} {G1} {G2} {X} {M}
    forall {T: set2capmap G X M}
    {DJ: set`disjoint G1 G2}
    {J: set`join G1 G2 G}
    exists {M1} {M2}
    {T1: set2capmap G1 X M1}
    {T2: set2capmap G2 X M2}
    {DJ: capmap`disjoint M1 M2}
    {J: capmap`join M1 M2 M}
    true.

- : set2capmap-preserves-disjoint-join
    set2capmap/0 DJ J _ _ set2capmap/0 set2capmap/0 capmap`disjoint/L capmap`join/L.

%theorem set2capmap-preserves-disjoint-join/F
  : forall* {G1} {X} {G2} {M}
    forall {V:void}
    exists {M1} {M2}
    {T1: set2capmap G1 X M1}
    {T2: set2capmap G2 X M2}
    {DJ: capmap`disjoint M1 M2}
    {J: capmap`join M1 M2 M}
    true.

%worlds () (set2capmap-preserves-disjoint-join/F _ _ _ _ _ _ _).
%total {} (set2capmap-preserves-disjoint-join/F _ _ _ _ _ _ _).


%theorem set2capmap-preserves-disjoint-join/L
  : forall* {G} {G1} {G2} {X} {M} {MP} {GP} {N} {B1} {B2} {S} {D}
    forall {T: set2capmap GP X MP}
    {S=>D: cap-id N S X D}
    {FS: set`fresh GP N}
    {A: set`update GP N S G}
    {U: capmap`update MP N D M}
    {DJ: set`disjoint G1 G2}
    {J: set`join G1 G2 G}
    {IN1?: set`domain? G1 N B1}
    {IN2?: set`domain? G2 N B2}
    exists {M1} {M2}
    {T1: set2capmap G1 X M1}
    {T2: set2capmap G2 X M2}
    {DJ: capmap`disjoint M1 M2}
    {J: capmap`join M1 M2 M}
    true.

- : set2capmap-preserves-disjoint-join/L GP=>MP S=>D N!<GP GP+N=G MP+N=M G1^G2 G1+G2=G
    (set`domain?/out N!<G1) (set`domain?/out N!<G2) M1 M2 G1=>M1 G2=>M2 M1^M2 M1+M2=M
    <- set`join-preserves-fresh* N!<G1 N!<G2 G1+G2=G N!<G
    <- set`update-implies-lookup GP+N=G G->N=S
    <- set`fresh-lookup-not-equal N!<G G->N=S N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- set2capmap-preserves-disjoint-join/F V M1 M2 G1=>M1 G2=>M2 M1^M2 M1+M2=M.

- : set2capmap-preserves-disjoint-join/L GP+X=>MP S+X=>D N!<GP GP+N+S=G
    MP+N+D=M G1^G2 G1+G2=G (set`domain?/in G1->N=SP) (set`domain?/out N!<G2)
    M1 M2 (set2capmap/U G1P+X=>M1P SP+X=>D N!<G1P G1P+N+SP=G1 M1P+N+D=M1)
    G2+X=>M2 M1^M2 M1+M2=M
    <- set`lookup-implies-fresh-update G1->N=SP G1P N!<G1P G1P+N+SP=G1
    <- set`fresh-update-implies-leq N!<G1P G1P+N+SP=G1 G1P<=G1
    <- set`disjoint-respects-geq* G1^G2 G1P<=G1 G1P^G2
    <- set`fresh-update-implies-unit-join N!<G1P G1P+N+SP=G1 G1P+SP=G1
    <- set`join-commutative G1P+SP=G1 SP+G1P=G1
    <- set`join-associative SP+G1P=G1 G1+G2=G GPk G1P+G2=GPk SP+GPk=G
    <- set`join-commutative SP+GPk=G GPk+SP=G
    <- set`join-preserves-fresh* N!<G1P N!<G2 G1P+G2=GPk N!<GPk
    <- set`fresh-unit-join-implies-update N!<GPk GPk+SP=G GPk+N+SP=G
    <- set`fresh-update-cancels N!<GP GP+N+S=G N!<GPk GPk+N+SP=G
       (nat`eq/:nat`eq N N) set`eq/ S=SP GP=GPk
    <- set`eq-symmetric GP=GPk GPk=GP
    <- set`join-respects-eq G1P+G2=GPk set`eq/ set`eq/ GPk=GP G1P+G2=GP
    <- set2capmap-preserves-disjoint-join GP+X=>MP G1P^G2 G1P+G2=GP M1P M2
      G1P+X=>M1P G2+X=>M2 M1P^M2 M1P+M2=MP
    <- set2capmap-preserves-fresh N!<GP GP+X=>MP N!<MP
    <- capmap`fresh-update-implies-unit-join N!<MP MP+N+D=M MP+D=M
    <- capmap`fresh-implies-unit-disjoint N!<MP MP^D
    <- capmap`disjoint-join-commutative MP^D MP+D=M D+MP=M
    <- capmap`join-associative-converse M1P+M2=MP D+MP=M M1 D+M1P=M1 M1+M2=M
    <- set2capmap-preserves-fresh N!<G1P G1P+X=>M1P N!<M1P
    <- capmap`fresh-implies-unit-disjoint N!<M1P M1P^D
    <- capmap`disjoint-symmetric M1P^D D^M1P
    <- capmap`disjoint-join-commutative D^M1P D+M1P=M1 M1P+D=M1
    <- capmap`fresh-unit-join-implies-update N!<M1P M1P+D=M1 M1P+N+D=M1
    <- cap-id-respects-eq S+X=>D (nat`eq/:nat`eq N N) S=SP cap`eq/ cap`eq/ SP+X=>D
    <- capmap`disjoint-symmetric M1P^M2 M2^M1P
    <- set2capmap-preserves-fresh N!<G2 G2+X=>M2 N!<M2
    <- capmap`fresh-update-preserves-disjoint M2^M1P N!<M2 M1P+N+D=M1 M2^M1
    <- capmap`disjoint-symmetric M2^M1 M1^M2.

- : set2capmap-preserves-disjoint-join/L GP+X=>MP S+X=>D N!<GP GP+N+S=G
    MP+N+D=M G1^G2 G1+G2=G (set`domain?/out N!<G1) (set`domain?/in G2->N=SP)
    M1 M2 G1+X=>M1 (set2capmap/U G2P+X=>M2P SP+X=>D N!<G2P G2P+N+SP=G2 M2P+N+D=M2)
    M1^M2 M1+M2=M
    <- set`lookup-implies-fresh-update G2->N=SP G2P N!<G2P G2P+N+SP=G2
    <- set`fresh-update-implies-leq N!<G2P G2P+N+SP=G2 G2P<=G2
    <- set`disjoint-symmetric G1^G2 G2^G1
    <- set`disjoint-respects-geq* G2^G1 G2P<=G2 G2P^G1
    <- set`fresh-update-implies-unit-join N!<G2P G2P+N+SP=G2 G2P+SP=G2
    <- set`join-associative-converse G2P+SP=G2 G1+G2=G GPk G1+G2P=GPk GPk+SP=G
    <- set`join-preserves-fresh* N!<G1 N!<G2P G1+G2P=GPk N!<GPk
    <- set`fresh-unit-join-implies-update N!<GPk GPk+SP=G GPk+N+SP=G
    <- set`fresh-update-cancels N!<GP GP+N+S=G N!<GPk GPk+N+SP=G
      nat`eq/ set`eq/ S=SP GP=GPk
    <- set`eq-symmetric GP=GPk GPk=GP
    <- set`join-respects-eq G1+G2P=GPk set`eq/ set`eq/ GPk=GP G1+G2P=GP
    <- set`disjoint-symmetric G2P^G1 G1^G2P
    <- set2capmap-preserves-disjoint-join GP+X=>MP G1^G2P G1+G2P=GP M1 M2P
      G1+X=>M1 G2P+X=>M2P M1^M2P M1+M2P=MP
    <- set2capmap-preserves-fresh N!<GP GP+X=>MP N!<MP
    <- capmap`fresh-update-implies-unit-join N!<MP MP+N+D=M MP+D=M
    <- capmap`join-associative M1+M2P=MP MP+D=M M2 M2P+D=M2 M1+M2=M
    <- set2capmap-preserves-fresh N!<G2P G2P+X=>M2P N!<M2P
    <- capmap`fresh-unit-join-implies-update N!<M2P M2P+D=M2 M2P+N+D=M2
    <- cap-id-respects-eq S+X=>D nat`eq/ S=SP cap`eq/ cap`eq/ SP+X=>D
    <- set2capmap-preserves-fresh N!<G1 G1+X=>M1 N!<M1
    <- capmap`fresh-update-preserves-disjoint M1^M2P N!<M1 M2P+N+D=M2 M1^M2.

- : set2capmap-preserves-disjoint-join/L
    GP+X=>MP S+X=>D N!<GP GP+N+S=G MP+N+D=M G1^G2 G1+G2=G
    (set`domain?/in G1->N=S1) (set`domain?/in G2->N=S2)
    M1 M2 G1=>M1 G2=>M2 M1^M2 M1+M2=M
    <- set`disjoint-lookup-contradiction G1^G2 G1->N=S1 G2->N=S2 V
    <- set2capmap-preserves-disjoint-join/F V M1 M2 G1=>M1 G2=>M2 M1^M2 M1+M2=M.

- : set2capmap-preserves-disjoint-join (set2capmap/U GP=>MP S=>D N!<GP GP+N=G MP+N=M)
    G1^G2 G1+G2=G M1 M2 G1=>M1 G2=>M2 M1^M2 M1+M2=M
    <- set`domain?-total MB1?
    <- set`domain?-total MB2?
    <- set2capmap-preserves-disjoint-join/L GP=>MP S=>D N!<GP GP+N=G MP+N=M
      G1^G2 G1+G2=G MB1? MB2? _ _ G1=>M1 G2=>M2 M1^M2 M1+M2=M.

%worlds () (set2capmap-preserves-disjoint-join _ _ _ _ _ _ _ _ _)
 (set2capmap-preserves-disjoint-join/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N1 N2) (set2capmap-preserves-disjoint-join N1 _ _ _ _ _ _ _ _)
 (set2capmap-preserves-disjoint-join/L N2 _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem set2capmap-preserves-disjoint-join*
  : forall* {G} {G1} {G2} {X} {M} {M1} {M2}
    forall {T: set2capmap G X M}
    {DJ: set`disjoint G1 G2}
    {J: set`join G1 G2 G}
    {T1: set2capmap G1 X M1}
    {T2: set2capmap G2 X M2}
    exists {DJ: capmap`disjoint M1 M2}
    {J: capmap`join M1 M2 M}
    true.

- : set2capmap-preserves-disjoint-join* G=>M G1^G2 G1+G2=G G1=>M1 G2=>M2 M1^M2 M1+M2=M
    <- set2capmap-preserves-disjoint-join
      G=>M G1^G2 G1+G2=G _ _ G1=>M1P G2=>M2P M1P^M2P M1P+M2P=M
    <- set2capmap-unique G1=>M1P G1=>M1 set`eq/ cap`eq/ M1P=M1
    <- set2capmap-unique G2=>M2P G2=>M2 set`eq/ cap`eq/ M2P=M2
    <- capmap`disjoint-respects-eq M1P^M2P M1P=M1 M2P=M2 M1^M2
    <- capmap`join-respects-eq M1P+M2P=M M1P=M1 M2P=M2 capmap`eq/ M1+M2=M.

%worlds () (set2capmap-preserves-disjoint-join* _ _ _ _ _ _ _).
%total {} (set2capmap-preserves-disjoint-join* _ _ _ _ _ _ _).




%theorem fresh-update-preserves-set2capmap-converse2
  : forall* {M} {G} {GP} {X} {F} {S}
    forall {T: set2capmap G X M}
    {FS: set`fresh GP F} {U: set`update GP F S G}
    exists {MP}
    {FS: capmap`fresh MP F} {U: capmap`update MP F X M}
    {T: set2capmap GP X MP}
    true.

- : fresh-update-preserves-set2capmap-converse2 T NM A MP F U TP
    <- fresh-update-preserves-set2capmap-converse T NM A _ _ ID F Ux TPx
    <- cap-id-eq ID Ex
    <- cap`eq-symmetric Ex E
    <- update-respects-eq Ux eq/ nat`eq/ E eq/ U
    <- set2capmap-respects-eq TPx set`eq/ cap`eq/ eq/ TP.

%worlds () (fresh-update-preserves-set2capmap-converse2 _ _ _ _ _ _ _).
%total {} (fresh-update-preserves-set2capmap-converse2 _ _ _ _ _ _ _).


%theorem set2capmap-implies-domain
  : forall* {S} {X} {M}
    forall {T: set2capmap S X M}
    exists {DM: capmap`domain M S}
    true.

- : set2capmap-implies-domain set2capmap/0 capmap`domain/0.

- : set2capmap-implies-domain
    (set2capmap/U SP=>MP cap-id/ N!<SP SP+N=S MP+N=M) DM-M
    <- set2capmap-implies-domain SP=>MP DM-MP
    <- capmap`domain-commute-update DM-MP MP+N=M SP+N=S DM-M.

%worlds () (set2capmap-implies-domain _ _).
%total (T) (set2capmap-implies-domain T _).


%theorem partition-leq-implies-leq
  : forall* {M} {M1} {M2P} {X} {M2} {S}
    forall {P: partition M S M1 M2P}
    {T: set2capmap S X M2} {LE: leq M2 M}
    exists {LE: leq M2 M2P}
    true.

%theorem partition-leq-implies-leq/L
  : forall* {M} {M2} {M2P} {S} {X}
    forall {N} {SZ: size M N}
    {R2: restrict M S M2P}
    {T: set2capmap S X M2} {LE: leq M2 M}
    exists {LE: leq M2 M2P}
    true.

- : partition-leq-implies-leq/L _ _ restrict/0 _ leq/0 leq/0.

%theorem partition-leq-implies-leq/U/in
  : forall* {M2S} {M2P} {F} {Z} {MS} {S} {M} {M2} {X} {B}
    forall {N} {SZ: size M N}
    {U: update M2S F Z M2P}
    {R2: restrict MS S M2S}
    {MB: set`member S F}
    {U: update MS F Z M} {FS: fresh MS F}
    {T: set2capmap S X M2} {LE: leq M2 M}
    {IN?: domain? M2 F B}
    exists {LE: leq M2 M2P}
    true.

- : partition-leq-implies-leq/U/in (s N) SZ M2S+F+Z=M2P
    MS|S=M2S F<-S MS+F+Z=M F!<MS S+X=>M2 M2<=M (domain?/in M2->F=XP) M2<=M2P
    <- set`member-implies-not-member-add F<-S SP F!<SP SP+F=S
    <- fresh-update-preserves-set2capmap-converse2
      S+X=>M2 F!<SP SP+F=S M2U F!<M2U M2U+F+XP=M2 SP+X=>M2U
    <- fresh-update-preserves-leq-converse
      M2<=M F!<M2U M2U+F+XP=M2 F!<MS MS+F+Z=M M2U<=MS XP<=Z
    <- fresh-add-preserves-restrict-converse MS|S=M2S F!<MS SP+F=S MS|SP=M2S
    <- fresh-update-increases-size-converse SZ F!<MS MS+F+Z=M SZP
    <- partition-leq-implies-leq/L N SZP MS|SP=M2S SP+X=>M2U M2U<=MS M2U<=M2S
    <- update-preserves-leq* M2U<=M2S XP<=Z M2U+F+XP=M2 M2S+F+Z=M2P M2<=M2P.

- : partition-leq-implies-leq/U/in (s N) SZ M2S+F+Z=M2P
    MS|S=M2S F<-S MS+F+Z=M F!<MS S+X=>M2 M2<=M (domain?/out F!<M2) M2<=M2P
    <- fresh-update2-preserves-leq-converse M2<=M F!<M2 F!<MS MS+F+Z=M M2<=MS
    <- fresh-update-increases-size-converse SZ F!<MS MS+F+Z=M SZP
    <- partition-leq-implies-leq/L N SZP MS|S=M2S S+X=>M2 M2<=MS M2<=M2S
    <- restrict-implies-leq MS|S=M2S M2S<=MS
    <- fresh-respects-geq F!<MS M2S<=MS F!<M2S
    <- fresh-update-implies-leq F!<M2S M2S+F+Z=M2P M2S<=M2P
    <- leq-transitive M2<=M2S M2S<=M2P M2<=M2P.

- : partition-leq-implies-leq/L N SZ
    (restrict/in MS|S=M2S F<-S F!<MS MS+F+Z=M M2S+F+Z=M2P) S+X=>M2 M2<=M M2<=M2P
    <- domain?-total DM?
    <- partition-leq-implies-leq/U/in N SZ M2S+F+Z=M2P MS|S=M2S F<-S
      MS+F+Z=M F!<MS S+X=>M2 M2<=M DM? M2<=M2P.

- : partition-leq-implies-leq/L (s N) SZ
    (restrict/out MS|S=M2P F!<S F!<MS MS+F+Z=M) S+X=>M2 M2<=M M2<=M2P
    <- set2capmap-preserves-fresh F!<S S+X=>M2 F!<M2
    <- fresh-update2-preserves-leq-converse M2<=M F!<M2 F!<MS MS+F+Z=M M2<=MS
    <- fresh-update-increases-size-converse SZ F!<MS MS+F+Z=M SZP
    <- partition-leq-implies-leq/L N SZP MS|S=M2P S+X=>M2 M2<=MS M2<=M2P.

%worlds () (partition-leq-implies-leq/L _ _ _ _ _ _)
 (partition-leq-implies-leq/U/in _ _ _ _ _ _ _ _ _ _ _).
%total (N1 N2) (partition-leq-implies-leq/U/in N1 _ _ _ _ _ _ _ _ _ _)
 (partition-leq-implies-leq/L N2 _ _ _ _ _).


- : partition-leq-implies-leq (partition/ _ _ _ R) T LE LE2
    <- size-total Z
    <- partition-leq-implies-leq/L _ Z R T LE LE2.

%worlds () (partition-leq-implies-leq _ _ _ _).
%total {} (partition-leq-implies-leq _ _ _ _).
