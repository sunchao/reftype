%%% Converting *map to permission

%%% ======================= Abbreviations =====================================

%abbrev fldperm
  : object -> nat -> (object -> permission) -> permission
  = [O][F][PF] (unitperm (precise-exists O F ([x] PF x))).

%abbrev cond-fldperm
  : object -> nat -> (object -> permission) -> permission
  = [O][F][PF]
    (unitperm (conditional (objequal O null) empty
                (unitperm (precise-exists O F PF)))).

%abbrev obj-not-null : object -> permission
  = ([r] unitperm (nonlinear (neg (objequal r null)))).

%abbrev encumbered-fldperm
  : object -> (object -> permission) -> clspred -> permission
  = [O][PF][CP] (unitperm
                  (conditional
                    (objequal O null)
                    (empty)
                    (unitperm
                      (encumbered
                        (PF O)
                        (combine
                          (allperm O)
                          (one-predcall CP O)))))).


%%% ======================= Definitions =======================================

%%% Convert a set of object locations to a conditional of objequal
%%% facts. Used in output.

set2cond : cxt -> object -> set -> permission -> type.

set2cond/0 : set2cond _ _ set/0 (unitperm (nonlinear (neg t))).

set2cond/U :
    set2cond B O S' Pi ->
    set`add S' N S ->
    set`not-member S' N ->
    cxt`lookup B N (cxt-info/ O' (ty/ _ _ _)) ->
 set2cond B O S (unitperm (conditional (objequal O O') empty Pi)).


%{
A whole object can be consumed, for instance, in x.f = a, object
a is consumed. In this case, we treated as if all of a's field are
consumed. But, we also need the encumbered permission:
 \forall f (P(a.f) encumbered-in P(a.all))
Given a set of objects, the relation "make-encumbered" construct
such an encumbered permission for each object, using "fldset2perm".
}%

fldset2perm : predmap -> object -> fldmap -> set -> permission -> type.

fldset2perm/0 : fldset2perm _ _ _ set/0 empty.

fldset2perm/+ :
    set`shift F S1 S2 ->
    fldset2perm PM O FM S2 Pi ->
    fldmap`lookup FM F T ->
    ty2perm PM T PF ->
  fldset2perm PM O FM (set/+ F S1) (unitperm (precise-exists O F PF) , Pi).


%{
Convert a type in a context to a permission
The interesting case is unique type, for which we convert to an
encumbered permissions. The field permissions are recorded in the
capabilities, together with which we can restore the whole permission
for the object, and then used for consumption.
}%

ty2perm2 : predmap -> ty -> (object -> permission) -> type.

% ty2perm2/null : ty2perm2 _ ty/null ([x] unitperm (nonlinear (objequal x null))).

ty2perm2/shared :
    ty2perm PM (ty/ NN annot/shared C) PF ->
  ty2perm2 PM (ty/ NN annot/shared C) ([x] PF x).

ty2perm2/borrow :
    ty2perm PM (ty/ NN annot/borrow C) PF ->
  ty2perm2 PM (ty/ NN annot/borrow C) ([x] PF x).

ty2perm2/unique :
    ty2perm PM (ty/ NN annot/borrow C) PF ->
  ty2perm2 PM (ty/ NN annot/unique C) ([x] PF x).


%{
Convert the explicit context to permissions, which
consists of non-null information, class predicate, and,
for shared the nesting facts, for each parameter.
Notice that, unique has the same permission as borrowed
parameter. We use a separate procedure to generate the
encumbered permission for them. So, the cxt should only
contain borrowed and shared types.
}%

cxt2perm : predmap -> cxt -> permission -> type.

cxt2perm/0 : cxt2perm _ cxt/0 empty.

cxt2perm/U :
    cxt2perm PM B' Pi2 ->
    cxt`fresh B' N ->
    cxt`update B' N (cxt-info/ O T) B ->
    ty2perm2 PM T PF ->
  cxt2perm PM B ((PF O) , Pi2).


%%% Create field permission

create-fldperm : clsmap -> predmap -> nat -> nat -> (object -> permission) -> type.

create-fldperm/ :
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F T ->
    ty2perm PM T PF ->
  create-fldperm CM PM C F ([x] PF x).

%{
Convert a capability set (capset) to a set of permissions:
Each entry (O, F) in the capset will be converted to a packed whole
field permission. Note that, the object O in this case must be
not-null, otherwise we cannot do anything on the field F.
To unlock the nonnull, we need to lookup context.
}%

capset2perm : clsmap -> predmap -> cxt -> set -> permission -> type.

capset2perm/0 : capset2perm _ _ _ set/0 empty.

capset2perm/U :
    capset2perm CM PM B CS' Pi2 ->
    nat2pair (s K) (pair/ N F) ->
    cxt`lookup B N (cxt-info/ O (ty/ _ _ C)) ->
    create-fldperm CM PM C F PF ->
    set`not-member CS' (s K) ->
    set`add CS' (s K) CS ->
  capset2perm CM PM B CS (combine
    (unitperm (conditional (objequal O null) empty (fldperm O F PF)))
    Pi2).

capset2perm/z :
    capset2perm CM PM B CS' Pi ->
    set`not-member CS' shared ->
    set`add CS' shared CS ->
  capset2perm CM PM B CS (combine (unitperm (basic null all null)) Pi).


make-encumbered : clsmap -> predmap -> cxt -> set -> permission -> type.

make-encumbered/0 : make-encumbered _ _ _ set/0 empty.

make-encumbered/U :
    make-encumbered CM PM B S' Pi2 ->
    cxt`lookup B N (cxt-info/ O (ty/ NN _ C)) ->
    clsmap`lookup CM C FM ->
    predmap`lookup PM C CP ->
    fldmap`domain FM FS ->
    ({x} fldset2perm PM x FM FS (PF x)) ->
    set`not-member S' N ->
    set`add S' N S ->
  make-encumbered CM PM B S ((encumbered-fldperm O PF CP) , Pi2).


%%% Convert an input environment (context and capabilities) to a set of
%%% input permissions.

env2input : clsmap -> predmap -> cxt -> env -> permission -> type.

env2input/ :
    make-encumbered CM PM B U PiU ->
    capset2perm CM PM B M PiM ->
  env2input CM PM B (env/ U M) (PiU , PiM).


%%% Convert result to output permissions.

reftype2perm : clsmap -> predmap -> cxt -> reftype ->
    (object -> object -> permission -> permission) -> type.

reftype2perm/shared :
    ty2perm PM (ty/ NN annot/shared C) PF ->
  reftype2perm CM PM _ (reftype/ NN C targets/shared) ([o][_][_] PF o).

reftype2perm/borrow :
    set`size S (nat`s _) ->
    set`size M nat`z ->
    ty2perm PM (ty/ NN annot/borrow C) PF ->
    ({x} set2cond B x S (GF x)) ->
  reftype2perm CM PM B (reftype/ NN C (targets/unique S M false)) ([o][_][_] (PF o) , (GF o)).

reftype2perm/unique :
    set`size M (nat`s _) ->
    ty2perm PM (ty/ NN annot/unique C) PF ->
    ({x} set2cond B x S (GF x)) ->
    capset2perm CM PM B M Pi ->
  reftype2perm CM PM B (reftype/ NN C (targets/unique S M false))
    ([o][r][_] combine
      (unitperm
        (conditional (objequal o r) empty (GF o)))
      (combine (PF r) (unitperm (encumbered (PF r) Pi)))).

reftype2perm/unique+fresh :
    ty2perm PM (ty/ NN annot/unique C) PF ->
    ({x} set2cond B x S (GF x)) ->
    capset2perm CM PM B M Pi ->
  reftype2perm CM PM B (reftype/ NN C (targets/unique S M true))
    ([o][r][v] combine
      (unitperm
        (conditional (objequal o r) empty (GF o)))
      (combine (PF r) (unitperm (encumbered (PF r) (combine Pi v))))).

reftype2perm/fresh :
    ty2perm PM (ty/ NN annot/unique C) PF ->
  reftype2perm CM PM B (reftype/ NN C targets/fresh)
    ([o][_][_] PF o).


result2output* : clsmap -> predmap -> cxt -> permission -> result K -> output K -> type.

result2output/expr :
    cxt2perm PM B PiB ->
    env2input CM PM B V PiV ->
    reftype2perm CM PM B RT PF ->
  result2output* CM PM B Pi (result/expr RT V)
    (output/exists [o]
      (output/exists [r]
        (output/exists [v:permission]
          (output/expr o
            (combine (combine PiB (combine (PF o r v) PiV)) Pi))))).

result2output/args/0 :
    cxt2perm PM B PiB ->
    env2input CM PM B V PiV ->
  result2output* CM PM B Pi0 (result/args/0 V) (output/args/0 (Pi0 , (PiB , PiV))).

result2output/args/+ :
    env2input CM PM B V PiV ->
    reftype2perm CM PM B RT ([o][r][v] PF o r v) ->
    ({o}{r}{v} result2output* CM PM B (((PF o r v) , PiV) , Pi) A (AO o r v)) ->
  result2output* CM PM B Pi (result/args/+ RT V A)
    (output/exists [o] (output/exists [r] (output/exists [v] (output/args/+ o (AO o r v))))).

result2output/cond :
    cxt2perm PM B PiB ->
    env2input CM PM B V PiV ->
  result2output* CM PM B _ (result/cond V) (output/cond _ (PiB , PiV) (PiB , PiV)).

result2output/exists* :
    {Out: (gterm V) -> output condk}
    ({v} result2output* CM PM B Pi R (Out v)) ->
  result2output* CM PM B Pi R (output/exists ([v] Out v)).

%abbrev result2output/exists = [PO] result2output/exists* _ PO.

%abbrev result2output : clsmap -> predmap -> cxt -> result K -> output K -> type =
    [CM][PM][B][R][O] result2output* CM PM B empty R O.


argtype2perm : clsmap -> predmap -> ty -> set
    -> (object -> permission) -> (object -> permission) -> type.

argtype2perm/unique :
    ty2perm PM (ty/ NN annot/unique C) PF ->
  argtype2perm CM PM (ty/ NN annot/unique C) _ ([x] PF x) ([_] empty).

argtype2perm/shared :
    ty2perm PM (ty/ NN annot/shared C) PF ->
  argtype2perm CM PM (ty/ NN annot/shared C) _ ([x] PF x) ([x] PF x).

argtype2perm/borrow :
    clsmap`lookup CM C FM ->
    fldmap`domain FM FS0 ->
    set`leq FS FS0 ->
    ({x} fldset2perm PM x FM FS (PF x)) ->
  argtype2perm CM PM (ty/ NN annot/borrow C) FS
    ([x] (unitperm (conditional (objequal x null) empty (PF x))))
    ([x] (unitperm (conditional (objequal x null) empty (PF x)))).


methty2proctype* : clsmap -> predmap -> permission -> permission -> methty -> proctype -> type.

methty2proctype/base :
    ty2perm PM T PF ->
  methty2proctype* _ PM Pi1 Pi2 (methty/base T)
    (proctype/base Pi1 (output/exists [r] (output/expr r ((PF r) , Pi2)))).

methty2proctype/arg :
    argtype2perm CM PM T M PF1 PF2 ->
    ({x} methty2proctype* CM PM ((PF1 x) , Pi1) ((PF2 x) , Pi2) MT (PTF x)) ->
  methty2proctype* CM PM Pi1 Pi2 (methty/arg T M MT) (proctype/arg PTF).

%abbrev methty2proctype = [CM][PM][MT][PT] methty2proctype* CM PM empty empty MT PT.


%%% Convert a constructor type to a proctype
consty2proctype* : clsmap -> fldmap -> predmap -> permission ->
     permission -> methty -> (object -> proctype) -> type.

consty2proctype/base :
    fldmap`domain FM S ->
    ({x} allocFields x S (OS x)) ->
    ty2perm PM T PF ->
  consty2proctype* _ FM PM Pi1 Pi2 (methty/base T)
    ([x] proctype/base
      (combine Pi1 (combine (obj-not-null x) (OS x)))
      (output/exists [r] (output/expr r ((PF r) , Pi2)))).

consty2proctype/arg :
    argtype2perm CM PM T M PF1 PF2 ->
    ({o} consty2proctype* CM FM PM ((PF1 o) , Pi1) ((PF2 o) , Pi2) CT ([t] PTF t o)) ->
  consty2proctype* CM FM PM Pi1 Pi2 (methty/arg T M CT) ([t] proctype/arg (PTF t)).

%abbrev consty2proctype = [CM][FM][PM][MT][PTF] consty2proctype* CM FM PM empty empty MT PTF.


%%% Convert a method map into a progtype.

methmap2progtype : clsmap -> predmap -> methmap -> progtype -> type.

methmap2progtype/0 : methmap2progtype _ _ methmap/0 progtype`map/0.

methmap2progtype/U/c :
    methmap2progtype CM PM MM' W' ->
    clsmap`lookup CM C FM ->
    consty2proctype CM FM PM CT PTF ->
    methmap`fresh MM' N ->
    methmap`update MM' N (methty/arg (ty/ nn/yes annot/unique C) set/0 CT) MM ->
    progtype`update W' N (proctype/arg PTF) W ->
  methmap2progtype CM PM MM W.

methmap2progtype/U/m :
    methmap2progtype CM PM MM' W' ->
    clsmap`fresh CM N ->
    methty2proctype CM PM MT PT ->
    methmap`fresh MM' N ->
    methmap`update MM' N MT MM ->
    progtype`update W' N PT W ->
  methmap2progtype CM PM MM W.



%%% Theorems

%% 1, theorems about set2cond

%theorem false-implies-set2cond
  : forall* {O} {S} {G} {B}
    forall {V:void}
    exists {S=>G: set2cond B O S G}
    true.

%worlds (gtermvar) (false-implies-set2cond _ _).
%total {} (false-implies-set2cond _ _).


%theorem set2cond-respects-eq
  : forall* {S1} {S2} {O1} {O2} {G1} {G2} {B1} {B2}
    forall {S2G: set2cond B1 O1 S1 G1}
    {E: cxt`eq B1 B2} {E: object`eq O1 O2} {E: set`eq S1 S2}
    {E: permission`eq G1 G2}
    exists {S2G2: set2cond B2 O2 S2 G2}
    true.

- : set2cond-respects-eq S2G cxt`eq/ object`eq/ set`eq/ permission`eq/ S2G.

%worlds (gtermvar) (set2cond-respects-eq _ _ _ _ _ _).
%total {} (set2cond-respects-eq _ _ _ _ _ _).


%theorem cxt-unique-objset-implies-set2cond
  : forall* {B} {NN} {C} {S} {O}
    forall {CM-B-S: cxt-unique-objset B NN C S}
    exists {G} {S2G: set2cond B O S G}
    true.

- : cxt-unique-objset-implies-set2cond cxt-unique-objset/0 _ set2cond/0.

- : cxt-unique-objset-implies-set2cond
    (cxt-unique-objset/U B-S' BL _ _ F U) _ (set2cond/U S2G' U F BL)
    <- cxt-unique-objset-implies-set2cond B-S' _ S2G'.

%worlds (gtermvar) (cxt-unique-objset-implies-set2cond _ _ _).
%total (A) (cxt-unique-objset-implies-set2cond A _ _).


%theorem cxt-unique-objset-implies-set2cond
  : forall* {B} {S} {C} {O} {NN}
    forall {SOC: cxt-unique-objset B NN C S}
    exists {G} {S2G: set2cond B O S G}
    true.

- : cxt-unique-objset-implies-set2cond cxt-unique-objset/0 _ set2cond/0.

- : cxt-unique-objset-implies-set2cond (cxt-unique-objset/U SOC' BL _ _ F U)
    _ (set2cond/U S2G' U F BL)
    <- cxt-unique-objset-implies-set2cond SOC' _ S2G'.

%worlds (gtermvar) (cxt-unique-objset-implies-set2cond _ _ _).
%total (B) (cxt-unique-objset-implies-set2cond B _ _).


%theorem clsmap-cxt-objset-implies-set2cond
  : forall* {CM} {B} {S} {O}
    forall {B-S: clsmap-cxt-objset CM B S}
    exists {G} {S2G: set2cond B O S G}
    true.

- : clsmap-cxt-objset-implies-set2cond clsmap-cxt-objset/0 _ set2cond/0.

- : clsmap-cxt-objset-implies-set2cond
    (clsmap-cxt-objset/U B-S' BL CML FS U)
    _ (set2cond/U S'2G U FS BL)
    <- clsmap-cxt-objset-implies-set2cond B-S' _ S'2G.

%worlds () (clsmap-cxt-objset-implies-set2cond _ _ _).
%total (CM) (clsmap-cxt-objset-implies-set2cond CM _ _).


%theorem set2cond/U-inversion
  : forall* {B} {O} {S} {SP} {G} {N}
    forall {S=>G: set2cond B O S G}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    exists {GP} {SP=>GP: set2cond B O SP GP}
    {O'} {T} {BL: cxt`lookup B N (cxt-info/ O' T)}
    {IMP1: implies G (unitperm (conditional (objequal O O') empty GP))}
    {IMP2: implies (unitperm (conditional (objequal O O') empty GP)) G}
    true.

%theorem set2cond/U-inversion/L
  : forall* {B} {O} {S} {SP} {N} {S1} {N1} {G1} {P} {O1'} {NN} {A} {C}
    forall {NM1: set`not-member S1 N1}
    {A1: set`add S1 N1 S}
    {S1=>G1: set2cond B O S1 G1}
    {BL: cxt`lookup B N1 (cxt-info/ O1' (ty/ NN A C))}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    {E?: nat`eq? N N1 P}
    exists {GP} {SP=>GP: set2cond B O SP GP}
    {O'} {T} {BL: cxt`lookup B N (cxt-info/ O' T)}
    {IMP1: implies
           (unitperm (conditional (objequal O O1') empty G1))
           (unitperm (conditional (objequal O O') empty GP))}
    {IMP2: implies
           (unitperm (conditional (objequal O O') empty GP))
           (unitperm (conditional (objequal O O1') empty G1))}
    true.

- : set2cond/U-inversion
    (set2cond/U
      (S2G1:set2cond B O S1 G1)
      (U1:set`add S1 N1 S)
      (F1:set`not-member S1 N1)
      (BL1:cxt`lookup B N1 (cxt-info/ O1 _)))
    (F2:set`not-member SP N)
    (U2:set`add SP N S) GP S2G O' T BL IMP1 IMP2
    <- nat`eq?-total E?
    <- set2cond/U-inversion/L F1 U1 S2G1 BL1 F2 U2 E? GP S2G O' T BL IMP1 IMP2.

- : set2cond/U-inversion/L F1 U1 S2G1 BL1 F2 U2 nat`eq?/yes _ S2G _ _ BL1
    (implies/reflexive) (implies/reflexive)
    <- set`not-member-add-cancels F1 U1 F2 U2 nat`eq/ set`eq/ S1=S2
    <- set2cond-respects-eq S2G1 cxt`eq/ object`eq/ S1=S2 permission`eq/ S2G.

- : set2cond/U-inversion/L F1 U1 S2G1 BL1 F2 U2 (nat`eq?/no N<>N1) _
    (set2cond/U S2G U4 F4 BL1) _ _ BL3
    (implies/trans
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (IMP1))
      (IMP3))
    (implies/trans
      (IMP4)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (IMP2)))
    <- set`add-commutes-converse U2 U1 N<>N1 _ U4 U3
    <- set`add-preserves-not-member-converse F2 U4 F3
    <- set`add-preserves-not-member-converse F1 U3 F4
    <- set2cond/U-inversion S2G1 F3 U3 _ S2G _ _ BL3 IMP1 IMP2
    <- cond-objequal-can-swap _ _ _ _ IMP3
    <- cond-objequal-can-swap _ _ _ _ IMP4.

%worlds (gtermvar) (set2cond/U-inversion _ _ _ _ _ _ _ _ _ _)
  (set2cond/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N N1) (set2cond/U-inversion N _ _ _ _ _ _ _ _ _)
  (set2cond/U-inversion/L _ _ N1 _ _ _ _ _ _ _ _ _ _ _).


%theorem set2cond-implies
  : forall* {B} {O1} {O2} {S1} {S2} {G1} {G2}
    forall {S1=>G1: set2cond B O1 S1 G1}
    {S2=>G2: set2cond B O2 S2 G2}
    {E: object`eq O1 O2} {E: set`eq S1 S2}
    exists {IMP1: implies G1 G2} {IMP2: implies G2 G1}
    true.

%theorem set2cond-implies/L
  : forall* {O1} {O1'} {O2} {O2'} {G1} {G2}
    forall {OE: object`eq O1 O2} {OE: object`eq O1' O2'}
    {IMP1: implies G1 G2} {IMP2: implies G2 G1}
    exists {IMP1: implies
                  (unitperm (conditional (objequal O1 O1') empty G1))
                  (unitperm (conditional (objequal O2 O2') empty G2))}
    {IMP2: implies (unitperm (conditional (objequal O2 O2') empty G2))
           (unitperm (conditional (objequal O1 O1') empty G1))}
    true.

- : set2cond-implies/L object`eq/ object`eq/ IMP1 IMP2
    (implies/cond-inner bimplies/reflexive bimplies/reflexive
      implies/reflexive IMP1)
    (implies/cond-inner bimplies/reflexive bimplies/reflexive
      implies/reflexive IMP2).

- : set2cond-implies
    set2cond/0 set2cond/0 object`eq/ set`eq/ implies/reflexive implies/reflexive.

- : set2cond-implies (set2cond/U S2G0 F0 U0 L0) S2G OE SE
    (implies/trans IMP1R IMP2P) (implies/trans IMP1P IMP2R)
    <- set2cond/U-inversion S2G U0 F0 _ S2G1 _ _ L1 IMP1P IMP2P
    <- set2cond-implies S2G0 S2G1 OE set`eq/ IMP1Q IMP2Q
    <- cxt`lookup-unique L0 L1 cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE' TE
    <- set2cond-implies/L OE OE' IMP1Q IMP2Q IMP1R IMP2R.

%worlds (gtermvar) (set2cond-implies/L _ _ _ _ _ _).
%total { } (set2cond-implies/L _ _ _ _ _ _).

%worlds (gtermvar) (set2cond-implies _ _ _ _ _ _).
%total (R) (set2cond-implies R _ _ _ _ _).


%theorem set2cond-implies-empty
  : forall* {B} {S} {GF} {O}
    forall {B=>GF: set2cond B O S GF}
    exists {GF=>E: implies GF empty}
    true.

- : set2cond-implies-empty set2cond/0 implies/contradiction.

- : set2cond-implies-empty
    (set2cond/U SP=>GFP N!<SP SP+N=S BL)
    (implies/trans
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (IMP))
      (implies/cond-equal))
    <- set2cond-implies-empty SP=>GFP IMP.

%worlds (gtermvar) (set2cond-implies-empty _ _).
%total (A) (set2cond-implies-empty A _).


%% theorems about fldset2perm

%theorem false-implies-fldset2perm
  : forall* {PM} {O} {FM} {FS} {Pi}
    forall {V:void} exists {MFP: fldset2perm PM O FM FS Pi}
    true.

%worlds (gtermvar) (false-implies-fldset2perm _ _).
%total { } (false-implies-fldset2perm _ _).


%theorem fldset2perm-respects-eq
  : forall* {FS1} {PM1} {PM2} {O1} {O2} {FM1} {FM2} {Pi1} {Pi2} {FS2}
    forall {MFP1: fldset2perm PM1 O1 FM1 FS1 Pi1}
    {PME: predmap`eq PM1 PM2} {OE: object`eq O1 O2}
    {FME: fldmap`eq FM1 FM2} {FSE: set`eq FS1 FS2}
    {PE: permission`eq Pi1 Pi2}
    exists {MFP2: fldset2perm PM2 O2 FM2 FS2 Pi2}
    true.

- : fldset2perm-respects-eq MFP predmap`eq/
    object`eq/ fldmap`eq/ set`eq/ permission`eq/ MFP.

%worlds (gtermvar) (fldset2perm-respects-eq _ _ _ _ _ _ _).
%total {} (fldset2perm-respects-eq _ _ _ _ _ _ _).


%theorem fldset2perm-total
  : forall* {CM} {C} {PM} {O} {FM} {FS} {FS0}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    exists {Pi} {MF1: fldset2perm PM O FM FS Pi}
    true.

%theorem fldset2perm-total/L
  : forall* {CM} {C} {PM} {O} {FM} {FS0} {FS}
    forall {N} {SZ: set`size FS N}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS0}
    {LE: set`leq FS FS0}
    exists {Pi} {MF1: fldset2perm PM O FM FS Pi}
    true.

- : fldset2perm-total/L z _ _ _ _ _ set`leq/0 _ fldset2perm/0.

- : fldset2perm-total/L (s N) SZ CM-CM CM2PM CML DM-FM=FS0 FS<=FS0 _
    (fldset2perm/+ SH FS'=>Pi FML T2PF)
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) FS' F!<FS' FS'+F=FS
    <- set`not-member-update-implies-shift F!<FS' FS'+F=FS SH unit`eq/
    <- set`add-implies-member FS'+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
    <- fldmap`domain-preserves-lookup-converse F<-FS0 DM-FM=FS0 T FML
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- set`not-member-update-implies-leq F!<FS' FS'+F=FS FS'<=FS
    <- set`leq-transitive FS'<=FS FS<=FS0 FS'<=FS0
    <- set`not-member-add-increases-size-converse SZ F!<FS' FS'+F=FS SZ'
    <- fldset2perm-total/L N SZ' CM-CM CM2PM CML DM-FM=FS0 FS'<=FS0 _ FS'=>Pi.

- : fldset2perm-total CM-CM CM2PM CML DM LEQ _ MF1
    <- set`size-total SZ
    <- fldset2perm-total/L _ SZ CM-CM CM2PM CML DM LEQ _ MF1.

%worlds (gtermvar) (fldset2perm-total/L _ _ _ _ _ _ _ _ _).
%total (N) (fldset2perm-total/L N _ _ _ _ _ _ _ _).

%worlds (gtermvar) (fldset2perm-total _ _ _ _ _ _ _).
%total { } (fldset2perm-total _ _ _ _ _ _ _).


%theorem fldset2perm-unique
  : forall* {PM} {O} {FM} {FS} {Pi}
    {PM'} {O'} {FM'} {FS'} {Pi'}
    forall {MF1: fldset2perm PM O FM FS Pi}
    {MF1': fldset2perm PM' O' FM' FS' Pi'}
    {PME: predmap`eq PM PM'} {OE: object`eq O O'}
    {FME: fldmap`eq FM FM'} {FSE: set`eq FS FS'}
    exists {EQ: permission`eq Pi Pi'}
    true.

%theorem fldset2perm-unique/L
  : forall* {O1} {O2} {N1} {N2} {PF1} {PF2} {Pi1} {Pi2}
    forall {O1=O2: object`eq O1 O2}
    {N1=N2: nat`eq N1 N2}
    {PF1=PF2: {x} permission`eq (PF1 x) (PF2 x)}
    {Pi1=Pi2: permission`eq Pi1 Pi2}
    exists {EQ: permission`eq (unitperm (precise-exists O1 N1 PF1) , Pi1)
                (unitperm (precise-exists O2 N2 PF2) , Pi2)}
    true.

- : fldset2perm-unique/L object`eq/ nat`eq/
    ([_] permission`eq/) permission`eq/ permission`eq/.

- : fldset2perm-unique fldset2perm/0 fldset2perm/0 predmap`eq/
    object`eq/ fldmap`eq/ set`eq/ permission`eq/.

- : fldset2perm-unique
    (fldset2perm/+ SH1 FM2P1 FML1 T2PF1)
    (fldset2perm/+ SH2 FM2P2 FML2 T2PF2) (PM1=PM2:predmap`eq PM1 PM2)
    (O1=O2:object`eq O1 O2) (FM1=FM2:fldmap`eq FM1 FM2)
    (S1=S2) EQ
    <- set`map/+-preserves-eq-converse S1=S2 (N1=N2:nat`eq N1 N2) _ (SP1=SP2:set`eq SP1 SP2)
    <- set`shift-unique SH1 SH2 N1=N2 SP1=SP2 SQ1=SQ2
    <- fldset2perm-unique FM2P1 FM2P2 PM1=PM2 O1=O2 FM1=FM2 SQ1=SQ2 Pi1=Pi2
    <- fldmap`lookup-unique FML1 FML2 FM1=FM2 N1=N2 T1=T2
    <- ty2perm-deterministic T2PF1 T2PF2 PM1=PM2 T1=T2 PF1=PF2
    <- fldset2perm-unique/L O1=O2 N1=N2 PF1=PF2 Pi1=Pi2 EQ.

%worlds (gtermvar) (fldset2perm-unique/L _ _ _ _ _).
%total { } (fldset2perm-unique/L _ _ _ _ _).

%worlds (gtermvar) (fldset2perm-unique _ _ _ _ _ _ _).
%total (A) (fldset2perm-unique A _ _ _ _ _ _).


%theorem fldset2perm-split-implies-permission-combine
  : forall* {CM} {PM} {FM} {FS0} {FS1} {Pi0}
    forall {FS1<=FS0: set`leq FS1 FS0}
    {FS0=>Pi0: fldset2perm CM PM FM FS0 Pi0}
    exists {FS2} {Pi1} {Pi2}
    {FS0-FS1=FS2: set`remove FS0 FS1 FS2}
    {FS1=>Pi1: fldset2perm CM PM FM FS1 Pi1}
    {FS2=>Pi2: fldset2perm CM PM FM FS2 Pi2}
    {EQV: equiv Pi0 (Pi1 , Pi2)}
    true.

%worlds (gtermvar) (fldset2perm-split-implies-permission-combine _ _ _ _ _ _ _ _ _).
%trustme %total { } (fldset2perm-split-implies-permission-combine _ _ _ _ _ _ _ _ _).


%% theorems about ty2perm2

%theorem ty2perm2-respects-eq
  : forall* {T1} {T2} {PM1} {PM2} {PF1} {PF2}
    forall {T2PF: ty2perm2 PM1 T1 PF1}
    {PME: predmap`eq PM1 PM2} {TE: ty`eq T1 T2}
    {PFE: {o} permission`eq (PF1 o) (PF2 o)}
    exists {T2PF: ty2perm2 PM2 T2 PF2}
    true.

- : ty2perm2-respects-eq T2PF predmap`eq/ ty`eq/ ([_] permission`eq/) T2PF.

%worlds (gtermvar) (ty2perm2-respects-eq _ _ _ _ _).
%total { } (ty2perm2-respects-eq _ _ _ _ _).


%theorem ty2perm2-implies/L/unique
  : forall* {Pi1: object -> permission} {Pi2} {CP1} {CP2} {PF1} {PF2}
    forall {FEQ: {o} permission`eq (Pi1 o) (Pi2 o)}
    {PEQ: predicate`eq CP1 CP2} {PF-EQ: {x} equiv (PF1 x) (PF2 x)}
    exists
    {IMP1: {x} implies
           (combine (Pi1 x)
             (unitperm (conditional (objequal x null) empty
                         (unitperm (encumbered (PF1 x)
                                     (combine (allperm x) (one-predcall CP1 x)))))))
           (combine (Pi2 x)
             (unitperm (conditional (objequal x null) empty
                         (unitperm (encumbered (PF2 x)
                                     (combine (allperm x) (one-predcall CP2 x)))))))}
    {IMP2: {x} implies
           (combine (Pi2 x)
             (unitperm (conditional (objequal x null) empty
                         (unitperm (encumbered (PF2 x)
                                     (combine (allperm x) (one-predcall CP2 x)))))))
           (combine (Pi1 x)
             (unitperm (conditional (objequal x null) empty
                         (unitperm (encumbered (PF1 x)
                                     (combine (allperm x) (one-predcall CP1 x)))))))}
    true.

- : ty2perm2-implies/L/unique
     ([_] permission`eq/) predicate`eq/ ([x] EQV x)
    ([x] implies/combine (implies/reflexive)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (implies/equiv-encumbered (EQV x) equiv/reflexive)))
    ([x] implies/combine (implies/reflexive)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (implies/equiv-encumbered (equiv/symmetric (EQV x)) equiv/reflexive))).

%worlds (gtermvar) (ty2perm2-implies/L/unique _ _ _ _ _).
%total  {} (ty2perm2-implies/L/unique _ _ _ _ _).


%theorem ty2perm2-equiv
  : forall* {PM1} {PM2} {T1} {T2} {PF1} {PF2}
    forall {T12PF1: ty2perm2 PM1 T1 PF1}
    {T22PF2: ty2perm2 PM2 T2 PF2}
    {E: predmap`eq PM1 PM2} {EQ: ty`eq T1 T2}
    exists {EQV: {x} equiv (PF1 x) (PF2 x)}
    true.

- : ty2perm2-equiv (ty2perm2/unique T2PF1) (ty2perm2/unique T2PF2) PM-EQ T-EQ EQV
    <- ty-eq-inversion T-EQ NN-EQ _ C-EQ
    <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ2
    <- ty2perm-deterministic T2PF1 T2PF2 PM-EQ T-EQ2 P-EQ
    <- ({x} permission`eq-implies-equiv (P-EQ x) (EQV x)).

- : ty2perm2-equiv (ty2perm2/borrow T2PF1) (ty2perm2/borrow T2PF2) PM-EQ T-EQ EQV
    <- ty2perm-deterministic T2PF1 T2PF2 PM-EQ T-EQ P-EQ
    <- ({x} permission`eq-implies-equiv (P-EQ x) (EQV x)).

- : ty2perm2-equiv (ty2perm2/shared T2PF1) (ty2perm2/shared T2PF2) PM-EQ T-EQ EQV
    <- ty2perm-deterministic T2PF1 T2PF2 PM-EQ T-EQ P-EQ
    <- ({x} permission`eq-implies-equiv (P-EQ x) (EQV x)).

% - : ty2perm2-equiv ty2perm2/null ty2perm2/null PM-EQ T-EQ ([_] equiv/reflexive).

%worlds (gtermvar) (ty2perm2-equiv _ _ _ _ _).
%total { } (ty2perm2-equiv _ _ _ _ _).


%theorem clsmap-lookup-implies-ty2perm2*
  : forall* {CM} {PM} {FM} {C} {NN}
    forall {A} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    exists {PF} {T2PF: ty2perm2 PM (ty/ NN A C) PF}
    true.

- : clsmap-lookup-implies-ty2perm2*
    annot/shared _ CM2PM CM-L _ (ty2perm2/shared (ty2perm/ PM-L NN2P A2P))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CM-L _ PM-L
    <- annot2perm-total A2P
    <- nn2perm-total NN2P.

- : clsmap-lookup-implies-ty2perm2*
    annot/borrow _ CM2PM CM-L _ (ty2perm2/borrow (ty2perm/ PM-L NN2P A2P))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CM-L _ PM-L
    <- annot2perm-total A2P
    <- nn2perm-total NN2P.

- : clsmap-lookup-implies-ty2perm2*
    annot/unique _ CM2PM CM-L _ (ty2perm2/unique (ty2perm/ PM-L NN2P A2P))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CM-L _ PM-L
    <- annot2perm-total A2P
    <- nn2perm-total NN2P.

%worlds (gtermvar) (clsmap-lookup-implies-ty2perm2* _ _ _ _ _ _).
%total {} (clsmap-lookup-implies-ty2perm2* _ _ _ _ _ _).

%abbrev clsmap-lookup-implies-ty2perm2 = clsmap-lookup-implies-ty2perm2* _.


%theorem ty2perm2-duplicate-notnull-info
  : forall* {PM} {PF} {A} {C}
    forall {T2PF: ty2perm2 PM (ty/ nn/yes A C) PF}
    exists {IMP: {x} implies (PF x)
                 (combine (unitperm (nonlinear (neg (objequal x null)))) (PF x))}
    true.

- : ty2perm2-duplicate-notnull-info
    (ty2perm2/borrow (ty2perm/ _ nn2perm/yes _))
    ([_] implies/trans
      (implies/combine implies/duplicate implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))).

- : ty2perm2-duplicate-notnull-info
    (ty2perm2/unique (ty2perm/ _ nn2perm/yes _))
    ([_] implies/trans
      (implies/combine implies/duplicate implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))).

- : ty2perm2-duplicate-notnull-info
    (ty2perm2/shared (ty2perm/ _ nn2perm/yes _))
    ([_] implies/trans
      (implies/combine implies/duplicate implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))).

%worlds (gtermvar) (ty2perm2-duplicate-notnull-info _ _).
%total { } (ty2perm2-duplicate-notnull-info _ _).


%%% theorems about cxt2perm

%theorem false-implies-cxt2perm
  : forall* {PM} {B} {Pi}
    forall {F:void} exists {B2P: cxt2perm PM B Pi}
    true.

%worlds () (false-implies-cxt2perm _ _).
%total { } (false-implies-cxt2perm _ _).


%theorem cxt2perm-respects-eq
  : forall* {PM} {B} {Pi} {PM'} {B'} {Pi'}
    forall {B2P: cxt2perm PM B Pi}
    {PME: predmap`eq PM PM'}
    {BE: cxt`eq B B'} {PE: permission`eq Pi Pi'}
    exists {B2P': cxt2perm PM' B' Pi'}
    true.

- : cxt2perm-respects-eq B2P predmap`eq/ cxt`eq/ permission`eq/ B2P.

%worlds (gtermvar) (cxt2perm-respects-eq _ _ _ _ _).
%total { } (cxt2perm-respects-eq _ _ _ _ _).


%theorem clsmap-cxt-implies-cxt2perm
  : forall* {CM} {PM} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    exists {Pi:permission}
    {B=>Pi: cxt2perm PM B Pi}
    true.

- : clsmap-cxt-implies-cxt2perm _ _ clsmap-cxt/0 _ cxt2perm/0.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/U CM-B' (clsmap-ty/ L) BF BU)
    _ (cxt2perm/U B2P' BF BU T2PF)
    <- clsmap-lookup-implies-ty2perm2 CM-CM CM2PM L _ T2PF
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B' _ B2P'.

%worlds (gtermvar) (clsmap-cxt-implies-cxt2perm _ _ _ _ _).
%total (CM-B) (clsmap-cxt-implies-cxt2perm _ _ CM-B _ _).


%theorem cxt2perm/U-inversion
  : forall* {PM} {B} {Pi} {BP} {N} {O} {T}
    forall {B2P: cxt2perm PM B Pi}
    {F: cxt`fresh BP N}
    {U: cxt`update BP N (cxt-info/ O T) B}
    exists {PiP} {BP2P: cxt2perm PM BP PiP}
    {PF} {T2P: ty2perm2 PM T PF}
    {E: equiv Pi (combine (PF O) PiP)}
    true.

%theorem cxt2perm/U-inversion/L
  : forall* {PM} {B} {BP} {N} {O} {T} {B1} {N1} {O1} {T1} {PF1} {Pi1} {P}
    forall {B2P1: cxt2perm PM B1 Pi1}
    {F1: cxt`fresh B1 N1}
    {U1: cxt`update B1 N1 (cxt-info/ O1 T1) B}
    {R1: ty2perm2 PM T1 PF1}
    {F: cxt`fresh BP N}
    {U: cxt`update BP N (cxt-info/ O T) B}
    {E?: nat`eq? N N1 P}
    exists {PiP} {BP2P: cxt2perm PM BP PiP}
    {PF} {R: ty2perm2 PM T PF}
    {E: equiv (combine (PF1 O1) Pi1) (combine (PF O) PiP)}
    true.

- : cxt2perm/U-inversion/L B2P1 F1 U1 R1 F2 U2 nat`eq?/yes _ B2P _ R
    (equiv/combine PEQV equiv/reflexive)
    <- cxt`fresh-update-cancels F1 U1 F2 U2 nat`eq/ cxt`eq/ CIE BE
    <- cxt2perm-respects-eq B2P1 predmap`eq/ BE permission`eq/ B2P
    <- cxt-info-eq-inversion CIE (OE:object`eq O O') TE
    <- ty2perm2-respects-eq (R1:ty2perm2 PM _ PF)
      predmap`eq/ TE ([_] permission`eq/) R
    <- permission`apply-object-preserves-eq
      (([_] permission`eq/):({o} permission`eq (PF o) (PF o))) OE PE
    <- permission`eq-implies-equiv PE PEQV.

- : cxt2perm/U-inversion/L B2P1 F1 U1 R1 F2 U2 (nat`eq?/no N<>N1)
    _ (cxt2perm/U B2P2 F4 U4 R1) _ R
    (equiv/transitive (equiv/combine equiv/reflexive EQV1) equiv/roll2)
    <- cxt`update-commutes-converse U2 U1 N<>N1 _ U4 U3
    <- cxt`update-preserves-fresh-converse F2 U4 F3
    <- cxt`update-preserves-fresh-converse F1 U3 F4
    <- cxt2perm/U-inversion B2P1 F3 U3 _ B2P2 _ R EQV1.

- : cxt2perm/U-inversion (cxt2perm/U B2P0 F0 U0 R0) F1 U1 _ B2P _ R EQV
    <- nat`eq?-total E?
    <- cxt2perm/U-inversion/L B2P0 F0 U0 R0 F1 U1 E? _ B2P _ R EQV.

%worlds (gtermvar) (cxt2perm/U-inversion _ _ _ _ _ _ _ _)
  (cxt2perm/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _).
%total (R R0) (cxt2perm/U-inversion R _ _ _ _ _ _ _)
  (cxt2perm/U-inversion/L R0 _ _ _ _ _ _ _ _ _ _ _).


%theorem cxt2perm-equiv
  : forall* {PM} {PM'} {B} {B'} {Pi} {Pi'}
    forall {B=>Pi: cxt2perm PM B Pi}
    {B=>Pi': cxt2perm PM' B' Pi'}
    {PME: predmap`eq PM PM'} {BE: cxt`eq B B'}
    exists {EQV: equiv Pi Pi'}
    true.

- : cxt2perm-equiv cxt2perm/0 cxt2perm/0 _ _ equiv/reflexive.

- : cxt2perm-equiv
    (cxt2perm/U B2P0 F0 (U0:cxt`update _ _ (cxt-info/ O T) _)
      (R0:ty2perm2 PM0 T PF0)) B2P PME BE
    (equiv/transitive
      (equiv/combine (EQV3 O) EQV2)
      (equiv/symmetric EQV1))
    <- cxt2perm/U-inversion B2P F0 U0 _ B2P1 _ (R1:ty2perm2 PM1 T PF1) EQV1
    <- cxt2perm-equiv B2P0 B2P1 PME cxt`eq/ EQV2
    <- ty2perm2-equiv R0 R1 PME ty`eq/ EQV3.

%worlds (gtermvar) (cxt2perm-equiv _ _ _ _ _).
%total (T) (cxt2perm-equiv T _ _ _ _).


%theorem cxt2perm-lookup-not-shared-can-duplicate
  : forall* {PM} {B} {PiB} {N} {O} {NN} {A} {C}
    forall {B=>PiB: cxt2perm PM B PiB}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {U-OR-B: not-shared A}
    exists {PF} {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {IMP: implies PiB (combine (PF O) PiB)}
    true.

- : cxt2perm-lookup-not-shared-can-duplicate
    B=>PiB (BL:cxt`lookup B N (cxt-info/ O _)) not-shared/borrow _ T2PF
    (implies/trans4
      (implies/equiv EQV)
      (implies/combine (IMP2 O) implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive (implies/equiv (equiv/symmetric EQV))))
    <- cxt`lookup-implies-fresh-update BL BP N!<BP BP+N=B
    <- cxt2perm/U-inversion B=>PiB N!<BP BP+N=B PiBP BP=>PiBP _
      (ty2perm2/borrow T2PF) EQV
    <- can-duplicate-borrow T2PF IMP2.

- : cxt2perm-lookup-not-shared-can-duplicate
    B=>PiB (BL:cxt`lookup B N (cxt-info/ O _)) not-shared/unique _ T2PF
    (implies/trans4
      (implies/equiv EQV)
      (implies/combine (IMP2 O) implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive (implies/equiv (equiv/symmetric EQV))))
    <- cxt`lookup-implies-fresh-update BL BP N!<BP BP+N=B
    <- cxt2perm/U-inversion B=>PiB N!<BP BP+N=B PiBP BP=>PiBP _
      (ty2perm2/unique T2PF) EQV
    <- can-duplicate-borrow T2PF IMP2.

%worlds (gtermvar) (cxt2perm-lookup-not-shared-can-duplicate _ _ _ _ _ _).
%total { } (cxt2perm-lookup-not-shared-can-duplicate _ _ _ _ _ _).


%theorem cxt2perm-duplicate-notnull-info
  : forall* {PM} {N} {Pi} {O} {A} {C} {B}
    forall {B2P: cxt2perm PM B Pi}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ nn/yes A C))}
    exists {IMP: implies Pi (combine (unitperm (nonlinear (neg (objequal O null)))) Pi)}
    true.

- : cxt2perm-duplicate-notnull-info B2P BL
    (implies/trans4
      (implies/equiv EQV)
      (implies/combine (IMP _) implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive (implies/equiv (equiv/symmetric EQV))))
    <- cxt`lookup-implies-fresh-update BL BP N!<BP BP+N=B
    <- cxt2perm/U-inversion B2P N!<BP BP+N=B _ B2PP _ T2PF2 EQV
    <- ty2perm2-duplicate-notnull-info T2PF2 IMP.

%worlds (gtermvar) (cxt2perm-duplicate-notnull-info _ _ _).
%total { } (cxt2perm-duplicate-notnull-info _ _ _).


%%% theorems about create-fldperm

%theorem create-fldperm-unique
  : forall* {CM1} {CM2} {PM1} {PM2} {C1} {C2} {F1} {F2} {PF1} {PF2}
    forall {CF1: create-fldperm CM1 PM1 C1 F1 PF1}
    {CF2: create-fldperm CM2 PM2 C2 F2 PF2}
    {EQ: clsmap`eq CM1 CM2}
    {EQ: predmap`eq PM1 PM2}
    {EQ: nat`eq C1 C2}
    {EQ: nat`eq F1 F2}
    exists {EQ: {x} permission`eq (PF1 x) (PF2 x)}
    true.

- : create-fldperm-unique
    (create-fldperm/ CML1 FML1 T2PF1) (create-fldperm/ CML2 FML2 T2PF2)
    CME PME CE FE PE
    <- clsmap`lookup-unique CML1 CML2 CME CE FME
    <- fldmap`lookup-unique FML1 FML2 FME FE TE
    <- ty2perm-deterministic T2PF1 T2PF2 PME TE PE.

%worlds (gtermvar) (create-fldperm-unique _ _ _ _ _ _ _).
%total { } (create-fldperm-unique _ _ _ _ _ _ _).


%% Theorems about make-encumbered

%theorem false-implies-make-encumbered
  : forall* {CM} {PM} {B} {S} {Pi}
    forall {V:void} exists {MF: make-encumbered CM PM B S Pi}
    true.

%worlds (gtermvar) (false-implies-make-encumbered _ _).
%total { } (false-implies-make-encumbered _ _).


%theorem make-encumbered-respects-eq
  : forall* {PM1} {PM2} {CM1} {CM2} {B1} {B2} {S1} {S2} {Pi1} {Pi2}
    forall {MFP1: make-encumbered CM1 PM1 B1 S1 Pi1}
    {CME: clsmap`eq CM1 CM2}
    {PME: predmap`eq PM1 PM2}
    {BE: cxt`eq B1 B2} {SE: set`eq S1 S2}
    {PE: permission`eq Pi1 Pi2}
    exists {MFP2: make-encumbered CM2 PM2 B2 S2 Pi2}
    true.

- : make-encumbered-respects-eq MFP clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/
    permission`eq/ MFP.

%worlds (gtermvar) (make-encumbered-respects-eq _ _ _ _ _ _ _).
%total {} (make-encumbered-respects-eq _ _ _ _ _ _ _).


%theorem make-encumbered/U-inversion
  : forall* {CM} {PM} {B} {S} {Pi} {SP} {N}
    forall {MF: make-encumbered CM PM B S Pi}
    {NM: set`not-member SP N}
    {UD: set`add SP N S}
    exists {Pi1} {MFP: make-encumbered CM PM B SP Pi1}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    {CP} {PML: predmap`lookup PM C CP}
    {FS} {DM: fldmap`domain FM FS}
    {PiP} {MF1: {x} fldset2perm PM x FM FS (PiP x)}
    {EQV: equiv Pi ((encumbered-fldperm O PiP CP), Pi1)}
    true.

%theorem make-encumbered/U-inversion/L
  : forall* {CM} {PM} {B} {S} {SP} {N} {S1} {Pi1} {N1} {O1} {NN1}
    {A1} {C1} {FM1} {FS1} {PiP1} {P} {CP1}
    forall {MF1: make-encumbered CM PM B S1 Pi1}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {CML1: clsmap`lookup CM C1 FM1}
    {PML1: predmap`lookup PM C1 CP1}
    {DM1: fldmap`domain FM1 FS1}
    {MF11: {x} fldset2perm PM x FM1 FS1 (PiP1 x)}
    {NM1: set`not-member S1 N1}
    {U1: set`add S1 N1 S}
    {NM: set`not-member SP N}
    {U: set`add SP N S}
    {E?: nat`eq? N N1 P}
    exists {Pi} {MFP: make-encumbered CM PM B SP Pi}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    {CP} {PML: predmap`lookup PM C CP}
    {FS} {DM: fldmap`domain FM FS}
    {PiP} {MF1: {x} fldset2perm PM x FM FS (PiP x)}
    {EQV: equiv ((encumbered-fldperm O1 PiP1 CP1) , Pi1)
          ((encumbered-fldperm O PiP CP) , Pi)}
    true.

- : make-encumbered/U-inversion/L MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1 F2 U2
    nat`eq?/yes %{=>}% _ MF _ _ _ _ BL1 _ CML1 _ PML1 _ DM1 _ MFO1 equiv/reflexive
    <- set`not-member-add-cancels F1 U1 F2 U2 nat`eq/ set`eq/ SE
    <- make-encumbered-respects-eq MF1 clsmap`eq/ predmap`eq/ cxt`eq/ SE
      permission`eq/ MF.

- : make-encumbered/U-inversion/L MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1 F2 U2
    (nat`eq?/no N<>N1) %{=>}%
    _ (make-encumbered/U MF2 BL1 CML1 PML1 DM1 MFO1 F4 U4)
    _ _ _ _ BL2 _ CML2 _ PML2 _ DM2 _ MFO2
    (equiv/transitive
      (equiv/combine equiv/reflexive EQV)
      (equiv/roll2))
    <- set`add-commutes-converse U2 U1 N<>N1 _ U4 U3
    <- set`add-preserves-not-member-converse F2 U4 F3
    <- set`add-preserves-not-member-converse F1 U3 F4
    <- make-encumbered/U-inversion MF1 F3 U3 _ MF2 _ _ _ _ BL2 _ CML2 _ PML2 _ DM2
      _ MFO2 EQV.

- : make-encumbered/U-inversion (make-encumbered/U MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1)
    F2 U2 _ MF _ _ _ _ BL _ CML _ PML _ DM _ MFO EQV
    <- nat`eq?-total E?
    <- make-encumbered/U-inversion/L MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1
      F2 U2 E? _ MF _ _ _ _ BL _ CML _ PML _ DM _ MFO EQV.

%worlds (gtermvar) (make-encumbered/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  (make-encumbered/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N N0) (make-encumbered/U-inversion N _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  (make-encumbered/U-inversion/L N0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem make-encumbered-equiv
  : forall* {CM} {PM} {B} {Q} {Pi} {CM'} {PM'} {B'} {Q'} {Pi'}
    forall {MF: make-encumbered CM PM B Q Pi}
    {MF': make-encumbered CM' PM' B' Q' Pi'}
    {CME: clsmap`eq CM CM'} {PME: predmap`eq PM PM'}
    {BE: cxt`eq B B'} {QE: set`eq Q Q'}
    exists {EQV: permission`equiv Pi Pi'}
    true.

%theorem make-encumbered-equiv/L
  : forall* {PF1} {PF2} {CP1} {CP2}
    forall {O1} {O2}
    {EQ: object`eq O1 O2}
    {EQ: predicate`eq CP1 CP2}
    {EQV: {x} permission`eq (PF1 x) (PF2 x)}
    exists {IMP1: permission`eq (encumbered-fldperm O1 PF1 CP1)
                  (encumbered-fldperm O2 PF2 CP2)}
    true.

- : make-encumbered-equiv/L _ _
    object`eq/ predicate`eq/ ([_] permission`eq/) (permission`eq/).

- : make-encumbered-equiv make-encumbered/0 make-encumbered/0 _ _ _ _ equiv/reflexive.

- : make-encumbered-equiv MF
    (make-encumbered/U MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1) CME PME BE SE
    (equiv/transitive
      (EQV1)
      (equiv/combine EQV2 EQV))
    <- make-encumbered/U-inversion MF F1 U1 _ MF0 _ _ _ _ BL0
      _ CML0 _ PML0 _ DM0 _ MFO0 EQV1
    <- cxt`lookup-unique BL0 BL1 BE nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE TE
    <- ty-eq-inversion TE NNE AE CE
    <- clsmap`lookup-unique CML0 CML1 CME CE FME
    <- predmap`lookup-unique PML0 PML1 PME CE CPE
    <- fldmap`domain-unique DM0 DM1 FME FSE
    <- ({x} fldset2perm-unique (MFO0 x) (MFO1 x) PME object`eq/ FME FSE (PEQ x))
    <- make-encumbered-equiv MF0 MF1 CME PME BE set`eq/ EQV
    <- make-encumbered-equiv/L _ _ OE CPE PEQ PEQ'
    <- permission`eq-implies-equiv PEQ' EQV2.

%worlds (gtermvar) (make-encumbered-equiv/L _ _ _ _ _ _).
%total { } (make-encumbered-equiv/L _ _ _ _ _ _).

%worlds (gtermvar) (make-encumbered-equiv _ _ _ _ _ _ _).
%total (K) (make-encumbered-equiv _ K _ _ _ _ _).


%theorem clsmap-cxt-objset-implies-make-encumbered
  : forall* {CM} {PM} {B} {U}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-U: clsmap-cxt-objset CM B U}
    exists {Pi} {U=>Pi: make-encumbered CM PM B U Pi}
    true.

- : clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM
    clsmap-cxt-objset/0 _ make-encumbered/0.

- : clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM
    (clsmap-cxt-objset/U CM-B-U' BL CML F U) _
    (make-encumbered/U U'=>Pi' BL CML PML FM-DM FM=>PF F U)
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- fldmap`domain-total FM-DM
    <- set`leq-reflexive _ LE
    <- ({x} fldset2perm-total CM-CM CM2PM CML FM-DM LE _ (FM=>PF x))
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-B-U' _ U'=>Pi'.

%worlds (gtermvar) (clsmap-cxt-objset-implies-make-encumbered _ _ _ _ _).
%total (A) (clsmap-cxt-objset-implies-make-encumbered _ _ A _ _).


%theorem cxt-fresh-update-preserves-make-encumbered
  : forall* {CM} {PM} {B0} {B1} {O} {U} {PiU} {N} {CI}
    forall {ME: make-encumbered CM PM B0 U PiU}
    {N!<B0: cxt`fresh B0 N}
    {B0+N=B1: cxt`update B0 N (cxt-info/ O CI) B1}
    exists {ME: make-encumbered CM PM B1 U PiU}
    true.

- : cxt-fresh-update-preserves-make-encumbered
    (make-encumbered/U B0+U'=>PiU' B0-L CML PML FM-DM=FS ([x] FS=>PF x)
      N!<U' U'+N=U)
    N!<B0 B0+N=B1
    (make-encumbered/U B1+U'=>PiU' B1-L CML PML FM-DM=FS ([x] FS=>PF x)
      N!<U' U'+N=U)
    <- cxt`fresh-update-preserves-lookup B0-L N!<B0 B0+N=B1 B1-L
    <- cxt-fresh-update-preserves-make-encumbered B0+U'=>PiU' N!<B0 B0+N=B1 B1+U'=>PiU'.

- : cxt-fresh-update-preserves-make-encumbered make-encumbered/0 _ _ make-encumbered/0.

%worlds (gtermvar) (cxt-fresh-update-preserves-make-encumbered _ _ _ _).
%total (ME) (cxt-fresh-update-preserves-make-encumbered ME _ _ _).


%theorem make-encumbered-combines
  : forall* {CM} {PM} {B} {U0} {U1} {U} {PiU0} {PiU1}
    forall {U0=>PiU0: make-encumbered CM PM B U0 PiU0}
    {U1=>PiU1: make-encumbered CM PM B U1 PiU1}
    {U0+U1=U: set`combine U0 U1 U}
    exists {PiU} {U=>PiU: make-encumbered CM PM B U PiU}
    {EQV: equiv (PiU0 , PiU1) PiU}
    true.

%worlds (gtermvar) (make-encumbered-combines _ _ _ _ _ _).
%trustme %total { } (make-encumbered-combines _ _ _ _ _ _).


%theorem make-encumbered-combines-converse
  : forall* {CM} {PM} {B} {U0} {U1} {U} {PiU}
    forall {U=>PiU: make-encumbered CM PM B U PiU}
    {U0+U1=U: set`combine U0 U1 U}
    exists {PiU0} {PiU1} {U0=>PiU0: make-encumbered CM PM B U0 PiU0}
    {U1=>PiU1: make-encumbered CM PM B U1 PiU1}
    {EQV: equiv (PiU0 , PiU1) PiU}
    true.

%worlds (gtermvar) (make-encumbered-combines-converse _ _ _ _ _ _ _).
%trustme %total { } (make-encumbered-combines-converse _ _ _ _ _ _ _).


%% theorems about capset2perm

%theorem false-implies-capset2perm
  : forall* {CM} {PM} {B} {M} {Pi}
    forall  {V: void}
    exists  {M=>Pi: capset2perm CM PM B M Pi}
    true.

%worlds (gtermvar) (false-implies-capset2perm _ _).
%total {} (false-implies-capset2perm _ _).


%theorem capset2perm-respects-eq
  : forall* {CM1} {PM1} {B1} {M1} {Pi1}
    {CM2} {PM2} {B2} {M2} {Pi2}
    forall  {M1=>Pi1: capset2perm CM1 PM1 B1 M1 Pi1}
    {E: clsmap`eq CM1 CM2} {E: predmap`eq PM1 PM2}
    {E: cxt`eq B1 B2} {E: set`eq M1 M2}
    {E: permission`eq Pi1 Pi2}
    exists  {M2=>Pi2: capset2perm CM2 PM2 B2 M2 Pi2}
    true.

- : capset2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/
    cxt`eq/ set`eq/ permission`eq/ M=>Pi.

%worlds (gtermvar) (capset2perm-respects-eq _ _ _ _ _ _ _).
%total {} (capset2perm-respects-eq _ _ _ _ _ _ _).


%theorem clsmap-cxt-capset-implies-capset2perm
  : forall* {CM} {PM} {B} {M}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-M: clsmap-cxt-capset CM B M}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    true.

- : clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM
    clsmap-cxt-capset/0 _ capset2perm/0.

- : clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM
    (clsmap-cxt-capset/U CM-B-M' N+F=>K BL NS CML FML K!<M' M'+K+X=M)
    _ (capset2perm/U M'=>Pi' N+F=>K BL (create-fldperm/ CML FML T2PF)
        K!<M' M'+K+X=M)
    <- set`update-implies-lookup M'+K+X=M M->K=X
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-B-M' _ M'=>Pi'
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF.

- : clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM
    (clsmap-cxt-capset/z CM-B-M' Z!<M' M'+Z=M)
    _ (capset2perm/z M'=>Pi' Z!<M' M'+Z=M)
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-B-M' _ M'=>Pi'.

%worlds (gtermvar) (clsmap-cxt-capset-implies-capset2perm _ _ _ _ _).
%total (T) (clsmap-cxt-capset-implies-capset2perm _ _ T _ _).


%theorem clsmap-cxt-unique-capset-implies-capset2perm
  : forall* {CM} {PM} {B} {M} {NN} {C}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-M: clsmap-cxt-unique-capset CM B NN C M}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    true.

- : clsmap-cxt-unique-capset-implies-capset2perm CM-CM CM2PM CM-B-NN-C-M _ M=>Pi
    <- clsmap-cxt-unique-capset-implies-clsmap-cxt-capset CM-B-NN-C-M CM-B-M
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-B-M _ M=>Pi.

%worlds (gtermvar) (clsmap-cxt-unique-capset-implies-capset2perm _ _ _ _ _).
%total { } (clsmap-cxt-unique-capset-implies-capset2perm _ _ _ _ _).


%theorem capset2perm/U-inversion
  : forall* {M} {MP} {CM} {PM} {K} {Pi} {B}
    forall {M2P: capset2perm CM PM B M Pi}
    {FS: set`not-member MP (s K)}
    {U: set`add MP (s K) M}
    exists {N} {F} {K=>N+F: nat2pair (s K) (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {PF} {CT-PF: create-fldperm CM PM C F PF}
    {Pi2} {M2P: capset2perm CM PM B MP Pi2}
    {EQV: equiv
      (combine (unitperm (conditional (objequal O null) empty (fldperm O F PF))) Pi2) Pi}
    true.

- : capset2perm/U-inversion
    (capset2perm/z M2P F1 U1) F U
    _ _ N2P _ _ _ _ BL _ CT-PF _ (capset2perm/z M2P2 F3 U3)
    (equiv/transitive
      (equiv/roll2)
      (equiv/combine equiv/reflexive (EQV)))
    <- nat`succ-implies-gt-zero _ GT
    <- set`update-commutes-converse U U1 (nat`ne/> GT) M U3 U2
    <- set`update-preserves-not-member-converse F U3 F2
    <- set`update-preserves-not-member-converse F1 U2 F3
    <- capset2perm/U-inversion M2P F2 U2 _ _ N2P _ _ _ _ BL _ CT-PF _ M2P2 EQV.

%theorem capset2perm/U-inversion/L
  : forall* {BP} {M} {B} {CM} {PM} {K} {K1} {PF1}
    {MP1} {MP} {Pi21} {NN1} {A1} {C1} {N1} {F1} {O1}
    forall {FS1: set`not-member MP1 (s K1)}
    {U1: set`add MP1 (s K1) M}
    {K=>N+F: nat2pair (s K1) (pair/ N1 F1)}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {CT-PF: create-fldperm CM PM C1 F1 PF1}
    {M2P: capset2perm CM PM B MP1 Pi21}
    {FS2: set`not-member MP (s K)}
    {U2: set`add MP (s K) M}
    {EQ: nat`eq? (s K) (s K1) BP}
    exists {N} {F} {K=>N+F: nat2pair (s K) (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {PF} {CT-PF: create-fldperm CM PM C F PF}
    {Pi2} {M2P: capset2perm CM PM B MP Pi2}
    {EQV: equiv
          (combine (unitperm (conditional (objequal O null) empty (fldperm O F PF))) (Pi2))
          (combine (unitperm (conditional (objequal O1 null) empty (fldperm O1 F1 PF1))) Pi21)}
    true.

- : capset2perm/U-inversion/L F1 U1 N2P1 BL1 CT-PF1 M2P1 F2 U2
    nat`eq?/yes _ _ N2P1 _ _ _ _ BL1 _ CT-PF1 _ M2P equiv/reflexive
    <- set`not-member-update-cancels F1 U1 F2 U2 nat`eq/ set`eq/ X1=X2 M1=M2
    <- capset2perm-respects-eq M2P1 clsmap`eq/ predmap`eq/ cxt`eq/ M1=M2 permission`eq/ M2P.

- : capset2perm/U-inversion/L F1 U1 N2P1 BL1 CT-PF1 M2P1 F2 U2
    (nat`eq?/no K<>K1) _ _ N2P2 _ _ _ _ BL2 _ CT-PF2 _
    (capset2perm/U M2P2 N2P1 BL1 CT-PF1 F4 U4)
    (equiv/transitive equiv/roll2 (equiv/combine equiv/reflexive EQV))
    <- set`update-commutes-converse U2 U1 K<>K1 _ U4 U3
    <- set`update-preserves-not-member-converse F2 U4 F3
    <- set`update-preserves-not-member-converse F1 U3 F4
    <- capset2perm/U-inversion M2P1 F3 U3 _ _ N2P2 _ _ _ _ BL2 _ CT-PF2 _ M2P2 EQV.

- : capset2perm/U-inversion
    (capset2perm/U M2P1 N2P1 BL1 CT-PF1 F1 U1) F2 U2 _ _ N2P _ _ _ _ BL _ CT-PF _ M2P EQV
    <- nat`eq?-total E?
    <- capset2perm/U-inversion/L
      F1 U1 N2P1 BL1 CT-PF1 M2P1 F2 U2 E? _ _ N2P _ _ _ _ BL _ CT-PF _ M2P EQV.

%worlds (gtermvar)
	(capset2perm/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(capset2perm/U-inversion/L _ _ _ _ _ _ _ _  _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A B)
	(capset2perm/U-inversion A _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(capset2perm/U-inversion/L _ _ _ _ _ B _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem capset2perm/U-inversion*
  : forall* {M} {MP} {CM} {PM} {K} {Pi} {B} {N} {F}
    {NN} {A} {C} {O} {PF}
    forall {M2P: capset2perm CM PM B M Pi}
    {FS: set`not-member MP (s K)}
    {U: set`add MP (s K) M}
    {K=>N+F: nat2pair (s K) (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {CT-PF: create-fldperm CM PM C F PF}
    exists {Pi2} {M2P: capset2perm CM PM B MP Pi2}
    {EQV: equiv
      (combine (unitperm (conditional (objequal O null) empty (fldperm O F PF))) Pi2) Pi}
    true.

%theorem capset2perm/U-inversion*/L
  : forall* {O0} {O1} {F0} {F1} {PF0} {PF1} {Pi}
    forall {EQ: object`eq O1 O0} {EQ: nat`eq F1 F0}
    {EQ: {x} permission`eq (PF1 x) (PF0 x)}
    exists
    {EQV: equiv (combine
            (unitperm
              (conditional (objequal O1 null) empty
                (unitperm
                  (precise-exists O1 F1 ([x:gterm objectk] PF1 x)))))
            Pi)
          (combine
            (unitperm
              (conditional (objequal O0 null) empty
                (unitperm
                  (precise-exists O0 F0 ([x:gterm objectk] PF0 x)))))
            Pi)}
    true.

- : capset2perm/U-inversion*/L object`eq/ nat`eq/ ([_] permission`eq/) equiv/reflexive.

- : capset2perm/U-inversion* M2P FS UD
    (K2P0:nat2pair (s K) (pair/ N0 F0))
    (BL0:cxt`lookup B N0 (cxt-info/ O0 (ty/ NN0 A0 C0)))
    (CF0:create-fldperm CM PM C0 F0 PF0)
    _ M2PP
    (equiv/transitive EQV0 EQV1)
    <- capset2perm/U-inversion M2P FS UD N1 F1 K2P1 O1 NN1 A1 C1 BL1 PF1 CF1 _ M2PP EQV1
    <- nat2pair-unique K2P0 K2P1 nat`eq/ PE
    <- pair-eq-implies-eq PE (N0=N1:nat`eq N0 N1) (F0=F1:nat`eq F0 F1)
    <- cxt`lookup-unique BL0 BL1 cxt`eq/ N0=N1 CIE
    <- cxt-info-eq-inversion CIE O0=O1 TE
    <- ty-eq-inversion TE NN0=NN1 A0=A1 C0=C1
    <- create-fldperm-unique CF0 CF1 clsmap`eq/ predmap`eq/ C0=C1 F0=F1 PF0=PF1
    <- capset2perm/U-inversion*/L O0=O1 F0=F1 PF0=PF1 EQV0.

%worlds (gtermvar) (capset2perm/U-inversion*/L _ _ _ _).
%total { } (capset2perm/U-inversion*/L _ _ _ _).

%worlds (gtermvar) (capset2perm/U-inversion* _ _ _ _ _ _ _ _ _).
%total { } (capset2perm/U-inversion* _ _ _ _ _ _ _ _ _).


%theorem capset2perm/z-inversion
  : forall* {M} {MP} {CM} {PM} {Pi} {B}
    forall {M2P: capset2perm CM PM B M Pi}
    {FS: set`not-member MP shared}
    {U: set`add MP shared M}
    exists {Pi2} {M2P: capset2perm CM PM B MP Pi2}
    {EQV: equiv (combine (unitperm (basic null all null)) Pi2) Pi}
    true.

- : capset2perm/z-inversion
    (capset2perm/U M2P N+F=>K BL CF F1 U1) F U
    _ (capset2perm/U M2P2 N+F=>K BL CF F3 U3)
    (equiv/transitive equiv/roll2 (equiv/combine equiv/reflexive EQV))
    <- nat`succ-implies-gt-zero _ GT
    <- set`update-commutes-converse U U1 (nat`ne/< GT) M U3 U2
    <- set`update-preserves-not-member-converse F U3 F2
    <- set`update-preserves-not-member-converse F1 U2 F3
    <- capset2perm/z-inversion M2P F2 U2 _ M2P2 EQV.

- : capset2perm/z-inversion
    (capset2perm/z M2P F1 U1) F U _ M2P2 equiv/reflexive
    <- set`not-member-update-cancels F1 U1 F U nat`eq/ set`eq/ X1=X M1=M
    <- capset2perm-respects-eq M2P clsmap`eq/ predmap`eq/ cxt`eq/ M1=M permission`eq/ M2P2.

%worlds (gtermvar) (capset2perm/z-inversion _ _ _ _ _ _).
%total (A) (capset2perm/z-inversion A _ _ _ _ _).


%theorem capset2perm-equiv
  : forall* {CM1} {CM2} {PM1} {PM2} {B1} {B2}
    {M1} {M2} {Pi1} {Pi2}
    forall {M1=>Pi1: capset2perm CM1 PM1 B1 M1 Pi1}
    {M2=>Pi2: capset2perm CM2 PM2 B2 M2 Pi2}
    {E: clsmap`eq CM1 CM2}
    {E: predmap`eq PM1 PM2} {E: cxt`eq B1 B2} {E: set`eq M1 M2}
    exists {EQV: equiv Pi1 Pi2}
    true.

%theorem capset2perm-equiv/L/U
  : forall* {F0} {F1} {PF0:object -> permission} {PF1} {O0} {O1} {NN0} {NN1}
    forall {PFE: {x} permission`eq (PF0 x) (PF1 x)}
    {NNE: nonnull`eq NN0 NN1}
    {FE: nat`eq F0 F1}
    {OE: object`eq O0 O1}
    exists {PE: permission`eq
                (unitperm
                  (conditional
                    (objequal O0 null)
                    (empty)
                    (fldperm O0 F0 PF0)))
                (unitperm
                  (conditional
                    (objequal O1 null)
                    (empty)
                    (fldperm O1 F1 PF1)))}
    true.

- : capset2perm-equiv/L/U ([_] permission`eq/) nonnull`eq/
    nat`eq/ object`eq/ permission`eq/.

- : capset2perm-equiv capset2perm/0 capset2perm/0 _ _ _ _ equiv/reflexive.

- : capset2perm-equiv (capset2perm/z M2P0 F0 U0) M2P CME PME BE ME
    (equiv/transitive (equiv/combine equiv/reflexive EQV2) EQV1)
    <- capset2perm/z-inversion M2P F0 U0 _ M2P1 EQV1
    <- capset2perm-equiv M2P0 M2P1 CME PME BE set`eq/ EQV2.

- : capset2perm-equiv (capset2perm/U M2P0 P2K0 L0 R0 F0 U0) M2P CME PME BE ME
    (equiv/transitive (equiv/combine PXEQV EQV2) (EQV1))
    <- capset2perm/U-inversion M2P F0 U0 _ _ P2K1 _ _ _ _ L1 _ R1 _ M2P1 EQV1
    <- capset2perm-equiv M2P0 M2P1 CME PME BE set`eq/ EQV2
    <- nat2pair-unique P2K0 P2K1 nat`eq/ PE
    <- pair-eq-implies-eq PE (NE:nat`eq Nx0 Nx1) (FE:nat`eq Fx0 Fx1)
    <- cxt`lookup-unique L0 L1 BE NE CIE
    <- cxt-info-eq-inversion CIE (OE:object`eq O0 O1) TE
    <- ty-eq-inversion TE (NNE:nonnull`eq NN0 NN1) _ (CE:nat`eq C0 C1)
    <- create-fldperm-unique R0 R1 CME PME CE FE PFE
    <- capset2perm-equiv/L/U PFE NNE FE OE PFE'
    <- permission`eq-implies-equiv PFE' PXEQV.

%worlds (gtermvar) (capset2perm-equiv/L/U _ _ _ _ _).
%total { } (capset2perm-equiv/L/U _ _ _ _ _).

%worlds (gtermvar) (capset2perm-equiv _ _ _ _ _ _ _).
%total (R) (capset2perm-equiv R _ _ _ _ _ _).


%theorem capset`disjoint-join-implies-equiv
  : forall* {M1} {M2} {M} {O} {FM} {PM} {Pi}
    forall {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {M=>Pi: capset2perm O FM PM M Pi}
    exists {Pi1} {Pi2}
    {M1=>Pi1: capset2perm O FM PM M1 Pi1}
    {M2=>Pi2: capset2perm O FM PM M2 Pi2}
    {EQV: equiv Pi (Pi1 , Pi2)}
    true.

- : capset`disjoint-join-implies-equiv _ set`union/L M2P _ _ capset2perm/0 M2P
    (equiv/transitive (equiv/symmetric equiv/identity) equiv/commute).

- : capset`disjoint-join-implies-equiv _ set`union/R M2P
    _ _ M2P capset2perm/0 (equiv/symmetric equiv/identity).

%theorem capset`disjoint-join-implies-equiv/F
  : forall* {CM} {PM} {B} {M1} {M2} {Pix} {Piy}
    forall {V:void}
    exists {Pi1} {Pi2}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {EQV: (equiv (Pix , Piy) (Pi1 , Pi2))}
    true.

%theorem capset`disjoint-join-implies-equiv/L/z
  : forall* {M1} {M2} {M} {MP} {B} {PM} {Piy} {CM} {B1} {B2}
    forall {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {FS: set`not-member MP shared}
    {U: set`add MP shared M}
    {M=>Pi: capset2perm CM PM B MP Piy}
    {IN1?: set`member? M1 shared B1}
    {IN2?: set`member? M2 shared B2}
    exists {Pi1} {Pi2}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {EQV: equiv (combine (unitperm (basic null all null)) Piy) (Pi1 , Pi2)}
    true.

%theorem capset`disjoint-join-implies-equiv/L/U
  : forall* {M1} {M2} {M} {MP} {F} {PF} {B}
    {O} {PM} {Piy} {K} {N} {NN} {A} {CM} {C} {B1} {B2}
    forall {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {FS: set`not-member MP (s K)}
    {U: set`add MP (s K) M}
    {K=>N+F: nat2pair (s K) (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {CT: create-fldperm CM PM C F PF}
    {M=>Pi: capset2perm CM PM B MP Piy}
    {IN1?: set`member? M1 (s K) B1}
    {IN2?: set`member? M2 (s K) B2}
    exists {Pi1} {Pi2}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {EQV: equiv (unitperm
                  (conditional
                    (objequal O null)
                    (empty)
                    (fldperm O F PF)) ,
                  (Piy))
          (Pi1 , Pi2)}
    true.

- : capset`disjoint-join-implies-equiv/L/z DJ J F U M2P
    (set`member?/in L1) (set`member?/in L2) _ _ M2P1 M2P2 EQV
    <- set`disjoint-lookup-contradiction DJ L1 L2 V
    <- capset`disjoint-join-implies-equiv/F V _ _ M2P1 M2P2 EQV.

- : capset`disjoint-join-implies-equiv/L/z DJ J _ U _
    (set`member?/out F1) (set`member?/out F2) _ _ M2P1 M2P2 EQV
    <- set`union-preserves-not-member* F1 F2 J F
    <- set`update-implies-lookup U L
    <- set`not-member-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- capset`disjoint-join-implies-equiv/F V _ _ M2P1 M2P2 EQV.

- : capset`disjoint-join-implies-equiv/L/z DJ (J:set`union M1 M2 M)
    F (U:set`add MP shared M) M2P
    (set`member?/in (L1:set`member M1 shared))
    (set`member?/out F2) _ _
    (capset2perm/z M2P1P F1 U1K) M2P2
    (equiv/transitive (equiv/combine equiv/reflexive EQVP)
      (equiv/associate))
    <- set`member-implies-not-member-add L1 _ F1 U1
    <- set`not-member-update-implies-leq F1 U1 LE1
    <- set`disjoint-respects-geq* DJ LE1 (DJP:set`disjoint M1P M2)
    <- set`not-member-update-implies-unit-union F1 U1 UJ1
    <- set`union-commutative UJ1 UJ1P
    <- set`union-associative UJ1P J M3 (JP:set`union M1P M2 M3) UJ2
    <- set`union-commutative UJ2 UJ2P
    <- set`union-preserves-not-member* F1 F2 JP F3
    <- set`not-member-unit-union-implies-update F3 UJ2P U3
    <- set`not-member-update-cancels F U F3 U3 nat`eq/ set`eq/ DE' ME'
    <- set`eq-symmetric ME' ME
    <- set`union-respects-eq JP set`eq/ set`eq/ ME JP'
    <- capset`disjoint-join-implies-equiv DJP JP' M2P _ _ M2P1P M2P2 EQVP
    <- set`update-respects-eq U1 set`eq/ nat`eq/ unit`eq/ set`eq/ U1K.

- : capset`disjoint-join-implies-equiv/L/z DJ (J:set`union M1 M2 M)
    F (U:set`add MP shared M) M2P
    (set`member?/out F1) (set`member?/in (L2:set`member M2 shared)) _ _
    M2P1 (capset2perm/z M2P2P F2 U2K)
    (equiv/transitive (equiv/combine equiv/reflexive EQVP) equiv/roll2)
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- set`not-member-update-implies-leq F2 U2 (LE2:set`leq M2' M2)
    <- set`disjoint-symmetric DJ DJ'
    <- set`disjoint-respects-geq* DJ' LE2 (DJP:set`disjoint M2' M1)
    <- set`not-member-update-implies-unit-union F2 U2 UJ2
    <- set`union-associative-converse UJ2 J _ (JP:set`union M1 M2' M') UJ2P
    <- set`union-preserves-not-member* F1 F2 JP (F3:set`not-member M' shared)
    <- set`not-member-unit-union-implies-update F3 UJ2P U3
    <- set`not-member-update-cancels F U F3 U3 nat`eq/ set`eq/ DE' ME'
    <- set`eq-symmetric ME' ME
    <- set`union-respects-eq JP set`eq/ set`eq/ ME JP'
    <- set`disjoint-symmetric DJP DJP'
    <- capset`disjoint-join-implies-equiv DJP' JP' M2P _ _ M2P1 M2P2P EQVP
    <- set`update-respects-eq U2 set`eq/ nat`eq/ unit`eq/ set`eq/ U2K.

- : capset`disjoint-join-implies-equiv/L/U DJ J F U N2P BL R M2P
    (set`member?/in L1) (set`member?/in L2) _ _ M2P1 M2P2 EQV
    <- set`disjoint-lookup-contradiction DJ L1 L2 V
    <- capset`disjoint-join-implies-equiv/F V _ _ M2P1 M2P2 EQV.

- : capset`disjoint-join-implies-equiv/L/U DJ J _ U _ _ _ _
    (set`member?/out F1) (set`member?/out F2) _ _ M2P1 M2P2 EQV
    <- set`union-preserves-not-member* F1 F2 J F
    <- set`update-implies-lookup U L
    <- set`not-member-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- capset`disjoint-join-implies-equiv/F V _ _ M2P1 M2P2 EQV.

- : capset`disjoint-join-implies-equiv/L/U DJ (J:set`union M1 M2 M)
    F (U:set`add MP (s K) M) N2P BL R M2P
    (set`member?/in (L1:set`member M1 (s K)))
    (set`member?/out F2) _ _
    (capset2perm/U M2P1P N2P BL R F1 U1K) M2P2
    (equiv/transitive (equiv/combine equiv/reflexive EQVP)
      (equiv/associate))
    <- set`member-implies-not-member-add L1 _ F1 U1
    <- set`not-member-update-implies-leq F1 U1 LE1
    <- set`disjoint-respects-geq* DJ LE1 (DJP:set`disjoint M1P M2)
    <- set`not-member-update-implies-unit-union F1 U1 UJ1
    <- set`union-commutative UJ1 UJ1P
    <- set`union-associative UJ1P J M3 (JP:set`union M1P M2 M3) UJ2
    <- set`union-commutative UJ2 UJ2P
    <- set`union-preserves-not-member* F1 F2 JP F3
    <- set`not-member-unit-union-implies-update F3 UJ2P U3
    <- set`not-member-update-cancels F U F3 U3 nat`eq/ set`eq/ DE' ME'
    <- set`eq-symmetric ME' ME
    <- set`union-respects-eq JP set`eq/ set`eq/ ME JP'
    <- capset`disjoint-join-implies-equiv DJP JP' M2P _ _ M2P1P M2P2 EQVP
    <- set`update-respects-eq U1 set`eq/ nat`eq/ unit`eq/ set`eq/ U1K.

- : capset`disjoint-join-implies-equiv/L/U DJ (J:set`union M1 M2 M)
    F (U:set`add MP (s K) M) N2P BL R M2P
    (set`member?/out F1) (set`member?/in (L2:set`member M2 (s K))) _ _
    M2P1 (capset2perm/U M2P2P N2P BL R F2 U2K)
    (equiv/transitive (equiv/combine equiv/reflexive EQVP) equiv/roll2)
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- set`not-member-update-implies-leq F2 U2 (LE2:set`leq M2' M2)
    <- set`disjoint-symmetric DJ DJ'
    <- set`disjoint-respects-geq* DJ' LE2 (DJP:set`disjoint M2' M1)
    <- set`not-member-update-implies-unit-union F2 U2 UJ2
    <- set`union-associative-converse UJ2 J _ (JP:set`union M1 M2' M') UJ2P
    <- set`union-preserves-not-member* F1 F2 JP (F3:set`not-member M' (s K))
    <- set`not-member-unit-union-implies-update F3 UJ2P U3
    <- set`not-member-update-cancels F U F3 U3 nat`eq/ set`eq/ DE' ME'
    <- set`eq-symmetric ME' ME
    <- set`union-respects-eq JP set`eq/ set`eq/ ME JP'
    <- set`disjoint-symmetric DJP DJP'
    <- capset`disjoint-join-implies-equiv DJP' JP' M2P _ _ M2P1 M2P2P EQVP
    <- set`update-respects-eq U2 set`eq/ nat`eq/ unit`eq/ set`eq/ U2K.

- : capset`disjoint-join-implies-equiv DJ J
    (capset2perm/U M2P N2P BL R F U) _ _ M2P1 M2P2 EQV
    <- set`member?-total D1?
    <- set`member?-total D2?
    <- capset`disjoint-join-implies-equiv/L/U DJ J F U N2P BL R M2P
      D1? D2? _ _ M2P1 M2P2 EQV.

- : capset`disjoint-join-implies-equiv DJ J
    (capset2perm/z M2P F U) _ _ M2P1 M2P2 EQV
    <- set`member?-total D1?
    <- set`member?-total D2?
    <- capset`disjoint-join-implies-equiv/L/z DJ J F U M2P
      D1? D2? _ _ M2P1 M2P2 EQV.

%worlds (gtermvar) (capset`disjoint-join-implies-equiv/F _ _ _ _ _ _).
%total { } (capset`disjoint-join-implies-equiv/F _ _ _ _ _ _).

%worlds (gtermvar) (capset`disjoint-join-implies-equiv _ _ _ _ _ _ _ _)
  (capset`disjoint-join-implies-equiv/L/U _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  (capset`disjoint-join-implies-equiv/L/z _ _ _ _ _ _ _ _ _ _ _ _).
%total (T1 T2 T3) (capset`disjoint-join-implies-equiv _ _ T1 _ _ _ _ _)
  (capset`disjoint-join-implies-equiv/L/U _ _ _ _ _ _ _ T2 _ _ _ _ _ _ _)
  (capset`disjoint-join-implies-equiv/L/z _ _ _ _ T3 _ _ _ _ _ _ _).


%theorem capset`disjoint-join-implies-equiv-converse
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2}
    forall {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

%theorem capset`disjoint-join-implies-equiv-converse/L
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2}
    forall {N} {Z: set`size M N}
    {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

- : capset`disjoint-join-implies-equiv-converse/L
    z _ _ set`union/L capset2perm/0 M2P _ M2P
    (equiv/transitive equiv/commute equiv/identity).

- : capset`disjoint-join-implies-equiv-converse/L
    z _ _ set`union/R M2P capset2perm/0 _ M2P equiv/identity.

%theorem capset`disjoint-join-implies-equiv-converse/F
  : forall* {CM} {PM} {B} {M} {Pi1} {Pi2}
    forall {V:void}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

%theorem capset`disjoint-join-implies-equiv-converse/LL
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2} {MP} {K} {B1} {B2}
    forall {N} {Z: set`size M N}
    {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {F: set`not-member MP K}
    {U: set`add MP K M}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {D1?: set`member? M1 K B1}
    {D2?: set`member? M2 K B2}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z DJ J
    F U A1 A2 (set`member?/in L1) (set`member?/in L2) _ M2P EQV
    <- set`disjoint-lookup-contradiction DJ L1 L2 V
    <- capset`disjoint-join-implies-equiv-converse/F V _ M2P EQV.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z _ J
    _ U A1 A2 (set`member?/out F1) (set`member?/out F2) _ M2P EQV
    <- set`union-preserves-not-member* F1 F2 J F
    <- set`update-implies-lookup U L
    <- set`not-member-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- capset`disjoint-join-implies-equiv-converse/F V _ M2P EQV.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z DJ
    (J:set`union M1 M2 M) F (U:set`add MP shared M) A1 A2
    (set`member?/in _) (set`member?/out F2)
    _ (capset2perm/z AP F U)
    (equiv/transitive3
      (equiv/combine (equiv/symmetric EQV1) equiv/reflexive)
      (equiv/symmetric equiv/associate)
      (equiv/combine equiv/reflexive EQVP))
    <- set`update-implies-lookup U L
    <- set`not-member-union-right-preserves-lookup-converse L F2 J L1
    <- set`member-implies-not-member-add L1 M1P F1 U1
    <- capset2perm/z-inversion A1 F1 U1 _ A1P EQV1
    <- set`not-member-update-left-preserves-union-converse* F1 U1 F2 J F U J1
    <- set`not-member-update-implies-leq F1 U1 LE1
    <- set`disjoint-respects-geq* DJ LE1 DJP
    <- set`not-member-update-increases-size-converse Z F U Z1
    <- capset`disjoint-join-implies-equiv-converse/L N Z1 DJP J1 A1P A2 _ AP EQVP.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z DJ
    (J:set`union M1 M2 M) F (U:set`add MP (s K) M) A1 A2
    (set`member?/in _) (set`member?/out F2)
    _ (capset2perm/U AP N2P BL R F U)
    (equiv/transitive3
      (equiv/combine (equiv/symmetric EQV1) equiv/reflexive)
      (equiv/symmetric equiv/associate)
      (equiv/combine equiv/reflexive EQVP))
    <- set`update-implies-lookup U L
    <- set`not-member-union-right-preserves-member-converse L F2 J L1
    <- set`member-implies-not-member-add L1 M1P F1 U1
    <- capset2perm/U-inversion A1 F1 U1 _ _ N2P _ _ _ _ BL _ R _ A1P EQV1
    <- set`not-member-update-left-preserves-union-converse* F1 U1 F2 J F U J1
    <- set`not-member-update-implies-leq F1 U1 LE1
    <- set`disjoint-respects-geq* DJ LE1 DJP
    <- set`not-member-update-increases-size-converse Z F U Z1
    <- capset`disjoint-join-implies-equiv-converse/L N Z1 DJP J1 A1P A2 _ AP EQVP.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z DJ
    (J:set`union M1 M2 M) F (U:set`add MP shared M) A1 A2
    (set`member?/out F1) (set`member?/in _)
    _ (capset2perm/z AP F U)
    (equiv/transitive3
      (equiv/combine equiv/reflexive (equiv/symmetric EQV2))
      (equiv/roll2)
      (equiv/combine equiv/reflexive EQVP))
    <- set`update-implies-lookup U L
    <- set`not-member-union-left-preserves-lookup-converse F1 L J L2
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- capset2perm/z-inversion A2 F2 U2 _ A2P EQV2
    <- set`not-member-update-right-preserves-union-converse* F1 F2 U2 J F U J2
    <- set`not-member-update-implies-leq F2 U2 LE2
    <- set`disjoint-symmetric DJ DJ'
    <- set`disjoint-respects-geq* DJ' LE2 DJP'
    <- set`disjoint-symmetric DJP' DJP
    <- set`not-member-update-increases-size-converse Z F U Z1
    <- capset`disjoint-join-implies-equiv-converse/L N Z1 DJP J2 A1 A2P _ AP EQVP.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z DJ
    (J:set`union M1 M2 M) F (U:set`add MP (s K) M) A1 A2
    (set`member?/out F1) (set`member?/in _)
    _ (capset2perm/U AP N2P BL R F U)
    (equiv/transitive3
      (equiv/combine equiv/reflexive (equiv/symmetric EQV2))
      (equiv/roll2)
      (equiv/combine equiv/reflexive EQVP))
    <- set`update-implies-lookup U L
    <- set`not-member-union-left-preserves-lookup-converse F1 L J L2
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- capset2perm/U-inversion A2 F2 U2 _ _ N2P _ _ _ _ BL _ R _ A2P EQV2
    <- set`not-member-update-right-preserves-union-converse* F1 F2 U2 J F U J2
    <- set`not-member-update-implies-leq F2 U2 LE2
    <- set`disjoint-symmetric DJ DJ'
    <- set`disjoint-respects-geq* DJ' LE2 DJP'
    <- set`disjoint-symmetric DJP' DJP
    <- set`not-member-update-increases-size-converse Z F U Z1
    <- capset`disjoint-join-implies-equiv-converse/L N Z1 DJP J2 A1 A2P _ AP EQVP.

- : capset`disjoint-join-implies-equiv-converse/L _ Z DJ J M2P1 M2P2 _ M2P EQV
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) _ F U
    <- set`member?-total D1?
    <- set`member?-total D2?
    <- capset`disjoint-join-implies-equiv-converse/LL
      _ Z DJ J F U M2P1 M2P2 D1? D2? _ M2P EQV.

- : capset`disjoint-join-implies-equiv-converse DJ J A1 A2 _ A EQV
    <- set`size-total Z
    <- capset`disjoint-join-implies-equiv-converse/L _ Z DJ J A1 A2 _ A EQV.

%worlds (gtermvar) (capset`disjoint-join-implies-equiv-converse/F _ _ _ _).
%total { } (capset`disjoint-join-implies-equiv-converse/F _ _ _ _).

%worlds (gtermvar) (capset`disjoint-join-implies-equiv-converse/L _ _ _ _ _ _ _ _ _)
  (capset`disjoint-join-implies-equiv-converse/LL _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N N1)
  (capset`disjoint-join-implies-equiv-converse/LL N _ _ _ _ _ _ _ _ _ _ _ _)
  (capset`disjoint-join-implies-equiv-converse/L N1 _ _ _ _ _ _ _ _).

%worlds (gtermvar) (capset`disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).
%total { } (capset`disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).


%theorem capset`disjoint-join-implies-equiv*
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {M=>Pi: capset2perm CM PM B M Pi}
    exists {EQV: (equiv ((Pi1) , (Pi2)) (Pi))}
    true.

- : capset`disjoint-join-implies-equiv* M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 M=>Pi
    (equiv/transitive (EQV1) (EQV2))
    <- capset`disjoint-join-implies-equiv-converse
    M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 _ M=>Pi' EQV1
    <- capset2perm-equiv M=>Pi' M=>Pi
      clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/ EQV2.

%worlds (gtermvar) (capset`disjoint-join-implies-equiv* _ _ _ _ _ _).
%total {} (capset`disjoint-join-implies-equiv* _ _ _ _ _ _).


%theorem set`split-implies-permission-combine
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi}
    forall {R: set`split M M1 M2}
    {M=>Pi: capset2perm CM PM B M Pi}
    exists {Pi1} {Pi2} {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {EQV: (equiv Pi (Pi1 , Pi2))}
    true.

- : set`split-implies-permission-combine
    (set`split/ M1^M2 M1+M2=M) M=>Pi _ _ M1=>Pi1 M2=>Pi2 (Pi1+Pi2<=>Pi)
    <- capset`disjoint-join-implies-equiv
      M1^M2 M1+M2=M M=>Pi _ _ M1=>Pi1 M2=>Pi2 Pi1+Pi2<=>Pi.

%worlds (gtermvar) (set`split-implies-permission-combine _ _ _ _ _ _ _).
%total {} (set`split-implies-permission-combine _ _ _ _ _ _ _).


%theorem set`split-implies-permission-combine-converse
  :forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2}
    forall {R: set`split M M1 M2}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    {EQV: equiv (Pi1 , Pi2) Pi}
    true.

- : set`split-implies-permission-combine-converse (set`split/ X J) T1 T2 _ T EQV
    <- capset`disjoint-join-implies-equiv-converse X J T1 T2 _ T EQV.

%worlds (gtermvar) (set`split-implies-permission-combine-converse _ _ _ _ _ _).
%total {} (set`split-implies-permission-combine-converse _ _ _ _ _ _).


%theorem set`split-implies-permission-combine*
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {R: set`split M M1 M2}
    {M=>Pi: capset2perm CM PM B M Pi}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    exists {EQV: (equiv Pi (Pi1 , Pi2))}
    true.

- : set`split-implies-permission-combine* (set`split/ M1^M2 M1+M2=M)
    M=>Pi M1=>Pi1 M2=>Pi2 (equiv/symmetric (Pi1+Pi2<=>Pi))
    <- capset`disjoint-join-implies-equiv*
      M1^M2 M1+M2=M M1=>Pi1 M2=>Pi2 M=>Pi Pi1+Pi2<=>Pi.

%worlds (gtermvar) (set`split-implies-permission-combine* _ _ _ _ _).
%total {} (set`split-implies-permission-combine* _ _ _ _ _).


%theorem cxt-fresh-update-preserves-capset2perm
  : forall* {CM} {PM} {B} {BP} {N} {M} {CI} {Pi}
    forall {B+M=>Pi: capset2perm CM PM B M Pi}
    {BF: cxt`fresh B N}
    {BU: cxt`update B N CI BP}
    exists {BP+M=>Pi: capset2perm CM PM BP M Pi}
    true.

- : cxt-fresh-update-preserves-capset2perm capset2perm/0 _ _ capset2perm/0.

- : cxt-fresh-update-preserves-capset2perm
    (capset2perm/U B+M'=>Pi2 N+F=>K BL CF FS UD) BF BU
    (capset2perm/U BP+M'=>Pi2 N+F=>K BPL CF FS UD)
    <- cxt-fresh-update-preserves-capset2perm B+M'=>Pi2 BF BU BP+M'=>Pi2
    <- cxt`fresh-update-preserves-lookup BL BF BU BPL.

- : cxt-fresh-update-preserves-capset2perm
    (capset2perm/z B+M'=>Pi2 FS UD) BF BU
    (capset2perm/z BP+M'=>Pi2 FS UD)
    <- cxt-fresh-update-preserves-capset2perm B+M'=>Pi2 BF BU BP+M'=>Pi2.

%worlds (gtermvar) (cxt-fresh-update-preserves-capset2perm _ _ _ _).
%total (M2P) (cxt-fresh-update-preserves-capset2perm M2P _ _ _).


%%% theorems about env2input

%theorem env2input-unique
  : forall* {CM} {PM} {B} {V} {V'} {Pi} {Pi'}
    forall {V=>Pi: env2input CM PM B V Pi}
    {V'=>Pi': env2input CM PM B V' Pi'}
    {V=V': env`eq V V'}
    exists {EQV: equiv Pi Pi'}
    true.

- : env2input-unique (env2input/ U1=>PiU1 M1=>PiM1)
    (env2input/ U2=>PiU2 M2=>PiM2) VE (equiv/combine UEQV MEQV)
    <- env`eq-inversion VE UE ME
    <- make-encumbered-equiv U1=>PiU1 U2=>PiU2 clsmap`eq/
      predmap`eq/ cxt`eq/ UE UEQV
    <- capset2perm-equiv M1=>PiM1 M2=>PiM2 clsmap`eq/
      predmap`eq/ cxt`eq/ ME MEQV.

%worlds (gtermvar) (env2input-unique _ _ _ _).
%total { } (env2input-unique _ _ _ _).


%theorem result2output-respects-eq
  : forall* {CM} {PM} {B} {K} {Rslt: result K} {Rslt': result K} {Out}
    forall {R2O: result2output CM PM B Rslt Out}
    {EQ: result`eq Rslt Rslt'}
    exists {R2O: result2output CM PM B Rslt' Out}
    true.

- : result2output-respects-eq XX result`eq/ XX.

%worlds (gtermvar) (result2output-respects-eq _ _ _).
%total { } (result2output-respects-eq _ _ _).


%%% Can't get equivalence due to set2cond.
%theorem reftype2perm-implies
  : forall* {CM} {PM} {B} {RT} {RT'} {PF} {PF'}
    forall {T2P: reftype2perm CM PM B RT PF}
    {T2P: reftype2perm CM PM B RT' PF'}
    {EQ: reftype`eq RT RT'}
    exists {IMP1: {o}{r}{p} implies (PF o r p) (PF' o r p)}
    {IMP2: {o}{r}{p} implies (PF' o r p) (PF o r p)}
    true.

- : reftype2perm-implies
    (reftype2perm/fresh T2PF0) (reftype2perm/fresh T2PF1) RT-EQ
    ([x][_][_] (implies/equiv (EQV x)))
    ([x][_][_] (implies/equiv (equiv/symmetric (EQV x))))
    <- reftype-eq-inversion RT-EQ NN-EQ C-EQ G-EQ
    <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ
    <- ty2perm-deterministic T2PF0 T2PF1 predmap`eq/ T-EQ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV x)).

- : reftype2perm-implies
    (reftype2perm/shared T2PF0) (reftype2perm/shared T2PF1) RT-EQ
    ([x][_][_] (implies/equiv (EQV x)))
    ([x][_][_] (implies/equiv (equiv/symmetric (EQV x))))
    <- reftype-eq-inversion RT-EQ NN-EQ C-EQ G-EQ
    <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ
    <- ty2perm-deterministic T2PF0 T2PF1 predmap`eq/ T-EQ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV x)).

- : reftype2perm-implies
    (reftype2perm/borrow _ _ T2PF0 S2G0) (reftype2perm/borrow _ _ T2PF1 S2G1) RT-EQ
    ([o][_][_] (implies/combine (implies/equiv (EQV o)) (IMP1 o)))
    ([o][_][_] (implies/combine
                 (implies/equiv (equiv/symmetric (EQV o))) (IMP2 o)))
    <- reftype-eq-inversion RT-EQ NN-EQ C-EQ G-EQ
    <- targets/unique-eq-inversion G-EQ S-EQ M-EQ _
    <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ
    <- ty2perm-deterministic T2PF0 T2PF1 predmap`eq/ T-EQ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV x))
    <- ({x} set2cond-implies (S2G0 x) (S2G1 x) object`eq/ S-EQ (IMP1 x) (IMP2 x)).

- : reftype2perm-implies
    (reftype2perm/unique _ T2PF0 S2G0 M2P0) (reftype2perm/unique _ T2PF1 S2G1 M2P1)
    RT-EQ
    ([o][r][_] implies/combine
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (IMP1 o))
      (implies/combine
        (implies/equiv (EQV r))
        (implies/equiv-encumbered (EQV r) EQV1)))
    ([o][r][_] implies/combine
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (IMP2 o))
      (implies/combine
        (implies/equiv (equiv/symmetric (EQV r)))
        (implies/equiv-encumbered (equiv/symmetric (EQV r)) (equiv/symmetric EQV1))))
    <- reftype-eq-inversion RT-EQ NN-EQ C-EQ G-EQ
    <- targets/unique-eq-inversion G-EQ S-EQ M-EQ _
    <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ
    <- ty2perm-deterministic T2PF0 T2PF1 predmap`eq/ T-EQ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV x))
    <- ({x} set2cond-implies (S2G0 x) (S2G1 x) object`eq/ S-EQ (IMP1 x) (IMP2 x))
    <- capset2perm-equiv M2P0 M2P1 clsmap`eq/ predmap`eq/ cxt`eq/ M-EQ EQV1.

- : reftype2perm-implies
    (reftype2perm/unique+fresh T2PF0 S2G0 M2P0) (reftype2perm/unique+fresh T2PF1 S2G1 M2P1)
    RT-EQ
    ([o][r][_] implies/combine
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (IMP1 o))
      (implies/combine
        (implies/equiv (EQV r))
        (implies/equiv-encumbered (EQV r) (equiv/combine EQV1 equiv/reflexive))))
    ([o][r][_] implies/combine
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (IMP2 o))
      (implies/combine
        (implies/equiv (equiv/symmetric (EQV r)))
        (implies/equiv-encumbered (equiv/symmetric (EQV r))
          (equiv/combine (equiv/symmetric EQV1) equiv/reflexive))))
    <- reftype-eq-inversion RT-EQ NN-EQ C-EQ G-EQ
    <- targets/unique-eq-inversion G-EQ S-EQ M-EQ _
    <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ
    <- ty2perm-deterministic T2PF0 T2PF1 predmap`eq/ T-EQ PF-EQ
    <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV x))
    <- ({x} set2cond-implies (S2G0 x) (S2G1 x) object`eq/ S-EQ (IMP1 x) (IMP2 x))
    <- capset2perm-equiv M2P0 M2P1 clsmap`eq/ predmap`eq/ cxt`eq/ M-EQ EQV1.

%worlds (gtermvar) (reftype2perm-implies _ _ _ _ _).
%total { } (reftype2perm-implies _ _ _ _ _).


%%% We couldn't prove this for result/cond since the nonlinear
%%% permission is unbound.

%theorem result2output/expr-trans*
  : forall* {CM} {PM} {B} {Pi} {Pi'}
    {Rslt: expr-result} {Rslt'} {Out} {Out'}
    forall {R2O: result2output* CM PM B Pi Rslt Out}
    {R2O: result2output* CM PM B Pi' Rslt' Out'}
    {IMP1: implies Pi Pi'} {IMP1: implies Pi' Pi}
    {RE: result`eq Rslt Rslt'}
    exists {TRANS1: transform Out Out'}  {TRANS2: transform Out' Out}
    true.

- : result2output/expr-trans*
    (result2output/expr B2P0 V2P0 T2P0)
    (result2output/expr B2P1 V2P1 T2P1)
    IMP1 IMP2 RE
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/implies
            (implies/combine
              (implies/combine (implies/equiv EQV0)
                (implies/combine (IMP3 o r p) (implies/equiv EQV1)))
              (IMP1))))))
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/implies
            (implies/combine
              (implies/combine (implies/equiv (equiv/symmetric EQV0))
                (implies/combine (IMP4 o r p) (implies/equiv (equiv/symmetric EQV1))))
              (IMP2))))))
    <- result/expr-eq-inversion RE RT-EQ V-EQ
    <- cxt2perm-equiv B2P0 B2P1 predmap`eq/ cxt`eq/ EQV0
    <- env2input-unique V2P0 V2P1 V-EQ EQV1
    <- reftype2perm-implies T2P0 T2P1 RT-EQ IMP3 IMP4.

%worlds (gtermvar) (result2output/expr-trans* _ _ _ _ _ _ _).
%total (R) (result2output/expr-trans* R _ _ _ _ _ _).


%theorem result2output/expr-trans
  : forall* {CM} {PM} {B} {Rslt: expr-result} {Rslt'} {Out} {Out'}
    forall {R2O: result2output CM PM B Rslt Out}
    {R2O: result2output CM PM B Rslt' Out'}
    {RE: result`eq Rslt Rslt'}
    exists {TRANS1: transform Out Out'}  {TRANS2: transform Out' Out}
    true.

- : result2output/expr-trans R2O1 R2O2 RE TRANS1 TRANS2
    <- result2output/expr-trans* R2O1 R2O2
      implies/reflexive implies/reflexive RE TRANS1 TRANS2.

%worlds (gtermvar) (result2output/expr-trans _ _ _ _ _).
%total { } (result2output/expr-trans _ _ _ _ _).


%theorem result2output/args-trans*
  : forall* {CM} {PM} {B} {Pi} {Pi'}
    {Rslt: args-result} {Rslt'} {Out} {Out'}
    forall {R2O: result2output* CM PM B Pi Rslt Out}
    {R2O: result2output* CM PM B Pi' Rslt' Out'}
    {IMP1: implies Pi Pi'} {IMP1: implies Pi' Pi}
    {RE: result`eq Rslt Rslt'}
    exists {TRANS1: transform Out Out'}  {TRANS2: transform Out' Out}
    true.

- : result2output/args-trans*
    (result2output/args/0 B2P0 V2P0)
    (result2output/args/0 B2P1 V2P1)
    IMP1 IMP2 RE
    (transform/args/0
      (implies/combine IMP1
        (implies/equiv (equiv/combine EQV0 EQV1))))
    (transform/args/0
      (implies/combine IMP2
        (implies/equiv
          (equiv/combine (equiv/symmetric EQV0)
            (equiv/symmetric EQV1)))))
    <- result/args/0-eq-inversion RE V-EQ
    <- cxt2perm-equiv B2P0 B2P1 predmap`eq/ cxt`eq/ EQV0
    <- env2input-unique V2P0 V2P1 V-EQ EQV1.

- : result2output/args-trans*
    (result2output/args/+ V2P0 T2P0 A2P0)
    (result2output/args/+ V2P1 T2P1 A2P1)
    IMP1 IMP2 RE
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/args/+
            (TRANS0 o r p)))))
    (transform/inside [o]
      (transform/inside [r]
        (transform/inside [p]
          (transform/args/+
            (TRANS1 o r p)))))
    <- result/args/+-eq-inversion RE RT-EQ V-EQ A-EQ
    <- env2input-unique V2P0 V2P1 V-EQ EQV1
    <- reftype2perm-implies T2P0 T2P1 RT-EQ IMP3 IMP4
    <- ({o}{r}{p} result2output/args-trans* (A2P0 o r p) (A2P1 o r p)
         (implies/combine
           (implies/combine (IMP3 o r p) (implies/equiv EQV1)) IMP1)
         (implies/combine
           (implies/combine (IMP4 o r p)
             (implies/equiv (equiv/symmetric EQV1))) IMP2)
         A-EQ (TRANS0 o r p) (TRANS1 o r p)).

%worlds (gtermvar) (result2output/args-trans* _ _ _ _ _ _ _).
%total (R) (result2output/args-trans* R _ _ _ _ _ _).


%theorem result2output/args-trans
  : forall* {CM} {PM} {B} {Rslt: args-result} {Rslt'} {Out} {Out'}
    forall {R2O: result2output CM PM B Rslt Out}
    {R2O: result2output CM PM B Rslt' Out'}
    {RE: result`eq Rslt Rslt'}
    exists {TRANS1: transform Out Out'}  {TRANS2: transform Out' Out}
    true.

- : result2output/args-trans R2O1 R2O2 RE TRANS1 TRANS2
    <- result2output/args-trans* R2O1 R2O2
      implies/reflexive implies/reflexive RE TRANS1 TRANS2.

%worlds (gtermvar) (result2output/args-trans _ _ _ _ _).
%total { } (result2output/args-trans _ _ _ _ _).


%%% Theorems about env2input and result2output

%theorem clsmap-cxt-env-implies-env2input
  : forall* {CM} {PM} {B} {V}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-V: clsmap-cxt-env CM B V}
    exists {Pi} {V=>Pi: env2input CM PM B V Pi}
    true.

- : clsmap-cxt-env-implies-env2input CM-CM CM2PM
    (clsmap-cxt-env/ CM-B-U CM-B-M) _
    (env2input/ U=>PiU M=>PiM)
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-B-U _ U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-B-M _ M=>PiM.

%worlds (gtermvar) (clsmap-cxt-env-implies-env2input _ _ _ _ _).
%total { } (clsmap-cxt-env-implies-env2input _ _ _ _ _).


%{
theorems about leq - basically:
if M1 is less or equal than M2, and
M1 ==> Pi1, M2 ==> Pi2.
then exists Pi3, such that Pi2 <==> Pi1 , Pi3
}%

%theorem can-split-permission
  : forall* {Q1} {Pi}
    forall {Q1<1: rat`lst Q1 one}
    exists {Q2} {ADD: rat`add Q1 Q2 one}
    {EQV: equiv Pi ((scale (fraction/ Q1) Pi) , (scale (fraction/ Q2) Pi))}
    true.

- : can-split-permission (Q1<1:rat`lst Q1 one) Q2 Q1+Q2=1
    (equiv/transitive
      (equiv/symmetric equiv/one)
      (equiv/symmetric (equiv/add Q1+Q2=1)))
    <- rat`grt-implies-add Q1<1 Q2 Q2+Q1=1
    <- rat`add-commutative Q2+Q1=1 Q1+Q2=1.

%worlds (gtermvar) (can-split-permission _ _ _ _).
%total {} (can-split-permission _ _ _ _).


%%% If two types are the same except nn is leq, we can
%%% get implies on the corresponding permissions.

%theorem nn-leq-implies-permission-leq
  : forall* {PM} {C} {PF2} {NN2} {NN1} {A}
    forall {T2PF: ty2perm PM (ty/ NN2 A C) PF2}
    {NN2<=NN1: nonnull`leq NN1 NN2}
    exists {PF1} {T2PF: ty2perm PM (ty/ NN1 A C) PF1}
    {IMP: {x} implies (PF2 x) (PF1 x)}
    true.

- : nn-leq-implies-permission-leq T2PF
    (nonnull`leq/= nonnull`eq/) _ T2PF ([_] implies/reflexive).

- : nn-leq-implies-permission-leq
    (ty2perm/ PML nn2perm/yes A2AF)
    (nonnull`leq/<) _ (ty2perm/ PML nn2perm/may A2AF)
    ([_] implies/trans
      (implies/combine implies/nonlinear2empty implies/reflexive)
      (implies/equiv (equiv/transitive equiv/commute equiv/identity))).

%worlds (gtermvar) (nn-leq-implies-permission-leq _ _ _ _ _).
%total { } (nn-leq-implies-permission-leq _ _ _ _ _).


%theorem nn-leq-implies-permission-leq*
  : forall* {PM} {C} {PF1} {PF2} {NN2} {NN1} {A}
    forall {T2PF: ty2perm PM (ty/ NN2 A C) PF2}
    {NN2<=NN1: nonnull`leq NN1 NN2}
    {T2PF: ty2perm PM (ty/ NN1 A C) PF1}
    exists {IMP: {x} implies (PF2 x) (PF1 x)}
    true.

- : nn-leq-implies-permission-leq* T2PF2 LE T2PF
    ([x] implies/trans (IMP' x) (implies/equiv (PEQV x)))
    <- nn-leq-implies-permission-leq T2PF2 LE _ T2PF' IMP'
    <- ty2perm-deterministic T2PF' T2PF predmap`eq/ ty`eq/ PEF
    <- ({x} permission`eq-implies-equiv (PEF x) (PEQV x)).

%worlds (gtermvar) (nn-leq-implies-permission-leq* _ _ _ _).
%total { } (nn-leq-implies-permission-leq* _ _ _ _).


%%% XX-no-var

%theorem cxt`lookup-no-var
  : forall* {B} {N} {NN} {A} {C} {OF:object -> object}
    forall {BL: {x} cxt`lookup B N (cxt-info/ (OF x) (ty/ NN A C))}
    exists {O} {OE: {x} object`eq (OF x) O}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    true.

- : cxt`lookup-no-var ([x] cxt`lookup/> (LP x) P) _ E (cxt`lookup/> L P)
    <- cxt`lookup-no-var LP _ E L.

- : cxt`lookup-no-var ([_] cxt`lookup/= nat`eq/) _
    ([_] object`eq/) (cxt`lookup/= nat`eq/).

%worlds (gtermvar) (cxt`lookup-no-var _ _ _ _).
%total (L) (cxt`lookup-no-var L _ _ _).


%theorem fldset2perm-no-var
  : forall* {PM} {FM} {FS} {PF':object -> object -> permission}
    forall {FS=>PF': {x}{o} fldset2perm PM o FM FS (PF' x o)}
    exists {PF} {EQ: {x}{o} permission`eq (PF' x o) (PF o)}
    {FS=>PF: {o} fldset2perm PM o FM FS (PF o)}
    true.

%theorem fldset2perm-no-var/L
  : forall* {N1} {X2:object -> object -> object -> permission} {X3} {X6} {X7}
    forall {EQ1: {x}{o}{v} permission`eq (X2 x o v) (X3 v)}
    {EQ2: {x}{o} permission`eq (X6 x o) (X7 o)}
    exists {EQ: {x}{x1} permission`eq
                (combine
                  (unitperm
                    (precise-exists x1 N1 ([x2:gterm objectk] X2 x x1 x2)))
                  (X6 x x1))
                (combine
                  (unitperm (precise-exists x1 N1 ([x2:gterm objectk] X3 x2)))
                  (X7 x1))}
    true.

- : fldset2perm-no-var/L ([_][_][_] permission`eq/) ([_][_] permission`eq/)
    ([_][_] permission`eq/).

%worlds (gtermvar) (fldset2perm-no-var/L _ _ _).
%total { } (fldset2perm-no-var/L _ _ _).


- : fldset2perm-no-var ([_][_] fldset2perm/0) _ ([_][_] permission`eq/)
    ([_] fldset2perm/0).

- : fldset2perm-no-var
    ([x][o] fldset2perm/+ SH (FS1=>PF1' x o) FML (T2PF' x o)) _ EQ
    ([o] fldset2perm/+ SH (FS1=>PF1 o) FML T2PF)
    <- fldset2perm-no-var FS1=>PF1' _ P-EQ ([o] FS1=>PF1 o)
    <- ty2perm-no-var2 T2PF' _ PF-EQ T2PF
    <- fldset2perm-no-var/L PF-EQ P-EQ EQ.

%worlds (gtermvar) (fldset2perm-no-var _ _ _ _).
%total (F) (fldset2perm-no-var F _ _ _).


%theorem cxt2perm-no-var
  : forall* {PM} {B} {PiBF: object -> permission}
    forall {B=>PiBF: {x} cxt2perm PM B (PiBF x)}
    exists {PiB} {EQ: {x} permission`eq (PiBF x) PiB}
    {B=>PiB: cxt2perm PM B PiB}
    true.

%worlds (gtermvar) (cxt2perm-no-var _ _ _ _).
%trustme %total { } (cxt2perm-no-var _ _ _ _).


%%% cxt`fresh-update-preserves-XX

%theorem cxt`fresh-update-preserves-clsmap-cxt-objset
  : forall* {CM} {B0} {B1} {N} {T} {S}
    forall {CM-B0-V: clsmap-cxt-objset CM B0 S}
    {N!<B0: cxt`fresh B0 N} {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x T) (B1 x)}
    exists {CM-B1-V: {x} clsmap-cxt-objset CM (B1 x) S}
    true.

- : cxt`fresh-update-preserves-clsmap-cxt-objset
    clsmap-cxt-objset/0 _ _ ([_] clsmap-cxt-objset/0).

- : cxt`fresh-update-preserves-clsmap-cxt-objset
    (clsmap-cxt-objset/U CM-B0-S B0-L CML NM AD)
    FS UD ([x] clsmap-cxt-objset/U (CM-B1-S x) (B1-L x) CML NM AD)
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-S FS UD CM-B1-S
    <- ({x} cxt`fresh-update-preserves-lookup B0-L FS (UD x) (B1-L x)).

%worlds (gtermvar) (cxt`fresh-update-preserves-clsmap-cxt-objset _ _ _ _).
%total (A) (cxt`fresh-update-preserves-clsmap-cxt-objset A _ _ _).


%theorem cxt`fresh-update-preserves-clsmap-cxt-capset
  : forall* {CM} {B0} {B1} {N} {T} {S}
    forall {CM-B0-V: clsmap-cxt-capset CM B0 S}
    {N!<B0: cxt`fresh B0 N} {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x T) (B1 x)}
    exists {CM-B1-V: {x} clsmap-cxt-capset CM (B1 x) S}
    true.

- : cxt`fresh-update-preserves-clsmap-cxt-capset
    clsmap-cxt-capset/0 _ _ ([_] clsmap-cxt-capset/0).

- : cxt`fresh-update-preserves-clsmap-cxt-capset
    (clsmap-cxt-capset/U CM-B0-S N2P B0-L NA CML FML NM AD)
    FS UD ([x] clsmap-cxt-capset/U (CM-B1-S x) N2P (B1-L x) NA CML FML NM AD)
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-S FS UD CM-B1-S
    <- ({x} cxt`fresh-update-preserves-lookup B0-L FS (UD x) (B1-L x)).

- : cxt`fresh-update-preserves-clsmap-cxt-capset
    (clsmap-cxt-capset/z CM-B0-S NM AD)
    FS UD ([x] clsmap-cxt-capset/z (CM-B1-S x) NM AD)
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-S FS UD CM-B1-S.

%worlds (gtermvar) (cxt`fresh-update-preserves-clsmap-cxt-capset _ _ _ _).
%total (A) (cxt`fresh-update-preserves-clsmap-cxt-capset A _ _ _).


%theorem cxt`fresh-update-preserves-clsmap-cxt-env
  : forall* {CM} {B0} {B1} {N} {T} {V}
    forall {CM-B0-V: clsmap-cxt-env CM B0 V}
    {N!<B0: cxt`fresh B0 N} {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x T) (B1 x)}
    exists {CM-B1-V: {x} clsmap-cxt-env CM (B1 x) V}
    true.

- : cxt`fresh-update-preserves-clsmap-cxt-env
    (clsmap-cxt-env/ CM-B-U CM-B-M) FS UD ([x] clsmap-cxt-env/ (CM-BF-U x) (CM-BF-M x))
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B-U FS UD CM-BF-U
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B-M FS UD CM-BF-M.

%worlds (gtermvar) (cxt`fresh-update-preserves-clsmap-cxt-env _ _ _ _).
%total { } (cxt`fresh-update-preserves-clsmap-cxt-env _ _ _ _).


%theorem cxt`fresh-update-preserves-make-encumbered
  : forall* {CM} {PM} {B0} {B1} {N} {S} {T} {PiS}
    forall {B0+S=>PiS: make-encumbered CM PM B0 S PiS}
    {N!<B0: cxt`fresh B0 N} {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x T) (B1 x)}
    exists {B1+S=>PiS: {x} make-encumbered CM PM (B1 x) S PiS}
    true.

- : cxt`fresh-update-preserves-make-encumbered
    make-encumbered/0 _ _ ([_] make-encumbered/0).

- : cxt`fresh-update-preserves-make-encumbered
    (make-encumbered/U ME B0-L CML PML DM FS2P NM AD)
    FS UD ([x] make-encumbered/U (MEF x) (B1-L x) CML PML DM FS2P NM AD)
    <- cxt`fresh-update-preserves-make-encumbered ME FS UD MEF
    <- ({x} cxt`fresh-update-preserves-lookup B0-L FS (UD x) (B1-L x)).

%worlds (gtermvar) (cxt`fresh-update-preserves-make-encumbered _ _ _ _).
%total (ME) (cxt`fresh-update-preserves-make-encumbered ME _ _ _).


%theorem cxt`fresh-update-preserves-capset2perm
  : forall* {CM} {PM} {B0} {B1} {N} {M} {T} {PiM}
    forall {B0+M=>PiM: capset2perm CM PM B0 M PiM}
    {N!<B0: cxt`fresh B0 N} {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x T) (B1 x)}
    exists {B1+M=>PiM: {x} capset2perm CM PM (B1 x) M PiM}
    true.

- : cxt`fresh-update-preserves-capset2perm
    capset2perm/0 _ _ ([_] capset2perm/0).

- : cxt`fresh-update-preserves-capset2perm
    (capset2perm/U M2P N2P B0-L CF NM AD)
    FS UD ([x] capset2perm/U (M2PF x) N2P (B1-L x) CF NM AD)
    <- cxt`fresh-update-preserves-capset2perm M2P FS UD M2PF
    <- ({x} cxt`fresh-update-preserves-lookup B0-L FS (UD x) (B1-L x)).

- : cxt`fresh-update-preserves-capset2perm
    (capset2perm/z M2P NM AD) FS UD ([x] capset2perm/z (M2PF x) NM AD)
    <- cxt`fresh-update-preserves-capset2perm M2P FS UD M2PF.

%worlds (gtermvar) (cxt`fresh-update-preserves-capset2perm _ _ _ _).
%total (M2P) (cxt`fresh-update-preserves-capset2perm M2P _ _ _).


%theorem cxt`fresh-update-preserves-env2input
  : forall* {CM} {PM} {B0} {B1} {N} {V} {T} {PiV}
    forall {B0+V=>PiV: env2input CM PM B0 V PiV}
    {N!<B0: cxt`fresh B0 N} {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x T) (B1 x)}
    exists {B1+V=>PiV: {x} env2input CM PM (B1 x) V PiV}
    true.

- : cxt`fresh-update-preserves-env2input (env2input/ ME M2P)
    FS UD ([x] env2input/ (MEF x) (M2PF x))
    <- cxt`fresh-update-preserves-make-encumbered ME FS UD MEF
    <- cxt`fresh-update-preserves-capset2perm M2P FS UD M2PF.

%worlds (gtermvar) (cxt`fresh-update-preserves-env2input _ _ _ _).
%total { } (cxt`fresh-update-preserves-env2input _ _ _ _).



%theorem cxt`fresh-update-preserves-make-encumbered-converse
  : forall* {CM} {PM} {B0} {B1} {N} {S} {T} {PiS1}
    forall {B1+S=>PiS1: {x} make-encumbered CM PM (B1 x) S (PiS1 x)}
    {N!<B0: cxt`fresh B0 N} {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x T) (B1 x)}
    {N!<S: set`not-member S N}
    exists {PiS0} {B0+S=>PiS0: make-encumbered CM PM B0 S PiS0}
    {PiS1<=>PiS0: {x} equiv (PiS1 x) PiS0}
    true.

%theorem cxt`fresh-update-preserves-make-encumbered-converse/L
  : forall* {CM} {PM} {B0} {B1} {N} {S'} {S} {T} {K} {M}
    {NN} {A} {C} {FM} {FS} {OF} {PiFS} {PiS1'} {CPF:object -> clspred}
    forall {B1+S'=>PiS1': {x} make-encumbered CM PM (B1 x) S' (PiS1' x)}
    {B1-L: {x} cxt`lookup (B1 x) M (cxt-info/ (OF x) (ty/ NN A C))}
    {CML: clsmap`lookup CM C FM}
    {PML: {x} predmap`lookup PM C (CPF x)}
    {DM: fldmap`domain FM FS}
    {FS=>PiFS: {x}{o} fldset2perm PM o FM FS (PiFS x o)}
    {M!<S': set`not-member S' M}
    {S'+M=S: set`add S' M S}
    {N!<B0: cxt`fresh B0 N}
    {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x T) (B1 x)}
    {N!<S: set`not-member S N}
    {M=N?: nat`eq? M N K}
    exists {PiS0}
    {B0+S=>PiS0: make-encumbered CM PM B0 S PiS0}
    {PiS1<=>PiS0: {x} equiv
                  (combine
                    (unitperm
                      (conditional (objequal (OF x) null) empty
                        (unitperm
                          (encumbered (PiFS x (OF x))
                            (combine (allperm (OF x)) (one-predcall (CPF x) (OF x)))))))
                    (PiS1' x))
                  PiS0}
    true.

%theorem cxt`fresh-update-preserves-make-encumbered-converse/LF
  : forall* {CM} {PM} {B0} {S} {OF:object -> object} {CPF:object -> clspred} {PiS1'}
    forall {PiFS:object -> object -> permission} {V: void}
    exists {PiS0}
    {B0+S=>PiS0: make-encumbered CM PM B0 S PiS0}
    {PiS1<=>PiS0: {x} equiv
                  (combine
                    (unitperm
                      (conditional (objequal (OF x) null) empty
                        (unitperm
                          (encumbered (PiFS x (OF x))
                            (combine (allperm (OF x)) (one-predcall (CPF x) (OF x)))))))
                    (PiS1' x))
                  PiS0}
    true.

%worlds (gtermvar) (cxt`fresh-update-preserves-make-encumbered-converse/LF _ _ _ _ _).
%total { } (cxt`fresh-update-preserves-make-encumbered-converse/LF _ _ _ _ _).


%theorem cxt`fresh-update-preserves-make-encumbered-converse/LL
  : forall* {OF:object -> object} {O} {CPF} {CP}
    forall {PF1: object -> object -> permission}
    {PF: object -> permission}
    {PFE: {x}{o} permission`eq (PF1 x o) (PF o)}
    {CPE: {x} predicate`eq (CPF x) CP}
    {OE: {x} object`eq (OF x) O}
    exists {PEQ: {x} permission`eq
                 (unitperm
                  (conditional (objequal (OF x) null) empty
                    (unitperm
                      (encumbered (PF1 x (OF x))
                        (combine (allperm (OF x))
                          (one-predcall (CPF x) (OF x)))))))
                 (unitperm
                  (conditional (objequal O null) empty
                    (unitperm
                      (encumbered (PF O)
                        (combine (allperm O)
                          (one-predcall CP O))))))}
    true.

- : cxt`fresh-update-preserves-make-encumbered-converse/LL
    _ _ ([_][_] permission`eq/) ([_] predicate`eq/) ([_] object`eq/) ([_] permission`eq/).

%worlds (gtermvar) (cxt`fresh-update-preserves-make-encumbered-converse/LL _ _ _ _ _ _).
%total { } (cxt`fresh-update-preserves-make-encumbered-converse/LL _ _ _ _ _ _).


- : cxt`fresh-update-preserves-make-encumbered-converse/L
    ([x] B1+S'=>PiS1' x) ([x] B1-L x) CML PMLF DM
    ([x][o] (FS=>PF:{x}{o} fldset2perm PM o FM FS (PF x o)) x o) M!<S' S'+M=S
    N!<B0 B0+N=B1 N!<S nat`eq?/yes _ B0+S=>PiS0 PiS1<=>PiS0
    <- set`add-implies-member S'+M=S M<-S
    <- set`member-not-member-contradiction M<-S N!<S V
    <- cxt`fresh-update-preserves-make-encumbered-converse/LF PF V _ B0+S=>PiS0 PiS1<=>PiS0.

- : cxt`fresh-update-preserves-make-encumbered-converse/L
    ([x] B1+S'=>PiS1' x) ([x] B1-L x) CML
    ([x] (PMLF:{x} predmap`lookup PM C (CPF x)) x) DM
    ([x][o] (FS=>PF1:{x}{o} fldset2perm PM o FM FS (PF1 x o)) x o) M!<S' S'+M=S
    (N!<B0:cxt`fresh B0 N) B0+N=B1 N!<S (nat`eq?/no (M<>N: nat`ne M N)) _
    (make-encumbered/U B0+S'=>PiS0' B0-L CML PML DM
      ([o] (FS=>PF:{o} fldset2perm PM o FM FS (PF o)) o) M!<S' S'+M=S)
    ([x] equiv/combine (EQV x) (PiS1'<=>PiS0' x))
    <- ({x} cxt`update-preserves-lookup-converse (B1-L x) (B0+N=B1 x) M<>N
         ((B0-LV:{x} cxt`lookup B0 M (cxt-info/ (OF x) (ty/ NN A C))) x))
    <- set`add-preserves-not-member-converse N!<S S'+M=S N!<S'
    <- predmap`no-variable-lookup PMLF CP PML P-EQ
    <- cxt`lookup-no-var B0-LV O OE B0-L
    <- fldset2perm-no-var FS=>PF1 _ PF-EQ FS=>PF
    <- cxt`fresh-update-preserves-make-encumbered-converse B1+S'=>PiS1' N!<B0 B0+N=B1
      N!<S' _ B0+S'=>PiS0' PiS1'<=>PiS0'
    <- cxt`fresh-update-preserves-make-encumbered-converse/LL PF1 PF PF-EQ P-EQ OE Pi-EQ
    <- ({x} permission`eq-implies-equiv (Pi-EQ x) (EQV x)).

- : cxt`fresh-update-preserves-make-encumbered-converse
    ([_] make-encumbered/0) _ _ _ _ make-encumbered/0 ([_] equiv/reflexive).

- : cxt`fresh-update-preserves-make-encumbered-converse
    ([x] make-encumbered/U (B1+S'=>PiS1' x) (B1-L x) CML (PMLF x) DM
      ([o] FS=>PF x o) M!<S' S'+M=S) N!<B0 B0+N=B1 N!<S _ B0+S=>PiS0 PiS1<=>PiS0
    <- nat`eq?-total EQ?
    <- cxt`fresh-update-preserves-make-encumbered-converse/L ([x] B1+S'=>PiS1' x)
      ([x] B1-L x) CML PMLF DM ([x] FS=>PF x) M!<S' S'+M=S N!<B0 B0+N=B1
      N!<S EQ? _ B0+S=>PiS0 PiS1<=>PiS0.

%worlds (gtermvar)
  (cxt`fresh-update-preserves-make-encumbered-converse _ _ _ _ _ _ _)
  (cxt`fresh-update-preserves-make-encumbered-converse/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A A0)
  (cxt`fresh-update-preserves-make-encumbered-converse A _ _ _ _ _ _)
  (cxt`fresh-update-preserves-make-encumbered-converse/L A0 _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem cxt`fresh-update-preserves-capset2perm-converse
  : forall* {CM} {PM} {B0} {B1} {N} {M} {T} {PiM1}
    forall {B1+M=>PiM1: {x} capset2perm CM PM (B1 x) M (PiM1 x)}
    {N!<B0: cxt`fresh B0 N} {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x T) (B1 x)}
    exists {PiM0} {B0+M=>PiM0: capset2perm CM PM B0 M PiM0}
    {PiM1<=>PiM0: {x} permission`eq (PiM1 x) PiM0}
    true.

%worlds (gtermvar) (cxt`fresh-update-preserves-capset2perm-converse _ _ _ _ _ _).
%trustme %total { } (cxt`fresh-update-preserves-capset2perm-converse _ _ _ _ _ _).


%theorem cxt`fresh-update-preserves-set2cond-converse
  : forall* {B0} {B1} {S} {N} {T} {GFF}
    forall {B1+S=>GF: {x}{o} set2cond (B1 x) o S (GFF x o)}
    {N!<B0: cxt`fresh B0 N} {B0+N=B1: {x} cxt`update B0 N (cxt-info/ x T) (B1 x)}
    {N!<S: set`not-member S N}
    exists {GF} {B1+S=>GF: {o} set2cond B0 o S (GF o)}
    {GFF<=>GF: {x}{o} permission`eq (GFF x o) (GF o)}
    true.

%worlds (gtermvar) (cxt`fresh-update-preserves-set2cond-converse _ _ _ _ _ _ _).
%trustme %total { } (cxt`fresh-update-preserves-set2cond-converse _ _ _ _ _ _ _).


%%% Theorems about methmap2progtype

%theorem clsmap-ty-implies-argtype2perm*
  : forall* {CM} {PM} {FS} {NN} {C} {FM} {FS0}
    forall {A} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    exists {PF1} {PF2}
    {MT=>PF: argtype2perm CM PM (ty/ NN A C) FS PF1 PF2}
    true.

- : clsmap-ty-implies-argtype2perm* annot/unique _ CM2PM CML _ _
    _ _ (argtype2perm/unique T2PF)
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/ CML) _ T2PF.

- : clsmap-ty-implies-argtype2perm* annot/shared _ CM2PM CML _ _
    _ _ (argtype2perm/shared T2PF)
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/ CML) _ T2PF.

- : clsmap-ty-implies-argtype2perm* annot/borrow CM-CM CM2PM CML DM LE
    _ _ (argtype2perm/borrow CML DM LE FS=>PF)
    <- ({x} fldset2perm-total CM-CM CM2PM CML DM LE _ (FS=>PF x)).

%worlds (gtermvar) (clsmap-ty-implies-argtype2perm* _ _ _ _ _ _ _ _ _).
%total { } (clsmap-ty-implies-argtype2perm* _ _ _ _ _ _ _ _ _).

%abbrev clsmap-ty-implies-argtype2perm = clsmap-ty-implies-argtype2perm* _.


%theorem clsmap-methty-implies-methty2proctype*
  : forall* {CM} {PM} {MT} {Piin} {Piout}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-MT: clsmap-methty CM MT}
    exists {PT} {MT=>PT: methty2proctype* CM PM Piin Piout MT PT}
    true.

- : clsmap-methty-implies-methty2proctype* _ CM2PM
    (clsmap-methty/base CM-T) _ (methty2proctype/base T2PF)
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF.

- : clsmap-methty-implies-methty2proctype* CM-CM CM2PM
    (clsmap-methty/args CM-MT CML DM LE) _ (methty2proctype/arg T2PF ([x] MT=>PT x))
    <- clsmap-ty-implies-argtype2perm CM-CM CM2PM CML DM LE _ _ T2PF
    <- ({x} clsmap-methty-implies-methty2proctype* CM-CM CM2PM CM-MT _ (MT=>PT x)).

%worlds (gtermvar) (clsmap-methty-implies-methty2proctype* _ _ _ _ _).
%total (A) (clsmap-methty-implies-methty2proctype* _ _ A _ _).


%theorem methmap2progtype/U/c-inversion
  : forall* {CM} {PM} {MM} {W} {T} {C} {M} {FM} {MM'} {N} {CT}
    forall {MM=>W: methmap2progtype CM PM MM W}
    {CML: clsmap`lookup CM C FM}
    {M!<MM': methmap`fresh MM' N}
    {MM'+M=MM: methmap`update MM' N (methty/arg T M CT) MM}
    exists {W'} {PTF} {MM'=>W': methmap2progtype CM PM MM' W'}
    {W'+M=W: progtype`update W' N (proctype/arg PTF) W}
    {CT=>PT: consty2proctype CM FM PM CT PTF}
    true.

%worlds (gtermvar) (methmap2progtype/U/c-inversion _ _ _ _ _ _ _ _ _).
%trustme %total { } (methmap2progtype/U/c-inversion _ _ _ _ _ _ _ _ _).


%theorem methmap2progtype/U/m-inversion
  : forall* {CM} {PM} {MM} {W} {C} {MM'} {N} {MT}
    forall {MM=>W: methmap2progtype CM PM MM W}
    {CMF: clsmap`fresh CM C}
    {M!<MM': methmap`fresh MM' N}
    {MM'+M=MM: methmap`update MM' N MT MM}
    exists {W'} {PT} {MM'=>W': methmap2progtype CM PM MM' W'}
    {W'+M=W: progtype`update W' N PT W}
    {MT=>PT: methty2proctype CM PM MT PT}
    true.

%worlds (gtermvar) (methmap2progtype/U/m-inversion _ _ _ _ _ _ _ _ _).
%trustme %total { } (methmap2progtype/U/m-inversion _ _ _ _ _ _ _ _ _).