%%% Converting *map to permission

% Convert a set of object locations to a disjunction of objequal
% facts. Used in output.

set2facts : object -> set -> formula -> type.

set2facts/0 : set2facts _ set/0 f.

set2facts/U : set2facts O S (disj (objequal O (object/ N)) G)
              <- set`not-member S' N
              <- set`add S' N S
              <- set2facts O S' G.

%{%
 Convert the explicit context to permissions, which
 consists of non-null information, class predicate, and,
 for shared the nesting facts, for each parameter.
 Notice that, unique has the same permission as borrowed
 parameter. We use a separate procedure to generate the
 encumbered permission for them. So, the cxt should only
 contain borrowed and shared types.
%}%

cxt2perm : clsmap -> predmap -> cxt -> permission -> type.

cxt2perm/nil : cxt2perm _ _ cxt/nil empty.

cxt2perm/cons : cxt2perm CM PM (cxt/cons O T B) ((PF O) , Pi2)
                <- ty2perm PM T PF
                <- cxt2perm CM PM B Pi2.


% Apply given effect to the input permission, and convert
% it to another permission.

apply-efx : efx -> permission -> permission -> type.

apply-efx/read : apply-efx efx/read Pi (scale half Pi).

apply-efx/write : apply-efx efx/write Pi Pi.



% Convert a efx to a fraction, which is either half or one.
% This function is partial, and only applies to read and write.

efx2frac : efx -> fraction -> type.

efx2frac/read : efx2frac efx/read half.

efx2frac/write : efx2frac efx/write (fraction/ one).


% Convert "shared-efx" to permissions. "shared-efx" is used to
% record effects on shared.

shared-efx2perm : shared-efx -> permission -> type.

shared-efx2perm/none : shared-efx2perm shared-efx/none empty.

shared-efx2perm/read : shared-efx2perm shared-efx/read Pi
                       <- apply-efx efx/read (allperm null) Pi.

shared-efx2perm/write : shared-efx2perm shared-efx/write Pi
                        <- apply-efx efx/write (allperm null) Pi.


% consider nonnull type and produce a conditional if
% the object could be null.

consider-nn : (object -> permission) -> nn ->
	(object -> permission) -> type.

consider-nn/yes : consider-nn ([x] PF x) nn/yes ([x] PF x).

consider-nn/may : consider-nn PF nn/may
                  ([r] unitperm (conditional (objequal r null) empty (PF r))).


% Convert a efxmap to permissions. Each entry ((O, F), X) in
% the efxmap will be converted to a packed field permission with
% the effect X been applied to it.

efxmap2perm : clsmap -> predmap -> cxt -> efxmap -> permission -> type.

efxmap2perm/0 : efxmap2perm _ _ _ efxmap/0 empty.

efxmap2perm/U
  : efxmap2perm CM PM B M' Pi2
    -> nat2pair K (pair/ N F)
    -> cxt`lookup B (object/ N) (ty/ NN _ C)
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F T
    -> ty2perm PM T PF
    -> consider-nn ([x] unitperm (precise-exists x F PF)) NN Pi1F
    -> apply-efx X (Pi1F (object/ N)) Pi1
    -> efxmap`fresh M' K
    -> efxmap`update M' K X M
    -> efxmap2perm CM PM B M (Pi1 , Pi2).


%{
 A whole object can be consumed, for instance, in x.f = a, object
 a is consumed. In this case, we treated as if all of a's field are
 consumed. But, we also need the encumbered permission:
  \forall f (P(a.f) encumbered-in P(a.all))

 Given a set of objects, the relation "make-fperm" construct
 such an encumbered permission for each object, using "make-fperm1".
}%

make-fperm1 : predmap -> object -> fldmap -> set -> permission -> type.

make-fperm1/0 : make-fperm1 _ _ _ set/0 empty.

make-fperm1/U
  : make-fperm1 PM O FM S' Pi
    -> set`not-member S' F
    -> set`add S' F S
    -> fldmap`lookup FM F T
    -> ty2perm PM T PF
    -> make-fperm1 PM O FM S (unitperm (precise-exists O F PF) , Pi).


make-fperm : clsmap -> predmap -> cxt -> set -> permission -> type.

make-fperm/0 : make-fperm _ _ _ set/0 empty.

make-fperm/U : make-fperm CM PM B SP Pi
               -> cxt`lookup B (object/ N) (ty/ NN _ C)
               -> predmap`lookup PM C CP
               -> clsmap`lookup CM C FM
               -> fldmap`domain FM FS
               -> ({x} make-fperm1 PM x FM FS (Pi2 x))
               -> consider-nn
                 ([x] (combine (one-predcall CP x)
                        (combine (obj-ne-null x)
                          (unitperm (encumbered (Pi2 x) (allperm x)))))) NN PiF
               -> set`not-member SP N
               -> set`add SP N S
               -> make-fperm CM PM B S ((PiF (object/ N)), Pi).

% Convert effects to input permissions. This is simply a wrapper on
% efxmap2perm and shared-efx2perm, as the definition of effects.

effects2input : clsmap -> predmap -> cxt -> effects -> permission -> type.

effects2input/
  : cxt2perm CM PM B Pi1
    -> make-fperm CM PM B Q Pi2
    -> set2efxmap S efx/write M'
    -> efxmap2perm CM PM B M' Pi3
    -> efxmap2perm CM PM B M Pi4
    -> shared-efx2perm SX Pi5
    -> effects2input CM PM B
      (effects/ M S SX Q) ((Pi1 , (Pi2 , Pi3)) , Pi4 , Pi5).


% compute minimum effects for this efxmap, start with efx/write.

efxmap-minimum-efx* : efx -> efxmap -> efx -> type.

efxmap-minimum-efx/0 : efxmap-minimum-efx* X efxmap/0 X.

efxmap-minimum-efx/U : efxmap-minimum-efx* X1 M X4
                <- efxmap`fresh M' N
                <- efxmap`update M' N X2 M
                <- efx`min X1 X2 X3
                <- efxmap-minimum-efx* X3 M' X4.

%abbrev efxmap-minimum-efx = [M][X] efxmap-minimum-efx* efx/write M X.


%{
 Convert effects to output (defined in permission-type/environment.elf).
 The format of output varies depending on the resulting reftype. The
 cases for unique reftype are basically combinations on size of set and
 tgtmap. We need special case when tgtmap size is zero since
   Pi, Pi --|- empty is obviously unsound: Pi should come from at least
 one field permission.

 Another special case is when set and tgtmap are both empty, and
 the unique permission is not from shared. This is the case when we
 have method calls (including constructor call) that return fresh
 locations alone with permissions. These locations are local, and unless
 they are later bound to a let-expression, they will only be used once.
 For let-expression, we use substitution to check effects.

 Note:
 06-16-13: efxmap may contain inner-efxmap/0 as value. Do we need to
 remove them first? Maybe not, since tgtmap in reftype should definitely
 be well-formed.
 08-01-13: previous definition is wrong: it always generate scaled perm
 for unique/0t, unique/+f and unique/+t. However, in these two instances
 we need to consider all encumbered permissions and generate the "best"
 permission. In other words, if all encumbered permissions are not
 fractional, then we shouldn't apply scale.
 09-22-13: we separate read/write efx with consume efx. The consume efx
 only appear as input.
}%

simple-targets : targets -> type.

simple-targets/shared : simple-targets targets/shared.

simple-targets/unique : simple-targets (targets/unique set/0 set/0 false).


effects2output : clsmap -> predmap ->
	cxt -> reftype -> effects -> expr-output -> type.

effects2output/simple
  : effects2output CM PM B
    (reftype/ NN C G) (effects/ M _ SX _)
    (output/exists [r]
      (output/expr r % "shared" don't need scaling
        (combine Pi1
          (combine (PF r) (combine Pi2 Pi3)))))
    <- cxt2perm CM PM B Pi1
    <- efxmap2perm CM PM B M Pi2
    <- shared-efx2perm SX Pi3
    <- simple-targets G
    <- reftype2ty (reftype/ NN C G) T
    <- ty2perm PM T PF.

effects2output/unique/0f
  : effects2output CM PM B
    (reftype/ NN C (targets/unique S S2 false)) (effects/ M _ SX _)
    (output/exists [r]
      (output/expr r
        (combine Pi1
          (combine (PF r)
            (combine (unitperm (nonlinear (GF r)))
              (combine Pi2 Pi3))))))
    <- set`size S (s _)
    <- set`size S2 z
    <- cxt2perm CM PM B Pi1
    <- ({r} set2facts r S (GF r))
    <- efxmap2perm CM PM B M Pi2
    <- shared-efx2perm SX Pi3
    <- ty2perm PM (ty/ NN annot/borrow C) PF.

effects2output/unique/+f
  : effects2output CM PM B
    (reftype/ NN C (targets/unique S S2 false)) (effects/ M _ SX _)
    (output/exists [o]
      (output/exists [r]
        (output/expr o
          (combine Pi1
            (combine (unitperm (nonlinear (disj (objequal o r) (GF o))))
              (combine (scale Q (PF r))
                (combine (unitperm (encumbered (scale Q (PF r)) Pi3))
                  (combine Pi2 Pi4))))))))
    <- set`size S2 (s _)
    <- cxt2perm CM PM B Pi1
    <- ({r} set2facts r S (GF r))
    <- efxmap`partition M S2 M1 M2
    <- efxmap2perm CM PM B M1 Pi2
    <- efxmap2perm CM PM B M2 Pi3
    <- efxmap-minimum-efx M2 X
    <- efx2frac X Q
    <- shared-efx2perm SX Pi4
    <- ty2perm PM (ty/ NN annot/unique C) PF.

effects2output/unique/t
  : effects2output CM PM B
    (reftype/ NN C (targets/unique S S2 true)) (effects/ M _ SX _)
    (output/exists [o]
      (output/exists [r]
        (output/expr o
          (combine Pi1
            (combine (unitperm (nonlinear (disj (objequal o r) (GF o))))
              (combine (scale Q (PF r))
                (combine
                  (unitperm (encumbered (scale Q (PF r)) (combine Pi3 Pi4)))
                  Pi2)))))))
    <- cxt2perm CM PM B Pi1
    <- ({r} set2facts r S (GF r))
    <- efxmap`partition M S2 M1 M2
    <- efxmap2perm CM PM B M1 Pi2
    <- efxmap2perm CM PM B M2 Pi3
    <- efxmap-minimum-efx M2 X1
    <- shared-efx2efx SX X2
    <- efx`min X1 X2 X
    <- efx2frac X Q
    <- shared-efx2perm SX Pi4
    <- ty2perm PM (ty/ NN annot/unique C) PF.


% Convert methty to proctype.

% The first set of permissions are those from read and write effects,
% the second set of permissions are those from consumed effects.

methty2proctype* : predmap -> permission -> permission -> methty -> proctype -> type.

methty2proctype/base
  : methty2proctype* PM Pi Pic (methty/base T SX)
    (proctype/base (combine Pi (combine Pic Pis))
      (output/exists [ret]
        (output/expr ret (combine (PF ret) (combine Pi Pis)))))
    <- ty2perm PM T PF
    <- shared-efx2perm MX Pis.

methty2proctype/args/unique
  : methty2proctype* PM Pi Pic
    (methty/arg (ty/ NN annot/unique C) set/0 set/0 MT) (proctype/arg PTF)
    <- ty2perm PM (ty/ NN annot/unique C) PF
    <- ({x:object} methty2proctype* PM Pi (Pic , (PF x)) MT (PTF x)).

methty2proctype/args/borrow
  : methty2proctype* PM Pi1 Pic
    (methty/arg (ty/ NN annot/borrow C) Rs Ws MT) (proctype/arg PTF)
    <- ty2perm PM (ty/ NN annot/borrow C) PF
    <- ({x} methty2proctype* PM
         (Pi1 , (Pi2 x)) (Pic , PF x) MT (PTF x)).

methty2proctype/args/shared
  : methty2proctype* PM Pi Pic
    (methty/arg (ty/ NN annot/shared C) set/0 set/0 MT) (proctype/arg PTF)
    <- ty2perm PM (ty/ NN annot/shared C) PF
    <- ({x} methty2proctype* PM Pi Pic MT (PTF x)).

%abbrev methty2proctype = [PM][MT][PT] methty2proctype* PM empty empty MT PT.


% Convert consty (constructor type) to proctype with a hole.

consty2proctype* : predmap -> fldmap -> permission
    -> permission -> methty -> (object -> proctype) -> type.

consty2proctype/base
  : consty2proctype* PM FM Pi Pic
    (methty/base (ty/ nn/yes annot/unique C) MX)
    ([t] (proctype/base
           (combine (obj-ne-null t)
             (combine (OS t) (combine Pi (combine Pic Pis))))
           (output/exists [ret]
             (output/expr ret
               (combine (PF ret) (combine Pi Pis))))))
    <- ty2perm PM (ty/ nn/yes annot/unique C) PF
    <- fldmap`domain FM S
    <- ({t} allocFields t S (OS t)).

consty2proctype/args/unique
  : consty2proctype* PM FM Pi Pic
    (methty/arg (ty/ NN annot/unique C) set/0 set/0 CT) ([t] proctype/arg (PTF t))
    <- ty2perm PM (ty/ NN annot/unique C) PF
    <- ({x} consty2proctype* PM FM Pi (Pic , PF x) CT ([t] (PTF t x))).

consty2proctype/args/borrow
  : consty2proctype* PM FM Pi1 Pic
    (methty/arg (ty/ NN annot/borrow C) Rs Ws CT) ([t] proctype/arg (CTF t))
    <- ty2perm PM (ty/ NN annot/unique C) PF
    <- ({x} consty2proctype* PM FM (Pi1 , (Pi2 x)) (Pic , PF x) CT ([t] (CTF t x))).

consty2proctype/args/shared
  : consty2proctype* PM FM Pi Pic
    (methty/arg (ty/ NN annot/shared C) set/0 set/0 CT) ([t] proctype/arg (CTF t))
    <- ty2perm PM (ty/ NN annot/shared C) PF
    <- ({x} consty2proctype* PM FM Pi Pic CT (CTF x)).

%abbrev consty2proctype = [PM][FM][CT][PTF]
                          consty2proctype* PM FM empty empty CT PTF.


% Convert methmap to progtype, calls methty2proctype and consty2proctype.

methmap2progtype : clsmap -> predmap -> methmap -> progtype -> type.

methmap2progtype/0 : methmap2progtype _ _ methmap`map/0 progtype`map/0.

methmap2progtype/U/c
  : methmap2progtype CM PM MM W
    <- methmap`fresh MMP N
    <- methmap`update MMP N
      (methty/arg (ty/ nn/yes annot/unique C) set/0 set/0 CT) MM
    <- clsmap`lookup CM N FM
    <- consty2proctype PM FM CT PTF
    <- methmap2progtype CM PM MMP WP
    <- progtype`update WP N (proctype/arg PTF) W.

methmap2progtype/U/m
  : methmap2progtype CM PM MM W
    <- methmap`fresh MMP N
    <- methmap`update MMP N MT MM
    <- methty2proctype PM MT PT
    <- methmap2progtype CM PM MMP WP
    <- progtype`update WP N PT W.


% Convert a methmap to progtype, calling methmap2progtype.

env2progtype : clsmap -> methmap -> progtype -> type.

env2progtype/
  : env2progtype CM MM W
    <- clsmap2predmap CM PM
    <- methmap2progtype CM PM MM W.



%%% Theorems

%theorem shared-efx-not-none-implies-shared-efx2efx
  : forall* {SX}
    forall {NN: shared-efx-not-none SX}
    exists {X} {SX2X: shared-efx2efx SX X}
    true.

- : shared-efx-not-none-implies-shared-efx2efx
    shared-efx-not-none/ _ shared-efx2efx/.

%worlds (objvar) (shared-efx-not-none-implies-shared-efx2efx _ _ _).
%total {} (shared-efx-not-none-implies-shared-efx2efx _ _ _).


% false-implies

%theorem false-implies-set2facts
  : forall* {O} {S} {G}
    forall {V:void}
    exists {S=>G: set2facts O S G}
    true.

%worlds (objvar) (false-implies-set2facts _ _).
%total {} (false-implies-set2facts _ _).


%theorem false-implies-apply-efx
  : forall* {X} {Pi} {Pi2}
    forall {V:void}
    exists {AP: apply-efx X Pi Pi2}
    true.

%worlds (objvar) (false-implies-apply-efx _ _).
%total {} (false-implies-apply-efx _ _).


%theorem false-implies-efxmap2perm
  : forall* {CM} {PM} {B} {M} {Pi}
    forall  {V: void}
    exists  {M=>Pi: efxmap2perm CM PM B M Pi}
    true.

%worlds (objvar) (false-implies-efxmap2perm _ _).
%total {} (false-implies-efxmap2perm _ _).


% respects-eq

%theorem set2facts-respects-eq
  : forall* {S1} {S2} {O1} {O2} {G1} {G2}
    forall {S2G: set2facts O1 S1 G1}
    {E: object`eq O1 O2} {E: set`eq S1 S2}
    {E: permission`eq (unitperm (nonlinear G1)) (unitperm (nonlinear G2))}
    exists {S2G2: set2facts O2 S2 G2}
    true.

- : set2facts-respects-eq S2G object`eq/ set`eq/ permission`eq/ S2G.

%worlds (objvar) (set2facts-respects-eq _ _ _ _ _).
%total {} (set2facts-respects-eq _ _ _ _ _).


%theorem cxt2perm-respects-eq
  : forall* {CM} {PM} {B} {Pi} {CM'} {PM'} {B'} {Pi'}
    forall {B2P: cxt2perm CM PM B Pi}
    {CME: clsmap`eq CM CM'} {PME: predmap`eq PM PM'}
    {BE: cxt`eq B B'} {PE: permission`eq Pi Pi'}
    exists {B2P': cxt2perm CM' PM' B' Pi'}
    true.

- : cxt2perm-respects-eq
    B2P clsmap`eq/ predmap`eq/ cxt`eq/ permission`eq/ B2P.

%worlds (objvar) (cxt2perm-respects-eq _ _ _ _ _ _).
%total {} (cxt2perm-respects-eq _ _ _ _ _ _).


%theorem apply-efx-respects-eq
  : forall* {X1} {X2} {P1} {P2} {S1} {S2}
    forall {AP: apply-efx X1 P1 S1}
    {E: efx`eq X1 X2}
    {E: permission`eq P1 P2} {E: permission`eq S1 S2}
    exists {AP: apply-efx X2 P2 S2}
    true.

- : apply-efx-respects-eq apply-efx/read
    efx`eq/ permission`eq/ permission`eq/ apply-efx/read.

- : apply-efx-respects-eq apply-efx/write
    efx`eq/ permission`eq/ permission`eq/ apply-efx/write.

%worlds (objvar) (apply-efx-respects-eq _ _ _ _ _).
%total {} (apply-efx-respects-eq _ _ _ _ _).


%theorem efx2frac-respects-eq
  : forall* {X} {X'} {Q}
    forall {X2Q: efx2frac X Q}
    {XE: efx`eq X X'}
    exists {X2Q': efx2frac X' Q}
    true.

- : efx2frac-respects-eq X2Q efx`eq/ X2Q.

%worlds (objvar) (efx2frac-respects-eq _ _ _).
%total {} (efx2frac-respects-eq _ _ _).


%theorem consider-nn-respects-eq
  : forall* {NN1} {NN2} {PF1} {PF2} {PK1} {PK2}
    forall {CNN: consider-nn PF1 NN1 PK1}
    {PFE: {x} permission`eq (PF1 x) (PF2 x)}
    {NNE: nonnull`eq NN1 NN2}
    {PKE: {x} permission`eq (PK1 x) (PK2 x)}
    exists {CNN: consider-nn PF2 NN2 PK2}
    true.

- : consider-nn-respects-eq CNN ([_] permission`eq/) nonnull`eq/
    ([_] permission`eq/) CNN.

%worlds (objvar) (consider-nn-respects-eq _ _ _ _ _ ).
%total { } (consider-nn-respects-eq _ _ _ _ _ ).


%theorem shared-efx2perm-respects-eq
  : forall* {SX} {SX'} {Pi} {Pi'}
    forall {SX2P: shared-efx2perm SX Pi}
    {XE: shared-efx`eq SX SX'} {PE: permission`eq Pi Pi'}
    exists {SX2P': shared-efx2perm SX' Pi'}
    true.

- : shared-efx2perm-respects-eq SX2P shared-efx`eq/ permission`eq/ SX2P.

%worlds (objvar) (shared-efx2perm-respects-eq _ _ _ _).
%total {} (shared-efx2perm-respects-eq _ _ _ _).


%theorem efxmap2perm-respects-eq
  : forall* {CM1} {PM1} {B1} {M1} {Pi1}
    {CM2} {PM2} {B2} {M2} {Pi2}
    forall  {M1=>Pi1: efxmap2perm CM1 PM1 B1 M1 Pi1}
    {E: clsmap`eq CM1 CM2} {E: predmap`eq PM1 PM2}
    {E: cxt`eq B1 B2} {E: efxmap`eq M1 M2}
    {E: permission`eq Pi1 Pi2}
    exists  {M2=>Pi2: efxmap2perm CM2 PM2 B2 M2 Pi2}
    true.

- : efxmap2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/
    cxt`eq/ efxmap`eq/ permission`eq/ M=>Pi.

%worlds (objvar) (efxmap2perm-respects-eq _ _ _ _ _ _ _).
%total {} (efxmap2perm-respects-eq _ _ _ _ _ _ _).


%theorem make-fperm1-respects-eq
  : forall* {FS1} {PM1} {PM2} {O1} {O2} {FM1} {FM2} {Pi1} {Pi2} {FS2}
    forall {MFP1: make-fperm1 PM1 O1 FM1 FS1 Pi1}
    {PME: predmap`eq PM1 PM2} {OE: object`eq O1 O2}
    {FME: fldmap`eq FM1 FM2} {FSE: set`eq FS1 FS2}
    {PE: permission`eq Pi1 Pi2}
    exists {MFP2: make-fperm1 PM2 O2 FM2 FS2 Pi2}
    true.

- : make-fperm1-respects-eq MFP predmap`eq/
    object`eq/ fldmap`eq/ set`eq/ permission`eq/ MFP.

%worlds (objvar) (make-fperm1-respects-eq _ _ _ _ _ _ _).
%total {} (make-fperm1-respects-eq _ _ _ _ _ _ _).


%theorem make-fperm-respects-eq
  : forall* {PM1} {PM2} {CM1} {CM2} {B1} {B2} {S1} {S2} {Pi1} {Pi2}
    forall {MFP1: make-fperm CM1 PM1 B1 S1 Pi1}
    {CME: clsmap`eq CM1 CM2}
    {PME: predmap`eq PM1 PM2}
    {BE: cxt`eq B1 B2} {SE: set`eq S1 S2}
    {PE: permission`eq Pi1 Pi2}
    exists {MFP2: make-fperm CM2 PM2 B2 S2 Pi2}
    true.

- : make-fperm-respects-eq MFP clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/
    permission`eq/ MFP.

%worlds (objvar) (make-fperm-respects-eq _ _ _ _ _ _ _).
%total {} (make-fperm-respects-eq _ _ _ _ _ _ _).


%theorem effects2input-respects-eq
  : forall* {CM} {PM} {B} {XX} {XX'} {Pi} {Pi'}
    forall {XX2I: effects2input CM PM B XX Pi}
    {E: effects`eq XX XX'} {E: permission`eq Pi Pi'}
    exists {XX2I': effects2input CM PM B XX' Pi'}
    true.

- : effects2input-respects-eq XX2I effects`eq/ permission`eq/ XX2I.

%worlds (objvar) (effects2input-respects-eq _ _ _ _).
%total {} (effects2input-respects-eq _ _ _ _).


%theorem efxmap-minimum-efx-respects-eq
  : forall* {M} {M'} {X1} {X1'} {X2} {X2'}
    forall {MX: efxmap-minimum-efx* X1 M X2}
    {E: efx`eq X1 X1'} {E: efxmap`eq M M'} {E: efx`eq X2 X2'}
    exists {MX: efxmap-minimum-efx* X1' M' X2'}
    true.

- : efxmap-minimum-efx-respects-eq MX efx`eq/ efxmap`eq/ efx`eq/ MX.

%worlds (objvar) (efxmap-minimum-efx-respects-eq _ _ _ _ _).
%total {} (efxmap-minimum-efx-respects-eq _ _ _ _ _).


%theorem effects2output-respects-eq
  : forall* {CM} {PM} {B} {NN} {C} {XX} {NN1} {C1} {XX1} {Out} {GS} {GS1}
    forall {XX2O: effects2output CM PM B (reftype/ NN C GS) XX Out}
    {E: nonnull`eq NN NN1} {E: nat`eq C C1} {E: targets`eq GS GS1}
    {E: effects`eq XX XX1}
    exists {XX2O: effects2output CM PM B (reftype/ NN1 C1 GS1) XX1 Out}
    true.

- : effects2output-respects-eq XX nonnull`eq/ nat`eq/ targets`eq/ effects`eq/ XX.

%worlds (objvar) (effects2output-respects-eq _ _ _ _ _ _).
%total { } (effects2output-respects-eq _ _ _ _ _ _).

% TODO: respects-eq for methty2proctype and consty2proctype..

% totality

%theorem set2facts-total* : forall {O}{S} exists {G} {S=>G: set2facts O S G} true.

%theorem set2facts-total/L
  : forall* {S} {O}
    forall {N} {Z: set`size S N}
    exists {G} {S=>G: set2facts O S G}
    true.

- : set2facts-total/L z _ f set2facts/0.

- : set2facts-total/L (s N) Z _ (set2facts/U SP=>GP A F)
    <- set`lookup-implies-not-member-update (set`lookup/= nat`eq/) SP F A
    <- set`not-member-add-increases-size-converse Z F A Z'
    <- set2facts-total/L N Z' _ SP=>GP.

%worlds (objvar) (set2facts-total/L _ _ _ _).
%total (N) (set2facts-total/L N _ _ _).

- : set2facts-total* _ _ G S=>G
    <- set`size-total Z
    <- set2facts-total/L _ Z G S=>G.

%worlds (objvar) (set2facts-total* _ _ _ _).
%total {} (set2facts-total* _ _ _ _).

%abbrev set2facts-total = set2facts-total* _ _ _.


% cxt needs to be consistent with clsmap

%theorem clsmap-cxt-implies-cxt2perm
  : forall* {CM} {PM} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    exists {Pi:permission} {B=>Pi: cxt2perm CM PM B Pi}
    true.

- : clsmap-cxt-implies-cxt2perm _ _ clsmap-cxt/nil _ cxt2perm/nil.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/cons/b CM-B (clsmap-ty/notnull L))
    _ (cxt2perm/cons B2P T2PF)
    <- clsmap-lookup-implies-ty2perm CM2PM L _ T2PF
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B2P.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/cons/s CM-B (clsmap-ty/notnull L))
    _ (cxt2perm/cons B2P T2PF)
    <- clsmap-lookup-implies-ty2perm CM2PM L _ T2PF
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B2P.

%worlds (objvar) (clsmap-cxt-implies-cxt2perm _ _ _ _ _).
%total (CM-B) (clsmap-cxt-implies-cxt2perm _ _ CM-B _ _).


% TODO: efx2frac

%theorem efx2frac-total*
  : forall {X} exists {Q} {X2Q: efx2frac X Q} true.

- : efx2frac-total* efx/read _ efx2frac/read.

- : efx2frac-total* efx/write _ efx2frac/write.

%worlds (objvar) (efx2frac-total* _ _ _).
%total {} (efx2frac-total* _ _ _).

%abbrev efx2frac-total = efx2frac-total* _ _.


%theorem apply-efx-total*
  : forall {X} {Pi}
    exists {PF} {AP: apply-efx X Pi PF}
    true.

- : apply-efx-total* efx/read _ _ apply-efx/read.

- : apply-efx-total* efx/write _ _ apply-efx/write.

%worlds (objvar) (apply-efx-total* _ _ _ _).
%total {} (apply-efx-total* _ _ _ _).

%abbrev apply-efx-total = apply-efx-total* _ _ _.


%theorem shared-efx2perm-total*
  : forall {MX}
    exists {Pi} {MX=>Pi: shared-efx2perm MX Pi}
    true.

- : shared-efx2perm-total* shared-efx/none _ shared-efx2perm/none.

- : shared-efx2perm-total* shared-efx/read _ (shared-efx2perm/read AP)
    <- apply-efx-total AP.

- : shared-efx2perm-total* shared-efx/write _ (shared-efx2perm/write AP)
    <- apply-efx-total AP.

%worlds (objvar) (shared-efx2perm-total* _ _ _).
%total {} (shared-efx2perm-total* _ _ _).

%abbrev shared-efx2perm-total = shared-efx2perm-total* _ _.


%theorem consider-nn-total*
  : forall* {GF} forall {NN} exists {GF2} {GF+NN=>GF2: consider-nn GF NN GF2} true.

- : consider-nn-total* nn/yes _ consider-nn/yes.

- : consider-nn-total* nn/may _ consider-nn/may.

%worlds (objvar) (consider-nn-total* _ _ _).
%total { } (consider-nn-total* _ _ _).

%abbrev consider-nn-total = consider-nn-total* _ _.


%theorem clsmap-cxt-set-implies-efxmap2perm
  : forall* {CM} {PM} {B} {M} {S}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM} {DM: efxmap`domain M S}
    {B-M: clsmap-cxt-set CM B S}
    exists {Pi} {M=>Pi: efxmap2perm CM PM B M Pi}
    true.

- : clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM
    efxmap`domain/0 clsmap-cxt-set/0 _ efxmap2perm/0.

- : clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM-M=S
    (clsmap-cxt-set/U CM-B-S' N+F=>K BL CML FML K!<S' S'+K=S)
    _ (efxmap2perm/U M'=>Pi' N+F=>K BL CML FML T2PF CNN AP K!<M' M'+K+X=M)
    <- set`add-implies-member S'+K=S K<-S
    <- efxmap`domain-preserves-lookup-converse K<-S DM-M=S X M->K=X
    <- efxmap`lookup-implies-fresh-update M->K=X M' K!<M' M'+K+X=M
    <- efxmap`domain-commute-fresh-update-converse DM-M=S K!<M' M'+K+X=M K!<S'
      S'+K=S DM-M'=S'
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM-M'=S' CM-B-S' _
      M'=>Pi'
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- consider-nn-total CNN
    <- apply-efx-total AP.

%worlds (objvar) (clsmap-cxt-set-implies-efxmap2perm _ _ _ _ _ _).
%total (T) (clsmap-cxt-set-implies-efxmap2perm _ _ _ T _ _).


%theorem clsmap-cxt-effects-implies-efxmap2perm
  : forall* {CM} {PM} {B} {M} {SX} {S} {Q}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B-M: clsmap-cxt-effects CM B (effects/ M S SX Q)}
    exists {Pi} {M=>Pi: efxmap2perm CM PM B M Pi}
    true.

- : clsmap-cxt-effects-implies-efxmap2perm CM-CM CM2PM
    (clsmap-cxt-effects/ DM _ _ _ CM-B-S _) _ M=>Pi
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM CM-B-S _ M=>Pi.

%worlds (objvar) (clsmap-cxt-effects-implies-efxmap2perm _ _ _ _ _).
%total {} (clsmap-cxt-effects-implies-efxmap2perm _ _ _ _ _).


%theorem make-fperm1-total
  : forall* {CM} {C} {PM} {O} {FM} {FS}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS}
    exists {Pi} {MF1: make-fperm1 PM O FM FS Pi}
    true.

%theorem make-fperm1-total/L
  : forall* {CM} {C} {PM} {O} {FM} {FS0} {FS}
    forall {N} {SZ: set`size FS N}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS0}
    {LE: set`leq FS FS0}
    exists {Pi} {MF1: make-fperm1 PM O FM FS Pi}
    true.

- : make-fperm1-total/L z _ _ _ _ _ set`leq/0 _ make-fperm1/0.

- : make-fperm1-total/L (s N) SZ CM-CM CM2PM CML DM-FM=FS0 FS<=FS0 _
    (make-fperm1/U FS'=>Pi F!<FS' FS'+F=FS FML T2PF)
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) FS' F!<FS' FS'+F=FS
    <- set`add-implies-member FS'+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
    <- fldmap`domain-preserves-lookup-converse F<-FS0 DM-FM=FS0 T FML
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- set`fresh-update-implies-leq F!<FS' FS'+F=FS FS'<=FS
    <- set`leq-transitive FS'<=FS FS<=FS0 FS'<=FS0
    <- set`not-member-add-increases-size-converse SZ F!<FS' FS'+F=FS SZ'
    <- make-fperm1-total/L N SZ' CM-CM CM2PM CML DM-FM=FS0 FS'<=FS0 _ FS'=>Pi.

- : make-fperm1-total CM-CM CM2PM CML DM _ MF1
    <- set`leq-reflexive _ LEQ
    <- set`size-total SZ
    <- make-fperm1-total/L _ SZ CM-CM CM2PM CML DM LEQ _ MF1.

%worlds (objvar) (make-fperm1-total/L _ _ _ _ _ _ _ _ _).
%total (N) (make-fperm1-total/L N _ _ _ _ _ _ _ _).

%worlds (objvar) (make-fperm1-total _ _ _ _ _ _).
%total { } (make-fperm1-total _ _ _ _ _ _).


%theorem make-fperm-total
  : forall* {CM} {PM} {B} {S}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-S: clsmap-cxt-set2 CM B S}
    exists {Pi} {MF: make-fperm CM PM B S Pi}
    true.

- : make-fperm-total CM-CM CM2PM clsmap-cxt-set2/0 _ make-fperm/0.

- : make-fperm-total CM-CM CM2PM
    (clsmap-cxt-set2/U CM-B-S' BL CML FS U) _
    (make-fperm/U MFP' BL PML CML FM-DM MF1 CNN FS U)
    <- fldmap`domain-total FM-DM
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- ({x} make-fperm1-total CM-CM CM2PM CML FM-DM _ (MF1 x))
    <- consider-nn-total CNN
    <- make-fperm-total CM-CM CM2PM CM-B-S' _ MFP'.

%worlds (objvar) (make-fperm-total _ _ _ _ _).
%total (S) (make-fperm-total _ _ S _ _).


%theorem clsmap-cxt-effects-implies-effects2input
  : forall* {CM} {PM} {B} {XX}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {CM-B-XX: clsmap-cxt-effects CM B XX}
    exists {Pi} {XX=>Pi: effects2input CM PM B XX Pi}
    true.

- : clsmap-cxt-effects-implies-effects2input CM-CM CM2PM CM-B
    (clsmap-cxt-effects/ DM _ S=>SQ Q<=SQ CM-B-R CM-B-S) _
    (effects2input/ B=>Pi1 MFP S=>M' M'=>Pi3 M=>Pi4 SX=>Pi5)
    <- collect-objs-implies-clsmap-cxt-set2 CM-B-S S=>SQ CM-B-SQ
    <- clsmap-cxt-set2-respects-geq CM-B-SQ Q<=SQ CM-B-Q
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>Pi1
    <- make-fperm-total CM-CM CM2PM CM-B-Q _ MFP
    <- set2efxmap-total S=>M'
    <- set2efxmap-implies-domain S=>M' DM'
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM' CM-B-S _ M'=>Pi3
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM CM-B-R _ M=>Pi4
    <- shared-efx2perm-total SX=>Pi5.

%worlds (objvar) (clsmap-cxt-effects-implies-effects2input _ _ _ _ _ _).
%total {} (clsmap-cxt-effects-implies-effects2input _ _ _ _ _ _).


%theorem efxmap-minimum-efx-total*
  : forall* {M} {X1}
    exists {X2} {MX: efxmap-minimum-efx* X1 M X2} true.

%theorem efxmap-minimum-efx-total*/L
  : forall* {M} {X1}
    forall {N} {Z: efxmap`size M N}
    exists {X2} {MX: efxmap-minimum-efx* X1 M X2} true.

- : efxmap-minimum-efx-total*/L z _  _ efxmap-minimum-efx/0.

- : efxmap-minimum-efx-total*/L (s N) Z _ (efxmap-minimum-efx/U MX MIN U F)
    <- efxmap`lookup-implies-fresh-update (efxmap`lookup/= nat`eq/) MP F U
    <- efx`min-total MIN
    <- efxmap`fresh-update-increases-size-converse Z F U ZP
    <- efxmap-minimum-efx-total*/L N ZP _ MX.

%worlds (objvar) (efxmap-minimum-efx-total*/L _ _ _ _).
%total (N) (efxmap-minimum-efx-total*/L N _ _ _).

- : efxmap-minimum-efx-total* _ MX
    <- efxmap`size-total Z
    <- efxmap-minimum-efx-total*/L _ Z _ MX.

%worlds (objvar) (efxmap-minimum-efx-total* _ _).
%total {} (efxmap-minimum-efx-total* _ _).

%abbrev efxmap-minimum-efx-total = efxmap-minimum-efx-total* _.


%theorem set2efxmap-implies-efxmap-minimum-efx
  : forall* {X} {S} {M}
    forall {N} {SZ: set`size S (s N)} {S+X=>M: set2efxmap S X M}
    exists {MX: efxmap-minimum-efx M X}
    true.

% - : set2efxmap-implies-efxmap-minimum-efx z (set`size/+ set`size/0)
%     (set2efxmap/U S+X=>M ID F U MUx)
%     (efxmap-minimum-efx/U KK MIN MU MF)
%     <- set`not-member-update-increases-size-converse 
%       (set`size/+ set`size/0) F U SZ
%     <- set`size-zero-implies-empty SZ S=0
%     <- efx-id-eq ID EQx
%     <- efx`eq-symmetric EQx EQ
%     <- efxmap`update-respects-eq MUx 
%     <- set2efxmap-unique S+X=>M set2efxmap/0 set`eq/ 
%     <- set2efxmap-

%worlds () (set2efxmap-implies-efxmap-minimum-efx _ _ _ _).
%trustme %total { } (set2efxmap-implies-efxmap-minimum-efx _ _ _ _).


%theorem clsmap-cxt-effects-implies-effects2output*
  : forall* {CM} {PM} {B} {XX} {NN} {C} {FM}
    forall {GS} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {CM-B-XX: clsmap-cxt-effects CM B XX}
    {GS-XX: targets-effects GS XX}
    {CML: clsmap`lookup CM C FM}
    exists {Out} {XX=>Out: effects2output CM PM B (reftype/ NN C GS) XX Out}
    true.

%theorem clsmap-cxt-effects-implies-effects2output/shared
  : forall* {CM} {PM} {B} {XX} {NN} {C} {FM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {CM-B-XX: clsmap-cxt-effects CM B XX}
    {CML: clsmap`lookup CM C FM}
    exists {Out} {XX=>Out: effects2output CM PM B
                           (reftype/ NN C targets/shared) XX Out}
    true.

- : clsmap-cxt-effects-implies-effects2output/shared
    CM-CM CM2PM CM-B CM-B-XX CML _
    (effects2output/simple T2PF reftype2ty/shared simple-targets/shared
      SX=>Pi3 M=>Pi2 B=>Pi1)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>Pi1
    <- clsmap-cxt-effects-implies-efxmap2perm CM-CM CM2PM CM-B-XX _ M=>Pi2
    <- shared-efx2perm-total SX=>Pi3
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/notnull CML) _ T2PF.

%worlds (objvar) (clsmap-cxt-effects-implies-effects2output/shared _ _ _ _ _ _ _).
%total {} (clsmap-cxt-effects-implies-effects2output/shared _ _ _ _ _ _ _).


%theorem clsmap-cxt-effects-implies-effects2output/unique*
  : forall* {CM} {PM} {B} {XX} {NN} {C} {FM}
    forall {S} {S2} {SB} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {G-XX: targets-effects (targets/unique S S2 SB) XX}
    {CM-B-XX: clsmap-cxt-effects CM B XX}
    {CML: clsmap`lookup CM C FM}
    exists {Out} {XX=>Out: effects2output CM PM B
                           (reftype/ NN C (targets/unique S S2 SB)) XX Out}
    true.

- : clsmap-cxt-effects-implies-effects2output/unique*
    set/0 set/0 false CM-CM CM2PM CM-B _ CM-B-XX CML _
    (effects2output/simple T2PF reftype2ty/unique simple-targets/unique
      SX=>Pi3 M=>Pi2 B=>Pi1)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>Pi1
    <- clsmap-cxt-effects-implies-efxmap2perm CM-CM CM2PM CM-B-XX _ M=>Pi2
    <- shared-efx2perm-total SX=>Pi3
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/notnull CML) _ T2PF.

- : clsmap-cxt-effects-implies-effects2output/unique*
    (set/+ _ _) set/0 false CM-CM CM2PM CM-B _ CM-B-XX CML _
    (effects2output/unique/0f T2PF SX=>Pi3 M=>Pi2 S=>G B=>Pi1 set`size/0
      (set`size/+ Z))
    <- set`size-total Z
    <- ({r} set2facts-total (S=>G r))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>Pi1
    <- clsmap-cxt-effects-implies-efxmap2perm CM-CM CM2PM CM-B-XX _ M=>Pi2
    <- shared-efx2perm-total SX=>Pi3
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/notnull CML) _ T2PF.

- : clsmap-cxt-effects-implies-effects2output/unique*
    _ (set/+ _ _) false CM-CM CM2PM CM-B
    (targets-effects/unique _ S2<=M2 _)
    (clsmap-cxt-effects/ DM _ _ _ CM-B-S _) CML _
    (effects2output/unique/+f T2PF
      SX=>Pi3 X2Q MX-M2 M2=>Pi3 M1=>Pi2 R
      S=>G B=>Pi1 (set`size/+ Z))
    <- set`size-total Z
    <- ({r} set2facts-total (S=>G r))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>Pi1
    <- efxmap`partition-total R
    <- efxmap`partition-implies-leq R LE1 LE2
    <- efxmap`domain-total DM1
    <- efxmap`domain-total DM2
    <- efxmap`domain-preserves-leq* LE1 DM1 DM SLE1
    <- efxmap`domain-preserves-leq* LE2 DM2 DM SLE2
    <- clsmap-cxt-set-respects-geq CM-B-S SLE1 CM-B-S1
    <- clsmap-cxt-set-respects-geq CM-B-S SLE2 CM-B-S2
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM1 CM-B-S1 _ M1=>Pi2
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM2 CM-B-S2 _ M2=>Pi3
    <- shared-efx2perm-total SX=>Pi3
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/notnull CML) _ T2PF
    <- efxmap-minimum-efx-total MX-M2
    <- efx2frac-total X2Q.

- : clsmap-cxt-effects-implies-effects2output/unique*
    _ _ true CM-CM CM2PM CM-B
    (targets-effects/unique _ S2<=M2 (shared-efx-relation/t NN))
    (clsmap-cxt-effects/ DM _ _ _ CM-B-S _) CML _
    (effects2output/unique/t T2PF SX=>Pi3 X2Q MX-X SX2X MX-M2 M2=>Pi3 M1=>Pi2 SG
      S=>G B=>Pi1)
    <- ({r} set2facts-total (S=>G r))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>Pi1
    <- efxmap`partition-total SG
    <- efxmap`partition-implies-leq SG LE1 LE2
    <- efxmap`domain-total DM1
    <- efxmap`domain-total DM2
    <- efxmap`domain-preserves-leq* LE1 DM1 DM SLE1
    <- efxmap`domain-preserves-leq* LE2 DM2 DM SLE2
    <- clsmap-cxt-set-respects-geq CM-B-S SLE1 CM-B-S1
    <- clsmap-cxt-set-respects-geq CM-B-S SLE2 CM-B-S2
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM1 CM-B-S1 _ M1=>Pi2
    <- clsmap-cxt-set-implies-efxmap2perm CM-CM CM2PM DM2 CM-B-S2 _ M2=>Pi3
    <- shared-efx2perm-total SX=>Pi3
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/notnull CML) _ T2PF
    <- efxmap-minimum-efx-total MX-M2
    <- shared-efx-not-none-implies-shared-efx2efx NN _ SX2X
    <- efx`min-total MX-X
    <- efx2frac-total X2Q.

%worlds (objvar)
  (clsmap-cxt-effects-implies-effects2output/unique* _ _ _ _ _ _ _ _ _ _ _).
%total {}
  (clsmap-cxt-effects-implies-effects2output/unique* _ _ _ _ _ _ _ _ _ _ _).


%abbrev clsmap-cxt-effects-implies-effects2output/unique
  = clsmap-cxt-effects-implies-effects2output/unique* _ _ _.

- : clsmap-cxt-effects-implies-effects2output* targets/shared CM-CM CM2PM CM-B
    CM-B-XX GS-XX CML _ XX=>Out
    <- clsmap-cxt-effects-implies-effects2output/shared CM-CM CM2PM CM-B CM-B-XX
      CML _ XX=>Out.

- : clsmap-cxt-effects-implies-effects2output* (targets/unique _ _ _)
    CM-CM CM2PM CM-B CM-B-XX GS-XX CML _ XX=>Out
    <- clsmap-cxt-effects-implies-effects2output/unique
      CM-CM CM2PM CM-B GS-XX CM-B-XX CML _ XX=>Out.

%worlds (objvar) (clsmap-cxt-effects-implies-effects2output* _ _ _ _ _ _ _ _ _).
%total {} (clsmap-cxt-effects-implies-effects2output* _ _ _ _ _ _ _ _ _).

%abbrev clsmap-cxt-effects-implies-effects2output
  = clsmap-cxt-effects-implies-effects2output* _.


% U-inversions

%theorem set2facts/U-inversion
  : forall* {O} {S} {SP} {G} {N}
    forall {S=>G: set2facts O S G}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    exists {GP} {SP=>GP: set2facts O SP GP}
    {IMP1: bimplies true G (disj (objequal O (object/ N)) GP)}
    {IMP2: bimplies true (disj (objequal O (object/ N)) GP) G}
    true.

%theorem set2facts/U-inversion/L
  : forall* {O} {S} {SP} {N} {S1} {N1} {G1} {P}
    forall {NM1: set`not-member S1 N1}
    {A1: set`add S1 N1 S}
    {S1=>G1: set2facts O S1 G1}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    {E?: nat`eq? N N1 P}
    exists {GP} {SP=>GP: set2facts O SP GP}
    {IMP1: bimplies true
          (disj (objequal O (object/ N1)) G1)
          (disj (objequal O (object/ N)) GP)}
    {IMP2: bimplies true
           (disj (objequal O (object/ N)) GP)
           (disj (objequal O (object/ N1)) G1)}
    true.

- : set2facts/U-inversion/L F1 U1 S2G1 F2 U2 nat`eq?/yes _ S2G
    (bimplies/reflexive) (bimplies/reflexive)
    <- set`not-member-add-cancels F1 U1 F2 U2 nat`eq/ set`eq/ S1=S2
    <- set2facts-respects-eq S2G1 object`eq/ S1=S2 permission`eq/ S2G.

- : set2facts/U-inversion/L F1 U1 S2G1 F2 U2 (nat`eq?/no N<>N1) _
    (set2facts/U S2G U4 F4)
    (bimplies/neg
      (bimplies/trans
        (bimplies/conj/XX
          (bimplies/reflexive)
          (bimplies/trans
            (bimplies/neg
              (IMP1)
              (bool`ne/TF))
            (bimplies/rem-negneg)))
        (bimplies/trans
          (bimplies/conj-commutative)
          (bimplies/trans
            (bimplies/conj-associative)
            (bimplies/conj/XX
              (bimplies/reflexive)
              (bimplies/trans
                (bimplies/conj-commutative)
                (bimplies/add-negneg))))))
      (bool`ne/FT))
    (bimplies/neg
      (bimplies/trans
        (bimplies/conj/XX
          (bimplies/reflexive)
          (bimplies/rem-negneg))
        (bimplies/trans
          (bimplies/conj-commutative)
          (bimplies/trans
            (bimplies/conj-associative)
            (bimplies/conj/XX
              (bimplies/reflexive)
              (bimplies/trans
                (bimplies/conj-commutative)
                (bimplies/trans
                  (bimplies/add-negneg)
                  (bimplies/neg
                    (IMP2)
                    (bool`ne/TF))))))))
      (bool`ne/FT))
    <- set`add-commutes-converse U2 U1 N<>N1 _ U4 U3
    <- set`add-preserves-not-member-converse F2 U4 F3
    <- set`add-preserves-not-member-converse F1 U3 F4
    <- set2facts/U-inversion S2G1 F3 U3 _ S2G IMP1 IMP2.

- : set2facts/U-inversion (set2facts/U S2G1 U1 F1) F2 U2 _ S2G IMP1 IMP2
    <- nat`eq?-total E?
    <- set2facts/U-inversion/L F1 U1 S2G1 F2 U2 E? _ S2G IMP1 IMP2.

%worlds (objvar) (set2facts/U-inversion _ _ _ _ _ _ _)
(set2facts/U-inversion/L _ _ _ _ _ _ _ _ _ _).
%total (N N1) (set2facts/U-inversion N _ _ _ _ _ _)
(set2facts/U-inversion/L _ _ N1 _ _ _ _ _ _ _).


%theorem make-fperm1/U-inversion
  : forall* {PM} {O} {FM} {FS} {Pi} {FS'} {F}
    forall {MF1: make-fperm1 PM O FM FS Pi}
    {F!<FS': set`not-member FS' F}
    {FS'+F=FS: set`add FS' F FS}
    exists {Pi'} {MF1': make-fperm1 PM O FM FS' Pi'}
    {T} {FML: fldmap`lookup FM F T}
    {PF} {T2PF: ty2perm PM T PF}
    {EQV: equiv Pi ((unitperm (precise-exists O F PF)) , Pi')}
    true.

%worlds (objvar) (make-fperm1/U-inversion _ _ _ _ _ _ _ _ _ _).
%trustme %total { } (make-fperm1/U-inversion _ _ _ _ _ _ _ _ _ _).


%theorem make-fperm/U-inversion
  : forall* {CM} {PM} {B} {S} {Pi} {SP} {N}
    forall {MF: make-fperm CM PM B S Pi}
    {NM: set`not-member SP N}
    {UD: set`add SP N S}
    exists {Pi'} {MFP: make-fperm CM PM B SP Pi'}
    {NN} {A} {C} {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {FM} {CML: clsmap`lookup CM C FM}
    {FS} {DM: fldmap`domain FM FS}
    {Pi2} {MF1: make-fperm1 PM (object/ N) FM FS Pi2}
    {EQV: equiv ((unitperm (encumbered Pi2 (allperm (object/ N)))) , Pi') Pi}
    true.

%worlds (objvar) (make-fperm/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {} (make-fperm/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem efxmap2perm/U-inversion
  : forall* {M} {MP} {CM} {PM} {K} {X} {Pi} {B}
    forall {M2P: efxmap2perm CM PM B M Pi}
    {FS: efxmap`fresh MP K}
    {U: efxmap`update MP K X M}
    exists {N} {F} {K=>N+F: nat2pair K (pair/ N F)}
    {NN} {A} {C} {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {FM} {CML: clsmap`lookup CM C FM}
    {T} {FML: fldmap`lookup FM F T}
    {PF} {T2PF: ty2perm PM T PF}
    {PiF} {CNN: consider-nn ([x] unitperm (precise-exists x F PF)) NN PiF}
    {Pi1} {AP: apply-efx X (PiF (object/ N)) Pi1}
    {Pi2} {M2P: efxmap2perm CM PM B MP Pi2}
    {EQV: equiv (Pi1 , Pi2) Pi}
    true.

%theorem efxmap2perm/U-inversion/L
  : forall* {BP} {M} {B} {CM} {PM} {K} {K1} {X1} {X} {T1} {PF1}
    {MP1} {MP} {Pi11} {Pi21} {NN1} {A1} {C1} {FM1} {N1} {F1} {PiF1}
    forall {FS1: efxmap`fresh MP1 K1}
    {U1: efxmap`update MP1 K1 X1 M}
    {K=>N+F: nat2pair K1 (pair/ N1 F1)}
    {BL1: cxt`lookup B (object/ N1) (ty/ NN1 A1 C1)}
    {CML1: clsmap`lookup CM C1 FM1}
    {FML1: fldmap`lookup FM1 F1 T1}
    {T2PF1: ty2perm PM T1 PF1}
    {CNN1: consider-nn ([x] unitperm (precise-exists x F1 PF1)) NN1 PiF1}
    {AP1: apply-efx X1 (PiF1 (object/ N1)) Pi11}
    {M2P: efxmap2perm CM PM B MP1 Pi21}
    {FS2: efxmap`fresh MP K}
    {U2: efxmap`update MP K X M}
    {EQ: nat`eq? K K1 BP}
    exists {N} {F} {K=>N+F: nat2pair K (pair/ N F)}
    {NN} {A} {C} {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {FM} {CML: clsmap`lookup CM C FM}
    {T} {FML: fldmap`lookup FM F T}
    {PF} {T2PF: ty2perm PM T PF}
    {PiF} {CNN: consider-nn ([x] unitperm (precise-exists x F PF)) NN PiF}
    {Pi1} {AP: apply-efx X (PiF (object/ N)) Pi1}
    {Pi2} {M2P: efxmap2perm CM PM B MP Pi2}
    {EQV: equiv (Pi1 , Pi2) (Pi11 , Pi21)}
    true.

- : efxmap2perm/U-inversion/L F1 U1 N2P1 BL1 CML1 FML1 T2PF1 CNN1 AP1 M2P1 F2 U2
    nat`eq?/yes _ _ N2P1 _ _ _ BL1 _ CML1 _ FML1 _ T2PF1 _ CNN1 _ AP2 _ M2P
    equiv/reflexive
    <- efxmap`fresh-update-cancels F1 U1 F2 U2 nat`eq/ efxmap`eq/ X1=X2 M1=M2
    <- apply-efx-respects-eq AP1 X1=X2 permission`eq/
      permission`eq/ AP2
    <- efxmap2perm-respects-eq M2P1 clsmap`eq/ predmap`eq/ cxt`eq/
      M1=M2 permission`eq/ M2P.

- : efxmap2perm/U-inversion/L F1 U1 N2P1 BL1 CML1 FML1 T2PF1 CNN1 AP1 M2P1 F2 U2
    (nat`eq?/no K<>K1) _ _ N2P2 _ _ _ BL2 _ CML2 _ FML2 _ T2PF2 _ CNN2 _ AP2 _
    (efxmap2perm/U M2P2 N2P1 BL1 CML1 FML1 T2PF1 CNN1 AP1 F4 U4)
    (equiv/transitive equiv/roll2 (equiv/combine equiv/reflexive EQV2))
    <- efxmap`update-commutes-converse U2 U1 K<>K1 _ U4 U3
    <- efxmap`update-preserves-fresh-converse F2 U4 F3
    <- efxmap`update-preserves-fresh-converse F1 U3 F4
    <- efxmap2perm/U-inversion M2P1 F3 U3 _ _ N2P2 _ _ _ BL2 _ CML2 _
      FML2 _ T2PF2 _ CNN2 _ AP2 _ M2P2 EQV2.

- : efxmap2perm/U-inversion
    (efxmap2perm/U M2P1 N2P1 BL1 CML1 FML1 T2PF1 CNN1 AP1 F1 U1)
    F2 U2 _ _ N2P _ _ _ BL _ CML _ FML _ T2PF _ CNN _ AP _ M2P EQV
    <- nat`eq?-total E?
    <- efxmap2perm/U-inversion/L
      F1 U1 N2P1 BL1 CML1 FML1 T2PF1 CNN1 AP1 M2P1 F2 U2 E? _ _ N2P
      _ _ _ BL _ CML _ FML _ T2PF _ CNN _ AP _ M2P EQV.

%worlds (objvar)
	(efxmap2perm/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(efxmap2perm/U-inversion/L
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A B)
	(efxmap2perm/U-inversion A _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(efxmap2perm/U-inversion/L
    _ _ _ _ _ _ _ _ _ B _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem efxmap-minimum-efx/U-inversion
  : forall* {M'} {N} {M} {X1} {X2} {X3} {X4}
    forall {MX: efxmap-minimum-efx* X1 M X4}
    {F: efxmap`fresh M' N}
    {U: efxmap`update M' N X2 M}
    exists {X2} {MX: efx`min X1 X2 X3}
    {MX': efxmap-minimum-efx* X3 M' X4}
    true.

%worlds (objvar) (efxmap-minimum-efx/U-inversion _ _ _ _ _ _).
%trustme %total {} (efxmap-minimum-efx/U-inversion _ _ _ _ _ _).


% uniqueness

%% set2facts is NOT unique, but results are "equivalent"

%theorem set2facts-bimplies
  : forall* {O1} {O2} {S1} {S2} {G1} {G2}
    forall {S1=>G1: set2facts O1 S1 G1}
    {S2=>G2: set2facts O2 S2 G2}
    {E: object`eq O1 O2} {E: set`eq S1 S2}
    exists {IMP1: bimplies true G1 G2} {IMP2: bimplies true G2 G1}
    true.

%worlds (objvar) (set2facts-bimplies _ _ _ _ _ _).
%trustme %total {} (set2facts-bimplies _ _ _ _ _ _).


%theorem efx2frac-unique
  : forall* {X1} {X2} {Q1} {Q2}
    forall {X1=>Q1: efx2frac X1 (fraction/ Q1)}
    {X2=>Q2: efx2frac X2 (fraction/ Q2)}
    {X1=X2: efx`eq X1 X2}
    exists {Q1=Q2: rat`eq Q1 Q2}
    true.

- : efx2frac-unique T1 T2 efx`eq/ rat`eq/.

%worlds () (efx2frac-unique _ _ _ _).
%total { } (efx2frac-unique _ _ _ _).


%theorem cxt2perm-unique
  : forall* {CM} {CM'} {PM} {PM'} {B} {B'} {Pi} {Pi'}
    forall {B=>Pi: cxt2perm CM PM B Pi}
    {B=>Pi': cxt2perm CM' PM' B' Pi'}
    {CME: clsmap`eq CM CM'} {PME: predmap`eq PM PM'} {BE: cxt`eq B B'}
    exists {PiE: permission`eq Pi Pi'}
    true.

- : cxt2perm-unique cxt2perm/nil cxt2perm/nil _ _ _ permission`eq/.

- : cxt2perm-unique (cxt2perm/cons B2P T2PF) (cxt2perm/cons B2P' T2PF')
    CME PME BE PiE
    <- cxt`eq/cons-inversion BE OE TE BPE
    <- ty2perm-deterministic T2PF T2PF' PME TE PFE
    <- permission`apply-object-preserves-eq PFE OE Pi1E
    <- cxt2perm-unique B2P B2P' CME PME BPE Pi2E
    <- permission`combine-preserves-eq Pi1E Pi2E PiE.

%worlds (objvar) (cxt2perm-unique _ _ _ _ _ _).
%total (T) (cxt2perm-unique T _ _ _ _ _).


%theorem consider-nn-unique
  : forall* {PF1} {PF2} {NN1} {NN2} {PK1} {PK2}
    forall {CNN: consider-nn PF1 NN1 PK1}
    {CNN: consider-nn PF2 NN2 PK2}
    {PFE: {x} permission`eq (PF1 x) (PF2 x)}
    {NNE: nonnull`eq NN1 NN2}
    exists {PKE: {x} permission`eq (PK1 x) (PK2 x)}
    true.

- : consider-nn-unique _ _ ([_] permission`eq/) nonnull`eq/ ([_] permission`eq/).

%worlds (objvar) (consider-nn-unique _ _ _ _ _).
%total { } (consider-nn-unique _ _ _ _ _).


%theorem shared-efx2perm-unique
  : forall* {SX} {SX'} {Pi} {Pi'}
    forall {SX2P: shared-efx2perm SX Pi}
    {SX2P': shared-efx2perm SX' Pi'}
    {XE: shared-efx`eq SX SX'}
    exists {PE: permission`eq Pi Pi'}
    true.

- : shared-efx2perm-unique SX SX' shared-efx`eq/ permission`eq/.

%worlds (objvar) (shared-efx2perm-unique _ _ _ _).
%total {} (shared-efx2perm-unique _ _ _ _).


%theorem apply-efx-deterministic
  : forall* {X1} {X2} {Pi1} {Pi2} {PF1} {PF2}
    forall {AP1: apply-efx X1 Pi1 PF1}
    {AP2: apply-efx X2 Pi2 PF2}
    {E: efx`eq X1 X2}
    {E: permission`eq Pi1 Pi2}
    exists {E: permission`eq PF1 PF2}
    true.

- : apply-efx-deterministic AP1 AP2 efx`eq/ permission`eq/ permission`eq/.

%worlds (objvar) (apply-efx-deterministic _ _ _ _ _).
%total {} (apply-efx-deterministic _ _ _ _ _).

%abbrev apply-efx-unique = apply-efx-deterministic.


%theorem make-fperm1-unique
  : forall* {PM} {O} {FM} {FS} {Pi}
    {PM'} {O'} {FM'} {FS'} {Pi'}
    forall {MF1: make-fperm1 PM O FM FS Pi}
    {MF1': make-fperm1 PM' O' FM' FS' Pi'}
    {PME: predmap`eq PM PM'} {OE: object`eq O O'}
    {FME: fldmap`eq FM FM'} {FSE: set`eq FS FS'}
    exists {EQV: permission`eq Pi Pi'}
    true.

%worlds (objvar) (make-fperm1-unique _ _ _ _ _ _ _).
%trustme %total {} (make-fperm1-unique _ _ _ _ _ _ _).


%theorem make-fperm-unique
  : forall* {CM} {PM} {B} {Q} {Pi} {CM'} {PM'} {B'} {Q'} {Pi'}
    forall {MF: make-fperm CM PM B Q Pi}
    {MF': make-fperm CM' PM' B' Q' Pi'}
    {CME: clsmap`eq CM CM'} {PME': predmap`eq PM PM'}
    {BE: cxt`eq B B'} {QE: set`eq Q Q'}
    exists {PE: permission`eq Pi Pi'}
    true.

%worlds (objvar) (make-fperm-unique _ _ _ _ _ _ _).
%trustme %total {} (make-fperm-unique _ _ _ _ _ _ _).


%theorem efxmap-minimum-efx-unique
  : forall* {M} {M'} {X1} {X1'} {X2} {X2'}
    forall {MX: efxmap-minimum-efx* X1 M X2}
    {MX': efxmap-minimum-efx* X1' M' X2'}
    {E: efx`eq X1 X1'} {E: efxmap`eq M M'}
    exists {E: efx`eq X2 X2'}
    true.

- : efxmap-minimum-efx-unique MX MX efx`eq/ efxmap`eq/ efx`eq/.

%worlds (objvar) (efxmap-minimum-efx-unique _ _ _ _ _).
%trustme %total {} (efxmap-minimum-efx-unique _ _ _ _ _).


%theorem efxmap2perm-equiv
  : forall* {CM1} {CM2} {PM1} {PM2} {B1} {B2}
    {M1} {M2} {Pi1} {Pi2}
    forall {M1=>Pi1: efxmap2perm CM1 PM1 B1 M1 Pi1}
    {M2=>Pi2: efxmap2perm CM2 PM2 B2 M2 Pi2}
    {E: clsmap`eq CM1 CM2}
    {E: predmap`eq PM1 PM2} {E: cxt`eq B1 B2} {E: efxmap`eq M1 M2}
    exists {EQV: equiv Pi1 Pi2}
    true.

%worlds (objvar) (efxmap2perm-equiv _ _ _ _ _ _ _).
%trustme %total {} (efxmap2perm-equiv _ _ _ _ _ _ _).


%theorem effects2input-equiv
  : forall* {CM} {CM'} {PM} {PM'} {B} {B'} {XX} {XX'} {Pi} {Pi'}
    forall {XX=>Pi: effects2input CM PM B XX Pi}
    {XX=>Pi: effects2input CM' PM' B' XX' Pi'}
    {CME: clsmap`eq CM CM'} {PME: predmap`eq PM PM'}
    {BE: cxt`eq B B'} {XXE: effects`eq XX XX'}
    exists {EQV: equiv Pi Pi'}
    true.

%worlds () (effects2input-equiv _ _ _ _ _ _ _).
%trustme %total { } (effects2input-equiv _ _ _ _ _ _ _).



%% fresh-update-implies-equiv-converse


%{
 theorems about leq - basically:

 if M1 is less or equal than M2, and
 M1 ==> Pi1, M2 ==> Pi2.
 then exists Pi3, such that Pi2 <==> Pi1 , Pi3
}%

%theorem can-split-permission
  : forall* {Q1} {Pi}
    forall {Q1<1: rat`lst Q1 one}
    exists {Q2} {ADD: rat`add Q1 Q2 one}
    {EQV: equiv Pi ((scale (fraction/ Q1) Pi) , (scale (fraction/ Q2) Pi))}
    true.

- : can-split-permission (Q1<1:rat`lst Q1 one) Q2 Q1+Q2=1
    (equiv/transitive
      (equiv/symmetric equiv/one)
      (equiv/symmetric (equiv/add Q1+Q2=1)))
    <- rat`grt-implies-add Q1<1 Q2 Q2+Q1=1
    <- rat`add-commutative Q2+Q1=1 Q1+Q2=1.

%worlds (objvar) (can-split-permission _ _ _ _).
%total {} (can-split-permission _ _ _ _).


%theorem apply-efx-respects-geq
  : forall* {X1} {X2} {Pi} {Pi2}
    forall {AP-X2: apply-efx X2 Pi Pi2}
    {X1<=X2: efx`leq X1 X2}
    exists {Pi1} {Pi3} {AP-X1: apply-efx X1 Pi Pi1}
    {Pi2=>Pi1+Pi3: equiv Pi2 (Pi1 , Pi3)}
    true.

- : apply-efx-respects-geq apply-efx/read
    (efx`geq/= efx`eq/) _ _ apply-efx/read (equiv/symmetric equiv/identity).

- : apply-efx-respects-geq apply-efx/write
    (efx`geq/= efx`eq/) _ _ apply-efx/write (equiv/symmetric equiv/identity).

- : apply-efx-respects-geq apply-efx/write
    (efx`geq/> (efx`grt/wr)) _ _ apply-efx/read
    (equiv/transitive
      (equiv/symmetric equiv/one)
      (equiv/symmetric (equiv/add 1/2+1/2=1))).

%worlds (objvar) (apply-efx-respects-geq _ _ _ _ _ _).
%total {} (apply-efx-respects-geq _ _ _ _ _ _).


%theorem apply-efx-respects-geq*
  : forall* {X1} {X2} {Pi} {Pi1} {Pi2}
    forall {AP-X1: apply-efx X2 Pi Pi2}
    {X1<=X2: efx`leq X1 X2}
    {AP-X2: apply-efx X1 Pi Pi1}
    exists {Pi3} {Pi2=>Pi1+Pi3: equiv Pi2 (Pi1 , Pi3)}
    true.

- : apply-efx-respects-geq*
    apply-efx/read _ apply-efx/read _ (equiv/symmetric equiv/identity).

- : apply-efx-respects-geq*
    apply-efx/write _ apply-efx/write _ (equiv/symmetric equiv/identity).

- : apply-efx-respects-geq*
    apply-efx/write _ apply-efx/read _
    (equiv/transitive
      (equiv/symmetric equiv/one)
      (equiv/symmetric (equiv/add 1/2+1/2=1))).

%worlds (objvar) (apply-efx-respects-geq* _ _ _ _ _).
%total {} (apply-efx-respects-geq* _ _ _ _ _).


%theorem efxmap2perm-respects-geq
  : forall* {M1} {M2} {CM} {PM} {B} {Pi2}
    forall {M2=>Pi2: efxmap2perm CM PM B M2 Pi2}
    {M1<=M2: efxmap`leq M1 M2}
    exists {Pi1} {Pi3} {M1=>Pi1: efxmap2perm CM PM B M1 Pi1}
    {EQV: (equiv Pi2 (Pi1 , Pi3))}
    true.

%theorem efxmap2perm-respects-geq/L
  : forall* {M1} {M2} {CM} {PM} {B} {Pi21} {Pi22}
    {M2'} {K} {N} {F} {X} {NN} {A} {C} {FM} {T} {PF} {PiF}
    forall {FS: efxmap`fresh M2' K}
    {UD: efxmap`update M2' K X M2}
    {K=>NF: nat2pair K (pair/ N F)}
    {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    {T2PF: ty2perm PM T PF}
    {CNN: consider-nn ([x] unitperm (precise-exists x F PF)) NN PiF}
    {AE: apply-efx X (PiF (object/ N)) Pi21}
    {M2'=>Pi22: efxmap2perm CM PM B M2' Pi22}
    {M1<=M2: efxmap`leq M1 M2}
    {BP} {DM?: efxmap`domain? M1 K BP}
    exists {Pi1} {Pi3} {M1=>Pi1: efxmap2perm CM PM B M1 Pi1}
    {EQV: (equiv (Pi21 , Pi22) (Pi1 , Pi3))}
    true.

- : efxmap2perm-respects-geq/L K!<M2' M2'+K+X=M2
    K2NF BL CML FML T2PF CNN AE M2'=>Pi22 M1<=M2 _ (efxmap`domain?/out K!<M1)
    _ _ M1=>Pi1
    (equiv/transitive
      (equiv/combine equiv/reflexive (Pi22<=>Pi1+Pi3))
      (equiv/reorder))
    <- efxmap`fresh-update2-preserves-leq-converse
      M1<=M2 K!<M1 K!<M2' M2'+K+X=M2 M1<=M2'
    <- efxmap2perm-respects-geq
      M2'=>Pi22 M1<=M2' _ _ M1=>Pi1 Pi22<=>Pi1+Pi3.

- : efxmap2perm-respects-geq/L K!<M2' M2'+K+X=M2
    K2NF BL CML FML T2PF CNN AE M2'=>Pi22 M1<=M2 _ (efxmap`domain?/in M1->K=X1)
    _ _ (efxmap2perm/U M1'=>Pi11 K2NF BL CML FML T2PF CNN AE1 K!<M1' M1'+K+X1=M1)
    (equiv/transitive4
      (equiv/combine (EQV1) (Pi22<=>Pi11+Pi3))
      (equiv/symmetric equiv/associate)
      (equiv/combine equiv/reflexive equiv/reorder)
      (equiv/associate))
    <- efxmap`lookup-implies-fresh-update M1->K=X1 M1' K!<M1' M1'+K+X1=M1
    <- efxmap`fresh-update-preserves-leq-converse M1<=M2
      K!<M1' M1'+K+X1=M1 K!<M2' M2'+K+X=M2 M1'<=M2' X1<=X
    <- efxmap2perm-respects-geq
      M2'=>Pi22 M1'<=M2' _ _ M1'=>Pi11 Pi22<=>Pi11+Pi3
    <- apply-efx-respects-geq AE X1<=X _ _ AE1 EQV1.

- : efxmap2perm-respects-geq
    efxmap2perm/0 efxmap`leq/0 _ _ efxmap2perm/0
    (equiv/symmetric equiv/identity).

- : efxmap2perm-respects-geq
    (efxmap2perm/U T' P BL CML FML T2PF CNN AE F U) M1<=M2 _ _ M1=>Pi1 EQV
    <- efxmap`domain?-total DM?
    <- efxmap2perm-respects-geq/L F U P BL CML FML T2PF CNN AE
      T' M1<=M2 _ DM? _ _ M1=>Pi1 EQV.

%worlds (objvar)
	(efxmap2perm-respects-geq _ _ _ _ _ _)
	(efxmap2perm-respects-geq/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A1 A2)
	(efxmap2perm-respects-geq A1 _ _ _ _ _)
	(efxmap2perm-respects-geq/L _ _ _ _ _ _ _ _ _ A2 _ _ _ _ _ _ _).


%theorem efxmap2perm-respects-geq*
  : forall* {M1} {M2} {CM} {PM} {B} {Pi1} {Pi2}
    forall {M2=>Pi2: efxmap2perm CM PM B M2 Pi2}
    {M1<=M2: efxmap`leq M1 M2}
    {M1=>Pi1: efxmap2perm CM PM B M1 Pi1}
    exists {Pi3} {EQV: (equiv Pi2 (Pi1 , Pi3))}
    true.

- : efxmap2perm-respects-geq* M2=>Pi2 M1<=M2 M1=>Pi1 _
    (equiv/transitive EQV1 (equiv/combine EQV2 equiv/reflexive))
    <- efxmap2perm-respects-geq M2=>Pi2 M1<=M2 _ _ M1=>Pi1' EQV1
    <- efxmap2perm-equiv M1=>Pi1' M1=>Pi1 clsmap`eq/
      predmap`eq/ cxt`eq/ efxmap`eq/ EQV2.

%worlds (objvar) (efxmap2perm-respects-geq* _ _ _ _ _).
%total {} (efxmap2perm-respects-geq* _ _ _ _ _).


%theorem shared-efx2perm-respects-geq
  : forall* {SX1} {SX2} {Pi2}
    forall {SX2=>Pi2: shared-efx2perm SX2 Pi2}
    {SX1<=SX2: shared-efx`leq SX1 SX2}
    exists {Pi1} {Pi3} {SX1=>Pi1: shared-efx2perm SX1 Pi1}
    {EQV: equiv Pi2 (Pi1 , Pi3)}
    true.

- : shared-efx2perm-respects-geq
    _  shared-efx`leq/< _ _ shared-efx2perm/none
    (equiv/transitive
      (equiv/symmetric equiv/identity)
      (equiv/commute)).

- : shared-efx2perm-respects-geq
    (shared-efx2perm/read AE) (shared-efx`leq/= (efx`geq/= efx`eq/))
    _ _ (shared-efx2perm/read AE) (equiv/symmetric equiv/identity).

- : shared-efx2perm-respects-geq
    (shared-efx2perm/write AE) (shared-efx`leq/= (efx`geq/= efx`eq/))
    _ _ (shared-efx2perm/write AE) (equiv/symmetric equiv/identity).

- : shared-efx2perm-respects-geq
    (shared-efx2perm/write AE) (shared-efx`leq/= (efx`geq/> X1<X2))
    _ _ (shared-efx2perm/read AE1) EQV
    <- apply-efx-respects-geq AE (efx`geq/> X1<X2) _ _ AE1 EQV.

%worlds (objvar) (shared-efx2perm-respects-geq _ _ _ _ _ _).
%total {} (shared-efx2perm-respects-geq _ _ _ _ _ _).


%theorem shared-efx2perm-respects-geq*
  : forall* {SX1} {SX2} {Pi1} {Pi2}
    forall {SX2=>Pi2: shared-efx2perm SX2 Pi2}
    {SX1<=SX2: shared-efx`leq SX1 SX2}
    {SX1=>Pi1: shared-efx2perm SX1 Pi1}
    exists {Pi3} {EQV: equiv Pi2 (Pi1 , Pi3)}
    true.

- : shared-efx2perm-respects-geq* T2 L T1 _
    (equiv/transitive EQV (equiv/combine PEQV equiv/reflexive))
    <- shared-efx2perm-respects-geq T2 L _ _ T1' EQV
    <- shared-efx2perm-unique T1' T1 shared-efx`eq/ PE
    <- permission`eq-implies-equiv PE PEQV.

%worlds (objvar) (shared-efx2perm-respects-geq* _ _ _ _ _).
%total {} (shared-efx2perm-respects-geq* _ _ _ _ _).


%{
 disjoint-join-implies-equiv:

 If we have two effect maps M1 and M2,
   and if the following condition holds

 1. M1^M2
 2. M1+M2 = M
 3. M1 ==> Pi1
 4. M2 ==> Pi2
 5. M  ==> Pi

 then we can derive:

 Pi1 , Pi2 <==> Pi
}%

%theorem make-fperm-disjoint-join-implies-equiv
  : forall* {CM} {PM} {B} {S1} {S2} {S} {Pi}
    forall {D: set`disjoint S1 S2}
    {U: set`union S1 S2 S}
    {S=>Pi: make-fperm CM PM B S Pi}
    exists {Pi1} {Pi2}
    {S1=>Pi1: make-fperm CM PM B S1 Pi1}
    {S2=>Pi2: make-fperm CM PM B S2 Pi2}
    {EQV: equiv (Pi1 , Pi2) Pi}
    true.

%worlds (objvar) (make-fperm-disjoint-join-implies-equiv _ _ _ _ _ _ _ _).
%trustme %total {} (make-fperm-disjoint-join-implies-equiv _ _ _ _ _ _ _ _).


%theorem make-fperm-disjoint-join-implies-equiv*
  : forall* {CM} {PM} {B} {S1} {S2} {S} {Pi1} {Pi2} {Pi}
    forall {D: set`disjoint S1 S2}
    {U: set`union S1 S2 S}
    {S1=>Pi1: make-fperm CM PM B S1 Pi1}
    {S2=>Pi2: make-fperm CM PM B S2 Pi2}
    {S=>Pi: make-fperm CM PM B S Pi}
    exists {EQV: equiv (Pi1 , Pi2) Pi}
    true.

%worlds (objvar) (make-fperm-disjoint-join-implies-equiv* _ _ _ _ _ _).
%trustme %total {} (make-fperm-disjoint-join-implies-equiv* _ _ _ _ _ _).


%theorem efxmap`disjoint-join-implies-equiv
  : forall* {M1} {M2} {M} {O} {FM} {PM} {Pi}
    forall {DJ: efxmap`disjoint M1 M2}
    {J: efxmap`join M1 M2 M}
    {M=>Pi: efxmap2perm O FM PM M Pi}
    exists {Pi1} {Pi2}
    {M1=>Pi1: efxmap2perm O FM PM M1 Pi1}
    {M2=>Pi2: efxmap2perm O FM PM M2 Pi2}
    {EQV: equiv Pi (Pi1 , Pi2)}
    true.

%theorem efxmap`disjoint-join-implies-equiv/L
  : forall* {M1} {M2} {M} {MP} {F} {X} {T} {PF} {B}
    {O} {FM} {PM} {Pix} {Piy} {K} {N} {NN} {A} {CM} {C}
    forall {DJ: efxmap`disjoint M1 M2}
    {J: efxmap`join M1 M2 M}
    {FS: efxmap`fresh MP K}
    {U: efxmap`update MP K X M}
    {K=>N+F: nat2pair K (pair/ N F)}
    {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F T}
    {T=>PF: ty2perm PM T PF}
    {AP: apply-efx X (unitperm (precise-exists O F PF)) Pix}
    {M=>Pi: efxmap2perm CM PM B MP Piy}
    {B1} {IN1?: efxmap`domain? M1 K B1}
    {B2} {IN2?: efxmap`domain? M2 K B2}
    exists {Pi1} {Pi2}
    {M1=>Pi1: efxmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: efxmap2perm CM PM B M2 Pi2}
    {EQV: (equiv (Pix , Piy) (Pi1 , Pi2))}
    true.

%worlds (objvar)
(efxmap`disjoint-join-implies-equiv _ _ _ _ _ _ _ _)
(efxmap`disjoint-join-implies-equiv/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (T1 T2) (efxmap`disjoint-join-implies-equiv _ _ T1 _ _ _ _ _)
(efxmap`disjoint-join-implies-equiv/L _ _ _ _ _ _ _ _ _ _ T2 _ _ _ _ _ _ _ _ _).


%theorem efxmap`disjoint-join-implies-equiv-converse
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2}
    forall {DJ: efxmap`disjoint M1 M2}
    {J: efxmap`join M1 M2 M}
    {M1=>Pi1: efxmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: efxmap2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: efxmap2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

%theorem efxmap`disjoint-join-implies-equiv-converse/L
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2}
    forall {N1} {SZ1: efxmap`size M1 N1}
    {N2} {SZ2: efxmap`size M2 N2}
    {DJ: efxmap`disjoint M1 M2}
    {J: efxmap`join M1 M2 M}
    {M1=>Pi1: efxmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: efxmap2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: efxmap2perm CM PM B M Pi}
    {EQV: (equiv ((Pi1) , (Pi2)) (Pi))}
    true.

- : efxmap`disjoint-join-implies-equiv-converse
    M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 Pi M=>Pi EQV
    <- efxmap`size-total SZ1
    <- efxmap`size-total SZ2
    <- efxmap`disjoint-join-implies-equiv-converse/L
      _ SZ1 _ SZ2 M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 Pi M=>Pi EQV.

%worlds (objvar)
(efxmap`disjoint-join-implies-equiv-converse/L _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {N1 N2}
(efxmap`disjoint-join-implies-equiv-converse/L N1 _ N2 _ _ _ _ _ _ _ _).

%worlds (objvar) (efxmap`disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).
%total {} (efxmap`disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).


%theorem efxmap`disjoint-join-implies-equiv*
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {DJ: efxmap`disjoint M1 M2}
    {J: efxmap`join M1 M2 M}
    {M1=>Pi1: efxmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: efxmap2perm CM PM B M2 Pi2}
    {M=>Pi: efxmap2perm CM PM B M Pi}
    exists {EQV: (equiv ((Pi1) , (Pi2)) (Pi))}
    true.

- : efxmap`disjoint-join-implies-equiv* M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 M=>Pi
    (equiv/transitive (EQV1) (EQV2))
    <- efxmap`disjoint-join-implies-equiv-converse
    M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 _ M=>Pi' EQV1
    <- efxmap2perm-equiv M=>Pi' M=>Pi
      clsmap`eq/ predmap`eq/ cxt`eq/ efxmap`eq/ EQV2.

%worlds (objvar) (efxmap`disjoint-join-implies-equiv* _ _ _ _ _ _).
%total {} (efxmap`disjoint-join-implies-equiv* _ _ _ _ _ _).


%theorem efxmap`partition-implies-permission-combine
  : forall* {M1} {M2} {M} {S22} {CM} {PM} {B} {Pi}
    forall {R: efxmap`partition M S22 M1 M2}
    {M=>Pi: efxmap2perm CM PM B M Pi}
    exists {Pi1} {Pi2} {M1=>Pi1: efxmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: efxmap2perm CM PM B M2 Pi2}
    {EQV: (equiv (Pi) ((Pi1) , (Pi2)))}
    true.

- : efxmap`partition-implies-permission-combine
    M/S22=M1+M2 M=>Pi _ _ M1=>Pi1 M2=>Pi2 (Pi1+Pi2<=>Pi)
    <- efxmap`partition-implies-disjoint-join M/S22=M1+M2 M1^M2 M1+M2=M
    <- efxmap`disjoint-join-implies-equiv
      M1^M2 M1+M2=M M=>Pi _ _ M1=>Pi1 M2=>Pi2 Pi1+Pi2<=>Pi.

%worlds (objvar) (efxmap`partition-implies-permission-combine _ _ _ _ _ _ _).
%total {} (efxmap`partition-implies-permission-combine _ _ _ _ _ _ _).


%theorem efxmap`partition-implies-permission-combine-converse
  :forall* {M1} {M2} {M} {S22} {CM} {PM} {B} {Pi1} {Pi2}
    forall {R: efxmap`partition M S22 M1 M2}
    {M1=>Pi1: efxmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: efxmap2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: efxmap2perm CM PM B M Pi}
    {EQV: equiv (Pi1 , Pi2) Pi}
    true.

- : efxmap`partition-implies-permission-combine-converse SG T1 T2 _ T EQV
    <- efxmap`partition-implies-disjoint-join SG X J
    <- efxmap`disjoint-join-implies-equiv-converse X J T1 T2 _ T EQV.

%worlds (objvar) (efxmap`partition-implies-permission-combine-converse _ _ _ _ _ _).
%total {} (efxmap`partition-implies-permission-combine-converse _ _ _ _ _ _).


%theorem efxmap`partition-implies-permission-combine*
  : forall* {M1} {M2} {M} {S22} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {R: efxmap`partition M S22 M1 M2}
    {M=>Pi: efxmap2perm CM PM B M Pi}
    {M1=>Pi1: efxmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: efxmap2perm CM PM B M2 Pi2}
    exists {EQV: (equiv Pi (Pi1 , Pi2))}
    true.

- : efxmap`partition-implies-permission-combine* M/S22=M1+M2 M=>Pi M1=>Pi1 M2=>Pi2
    (equiv/symmetric (Pi1+Pi2<=>Pi))
    <- efxmap`partition-implies-disjoint-join M/S22=M1+M2 M1^M2 M1+M2=M
    <- efxmap`disjoint-join-implies-equiv*
      M1^M2 M1+M2=M M1=>Pi1 M2=>Pi2 M=>Pi Pi1+Pi2<=>Pi.

%worlds (objvar) (efxmap`partition-implies-permission-combine* _ _ _ _ _).
%total {} (efxmap`partition-implies-permission-combine* _ _ _ _ _).


%theorem efxmap`leq-partition
  : forall* {M1} {M} {S}
    forall {LEQ: efxmap`leq M1 M}
    {DM: efxmap`domain M1 S}
    exists {M2} {M3} {DJ: efxmap`disjoint M2 M3}
    {J: efxmap`join M2 M3 M}
    {DM: efxmap`domain M2 S}
    true.

%worlds (objvar) (efxmap`leq-partition _ _ _ _ _ _ _).
%trustme %total { } (efxmap`leq-partition _ _ _ _ _ _ _).


%theorem can-duplicate-borrow
  : forall* {PM} {NN} {C} {PF}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    exists {IMP: {o} implies (PF o) ((PF o) , (PF o))}
    true.

- : can-duplicate-borrow
    (ty2perm/ _ nn2perm/yes annot2perm/borrow)
    ([_] implies/trans5
      (implies/combine
        (implies/duplicate)
        (implies/combine
          (implies/reflexive)
          (implies/duplicate)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/equiv equiv/roll3))
      (implies/equiv equiv/associate)
      (implies/combine
        (implies/combine
          (implies/reflexive)
          (implies/equiv
            (equiv/transitive
              (equiv/symmetric equiv/identity)
              (equiv/commute))))
        (implies/reflexive))).

- : can-duplicate-borrow
    (ty2perm/ _ nn2perm/may annot2perm/borrow)
    ([_] implies/trans3
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/trans3
          (implies/combine
            (implies/reflexive)
            (implies/duplicate))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/reflexive)
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/identity)
                (equiv/commute))))))
      (implies/cond-distribute)
      (implies/equiv equiv/commute)).

%worlds (objvar) (can-duplicate-borrow _ _).
%total {} (can-duplicate-borrow _ _).


%theorem can-duplicate-shared
  : forall* {PM} {NN} {C} {PF}
    forall {T2PF: ty2perm PM (ty/ NN annot/shared C) PF}
    exists {IMP: {o} implies (PF o) ((PF o) , (PF o))}
    true.

- : can-duplicate-shared
    (ty2perm/ _ nn2perm/may annot2perm/shared)
    ([_] implies/trans3
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/trans
          (implies/combine2conj)
          (implies/duplicate)))
      (implies/cond-distribute)
      (implies/combine
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/conj2combine))
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/conj2combine)))).

- : can-duplicate-shared
    (ty2perm/ _ nn2perm/yes annot2perm/shared)
    ([_] implies/trans4
      (implies/combine
        (implies/reflexive)
        (implies/combine2conj))
      (implies/combine2conj)
      (implies/duplicate)
      (implies/combine
        (implies/trans
          (implies/conj2combine)
          (implies/combine
            (implies/reflexive)
            (implies/conj2combine)))
        (implies/trans
          (implies/conj2combine)
          (implies/combine
            (implies/reflexive)
            (implies/conj2combine))))).

%worlds (objvar) (can-duplicate-shared _ _).
%total {} (can-duplicate-shared _ _).


%theorem clsmap-cxt-lookup-implies-ty2perm
  : forall* {CM} {PM} {T} {B} {Pi} {O}
    forall {CM-B: clsmap-cxt CM B}
    {BL: cxt`lookup B O T}
    {B2P: cxt2perm CM PM B Pi}
    exists {PF} {T2PF: ty2perm PM T PF}
    {EQV: implies Pi ((PF O) , Pi)}
    true.

- : clsmap-cxt-lookup-implies-ty2perm
    (clsmap-cxt/cons/b _ _)
    (cxt`lookup/hit:cxt`lookup _ O _) (cxt2perm/cons _ T2PF) _ T2PF
    (implies/trans
      (implies/combine
        (IMP O) (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate)))
    <- can-duplicate-borrow T2PF IMP.

- : clsmap-cxt-lookup-implies-ty2perm
    (clsmap-cxt/cons/s _ _)
    (cxt`lookup/hit:cxt`lookup _ O _) (cxt2perm/cons _ T2PF) _ T2PF
    (implies/trans
      (implies/combine
        (IMP O) (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate)))
    <- can-duplicate-shared T2PF IMP.

- : clsmap-cxt-lookup-implies-ty2perm
    (clsmap-cxt/cons/b CM-B _)
    (cxt`lookup/miss BL _) (cxt2perm/cons B2P _) _ T2PF
    (implies/trans
      (implies/combine (implies/reflexive) (IMP))
      (implies/equiv (equiv/roll2)))
    <- clsmap-cxt-lookup-implies-ty2perm CM-B BL B2P _ T2PF IMP.

- : clsmap-cxt-lookup-implies-ty2perm
    (clsmap-cxt/cons/s CM-B _)
    (cxt`lookup/miss BL _) (cxt2perm/cons B2P _) _ T2PF
    (implies/trans
      (implies/combine (implies/reflexive) (IMP))
      (implies/equiv (equiv/roll2)))
    <- clsmap-cxt-lookup-implies-ty2perm CM-B BL B2P _ T2PF IMP.

%worlds (objvar) (clsmap-cxt-lookup-implies-ty2perm _ _ _ _ _ _).
%total (B) (clsmap-cxt-lookup-implies-ty2perm _ B _ _ _ _).


%theorem efxmap-minimum-efx-respects-leq
  : forall* {M1} {M2} {X1} {X2}
    forall {M1<=M2: efxmap`leq M1 M2}
    {MX-M1: efxmap-minimum-efx M1 X1}
    {MX-M2: efxmap-minimum-efx M2 X2}
    exists {X2<=X1: efx`leq X2 X1}
    true.

%worlds (objvar) (efxmap-minimum-efx-respects-leq _ _ _ _).
%trustme %total {} (efxmap-minimum-efx-respects-leq _ _ _ _).


% domain has to be equal, otherwise M' may contain efxs which are
% not in M but smaller than X.

%theorem efxmap-minimum-efx-respects-leq-domain
  : forall* {M} {M'} {X} {S}
    forall {MX: efxmap-minimum-efx M X}
    {M<=M': efxmap`leq M M'}
    {DM-M: efxmap`domain M S} {DM-M': efxmap`domain M' S}
    exists {X'} {MX': efxmap-minimum-efx M' X'}
    {X<=X': efx`leq X X'}
    true.

%worlds () (efxmap-minimum-efx-respects-leq-domain _ _ _ _ _ _ _).
%trustme %total { } (efxmap-minimum-efx-respects-leq-domain _ _ _ _ _ _ _).




%theorem efxmap`join-joins-minimum-efx
  : forall* {M1} {M2} {M} {X1} {X2}
    forall {J: efxmap`join M1 M2 M}
    {MX-M1: efxmap-minimum-efx M1 X1}
    {MX-M2: efxmap-minimum-efx M2 X2}
    exists {X} {MX: efx`min X1 X2 X}
    {MX-M: efxmap-minimum-efx M X}
    true.

%worlds (objvar) (efxmap`join-joins-minimum-efx _ _ _ _ _ _).
%trustme %total {} (efxmap`join-joins-minimum-efx _ _ _ _ _ _).


%theorem effects`join-implies-permission-combine-converse
  : forall* {CM} {PM} {B} {Pi} {XX1} {XX2} {XX}
    forall {J: effects`join XX1 XX2 XX}
    {XX=>Pi: effects2input CM PM B XX Pi}
    exists {Pi1} {Pi2}
    {XX1=>Pi1: effects2input CM PM B XX1 Pi1}
    {XX2=>Pi2: effects2input CM PM B XX2 Pi2}
    {EQV: equiv Pi (Pi1 , Pi2)}
    true.

%worlds (objvar) (effects`join-implies-permission-combine-converse _ _ _ _ _ _ _).
%trustme %total {} (effects`join-implies-permission-combine-converse _ _ _ _ _ _ _).



%{ This theorem says if we have a class predicate and we
know that this class has a field F, then we can pull out
the nesting fact about F from the predicate. }%

%theorem fldperm-can-lookup
  : forall* {CM} {PM} {C} {FM} {F} {NN} {A} {FC} {CP}
    forall {CM2PM: clsmap2predmap CM PM}
    {PM-L: predmap`lookup PM C CP}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    exists {AF} {PF} {FCP}
    {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM FC FCP}
    {IMP: {o} implies
          (unitperm
            (nonlinear
              (predcall CP (predargs/1 o))))
          (unitperm
            (nonlinear
              (nested ((fldperm F PF) FCP o) o all)))}
    true.

%theorem fldperm-can-lookup/false-imply
  : forall* {PM} {NN} {C} {F:nat} {G} {A}
    forall {V:void}
    exists {AF} {PF:clspred -> object -> permission}
    {CP} {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    {IMP: {o} implies (unitperm (nonlinear (G o)))
        (unitperm
          (nonlinear
            (nested ((fldperm F PF) CP o) o all)))}
    true.

%theorem fldperm-can-lookup/L
  : forall* {CM} {PM} {FM} {F} {NN} {A} {G} {C}
    forall {FM=>G: fldmap2conj CM PM FM ([r] G r) PM}
    {FM-L: fldmap`lookup FM F (ty/ NN A C)}
    exists {AF} {PF} {CP}
    {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    {IMP: {o} implies (unitperm (nonlinear (G o)))
        (unitperm
            (nonlinear
              (nested ((fldperm F PF) CP o) o all)))}
    true.

- : fldperm-can-lookup/L (fldmap2conj/null FMP2G F<=FM=FMP)
    (fldmap`lookup/> FM->F P) AF PF CP A2AF FNN2PF PM->C IMP
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- fldmap`shift-preserves-lookup* FM->F F<=FM=FMP P2 FMP->F
    <- fldperm-can-lookup/L FMP2G FMP->F AF PF CP A2AF FNN2PF PM->C IMP.

- : fldperm-can-lookup/L (fldmap2conj/in _ FNN2P A2AF _ PM-L)
     (fldmap`lookup/= nat`eq/) _ _ _ A2AF FNN2P PM-L
    ([o] implies/trans3
      (implies/conj2combine)
      (implies/combine
        (implies/reflexive)
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
      (implies/equiv equiv/identity)).

- : fldperm-can-lookup/L (fldmap2conj/in FM2G _ _ FM-SH _)
    (fldmap`lookup/> FM-L P) AF PF CP A2AF FNN2P PM-L
    ([o] implies/trans4
      (implies/conj2combine)
      (implies/combine
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
        (I o))
      (implies/equiv equiv/commute)
      (implies/equiv equiv/identity))
    <- nat`plus-swap-succ P P'
    <- nat`plus-commutative P' P''
    <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
    <- fldperm-can-lookup/L FM2G FM-L' AF PF CP A2AF FNN2P PM-L I.

- : fldperm-can-lookup/L
    (fldmap2conj/out F2C
      (F2CF:{f} fldmap2conj _ _ _ ([r] CJ f r) _)
      ([f] PM-U f) _ _ _ _ PM-FS) _ AF PF PD A2AF FNN2P PM-L I
    <- predmap`size-total SZ-PM
    <- predmap`fresh-update-increases-size
      SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
    <- fldmap2conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
    <- predmap`size-total SZ-PMF
    <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
    <- fldmap2conj-implies-predmap-leq F2C PMF<=PM
    <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
    <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
    <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
    <- nat`gt-anti-reflexive SZ-PM>PM F
    <- fldperm-can-lookup/false-imply F AF PF PD A2AF FNN2P PM-L I.

- : fldperm-can-lookup
    CM2PM PM-L CM-L FM-L AF PF CP A2AF FNN2PF PM->FC
    ([o] implies/trans3
      (implies/equiv (EQV o))
      (implies/nonlinear
        (bimplies/trans
          (bimplies/predcall/Y/inline)
          (bimplies/trans
            (bimplies/predcall/+/inline o)
            (bimplies/predcall/0/inline))))
      (IMP o))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- clsmap-predmap-implies-lookup-format CM-PM PM-L _ PM-LP ([o] (PEQ o))
    <- ({o} permission`eq-implies-equiv (PEQ o) (EQV o))
    <- clsmap2predmap-implies-fldmap2conj CM2PM PM-LP CM-L FM2G
    <- fldperm-can-lookup/L FM2G FM-L AF PF CP A2AF FNN2PF PM->FC IMP.

%worlds (objvar) (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).
%total {} (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).

%worlds (objvar) (fldperm-can-lookup/L _ _ _ _ _ _ _ _ _).
%total (FM2G) (fldperm-can-lookup/L FM2G _ _ _ _ _ _ _ _).

%worlds (objvar) (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).
%total {} (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).



%theorem sharedperm-can-be-duplicated
  : forall* {NN} {C} {AF} {PF} {PM} {CP}
    forall {A2AF: annot2perm annot/shared AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    exists {IMP: {r} implies (PF CP r) ((PF CP r) , (PF CP r))}
    true.

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/yes _
    ([r]
      (implies/trans4
        (implies/combine
          (implies/reflexive)
          (implies/combine2conj))
        (implies/combine2conj)
        (implies/duplicate)
        (implies/combine
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))))).

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/may _
    ([r]
      (implies/trans3
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/trans
            (implies/combine2conj)
            (implies/duplicate)))
        (implies/cond-distribute)
        (implies/combine
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/conj2combine))
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/conj2combine))))).

%worlds (objvar) (sharedperm-can-be-duplicated _ _ _ _).
%total {} (sharedperm-can-be-duplicated _ _ _ _).


%theorem sharedperm-can-be-duplicated*
  : forall* {NN} {C} {PF} {PM}
    forall {T2PF: ty2perm PM (ty/ NN annot/shared C) PF}
    exists {IMP: {r} implies (PF r) ((PF r) , (PF r))}
    true.

- : sharedperm-can-be-duplicated*
    (ty2perm/ PM-L NN2PF A2AF) IMP
    <- sharedperm-can-be-duplicated A2AF NN2PF PM-L IMP.

%worlds (objvar) (sharedperm-can-be-duplicated* _ _).
%total {} (sharedperm-can-be-duplicated* _ _).


%{
 This lemma says if we have a partial permission for shared, as well as
 fact that the whole permission for object r is nested in shared, then
 we can carve that permission out, along with the encumbered permission.
 TODO: this lemma could be simpler by eliminating Pi1 and Pi3.
}%

%theorem can-carve-out-of-shared
  : forall* {Pi1} {Pi2} {Pi3} {Q}
    forall {EQV: equiv Pi2 (scale Q (allperm null) , Pi3)}
    exists {IMP: {r} implies
                 ((unitperm
                      (nonlinear
                        (nested (allperm r) null all))) , (Pi1 , Pi2))
                 ((scale Q (allperm r)) ,
                   ((unitperm
                     (encumbered
                       (scale Q (allperm r)) (Pi2))) , (Pi1)))}
    true.

- : can-carve-out-of-shared
    EQV ([r] implies/trans3
          (implies/equiv
            (equiv/transitive
              (equiv/combine
                (equiv/reflexive) equiv/commute)
              (equiv/associate)))
          (implies/combine
            (implies/trans6
              (implies/combine
                implies/reflexive (implies/equiv (EQV)))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans5
                  (implies/combine
                    (implies/scale-into-formula)
                    (implies/reflexive))
                  (implies/equiv (equiv/symmetric equiv/distribute))
                  (implies/scale implies/carve)
                  (implies/equiv equiv/distribute)
                  (implies/combine
                    implies/reflexive
                    (implies/scale-distribute-encumbered)))
                (implies/reflexive))
              (implies/combine
                (implies/reflexive)
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/transitive
                          (EQV)
                          (equiv/commute))
                        (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive implies/chain-implication))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))).

%worlds (objvar) (can-carve-out-of-shared _ _).
%total {} (can-carve-out-of-shared _ _).


%{
 The following two lemmas say if we have a permission converted from
 either unique or borrowed type, then we can "scale from" the permission,
 and remove the fraction (since the permission is actually formule).
}%

%theorem can-scale-from-shared
  : forall* {PM} {PF} {C} {NN} {Q}
    forall {T2PF: ty2perm PM (ty/ NN annot/shared C) PF}
    exists {IMP: {v} implies (scale Q (PF v)) (PF v)}
    true.

- : can-scale-from-shared
    (ty2perm/ _ nn2perm/yes annot2perm/shared)
    ([_] implies/trans
      (implies/equiv
        (equiv/transitive
          (equiv/distribute)
          (equiv/combine
            (equiv/reflexive)
            (equiv/distribute))))
      (implies/combine
        (implies/scale-from-formula)
        (implies/combine
          (implies/scale-from-formula)
          (implies/scale-from-formula)))).

- : can-scale-from-shared
    (ty2perm/ _ nn2perm/may annot2perm/shared)
    ([_] implies/trans
      (implies/scale-distribute-cond)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/zero)
        (implies/trans
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/scale-from-formula)
            (implies/scale-from-formula))))).

%worlds (objvar) (can-scale-from-shared _ _).
%total {} (can-scale-from-shared _ _).


%theorem can-scale-from-borrow
  : forall* {PM} {PF} {C} {NN} {Q}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    exists {IMP: {v} implies (scale Q (PF v)) (PF v)}
    true.

- : can-scale-from-borrow
    (ty2perm/ _ nn2perm/yes annot2perm/borrow)
    ([v] implies/trans
      (implies/equiv
        (equiv/transitive
          (equiv/distribute)
          (equiv/combine
            (equiv/reflexive)
            (equiv/distribute))))
      (implies/combine
        (implies/scale-from-formula)
        (implies/combine
          (implies/equiv
            (equiv/zero))
          (implies/scale-from-formula)))).

- : can-scale-from-borrow
    (ty2perm/ _ nn2perm/may annot2perm/borrow)
    ([_] implies/trans
      (implies/scale-distribute-cond)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/zero)
        (implies/trans
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/equiv equiv/zero)
            (implies/scale-from-formula))))).

%worlds (objvar) (can-scale-from-borrow _ _).
%total {} (can-scale-from-borrow _ _).