%%% converting *map to permission
%%% $Id: conversion.elf,v 1.4 2013/06/01 16:55:39 csun Exp csun $


%%% Definitions


% make disjunction of objequal facts for object targets.

%abbrev fracperm = fraction -> permission.

set2facts : cxt -> object -> set -> formula -> type.

set2facts/0 : set2facts _ _ set/0 f.

set2facts/U
  : set`not-member SP N
    -> set`add SP N S
    -> cxt-lookup-loc B N O' _
    -> set2facts B O SP G
    -> set2facts B O S (disj (objequal O O') G).


% apply efx on given permission, and get a altered permission

apply-efx : bool -> efx -> permission -> fracperm -> type.

apply-efx/read : apply-efx _ efx/read Pi ([z] (scale z Pi)).

apply-efx/write : apply-efx _ efx/write Pi ([_] Pi).

apply-efx/consume/true : apply-efx true efx/consume Pi ([_] Pi).

apply-efx/consume/false : apply-efx false efx/consume Pi ([_] empty).


%{ The bool is used to control whether converted
permission is input or output.
Entry 0->0 should be converted to shared permission.
clsmap should contain a special key 0, which maps
to a special fldmap. }%

efxmap2perm : bool -> clsmap -> predmap -> cxt ->
  efxmap -> fracperm -> type.

inner-efxmap2perm : bool -> object -> fldmap -> predmap -> 
  inner-efxmap -> fracperm -> type.

inner-efxmap2perm/0 : inner-efxmap2perm _ _ _ _ inner-efxmap/0 ([_] empty).

inner-efxmap2perm/U
  : inner-efxmap`fresh MP F
    -> inner-efxmap`update MP F X M
    -> fldmap`lookup FM F T
    -> ty2perm PM T PF
    -> apply-efx P X (unitperm (precise-exists O F PF)) Pi1
    -> inner-efxmap2perm P O FM PM MP Pi2
    -> inner-efxmap2perm P O FM PM M ([z] (Pi1 z), Pi2 z).


%{ here we need to handle specially for the shared object }%

efxmap2perm/0 : efxmap2perm _ _ _ _ efxmap/0 ([_] empty).

efxmap2perm/S
  : efxmap`fresh XMP z
    -> efxmap`update XMP z (inner-efxmap/+ z _ inner-efxmap/0) XM 
    -> efxmap2perm P CM PM B XMP Pi
    -> efxmap2perm P CM PM B XM
      ([z] (unitperm (basic null all null) , (Pi z))).

efxmap2perm/U
  : efxmap`fresh XMP (s N)
    -> efxmap`update XMP (s N) M XM
    -> cxt-lookup-loc B (s N) O (ty/ _ _ C)
    -> clsmap`lookup CM C FM
    -> inner-efxmap2perm P O FM PM M Pi1
    -> efxmap2perm P CM PM B XMP Pi2
    -> efxmap2perm P CM PM B XM ([z] (Pi1 z) , Pi2 z).


%{ if tgtmap is empty, we shouldn't generate field
  permissions, since otherwise we may have permission like:

   (allperm o) , (unitperm (encumbered (allperm o) empty))

  which is obviously unsound. }%

tgtmap2perm : tgtmap -> (object -> permission) -> 
    (object -> formula) -> fracperm -> 
    fracperm -> (fraction -> expr-output) -> type.
  
%{ Pi1 is all the permissions that are NOT encumbered }%
tgtmap2perm/0
  : tgtmap2perm tgtmap/0 PF GF Pi1 Pi2
    ([z] output/exists [o]
      (output/expr o
        (unitperm (nonlinear (GF o)) , ((Pi1 z) , (Pi2 z))))).

tgtmap2perm/+
  : tgtmap2perm (tgtmap/+ _ _ _) PF GF Pi1 Pi2
    ([z] output/exists [o]
      (output/exists [r]
        (output/expr o
          (unitperm (nonlinear (disj (objequal o r) (GF o))) ,
            ((PF r) , (unitperm (encumbered (PF r) (Pi2 z)))) , (Pi1 z))))).


%abbrev nested-perm : object -> permission =
    [r] (unitperm (nonlinear (nested (allperm r) null all))).


reftype+efxmap2output : clsmap -> predmap -> cxt -> 
    reftype -> efxmap -> (fraction -> expr-output) -> type.

reftype+efxmap2output/
  : reftype+efxmap2output CM PM B (reftype/ T S GM) XM OUT
    <- ty2perm PM T PF
    <- efxmap`remove-tgtmap XM GM XM1 XM2
    <- efxmap2perm false CM PM B XM1 ([z] Pi1 z)
    <- efxmap2perm false CM PM B XM2 ([z] Pi2 z)
    <- ({r} set2facts B r S (GF r))
    <- tgtmap2perm GM PF GF Pi1 Pi2 ([z] OUT z).


cxt2facts : predmap -> cxt -> permission -> type.

% TODO

set2nesting-facts : cxt -> set -> permission -> type.

set2nesting-facts/0 : set2nesting-facts _ set/0 empty.

set2nesting-facts/+
  : set2nesting-facts B S
    (unitperm (nonlinear (nested (allperm O) null all)) , Pi) 
    <- set`not-member S' N
    <- set`add S' N S
    <- cxt-lookup-loc B N O T
    <- set2nesting-facts B S' Pi.


effects2input : clsmap -> predmap -> cxt -> effects -> fracperm -> type.

effects2input/
  : effects2input CM PM B (effects/ S XM) ([z] (FA , (FP z)))
    <- set2nesting-facts B S FA
    <- efxmap2perm true CM PM B XM ([z] FP z).


effects2output : clsmap -> predmap -> cxt -> reftype 
  -> effects -> (fraction -> expr-output) -> type.

effects2output/
  : effects2output CM PM B RT (effects/ S XM) Out'
    <- reftype+efxmap2output CM PM B RT XM Out
    <- set2nesting-facts B S FA
    <- ({z} envadd FA (Out z) (Out' z)). 



% TODO

methty2proctype* : clsmap -> predmap -> permission
  -> permission -> methty -> proctype -> type.

% TODO

%abbrev methty2proctype
  = [CM][PM][MT][PT] methty2proctype* CM PM empty empty MT PT.

consty2proctype*
  : clsmap -> predmap -> fldmap -> permission -> 
  permission -> methty -> (object -> proctype) -> type.

% TODO

%abbrev consty2proctype
   = [CM][PM][FM][CT][PTF] consty2proctype* CM PM FM empty empty CT PTF.


methmap2progtype : clsmap -> predmap -> methmap -> progtype -> type.

env2progtype : clsmap -> methmap -> progtype -> type.

env2progtype/
  : env2progtype CM MM W
    <- clsmap2predmap CM PM
    <- methmap2progtype CM PM MM W.



%%% Theorems


% First, extra permission-related theorems

%theorem permission`eq-implies-equiv :
    forall* {Pi1} {Pi2}
    forall  {EQ: permission`eq Pi1 Pi2}
    exists  {EQV: equiv Pi1 Pi2}
    true.

- : permission`eq-implies-equiv permission`eq/ equiv/reflexive.

%worlds () (permission`eq-implies-equiv _ _).
%total  {} (permission`eq-implies-equiv _ _).


%theorem permission`combine-preserves-eq :
    forall* {Pi1} {Pi2} {Pi3} {Pi4}
    forall  {EQ: permission`eq Pi1 Pi3}
            {EQ: permission`eq Pi2 Pi4} 
    exists  {EQ: permission`eq (Pi1 , Pi2) (Pi3 , Pi4)}
    true.

- : permission`combine-preserves-eq 
    permission`eq/ permission`eq/ permission`eq/.

%worlds (objvar) (permission`combine-preserves-eq _ _ _).
%total  {} (permission`combine-preserves-eq _ _ _).


%theorem permission`implies-respects-eq-left :
    forall* {P1} {P2} {P}
    forall  {P-EQ: permission`eq P1 P2}
            {IMP1: implies P1 P}
    exists  {IMP2: implies P2 P}
    true.

- : permission`implies-respects-eq-left permission`eq/ IMP IMP.

%worlds () (permission`implies-respects-eq-left _ _ _).
%total  {} (permission`implies-respects-eq-left _ _ _).


%theorem permission`implies-respects-eq-right :
    forall* {P1} {P2} {P}
    forall  {P-EQ: permission`eq P1 P2}
            {IMP1: implies P P1}
    exists  {IMP2: implies P P2}
    true.

- : permission`implies-respects-eq-right permission`eq/ IMP IMP.

%worlds () (permission`implies-respects-eq-right _ _ _).
%total  {} (permission`implies-respects-eq-right _ _ _).


%%% set2facts


%theorem cxt-set-implies-set2facts :
    forall* {B} {O} {S}
    forall  {S-B: cxt-set B S}
    exists  {G} {S2G: set2facts B O S G}
    true.

- : cxt-set-implies-set2facts cxt-set/0 f set2facts/0.

- : cxt-set-implies-set2facts
    (cxt-set/U NM A L B-SP) _
    (set2facts/U NM A L SP=>G)
    <- cxt-set-implies-set2facts B-SP _ SP=>G.

%worlds () (cxt-set-implies-set2facts _ _ _).
%total (S-B) (cxt-set-implies-set2facts S-B _ _).


%{% set2facts is NOT unique, but results are equivalent %}%

set2facts-implies-equiv
  : set2facts B1 O1 S1 G1
    -> set2facts B2 O2 S2 G2
    -> cxt`eq B1 B2
    -> object`eq O1 O2
    -> set`eq S1 S2
    -> equiv (unitperm (nonlinear G1)) (unitperm (nonlinear G2))
    -> type.
%mode set2facts-implies-equiv +T1 +T2 +E1 +E2 +E3 -EV.

%worlds (objvar | fracvar) (set2facts-implies-equiv _ _ _ _ _ _).
%trustme %total {} (set2facts-implies-equiv _ _ _ _ _ _).


% apply-efx

apply-efx-total* : {P} {X} {Pi} {FPi} apply-efx P X Pi FPi -> type.

%mode apply-efx-total* +P +X +Pi -FPi -AP.

- : apply-efx-total* _ efx/read _ _ apply-efx/read.

- : apply-efx-total* _ efx/write _ _ apply-efx/write.

- : apply-efx-total* true efx/consume Pi ([_] Pi) apply-efx/consume/true.

- : apply-efx-total* false efx/consume Pi ([_] empty) apply-efx/consume/false.

%worlds (fracvar) (apply-efx-total* _ _ _ _ _).
%total {} (apply-efx-total* _ _ _ _ _).

%abbrev apply-efx-total = apply-efx-total* _ _ _ _.


apply-efx-deterministic 
  : apply-efx P1 X1 Pi1 FPi1
    -> apply-efx P2 X2 Pi2 FPi2
    -> bool`eq P1 P2
    -> efx`eq X1 X2
    -> permission`eq Pi1 Pi2
    -> ({z} permission`eq (FPi1 z) (FPi2 z))
    -> type.

%mode apply-efx-deterministic +AX1 +AX2 +E1 +E2 +E3 -E4.

- : apply-efx-deterministic
    AX1 AX2 bool`eq/ efx`eq/ permission`eq/ ([_] permission`eq/).

%worlds () (apply-efx-deterministic _ _ _ _ _ _).
%total { } (apply-efx-deterministic _ _ _ _ _ _).


apply-efx-respects-eq
  : apply-efx B1 X1 P1 S1
    -> bool`eq B1 B2
    -> efx`eq X1 X2
    -> permission`eq P1 P2
    -> ({z} permission`eq (S1 z) (S2 z))
    -> apply-efx B2 X2 P2 S2
    -> type.

%mode apply-efx-respects-eq +A1 +E1 +E2 +E3 +E4 -A2.

- : apply-efx-respects-eq apply-efx/read bool`eq/
    efx`eq/ permission`eq/ ([_] permission`eq/) apply-efx/read.
    
- : apply-efx-respects-eq apply-efx/write bool`eq/
    efx`eq/ permission`eq/ ([_] permission`eq/) apply-efx/write.

- : apply-efx-respects-eq apply-efx/consume/false bool`eq/
    efx`eq/ permission`eq/ ([_] permission`eq/) apply-efx/consume/false.

- : apply-efx-respects-eq apply-efx/consume/true bool`eq/
    efx`eq/ permission`eq/ ([_] permission`eq/) apply-efx/consume/true.

%worlds () (apply-efx-respects-eq _ _ _ _ _ _).
%total {} (apply-efx-respects-eq _ _ _ _ _ _).


% inner-efxmap2perm

false-implies-inner-efxmap2perm
  : {V:void} inner-efxmap2perm P O FM PM M Pi -> type.

%mode +{P} +{O} +{FM} +{PM} +{M} +{V} -{Pi}
-{M2Pi: inner-efxmap2perm P O FM PM M Pi} 
false-implies-inner-efxmap2perm V M2Pi.

%worlds (fracvar) (false-implies-inner-efxmap2perm _ _).
%total { } (false-implies-inner-efxmap2perm _ _).


inner-efxmap2perm-respects-eq
  : inner-efxmap2perm P1 O1 FM1 PM1 M1 Pi1
    -> bool`eq P1 P2
    -> object`eq O1 O2
    -> fldmap`eq FM1 FM2
    -> predmap`eq PM1 PM2 
    -> inner-efxmap`eq M1 M2
    -> ({z} permission`eq (Pi1 z) (Pi2 z))
    -> inner-efxmap2perm P2 O2 FM2 PM2 M2 Pi2
    -> type.

%mode inner-efxmap2perm-respects-eq +M1 +BE +OE +FME +PME +ME +PE -M2.

- : inner-efxmap2perm-respects-eq 
    M=>Pi bool`eq/ object`eq/ fldmap`eq/ 
    predmap`eq/ inner-efxmap`eq/ ([_] permission`eq/) M=>Pi.

%worlds (fracvar) (inner-efxmap2perm-respects-eq _ _ _ _ _ _ _ _).
%total { } (inner-efxmap2perm-respects-eq _ _ _ _ _ _ _ _).


inner-efxmap2perm-implies-equiv
  : inner-efxmap2perm P1 O1 FM1 PM1 M1 Pi1
    -> inner-efxmap2perm P2 O2 FM2 PM2 M2 Pi2
    -> bool`eq P1 P2
    -> object`eq O1 O2
    -> fldmap`eq FM1 FM2
    -> predmap`eq PM1 PM2
    -> inner-efxmap`eq M1 M2
    -> ({z} equiv (Pi1 z) (Pi2 z))
    -> type.

%mode inner-efxmap2perm-implies-equiv +T1 +T2 +E1 +E2 +E3 +E4 +E5 -EV.

%worlds () (inner-efxmap2perm-implies-equiv _ _ _ _ _ _ _ _).
%trustme %total {} (inner-efxmap2perm-implies-equiv _ _ _ _ _ _ _ _).



% efxmap2perm 

%theorem false-implies-efxmap2perm :
    forall* {CM} {PM} {B} {XM} {P}
    forall  {F: void}
    exists  {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    true.

%worlds (fracvar) (false-implies-efxmap2perm _ _ _).
%total  {} (false-implies-efxmap2perm _ _ _).


%theorem efxmap2perm-respects-eq :
    forall* {CM1} {PM1} {B1} {XM1} {Pi1} {P1}
            {CM2} {PM2} {B2} {XM2} {Pi2} {P2}
    forall  {XM1=>Pi1: efxmap2perm P1 CM1 PM1 B1 XM1 Pi1}
            {EQ: bool`eq P1 P2} 
            {EQ: clsmap`eq CM1 CM2} {EQ: predmap`eq PM1 PM2}
            {EQ: cxt`eq B1 B2} {EQ: efxmap`eq XM1 XM2}
            {EQ: {z} permission`eq (Pi1 z) (Pi2 z)}
    exists  {XM2=>Pi2: efxmap2perm P2 CM2 PM2 B2 XM2 Pi2} 
    true.

- : efxmap2perm-respects-eq XM=>Pi bool`eq/ clsmap`eq/ predmap`eq/
    cxt`eq/ efxmap`eq/ ([_] permission`eq/) XM=>Pi.

%worlds (fracvar) (efxmap2perm-respects-eq _ _ _ _ _ _ _ _).
%total  {} (efxmap2perm-respects-eq _ _ _ _ _ _ _ _).


efxmap2perm-implies-equiv
  : efxmap2perm P1 CM1 PM1 B1 XM1 Pi1
    -> efxmap2perm P2 CM2 PM2 B2 XM2 Pi2
    -> bool`eq P1 P2
    -> clsmap`eq CM1 CM2
    -> predmap`eq PM1 PM2
    -> cxt`eq B1 B2
    -> efxmap`eq XM1 XM2
    -> ({z} equiv (Pi1 z) (Pi2 z))
    -> type.

%mode efxmap2perm-implies-equiv +T1 +T2 +E1 +E2 +E3 +E4 +E5 -EV.

%worlds (fracvar) (efxmap2perm-implies-equiv _ _ _ _ _ _ _ _).
%trustme %total {} (efxmap2perm-implies-equiv _ _ _ _ _ _ _ _).


fldmap-inner-efxmap-implies-inner-efxmap2perm*
  : {P} {O} clsmap-clsmap CM CM
    -> clsmap2predmap CM PM
    -> clsmap`lookup CM C FM
    -> fldmap-inner-efxmap FM M
    -> {Pi} inner-efxmap2perm P O FM PM M Pi
    -> type.

%mode fldmap-inner-efxmap-implies-inner-efxmap2perm* 
+P +O +D1 +D2 +D3 +D4 -Pi -D5.

- : fldmap-inner-efxmap-implies-inner-efxmap2perm*
    _ _ _ _ _ fldmap-inner-efxmap/0 ([_] empty) inner-efxmap2perm/0.

- : fldmap-inner-efxmap-implies-inner-efxmap2perm* _ _ CM-CM CM2PM CM-L
    (fldmap-inner-efxmap/U F U L FIE) _
    (inner-efxmap2perm/U F U L T2P AP M2P)
    <- lookup-implies-clsmap-fldmap CM-CM CM-L CM-FM
    <- lookup-implies-clsmap-ty CM-FM L CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2P
    <- apply-efx-total AP
    <- fldmap-inner-efxmap-implies-inner-efxmap2perm*
      _ _ CM-CM CM2PM CM-L FIE _ M2P.

%worlds (fracvar)
(fldmap-inner-efxmap-implies-inner-efxmap2perm* _ _ _ _ _ _ _ _).
%total (I) (fldmap-inner-efxmap-implies-inner-efxmap2perm* _ _ _ _ _ I _ _).

%abbrev fldmap-inner-efxmap-implies-inner-efxmap2perm
  = fldmap-inner-efxmap-implies-inner-efxmap2perm* _ _.


efxmap-clsmap-implies-efxmap2perm*
  : {P} clsmap-clsmap CM CM
    -> clsmap2predmap CM PM
    -> cxt-efxmap B CM XM
    -> {Pi} efxmap2perm P CM PM B XM Pi
    -> type.

%mode efxmap-clsmap-implies-efxmap2perm* +D0 +D1 +D2 +D3 -Pi -T.

- : efxmap-clsmap-implies-efxmap2perm* _ _ _ cxt-efxmap/0 _ efxmap2perm/0.

- : efxmap-clsmap-implies-efxmap2perm* _ CM-CM CM2PM
    (cxt-efxmap/S F U B-XM) _ (efxmap2perm/S F U XM2P)
    <- efxmap-clsmap-implies-efxmap2perm* _ CM-CM CM2PM B-XM _ XM2P.

- : efxmap-clsmap-implies-efxmap2perm* P CM-CM CM2PM
    (cxt-efxmap/U F U BL L FIE B-XM)
    ([z] (Pi1 z) , Pi2 z) (efxmap2perm/U F U BL L M2P XM2P)
    <- fldmap-inner-efxmap-implies-inner-efxmap2perm* P _
      CM-CM CM2PM L FIE Pi1 M2P
    <- efxmap-clsmap-implies-efxmap2perm* P CM-CM CM2PM B-XM Pi2 XM2P.

%worlds (fracvar) (efxmap-clsmap-implies-efxmap2perm* _ _ _ _ _ _).
%total (T) (efxmap-clsmap-implies-efxmap2perm* _ _ _ T _ _).

%abbrev efxmap-clsmap-implies-efxmap2perm = efxmap-clsmap-implies-efxmap2perm* _.



% cxt2facts

%theorem cxt2facts-total :
    forall* {CM} {PM} {B}
    forall  {CM-B: clsmap-cxt CM B}
            {CM2PM: clsmap2predmap CM PM}
    exists  {G} {B2G: cxt2facts PM B G}
    true.

%worlds () (cxt2facts-total _ _ _ _).
%trustme %total (CM-B) (cxt2facts-total CM-B _ _ _).


% inner-efxmap2perm

inner-efxmap`fresh-update-implies-equiv-converse
  : inner-efxmap`fresh MP F
    -> inner-efxmap`update MP F X M
    -> inner-efxmap2perm P O FM PM M Pi1
    -> {Pi2} {Pi3} fldmap`lookup FM F T
    -> ty2perm PM T PF
    -> apply-efx P X (unitperm (precise-exists O F PF)) Pi2
    -> inner-efxmap2perm P O FM PM MP Pi3
    -> ({z} equiv (Pi1 z) ((Pi2 z) , Pi3 z))
    -> type.

%mode inner-efxmap`fresh-update-implies-equiv-converse
+FS +U +T1 -P2 -P3 -L -TF -AP -T2 -EV.

- : inner-efxmap`fresh-update-implies-equiv-converse
    inner-efxmap`fresh/0 inner-efxmap`update/0 %{=>}%
    (inner-efxmap2perm/U 
      inner-efxmap`fresh/0 inner-efxmap`update/0
      FM-L T2P AP inner-efxmap2perm/0)
    _ _ FM-L T2P AP inner-efxmap2perm/0 ([_] equiv/reflexive).

inner-efxmap`fresh-update-implies-equiv-converse/U
  : inner-efxmap`fresh MP F1
    -> inner-efxmap`update MP F1 X1 M
    -> inner-efxmap`fresh MS F2
    -> inner-efxmap`update MS F2 X2 M
    -> fldmap`lookup FM F2 T2
    -> ty2perm PM T2 PF2
    -> apply-efx P X2 (unitperm (precise-exists O F2 PF2)) Pi1
    -> inner-efxmap2perm P O FM PM MS Pi2
    -> nat`eq? F1 F2 B
    %{=>}%
    -> fldmap`lookup FM F1 T1
    -> ty2perm PM T1 PF1
    -> apply-efx P X1 (unitperm (precise-exists O F1 PF1)) Pi3
    -> inner-efxmap2perm P O FM PM MP Pi4
    -> ({z} equiv ((Pi1 z) , Pi2 z) ((Pi3 z) , Pi4 z))
    -> type.

%mode inner-efxmap`fresh-update-implies-equiv-converse/U
+FS1 +U1 +FS2 +U2 +L1 +T1 +A1 +TP1 +E? -L2 -T2 -A2 -TP2 -EV.

- : inner-efxmap`fresh-update-implies-equiv-converse/U
    F!<MP MP+F=M F!<MS MS+F=M FM->F T=>PF PF+X1=>P1 MS=>P2
    (nat`eq?/yes) %{=>}% FM->F T=>PF PF+X2=>P1 MP=>P2 ([_] equiv/reflexive)
    <- inner-efxmap`fresh-update-cancels F!<MS MS+F=M F!<MP MP+F=M 
      nat`eq/ inner-efxmap`eq/ X2=X1 MS=MP
    <- apply-efx-respects-eq 
      PF+X1=>P1 bool`eq/ X2=X1 permission`eq/ ([_] permission`eq/) PF+X2=>P1
    <- inner-efxmap2perm-respects-eq 
      MS=>P2 bool`eq/ object`eq/ fldmap`eq/ predmap`eq/ MS=MP
      ([_] permission`eq/) MP=>P2.
    
- : inner-efxmap`fresh-update-implies-equiv-converse/U
     F1!<MP MP+F1=M F2!<MS MS+F2=M FM->F2 T2=>PF2 PF2=>P1 MS=>P2
    (nat`eq?/no F1!=F2) %{=>}% FM->F1 T1=>PF1 PF1=>P3
    (inner-efxmap2perm/U F2!<MK MK+F2=MP FM->F2 T2=>PF2 PF2=>P1 MK=>P5)
    ([f] equiv/transitive
      (equiv/combine
        equiv/reflexive (EQV f))
      (equiv/roll2))
    <- inner-efxmap`update-commutes-converse
      MP+F1=M MS+F2=M F1!=F2 MK MK+F2=MP MK+F1=MS
    <- inner-efxmap`update-preserves-fresh-converse F1!<MP MK+F2=MP F1!<MK
    <- inner-efxmap`update-preserves-fresh-converse F2!<MS MK+F1=MS F2!<MK
    <- inner-efxmap`fresh-update-implies-equiv-converse
      F1!<MK MK+F1=MS MS=>P2 _ _ FM->F1 T1=>PF1 PF1=>P3 MK=>P5 EQV.

- : inner-efxmap`fresh-update-implies-equiv-converse F1!<MP MP+F1=M
    (inner-efxmap2perm/U F2!<MS MS+F2=M T1 T2 T3 T4) _ _ Q1 Q2 Q3 Q4 EQV
    <- nat`eq?-total EQ?
    <- inner-efxmap`fresh-update-implies-equiv-converse/U
      F1!<MP MP+F1=M F2!<MS MS+F2=M T1 T2 T3 T4 EQ? Q1 Q2 Q3 Q4 EQV. 

%worlds () 
(inner-efxmap`fresh-update-implies-equiv-converse _ _ _ _ _ _ _ _ _ _)
(inner-efxmap`fresh-update-implies-equiv-converse/U _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (T1 T2)
(inner-efxmap`fresh-update-implies-equiv-converse _ _ T1 _ _ _ _ _ _ _)
(inner-efxmap`fresh-update-implies-equiv-converse/U _ _ _ _ _ _ _ T2 _ _ _ _ _ _).


%theorem inner-efxmap`leq-implies-permission-leq/L :
    forall* {O} {CM} {C} {FM} {PM} {M1} {M2} {Pi1} {P}
    forall  {N} {SZ: inner-efxmap`size M2 N}
            {CM-CM: clsmap-clsmap CM CM}
            {CM2PM: clsmap2predmap CM PM}
            {CM-L: clsmap`lookup CM C FM}
            {FM-M: fldmap-inner-efxmap FM M2}
            {M1=>Pi1: inner-efxmap2perm P O FM PM M1 Pi1}
            {M1<=M2: inner-efxmap`leq M1 M2}
    exists  {Pi2} {Pi3} {M2=>Pi2: inner-efxmap2perm P O FM PM M2 Pi2}
            {IMP: {z} equiv (Pi2 z) ((Pi1 z) , (Pi3 z))}
    true.

%worlds (fracvar | objvar) 
(inner-efxmap`leq-implies-permission-leq/L _ _ _ _ _ _ _ _ _ _ _ _).
%trustme  % this is tricky because of expose
%total (N) 
(inner-efxmap`leq-implies-permission-leq/L N _ _ _ _ _ _ _ _ _ _ _).


inner-efxmap`leq-implies-permission-leq
  : clsmap-clsmap CM CM
    -> clsmap2predmap CM PM
    -> clsmap`lookup CM C FM
    -> fldmap-inner-efxmap FM MP
    -> inner-efxmap2perm P O FM PM M P1
    -> inner-efxmap`leq M MP
    -> {P2} {P3} inner-efxmap2perm P O FM PM MP P2
    -> ({f} equiv (P2 f) ((P1 f) , (P3 f)))
    -> type.

%mode inner-efxmap`leq-implies-permission-leq 
+D0 +D1 +L +I +T +LE -P2 -P3 -T2 -EV.

- : inner-efxmap`leq-implies-permission-leq A B C D E G _ _ H I
    <- inner-efxmap`size-total SZ
    <- inner-efxmap`leq-implies-permission-leq/L _ SZ A B C D E G _ _ H I.

%worlds (fracvar) 
(inner-efxmap`leq-implies-permission-leq _ _ _ _ _ _ _ _ _ _).
%total  {} (inner-efxmap`leq-implies-permission-leq _ _ _ _ _ _ _ _ _ _).


% efxmap2perm



efxmap`fresh-update-zero-implies-equiv-converse
  : efxmap`fresh MP z
    -> efxmap`update MP z D M
    -> efxmap2perm P CM PM B M Pi1
    -> {Pi2} efxmap2perm P CM PM B MP Pi2
    -> ({f} equiv (Pi1 f) ((unitperm (basic null all null)) , (Pi2 f)))
    -> type.

%mode efxmap`fresh-update-zero-implies-equiv-converse
+F1 +U1 +T1 -P1 -T3 -EV.

- : efxmap`fresh-update-zero-implies-equiv-converse
    efxmap`fresh/0 efxmap`update/0 %{=>}%
    (efxmap2perm/S efxmap`fresh/0 efxmap`update/0 efxmap2perm/0)
    _ efxmap2perm/0 ([_] equiv/reflexive).

- : efxmap`fresh-update-zero-implies-equiv-converse
    Z!<MP (MP+Z=M:efxmap`update MP _ _ M)
    (efxmap2perm/S Z!<MS (MS+Z=M:efxmap`update MS _ _ M) MS=>P) _ MP=>P
    ([_] equiv/reflexive)
    <- efxmap`fresh-update-cancels
      Z!<MS MS+Z=M Z!<MP MP+Z=M nat`eq/ efxmap`eq/ D2=D1 MS=MP
    <- efxmap2perm-respects-eq MS=>P bool`eq/ clsmap`eq/ predmap`eq/
      cxt`eq/ MS=MP ([_] permission`eq/) MP=>P.

- : efxmap`fresh-update-zero-implies-equiv-converse
    Z!<MP (MP+Z=M:efxmap`update MP _ _ M)
    (efxmap2perm/U N!<MS
      (MS+N=M:efxmap`update MS (s N) D M) B-L CM-L D=>P1 MS=>P2)
    _ (efxmap2perm/U N!<MK MK+N=MP B-L CM-L D=>P1 MK=>P)
    ([f] equiv/transitive
      (equiv/combine
        equiv/reflexive (EQV f))
      (equiv/roll2))
    <- nat`succ-implies-gt-zero _ GT
    <- efxmap`update-commutes-converse
      MP+Z=M MS+N=M (nat`ne/< GT) MK MK+N=MP MK+Z=MS
    <- efxmap`update-preserves-fresh-converse Z!<MP MK+N=MP Z!<MK
    <- efxmap`update-preserves-fresh-converse N!<MS MK+Z=MS N!<MK
    <- efxmap`fresh-update-zero-implies-equiv-converse
      Z!<MK MK+Z=MS MS=>P2 _ MK=>P EQV.

%worlds (fracvar) (efxmap`fresh-update-zero-implies-equiv-converse _ _ _ _ _ _).
%total (T) (efxmap`fresh-update-zero-implies-equiv-converse _ _ T _ _ _).


efxmap`fresh-update-succ-implies-equiv-converse
  : efxmap`fresh MP (s N)
    -> efxmap`update MP (s N) D M
    -> efxmap2perm P CM PM B M Pi3
    -> {Pi1} {Pi2} 
      cxt-lookup-loc B (s N) O (ty/ NN A C)
    -> clsmap`lookup CM C FM
    -> inner-efxmap2perm P O FM PM D Pi1
    -> efxmap2perm P CM PM B MP Pi2
    -> ({f} equiv (Pi3 f) ((Pi1 f) , (Pi2 f)))
    -> type.

%mode efxmap`fresh-update-succ-implies-equiv-converse
+F1 +U1 +T1 -P1 -P2 -L1 -L2 -T2 -T3 -EV.

- : efxmap`fresh-update-succ-implies-equiv-converse
    efxmap`fresh/0 efxmap`update/0 %{=>}%
    (efxmap2perm/U 
      efxmap`fresh/0 efxmap`update/0
      B-L CM-L DT efxmap2perm/0)
    _ _ B-L CM-L DT efxmap2perm/0 ([_] equiv/reflexive).

- : efxmap`fresh-update-succ-implies-equiv-converse
    N!<MP (MP+N=M:efxmap`update MP (s N) D1 M)
    (efxmap2perm/S Z!<MS (MS+Z=M:efxmap`update MS _ _ M) MS=>P) _ _
    B-L CM-L D=>P (efxmap2perm/S Z!<MK MK+Z=MP MK=>P) 
    ([f] equiv/transitive
      (equiv/combine equiv/reflexive (EQV f))
      (equiv/roll2))
    <- nat`succ-implies-gt-zero _ GT
    <- efxmap`update-commutes-converse
      MP+N=M MS+Z=M (nat`ne/> GT) MK MK+Z=MP MK+N=MS
    <- efxmap`update-preserves-fresh-converse N!<MP MK+Z=MP N!<MK
    <- efxmap`update-preserves-fresh-converse Z!<MS MK+N=MS Z!<MK
    <- efxmap`fresh-update-succ-implies-equiv-converse
      N!<MK MK+N=MS MS=>P _ _ B-L CM-L D=>P MK=>P EQV.


efxmap`fresh-update-succ-implies-equiv-converse/U
  : efxmap`fresh MP (s N1)
    -> efxmap`update MP (s N1) D1 M
    -> efxmap`fresh MS (s N2)
    -> efxmap`update MS (s N2) D2 M
    -> cxt-lookup-loc B (s N2) O2 (ty/ NN2 A2 C2)
    -> clsmap`lookup CM C2 FM2
    -> inner-efxmap2perm P O2 FM2 PM D2 Pi1
    -> efxmap2perm P CM PM B MS Pi2
    -> nat`eq? (s N1) (s N2) IN?
    %{=>}%
    -> cxt-lookup-loc B (s N1) O1 (ty/ NN1 A1 C1)
    -> clsmap`lookup CM C1 FM1
    -> inner-efxmap2perm P O1 FM1 PM D1 Pi3
    -> efxmap2perm P CM PM B MP Pi4
    -> ({z} equiv ((Pi1 z) , Pi2 z) ((Pi3 z) , Pi4 z))
    -> type.

%mode efxmap`fresh-update-succ-implies-equiv-converse/U
+FS1 +U1 +FS2 +U2 +L2 +LL2 +T2 +TP1 +E? -L1 -LL1 -T1 -TP2 -EV.

- : efxmap`fresh-update-succ-implies-equiv-converse/U
    N!<MP MP+N=M N!<MS MS+N=M B-L2 CM-L2 M2P2 XM2P2 nat`eq?/yes
    %{=>}% B-L2 CM-L2 M2P1 XM2P1 ([_] equiv/reflexive)
    <- efxmap`fresh-update-cancels
      N!<MS MS+N=M N!<MP MP+N=M nat`eq/ efxmap`eq/ D2=D1 MS=MP
    <- inner-efxmap2perm-respects-eq M2P2
      bool`eq/ object`eq/ fldmap`eq/ predmap`eq/ 
      D2=D1 ([_] permission`eq/) M2P1
    <- efxmap2perm-respects-eq XM2P2
      bool`eq/ clsmap`eq/ predmap`eq/ 
      cxt`eq/ MS=MP ([_] permission`eq/) XM2P1.

- : efxmap`fresh-update-succ-implies-equiv-converse/U
    N1!<MP MP+N1=M N2!<MS MS+N2=M B->N2 CM->C2 D2=>P1 MS=>P2
    (nat`eq?/no N1!=N2) %{=>}% B->N1 CM->C1 D1=>P3 
    (efxmap2perm/U N2!<MK MK+N2=MP B->N2 CM->C2 D2=>P1 MK=>P5)
    ([f] equiv/transitive
      (equiv/combine
        equiv/reflexive (EQV f))
      (equiv/roll2))
    <- efxmap`update-commutes-converse
      MP+N1=M MS+N2=M N1!=N2 MK MK+N2=MP MK+N1=MS
    <- efxmap`update-preserves-fresh-converse N1!<MP MK+N2=MP N1!<MK
    <- efxmap`update-preserves-fresh-converse N2!<MS MK+N1=MS N2!<MK
    <- efxmap`fresh-update-succ-implies-equiv-converse
      N1!<MK MK+N1=MS MS=>P2 _ _ B->N1 CM->C1 D1=>P3 MK=>P5 EQV.

- : efxmap`fresh-update-succ-implies-equiv-converse F1!<MP MP+F1=M
    (efxmap2perm/U F2!<MS MS+F2=M T1 T2 T3 T4) _ _ Q1 Q2 Q3 Q4 EQV
    <- nat`eq?-total EQ?
    <- efxmap`fresh-update-succ-implies-equiv-converse/U
      F1!<MP MP+F1=M F2!<MS MS+F2=M T1 T2 T3 T4 EQ? Q1 Q2 Q3 Q4 EQV. 

%worlds (fracvar) 
(efxmap`fresh-update-succ-implies-equiv-converse _ _ _ _ _ _ _ _ _ _)
(efxmap`fresh-update-succ-implies-equiv-converse/U _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (T1 T2)
(efxmap`fresh-update-succ-implies-equiv-converse _ _ T1 _ _ _ _ _ _ _)
(efxmap`fresh-update-succ-implies-equiv-converse/U _ _ _ _ _ _ _ T2 _ _ _ _ _ _).


efxmap`leq-implies-permission-leq/L
  : {N} efxmap`size XM2 N
    -> wf-cxt B
    -> clsmap-clsmap CM CM
    -> clsmap2predmap CM PM
    -> cxt-efxmap B CM XM2
    -> efxmap2perm P CM PM B XM1 Pi1
    -> efxmap`leq XM1 XM2
    -> {Pi2} {Pi3} efxmap2perm P CM PM B XM2 Pi2
    -> ({f} equiv (Pi2 f) ((Pi1 f) , Pi3 f))
    -> type.

%mode efxmap`leq-implies-permission-leq/L
+N +SZ +W +D0 +D1 +D2 +T +LE -P1 -P2 -T1 -EV.

- : efxmap`leq-implies-permission-leq/L _ _ _
    CM-CM CM2PM B-XM2 efxmap2perm/0 efxmap`leq/0 _ _ XM=>Pi
    ([_] equiv/transitive
      (equiv/symmetric equiv/identity)
      (equiv/commute))
    <- efxmap-clsmap-implies-efxmap2perm CM-CM CM2PM B-XM2 _ XM=>Pi.
    
efxmap`leq-implies-permission-leq/S
  : {K} efxmap`size XM2 K
    -> wf-cxt B
    -> clsmap-clsmap CM CM
    -> clsmap2predmap CM PM
    -> efxmap`fresh XM2P z
    -> efxmap`update XM2P z (inner-efxmap/+ z X inner-efxmap/0) XM2
%    -> efxmap`update XM2P z M XM2
    -> cxt-efxmap B CM XM2P
    -> efxmap2perm P CM PM B XM1 Pi1
    -> efxmap`leq XM1 XM2
    -> efxmap`domain? XM1 z IN?
    -> {Pi2} {Pi3} efxmap2perm P CM PM B XM2 Pi2
    -> ({z} equiv (Pi2 z) ((Pi1 z) , (Pi3 z)))
    -> type.

%mode efxmap`leq-implies-permission-leq/S
+K +SZ +W +D0 +D1 +F1 +U1 +D2 +T1 +LE +DM -P1 -P2 -T2 -EV.

- : efxmap`leq-implies-permission-leq/S
    _ SZ-XM2 WF CM-CM CM2PM Z!<XM2P XM2P+Z+M=XM2 B-XM2P XM1=>Pi1 
    XM1<=XM2 (efxmap`domain?/in XM1->Z) _ _ 
    (efxmap2perm/S Z!<XM2P XM2P+Z+M=XM2 XM2P=>P2)
    ([f] equiv/transitive3
      (equiv/combine (equiv/reflexive) (EQV f))
      (equiv/associate)
      (equiv/combine (equiv/symmetric (EQV2 f)) equiv/reflexive))
    <- efxmap`lookup-implies-fresh-update
      XM1->Z XM1P Z!<XM1P (XM1P+Z+M1=XM1:efxmap`update XM1P z M1 XM1)
    <- efxmap`fresh-update-preserves-leq-converse
      XM1<=XM2 Z!<XM1P XM1P+Z+M1=XM1 Z!<XM2P XM2P+Z+M=XM2 
      XM1P<=XM2P M1<=M
    <- efxmap`fresh-update-zero-implies-equiv-converse
      Z!<XM1P XM1P+Z+M1=XM1 XM1=>Pi1 _ XM1P=>Pi1 EQV2
    <- efxmap`fresh-update-increases-size-converse 
      SZ-XM2 Z!<XM2P XM2P+Z+M=XM2 SZ-XM2P
    <- efxmap`leq-implies-permission-leq/L _ SZ-XM2P WF
      CM-CM CM2PM B-XM2P XM1P=>Pi1 XM1P<=XM2P _ _ XM2P=>P2 EQV.

- : efxmap`leq-implies-permission-leq/S _ SZ-XM2 WF
    CM-CM CM2PM Z!<XM2P (XM2P+Z+M=XM2: efxmap`update XM2P z _ XM2)
    B-XM2P XM1=>Pi1 XM1<=XM2 (efxmap`domain?/out Z!<XM1) _ _ 
    (efxmap2perm/S Z!<XM2P XM2P+Z+M=XM2 XM2P=>P) 
    ([f] equiv/transitive
      (equiv/combine equiv/reflexive (EQV f))
      (equiv/roll2))
    <- efxmap`fresh-update2-preserves-leq-converse
      XM1<=XM2 Z!<XM1 Z!<XM2P XM2P+Z+M=XM2 XM1<=XM2P
    <- efxmap`fresh-update-increases-size-converse 
      SZ-XM2 Z!<XM2P XM2P+Z+M=XM2 SZ-XM2P
    <- efxmap`leq-implies-permission-leq/L _ SZ-XM2P WF
      CM-CM CM2PM B-XM2P XM1=>Pi1 XM1<=XM2P _ _ XM2P=>P EQV.

efxmap`leq-implies-permission-leq/U
  : {K} efxmap`size XM2 K
    -> wf-cxt B
    -> clsmap-clsmap CM CM
    -> clsmap2predmap CM PM
    -> efxmap`fresh XM2P (s N)
    -> efxmap`update XM2P (s N) M XM2
    -> cxt-lookup-loc B (s N) O (ty/ NN A C)
    -> clsmap`lookup CM C FM
    -> fldmap-inner-efxmap FM M
    -> cxt-efxmap B CM XM2P
    -> efxmap2perm P CM PM B XM1 Pi1
    -> efxmap`leq XM1 XM2
    -> efxmap`domain? XM1 (s N) IN?
    -> {Pi2} {Pi3} efxmap2perm P CM PM B XM2 Pi2
    -> ({z} equiv (Pi2 z) ((Pi1 z) , (Pi3 z)))
    -> type.

%mode efxmap`leq-implies-permission-leq/U
+K +SZ +W +D0 +D1 +F1 +U1 +BL +CML +D2 +D3 +T1 +LE +DM -P1 -P2 -T2 -EV.

- : efxmap`leq-implies-permission-leq/U _ SZ-XM2 WF
    CM-CM CM2PM N!<XM2P (XM2P+N+M=XM2:efxmap`update XM2P (s N) M XM2)
    B-L CM-L FM-M B-XM2P XM1=>Pi1 XM1<=XM2
    (efxmap`domain?/out N!<XM1) %{=>}% _ _
    (efxmap2perm/U N!<XM2P XM2P+N+M=XM2 B-L CM-L M=>P XM2P=>P) 
    ([f] equiv/transitive
      (equiv/combine equiv/reflexive (EQV f))
      (equiv/roll2))
    <- efxmap`fresh-update2-preserves-leq-converse
      XM1<=XM2 N!<XM1 N!<XM2P XM2P+N+M=XM2 XM1<=XM2P
    <- efxmap`fresh-update-increases-size-converse 
      SZ-XM2 N!<XM2P XM2P+N+M=XM2 SZ-XM2P
    <- efxmap`leq-implies-permission-leq/L _ SZ-XM2P
      WF CM-CM CM2PM B-XM2P XM1=>Pi1 XM1<=XM2P _ _ XM2P=>P EQV
    <- fldmap-inner-efxmap-implies-inner-efxmap2perm CM-CM CM2PM
      CM-L FM-M _ M=>P.

- : efxmap`leq-implies-permission-leq/U _ SZ-XM2 WF
    CM-CM CM2PM N!<XM2P (XM2P+N+M=XM2:efxmap`update XM2P (s N) M XM2)
    B-L CM-L FM-M B-XM2P XM1=>Pi1 XM1<=XM2
    (efxmap`domain?/in XM1->N=M1) %{=>}% _ _
    (efxmap2perm/U N!<XM2P XM2P+N+M=XM2 B-L CM-L M=>P XM2P=>P2) 
    ([f] equiv/transitive3
      (equiv/combine (EQV3 f) (EQV f))
      (equiv/transitive3
        (equiv/symmetric equiv/associate)
        (equiv/combine equiv/reflexive equiv/roll2)
        (equiv/associate))
      (equiv/combine (equiv/symmetric (EQV2 f)) equiv/reflexive))
    <- efxmap`lookup-implies-fresh-update
      XM1->N=M1 XM1P N!<XM1P (XM1P+N+M1=XM1:efxmap`update XM1P (s N) M1 XM1)
    <- efxmap`fresh-update-preserves-leq-converse
      XM1<=XM2 N!<XM1P XM1P+N+M1=XM1 N!<XM2P XM2P+N+M=XM2 XM1P<=XM2P M1<=M
    <- efxmap`fresh-update-increases-size-converse 
      SZ-XM2 N!<XM2P XM2P+N+M=XM2 SZ-XM2P
    <- efxmap`fresh-update-succ-implies-equiv-converse
      N!<XM1P XM1P+N+M1=XM1 XM1=>Pi1 _ _ B-L' CM-L' M1=>P' XM1P=>Pi1 EQV2
    <- cxt-lookup-loc-unique WF WF B-L' B-L cxt`eq/ nat`eq/ OE TE
    <- ty-eq-inversion TE _ _ CE
    <- clsmap`lookup-unique CM-L' CM-L clsmap`eq/ CE FME
    <- inner-efxmap2perm-respects-eq M1=>P' bool`eq/ OE FME 
      predmap`eq/ inner-efxmap`eq/ ([_] permission`eq/) M1=>P
    <- efxmap`leq-implies-permission-leq/L _ SZ-XM2P WF
      CM-CM CM2PM B-XM2P XM1P=>Pi1 XM1P<=XM2P _ _ XM2P=>P2 EQV
    <- inner-efxmap`leq-implies-permission-leq 
      CM-CM CM2PM CM-L FM-M M1=>P M1<=M _ _ M=>P EQV3.

- : efxmap`leq-implies-permission-leq/L _ SZ-XM2 W CM-CM CM2PM
    (cxt-efxmap/U N!<XM2P (XM2P+N+M=XM2:efxmap`update XM2P (s N) M XM2)
      B->N=C CM->C=FM FM-M B-XM2P)
    XM1=>Pi1 XM1<=XM2 %{=>}% _ _ XM2=>Pi2 EQV
    <- efxmap`domain?-total IN?
    <- efxmap`leq-implies-permission-leq/U 
      _ SZ-XM2 W CM-CM CM2PM N!<XM2P XM2P+N+M=XM2 B->N=C CM->C=FM
      FM-M B-XM2P XM1=>Pi1 XM1<=XM2 IN? _ _ XM2=>Pi2 EQV.

- : efxmap`leq-implies-permission-leq/L _ SZ-XM2 W CM-CM CM2PM
    (cxt-efxmap/S Z!<XM2P XM2P+Z=XM2 B-XM2P) 
    XM1=>Pi1 XM1<=XM2 %{=>}% _ _ XM2=>Pi2 EQV
    <- efxmap`domain?-total IN?
    <- efxmap`leq-implies-permission-leq/S _ SZ-XM2 W CM-CM
      CM2PM Z!<XM2P XM2P+Z=XM2 B-XM2P XM1=>Pi1 XM1<=XM2 IN? _ _ XM2=>Pi2 EQV.

%worlds (fracvar) 
(efxmap`leq-implies-permission-leq/L _ _ _ _ _ _ _ _ _ _ _ _)
(efxmap`leq-implies-permission-leq/U _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(efxmap`leq-implies-permission-leq/S _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N1 N2 N3) 
(efxmap`leq-implies-permission-leq/U N2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(efxmap`leq-implies-permission-leq/S N3 _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(efxmap`leq-implies-permission-leq/L N1 _ _ _ _ _ _ _ _ _ _ _).


efxmap`leq-implies-permission-leq
  : clsmap-clsmap CM CM
    -> clsmap2predmap CM PM
    -> wf-cxt B
    -> cxt-efxmap B CM XM2
    -> efxmap2perm P CM PM B XM1 Pi1
    -> efxmap`leq XM1 XM2
    -> {Pi2} {Pi3} efxmap2perm P CM PM B XM2 Pi2
    -> ({z} equiv (Pi2 z) ((Pi1 z) , (Pi3 z))) -> type.

%mode efxmap`leq-implies-permission-leq +C1 +C2 +C9 +C3 +C4 +C5 -P1 -P2 -C6 -C7.

- : efxmap`leq-implies-permission-leq CM-CM CM2PM  WF
    B-XM2 XM1=>Pi1 XM1<=XM2 Pi2 Pi3 XM2=>Pi2 EQV
    <- efxmap`size-total SZ
    <- leq-preserves-cxt-efxmap B-XM2 XM1<=XM2 B-XM1
    <- efxmap`leq-implies-permission-leq/L _ SZ WF CM-CM CM2PM 
      B-XM2 XM1=>Pi1 XM1<=XM2 _ _ XM2=>Pi2 EQV.

%worlds (fracvar) (efxmap`leq-implies-permission-leq _ _ _ _ _ _ _ _ _ _).
%total  {} (efxmap`leq-implies-permission-leq _ _ _ _ _ _ _ _ _ _).


%theorem false-implies-equiv :
	forall* {Pi1} {Pi2}
	forall {F:void}
	exists {EQ:equiv Pi1 Pi2}
	true.

%worlds (fracvar | objvar) (false-implies-equiv _ _).
%total { } (false-implies-equiv _ _).


%theorem equiv-respects-eq :
	forall* {Pi1} {Pi1'} {Pi2} {Pi2'}
	forall {E1:equiv Pi1 Pi1'} {E:permission`eq Pi1 Pi2} {E':permission`eq Pi1' Pi2'}
	exists {E2:equiv Pi2 Pi2'}
	true.

- : equiv-respects-eq EQ permission`eq/ permission`eq/ EQ.

%worlds (fracvar | objvar) (equiv-respects-eq _ _ _ _).
%total { } (equiv-respects-eq _ _ _ _).


efxmap`leq-implies-permission-leq-converse
  : clsmap-clsmap CM CM
    -> clsmap2predmap CM PM
    -> wf-cxt B
    -> cxt-efxmap B CM XM2
    -> efxmap2perm P CM PM B XM2 Pi2
    -> efxmap`leq XM1 XM2
    -> {Pi1} {Pi3} efxmap2perm P CM PM B XM1 Pi1
    -> ({f} equiv (Pi2 f) ((Pi1 f) , (Pi3 f)))
    -> type.

%mode efxmap`leq-implies-permission-leq-converse 
+D0 +D1 +D7 +D2 +D3 +D4 -D5 -P1 -P2 -D6.

- : efxmap`leq-implies-permission-leq-converse
    CM-CM CM2PM W-B B-XM2 XM2=>Pi2 XM1<=XM2 Pi1 _ XM1=>Pi1 
    ([f] equiv/transitive (equiv/symmetric (EQV2 f)) (EQV1 f))
    <- leq-preserves-cxt-efxmap B-XM2 XM1<=XM2 B-XM1
    <- efxmap-clsmap-implies-efxmap2perm CM-CM CM2PM B-XM1 Pi1 XM1=>Pi1
    <- efxmap`leq-implies-permission-leq
      CM-CM CM2PM W-B B-XM2 XM1=>Pi1 XM1<=XM2 Pi2 Pi3 XM2=>Pi2' EQV1
    <- efxmap2perm-implies-equiv XM2=>Pi2' XM2=>Pi2
       bool`eq/ clsmap`eq/ predmap`eq/ cxt`eq/ efxmap`eq/ EQV2.

%worlds (fracvar)
(efxmap`leq-implies-permission-leq-converse _ _ _ _ _ _ _ _ _ _).
%total  {} (efxmap`leq-implies-permission-leq-converse _ _ _ _ _ _ _ _ _ _).


%theorem inner-efxmap`disjoint-join-implies-equiv/L :
    forall* {M1} {M2} {M} {O} {FM} {PM} {Pi1} {Pi2} {P}
    forall  {N1} {SZ: inner-efxmap`size M1 N1}
            {N2} {SZ: inner-efxmap`size M2 N2}
            {M1^M2: inner-efxmap`disjoint M1 M2}
            {M2UM2=M: inner-efxmap`join M1 M2 M}
            {M1=>Pi1: inner-efxmap2perm P O FM PM M1 Pi1}
            {M2=>Pi2: inner-efxmap2perm P O FM PM M2 Pi2}
    exists  {Pi} {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
            {EQV: {z} equiv ((Pi1 z) , (Pi2 z)) (Pi z)}
    true.
      
%worlds (fracvar) 
(inner-efxmap`disjoint-join-implies-equiv/L _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {N1 N2} 
(inner-efxmap`disjoint-join-implies-equiv/L N1 _ N2 _ _ _ _ _ _ _ _).
      

%theorem inner-efxmap`disjoint-join-implies-equiv :
    forall* {M1} {M2} {M} {O} {FM} {PM} {Pi1} {Pi2} {P}
    forall  {M1^M2: inner-efxmap`disjoint M1 M2}
            {M2UM2=M: inner-efxmap`join M1 M2 M}
            {M1=>Pi1: inner-efxmap2perm P O FM PM M1 Pi1}
            {M2=>Pi2: inner-efxmap2perm P O FM PM M2 Pi2}
    exists  {Pi} {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
            {EQV: {z} equiv ((Pi1 z) , (Pi2 z)) (Pi z)}
    true.

- : inner-efxmap`disjoint-join-implies-equiv 
    M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 Pi M=>Pi EQV
    <- inner-efxmap`size-total SZ-M1
    <- inner-efxmap`size-total SZ-M2
    <- inner-efxmap`disjoint-join-implies-equiv/L
      _ SZ-M1 _ SZ-M2 M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 Pi M=>Pi EQV.

%worlds (fracvar) (inner-efxmap`disjoint-join-implies-equiv _ _ _ _ _ _ _).
%total  {} (inner-efxmap`disjoint-join-implies-equiv _ _ _ _ _ _ _).


%theorem efxmap`deep-disjoint-join-implies-equiv/L :
    forall* {CM} {PM} {B} {Pi1} {Pi2} {XM1} {XM2} {XM} {P}
    forall  {N1} {SZ1: efxmap`size XM1 N1}
            {N2} {SZ2: efxmap`size XM2 N2}
            {XM1^XM2: efxmap`deep-disjoint XM1 XM2}
            {XM1UXM2=XM: efxmap`join XM1 XM2 XM}
            {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
            {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    exists  {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi} 
            {EQV: {z} equiv ((Pi1 z) , (Pi2 z)) (Pi z)}
    true.

%worlds (fracvar) 
(efxmap`deep-disjoint-join-implies-equiv/L _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {N1 N2}
(efxmap`deep-disjoint-join-implies-equiv/L N1 _ N2 _ _ _ _ _ _ _ _).


%theorem efxmap`deep-disjoint-join-implies-equiv :
    forall* {CM} {PM} {B} {Pi1} {Pi2} {XM1} {XM2} {XM} {P}
    forall  {XM1^XM2: efxmap`deep-disjoint XM1 XM2}
            {XM1UXM2=XM: efxmap`join XM1 XM2 XM}
            {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
            {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    exists  {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi} 
            {EQV: {z} equiv ((Pi1 z) , (Pi2 z)) (Pi z)}
    true.

- : efxmap`deep-disjoint-join-implies-equiv 
    XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 Pi XM=>Pi EQV
    <- efxmap`size-total SZ1
    <- efxmap`size-total SZ2
    <- efxmap`deep-disjoint-join-implies-equiv/L 
      _ SZ1 _ SZ2 XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 Pi XM=>Pi EQV.

%worlds (fracvar) (efxmap`deep-disjoint-join-implies-equiv _ _ _ _ _ _ _).
%total  {} (efxmap`deep-disjoint-join-implies-equiv _ _ _ _ _ _ _).


%theorem efxmap`deep-disjoint-join-implies-equiv* :
    forall* {CM} {PM} {B} {Pi1} {Pi2} {Pi} {XM1} {XM2} {XM} {P}
    forall  {XM1^XM2: efxmap`deep-disjoint XM1 XM2}
            {XM1UXM2=XM: efxmap`join XM1 XM2 XM}
            {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
            {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
            {XM=>Pi: efxmap2perm P CM PM B XM Pi} 
    exists  {EQV: {z} equiv ((Pi1 z) , (Pi2 z)) (Pi z)}
    true.

- : efxmap`deep-disjoint-join-implies-equiv*
    XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 XM=>Pi 
    ([f] equiv/transitive (EQV1 f) (EQV2 f))
    <- efxmap`deep-disjoint-join-implies-equiv
    XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 _ XM=>Pi' EQV1
    <- efxmap2perm-implies-equiv XM=>Pi' XM=>Pi
      bool`eq/ clsmap`eq/ predmap`eq/ cxt`eq/ efxmap`eq/ EQV2.

%worlds (fracvar) (efxmap`deep-disjoint-join-implies-equiv* _ _ _ _ _ _).
%total  {} (efxmap`deep-disjoint-join-implies-equiv* _ _ _ _ _ _).


efxmap`leq-partition
  : efxmap`leq XM1 XM
    -> efxmap`domain XM1 S
    -> {XM2} {XM3} efxmap`deep-disjoint XM2 XM3
    -> efxmap`join XM2 XM3 XM
    -> efxmap`domain XM2 S
    -> type.

%mode efxmap`leq-partition +LE +DM1 -XM2 -XM3 -DJ -J -DM2.

%worlds () (efxmap`leq-partition _ _ _ _ _ _ _).
%trustme %total { } (efxmap`leq-partition _ _ _ _ _ _ _).

%name map M.