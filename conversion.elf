%%% converting *map to permission


% =========================================================================
% ============================ Definitions ================================
% =========================================================================

%abbrev nested-perm : object -> permission =
    [r] (unitperm (nonlinear (nested (allperm r) null all))).

%abbrev half = (fraction/ (frac z one)).


% ============================ set2facts ==================================
% Convert a set of object locations to a disjunction of objequal
% facts. Used in output.
% =========================================================================

set2facts : object -> set -> formula -> type.

set2facts/0 : set2facts _ set/0 f.

set2facts/U : set2facts O S (disj (objequal O (object/ N)) G)
              <- set`not-member S' N
              <- set`add S' N S
              <- set2facts O S' G.

% =========================================================================


% ============================ set2perm ==================================
% Convert a set of object locations to a set of whole permissions for
% the object that the locations refer to.
% =========================================================================

set2perm : set -> permission -> type.

set2perm/0 : set2perm set/0 empty.

set2perm/U : set2perm S (unitperm (basic (object/ N) all null) , Pi)
             <- set`not-member S' N
             <- set`add S' N S
             <- set2perm S' Pi.

% =========================================================================


% ============================ cxt2perm ===================================
% Convert the explicit context to permissions, which
% consists of non-null information, class predicate, and,
% for shared the nesting facts, for each parameter.
% Notice that, unique has the same permission as borrowed
% parameter. We use a separate procedure to generate the
% encumbered permission for them. So, the cxt should only
% contain borrowed and shared types.
% =========================================================================

cxt2perm : clsmap -> predmap -> cxt -> permission -> type.

cxt2perm/nil : cxt2perm _ _ cxt/nil empty.

cxt2perm/cons : cxt2perm CM PM (cxt/cons O T B) ((PF O) , Pi2)
                <- ty2perm PM T PF
                <- cxt2perm CM PM B Pi2.

% ============================ end of cxt2perm ============================


% ============================ apply-efx ==================================
% Apply given effect to the input permission, and convert
% it to another permission.
% =========================================================================

apply-efx : bool -> efx -> permission -> permission -> type.

apply-efx/read : apply-efx _ efx/read Pi (scale half Pi).

apply-efx/write : apply-efx _ efx/write Pi Pi.

apply-efx/consume/true : apply-efx true efx/consume Pi Pi.

apply-efx/consume/false : apply-efx false efx/consume Pi empty.

% ============================ end of apply-efx ===========================


% ============================ efx2frac ===================================
% Convert a efx to a fraction, which is either half or one. 
% This function is partial, and only applies to read and write.
% =========================================================================

efx2frac : efx -> fraction -> type.

efx2frac/read : efx2frac efx/read half.

efx2frac/write : efx2frac efx/write (fraction/ one).

% =========================================================================


% ======================= shared-efx2perm =================================
% Convert "shared-efx" to permissions. "shared-efx" is used to
% record effects on shared.
% =========================================================================

shared-efx2perm : shared-efx -> permission -> type.

shared-efx2perm/none : shared-efx2perm shared-efx/none empty.

shared-efx2perm/read : shared-efx2perm shared-efx/read Pi
                       <- apply-efx true efx/read (allperm null) Pi.

shared-efx2perm/write : shared-efx2perm shared-efx/write Pi
                        <- apply-efx true efx/write (allperm null) Pi.

% =========================================================================


% ======================= shared-efx2efx ==================================
% We need to convert shared-efx to efx so as to get a fraction.
% =========================================================================

shared-efx2efx : shared-efx -> efx -> type.

shared-efx2efx/read : shared-efx2efx shared-efx/read efx/read.

shared-efx2efx/write : shared-efx2efx shared-efx/write efx/write.

% =========================================================================


% ============================ efxmap2perm ================================
% Convert a efxmap to permissions. Each entry ((O, F), X) in
% the efxmap will be converted to a packed field permission with
% the effect X been applied to it.
% =========================================================================

efxmap2perm : bool -> clsmap -> predmap -> cxt -> efxmap -> permission -> type.

inner-efxmap2perm : bool -> object -> fldmap -> predmap ->
  inner-efxmap -> permission -> type.

inner-efxmap2perm/0
  : inner-efxmap2perm _ _ _ _ inner-efxmap/0 empty.

inner-efxmap2perm/U
  : inner-efxmap2perm P O FM PM M (Pi1 , Pi2)
    <- inner-efxmap2perm P O FM PM M' Pi2
    <- apply-efx P X (unitperm (precise-exists O F PF)) Pi1
    <- ty2perm PM T PF
    <- fldmap`lookup FM F T
    <- inner-efxmap`update M' F X M
    <- inner-efxmap`fresh M' F.

efxmap2perm/0 : efxmap2perm _ _ _ _ efxmap/0 empty.

efxmap2perm/U
  : efxmap2perm P CM PM B XM (Pi1 , Pi2)
    <- efxmap2perm P CM PM B XM' Pi2
    <- inner-efxmap2perm P (object/ N) FM PM M Pi1
    <- clsmap`lookup CM C FM
    <- cxt`lookup B (object/ N) (ty/ _ _ C)
    <- efxmap`update XM' N M XM
    <- efxmap`fresh XM' N.

% =========================================================================


% ====================== effects2input =================================
% Convert effects to input permissions. This is simply a wrapper on
% efxmap2perm and shared-efx2perm, as the definition of effects.
% ======================================================================

effects2input : clsmap -> predmap -> cxt -> effects -> permission -> type.

effects2input/
  : effects2input CM PM B (effects/ XM SX S) ((Pi1 , Pi2) , Pi3 , Pi4)
    <- cxt2perm CM PM B Pi1
    <- set2perm S Pi2
    <- efxmap2perm true CM PM B XM Pi3
    <- shared-efx2perm SX Pi4.

% =========================================================================


% ============================ efxmap-minimum-efx =========================
% compute minimum effects for this efxmap, start with efx/read.
% =========================================================================

minimum-efx : efx -> efx -> efx -> type.

minimum-efx/= : minimum-efx X X X.

minimum-efx/< : minimum-efx X1 X2 X1 <- efx`lt X1 X2.

minimum-efx/> : minimum-efx X1 X2 X2 <- efx`lt X2 X1.


efxmap-minimum-efx* : efx -> efxmap -> efx -> type.

efxmap-minimum-efx-helper : efx -> inner-efxmap -> efx -> type.

efxmap-minimum-efx-helper/0 : efxmap-minimum-efx-helper X inner-efxmap/0 X.

efxmap-minimum-efx-helper/U : efxmap-minimum-efx-helper X1 M X4
                       <- inner-efxmap`fresh M' F
                       <- inner-efxmap`update M' F X2 M
                       <- minimum-efx X1 X2 X3
                       <- efxmap-minimum-efx-helper X3 M' X4.

efxmap-minimum-efx/0 : efxmap-minimum-efx* X efxmap/0 X.

efxmap-minimum-efx/U : efxmap-minimum-efx* X1 XM X3
                <- efxmap`fresh XM' N
                <- efxmap`update XM' N M XM
                <- efxmap-minimum-efx-helper X1 M X2
                <- efxmap-minimum-efx* X2 XM' X3.


%abbrev efxmap-minimum-efx = [M][X] efxmap-minimum-efx* efx/read M X.

% =========================================================================


% ===================== effects2output ===================================
% Convert effects to output (defined in permission-type/environment.elf).
% The format of output varies depending on the resulting reftype. The
% cases for unique reftype are basically combinations on size of set and
% tgtmap. We need special case when tgtmap size is zero since
%   Pi, Pi --|- empty is obviously unsound: Pi should come from at least
% one field permission. 
% 
% Another special case is when set and tgtmap are both empty, and 
% the unique permission is not from shared. This is the case when we 
% have method calls (including constructor call) that return fresh
% locations alone with permissions. These locations are local, and unless
% they are later bound to a let-expression, they will only be used once.
% For let-expression, we use substitution to check effects.
%
% Note:
% 06-16-13: efxmap may contain inner-efxmap/0 as value. Do we need to
% remove them first? Maybe not, since tgtmap in reftype should definitely
% be well-formed.
% 08-01-13: previous definition is wrong: it always generate scaled perm
% for unique/0t, unique/+f and unique/+t. However, in these two instances
% we need to consider all encumbered permissions and generate the "best"
% permission. In other words, if all encumbered permissions are not
% fractional, then we shouldn't apply scale.
% ========================================================================


effects2output : clsmap -> predmap -> cxt -> reftype -> effects -> expr-output -> type.

effects2output/shared
  : effects2output CM PM B
    (reftype/ NN C targets/shared) (effects/ XM SX S)
    (output/exists [r]
      (output/expr r % "shared" don't need scaling
        (combine Pi1
          (combine (PF r) (combine Pi2 Pi3)))))
    <- cxt2perm CM PM B Pi1
    <- efxmap2perm false CM PM B XM Pi2
    <- shared-efx2perm SX Pi3
    <- ty2perm PM (ty/ NN annot/shared C) PF.

effects2output/unique/0
  : effects2output CM PM B
    (reftype/ NN C (targets/unique S GM SB)) (effects/ XM SX CS)
    (output/exists [r]
      (output/expr r
        (combine Pi1 
          (combine (PF r) (combine Pi2 Pi3)))))
    <- set`size S z
    <- tgtmap`size GM z
    <- cxt2perm CM PM B Pi1
    <- efxmap2perm false CM PM B XM Pi2
    <- shared-efx2perm SX Pi3
    <- ty2perm PM (ty/ NN annot/unique C) PF.

effects2output/unique/0f
  : effects2output CM PM B
    (reftype/ NN C (targets/unique S GM false)) (effects/ XM SX CS)
    (output/exists [r]
      (output/expr r
        (combine Pi1
          (combine (PF r)
            (combine (unitperm (nonlinear (GF r)))
              (combine Pi2 Pi3))))))
    <- set`size S (s _)
    <- tgtmap`size GM z
    <- cxt2perm CM PM B Pi1
    <- ({r} set2facts r S (GF r))
    <- efxmap2perm false CM PM B XM Pi2
    <- shared-efx2perm SX Pi3
    <- ty2perm PM (ty/ NN annot/borrow C) PF.

% SX should either be read or write

effects2output/unique/0t
  : effects2output CM PM B
    (reftype/ NN C (targets/unique S GM true)) (effects/ XM SX CS)
    (output/exists [o]
      (output/exists [r]
        (output/expr o
          (combine Pi1
            (combine (unitperm (nonlinear (disj (objequal o r) (GF o))))
              (combine (scale Q (PF r))
                (combine (unitperm (encumbered (scale Q (PF r)) Pi3))
                  Pi2)))))))
    <- tgtmap`size GM z
    <- cxt2perm CM PM B Pi1
    <- ({r} set2facts r S (GF r))
    <- efxmap2perm false CM PM B XM Pi2
    <- shared-efx2perm SX Pi3
    <- shared-efx2efx SX X
    <- efx2frac X Q
    <- ty2perm PM (ty/ NN annot/unique C) PF.

effects2output/unique/+f
  : effects2output CM PM B
    (reftype/ NN C (targets/unique S GM false)) (effects/ XM SX CS)
    (output/exists [o]
      (output/exists [r]
        (output/expr o
          (combine Pi1
            (combine (unitperm (nonlinear (disj (objequal o r) (GF o))))
              (combine (scale Q (PF r))
                (combine (unitperm (encumbered (scale Q (PF r)) Pi3))
                  (combine Pi2 Pi4))))))))
    <- tgtmap`size GM (s _)
    <- cxt2perm CM PM B Pi1
    <- ({r} set2facts r S (GF r))
    <- select-tgtmap XM GM XM1 XM2
    <- efxmap2perm false CM PM B XM1 Pi2
    <- efxmap2perm false CM PM B XM2 Pi3
    <- efxmap-minimum-efx XM2 X
    <- efx2frac X Q
    <- shared-efx2perm SX Pi4
    <- ty2perm PM (ty/ NN annot/unique C) PF.

effects2output/unique/+t
  : effects2output CM PM B
    (reftype/ NN C (targets/unique S GM true)) (effects/ XM SX CS)
    (output/exists [o]
      (output/exists [r]
        (output/expr o
          (combine Pi1
            (combine (unitperm (nonlinear (disj (objequal o r) (GF o))))
              (combine (scale Q (PF r))
                (combine
                  (unitperm (encumbered (scale Q (PF r)) (combine Pi3 Pi4)))
                  Pi2)))))))
    <- tgtmap`size GM (s _)
    <- cxt2perm CM PM B Pi1
    <- ({r} set2facts r S (GF r))
    <- select-tgtmap XM GM XM1 XM2
    <- efxmap2perm false CM PM B XM1 Pi2
    <- efxmap2perm false CM PM B XM2 Pi3
    <- efxmap-minimum-efx XM2 X1
    <- shared-efx2efx SX X2
    <- minimum-efx X1 X2 X
    <- efx2frac X Q
    <- shared-efx2perm SX Pi4.

% =========================================================================


% ============================ methty2proctype ============================
% Convert methty to proctype.
% =========================================================================

% The first set of permissions are those from read and write effects,
% the second set of permissions are those from consumed effects.

methty2proctype* : predmap -> permission -> permission -> methty -> proctype -> type.

methty2proctype/base
  : methty2proctype* PM Pi Pic (methty/base T SX)
    (proctype/base (combine Pi (combine Pic Pis))
      (output/exists [ret]
        (output/expr ret (combine (PF ret) (combine Pi Pis)))))
    <- ty2perm PM T PF
    <- shared-efx2perm MX Pis.

methty2proctype/args/unique
  : methty2proctype* PM Pi Pic
    (methty/arg (ty/ NN annot/unique C) set/0 set/0 MT) (proctype/arg PTF)
    <- ty2perm PM (ty/ NN annot/unique C) PF
    <- ({x} methty2proctype* PM Pi (Pic , (PF x)) MT (PTF x)).

methty2proctype/args/borrow
  : methty2proctype* PM Pi1 Pic
    (methty/arg (ty/ NN annot/borrow C) Rs Ws MT) (proctype/arg PTF)
    <- set2inner-efxmap Rs efx/read R
    <- set2inner-efxmap Ws efx/write W
    <- inner-efxmap`join R W M
    <- ty2perm PM (ty/ NN annot/borrow C) PF
    <- ({x} inner-efxmap2perm true x FM PM M (Pi2 x))
    <- ({x} methty2proctype* PM
         (Pi1 , (Pi2 x)) (Pic , PF x) MT (PTF x)).

methty2proctype/args/shared
  : methty2proctype* PM Pi Pic
    (methty/arg (ty/ NN annot/shared C) set/0 set/0 MT) (proctype/arg PTF)
    <- ty2perm PM (ty/ NN annot/shared C) PF
    <- ({x} methty2proctype* PM Pi Pic MT (PTF x)).

%abbrev methty2proctype = [PM][MT][PT] methty2proctype* PM empty empty MT PT.

% =========================================================================


% ========================= consty2proctype ===============================
% Convert consty (constructor type) to proctype with a hole.
% =========================================================================

consty2proctype* : predmap -> fldmap -> permission
    -> permission -> methty -> (object -> proctype) -> type.

%abbrev obj-notnull : object -> permission
    = ([r] unitperm (nonlinear (neg (objequal r (object/ z))))).

consty2proctype/base
  : consty2proctype* PM FM Pi Pic
    (methty/base (ty/ nn/yes annot/unique C) MX)
    ([t] (proctype/base
           (combine (obj-notnull t)
             (combine (OS t) (combine Pi (combine Pic Pis))))
           (output/exists [ret]
             (output/expr ret
               (combine (PF ret) (combine Pi Pis))))))
    <- ty2perm PM (ty/ nn/yes annot/unique C) PF
    <- fldmap`domain FM S
    <- ({t} allocFields t S (OS t)).

consty2proctype/args/unique
  : consty2proctype* PM FM Pi Pic
    (methty/arg (ty/ NN annot/unique C) set/0 set/0 CT) ([t] proctype/arg (PTF t))
    <- ty2perm PM (ty/ NN annot/unique C) PF
    <- ({x} consty2proctype* PM FM Pi (Pic , PF x) CT ([t] (PTF t x))).

consty2proctype/args/borrow
  : consty2proctype* PM FM Pi1 Pic
    (methty/arg (ty/ NN annot/borrow C) Rs Ws CT) ([t] proctype/arg (CTF t))
    <- set2inner-efxmap Rs efx/read R
    <- set2inner-efxmap Ws efx/write W
    <- inner-efxmap`join R W M
    <- ty2perm PM (ty/ NN annot/borrow C) PF
    <- ({x} inner-efxmap2perm true x FM PM M (Pi2 x))
    <- ty2perm PM (ty/ NN annot/unique C) PF
    <- ({x} consty2proctype* PM FM (Pi1 , (Pi2 x)) (Pic , PF x) CT ([t] (CTF t x))).

consty2proctype/args/shared
  : consty2proctype* PM FM Pi Pic
    (methty/arg (ty/ NN annot/shared C) set/0 set/0 CT) ([t] proctype/arg (CTF t))
    <- ty2perm PM (ty/ NN annot/shared C) PF
    <- ({x} consty2proctype* PM FM Pi Pic CT (CTF x)).

%abbrev consty2proctype = [PM][FM][CT][PTF] consty2proctype* PM FM empty empty CT PTF.

% =========================================================================


% ====================== methmap2progtype =================================
% Convert methmap to progtype, calls methty2proctype and consty2proctype.
% =========================================================================

methmap2progtype : clsmap -> predmap -> methmap -> progtype -> type.

methmap2progtype/0 : methmap2progtype _ _ methmap`map/0 progtype`map/0.

methmap2progtype/U/c
  : methmap2progtype CM PM MM W
    <- methmap`fresh MMP N
    <- methmap`update MMP N (methty/arg (ty/ nn/yes annot/unique C) set/0 set/0 CT) MM
    <- clsmap`lookup CM N FM
    <- consty2proctype PM FM CT PTF
    <- methmap2progtype CM PM MMP WP
    <- progtype`update WP N (proctype/arg PTF) W.

methmap2progtype/U/m
  : methmap2progtype CM PM MM W
    <- methmap`fresh MMP N
    <- methmap`update MMP N MT MM
    <- methty2proctype PM MT PT
    <- methmap2progtype CM PM MMP WP
    <- progtype`update WP N PT W.

% =========================================================================


% ============================ env2progtype ===============================
% Convert a methmap to progtype, calling methmap2progtype.
% =========================================================================

env2progtype : clsmap -> methmap -> progtype -> type.

env2progtype/
  : env2progtype CM MM W
    <- clsmap2predmap CM PM
    <- methmap2progtype CM PM MM W.

% =========================================================================



% =========================================================================
% ============================ Theorems ===================================
% =========================================================================


% =========================================================================
% First, extra permission-related theorems
% =========================================================================


%theorem permission`eq-implies-equiv
  : forall* {Pi1} {Pi2}
    forall {EQ: permission`eq Pi1 Pi2}
    exists {EQV: equiv Pi1 Pi2}
    true.

- : permission`eq-implies-equiv permission`eq/ equiv/reflexive.

%worlds (objvar | fracvar) (permission`eq-implies-equiv _ _).
%total {} (permission`eq-implies-equiv _ _).


%theorem permission`combine-preserves-eq
  : forall* {Pi1} {Pi2} {Pi3} {Pi4}
    forall {EQ: permission`eq Pi1 Pi3}
    {EQ: permission`eq Pi2 Pi4}
    exists {EQ: permission`eq (Pi1 , Pi2) (Pi3 , Pi4)}
    true.

- : permission`combine-preserves-eq
    permission`eq/ permission`eq/ permission`eq/.

%worlds (objvar) (permission`combine-preserves-eq _ _ _).
%total {} (permission`combine-preserves-eq _ _ _).


% Need "scale" because there is no "equiv/scale"
%theorem permission`precise-exists-respects-eq
  : forall* {Pi1} {Pi2} {F} {O}
    forall {E: {x} permission`eq (Pi1 x) (Pi2 x)}
    exists {EQV: permission`eq
                 (unitperm (precise-exists O F Pi1))
                 (unitperm (precise-exists O F Pi2))}
    true.

- : permission`precise-exists-respects-eq
    ([_] permission`eq/) (permission`eq/).

%worlds (objvar) (permission`precise-exists-respects-eq _ _).
%total {} (permission`precise-exists-respects-eq _ _).


%theorem permission`implies-respects-eq-left
  : forall* {P1} {P2} {P}
    forall {EQ: permission`eq P1 P2}
    {IMP: implies P1 P}
    exists {IMP: implies P2 P}
    true.

- : permission`implies-respects-eq-left permission`eq/ IMP IMP.

%worlds () (permission`implies-respects-eq-left _ _ _).
%total {} (permission`implies-respects-eq-left _ _ _).


%theorem permission`implies-respects-eq-right
  : forall* {P1} {P2} {P}
    forall {EQ: permission`eq P1 P2}
    {IMP: implies P P1}
    exists {IMP: implies P P2}
    true.

- : permission`implies-respects-eq-right permission`eq/ IMP IMP.

%worlds () (permission`implies-respects-eq-right _ _ _).
%total {} (permission`implies-respects-eq-right _ _ _).

% =========================================================================


% ============================ false-implies-XX ===========================
% =========================================================================

%theorem false-implies-set2facts
  : forall* {O} {S} {G}
    forall {V:void}
    exists {S=>G: set2facts O S G}
    true.

%worlds () (false-implies-set2facts _ _).
%total {} (false-implies-set2facts _ _).


%theorem false-implies-apply-efx
  : forall* {B} {X} {Pi} {Pi2}
    forall {V:void}
    exists {AP: apply-efx B X Pi Pi2}
    true.

%worlds () (false-implies-apply-efx _ _).
%total {} (false-implies-apply-efx _ _).

%theorem false-implies-inner-efxmap2perm
  : forall* {P} {O} {FM} {PM} {M} {Pi}
    forall {V:void}
    exists {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
    true.

%worlds (fracvar) (false-implies-inner-efxmap2perm _ _).
%total {} (false-implies-inner-efxmap2perm _ _).


%theorem false-implies-efxmap2perm
  : forall* {CM} {PM} {B} {XM} {P} {Pi}
    forall  {V: void}
    exists  {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    true.

%worlds (fracvar) (false-implies-efxmap2perm _ _).
%total {} (false-implies-efxmap2perm _ _).

% ==================================================================



% ================== totality (constructive) theorems =====================
% =========================================================================

%theorem set2facts-total* : forall {O}{S} exists {G} {S=>G: set2facts O S G} true.

%theorem set2facts-total/L
  : forall* {S} {O}
    forall {N} {Z: set`size S N}
    exists {G} {S=>G: set2facts O S G}
    true.

- : set2facts-total/L z _ f set2facts/0.

- : set2facts-total/L (s N) Z _ (set2facts/U SP=>GP A F)
    <- set`lookup-implies-not-member-update (set`lookup/= nat`eq/) SP F A
    <- set`not-member-add-increases-size-converse Z F A Z'
    <- set2facts-total/L N Z' _ SP=>GP.

%worlds (objvar) (set2facts-total/L _ _ _ _).
%total (N) (set2facts-total/L N _ _ _).

- : set2facts-total* _ _ G S=>G
    <- set`size-total Z
    <- set2facts-total/L _ Z G S=>G.

%worlds (objvar) (set2facts-total* _ _ _ _).
%total {} (set2facts-total* _ _ _ _).

%abbrev set2facts-total = set2facts-total* _ _ _.


%theorem set2perm-total* : forall {S} exists {Pi} {S=>Pi: set2perm S Pi} true.
   
%worlds () (set2perm-total* _ _ _).
%trustme %total {} (set2perm-total* _ _ _).

%abbrev set2perm-total = set2perm-total* _ _.


% cxt needs to be consistent with clsmap

%theorem clsmap-cxt-implies-cxt2perm
  : forall* {CM} {PM} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    exists {Pi:permission} {B=>Pi: cxt2perm CM PM B Pi}
    true.

- : clsmap-cxt-implies-cxt2perm _ _ clsmap-cxt/nil _ cxt2perm/nil.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/cons/b CM-B (clsmap-ty/notnull L))
    _ (cxt2perm/cons B2P T2PF)
    <- clsmap-lookup-implies-ty2perm CM2PM L _ T2PF
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B2P.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/cons/s CM-B (clsmap-ty/notnull L))
    _ (cxt2perm/cons B2P T2PF)
    <- clsmap-lookup-implies-ty2perm CM2PM L _ T2PF
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B2P.

%worlds (objvar) (clsmap-cxt-implies-cxt2perm _ _ _ _ _).
%total (CM-B) (clsmap-cxt-implies-cxt2perm _ _ CM-B _ _).


%theorem apply-efx-total*
  : forall {P} {X} {Pi}
    exists {PF} {AP: apply-efx P X Pi PF}
    true.

- : apply-efx-total* _ efx/read _ _ apply-efx/read.

- : apply-efx-total* _ efx/write _ _ apply-efx/write.

- : apply-efx-total* true efx/consume Pi Pi apply-efx/consume/true.

- : apply-efx-total* false efx/consume Pi empty apply-efx/consume/false.

%worlds (fracvar | objvar) (apply-efx-total* _ _ _ _ _).
%total {} (apply-efx-total* _ _ _ _ _).

%abbrev apply-efx-total = apply-efx-total* _ _ _ _.


%theorem shared-efx2perm-total*
  : forall {MX}
    exists {Pi} {MX=>Pi: shared-efx2perm MX Pi}
    true.

- : shared-efx2perm-total* shared-efx/none _ shared-efx2perm/none.

- : shared-efx2perm-total* shared-efx/read _ (shared-efx2perm/read AP)
    <- apply-efx-total AP.

- : shared-efx2perm-total* shared-efx/write _ (shared-efx2perm/write AP)
    <- apply-efx-total AP.

%worlds (objvar) (shared-efx2perm-total* _ _ _).
%total {} (shared-efx2perm-total* _ _ _).

%abbrev shared-efx2perm-total = shared-efx2perm-total* _ _.


%theorem domain-leq-implies-inner-efxmap2perm/L
  : forall* {CM} {PM} {C} {FM} {M} {P} {O} {FS} {MS}
    forall {N} {SZ: inner-efxmap`size M N}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {DM-FM: fldmap`domain FM FS}
    {DM-M: inner-efxmap`domain M MS}
    {LE: set`leq MS FS}
    exists {Pi} {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
    true.

- : domain-leq-implies-inner-efxmap2perm/L
    z _ _ _ _ _ _ _ empty inner-efxmap2perm/0.

- : domain-leq-implies-inner-efxmap2perm/L (s N) SZ
    CM-CM CM2PM CM->C=FM DM-FM=FS DM-M=MS MS<=FS _
    (inner-efxmap2perm/U N!<MP MP+F+X=M FM->F=T T=>PF X+PF=>Pi1 MP=>Pi2)
    <- inner-efxmap`lookup-implies-fresh-update
      (inner-efxmap`lookup/= nat`eq/) MP N!<MP MP+F+X=M
    <- lookup-implies-clsmap-fldmap CM-CM CM->C=FM CM-FM
    <- inner-efxmap`domain-preserves-lookup
      (inner-efxmap`lookup/= nat`eq/) DM-M=MS N-in-MS
    <- set`member-respects-leq N-in-MS MS<=FS N-in-FS
    <- fldmap`domain-preserves-lookup-converse N-in-FS DM-FM=FS T FM->F=T
    <- lookup-implies-clsmap-ty CM-FM FM->F=T CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T=>PF
    <- apply-efx-total X+PF=>Pi1
    <- inner-efxmap`fresh-update-implies-leq N!<MP MP+F+X=M MP<=M
    <- inner-efxmap`domain-total DM-MP=MPS
    <- inner-efxmap`domain-preserves-leq* MP<=M DM-MP=MPS DM-M=MS MPS<=MS
    <- set`leq-transitive MPS<=MS MS<=FS MPS<=FS
    <- inner-efxmap`fresh-update-increases-size-converse SZ N!<MP MP+F+X=M SZP
    <- domain-leq-implies-inner-efxmap2perm/L N SZP
      CM-CM CM2PM CM->C=FM DM-FM=FS DM-MP=MPS MPS<=FS _ MP=>Pi2.

%worlds (fracvar | objvar)
(domain-leq-implies-inner-efxmap2perm/L _ _ _ _ _ _ _ _ _ _).
%total (N) (domain-leq-implies-inner-efxmap2perm/L N _ _ _ _ _ _ _ _ _).


%theorem domain-leq-implies-inner-efxmap2perm
  : forall* {CM} {PM} {C} {FM} {M} {P} {O} {FS} {MS}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {DM-FM: fldmap`domain FM FS}
    {DM-M: inner-efxmap`domain M MS}
    {LE: set`leq MS FS}
    exists {Pi} {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
    true.

- : domain-leq-implies-inner-efxmap2perm
    CM-CM CM2PM CM-L DM-FM DM-M LE _ M=>Pi
    <- inner-efxmap`size-total SZ
    <- domain-leq-implies-inner-efxmap2perm/L
      _ SZ CM-CM CM2PM CM-L DM-FM DM-M LE _ M=>Pi.

%worlds (fracvar | objvar) (domain-leq-implies-inner-efxmap2perm _ _ _ _ _ _ _ _).
%total {} (domain-leq-implies-inner-efxmap2perm _ _ _ _ _ _ _ _).


%theorem clsmap-cxt-efxmap-implies-efxmap2perm
  : forall* {P} {CM} {PM} {B} {XM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B-XM: clsmap-cxt-efxmap CM B XM}
    exists {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    true.

- : clsmap-cxt-efxmap-implies-efxmap2perm _ _ clsmap-cxt-efxmap/0 _ efxmap2perm/0.

- : clsmap-cxt-efxmap-implies-efxmap2perm CM-CM CM2PM
    (clsmap-cxt-efxmap/U B-XM F U BL L DM-FM DM-M LE)
     (Pi1 , Pi2) (efxmap2perm/U F U BL L M2P XM2P)
    <- domain-leq-implies-inner-efxmap2perm
      CM-CM CM2PM L DM-FM DM-M LE Pi1 M2P
    <- clsmap-cxt-efxmap-implies-efxmap2perm CM-CM CM2PM B-XM Pi2 XM2P.

%worlds (fracvar | objvar) (clsmap-cxt-efxmap-implies-efxmap2perm _ _ _ _ _).
%total (T) (clsmap-cxt-efxmap-implies-efxmap2perm _ _ T _ _).


%theorem clsmap-cxt-efxmap-implies-effects2input
  : forall* {CM} {PM} {B} {XM} {MX} {CS}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {B-XM: clsmap-cxt-efxmap CM B XM}
    exists {Pi} {XX=>Pi: effects2input CM PM B (effects/ XM MX CS) Pi}
    true.

- : clsmap-cxt-efxmap-implies-effects2input
    CM-CM CM2PM CM-B B-XM _ (effects2input/ SX=>Pi2 XM=>Pi1 S=>Pi4 B=>Pi3)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>Pi3
    <- set2perm-total S=>Pi4
    <- clsmap-cxt-efxmap-implies-efxmap2perm CM-CM CM2PM B-XM _ XM=>Pi1
    <- shared-efx2perm-total SX=>Pi2.

%worlds () (clsmap-cxt-efxmap-implies-effects2input _ _ _ _ _ _).
%total {} (clsmap-cxt-efxmap-implies-effects2input _ _ _ _ _ _).

% =========================================================================


% =========================== XX-respects-eq theorems =====================
% =========================================================================

%theorem set2facts-respects-eq
  : forall* {S1} {S2} {O1} {O2} {G1} {G2}
    forall {S2G: set2facts O1 S1 G1}
    {E: object`eq O1 O2} {E: set`eq S1 S2}
    {E: permission`eq (unitperm (nonlinear G1)) (unitperm (nonlinear G2))}
    exists {S2G2: set2facts O2 S2 G2}
    true.

- : set2facts-respects-eq S2G object`eq/ set`eq/ permission`eq/ S2G.

%worlds (objvar) (set2facts-respects-eq _ _ _ _ _).
%total {} (set2facts-respects-eq _ _ _ _ _).

 
%theorem apply-efx-respects-eq
  : forall* {B1} {B2} {X1} {X2} {P1} {P2} {S1} {S2}
    forall {AP: apply-efx B1 X1 P1 S1}
    {E: bool`eq B1 B2} {E: efx`eq X1 X2}
    {E: permission`eq P1 P2} {E: permission`eq S1 S2}
    exists {AP: apply-efx B2 X2 P2 S2}
    true.

- : apply-efx-respects-eq apply-efx/read bool`eq/
    efx`eq/ permission`eq/ permission`eq/ apply-efx/read.

- : apply-efx-respects-eq apply-efx/write bool`eq/
    efx`eq/ permission`eq/ permission`eq/ apply-efx/write.

- : apply-efx-respects-eq apply-efx/consume/false bool`eq/
    efx`eq/ permission`eq/ permission`eq/ apply-efx/consume/false.

- : apply-efx-respects-eq apply-efx/consume/true bool`eq/
    efx`eq/ permission`eq/ permission`eq/ apply-efx/consume/true.

%worlds (objvar) (apply-efx-respects-eq _ _ _ _ _ _).
%total {} (apply-efx-respects-eq _ _ _ _ _ _).


%theorem inner-efxmap2perm-respects-eq
  : forall* {P1} {P2} {O1} {O2} {FM1} {FM2}
    {PM1} {PM2} {M1} {M2} {Pi1} {Pi2}
    forall {M1=>Pi1: inner-efxmap2perm P1 O1 FM1 PM1 M1 Pi1}
    {E: bool`eq P1 P2} {O: object`eq O1 O2}
    {E: fldmap`eq FM1 FM2} {E: predmap`eq PM1 PM2}
    {E: inner-efxmap`eq M1 M2} {E: permission`eq Pi1 Pi2}
    exists {M2=>Pi2: inner-efxmap2perm P2 O2 FM2 PM2 M2 Pi2}
    true.

- : inner-efxmap2perm-respects-eq M=>Pi bool`eq/ object`eq/ fldmap`eq/
    predmap`eq/ inner-efxmap`eq/ permission`eq/ M=>Pi.

%worlds (fracvar | objvar) (inner-efxmap2perm-respects-eq _ _ _ _ _ _ _ _).
%total {} (inner-efxmap2perm-respects-eq _ _ _ _ _ _ _ _).


%theorem efxmap2perm-respects-eq
  : forall* {CM1} {PM1} {B1} {XM1} {Pi1} {P1}
    {CM2} {PM2} {B2} {XM2} {Pi2} {P2}
    forall  {XM1=>Pi1: efxmap2perm P1 CM1 PM1 B1 XM1 Pi1}
    {E: bool`eq P1 P2} {E: clsmap`eq CM1 CM2} {E: predmap`eq PM1 PM2}
    {E: cxt`eq B1 B2} {E: efxmap`eq XM1 XM2}
    {E: permission`eq Pi1 Pi2}
    exists  {XM2=>Pi2: efxmap2perm P2 CM2 PM2 B2 XM2 Pi2}
    true.

- : efxmap2perm-respects-eq XM=>Pi bool`eq/ clsmap`eq/ predmap`eq/
    cxt`eq/ efxmap`eq/ permission`eq/ XM=>Pi.

%worlds (fracvar | objvar) (efxmap2perm-respects-eq _ _ _ _ _ _ _ _).
%total {} (efxmap2perm-respects-eq _ _ _ _ _ _ _ _).


%theorem effects2output-respects-eq
  : forall* {CM} {PM} {B} {NN} {C} {GS} {XM} {MX}
    {NN1} {C1} {XM1} {GS1} {MX1} {Out} {CS} {CS1}
    forall {XX2O: effects2output CM PM B (reftype/ NN C GS) (effects/ XM MX CS) Out}
    {E: nonnull`eq NN NN1} {E: nat`eq C C1} {E: targets`eq GS GS1}
    {E: efxmap`eq XM XM1} {E: shared-efx`eq MX MX1} {E: set`eq CS CS1}
    exists {XX2O: effects2output CM PM B (reftype/ NN1 C1 GS1) (effects/ XM1 MX1 CS1) Out}
    true.

- : effects2output-respects-eq
    XX nonnull`eq/ nat`eq/ targets`eq/ efxmap`eq/ shared-efx`eq/ set`eq/ XX.
    
%worlds () (effects2output-respects-eq _ _ _ _ _ _ _ _).
%total { } (effects2output-respects-eq _ _ _ _ _ _ _ _).

% =========================================================================


% ============================ XX/U-inversion =============================
% =========================================================================

%theorem set2facts/U-inversion
  : forall* {O} {S} {SP} {G} {N} 
    forall {S=>G: set2facts O S G}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    exists {GP} {SP=>GP: set2facts O SP GP}
    {IMP1: bimplies true G (disj (objequal O (object/ N)) GP)}
    {IMP2: bimplies true (disj (objequal O (object/ N)) GP) G}
    true.

%theorem set2facts/U-inversion/L
  : forall* {O} {S} {SP} {N} {S1} {N1} {G1} {P}
    forall {NM1: set`not-member S1 N1}
    {A1: set`add S1 N1 S}
    {S1=>G1: set2facts O S1 G1}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    {E?: nat`eq? N N1 P}
    exists {GP} {SP=>GP: set2facts O SP GP}
    {IMP1: bimplies true
          (disj (objequal O (object/ N1)) G1)
          (disj (objequal O (object/ N)) GP)}
    {IMP2: bimplies true
           (disj (objequal O (object/ N)) GP)
           (disj (objequal O (object/ N1)) G1)}
    true.

- : set2facts/U-inversion/L F1 U1 S2G1 F2 U2 nat`eq?/yes _ S2G
    (bimplies/reflexive) (bimplies/reflexive)
    <- set`not-member-add-cancels F1 U1 F2 U2 nat`eq/ set`eq/ S1=S2
    <- set2facts-respects-eq S2G1 object`eq/ S1=S2 permission`eq/ S2G.

- : set2facts/U-inversion/L F1 U1 S2G1 F2 U2 (nat`eq?/no N<>N1) _
    (set2facts/U S2G U4 F4)
    (bimplies/neg
      (bimplies/trans
        (bimplies/conj/XX
          (bimplies/reflexive)
          (bimplies/trans
            (bimplies/neg
              (IMP1)
              (bool`ne/TF))
            (bimplies/rem-negneg)))
        (bimplies/trans
          (bimplies/conj-commutative)
          (bimplies/trans
            (bimplies/conj-associative)
            (bimplies/conj/XX
              (bimplies/reflexive)
              (bimplies/trans
                (bimplies/conj-commutative)
                (bimplies/add-negneg))))))
      (bool`ne/FT))
    (bimplies/neg
      (bimplies/trans
        (bimplies/conj/XX
          (bimplies/reflexive)
          (bimplies/rem-negneg))
        (bimplies/trans
          (bimplies/conj-commutative)
          (bimplies/trans
            (bimplies/conj-associative)
            (bimplies/conj/XX
              (bimplies/reflexive)
              (bimplies/trans
                (bimplies/conj-commutative)
                (bimplies/trans
                  (bimplies/add-negneg)
                  (bimplies/neg
                    (IMP2)
                    (bool`ne/TF))))))))
      (bool`ne/FT))
    <- set`add-commutes-converse U2 U1 N<>N1 _ U4 U3
    <- set`add-preserves-not-member-converse F2 U4 F3
    <- set`add-preserves-not-member-converse F1 U3 F4
    <- set2facts/U-inversion S2G1 F3 U3 _ S2G IMP1 IMP2.

- : set2facts/U-inversion (set2facts/U S2G1 U1 F1) F2 U2 _ S2G IMP1 IMP2
    <- nat`eq?-total E?
    <- set2facts/U-inversion/L F1 U1 S2G1 F2 U2 E? _ S2G IMP1 IMP2.

%worlds (objvar) (set2facts/U-inversion _ _ _ _ _ _ _)
(set2facts/U-inversion/L _ _ _ _ _ _ _ _ _ _).
%total (N N1) (set2facts/U-inversion N _ _ _ _ _ _)
(set2facts/U-inversion/L _ _ N1 _ _ _ _ _ _ _).


%theorem inner-efxmap2perm/U-inversion
  : forall* {P} {M} {MP} {O} {FM} {PM} {N} {X} {Pi}
    forall {M2P: inner-efxmap2perm P O FM PM M Pi}
    {FS: inner-efxmap`fresh MP N}
    {U: inner-efxmap`update MP N X M}
    exists {T} {L: fldmap`lookup FM N T}
    {PF} {T2PF: ty2perm PM T PF}
    {Pi1} {AP: apply-efx P X (unitperm (precise-exists O N PF)) Pi1}
    {Pi2} {M2P: inner-efxmap2perm P O FM PM MP Pi2}
    {EQV: equiv (Pi1 , Pi2) Pi}
    true.

%theorem inner-efxmap2perm/U-inversion/L
  : forall* {P} {M} {O} {FM} {PM} {N1} {N2} {T1} {B}
    {X1} {X2} {MP1} {MP2} {PF1} {Pi11} {Pi21}
    forall {FS1: inner-efxmap`fresh MP1 N1}
    {U1: inner-efxmap`update MP1 N1 X1 M}
    {L1: fldmap`lookup FM N1 T1}
    {T2PF1: ty2perm PM T1 PF1}
    {AP1: apply-efx P X1 (unitperm (precise-exists O N1 PF1)) Pi11}
    {M2P1: inner-efxmap2perm P O FM PM MP1 Pi21}
    {FS2: inner-efxmap`fresh MP2 N2}
    {U2: inner-efxmap`update MP2 N2 X2 M}
    {EQ: nat`eq? N2 N1 B}
    exists {T2} {L2: fldmap`lookup FM N2 T2}
    {PF2} {T2PF2: ty2perm PM T2 PF2}
    {Pi12} {AP2: apply-efx P X2 (unitperm (precise-exists O N2 PF2)) Pi12}
    {Pi22} {M2P2: inner-efxmap2perm P O FM PM MP2 Pi22}
    {EQV: equiv (Pi12 , Pi22) (Pi11 , Pi21)}
    true.

- : inner-efxmap2perm/U-inversion/L F1 U1 L1 T2PF1 AP1 M2P1
    F2 U2 nat`eq?/yes _ L1 _ T2PF1 _ AP2 _ M2P2 equiv/reflexive
    <- inner-efxmap`fresh-update-cancels
      F1 U1 F2 U2 nat`eq/ inner-efxmap`eq/ D1=D2 M1=M2
    <- inner-efxmap2perm-respects-eq M2P1 bool`eq/ object`eq/
      fldmap`eq/ predmap`eq/ M1=M2 permission`eq/ M2P2
    <- apply-efx-respects-eq AP1 bool`eq/ D1=D2 permission`eq/
      permission`eq/ AP2.

- : inner-efxmap2perm/U-inversion/L F1 U1 L1 T2PF1 AP1 M2P1
    F2 U2 (nat`eq?/no N2<>N1) _ L2 _ T2PF2 _ AP2 _
    (inner-efxmap2perm/U F4 U4 L1 T2PF1 AP1 M2P2)
    (equiv/transitive (equiv/roll2) (equiv/combine equiv/reflexive EQV2))
    <- inner-efxmap`update-commutes-converse U2 U1 N2<>N1 _ U4 U3
    <- inner-efxmap`update-preserves-fresh-converse F2 U4 F3
    <- inner-efxmap`update-preserves-fresh-converse F1 U3 F4
    <- inner-efxmap2perm/U-inversion M2P1 F3 U3 _ L2 _ T2PF2 _ AP2 _ M2P2 EQV2.

- : inner-efxmap2perm/U-inversion
    (inner-efxmap2perm/U F1 U1 L1 T2PF1 AP1 M2P1)
    F2 U2 _ L2 _ T2PF2 _ AP2 _ M2P2 EQV
    <- nat`eq?-total E?
    <- inner-efxmap2perm/U-inversion/L
      F1 U1 L1 T2PF1 AP1 M2P1 F2 U2 E? _ L2 _ T2PF2 _ AP2 _ M2P2 EQV.

%worlds (objvar)
(inner-efxmap2perm/U-inversion _ _ _ _ _ _ _ _ _ _ _ _)
(inner-efxmap2perm/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A B)
(inner-efxmap2perm/U-inversion A _ _ _ _ _ _ _ _ _ _ _)
(inner-efxmap2perm/U-inversion/L _ _ _ _ _ B _ _ _ _ _ _ _ _ _ _ _ _).


%theorem efxmap2perm/U-inversion
  : forall* {P} {M} {MP} {CM} {PM} {N} {X} {Pi} {B}
    forall {M2P: efxmap2perm P CM PM B M Pi}
    {FS: efxmap`fresh MP N}
    {U: efxmap`update MP N X M}
    exists {NN} {A} {C} {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {FM} {CML: clsmap`lookup CM C FM}
    {Pi1} {X2P: inner-efxmap2perm P (object/ N) FM PM X Pi1}
    {Pi2} {M2P: efxmap2perm P CM PM B MP Pi2}
    {EQV: equiv (Pi1 , Pi2) Pi}
    true.

%theorem efxmap2perm/U-inversion/L
  : forall* {P} {BP} {M} {CM} {PM} {N1} {N} {B} {X1} {X}
    {MP1} {MP} {Pi11} {Pi21} {NN1} {A1} {C1} {FM1}
    forall {FS1: efxmap`fresh MP1 N1}
    {U1: efxmap`update MP1 N1 X1 M}
    {BL: cxt`lookup B (object/ N1) (ty/ NN1 A1 C1)}
    {CML: clsmap`lookup CM C1 FM1}
    {X2P: inner-efxmap2perm P (object/ N1) FM1 PM X1 Pi11}
    {M2P: efxmap2perm P CM PM B MP1 Pi21}
    {FS2: efxmap`fresh MP N}
    {U2: efxmap`update MP N X M}
    {EQ: nat`eq? N N1 BP}
    exists {NN} {A} {C} {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {FM} {CML: clsmap`lookup CM C FM}
    {Pi1} {X2P: inner-efxmap2perm P (object/ N) FM PM X Pi1}
    {Pi2} {M2P: efxmap2perm P CM PM B MP Pi2}
    {EQV: equiv (Pi1 , Pi2) (Pi11 , Pi21)}
    true.

- : efxmap2perm/U-inversion/L F1 U1 BL1 CML1 X2P1 M2P1 F2 U2 nat`eq?/yes
    _ _ _ BL1 _ CML1 _ X2P2 _ M2P2 equiv/reflexive
    <- efxmap`fresh-update-cancels
      F1 U1 F2 U2 nat`eq/ efxmap`eq/ X1=X2 M1=M2
    <- efxmap2perm-respects-eq M2P1 bool`eq/ clsmap`eq/
      predmap`eq/ cxt`eq/ M1=M2 permission`eq/ M2P2
    <- inner-efxmap2perm-respects-eq X2P1 bool`eq/ object`eq/
      fldmap`eq/ predmap`eq/ X1=X2 permission`eq/ X2P2.

- : efxmap2perm/U-inversion/L F1 U1 BL1 CML1 X2P1 M2P1 F2 U2 (nat`eq?/no N<>N1)
    _ _ _ BL2 _ CML2 _ X2P2 _
    (efxmap2perm/U F4 U4 BL1 CML1 X2P1 M2P2)
     (equiv/transitive (equiv/roll2) (equiv/combine equiv/reflexive EQV2))
    <- efxmap`update-commutes-converse U2 U1 N<>N1 _ U4 U3
    <- efxmap`update-preserves-fresh-converse F2 U4 F3
    <- efxmap`update-preserves-fresh-converse F1 U3 F4
    <- efxmap2perm/U-inversion M2P1 F3 U3 _ _ _ BL2 _ CML2 _ X2P2 _ M2P2 EQV2.

- : efxmap2perm/U-inversion
    (efxmap2perm/U F1 U1 BL1 CML1 X2P1 M2P1)
    F2 U2 _ _ _ BL2 _ CML2 _ X2P2 _ M2P2 EQV
    <- nat`eq?-total E?
    <- efxmap2perm/U-inversion/L
      F1 U1 BL1 CML1 X2P1 M2P1 F2 U2 E? _ _ _ BL2 _ CML2 _ X2P2 _ M2P2 EQV.

%worlds (objvar)
(efxmap2perm/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(efxmap2perm/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A B)
(efxmap2perm/U-inversion A _ _ _ _ _ _ _ _ _ _ _ _ _)
(efxmap2perm/U-inversion/L _ _ _ _ _ B _ _ _ _ _ _ _ _ _ _ _ _ _ _).

% =========================================================================


% ============================ uniqueness theorems ========================
% =========================================================================

%% set2facts is NOT unique, but results are "equivalent"

%theorem set2facts-bimplies
  : forall* {O1} {O2} {S1} {S2} {G1} {G2}
    forall {S1=>G1: set2facts O1 S1 G1}
    {S2=>G2: set2facts O2 S2 G2}
    {E: object`eq O1 O2} {E: set`eq S1 S2}
    exists {IMP1: bimplies true G1 G2} {IMP2: bimplies true G2 G1}
    true.

%worlds (objvar | fracvar) (set2facts-bimplies _ _ _ _ _ _).
%trustme %total {} (set2facts-bimplies _ _ _ _ _ _).


%theorem apply-efx-deterministic
  : forall* {P1} {P2} {X1} {X2} {Pi1} {Pi2} {PF1} {PF2}
    forall {AP1: apply-efx P1 X1 Pi1 PF1}
    {AP2: apply-efx P2 X2 Pi2 PF2}
    {E: bool`eq P1 P2}
    {E: efx`eq X1 X2}
    {E: permission`eq Pi1 Pi2}
    exists {E: permission`eq PF1 PF2}
    true.

- : apply-efx-deterministic AP1 AP2
    bool`eq/ efx`eq/ permission`eq/ permission`eq/.

%worlds () (apply-efx-deterministic _ _ _ _ _ _).
%total {} (apply-efx-deterministic _ _ _ _ _ _).

%abbrev apply-efx-unique = apply-efx-deterministic.


%theorem inner-efxmap2perm-equiv
  : forall* {P1} {P2} {O1} {O2} {FM1} {FM2}
    {PM1} {PM2} {M1} {M2} {Pi1} {Pi2}
    forall {M1=>Pi1: inner-efxmap2perm P1 O1 FM1 PM1 M1 Pi1}
    {M2=>Pi2: inner-efxmap2perm P2 O2 FM2 PM2 M2 Pi2}
    {E: bool`eq P1 P2}
    {E: object`eq O1 O2}
    {E: fldmap`eq FM1 FM2}
    {E: predmap`eq PM1 PM2}
    {E: inner-efxmap`eq M1 M2}
    exists {EQV: equiv Pi1 Pi2}
    true.

%worlds (objvar) (inner-efxmap2perm-equiv _ _ _ _ _ _ _ _).
%trustme %total {} (inner-efxmap2perm-equiv _ _ _ _ _ _ _ _).


%theorem efxmap2perm-equiv
  : forall* {P1} {P2} {CM1} {CM2} {PM1} {PM2} {B1} {B2}
    {XM1} {XM2} {Pi1} {Pi2}
    forall {XM1=>Pi1: efxmap2perm P1 CM1 PM1 B1 XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P2 CM2 PM2 B2 XM2 Pi2}
    {E: bool`eq P1 P2} {E: clsmap`eq CM1 CM2}
    {E: predmap`eq PM1 PM2} {E: cxt`eq B1 B2} {E: efxmap`eq XM1 XM2}
    exists {EQV: equiv Pi1 Pi2}
    true.

%worlds (fracvar | objvar) (efxmap2perm-equiv _ _ _ _ _ _ _ _).
%trustme %total {} (efxmap2perm-equiv _ _ _ _ _ _ _ _).

% ======================================================================


% ==================== XX-fresh-update-implies-XX ======================
% ======================================================================

%% fresh-update-implies-equiv-converse

%theorem inner-efxmap`fresh-update-implies-equiv-converse
  : forall* {M} {MP} {F} {X} {P} {O} {FM} {PM} {Pi1}
    forall {FS: inner-efxmap`fresh MP F}
    {U: inner-efxmap`update MP F X M}
    {M=>Pi1: inner-efxmap2perm P O FM PM M Pi1}
    exists {T} {Pi2} {Pi3} {FM-L: fldmap`lookup FM F T}
    {PF} {T2PF: ty2perm PM T PF}
    {AP: apply-efx P X (unitperm (precise-exists O F PF)) Pi2}
    {MP=>Pi3: inner-efxmap2perm P O FM PM MP Pi3}
    {EQV: equiv Pi1 (Pi2 , Pi3)}
    true.

- : inner-efxmap`fresh-update-implies-equiv-converse
    inner-efxmap`fresh/0 inner-efxmap`update/0 %{=>}%
    (inner-efxmap2perm/U
      inner-efxmap`fresh/0 inner-efxmap`update/0
      FM-L T2P AP inner-efxmap2perm/0)
    _ _ _ FM-L _ T2P AP inner-efxmap2perm/0 equiv/reflexive.

%theorem inner-efxmap`fresh-update-implies-equiv-converse/U
  : forall* {M} {MP} {MS} {F1} {F2} {X1} {X2} {FM} {T2}
    {PM} {PF2} {P} {O} {Pi1} {Pi2} {B}
    forall {FS1: inner-efxmap`fresh MP F1}
    {U1: inner-efxmap`update MP F1 X1 M}
    {FS2: inner-efxmap`fresh MS F2}
    {U2: inner-efxmap`update MS F2 X2 M}
    {FM-L2: fldmap`lookup FM F2 T2}
    {T2PF2: ty2perm PM T2 PF2}
    {AP2: apply-efx P X2 (unitperm (precise-exists O F2 PF2)) Pi1}
    {MS=>Pi2: inner-efxmap2perm P O FM PM MS Pi2}
    {E?: nat`eq? F1 F2 B}
    exists {T1} {FM-L1: fldmap`lookup FM F1 T1}
    {PF1} {T2PF1: ty2perm PM T1 PF1}
    {Pi3} {AP: apply-efx P X1 (unitperm (precise-exists O F1 PF1)) Pi3}
    {Pi4} {MP=>Pi4: inner-efxmap2perm P O FM PM MP Pi4}
    {EQV: equiv (Pi1 , Pi2) (Pi3 , Pi4)}
    true.

- : inner-efxmap`fresh-update-implies-equiv-converse/U
    F!<MP MP+F=M F!<MS MS+F=M FM->F T=>PF PF+X1=>P1 MS=>P2
    (nat`eq?/yes) %{=>}% _ FM->F _ T=>PF _ PF+X2=>P1 _ MP=>P2 equiv/reflexive
    <- inner-efxmap`fresh-update-cancels F!<MS MS+F=M F!<MP MP+F=M
      nat`eq/ inner-efxmap`eq/ X2=X1 MS=MP
    <- apply-efx-respects-eq
      PF+X1=>P1 bool`eq/ X2=X1 permission`eq/ permission`eq/ PF+X2=>P1
    <- inner-efxmap2perm-respects-eq
      MS=>P2 bool`eq/ object`eq/ fldmap`eq/ predmap`eq/ MS=MP
      permission`eq/ MP=>P2.

- : inner-efxmap`fresh-update-implies-equiv-converse/U
     F1!<MP MP+F1=M F2!<MS MS+F2=M FM->F2 T2=>PF2 PF2=>P1 MS=>P2
    (nat`eq?/no F1!=F2) %{=>}% _ FM->F1 _ T1=>PF1 _ PF1=>P3
    _ (inner-efxmap2perm/U F2!<MK MK+F2=MP FM->F2 T2=>PF2 PF2=>P1 MK=>P5)
     (equiv/transitive
      (equiv/combine
        equiv/reflexive EQV)
      (equiv/roll2))
    <- inner-efxmap`update-commutes-converse
      MP+F1=M MS+F2=M F1!=F2 MK MK+F2=MP MK+F1=MS
    <- inner-efxmap`update-preserves-fresh-converse F1!<MP MK+F2=MP F1!<MK
    <- inner-efxmap`update-preserves-fresh-converse F2!<MS MK+F1=MS F2!<MK
    <- inner-efxmap`fresh-update-implies-equiv-converse
      F1!<MK MK+F1=MS MS=>P2 _ _ _ FM->F1 _ T1=>PF1 PF1=>P3 MK=>P5 EQV.

- : inner-efxmap`fresh-update-implies-equiv-converse F1!<MP MP+F1=M
    (inner-efxmap2perm/U F2!<MS MS+F2=M T1 T2 T3 T4) _ _ _ Q1 _ Q2 Q3 Q4 EQV
    <- nat`eq?-total EQ?
    <- inner-efxmap`fresh-update-implies-equiv-converse/U
      F1!<MP MP+F1=M F2!<MS MS+F2=M T1 T2 T3 T4 EQ? _ Q1 _ Q2 _ Q3 _ Q4 EQV.

%worlds ()
(inner-efxmap`fresh-update-implies-equiv-converse _ _ _ _ _ _ _ _ _ _ _ _)
(inner-efxmap`fresh-update-implies-equiv-converse/U _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (T1 T2)
(inner-efxmap`fresh-update-implies-equiv-converse _ _ T1 _ _ _ _ _ _ _ _ _)
(inner-efxmap`fresh-update-implies-equiv-converse/U _ _ _ _ _ _ _ T2 _ _ _ _ _ _ _ _ _ _).


%theorem efxmap`fresh-update-implies-equiv-converse
  : forall* {CM} {PM} {B} {MP} {N} {D} {P} {M} {Pi3}
    forall {FS: efxmap`fresh MP N}
    {U: efxmap`update MP N D M}
    {M=>Pi3: efxmap2perm P CM PM B M Pi3}
    exists {Pi1} {Pi2}
    {NN} {A} {C} {B-L: cxt`lookup B (object/ N) (ty/ NN A C)}
    {FM} {CM-L: clsmap`lookup CM C FM}
    {D=>Pi1: inner-efxmap2perm P (object/ N) FM PM D Pi1}
    {MP=>Pi2: efxmap2perm P CM PM B MP Pi2}
    {EQV: equiv Pi3 (Pi1 , Pi2)}
    true.

- : efxmap`fresh-update-implies-equiv-converse
    efxmap`fresh/0 efxmap`update/0 %{=>}%
    (efxmap2perm/U
      efxmap`fresh/0 efxmap`update/0
      B-L CM-L DT efxmap2perm/0)
    _ _ _ _ _ B-L _ CM-L DT efxmap2perm/0 equiv/reflexive.

%theorem efxmap`fresh-update-implies-equiv-converse/U
  : forall* {M} {MP} {MS} {N1} {N2} {D1} {D2} {B}
    {NN2} {A2} {C2} {CM} {FM2} {PM} {Pi1} {P} {Pi2} {IN?}
    forall {FS1: efxmap`fresh MP N1}
    {U1: efxmap`update MP N1 D1 M}
    {FS2: efxmap`fresh MS N2}
    {U2: efxmap`update MS N2 D2 M}
    {B-L2: cxt`lookup B (object/ N2) (ty/ NN2 A2 C2)}
    {CM-L2: clsmap`lookup CM C2 FM2}
    {D2=>Pi1: inner-efxmap2perm P (object/ N2) FM2 PM D2 Pi1}
    {MS=>Pi2: efxmap2perm P CM PM B MS Pi2}
    {E?: nat`eq? N1 N2 IN?}
    exists {NN1} {A1} {C1}
    {B-L1: cxt`lookup B (object/ N1) (ty/ NN1 A1 C1)}
    {FM1} {CM-L1: clsmap`lookup CM C1 FM1}
    {Pi3} {Pi4} {D1=>Pi3: inner-efxmap2perm P (object/ N1) FM1 PM D1 Pi3}
    {MP=>Pi4: efxmap2perm P CM PM B MP Pi4}
    {EQV: equiv (Pi1 , Pi2) (Pi3 , Pi4)}
    true.

- : efxmap`fresh-update-implies-equiv-converse/U
    N!<MP MP+N=M N!<MS MS+N=M B-L2 CM-L2 M2P2 XM2P2 nat`eq?/yes
    %{=>}% _ _ _ B-L2 _ CM-L2 _ _ M2P1 XM2P1 equiv/reflexive
    <- efxmap`fresh-update-cancels
      N!<MS MS+N=M N!<MP MP+N=M nat`eq/ efxmap`eq/ D2=D1 MS=MP
    <- inner-efxmap2perm-respects-eq M2P2
      bool`eq/ object`eq/ fldmap`eq/ predmap`eq/
      D2=D1 permission`eq/ M2P1
    <- efxmap2perm-respects-eq XM2P2
      bool`eq/ clsmap`eq/ predmap`eq/
      cxt`eq/ MS=MP permission`eq/ XM2P1.

- : efxmap`fresh-update-implies-equiv-converse/U
    N1!<MP MP+N1=M N2!<MS MS+N2=M B->N2 CM->C2 D2=>P1 MS=>P2
    (nat`eq?/no N1!=N2) %{=>}% _ _ _ B->N1 _ CM->C1 _ _ D1=>P3
    (efxmap2perm/U N2!<MK MK+N2=MP B->N2 CM->C2 D2=>P1 MK=>P5)
     (equiv/transitive
      (equiv/combine
        equiv/reflexive (EQV))
      (equiv/roll2))
    <- efxmap`update-commutes-converse
      MP+N1=M MS+N2=M N1!=N2 MK MK+N2=MP MK+N1=MS
    <- efxmap`update-preserves-fresh-converse N1!<MP MK+N2=MP N1!<MK
    <- efxmap`update-preserves-fresh-converse N2!<MS MK+N1=MS N2!<MK
    <- efxmap`fresh-update-implies-equiv-converse
      N1!<MK MK+N1=MS MS=>P2 _ _ _ _ _ B->N1 _ CM->C1 D1=>P3 MK=>P5 EQV.

- : efxmap`fresh-update-implies-equiv-converse F1!<MP MP+F1=M
    (efxmap2perm/U F2!<MS MS+F2=M T1 T2 T3 T4) _ _ _ _ _ Q1 _ Q2 Q3 Q4 EQV
    <- nat`eq?-total EQ?
    <- efxmap`fresh-update-implies-equiv-converse/U
      F1!<MP MP+F1=M F2!<MS MS+F2=M T1 T2 T3 T4 EQ? _ _ _ Q1 _ Q2 _ _ Q3 Q4 EQV.

%worlds (fracvar)
(efxmap`fresh-update-implies-equiv-converse _ _ _ _  _ _ _ _ _ _ _ _ _ _)
(efxmap`fresh-update-implies-equiv-converse/U _ _ _ _ _ _ _ _ _ _ _  _ _ _ _ _ _ _ _ _).
%total (T1 T2)
(efxmap`fresh-update-implies-equiv-converse _ _ T1 _ _ _ _ _ _ _ _  _ _ _)
(efxmap`fresh-update-implies-equiv-converse/U _ _ _ _ _ _ _ T2 _ _ _ _ _ _ _ _ _  _ _ _).


% =========================================================================
% theorems about leq - basically:
%
% if XM1 is less or equal than XM2, and
% XM1 ==> Pi1, XM2 ==> Pi2.
% then exists Pi3, such that Pi2 <==> Pi1 , Pi3
%
% =========================================================================

%theorem can-split-permission
  : forall* {Q1} {Pi}
    forall {Q1<1: rat`lst Q1 one}
    exists {Q2} {ADD: rat`add Q1 Q2 one}
    {EQV: equiv Pi ((scale (fraction/ Q1) Pi) , (scale (fraction/ Q2) Pi))}
    true.

- : can-split-permission (Q1<1:rat`lst Q1 one) Q2 Q1+Q2=1
    (equiv/transitive
      (equiv/symmetric equiv/one)
      (equiv/symmetric (equiv/add Q1+Q2=1)))
    <- rat`grt-implies-add Q1<1 Q2 Q2+Q1=1
    <- rat`add-commutative Q2+Q1=1 Q1+Q2=1.

%worlds () (can-split-permission _ _ _ _).
%total {} (can-split-permission _ _ _ _).


%% This turns out to be unprovable: we have no information
%% about the fraction variable - it could even be greater than 1!

%theorem apply-efx-preserves-permission-leq
  : forall* {X1} {X2} {Pi} {Pi1} {Pi2}
    forall {X1<=X2: efx`leq X1 X2}
    {AP-X1: apply-efx true X1 Pi Pi1}
    {AP-X2: apply-efx true X2 Pi Pi2}
    exists {Pi3} {Pi2=>Pi1+Pi3: equiv (Pi2) (Pi1 , Pi3)}
    true.

%worlds (fracvar) (apply-efx-preserves-permission-leq _ _ _ _ _).
%trustme %total {} (apply-efx-preserves-permission-leq _ _ _ _ _).


%theorem inner-efxmap`leq-implies-permission-leq
  : forall* {CM} {PM} {FM} {C} {MP} {P} {O} {M} {P1} {MPS} {FS}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {DM-FM=FS: fldmap`domain FM FS}
    {DM-M=MS: inner-efxmap`domain MP MPS}
    {LE: set`leq MPS FS}
    {M=>P1: inner-efxmap2perm P O FM PM M P1}
    {M<=MP: inner-efxmap`leq M MP}
    exists {P2} {P3} {MP=>P2: inner-efxmap2perm P O FM PM MP P2}
    {EQV: equiv (P2) ((P1) , (P3))}
    true.

%theorem inner-efxmap`leq-implies-permission-leq/L
  : forall* {CM} {PM} {FM} {C} {M1} {M2} {Pi1} {P} {O} {MS2} {FS}
    forall {N} {SZ: inner-efxmap`size M2 N}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {DM-FM=FS: fldmap`domain FM FS}
    {DM-M2=MS2: inner-efxmap`domain M2 MS2}
    {LE: set`leq MS2 FS}
    {M=>P1: inner-efxmap2perm P O FM PM M1 Pi1}
    {M1<=M2: inner-efxmap`leq M1 M2}
    exists {Pi2} {Pi3} {M2=>Pi2: inner-efxmap2perm P O FM PM M2 Pi2}
    {EQV: equiv (Pi2) ((Pi1) , (Pi3))}
    true.

%worlds (fracvar | objvar)
(inner-efxmap`leq-implies-permission-leq/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (N)
(inner-efxmap`leq-implies-permission-leq/L N _ _ _ _ _ _ _ _ _ _ _ _ _).

- : inner-efxmap`leq-implies-permission-leq A B C D E G K J _ _ H I
    <- inner-efxmap`size-total SZ
    <- inner-efxmap`leq-implies-permission-leq/L _ SZ A B C D E G K J _ _ H I.

%worlds (fracvar)
(inner-efxmap`leq-implies-permission-leq _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (inner-efxmap`leq-implies-permission-leq _ _ _ _ _ _ _ _ _ _ _ _).


%theorem efxmap`leq-implies-permission-leq/L
  : forall* {XM1} {XM2} {CM} {PM} {B} {P} {Pi1}
    forall {N} {SZ: efxmap`size XM2 N}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B-XM2: clsmap-cxt-efxmap CM B XM2}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM1<=XM2: efxmap`leq XM1 XM2}
    exists {Pi2} {Pi3} {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    {EQV: (equiv (Pi2) ((Pi1) , Pi3))}
    true.

- : efxmap`leq-implies-permission-leq/L _ _
    CM-CM CM2PM B-XM2 efxmap2perm/0 efxmap`leq/0 _ _ XM=>Pi
    (equiv/transitive
      (equiv/symmetric equiv/identity)
      (equiv/commute))
    <- clsmap-cxt-efxmap-implies-efxmap2perm CM-CM CM2PM B-XM2 _ XM=>Pi.

%theorem efxmap`leq-implies-permission-leq/U
  : forall* {CM} {PM} {FM} {XM1} {XM2} {XM2P} {FS}
    {P} {N} {M} {B} {NN} {A} {C} {Pi1} {IN?} {MS}
    forall {K} {SZ: efxmap`size XM2 K}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {F: efxmap`fresh XM2P N}
    {U: efxmap`update XM2P N M XM2}
    {B-L: cxt`lookup B (object/ N) (ty/ NN A C)}
    {CM-L: clsmap`lookup CM C FM}
    {DM-FM=FS: fldmap`domain FM FS}
    {DM-M=MS: inner-efxmap`domain M MS}
    {LE: set`leq MS FS}
    {B-XM2P: clsmap-cxt-efxmap CM B XM2P}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM1<=XM2: efxmap`leq XM1 XM2}
    {IN?: efxmap`domain? XM1 N IN?}
    exists {Pi2} {Pi3} {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    {EQV: (equiv (Pi2) ((Pi1) , (Pi3)))}
    true.

%worlds (fracvar)
(efxmap`leq-implies-permission-leq/L _ _ _ _ _ _ _ _ _ _ _)
(efxmap`leq-implies-permission-leq/U _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (N1 N2)
(efxmap`leq-implies-permission-leq/U N2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(efxmap`leq-implies-permission-leq/L N1 _ _ _ _ _ _ _ _ _ _).


% the major theorem

%theorem efxmap`leq-implies-permission-leq
  : forall* {CM} {PM} {B} {XM1} {XM2} {P} {Pi1}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B-XM2: clsmap-cxt-efxmap CM B XM2}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM1<=XM2: efxmap`leq XM1 XM2}
    exists {Pi2} {Pi3} {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    {EQV: (equiv (Pi2) ((Pi1) , (Pi3)))}
    true.

- : efxmap`leq-implies-permission-leq CM-CM CM2PM
    B-XM2 XM1=>Pi1 XM1<=XM2 Pi2 Pi3 XM2=>Pi2 EQV
    <- efxmap`size-total SZ
    <- leq-preserves-clsmap-cxt-efxmap B-XM2 XM1<=XM2 B-XM1
    <- efxmap`leq-implies-permission-leq/L _ SZ CM-CM CM2PM
      B-XM2 XM1=>Pi1 XM1<=XM2 _ _ XM2=>Pi2 EQV.

%worlds (fracvar) (efxmap`leq-implies-permission-leq _ _ _ _ _ _ _ _ _).
%total {} (efxmap`leq-implies-permission-leq _ _ _ _ _ _ _ _ _).


% conversed version of the major theorem

%theorem efxmap`leq-implies-permission-leq-converse
  : forall* {B} {P} {Pi2} {CM} {PM} {XM1} {XM2}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B-XM2: clsmap-cxt-efxmap CM B XM2}
    {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    {XM1<=XM2: efxmap`leq XM1 XM2}
    exists {Pi1} {Pi3} {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {EQV: (equiv (Pi2) ((Pi1) , (Pi3)))}
    true.

- : efxmap`leq-implies-permission-leq-converse
    CM-CM CM2PM B-XM2 XM2=>Pi2 XM1<=XM2 Pi1 _ XM1=>Pi1
     (equiv/transitive (equiv/symmetric (EQV2)) (EQV1))
    <- leq-preserves-clsmap-cxt-efxmap B-XM2 XM1<=XM2 B-XM1
    <- clsmap-cxt-efxmap-implies-efxmap2perm CM-CM CM2PM B-XM1 Pi1 XM1=>Pi1
    <- efxmap`leq-implies-permission-leq
      CM-CM CM2PM B-XM2 XM1=>Pi1 XM1<=XM2 Pi2 Pi3 XM2=>Pi2' EQV1
    <- efxmap2perm-equiv XM2=>Pi2' XM2=>Pi2
       bool`eq/ clsmap`eq/ predmap`eq/ cxt`eq/ efxmap`eq/ EQV2.

%worlds (fracvar)
(efxmap`leq-implies-permission-leq-converse _ _ _ _ _ _ _ _ _).
%total {} (efxmap`leq-implies-permission-leq-converse _ _ _ _ _ _ _ _ _).


%theorem shared-efx-leq-implies-permission-leq
  : forall* {MX1} {MX2} {P1} {P2}
    forall {LE: shared-efx`leq MX1 MX2}
    {MX1=>P1: shared-efx2perm MX1 P1}
    {MX2=>P2: shared-efx2perm MX2 P2}
    exists {P3}
    {EQV: equiv (P2) (P1 , P3)}
    true.

%worlds () (shared-efx-leq-implies-permission-leq _ _ _ _ _).
%trustme %total (L) (shared-efx-leq-implies-permission-leq L _ _ _ _).


% ==========================================================
% deep-disjoint-join-implies-equiv:
%
% If we have two effect maps XM1 and XM2,
%   and if the following condition holds
%
% 1. XM1^XM2
% 2. XM1+XM2 = XM
% 3. XM1 ==> Pi1
% 4. XM2 ==> Pi2
% 5. XM  ==> Pi
%
% then we can derive:
%
% Pi1 , Pi2 <==> Pi
%
% ==========================================================


%theorem inner-efxmap`disjoint-join-implies-equiv
  : forall* {M1} {M2} {M} {P} {O} {FM} {PM} {Pi}
    forall {DJ: inner-efxmap`disjoint M1 M2}
    {J: inner-efxmap`join M1 M2 M}
    {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
    exists {Pi1} {Pi2}
    {M1=>Pi1: inner-efxmap2perm P O FM PM M1 Pi1}
    {M2=>Pi2: inner-efxmap2perm P O FM PM M2 Pi2}
    {EQV: equiv (Pi) ((Pi1) , (Pi2))}
    true.

- : inner-efxmap`disjoint-join-implies-equiv
    _ _ inner-efxmap2perm/0 _ _ inner-efxmap2perm/0 inner-efxmap2perm/0
    (equiv/symmetric equiv/identity).

%theorem inner-efxmap`disjoint-join-implies-equiv/L
  : forall* {M1} {M2} {M} {MP} {F} {X} {T} {PF}
    {P} {O} {FM} {PM} {Pix} {Piy} {B}
    forall {DJ: inner-efxmap`disjoint M1 M2}
    {J: inner-efxmap`join M1 M2 M}
    {FS: inner-efxmap`fresh MP F}
    {U: inner-efxmap`update MP F X M}
    {FML: fldmap`lookup FM F T}
    {T=>PF: ty2perm PM T PF}
    {AP: apply-efx P X (unitperm (precise-exists O F PF)) Pix}
    {M=>Pi: inner-efxmap2perm P O FM PM MP Piy}
    {IN: inner-efxmap`domain? M1 F B}
    exists {Pi1} {Pi2}
    {M1=>Pi1: inner-efxmap2perm P O FM PM M1 Pi1}
    {M2=>Pi2: inner-efxmap2perm P O FM PM M2 Pi2}
    {EQV: (equiv ((Pix) , (Piy)) ((Pi1) , (Pi2)))}
    true.

- : inner-efxmap`disjoint-join-implies-equiv/L
    M1^M2 (M1+M2=M:inner-efxmap`join M1 M2 M)
    F!<MP (MP+F+X=M:inner-efxmap`update MP F X M)
    FM->F=T T=>PF PF=>Pix MP=>Piy
    (inner-efxmap`domain?/in M1->F) _ _
    (inner-efxmap2perm/U F!<M1P M1P+F+X=M1 FM->F=T T=>PF PF=>Pix M1P=>Pi1x)
    M2=>Pi2 (equiv/transitive
              (equiv/combine equiv/reflexive (Piy<=>Pi1x+Pi2))
              (equiv/associate))
    <- inner-efxmap`disjoint-lookup-implies-fresh M1->F M1^M2 F!<M2
    <- inner-efxmap`update-implies-lookup MP+F+X=M M->F=X
    <- inner-efxmap`fresh-join-right-preserves-lookup-converse
      M->F=X F!<M2 M1+M2=M M1->F=X
    <- inner-efxmap`lookup-implies-fresh-update M1->F=X M1P F!<M1P M1P+F+X=M1
    <- inner-efxmap`fresh-update-implies-unit-join F!<M1P M1P+F+X=M1 M1P+X=M1
    <- inner-efxmap`fresh-implies-unit-disjoint F!<M1P M1P^X
    <- inner-efxmap`disjoint-join-commutative M1P^X M1P+X=M1 X+M1P=M1
    <- inner-efxmap`join-associative X+M1P=M1 M1+M2=M MPx M1P+M2=MPx X+MPx=M
    <- inner-efxmap`join-preserves-fresh* F!<M1P F!<M2 M1P+M2=MPx F!<MPx
    <- inner-efxmap`fresh-implies-unit-disjoint F!<MPx MPx^X
    <- inner-efxmap`disjoint-symmetric MPx^X X^MPx
    <- inner-efxmap`disjoint-join-commutative X^MPx X+MPx=M MPx+X=M
    <- inner-efxmap`fresh-unit-join-implies-update F!<MPx MPx+X=M MPx+F+X=M
    <- inner-efxmap`fresh-update-cancels F!<MPx MPx+F+X=M F!<MP MP+F+X=M nat`eq/
      inner-efxmap`eq/ _ MPx=MP
    <- inner-efxmap`join-respects-eq M1P+M2=MPx inner-efxmap`eq/
      inner-efxmap`eq/ MPx=MP M1P+M2=MP
    <- inner-efxmap`fresh-update-implies-leq F!<M1P M1P+F+X=M1 M1P<=M1
    <- inner-efxmap`disjoint-respects-geq* M1^M2 M1P<=M1 M1P^M2
    <- inner-efxmap`disjoint-join-implies-equiv
      M1P^M2 M1P+M2=MP MP=>Piy Pi1x Pi2 M1P=>Pi1x M2=>Pi2 Piy<=>Pi1x+Pi2.

- : inner-efxmap`disjoint-join-implies-equiv/L
    M1^M2 (M1+M2=M:inner-efxmap`join M1 M2 M)
    F!<MP (MP+F+X=M:inner-efxmap`update MP F X M)
    FM->F=T T=>PF PF=>Pix MP=>Piy
    (inner-efxmap`domain?/out F!<M1) _ _
    M1=>Pi1 (inner-efxmap2perm/U F!<M2P M2P+F+X=M2 FM->F=T T=>PF PF=>Pix M2P=>Pi2x)
    (equiv/transitive (equiv/combine equiv/reflexive (Piy<=>Pi1+Pi2x))
      (equiv/roll2))
    <- inner-efxmap`update-implies-lookup MP+F+X=M M->F=X
    <- inner-efxmap`fresh-join-left-preserves-lookup-converse
      F!<M1 M->F=X M1+M2=M M2->F=X
    <- inner-efxmap`lookup-implies-fresh-update M2->F=X M2P F!<M2P M2P+F+X=M2
    <- inner-efxmap`fresh-update-implies-unit-join F!<M2P M2P+F+X=M2 M2P+X=M2
    <- inner-efxmap`join-associative-converse M2P+X=M2 M1+M2=M MPx M1+M2P=MPx MPx+X=M
    <- inner-efxmap`join-preserves-fresh* F!<M1 F!<M2P M1+M2P=MPx F!<MPx
    <- inner-efxmap`fresh-unit-join-implies-update F!<MPx MPx+X=M MPx+F+X=M
    <- inner-efxmap`fresh-update-cancels F!<MPx MPx+F+X=M F!<MP MP+F+X=M nat`eq/
      inner-efxmap`eq/ _ MPx=MP
    <- inner-efxmap`join-respects-eq M1+M2P=MPx inner-efxmap`eq/
      inner-efxmap`eq/ MPx=MP M1+M2P=MP
    <- inner-efxmap`fresh-update-implies-leq F!<M2P M2P+F+X=M2 M2P<=M2
    <- inner-efxmap`disjoint-symmetric M1^M2 M2^M1
    <- inner-efxmap`disjoint-respects-geq* M2^M1 M2P<=M2 M2P^M1
    <- inner-efxmap`disjoint-symmetric M2P^M1 M1^M2P
    <- inner-efxmap`disjoint-join-implies-equiv
      M1^M2P M1+M2P=MP MP=>Piy Pi1 Pi2x M1=>Pi1 M2P=>Pi2x Piy<=>Pi1+Pi2x.

- : inner-efxmap`disjoint-join-implies-equiv
    X J (inner-efxmap2perm/U F!<MP MP+F+X=M FM->F=T T=>PF P+X=>Pi1
          MP=>Pi2)
    _ _ M1=>Pi1 M2=>Pi2 EQV
    <- inner-efxmap`domain?-total IN?
    <- inner-efxmap`disjoint-join-implies-equiv/L
      X J F!<MP MP+F+X=M FM->F=T T=>PF P+X=>Pi1 MP=>Pi2 IN? _ _ M1=>Pi1 M2=>Pi2 EQV.

%worlds ()
(inner-efxmap`disjoint-join-implies-equiv _ _ _ _ _ _ _ _)
(inner-efxmap`disjoint-join-implies-equiv/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (T1 T2) (inner-efxmap`disjoint-join-implies-equiv _ _ T1 _ _ _ _ _)
(inner-efxmap`disjoint-join-implies-equiv/L _ _ _ _ _ _ _ T2 _ _ _ _ _ _).


%theorem inner-efxmap`disjoint-join-implies-equiv-converse
  : forall* {M1} {M2} {M} {P} {O} {FM} {PM} {Pi1} {Pi2}
    forall {DJ: inner-efxmap`disjoint M1 M2}
    {J: inner-efxmap`join M1 M2 M}
    {M1=>Pi1: inner-efxmap2perm P O FM PM M1 Pi1}
    {M2=>Pi2: inner-efxmap2perm P O FM PM M2 Pi2}
    exists {Pi} {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
    {EQV: (equiv ((Pi1) , (Pi2)) (Pi))}
    true.

%theorem inner-efxmap`disjoint-join-implies-equiv-converse/L
  : forall* {M1} {M2} {M} {P} {O} {FM} {PM} {Pi1} {Pi2}
    forall {N1} {SZ1: inner-efxmap`size M1 N1}
    {N2} {SZ2: inner-efxmap`size M2 N2}
    {DJ: inner-efxmap`disjoint M1 M2}
    {J: inner-efxmap`join M1 M2 M}
    {M1=>Pi1: inner-efxmap2perm P O FM PM M1 Pi1}
    {M2=>Pi2: inner-efxmap2perm P O FM PM M2 Pi2}
    exists {Pi} {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
    {EQV: (equiv ((Pi1) , (Pi2)) (Pi))}
    true.

- : inner-efxmap`disjoint-join-implies-equiv-converse
    M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 Pi M=>Pi EQV
    <- inner-efxmap`size-total SZ-M1
    <- inner-efxmap`size-total SZ-M2
    <- inner-efxmap`disjoint-join-implies-equiv-converse/L
      _ SZ-M1 _ SZ-M2 M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 Pi M=>Pi EQV.

%worlds (fracvar) (inner-efxmap`disjoint-join-implies-equiv-converse/L _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {N1 N2}
(inner-efxmap`disjoint-join-implies-equiv-converse/L N1 _ N2 _ _ _ _ _ _ _ _).

%worlds (fracvar) (inner-efxmap`disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).
%total {} (inner-efxmap`disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).


%theorem efxmap`deep-disjoint-join-implies-equiv
  : forall* {M1} {M2} {M} {P} {CM} {PM} {B} {Pi}
    forall {DJ: efxmap`deep-disjoint M1 M2}
    {J: efxmap`join M1 M2 M}
    {M=>Pi: efxmap2perm P CM PM B M Pi}
    exists {Pi1} {Pi2}
    {M1=>Pi1: efxmap2perm P CM PM B M1 Pi1}
    {M2=>Pi2: efxmap2perm P CM PM B M2 Pi2}
    {EQV: (equiv (Pi) ((Pi1) , (Pi2)))}
    true.

- : efxmap`deep-disjoint-join-implies-equiv
    _ _ efxmap2perm/0 _ _ efxmap2perm/0 efxmap2perm/0 ((equiv/symmetric equiv/identity)).


%theorem efxmap`deep-disjoint-join-implies-equiv/L
  : forall* {M1} {M2} {M} {MP} {N} {D} {NN} {A} {C}
    {P} {CM} {PM} {B} {FM} {Pix} {Piy} {B1} {B2}
    forall {DJ: efxmap`deep-disjoint M1 M2}
    {J: efxmap`join M1 M2 M}
    {FS: efxmap`fresh MP N}
    {U: efxmap`update MP N D M}
    {BL: cxt`lookup B (object/ N) (ty/ NN A C)}
    {CML: clsmap`lookup CM C FM}
    {D=>Pi: inner-efxmap2perm P (object/ N) FM PM D Pix}
    {MP=>Pi: efxmap2perm P CM PM B MP Piy}
    {IN1: efxmap`domain? M1 N B1}
    {IN2: efxmap`domain? M2 N B2}
    exists {Pi1} {Pi2}
    {M1=>Pi1: efxmap2perm P CM PM B M1 Pi1}
    {M2=>Pi2: efxmap2perm P CM PM B M2 Pi2}
    {EQV: (equiv ((Pix) , (Piy)) ((Pi1) , (Pi2)))}
    true.

- : efxmap`deep-disjoint-join-implies-equiv/L
    M1^M2 M1+M2=M N!<MP MP+N+D=M BL CML D=>Pix MP=>Piy
    (efxmap`domain?/in M1->N=D1) (efxmap`domain?/in M2->N=D2)
    _ _ (efxmap2perm/U N!<M1P M1P+N+D1=M1 BL CML D1=>Pix1 M1P=>Piy1)
    (efxmap2perm/U N!<M2P M2P+N+D2=M2 BL CML D2=>Pix2 M2P=>Piy2)
    ((equiv/transitive4
           (equiv/combine (EQV1) (EQV2))
           (equiv/symmetric equiv/associate)
           (equiv/combine equiv/reflexive equiv/roll2)
           (equiv/associate)))
    <- efxmap`deep-disjoint-lookup-implies-disjoint M1^M2 M1->N=D1 M2->N=D2 D1^D2
    <- efxmap`update-implies-lookup MP+N+D=M M->N=D
    <- efxmap`join-commutes-lookup M1+M2=M M1->N=D1 M2->N=D2 M->N=D D1+D2=D
    <- efxmap`lookup-implies-fresh-update M1->N=D1 M1P N!<M1P M1P+N+D1=M1
    <- efxmap`lookup-implies-fresh-update M2->N=D2 M2P N!<M2P M2P+N+D2=M2
    <- inner-efxmap`disjoint-join-implies-equiv
      D1^D2 D1+D2=D D=>Pix Pix1 Pix2 D1=>Pix1 D2=>Pix2 EQV1
    <- efxmap`fresh-update-preserves-deep-disjoint-join-converse
      N!<M1P M1P+N+D1=M1 N!<M2P M2P+N+D2=M2
      N!<MP MP+N+D=M M1+M2=M M1^M2 D1+D2=D M1P^M2P M1P+M2P=MP
    <- efxmap`deep-disjoint-join-implies-equiv
      M1P^M2P M1P+M2P=MP MP=>Piy Piy1 Piy2 M1P=>Piy1 M2P=>Piy2 EQV2.

- : efxmap`deep-disjoint-join-implies-equiv/L
    M1^M2 M1+M2=M N!<MP MP+N+D=M BL CML D=>Pix MP=>Piy
    (efxmap`domain?/in _) (efxmap`domain?/out N!<M2)
    _ _ (efxmap2perm/U N!<M1P M1P+N+D=M1 BL CML D=>Pix M1P=>Piy1)
    M2=>Piy2
    ((equiv/transitive (equiv/combine equiv/reflexive (EQV2)) (equiv/associate)))
    <- efxmap`update-implies-lookup MP+N+D=M M->N=D
    <- efxmap`fresh-join-right-preserves-lookup-converse M->N=D N!<M2 M1+M2=M M1->N=D
    <- efxmap`lookup-implies-fresh-update M1->N=D M1P N!<M1P M1P+N+D=M1
    <- efxmap`fresh-update1-preserves-deep-disjoint-join-converse
      N!<M1P M1P+N+D=M1 N!<M2 N!<MP MP+N+D=M M1+M2=M M1^M2 M1P^M2 M1P+M2=MP
    <- efxmap`deep-disjoint-join-implies-equiv
      M1P^M2 M1P+M2=MP MP=>Piy Piy1 Piy2 M1P=>Piy1 M2=>Piy2 EQV2.

- : efxmap`deep-disjoint-join-implies-equiv/L
    M1^M2 (M1+M2=M:efxmap`join M1 M2 M)
    N!<MP (MP+N+D=M:efxmap`update MP N D M) BL CML D=>Pix MP=>Piy
    (efxmap`domain?/out N!<M1) (efxmap`domain?/in _) _ _ M1=>Piy1
    (efxmap2perm/U N!<M2P (M2P+N+D=M2:efxmap`update M2P N D M2) BL CML D=>Pix M2P=>Piy2)
    (equiv/transitive (equiv/combine equiv/reflexive (EQV2)) (equiv/roll2))
    <- efxmap`update-implies-lookup MP+N+D=M M->N=D
    <- efxmap`fresh-join-left-preserves-lookup-converse N!<M1 M->N=D M1+M2=M M2->N=D
    <- efxmap`lookup-implies-fresh-update M2->N=D M2P N!<M2P M2P+N+D=M2
    <- efxmap`fresh-update2-preserves-deep-disjoint-join-converse
      N!<M1 N!<M2P M2P+N+D=M2 N!<MP MP+N+D=M M1+M2=M M1^M2 M1^M2P M1+M2P=MP
    <- efxmap`deep-disjoint-join-implies-equiv
      M1^M2P M1+M2P=MP MP=>Piy Piy1 Piy2 M1=>Piy1 M2P=>Piy2 EQV2.

%theorem efxmap`deep-disjoint-join-implies-equiv/LF
  : forall* {P} {CM} {PM} {B} {M1} {M2} {Pix} {Piy}
    forall {F: void}
    exists {Pi1} {Pi2}
    {M1=>Pi1: efxmap2perm P CM PM B M1 Pi1}
    {M2=>Pi2: efxmap2perm P CM PM B M2 Pi2}
    {EQV: (equiv ((Pix) , (Piy)) ((Pi1) , (Pi2)))}
    true.

%worlds () (efxmap`deep-disjoint-join-implies-equiv/LF _ _ _ _ _ _).
%total {} (efxmap`deep-disjoint-join-implies-equiv/LF _ _ _ _ _ _).


- : efxmap`deep-disjoint-join-implies-equiv/L
    _ M1+M2=M _ MP+N+D=M _ _ _ _
    (efxmap`domain?/out N!<M1) (efxmap`domain?/out N!<M2)
    _ _ T1 T2 EQV
    <- efxmap`join-preserves-fresh* N!<M1 N!<M2 M1+M2=M N!<M
    <- efxmap`update-implies-lookup MP+N+D=M M->N=D
    <- efxmap`fresh-lookup-not-equal N!<M M->N=D N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- efxmap`deep-disjoint-join-implies-equiv/LF F _ _ T1 T2 EQV.

- : efxmap`deep-disjoint-join-implies-equiv
    X J (efxmap2perm/U FS U BL CML DT T)
    _ _ T1 T2 EQV
    <- efxmap`domain?-total D1
    <- efxmap`domain?-total D2
    <- efxmap`deep-disjoint-join-implies-equiv/L
      X J FS U BL CML DT T D1 D2 _ _ T1 T2 EQV.

%worlds ()
(efxmap`deep-disjoint-join-implies-equiv _ _ _ _ _ _ _ _)
(efxmap`deep-disjoint-join-implies-equiv/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (T1 T2)
(efxmap`deep-disjoint-join-implies-equiv _ _ T1 _ _ _ _ _)
(efxmap`deep-disjoint-join-implies-equiv/L _ _ _ _ _ _ _ T2 _ _ _ _ _ _ _).


%theorem efxmap`deep-disjoint-join-implies-equiv-converse
  : forall* {XM1} {XM2} {XM} {P} {CM} {PM} {B} {Pi1} {Pi2}
    forall {DJ: efxmap`deep-disjoint XM1 XM2}
    {J: efxmap`join XM1 XM2 XM}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    exists {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    {EQV: (equiv ((Pi1) , (Pi2)) (Pi))}
    true.

%theorem efxmap`deep-disjoint-join-implies-equiv-converse/L
  : forall* {XM1} {XM2} {XM} {P} {CM} {PM} {B} {Pi1} {Pi2}
    forall {N1} {SZ1: efxmap`size XM1 N1}
    {N2} {SZ2: efxmap`size XM2 N2}
    {DJ: efxmap`deep-disjoint XM1 XM2}
    {J: efxmap`join XM1 XM2 XM}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    exists {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    {EQV: (equiv ((Pi1) , (Pi2)) (Pi))}
    true.

- : efxmap`deep-disjoint-join-implies-equiv-converse
    XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 Pi XM=>Pi EQV
    <- efxmap`size-total SZ1
    <- efxmap`size-total SZ2
    <- efxmap`deep-disjoint-join-implies-equiv-converse/L
      _ SZ1 _ SZ2 XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 Pi XM=>Pi EQV.

%worlds (fracvar)
(efxmap`deep-disjoint-join-implies-equiv-converse/L _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {N1 N2}
(efxmap`deep-disjoint-join-implies-equiv-converse/L N1 _ N2 _ _ _ _ _ _ _ _).

%worlds (fracvar) (efxmap`deep-disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).
%total {} (efxmap`deep-disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).


%theorem efxmap`deep-disjoint-join-implies-equiv*
  : forall* {XM1} {XM2} {XM} {P} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {DJ: efxmap`deep-disjoint XM1 XM2}
    {J: efxmap`join XM1 XM2 XM}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    exists {EQV: (equiv ((Pi1) , (Pi2)) (Pi))}
    true.

- : efxmap`deep-disjoint-join-implies-equiv*
    XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 XM=>Pi
     (equiv/transitive (EQV1) (EQV2))
    <- efxmap`deep-disjoint-join-implies-equiv-converse
    XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 _ XM=>Pi' EQV1
    <- efxmap2perm-equiv XM=>Pi' XM=>Pi
      bool`eq/ clsmap`eq/ predmap`eq/ cxt`eq/ efxmap`eq/ EQV2.

%worlds (fracvar) (efxmap`deep-disjoint-join-implies-equiv* _ _ _ _ _ _).
%total {} (efxmap`deep-disjoint-join-implies-equiv* _ _ _ _ _ _).


%theorem select-tgtmap-implies-permission-combine
  : forall* {XM1} {XM2} {XM} {GM2} {P} {CM} {PM} {B} {Pi}
    forall {R: select-tgtmap XM GM2 XM1 XM2}
    {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    exists {Pi1} {Pi2} {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    {EQV: (equiv (Pi) ((Pi1) , (Pi2)))}
    true.

- : select-tgtmap-implies-permission-combine
    XM/GM2=XM1+XM2 XM=>Pi _ _ XM1=>Pi1 XM2=>Pi2
     (Pi1+Pi2<=>Pi)
    <- select-tgtmap-implies-deep-disjoint-join XM/GM2=XM1+XM2 XM1^XM2 XM1+XM2=XM
    <- efxmap`deep-disjoint-join-implies-equiv
      XM1^XM2 XM1+XM2=XM XM=>Pi _ _ XM1=>Pi1 XM2=>Pi2 Pi1+Pi2<=>Pi.

%worlds () (select-tgtmap-implies-permission-combine _ _ _ _ _ _ _).
%total {} (select-tgtmap-implies-permission-combine _ _ _ _ _ _ _).


%theorem select-tgtmap-implies-permission-combine-converse
  :forall* {XM1} {XM2} {XM} {GM2} {P} {CM} {PM} {B} {Pi1} {Pi2}
    forall {R: select-tgtmap XM GM2 XM1 XM2}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    exists {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    {EQV: equiv ((Pi1) , (Pi2)) (Pi)}
    true.

- : select-tgtmap-implies-permission-combine-converse
    SG T1 T2 _ T EQV
    <- select-tgtmap-implies-deep-disjoint-join SG X J
    <- efxmap`deep-disjoint-join-implies-equiv-converse X J T1 T2 _ T EQV.

%worlds () (select-tgtmap-implies-permission-combine-converse _ _ _ _ _ _).
%total {} (select-tgtmap-implies-permission-combine-converse _ _ _ _ _ _). 


%theorem select-tgtmap-implies-permission-combine*
  : forall* {XM1} {XM2} {XM} {GM2} {P} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {R: select-tgtmap XM GM2 XM1 XM2}
    {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    exists {EQV: (equiv (Pi) ((Pi1) , (Pi2)))}
    true.

- : select-tgtmap-implies-permission-combine*
    XM/GM2=XM1+XM2 XM=>Pi XM1=>Pi1 XM2=>Pi2
     (equiv/symmetric (Pi1+Pi2<=>Pi))
    <- select-tgtmap-implies-deep-disjoint-join XM/GM2=XM1+XM2 XM1^XM2 XM1+XM2=XM
    <- efxmap`deep-disjoint-join-implies-equiv*
      XM1^XM2 XM1+XM2=XM XM1=>Pi1 XM2=>Pi2 XM=>Pi Pi1+Pi2<=>Pi.

%worlds () (select-tgtmap-implies-permission-combine* _ _ _ _ _).
%total {} (select-tgtmap-implies-permission-combine* _ _ _ _ _).


%theorem efxmap`leq-partition
  : forall* {XM1} {XM} {S}
    forall {LEQ: efxmap`leq XM1 XM}
    {DM: efxmap`domain XM1 S}
    exists {XM2} {XM3} {DJ: efxmap`deep-disjoint XM2 XM3}
    {J: efxmap`join XM2 XM3 XM}
    {DM: efxmap`domain XM2 S}
    true.

%worlds () (efxmap`leq-partition _ _ _ _ _ _ _).
%trustme %total { } (efxmap`leq-partition _ _ _ _ _ _ _).



% =========================================================================
% no-consume
% if a efxmap is no-consume, then its converted input and output
% permissions are the same.
% =========================================================================

%theorem apply-efx-no-consume-same-permission
  : forall* {X} {Pi} {Pi2}
    forall {NC-X: efx`not-consume X}
    {AP: apply-efx true X Pi Pi2}
    exists {AP: apply-efx false X Pi Pi2}
    true.

- : apply-efx-no-consume-same-permission
    efx`not-consume/read apply-efx/read apply-efx/read.

- : apply-efx-no-consume-same-permission
    efx`not-consume/write apply-efx/write apply-efx/write.

%worlds () (apply-efx-no-consume-same-permission _ _ _).
%total {} (apply-efx-no-consume-same-permission _ _ _).


%theorem apply-efx-no-consume-same-permission-converse
  : forall* {X} {Pi} {Pi2}
    forall {NC-X: efx`not-consume X}
    {AP: apply-efx false X Pi Pi2}
    exists {AP: apply-efx true X Pi Pi2}
    true.

- : apply-efx-no-consume-same-permission-converse
    efx`not-consume/read apply-efx/read apply-efx/read.

- : apply-efx-no-consume-same-permission-converse
    efx`not-consume/write apply-efx/write apply-efx/write.

%worlds () (apply-efx-no-consume-same-permission-converse _ _ _).
%total {} (apply-efx-no-consume-same-permission-converse _ _ _).


%theorem inner-efxmap`no-consume-same-permission
  : forall* {O} {FM} {PM} {M} {Pi}
    forall {NC-M: inner-efxmap`no-consume M}
    {M=>Pi: inner-efxmap2perm true O FM PM M Pi}
    exists {M=>Pi: inner-efxmap2perm false O FM PM M Pi}
    true.

- : inner-efxmap`no-consume-same-permission
    inner-efxmap`no-consume/0 inner-efxmap2perm/0 inner-efxmap2perm/0.

- : inner-efxmap`no-consume-same-permission NC-M
    (inner-efxmap2perm/U N!<MP MP+N+X=M FM->N=T T=>PF X=>PF MP=>P2)
    (inner-efxmap2perm/U N!<MP MP+N+X=M FM->N=T T=>PF X=>PF2 MP=>P2P)
    <- inner-efxmap`update-implies-lookup MP+N+X=M M->N=X
    <- inner-efxmap`lookup-implies-not-consume NC-M M->N=X NC-X
    <- inner-efxmap`fresh-update-preserves-no-consume-converse
      NC-M N!<MP MP+N+X=M NC-MP
    <- inner-efxmap`no-consume-same-permission NC-MP MP=>P2 MP=>P2P
    <- apply-efx-no-consume-same-permission NC-X X=>PF X=>PF2.

%worlds () (inner-efxmap`no-consume-same-permission _ _ _).
%total (T) (inner-efxmap`no-consume-same-permission _ T _).


%theorem inner-efxmap`no-consume-same-permission-converse
  : forall* {O} {FM} {PM} {M} {Pi}
    forall {NC-M: inner-efxmap`no-consume M}
    {M=>Pi: inner-efxmap2perm false O FM PM M Pi}
    exists {M=>Pi: inner-efxmap2perm true O FM PM M Pi}
    true.

- : inner-efxmap`no-consume-same-permission-converse
    inner-efxmap`no-consume/0 inner-efxmap2perm/0 inner-efxmap2perm/0.

- : inner-efxmap`no-consume-same-permission-converse NC-M
    (inner-efxmap2perm/U N!<MP MP+N+X=M FM->N=T T=>PF X=>PF MP=>P2)
    (inner-efxmap2perm/U N!<MP MP+N+X=M FM->N=T T=>PF X=>PF2 MP=>P2P)
    <- inner-efxmap`update-implies-lookup MP+N+X=M M->N=X
    <- inner-efxmap`lookup-implies-not-consume NC-M M->N=X NC-X
    <- inner-efxmap`fresh-update-preserves-no-consume-converse
      NC-M N!<MP MP+N+X=M NC-MP
    <- inner-efxmap`no-consume-same-permission-converse NC-MP MP=>P2 MP=>P2P
    <- apply-efx-no-consume-same-permission-converse NC-X X=>PF X=>PF2.

%worlds () (inner-efxmap`no-consume-same-permission-converse _ _ _).
%total (T) (inner-efxmap`no-consume-same-permission-converse _ T _).


%theorem efxmap`no-consume-same-permission
  : forall* {XM} {CM} {PM} {B} {Pi}
    forall {NC-XM: efxmap`no-consume XM}
    {XM=>Pi: efxmap2perm true CM PM B XM Pi}
    exists {XM=>Pi: efxmap2perm false CM PM B XM Pi}
    true.

- : efxmap`no-consume-same-permission
    efxmap`no-consume/0 efxmap2perm/0 efxmap2perm/0.

- : efxmap`no-consume-same-permission NC-XM
    (efxmap2perm/U N!<XMP XMP+N+M=XM B->N CM->C=FM T+M=>Pi1 T+XMP=>Pi2)
    (efxmap2perm/U N!<XMP XMP+N+M=XM B->N CM->C=FM F+M=>Pi1 F+XMP=>Pi2)
    <- efxmap`update-implies-lookup XMP+N+M=XM XM->N=M
    <- efxmap`lookup-implies-no-consume NC-XM XM->N=M NC-M
    <- inner-efxmap`no-consume-same-permission NC-M T+M=>Pi1 F+M=>Pi1
    <- efxmap`fresh-update-preserves-no-consume-converse
      NC-XM N!<XMP XMP+N+M=XM NC-XMP
    <- efxmap`no-consume-same-permission NC-XMP T+XMP=>Pi2 F+XMP=>Pi2.

%worlds () (efxmap`no-consume-same-permission _ _ _).
%total (T) (efxmap`no-consume-same-permission _ T _).


%theorem efxmap`no-consume-same-permission-converse
  : forall* {XM} {CM} {PM} {B} {Pi}
    forall {NC-XM: efxmap`no-consume XM}
    {XM=>Pi: efxmap2perm false CM PM B XM Pi}
    exists {XM=>Pi: efxmap2perm true CM PM B XM Pi}
    true.

- : efxmap`no-consume-same-permission-converse
    efxmap`no-consume/0 efxmap2perm/0 efxmap2perm/0.

- : efxmap`no-consume-same-permission-converse NC-XM
    (efxmap2perm/U N!<XMP XMP+N+M=XM B->N CM->C=FM F+M=>Pi1 F+XMP=>Pi2)
    (efxmap2perm/U N!<XMP XMP+N+M=XM B->N CM->C=FM T+M=>Pi1 T+XMP=>Pi2)
    <- efxmap`update-implies-lookup XMP+N+M=XM XM->N=M
    <- efxmap`lookup-implies-no-consume NC-XM XM->N=M NC-M
    <- inner-efxmap`no-consume-same-permission-converse NC-M F+M=>Pi1 T+M=>Pi1
    <- efxmap`fresh-update-preserves-no-consume-converse
      NC-XM N!<XMP XMP+N+M=XM NC-XMP
    <- efxmap`no-consume-same-permission-converse NC-XMP F+XMP=>Pi2 T+XMP=>Pi2.

%worlds () (efxmap`no-consume-same-permission-converse _ _ _).
%total (T) (efxmap`no-consume-same-permission-converse _ T _).


%theorem equiv-empty-implies-permission-equiv
  : forall* {CM} {PM} {B} {G} {M} {Pi}
    forall {M2G: efxmap2tgtmap M G}
    {EG: equiv-empty G}
    {M2P: efxmap2perm false CM PM B M Pi}
    exists {EQV: equiv (Pi) empty}
    true.

- : equiv-empty-implies-permission-equiv
    efxmap2tgtmap/0 equiv-empty/0 efxmap2perm/0 (equiv/reflexive) .

- : equiv-empty-implies-permission-equiv
    (efxmap2tgtmap/U MP=>GP DM-D=S N!<MP MP+N+D=M GP+N+S=>G) EE-G M=>Pi
     (equiv/transitive3
      (equiv/symmetric (Pi1+Pi2<=>Pi))
      (equiv/combine (EQV1) (EQV2))
      (equiv/identity))
    <- efxmap2tgtmap-preserves-fresh N!<MP MP=>GP N!<GP
    <- equiv-empty/U-inversion EE-G N!<GP GP+N+S=>G EE-GP S-EQx
    <- set`eq-symmetric S-EQx S-EQ
    <- inner-efxmap`domain-respects-eq DM-D=S inner-efxmap`eq/ S-EQ DM-D=0
    <- inner-efxmap`domain-empty-implies-empty DM-D=0 D-EQ
    <- efxmap2perm/U-inversion M=>Pi N!<MP MP+N+D=M _ _ _
      BL _ CML Pi1 D=>Pi1 Pi2 MP=>Pi2 Pi1+Pi2<=>Pi
    <- inner-efxmap2perm-equiv D=>Pi1 inner-efxmap2perm/0
      bool`eq/ object`eq/ fldmap`eq/ predmap`eq/ D-EQ EQV1
    <- equiv-empty-implies-permission-equiv MP=>GP EE-GP MP=>Pi2 EQV2.

%worlds () (equiv-empty-implies-permission-equiv _ _ _ _).
%total (T) (equiv-empty-implies-permission-equiv T _ _ _).


%theorem can-duplicate-borrow
  : forall* {PM} {NN} {C} {PF}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    exists {IMP: {o} implies (PF o) ((PF o) , (PF o))}
    true.

- : can-duplicate-borrow
    (ty2perm/ _ nn2perm/yes annot2perm/borrow)
    ([_] implies/trans5
      (implies/combine
        (implies/duplicate)
        (implies/combine
          (implies/reflexive)
          (implies/duplicate)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/equiv equiv/roll3))
      (implies/equiv equiv/associate)
      (implies/combine
        (implies/combine
          (implies/reflexive)
          (implies/equiv
            (equiv/transitive
              (equiv/symmetric equiv/identity)
              (equiv/commute))))
        (implies/reflexive))).

- : can-duplicate-borrow
    (ty2perm/ _ nn2perm/may annot2perm/borrow)
    ([_] implies/trans3
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/trans3
          (implies/combine
            (implies/reflexive)
            (implies/duplicate))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/reflexive)
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/identity)
                (equiv/commute))))))
      (implies/cond-distribute)
      (implies/equiv equiv/commute)).

%worlds () (can-duplicate-borrow _ _).
%total {} (can-duplicate-borrow _ _).


%theorem can-duplicate-shared
  : forall* {PM} {NN} {C} {PF}
    forall {T2PF: ty2perm PM (ty/ NN annot/shared C) PF}
    exists {IMP: {o} implies (PF o) ((PF o) , (PF o))}
    true.

- : can-duplicate-shared
    (ty2perm/ _ nn2perm/may annot2perm/shared)
    ([_] implies/trans3
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/trans
          (implies/combine2conj)
          (implies/duplicate)))
      (implies/cond-distribute)
      (implies/combine
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/conj2combine))
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/conj2combine)))).

- : can-duplicate-shared
    (ty2perm/ _ nn2perm/yes annot2perm/shared)
    ([_] implies/trans4
      (implies/combine
        (implies/reflexive)
        (implies/combine2conj))
      (implies/combine2conj)
      (implies/duplicate)
      (implies/combine
        (implies/trans
          (implies/conj2combine)
          (implies/combine
            (implies/reflexive)
            (implies/conj2combine)))
        (implies/trans
          (implies/conj2combine)
          (implies/combine
            (implies/reflexive)
            (implies/conj2combine))))).

%worlds () (can-duplicate-shared _ _).
%total {} (can-duplicate-shared _ _).


%theorem clsmap-cxt-lookup-implies-ty2perm
  : forall* {CM} {PM} {T} {B} {Pi} {O}
    forall {CM-B: clsmap-cxt CM B}
    {BL: cxt`lookup B O T}
    {B2P: cxt2perm CM PM B Pi}
    exists {PF} {T2PF: ty2perm PM T PF}
    {EQV: implies Pi ((PF O) , Pi)}
    true.

- : clsmap-cxt-lookup-implies-ty2perm
    (clsmap-cxt/cons/b _ _)
    (cxt`lookup/hit:cxt`lookup _ O _) (cxt2perm/cons _ T2PF) _ T2PF
    (implies/trans
      (implies/combine
        (IMP O) (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate)))
    <- can-duplicate-borrow T2PF IMP.

- : clsmap-cxt-lookup-implies-ty2perm
    (clsmap-cxt/cons/s _ _)
    (cxt`lookup/hit:cxt`lookup _ O _) (cxt2perm/cons _ T2PF) _ T2PF
    (implies/trans
      (implies/combine
        (IMP O) (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate)))
    <- can-duplicate-shared T2PF IMP.

- : clsmap-cxt-lookup-implies-ty2perm
    (clsmap-cxt/cons/b CM-B _)
    (cxt`lookup/miss BL _) (cxt2perm/cons B2P _) _ T2PF
    (implies/trans
      (implies/combine (implies/reflexive) (IMP))
      (implies/equiv (equiv/roll2)))
    <- clsmap-cxt-lookup-implies-ty2perm CM-B BL B2P _ T2PF IMP.

- : clsmap-cxt-lookup-implies-ty2perm
    (clsmap-cxt/cons/s CM-B _)
    (cxt`lookup/miss BL _) (cxt2perm/cons B2P _) _ T2PF
    (implies/trans
      (implies/combine (implies/reflexive) (IMP))
      (implies/equiv (equiv/roll2)))
    <- clsmap-cxt-lookup-implies-ty2perm CM-B BL B2P _ T2PF IMP.

%worlds () (clsmap-cxt-lookup-implies-ty2perm _ _ _ _ _ _).
%total (B) (clsmap-cxt-lookup-implies-ty2perm _ B _ _ _ _).