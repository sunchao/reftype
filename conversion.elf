%%% converting *map to permission

% make disjunction of objequal facts for object targets.

set2facts : cxt -> object -> set -> formula -> type.

set2facts/0 : set2facts _ _ set/0 f.

set2facts/+
  : set2facts B O S (disj (objequal O O') G)
    <- set`add S' L S
    <- cxt-lookup-index B L O' _
    <- set2facts B O S' G.


% convert a efxmap to a set of permissions.

efxmap2perm : clsmap -> predmap -> cxt -> efxmap -> permission -> type.

inner-efxmap2perm : object -> fldmap -> predmap ->
    inner-efxmap -> permission -> type.

inner-efxmap2perm/0 : inner-efxmap2perm _ _ _ inner-efxmap/0 empty.

inner-efxmap2perm/+ 
  : inner-efxmap2perm O FM PM
    (inner-efxmap/+ F X M) (unitperm (precise-exists O F PF) , Pi) 
    <- fldmap`lookup FM F T
    <- ty2perm PM T PF
    <- inner-efxmap`shift F M MP
    <- inner-efxmap2perm O FM PM MP Pi.


efxmap2perm/0 : efxmap2perm _ _ _ efxmap/0 empty.

efxmap2perm/+
  : efxmap2perm CM PM B (efxmap/+ L M XM) (Pi1 , Pi2)
    <- cxt-lookup-index B L O (ty/ _ _ C)
    <- clsmap`lookup CM C FM
    <- inner-efxmap2perm O FM PM M Pi1
    <- efxmap`shift L XM XMP
    <- efxmap2perm CM PM B XMP Pi2.


%{ if tgtmap is empty, we shouldn't generate field
  permissions, since otherwise we may have permission like:

   (allperm o) , (unitperm (encumbered (allperm o) empty))

  which is obviously unsound. }%

tgtmap2perm : bool -> (object -> permission) -> 
  (object -> formula) -> permission -> permission -> expr-output -> type.
  
tgtmap2perm/false
  : tgtmap2perm false PF GF _ Pi2
    (output/exists [o]
      (output/expr o
        (unitperm (nonlinear (GF o)) , Pi2))).

tgtmap2perm/+
  : tgtmap2perm true PF GF Pi1 Pi2
    (output/exists [o]
      (output/exists [r]
        (output/expr o
          (unitperm (nonlinear (disj (objequal o r) (GF o))) ,
            ((PF r) , (unitperm (encumbered (PF r) Pi1))) ,
            ((allperm null) , Pi2))))).


%abbrev nested-perm : object -> permission =
    [r] (unitperm (nonlinear (nested (allperm r) null all))).


is-tgtmap-empty : tgtmap -> bool -> type.

is-tgtmap-empty/true : is-tgtmap-empty tgtmap/0 true.

is-tgtmap-empty/false : is-tgtmap-empty (tgtmap/+ _ _ _) false.


%%% This is WRONG: it doesn't handle consume/nested effects.

%%% we need to include (allperm r) when value is unique 

reftype+efxmap2output : clsmap -> predmap -> cxt -> 
    reftype -> efxmap -> expr-output -> type.

reftype+efxmap2output/s_
  : reftype+efxmap2output CM PM B
    (reftype/ (ty/ NN annot/shared C) _) XM
    (output/exists [r] 
      (output/expr r ((PF CP r) , ((allperm null) , Pi))))
    <- nn2perm NN ([r] (nested-perm r)) PF
    <- predmap`lookup PM C CP
    <- efxmap2perm CM PM B XM Pi.

reftype+efxmap2output/us
  : reftype+efxmap2output CM PM B
    (reftype/ (ty/ NN annot/unique C) reftgts/shared) XM
    (output/exists [r]
      (output/expr r
        ((PF CP r) , 
          ((unitperm (encumbered (PF CP r) (allperm null))) , Pi))))
    <- nn2perm NN ([r] (allperm r)) PF
    <- predmap`lookup PM C CP
    <- efxmap2perm CM PM B XM Pi.

reftype+efxmap2output/uu
  : reftype+efxmap2output CM PM B
    (reftype/ (ty/ NN annot/unique C) (reftgts/unique S GM)) XM OUT
    <- nn2perm NN ([r] (allperm r)) PF
    <- predmap`lookup PM C CP
    <- efxmap`remove-tgtmap XM GM XM1 XM2
    <- efxmap2perm CM PM B XM1 Pi1
    <- efxmap2perm CM PM B XM2 Pi2
    <- ({o} set2facts B o S (GF o))
    <- is-tgtmap-empty GM BO
    <- tgtmap2perm BO ([o] PF CP o) GF Pi1 Pi2 OUT.


%%% a well-formed context shouldn't contain null type.

cxt2facts : predmap -> cxt -> permission -> type.

cxt2facts/nil : cxt2facts PM cxt/nil empty.

cxt2facts/cons/shared
  : cxt2facts PM
    (cxt/cons O vtype/shared _ B) ((PF CP O) , Pi)
    <- nn2perm NN ([o] (nested-perm o)) PF
    <- predmap`lookup PM C CP
    <- cxt2facts PM B Pi.

cxt2facts/cons/unique
  : cxt2facts PM
    (cxt/cons O (vtype/unique N) T B) ((one-predcall CP O) , Pi)
    <- predmap`lookup PM C CP
    <- cxt2facts PM B Pi.

	
%{%


%%% methty => proctype

methty2proctype* : clsmap -> predmap -> permission
  -> permission -> methty -> proctype -> type.

methty2proctype/base 
  : methty2proctype* CM PM Pin Pout (methty/base T)
    (proctype/base Pin
      (output/exists [o]
	(output/expr o ((PF o) , Pout))))
    <- ty2perm PM T ([o] PF o).
	      

set2perm : clsmap -> predmap -> fldmap -> set ->
  (object -> permission) -> type.

set2perm/0 : set2perm _ _ _ set/0 ([_] empty).

set2perm/+
  : set2perm CM PM FM S
    ([o] (unitperm (precise-exists o F PF)) , (Pi o))
    <- set`add S' F S
    <- fldmap`lookup FM F T
    <- ty2perm PM T ([o] PF o)
    <- set2perm CM PM FM S' ([o] Pi o).




% here if the argument type is unique, then the read/write sets
% associated with it can only be empty. 
methty2proctype/args 
  : methty2proctype* CM PM Pin Pout (methty/arg MT (ty/ NN A C) R W)
    (proctype/arg ([r] PTF r))
    <- ty2perm PM (ty/ NN A C) ([o] PF o)
    <- clsmap`lookup CM C FM
    <- set2perm CM PM FM R ([o] RPF o)
    <- set2perm CM PM FM W ([o] WPF o)
    <- ({o} methty2proctype* CM PM
         (((PF o) , (RPF o) , (WPF o)) , Pin) 
         (((RPF o) , (WPF o)) , Pout) MT (PTF o)).

%abbrev methty2proctype
   = [CM][PM][MT][PT] methty2proctype* CM PM empty empty MT PT.


consty2proctype*
  : clsmap -> predmap -> fldmap -> permission -> 
  permission -> methty -> (object -> proctype) -> type.

consty2proctype/base
  : consty2proctype* CM PM FM Pin Pout
    (methty/base T)
    ([t] (proctype/base
	   (Pin , 
	     (unitperm (nonlinear (neg (objequal t null)))) , 
	     (OS t))
	   (output/exists [t]
	     (output/expr t ((PF t) , Pout)))))
    <- ty2perm PM T ([o] PF o)
    <- fldmap`domain FM S
    <- ({t} allocFields t S (OS t)).

consty2proctype/args
  : consty2proctype* CM PM FM Pin Pout
    (methty/arg CT (ty/ NN A C) R W)
    ([t] (proctype/arg ([r] PTF t r)))
    <- ty2perm PM (ty/ NN A C) ([r] PF r)
    <- clsmap`lookup CM C FM'
    <- set2perm CM PM FM' R ([o] RPF o)
    <- set2perm CM PM FM' W ([o] WPF o)
    <- ({r} consty2proctype* CM PM FM 
	 (((PF r) , (RPF r) , (WPF r)) , Pin)
	 (((RPF r) , (WPF r)) , Pout) CT ([t] PTF t r)).

%abbrev consty2proctype
   = [CM][PM][FM][CT][PTF] consty2proctype* CM PM FM empty empty CT PTF.


%%% methmap => progtype

methmap2progtype : clsmap -> predmap -> methmap -> progtype -> type.

methmap2progtype/0 : methmap2progtype _ _ methmap/0 progtype`map/0.

methmap2progtype/+/const
  : methmap2progtype CM PM MM W
    <- methmap`update 
      MM' C (methty/arg CT (ty/ nonnull/yes annot/unique C) _ _) MM
    <- methmap`fresh MM' C
    <- clsmap`lookup CM C FM
    <- consty2proctype CM PM FM CT ([t] PTF t)
    <- methmap2progtype CM PM MM' W'
    <- progtype`update W' C (proctype/arg PTF) W.

methmap2progtype/+/meth
  : methmap2progtype CM PM MM W
    <- methmap`update MM' C MT MM
    <- methmap`fresh MM' C
    <- clsmap`fresh CM C
    <- methty2proctype CM PM MT PT
    <- methmap2progtype CM PM MM' W'
    <- progtype`update W' C PT W.


%%% environment => progtype

env2progtype : clsmap -> methmap -> progtype -> type.

env2progtype/
  : env2progtype CM MM W
    <- clsmap2predmap CM PM
    <- methmap2progtype CM PM MM W.

%}%

%%% Theorems

%%% set2facts

%theorem set-cxt-implies-set2facts :
    forall* {B} {O} {S}
    forall  {S-B: set-cxt S B}
    exists  {G} {S2G: set2facts B O S G}
    true.

- : set-cxt-implies-set2facts set-cxt/0 f set2facts/0.

- : set-cxt-implies-set2facts 
    (set-cxt/+ S-B SH B-L) _
    (set2facts/+ S=>G B-L A)
    <- set-cxt-implies-set2facts S-B _ S=>G
    <- set`shift-implies-update SH A.

%worlds () (set-cxt-implies-set2facts _ _ _).
%total (S-B) (set-cxt-implies-set2facts S-B _ _).