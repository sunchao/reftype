%%% Converting *map to permission

%%% ======================= Abbreviations =====================================

%abbrev scale-fldperm
  : fraction -> object -> nat -> (object -> permission) -> permission
  = [Q][O][F][PF]
    (scale Q (unitperm (precise-exists O F ([x] PF x)))).


%%% ======================= Definitions =======================================

%%% Convert a set of object locations to a conditional of objequal
%%% facts. Used in output.

set2cond : cxt -> object -> set -> permission -> type.

set2cond/0 : set2cond _ _ set/0 (unitperm (nonlinear (neg t))).

set2cond/U : set2cond B O S (unitperm (conditional (objequal O O') empty Pi))
             <- cxt`lookup B N (cxt-info/ O' _)
             <- set`not-member S' N
             <- set`add S' N S
             <- set2cond B O S' Pi.


%%% Apply nonnull-ness

apply-nn : nonnull -> (object -> permission) -> (object -> permission) -> type.

apply-nn/may : apply-nn nn/may ([x] PF x)
               ([x] unitperm (conditional (objequal x null) empty (PF x))).

apply-nn/yes : apply-nn nn/yes ([x] PF x) ([x] PF x).


%%% A whole object can be consumed, for instance, in x.f = a, object
%%% a is consumed. In this case, we treated as if all of a's field are
%%% consumed. But, we also need the encumbered permission:
%%%  \forall f (P(a.f) encumbered-in P(a.all))
%%%
%%% Given a set of objects, the relation "make-encumbered" construct
%%% such an encumbered permission for each object, using "fldmap2perm".

fldmap2perm : predmap -> object -> fldmap -> set -> permission -> type.

fldmap2perm/0 : fldmap2perm _ _ _ set/0 empty.

fldmap2perm/U
  : fldmap2perm PM O FM S' Pi
    -> set`not-member S' F
    -> set`add S' F S
    -> fldmap`lookup FM F T
    -> ty2perm PM T PF
    -> fldmap2perm PM O FM S (unitperm (precise-exists O F PF) , Pi).


fldmap2perm2 : predmap -> object -> fldmap -> permission -> type.

fldmap2perm2/ : fldmap`domain FM FS
                -> fldmap2perm PM O FM FS Pi
                -> fldmap2perm2 PM O FM Pi.


%%% Convert a type in a context to a permission
%%% The interesting case is unique type, for which we convert to an
%%% encumbered permissions. The field permissions are recorded in the
%%% capabilities, together with which we can restore the whole permission
%%% for the object, and then used for consumption.

ty2perm2 : clsmap -> predmap -> ty -> (object -> permission) -> type.

ty2perm2/null : ty2perm2 _ _ ty/null ([x] unitperm (nonlinear (objequal x null))).

ty2perm2/shared : ty2perm PM (ty/ NN annot/shared C) PF
                  -> ty2perm2 _ PM (ty/ NN annot/shared C) ([x] PF x).

ty2perm2/borrow : ty2perm PM (ty/ NN annot/borrow C) PF
                  -> ty2perm2 _ PM (ty/ NN annot/borrow C) ([x] PF x).

ty2perm2/unique : clsmap`lookup CM C FM
                  -> predmap`lookup PM C CP
                  -> ({x} fldmap2perm2 PM x FM (PF x))
                  -> apply-nn NN ([x] (unitperm (encumbered (PF x)
                       (combine (obj-ne-null x)
                         (combine (allperm x) (one-predcall CP x)))))) ([x] Pi2 x)
                  -> ty2perm PM (ty/ NN annot/borrow C) ([x] (Pi x))
                  -> ty2perm2 CM PM (ty/ NN annot/unique C) ([x] (Pi x) , (Pi2 x)).


%%% Convert the explicit context to permissions, which
%%% consists of non-null information, class predicate, and,
%%% for shared the nesting facts, for each parameter.
%%% Notice that, unique has the same permission as borrowed
%%% parameter. We use a separate procedure to generate the
%%% encumbered permission for them. So, the cxt should only
%%% contain borrowed and shared types.

cxt2perm : clsmap -> predmap -> cxt -> permission -> type.

cxt2perm/0 : cxt2perm _ _ cxt/0 empty.

cxt2perm/U : cxt2perm CM PM B' Pi2
             -> cxt`fresh B' N
             -> cxt`update B' N (cxt-info/ O T) B
             -> ty2perm2 CM PM T PF
             -> cxt2perm CM PM B ((PF O) , Pi2).


%%% Convert a efx to a fraction, which is either half or one.
%%% This function is partial, and only applies to read and write.

cap2frac : cap -> fraction -> type.

cap2frac/read : cap2frac cap/read half.

cap2frac/write : cap2frac cap/write (fraction/ one).


%%% Create field permission

create-fldperm : clsmap -> predmap -> nat -> nat -> (object -> permission) -> type.

create-fldperm/ : clsmap`lookup CM C FM
                  -> fldmap`lookup FM F T
                  -> ty2perm PM T PF
                  -> create-fldperm CM PM C F ([x] PF x).

%%% Convert a capmap to permissions. Each entry ((O, F), X) in
%%% the capmap will be converted to a packed field permission with
%%% the effect X been applied to it.
%%% Note that, the object O in this case must be not-null, otherwise
%%% we cannot do anything on the field F.

capmap2perm : clsmap -> predmap -> cxt -> capmap -> permission -> type.

capmap2perm/0 : capmap2perm _ _ _ capmap/0 empty.

capmap2perm/U : capmap2perm CM PM B M' Pi2
                -> nat2pair K (pair/ N F)
                -> cxt`lookup B N (cxt-info/ O (ty/ NN _ C))
                -> create-fldperm CM PM C F PF
                -> cap2frac X Q
                -> apply-nn NN ([x] scale-fldperm Q x F PF) ([x] Pi1 x)
                -> capmap`fresh M' K
                -> capmap`update M' K X M
                -> capmap2perm CM PM B M ((Pi1 O) , Pi2).



%%% Convert an input environment (context and capabilities) to a set of
%%%  input permissions.

env2input : clsmap -> predmap -> env -> permission -> type.

env2input/ : cxt2perm CM PM B PiB
             -> capmap2perm CM PM B M PiM
             -> env2input CM PM (env/ B M) (PiB , PiM).


%%% Convert result to output permissions.

result2output : clsmap -> predmap -> expr-result -> expr-output -> type.

result2output/shared
  : ty2perm PM (ty/ NN annot/shared C) PF
    -> cxt2perm CM PM B Pi_B
    -> capmap2perm CM PM B M Pi_M
    -> result2output CM PM (result/expr (reftype/ NN C targets/shared) (env/ B M))
      (output/exists [r]
        (output/expr r (combine Pi_B (combine (PF r) Pi_M)))).

result2output/unique/1
  : set`size OS (nat`s _)
    -> capmap`size FS nat`z
    -> ty2perm PM (ty/ NN annot/borrow C) PF
    -> ({x} set2cond B x OS (GF x))
    -> cxt2perm CM PM B Pi_B
    -> capmap2perm CM PM B M Pi_M
    -> result2output CM PM
      (result/expr (reftype/ NN C (targets/unique OS FS)) (env/ B M))
      (output/exists [r]
        (output/expr r (combine Pi_B (combine (PF r) (combine (GF r) Pi_M))))).

result2output/unique/2
  : capmap`size M2 (nat`s _)
    -> ty2perm PM (ty/ NN annot/unique C) PF
    -> ({x} set2cond B x OS (GF x))
    -> cxt2perm CM PM B Pi_B
    -> capmap2perm CM PM B M1 Pi_M1
    -> capmap2perm CM PM B M2 Pi_M2
    -> capmap-min-cap M2 X
    -> cap2frac X Q
    -> result2output CM PM
      (result/expr (reftype/ NN C (targets/unique OS M2)) (env/ B M1))
      (output/exists [o]
        (output/exists [r]
          (output/expr o
            (combine Pi_B
              (combine
                (unitperm
                  (conditional (objequal o r) empty (GF o)))
                (combine (scale Q (PF r))
                  (combine (unitperm (encumbered
                                       (scale Q (PF r)) Pi_M2)) Pi_M1))))))).



%%% Convert a method map into a progtype.

methmap2progtype : clsmap -> predmap -> methmap -> progtype -> type.



%%% Theorems

%% 1, theorems about set2cond

%theorem false-implies-set2cond
  : forall* {O} {S} {G} {B}
    forall {V:void}
    exists {S=>G: set2cond B O S G}
    true.

%worlds (objvar) (false-implies-set2cond _ _).
%total {} (false-implies-set2cond _ _).


%theorem set2cond-respects-eq
  : forall* {S1} {S2} {O1} {O2} {G1} {G2} {B1} {B2}
    forall {S2G: set2cond B1 O1 S1 G1}
    {E: cxt`eq B1 B2} {E: object`eq O1 O2} {E: set`eq S1 S2}
    {E: permission`eq G1 G2}
    exists {S2G2: set2cond B2 O2 S2 G2}
    true.

- : set2cond-respects-eq S2G cxt`eq/ object`eq/ set`eq/ permission`eq/ S2G.

%worlds (objvar) (set2cond-respects-eq _ _ _ _ _ _).
%total {} (set2cond-respects-eq _ _ _ _ _ _).


%theorem clsmap-cxt-unique-objset-implies-set2cond
  : forall* {CM} {B} {NN} {C} {S} {O}
    forall {CM-B-S: clsmap-cxt-unique-objset CM B NN C S}
    exists {G} {S2G: set2cond B O S G}
    true.

- : clsmap-cxt-unique-objset-implies-set2cond
    clsmap-cxt-unique-objset/0 _ set2cond/0.

- : clsmap-cxt-unique-objset-implies-set2cond
    (clsmap-cxt-unique-objset/U CM-B-S' BL _ F U) _
    (set2cond/U S2G' U F BL)
    <- clsmap-cxt-unique-objset-implies-set2cond CM-B-S' _ S2G'.

%worlds (objvar) (clsmap-cxt-unique-objset-implies-set2cond _ _ _).
%total (CM) (clsmap-cxt-unique-objset-implies-set2cond CM _ _).


%theorem same-class-implies-set2cond
  : forall* {B} {S} {C} {O}
    forall {SOC: same-class B S C}
    exists {G} {S2G: set2cond B O S G}
    true.

- : same-class-implies-set2cond same-class/0 _ set2cond/0.

- : same-class-implies-set2cond (same-class/U SOC' F U BL)
    _ (set2cond/U S2G' U F BL)
    <- same-class-implies-set2cond SOC' _ S2G'.

%worlds (objvar) (same-class-implies-set2cond _ _ _).
%total (B) (same-class-implies-set2cond B _ _).


%theorem clsmap-cxt-objset-implies-set2cond
  : forall* {CM} {B} {S} {O}
    forall {CM-B-S: clsmap-cxt-objset CM B S}
    exists {G} {S2G: set2cond B O S G}
    true.

- : clsmap-cxt-objset-implies-set2cond clsmap-cxt-objset/0 _ set2cond/0.

- : clsmap-cxt-objset-implies-set2cond
    (clsmap-cxt-objset/U CM-B-S' BL CML FS U)
    _ (set2cond/U S'2G U FS BL)
    <- clsmap-cxt-objset-implies-set2cond CM-B-S' _ S'2G.

%worlds () (clsmap-cxt-objset-implies-set2cond _ _ _).
%total (CM) (clsmap-cxt-objset-implies-set2cond CM _ _).


%theorem set2cond/U-inversion
  : forall* {B} {O} {S} {SP} {G} {N}
    forall {S=>G: set2cond B O S G}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    exists {GP} {SP=>GP: set2cond B O SP GP}
    {O'} {T} {BL: cxt`lookup B N (cxt-info/ O' T)}
    {IMP1: implies G (unitperm (conditional (objequal O O') empty GP))}
    {IMP2: implies (unitperm (conditional (objequal O O') empty GP)) G}
    true.

%theorem set2cond/U-inversion/L
  : forall* {B} {O} {S} {SP} {N} {S1} {N1} {G1} {P} {O1'} {T1}
    forall {NM1: set`not-member S1 N1}
    {A1: set`add S1 N1 S}
    {S1=>G1: set2cond B O S1 G1}
    {BL: cxt`lookup B N1 (cxt-info/ O1' T1)}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    {E?: nat`eq? N N1 P}
    exists {GP} {SP=>GP: set2cond B O SP GP}
    {O'} {T} {BL: cxt`lookup B N (cxt-info/ O' T)}
    {IMP1: implies
           (unitperm (conditional (objequal O O1') empty G1))
           (unitperm (conditional (objequal O O') empty GP))}
    {IMP2: implies
           (unitperm (conditional (objequal O O') empty GP))
           (unitperm (conditional (objequal O O1') empty G1))}
    true.

- : set2cond/U-inversion
    (set2cond/U
      (S2G1:set2cond B O S1 G1)
      (U1:set`add S1 N1 S)
      (F1:set`not-member S1 N1)
      (BL1:cxt`lookup B N1 (cxt-info/ O1 T1)))
    (F2:set`not-member SP N)
    (U2:set`add SP N S) GP S2G O' T BL IMP1 IMP2
    <- nat`eq?-total E?
    <- set2cond/U-inversion/L F1 U1 S2G1 BL1 F2 U2 E? GP S2G O' T BL IMP1 IMP2.

- : set2cond/U-inversion/L F1 U1 S2G1 BL1 F2 U2 nat`eq?/yes _ S2G _ _ BL1
    (implies/reflexive) (implies/reflexive)
    <- set`not-member-add-cancels F1 U1 F2 U2 nat`eq/ set`eq/ S1=S2
    <- set2cond-respects-eq S2G1 cxt`eq/ object`eq/ S1=S2 permission`eq/ S2G.

%% Need this in implication.elf:
%% (x == o1 ? empty : (x == o2 ? empty : Pi)) ==>
%% (x == o2 ? empty : (x == o1 ? empty : Pi))
% - : set2cond/U-inversion/L F1 U1 S2G1 BL1 F2 U2 (nat`eq?/no N<>N1) _
%     (set2cond/U S2G U4 F4 BL1) _ _ BL3
%     <- set`add-commutes-converse U2 U1 N<>N1 _ U4 U3
%     <- set`add-preserves-not-member-converse F2 U4 F3
%     <- set`add-preserves-not-member-converse F1 U3 F4
%     <- set2cond/U-inversion S2G1 F3 U3 _ S2G _ _ BL3 IMP1 IMP2.

%worlds (objvar) (set2cond/U-inversion _ _ _ _ _ _ _ _ _ _)
  (set2cond/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (N N1) (set2cond/U-inversion N _ _ _ _ _ _ _ _ _)
  (set2cond/U-inversion/L _ _ N1 _ _ _ _ _ _ _ _ _ _ _).


%theorem set2cond-implies
  : forall* {B} {O1} {O2} {S1} {S2} {G1} {G2}
    forall {S1=>G1: set2cond B O1 S1 G1}
    {S2=>G2: set2cond B O2 S2 G2}
    {E: object`eq O1 O2} {E: set`eq S1 S2}
    exists {IMP1: implies G1 G2} {IMP2: implies G2 G1}
    true.

%theorem set2cond-implies/L
  : forall* {O1} {O1'} {O2} {O2'} {G1} {G2}
    forall {OE: object`eq O1 O2} {OE: object`eq O1' O2'}
    {IMP1: implies G1 G2} {IMP2: implies G2 G1}
    exists {IMP1: implies
                  (unitperm (conditional (objequal O1 O1') empty G1))
                  (unitperm (conditional (objequal O2 O2') empty G2))}
    {IMP2: implies (unitperm (conditional (objequal O2 O2') empty G2))
           (unitperm (conditional (objequal O1 O1') empty G1))}
    true.

- : set2cond-implies/L object`eq/ object`eq/ IMP1 IMP2
    (implies/cond-inner bimplies/reflexive bimplies/reflexive
      implies/reflexive IMP1)
    (implies/cond-inner bimplies/reflexive bimplies/reflexive
      implies/reflexive IMP2).

- : set2cond-implies
    set2cond/0 set2cond/0 object`eq/ set`eq/ implies/reflexive implies/reflexive.

- : set2cond-implies (set2cond/U S2G0 F0 U0 L0) S2G OE SE
    (implies/trans IMP1R IMP2P) (implies/trans IMP1P IMP2R)
    <- set2cond/U-inversion S2G U0 F0 _ S2G1 _ _ L1 IMP1P IMP2P
    <- set2cond-implies S2G0 S2G1 OE set`eq/ IMP1Q IMP2Q
    <- cxt`lookup-unique L0 L1 cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE' TE
    <- set2cond-implies/L OE OE' IMP1Q IMP2Q IMP1R IMP2R.

%worlds (objvar) (set2cond-implies/L _ _ _ _ _ _).
%total { } (set2cond-implies/L _ _ _ _ _ _).

%worlds (objvar) (set2cond-implies _ _ _ _ _ _).
%total (R) (set2cond-implies R _ _ _ _ _).


%% theorems about apply-nn

%theorem apply-nn-respects-eq
  : forall* {NN} {NN'} {Pi1} {Pi1'} {Pi2} {Pi2'}
    forall {AP: apply-nn NN Pi1 Pi2}
    {AP': apply-nn NN' Pi1' Pi2'}
    {EQ: nonnull`eq NN NN'}
    {EQ: {x} permission`eq (Pi1 x) (Pi1' x)}
    exists {EQ: {x} permission`eq (Pi2 x) (Pi2' x)}
    true.

- : apply-nn-respects-eq AP AP nonnull`eq/ ([_] permission`eq/) ([_] permission`eq/).

%worlds (objvar) (apply-nn-respects-eq _ _ _ _ _).
%total { } (apply-nn-respects-eq _ _ _ _ _).


%theorem apply-nn-total*
  : forall {NN} {Pi}
    exists {Pi2} {AP: apply-nn NN Pi Pi2}
    true.

- : apply-nn-total* nn/yes _ _ apply-nn/yes.

- : apply-nn-total* nn/may _ _ apply-nn/may.

%worlds (objvar) (apply-nn-total* _ _ _ _).
%total { } (apply-nn-total* _ _ _ _).

%abbrev apply-nn-total = apply-nn-total* _ _.


%theorem apply-nn-unique
  : forall* {NN} {NN'} {Pi1} {Pi1'} {Pi2} {Pi2'}
    forall {AP1: apply-nn NN Pi1 Pi2}
    {AP2: apply-nn NN' Pi1' Pi2'}
    {EQ: nonnull`eq NN NN'}
    {EQ: {x} permission`eq (Pi1 x) (Pi1' x)}
    exists {EQ: {x} permission`eq (Pi2 x) (Pi2' x)}
    true.

%worlds (objvar) (apply-nn-unique _ _ _ _ _).
%trustme %total { } (apply-nn-unique _ _ _ _ _).


%% theorems about fldmap2perm

%theorem false-implies-fldmap2perm
  : forall* {PM} {O} {FM} {FS} {Pi}
    forall {V:void} exists {MFP: fldmap2perm PM O FM FS Pi}
    true.

%worlds (objvar) (false-implies-fldmap2perm _ _).
%total { } (false-implies-fldmap2perm _ _).


%theorem fldmap2perm-respects-eq
  : forall* {FS1} {PM1} {PM2} {O1} {O2} {FM1} {FM2} {Pi1} {Pi2} {FS2}
    forall {MFP1: fldmap2perm PM1 O1 FM1 FS1 Pi1}
    {PME: predmap`eq PM1 PM2} {OE: object`eq O1 O2}
    {FME: fldmap`eq FM1 FM2} {FSE: set`eq FS1 FS2}
    {PE: permission`eq Pi1 Pi2}
    exists {MFP2: fldmap2perm PM2 O2 FM2 FS2 Pi2}
    true.

- : fldmap2perm-respects-eq MFP predmap`eq/
    object`eq/ fldmap`eq/ set`eq/ permission`eq/ MFP.

%worlds (objvar) (fldmap2perm-respects-eq _ _ _ _ _ _ _).
%total {} (fldmap2perm-respects-eq _ _ _ _ _ _ _).


%theorem fldmap2perm-total
  : forall* {CM} {C} {PM} {O} {FM} {FS} {FS0}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    exists {Pi} {MF1: fldmap2perm PM O FM FS Pi}
    true.

%theorem fldmap2perm-total/L
  : forall* {CM} {C} {PM} {O} {FM} {FS0} {FS}
    forall {N} {SZ: set`size FS N}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS0}
    {LE: set`leq FS FS0}
    exists {Pi} {MF1: fldmap2perm PM O FM FS Pi}
    true.

- : fldmap2perm-total/L z _ _ _ _ _ set`leq/0 _ fldmap2perm/0.

- : fldmap2perm-total/L (s N) SZ CM-CM CM2PM CML DM-FM=FS0 FS<=FS0 _
    (fldmap2perm/U FS'=>Pi F!<FS' FS'+F=FS FML T2PF)
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) FS' F!<FS' FS'+F=FS
    <- set`add-implies-member FS'+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
    <- fldmap`domain-preserves-lookup-converse F<-FS0 DM-FM=FS0 T FML
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- set`fresh-update-implies-leq F!<FS' FS'+F=FS FS'<=FS
    <- set`leq-transitive FS'<=FS FS<=FS0 FS'<=FS0
    <- set`not-member-add-increases-size-converse SZ F!<FS' FS'+F=FS SZ'
    <- fldmap2perm-total/L N SZ' CM-CM CM2PM CML DM-FM=FS0 FS'<=FS0 _ FS'=>Pi.

- : fldmap2perm-total CM-CM CM2PM CML DM LEQ _ MF1
    <- set`size-total SZ
    <- fldmap2perm-total/L _ SZ CM-CM CM2PM CML DM LEQ _ MF1.

%worlds (objvar) (fldmap2perm-total/L _ _ _ _ _ _ _ _ _).
%total (N) (fldmap2perm-total/L N _ _ _ _ _ _ _ _).

%worlds (objvar) (fldmap2perm-total _ _ _ _ _ _ _).
%total { } (fldmap2perm-total _ _ _ _ _ _ _).


%theorem fldmap2perm/U-inversion
  : forall* {PM} {O} {FM} {FS} {Pi} {FS'} {F}
    forall {MF1: fldmap2perm PM O FM FS Pi}
    {F!<FS': set`not-member FS' F}
    {FS'+F=FS: set`add FS' F FS}
    exists {Pi'} {MF1': fldmap2perm PM O FM FS' Pi'}
    {T} {FML: fldmap`lookup FM F T}
    {PF} {T2PF: ty2perm PM T PF}
    {EQV: equiv Pi ((unitperm (precise-exists O F PF)) , Pi')}
    true.

%theorem fldmap2perm/U-inversion/L
  : forall* {PM} {O} {FM} {FS} {FS'} {F} {FS1} {Pi1} {F1} {T1} {PF1} {B}
    forall {MF1: fldmap2perm PM O FM FS1 Pi1}
    {FR1: set`not-member FS1 F1}
    {UD1: set`add FS1 F1 FS}
    {FML1: fldmap`lookup FM F1 T1}
    {T2PF1: ty2perm PM T1 PF1}
    {FR: set`not-member FS' F}
    {UD: set`add FS' F FS}
    {E?: nat`eq? F F1 B}
    exists {Pi'} {MF1': fldmap2perm PM O FM FS' Pi'}
    {T} {FML: fldmap`lookup FM F T}
    {PF} {T2PF: ty2perm PM T PF}
    {EQV: equiv (unitperm (precise-exists O F1 PF1) , Pi1)
          ((unitperm (precise-exists O F PF)) , Pi')}
    true.

- : fldmap2perm/U-inversion/L MF1 F1 U1 L1 R1 F2 U2 nat`eq?/yes %{=>}%
    _ MF _ L1 _ R1 equiv/reflexive
    <- set`not-member-add-cancels F1 U1 F2 U2 nat`eq/ set`eq/ SE
    <- fldmap2perm-respects-eq MF1 predmap`eq/ object`eq/
      fldmap`eq/ SE permission`eq/ MF.

- : fldmap2perm/U-inversion/L MF1 F1 U1 L1 R1 F2 U2 (nat`eq?/no F1<>F) %{=>}%
    _ (fldmap2perm/U MF F4 U4 L1 R1) _ L _ R
    (equiv/transitive
      (equiv/combine equiv/reflexive EQV)
      (equiv/roll2))
    <- set`add-commutes-converse U2 U1 F1<>F _ U4 U3
    <- set`add-preserves-not-member-converse F2 U4 F3
    <- set`add-preserves-not-member-converse F1 U3 F4
    <- fldmap2perm/U-inversion MF1 F3 U3 _ MF _ L _ R EQV.

- : fldmap2perm/U-inversion
    (fldmap2perm/U MF1 F1 U1 L1 R1) F2 U2 _ MF2 _ L2 _ R2 EQV
    <- nat`eq?-total E?
    <- fldmap2perm/U-inversion/L MF1 F1 U1 L1 R1 F2 U2 E? _ MF2 _ L2 _ R2 EQV.

%worlds (objvar) (fldmap2perm/U-inversion _ _ _ _ _ _ _ _ _ _)
  (fldmap2perm/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N N0) (fldmap2perm/U-inversion N _ _ _ _ _ _ _ _ _)
  (fldmap2perm/U-inversion/L N0 _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem fldmap2perm-equiv
  : forall* {PM} {O} {FM} {FS} {Pi}
    {PM'} {O'} {FM'} {FS'} {Pi'}
    forall {MF1: fldmap2perm PM O FM FS Pi}
    {MF1': fldmap2perm PM' O' FM' FS' Pi'}
    {PME: predmap`eq PM PM'} {OE: object`eq O O'}
    {FME: fldmap`eq FM FM'} {FSE: set`eq FS FS'}
    exists {EQV: equiv Pi Pi'}
    true.

%theorem fldmap2perm-equiv/L
  : forall* {O0} {O1} {PF0:object -> permission} {PF1} {F}
    forall {PFE: {x} permission`eq (PF0 x) (PF1 x)}
    {FE: object`eq O0 O1}
    exists {PE: permission`eq (unitperm (precise-exists O0 F PF0))
                (unitperm (precise-exists O1 F PF1))}
    true.

- : fldmap2perm-equiv/L ([_] permission`eq/) object`eq/ permission`eq/.

- : fldmap2perm-equiv fldmap2perm/0 fldmap2perm/0 _ _ _ _ equiv/reflexive.

- : fldmap2perm-equiv (fldmap2perm/U MF1 F1 U1 L1 R1) MF PME OE FME SE
    (equiv/transitive
      (equiv/combine PFEQV EQV2)
      (equiv/symmetric EQV1))
    <- fldmap2perm/U-inversion MF F1 U1 _ MF2 _ L2 _ R2 EQV1
    <- fldmap2perm-equiv MF1 MF2 PME OE FME set`eq/ EQV2
    <- fldmap`lookup-unique L1 L2 FME nat`eq/ TE
    <- ty2perm-deterministic R1 R2 PME TE ([x] PFE x)
    <- fldmap2perm-equiv/L PFE OE PFE'
    <- permission`eq-implies-equiv PFE' PFEQV.

%worlds (objvar) (fldmap2perm-equiv/L _ _ _).
%total { } (fldmap2perm-equiv/L _ _ _).

%worlds (objvar) (fldmap2perm-equiv _ _ _ _ _ _ _).
%total (M) (fldmap2perm-equiv M _ _ _ _ _ _).



%theorem fldmap2perm2-total
  : forall* {CM} {C} {PM} {O} {FM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    exists {Pi} {MF1: fldmap2perm2 PM O FM Pi}
    true.

- : fldmap2perm2-total CM-CM CM2PM CML _ (fldmap2perm2/ FM-DM FM2P)
    <- fldmap`domain-total FM-DM
    <- set`leq-reflexive _ LE
    <- fldmap2perm-total CM-CM CM2PM CML FM-DM LE _ FM2P.

%worlds (objvar) (fldmap2perm2-total _ _ _ _ _).
%total { } (fldmap2perm2-total _ _ _ _ _).


%% theorems about cxt2perm

%% 2.1 theorems about ty2perm2

%theorem ty2perm2-respects-eq
  : forall* {T1} {T2} {CM1} {CM2} {PM1} {PM2} {PF1} {PF2}
    forall {T2PF: ty2perm2 CM1 PM1 T1 PF1}
    {CME: clsmap`eq CM1 CM2} {PME: predmap`eq PM1 PM2} {TE: ty`eq T1 T2}
    {PFE: {o} permission`eq (PF1 o) (PF2 o)}
    exists {T2PF: ty2perm2 CM2 PM2 T2 PF2}
    true.

- : ty2perm2-respects-eq T2PF clsmap`eq/ predmap`eq/ ty`eq/ ([_] permission`eq/) T2PF.

%worlds (objvar) (ty2perm2-respects-eq _ _ _ _ _ _).
%total { } (ty2perm2-respects-eq _ _ _ _ _ _).


%theorem ty2perm2-deterministic/L :
    forall* {PF1: clspred -> object -> permission} {PF2} {PD1} {PD2}
    forall  {FEQ: {p}{o} permission`eq (PF1 p o) (PF2 p o)}
            {PEQ: predicate`eq PD1 PD2}
    exists  {PEQ: {o} permission`eq (PF1 PD1 o) (PF2 PD2 o)}
    true.

- : ty2perm2-deterministic/L
     ([_][_] permission`eq/) predicate`eq/ ([_] permission`eq/).

%worlds (objvar | fracvar) (ty2perm2-deterministic/L _ _ _).
%total  {} (ty2perm2-deterministic/L _ _ _).


%theorem ty2perm2-deterministic :
    forall* {CM1} {CM2} {PM1} {PM2} {T1} {T2} {PF1} {PF2}
    forall  {T12PF1: ty2perm2 CM1 PM1 T1 PF1}
            {T22PF2: ty2perm2 CM2 PM2 T2 PF2}
            {E: clsmap`eq CM1 CM2} {E: predmap`eq PM1 PM2} {EQ: ty`eq T1 T2}
    exists  {E: {o} permission`eq (PF1 o) (PF2 o)}
    true.

%worlds (objvar | fracvar) (ty2perm2-deterministic _ _ _ _ _ _).
%trustme %total { } (ty2perm2-deterministic _ _ _ _ _ _).

%abbrev ty2perm2-unique = ty2perm2-deterministic.


%theorem clsmap-lookup-implies-ty2perm2*
  : forall* {CM} {PM} {FM} {C} {NN}
    forall {A} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    exists {PF} {T2PF: ty2perm2 CM PM (ty/ NN A C) PF}
    true.

- : clsmap-lookup-implies-ty2perm2*
    annot/shared _ CM2PM CM-L _ (ty2perm2/shared (ty2perm/ PM-L NN2P A2P))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CM-L _ PM-L
    <- annot2perm-total A2P
    <- nn2perm-total NN2P.

- : clsmap-lookup-implies-ty2perm2*
    annot/borrow _ CM2PM CM-L _ (ty2perm2/borrow (ty2perm/ PM-L NN2P A2P))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CM-L _ PM-L
    <- annot2perm-total A2P
    <- nn2perm-total NN2P.

- : clsmap-lookup-implies-ty2perm2*
    annot/unique CM-CM CM2PM CM-L _
    (ty2perm2/unique CM-L PM-L ([x] FM2P x) AP (ty2perm/ PM-L NN2P A2P))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CM-L _ PM-L
    <- ({x} fldmap2perm2-total CM-CM CM2PM CM-L _ (FM2P x))
    <- annot2perm-total A2P
    <- nn2perm-total NN2P
    <- apply-nn-total _ AP.

%worlds (objvar) (clsmap-lookup-implies-ty2perm2* _ _ _ _ _ _).
%total {} (clsmap-lookup-implies-ty2perm2* _ _ _ _ _ _).

%abbrev clsmap-lookup-implies-ty2perm2 = clsmap-lookup-implies-ty2perm2* _.


%theorem false-implies-cxt2perm
  : forall* {CM} {PM} {B} {Pi}
    forall {F:void} exists {B2P: cxt2perm CM PM B Pi}
    true.

%worlds () (false-implies-cxt2perm _ _).
%total { } (false-implies-cxt2perm _ _).


%theorem cxt2perm-respects-eq
  : forall* {CM} {PM} {B} {Pi} {CM'} {PM'} {B'} {Pi'}
    forall {B2P: cxt2perm CM PM B Pi}
    {CME: clsmap`eq CM CM'} {PME: predmap`eq PM PM'}
    {BE: cxt`eq B B'} {PE: permission`eq Pi Pi'}
    exists {B2P': cxt2perm CM' PM' B' Pi'}
    true.

- : cxt2perm-respects-eq B2P clsmap`eq/ predmap`eq/ cxt`eq/ permission`eq/ B2P.

%worlds (objvar) (cxt2perm-respects-eq _ _ _ _ _ _).
%total { } (cxt2perm-respects-eq _ _ _ _ _ _).


%theorem clsmap-cxt-implies-cxt2perm
  : forall* {CM} {PM} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    exists {Pi:permission} {B=>Pi: cxt2perm CM PM B Pi}
    true.

- : clsmap-cxt-implies-cxt2perm _ _ clsmap-cxt/0 _ cxt2perm/0.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/U CM-B' (clsmap-ty/ L) BF BU)
    _ (cxt2perm/U B2P' BF BU T2PF)
    <- clsmap-lookup-implies-ty2perm2 CM-CM CM2PM L _ T2PF
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B' _ B2P'.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/U CM-B' clsmap-ty/null BF BU)
    _ (cxt2perm/U B2P' BF BU ty2perm2/null)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B' _ B2P'.

%worlds (objvar) (clsmap-cxt-implies-cxt2perm _ _ _ _ _).
%total (CM-B) (clsmap-cxt-implies-cxt2perm _ _ CM-B _ _).


%theorem cxt2perm/U-inversion
  : forall* {CM} {PM} {B} {Pi} {BP} {N} {O} {T}
    forall {B2P: cxt2perm CM PM B Pi}
    {F: cxt`fresh BP N}
    {U: cxt`update BP N (cxt-info/ O T) B}
    exists {PiP} {BP2P: cxt2perm CM PM BP PiP}
    {PF} {T2P: ty2perm2 CM PM T PF}
    {E: equiv Pi (combine (PF O) PiP)}
    true.

%theorem cxt2perm/U-inversion/L
  : forall* {CM} {PM} {B} {BP} {N} {O} {T} {B1} {N1} {O1} {T1} {PF1} {Pi1} {P}
    forall {B2P1: cxt2perm CM PM B1 Pi1}
    {F1: cxt`fresh B1 N1}
    {U1: cxt`update B1 N1 (cxt-info/ O1 T1) B}
    {R1: ty2perm2 CM PM T1 PF1}
    {F: cxt`fresh BP N}
    {U: cxt`update BP N (cxt-info/ O T) B}
    {E?: nat`eq? N N1 P}
    exists {PiP} {BP2P: cxt2perm CM PM BP PiP}
    {PF} {R: ty2perm2 CM PM T PF}
    {E: equiv (combine (PF1 O1) Pi1) (combine (PF O) PiP)}
    true.

- : cxt2perm/U-inversion/L B2P1 F1 U1 R1 F2 U2 nat`eq?/yes _ B2P _ R
    (equiv/combine PEQV equiv/reflexive)
    <- cxt`fresh-update-cancels F1 U1 F2 U2 nat`eq/ cxt`eq/ CIE BE
    <- cxt2perm-respects-eq B2P1 clsmap`eq/ predmap`eq/ BE permission`eq/ B2P
    <- cxt-info-eq-inversion CIE (OE:object`eq O O') TE
    <- ty2perm2-respects-eq (R1:ty2perm2 _ PM _ PF) clsmap`eq/ predmap`eq/ TE ([_] permission`eq/) R
    <- permission`apply-object-preserves-eq
      (([_] permission`eq/):({o} permission`eq (PF o) (PF o))) OE PE
    <- permission`eq-implies-equiv PE PEQV.

- : cxt2perm/U-inversion/L B2P1 F1 U1 R1 F2 U2 (nat`eq?/no N<>N1)
    _ (cxt2perm/U B2P2 F4 U4 R1) _ R
    (equiv/transitive (equiv/combine equiv/reflexive EQV1) equiv/roll2)
    <- cxt`update-commutes-converse U2 U1 N<>N1 _ U4 U3
    <- cxt`update-preserves-fresh-converse F2 U4 F3
    <- cxt`update-preserves-fresh-converse F1 U3 F4
    <- cxt2perm/U-inversion B2P1 F3 U3 _ B2P2 _ R EQV1.

- : cxt2perm/U-inversion (cxt2perm/U B2P0 F0 U0 R0) F1 U1 _ B2P _ R EQV
    <- nat`eq?-total E?
    <- cxt2perm/U-inversion/L B2P0 F0 U0 R0 F1 U1 E? _ B2P _ R EQV.

%worlds (objvar) (cxt2perm/U-inversion _ _ _ _ _ _ _ _)
  (cxt2perm/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _).
%total (R R0) (cxt2perm/U-inversion R _ _ _ _ _ _ _)
  (cxt2perm/U-inversion/L R0 _ _ _ _ _ _ _ _ _ _ _).


%theorem cxt2perm-equiv
  : forall* {CM} {CM'} {PM} {PM'} {B} {B'} {Pi} {Pi'}
    forall {B=>Pi: cxt2perm CM PM B Pi}
    {B=>Pi': cxt2perm CM' PM' B' Pi'}
    {CME: clsmap`eq CM CM'} {PME: predmap`eq PM PM'} {BE: cxt`eq B B'}
    exists {PiE: permission`equiv Pi Pi'}
    true.

- : cxt2perm-equiv cxt2perm/0 cxt2perm/0 _ _ _ equiv/reflexive.

- : cxt2perm-equiv (cxt2perm/U B2P0 F0 (U0:cxt`update _ _ (cxt-info/ O T) _)
                     (R0:ty2perm2 CM0 PM0 T PF0)) B2P CME PME BE
    (equiv/transitive (equiv/combine PFEQV EQV2)
      (equiv/symmetric EQV1))
    <- cxt2perm/U-inversion B2P F0 U0 _ B2P1 _ (R1:ty2perm2 CM1 PM1 T PF1) EQV1
    <- cxt2perm-equiv B2P0 B2P1 CME PME cxt`eq/ EQV2
    <- ty2perm2-unique R0 R1 CME PME ty`eq/ PFE
    <- permission`apply-object-preserves-eq PFE (object`eq/:object`eq O O) PFEQ
    <- permission`eq-implies-equiv PFEQ PFEQV.

%worlds (objvar) (cxt2perm-equiv _ _ _ _ _ _).
%total (T) (cxt2perm-equiv T _ _ _ _ _).



%% 4, theorems about cap2frac

%theorem cap2frac-respects-eq
  : forall* {X} {X'} {Q}
    forall {X2Q: cap2frac X Q}
    {XE: cap`eq X X'}
    exists {X2Q': cap2frac X' Q}
    true.

- : cap2frac-respects-eq X2Q cap`eq/ X2Q.

%worlds (objvar) (cap2frac-respects-eq _ _ _).
%total {} (cap2frac-respects-eq _ _ _).


%theorem cap2frac-total*
  : forall {X} exists {Q} {X2Q: cap2frac X Q} true.

- : cap2frac-total* cap/read _ cap2frac/read.

- : cap2frac-total* cap/write _ cap2frac/write.

%worlds (objvar) (cap2frac-total* _ _ _).
%total {} (cap2frac-total* _ _ _).

%abbrev cap2frac-total = cap2frac-total* _ _.


%theorem cap2frac-unique
  : forall* {X1} {X2} {Q1} {Q2}
    forall {X1=>Q1: cap2frac X1 (fraction/ Q1)}
    {X2=>Q2: cap2frac X2 (fraction/ Q2)}
    {X1=X2: cap`eq X1 X2}
    exists {Q1=Q2: rat`eq Q1 Q2}
    true.

- : cap2frac-unique T1 T2 cap`eq/ rat`eq/.

%worlds (objvar) (cap2frac-unique _ _ _ _).
%total { } (cap2frac-unique _ _ _ _).


%theorem cap2frac-permission-respects-geq
  : forall* {X1} {X2} {Q2} {Pi1}
    forall {X2Q: cap2frac X2 Q2}
    {X1<=X2: cap`leq X1 X2}
    exists {Q1} {Pi2} {X2Q: cap2frac X1 Q1}
    {IMP: equiv (scale Q2 Pi1) ((scale Q1 Pi1) , Pi2)}
    true.

- : cap2frac-permission-respects-geq X2Q (cap`geq/= cap`eq/) _ _
    X2Q (equiv/symmetric equiv/identity).

- : cap2frac-permission-respects-geq cap2frac/write
    (cap`geq/> cap`grt/wr) _ _ cap2frac/read
    (equiv/symmetric (equiv/add 1/2+1/2=1)).

%worlds (objvar) (cap2frac-permission-respects-geq _ _ _ _ _ _).
%total { } (cap2frac-permission-respects-geq _ _ _ _ _ _).


%%% theorems about create-fldperm

%theorem create-fldperm-unique
  : forall* {CM1} {CM2} {PM1} {PM2} {C1} {C2} {F1} {F2} {PF1} {PF2}
    forall {CF1: create-fldperm CM1 PM1 C1 F1 PF1}
    {CF2: create-fldperm CM2 PM2 C2 F2 PF2}
    {EQ: clsmap`eq CM1 CM2}
    {EQ: predmap`eq PM1 PM2}
    {EQ: nat`eq C1 C2}
    {EQ: nat`eq F1 F2}
    exists {EQ: {x} permission`eq (PF1 x) (PF2 x)}
    true.

%worlds (objvar) (create-fldperm-unique _ _ _ _ _ _ _).
%trustme %total { } (create-fldperm-unique _ _ _ _ _ _ _).


%% 6, theorems about capmap2perm

%theorem false-implies-capmap2perm
  : forall* {CM} {PM} {B} {M} {Pi}
    forall  {V: void}
    exists  {M=>Pi: capmap2perm CM PM B M Pi}
    true.

%worlds (objvar) (false-implies-capmap2perm _ _).
%total {} (false-implies-capmap2perm _ _).


%theorem capmap2perm-respects-eq
  : forall* {CM1} {PM1} {B1} {M1} {Pi1}
    {CM2} {PM2} {B2} {M2} {Pi2}
    forall  {M1=>Pi1: capmap2perm CM1 PM1 B1 M1 Pi1}
    {E: clsmap`eq CM1 CM2} {E: predmap`eq PM1 PM2}
    {E: cxt`eq B1 B2} {E: capmap`eq M1 M2}
    {E: permission`eq Pi1 Pi2}
    exists  {M2=>Pi2: capmap2perm CM2 PM2 B2 M2 Pi2}
    true.

- : capmap2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/
    cxt`eq/ capmap`eq/ permission`eq/ M=>Pi.

%worlds (objvar) (capmap2perm-respects-eq _ _ _ _ _ _ _).
%total {} (capmap2perm-respects-eq _ _ _ _ _ _ _).


%theorem clsmap-cxt-capmap-implies-capmap2perm
  : forall* {CM} {PM} {B} {M}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B-M: clsmap-cxt-capmap CM B M}
    exists {Pi} {M=>Pi: capmap2perm CM PM B M Pi}
    true.

- : clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM
    clsmap-cxt-capmap/0 _ capmap2perm/0.

- : clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM
    (clsmap-cxt-capmap/U CM-B-M' N+F=>K BL CML FML K!<M' M'+K+X=M)
    _ (capmap2perm/U M'=>Pi' N+F=>K BL (create-fldperm/ CML FML T2PF)
        X2Q AP-NN K!<M' M'+K+X=M)
    <- capmap`update-implies-lookup M'+K+X=M M->K=X
    <- clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM CM-B-M' _ M'=>Pi'
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- cap2frac-total X2Q
    <- apply-nn-total _ AP-NN.

%worlds (objvar) (clsmap-cxt-capmap-implies-capmap2perm _ _ _ _ _).
%total (T) (clsmap-cxt-capmap-implies-capmap2perm _ _ T _ _).


%theorem capmap2perm/U-inversion
  : forall* {M} {MP} {CM} {PM} {K} {X} {Pi} {B}
    forall {M2P: capmap2perm CM PM B M Pi}
    {FS: capmap`fresh MP K}
    {U: capmap`update MP K X M}
    exists {N} {F} {K=>N+F: nat2pair K (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {PF} {CT-PF: create-fldperm CM PM C F PF}
    {Q} {X2Q: cap2frac X Q}
    {Pi1} {AP-NN: apply-nn NN ([x] scale-fldperm Q x F PF) ([x] Pi1 x)}
    {Pi2} {M2P: capmap2perm CM PM B MP Pi2}
    {EQV: equiv ((Pi1 O) , Pi2) Pi}
    true.

%theorem capmap2perm/U-inversion/L
  : forall* {BP} {M} {B} {CM} {PM} {K} {K1} {X1} {X} {PF1}
    {MP1} {MP} {Q1} {Pi21} {NN1} {A1} {C1} {N1} {F1} {O1} {Pi11}
    forall {FS1: capmap`fresh MP1 K1}
    {U1: capmap`update MP1 K1 X1 M}
    {K=>N+F: nat2pair K1 (pair/ N1 F1)}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {CT-PF: create-fldperm CM PM C1 F1 PF1}
    {X2Q: cap2frac X1 Q1}
    {AP-NN1: apply-nn NN1 ([x] scale-fldperm Q1 x F1 PF1) ([x] Pi11 x)}
    {M2P: capmap2perm CM PM B MP1 Pi21}
    {FS2: capmap`fresh MP K}
    {U2: capmap`update MP K X M}
    {EQ: nat`eq? K K1 BP}
    exists {N} {F} {K=>N+F: nat2pair K (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {PF} {CT-PF: create-fldperm CM PM C F PF}
    {Q} {X2Q: cap2frac X Q}
    {Pi1} {AP-NN: apply-nn NN ([x] scale-fldperm Q x F PF) ([x] Pi1 x)}
    {Pi2} {M2P: capmap2perm CM PM B MP Pi2}
    {EQV: equiv ((Pi1 O) , Pi2) ((Pi11 O1) , Pi21)}
    true.

- : capmap2perm/U-inversion/L F1 U1 N2P1 BL1 CT-PF1 X2Q1 AP-NN1 M2P1 F2 U2
    nat`eq?/yes _ _ N2P1 _ _ _ _ BL1 _ CT-PF1 _ X2Q2 _ AP-NN1 _ M2P
    equiv/reflexive
    <- capmap`fresh-update-cancels F1 U1 F2 U2 nat`eq/ capmap`eq/ X1=X2 M1=M2
    <- cap2frac-respects-eq X2Q1 X1=X2 X2Q2
    <- capmap2perm-respects-eq M2P1 clsmap`eq/ predmap`eq/ cxt`eq/
      M1=M2 permission`eq/ M2P.

- : capmap2perm/U-inversion/L F1 U1 N2P1 BL1 CT-PF1 X2Q1 AP-NN1 M2P1 F2 U2
    (nat`eq?/no K<>K1) _ _ N2P2 _ _ _ _ BL2 _ CT-PF2 _ X2Q2 _ AP-NN2 _
    (capmap2perm/U M2P2 N2P1 BL1 CT-PF1 X2Q1 AP-NN1 F4 U4)
    (equiv/transitive equiv/roll2 (equiv/combine equiv/reflexive EQV))
    <- capmap`update-commutes-converse U2 U1 K<>K1 _ U4 U3
    <- capmap`update-preserves-fresh-converse F2 U4 F3
    <- capmap`update-preserves-fresh-converse F1 U3 F4
    <- capmap2perm/U-inversion M2P1 F3 U3 _ _ N2P2 _ _ _ _ BL2
      _ CT-PF2 _ X2Q2 _ AP-NN2 _ M2P2 EQV.

- : capmap2perm/U-inversion
    (capmap2perm/U M2P1 N2P1 BL1 CT-PF1 X2Q1 AP1 F1 U1)
    F2 U2 _ _ N2P _ _ _ _ BL _ CT-PF _ X2Q _ AP _ M2P EQV
    <- nat`eq?-total E?
    <- capmap2perm/U-inversion/L
      F1 U1 N2P1 BL1 CT-PF1 X2Q1 AP1 M2P1 F2 U2 E? _ _ N2P
      _ _ _ _ BL _ CT-PF _ X2Q _ AP _ M2P EQV.

%worlds (objvar)
	(capmap2perm/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(capmap2perm/U-inversion/L
    _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A B)
	(capmap2perm/U-inversion A _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(capmap2perm/U-inversion/L
    _ _ _ _ _ _ _ B _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem capmap2perm-equiv
  : forall* {CM1} {CM2} {PM1} {PM2} {B1} {B2}
    {M1} {M2} {Pi1} {Pi2}
    forall {M1=>Pi1: capmap2perm CM1 PM1 B1 M1 Pi1}
    {M2=>Pi2: capmap2perm CM2 PM2 B2 M2 Pi2}
    {E: clsmap`eq CM1 CM2}
    {E: predmap`eq PM1 PM2} {E: cxt`eq B1 B2} {E: capmap`eq M1 M2}
    exists {EQV: equiv Pi1 Pi2}
    true.

 %theorem capmap2perm-equiv/L
  : forall* {F0} {F1} {PF0:object -> permission} {PF1} {O0} {O1} {Q0} {Q1}
    {NN0} {NN1} {Pi0} {Pi1}
    forall {PFE: {x} permission`eq (PF0 x) (PF1 x)}
    {NNE: nonnull`eq NN0 NN1}
    {QE: rat`eq Q0 Q1}
    {FE: nat`eq F0 F1}
    {OE: object`eq O0 O1}
    {AP0: apply-nn NN0 ([x] scale-fldperm (fraction/ Q0) x F0 PF0) Pi0}
    {AP0: apply-nn NN1 ([x] scale-fldperm (fraction/ Q1) x F1 PF1) Pi1}
    exists {PE: permission`eq (Pi0 O0) (Pi1 O1)}
    true.

- : capmap2perm-equiv/L ([_] permission`eq/) nonnull`eq/ rat`eq/
    nat`eq/ object`eq/ AP AP permission`eq/.

- : capmap2perm-equiv capmap2perm/0 capmap2perm/0 _ _ _ _ equiv/reflexive.

- : capmap2perm-equiv (capmap2perm/U M2P0 P2K0 L0 R0 X2Q0 AP0 F0 U0)
    M2P CME PME BE ME
    (equiv/transitive (equiv/combine PXEQV EQV2) (EQV1))
    <- capmap2perm/U-inversion M2P F0 U0 _ _ P2K1 _ _ _ _ L1 _ R1 _ X2Q1 _ AP1 _ M2P1 EQV1
    <- capmap2perm-equiv M2P0 M2P1 CME PME BE capmap`eq/ EQV2
    <- nat2pair-unique P2K0 P2K1 nat`eq/ PE
    <- pair-eq-implies-eq PE (NE:nat`eq Nx0 Nx1) (FE:nat`eq Fx0 Fx1)
    <- cxt`lookup-unique L0 L1 BE NE CIE
    <- cxt-info-eq-inversion CIE (OE:object`eq O0 O1) TE
    <- ty-eq-inversion TE (NNE:nonnull`eq NN0 NN1) _ (CE:nat`eq C0 C1)
    <- create-fldperm-unique R0 R1 CME PME CE FE PFE
    <- cap2frac-unique X2Q0 X2Q1 cap`eq/ QE
    <- capmap2perm-equiv/L PFE NNE QE FE OE AP0 AP1 PFE'
    <- permission`eq-implies-equiv PFE' PXEQV.

%worlds (objvar) (capmap2perm-equiv/L _ _ _ _ _ _ _ _).
%total { } (capmap2perm-equiv/L _ _ _ _ _ _ _ _).

%worlds (objvar) (capmap2perm-equiv _ _ _ _ _ _ _).
%total (R) (capmap2perm-equiv R _ _ _ _ _ _).


%theorem capmap2perm-respects-geq
  : forall* {M1} {M2} {CM} {PM} {B} {Pi2}
    forall {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    {M1<=M2: capmap`leq M1 M2}
    exists {Pi1} {Pi3} {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {EQV: (equiv Pi2 (Pi1 , Pi3))}
    true.

%theorem capmap2perm-respects-geq/L
  : forall* {M1} {M2} {CM} {PM} {B} {Q} {Pi22}
    {M2'} {K} {N} {F} {X} {NN} {A} {C} {Pi21} {T} {PF} {O}
    forall {FS: capmap`fresh M2' K}
    {UD: capmap`update M2' K X M2}
    {K=>NF: nat2pair K (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {CT: create-fldperm CM PM C T PF}
    {X2Q: cap2frac X Q}
    {AP: apply-nn NN ([x] scale-fldperm Q x F PF) Pi21}
    {M2'=>Pi22: capmap2perm CM PM B M2' Pi22}
    {M1<=M2: capmap`leq M1 M2}
    {BP} {DM?: capmap`domain? M1 K BP}
    exists {Pi1} {Pi3} {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {EQV: (equiv ((Pi21 O) , Pi22) (Pi1 , Pi3))}
    true.

% - : capmap2perm-respects-geq/L K!<M2' M2'+K+X=M2
%     K2NF BL CT AE AP M2'=>Pi22 M1<=M2 _ (capmap`domain?/out K!<M1)
%     _ _ M1=>Pi1
%     (equiv/transitive
%       (equiv/combine equiv/reflexive (Pi22<=>Pi1+Pi3))
%       (equiv/reorder))
%     <- capmap`fresh-update2-preserves-leq-converse
%       M1<=M2 K!<M1 K!<M2' M2'+K+X=M2 M1<=M2'
%     <- capmap2perm-respects-geq
%       M2'=>Pi22 M1<=M2' _ _ M1=>Pi1 Pi22<=>Pi1+Pi3.

% - : capmap2perm-respects-geq/L K!<M2' M2'+K+X=M2
%     K2NF BL CT X2Q AP M2'=>Pi22 M1<=M2 _ (capmap`domain?/in M1->K=X1)
%     _ _ (capmap2perm/U M1'=>Pi11 K2NF BL CT X2Q1 AP K!<M1' M1'+K+X1=M1)
%     (equiv/transitive6
%       (equiv/combine (EQV1) (Pi22<=>Pi11+Pi3))
%       (equiv/symmetric equiv/associate)
%       (equiv/combine equiv/reflexive equiv/reorder)
%       (equiv/associate))
%     <- capmap`lookup-implies-fresh-update M1->K=X1 M1' K!<M1' M1'+K+X1=M1
%     <- capmap`fresh-update-preserves-leq-converse M1<=M2
%       K!<M1' M1'+K+X1=M1 K!<M2' M2'+K+X=M2 M1'<=M2' X1<=X
%     <- capmap2perm-respects-geq
%       M2'=>Pi22 M1'<=M2' _ _ M1'=>Pi11 Pi22<=>Pi11+Pi3
%     <- cap2frac-permission-respects-geq X2Q X1<=X _ _ X2Q1 EQV1.

% - : capmap2perm-respects-geq
%     capmap2perm/0 capmap`leq/0 _ _ capmap2perm/0
%     (equiv/symmetric equiv/identity).

% - : capmap2perm-respects-geq
%     (capmap2perm/U T' P BL CML FML T2PF AE F U) M1<=M2 _ _ M1=>Pi1 EQV
%     <- capmap`domain?-total DM?
%     <- capmap2perm-respects-geq/L F U P BL CML FML T2PF AE
%       T' M1<=M2 _ DM? _ _ M1=>Pi1 EQV.

%worlds (objvar)
	(capmap2perm-respects-geq _ _ _ _ _ _)
	(capmap2perm-respects-geq/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (A1 A2)
	(capmap2perm-respects-geq A1 _ _ _ _ _)
	(capmap2perm-respects-geq/L _ _ _ _ _ _ _ A2 _ _ _ _ _ _ _).


%theorem capmap2perm-respects-geq*
  : forall* {M1} {M2} {CM} {PM} {B} {Pi1} {Pi2}
    forall {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    {M1<=M2: capmap`leq M1 M2}
    {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    exists {Pi3} {EQV: (equiv Pi2 (Pi1 , Pi3))}
    true.

- : capmap2perm-respects-geq* M2=>Pi2 M1<=M2 M1=>Pi1 _
    (equiv/transitive EQV1 (equiv/combine EQV2 equiv/reflexive))
    <- capmap2perm-respects-geq M2=>Pi2 M1<=M2 _ _ M1=>Pi1' EQV1
    <- capmap2perm-equiv M1=>Pi1' M1=>Pi1 clsmap`eq/
      predmap`eq/ cxt`eq/ capmap`eq/ EQV2.

%worlds (objvar) (capmap2perm-respects-geq* _ _ _ _ _).
%total {} (capmap2perm-respects-geq* _ _ _ _ _).


%theorem capmap`disjoint-join-implies-equiv
  : forall* {M1} {M2} {M} {O} {FM} {PM} {Pi}
    forall {DJ: capmap`disjoint M1 M2}
    {J: capmap`join M1 M2 M}
    {M=>Pi: capmap2perm O FM PM M Pi}
    exists {Pi1} {Pi2}
    {M1=>Pi1: capmap2perm O FM PM M1 Pi1}
    {M2=>Pi2: capmap2perm O FM PM M2 Pi2}
    {EQV: equiv Pi (Pi1 , Pi2)}
    true.

- : capmap`disjoint-join-implies-equiv _ capmap`join/L M2P
    _ _ capmap2perm/0 M2P
    (equiv/transitive (equiv/symmetric equiv/identity)
      equiv/commute).

- : capmap`disjoint-join-implies-equiv _ capmap`join/R M2P
    _ _ M2P capmap2perm/0 (equiv/symmetric equiv/identity).


%theorem capmap`disjoint-join-implies-equiv/F
  : forall* {CM} {PM} {B} {M1} {M2} {Pix} {Piy}
    forall {V:void}
    exists {Pi1} {Pi2}
    {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    {EQV: (equiv (Pix , Piy) (Pi1 , Pi2))}
    true.

%theorem capmap`disjoint-join-implies-equiv/L
  : forall* {M1} {M2} {M} {MP} {F} {X} {PF} {B}
    {O} {PM} {Q} {Pix} {Piy} {K} {N} {NN} {A} {CM} {C} {B1} {B2}
    forall {DJ: capmap`disjoint M1 M2}
    {J: capmap`join M1 M2 M}
    {FS: capmap`fresh MP K}
    {U: capmap`update MP K X M}
    {K=>N+F: nat2pair K (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {CT: create-fldperm CM PM C F PF}
    {X2Q: cap2frac X Q}
    {ANN: apply-nn NN ([x] scale-fldperm Q x F PF) ([x] Pix x)}
    {M=>Pi: capmap2perm CM PM B MP Piy}
    {IN1?: capmap`domain? M1 K B1}
    {IN2?: capmap`domain? M2 K B2}
    exists {Pi1} {Pi2}
    {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    {EQV: (equiv ((Pix O) , Piy) (Pi1 , Pi2))}
    true.

- : capmap`disjoint-join-implies-equiv/L DJ J
    F U N2P BL R AP AN M2P
    (capmap`domain?/in L1) (capmap`domain?/in L2) _ _ M2P1 M2P2 EQV
    <- capmap`disjoint-lookup-contradiction DJ L1 L2 V
    <- capmap`disjoint-join-implies-equiv/F V _ _ M2P1 M2P2 EQV.

- : capmap`disjoint-join-implies-equiv/L DJ J _ U _ _ _ _ _ _
    (capmap`domain?/out F1) (capmap`domain?/out F2) _ _ M2P1 M2P2 EQV
    <- capmap`join-preserves-fresh* F1 F2 J F
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- capmap`disjoint-join-implies-equiv/F V _ _ M2P1 M2P2 EQV.

- : capmap`disjoint-join-implies-equiv/L DJ (J:capmap`join M1 M2 M)
    F (U:capmap`update MP K Xx M) N2P BL R AP AN M2P
    (capmap`domain?/in (L1:capmap`lookup M1 K Xy))
    (capmap`domain?/out F2) _ _
    (capmap2perm/U M2P1P N2P BL R AP AN F1 U1K) M2P2
    (equiv/transitive (equiv/combine equiv/reflexive EQVP)
      (equiv/associate))
    <- capmap`lookup-implies-fresh-update L1 _ F1 U1
    <- capmap`fresh-update-implies-leq F1 U1 LE1
    <- capmap`disjoint-respects-geq* DJ LE1 (DJP:capmap`disjoint M1P M2)
    <- capmap`fresh-update-implies-unit-join F1 U1 UJ1
    <- capmap`join-commutative UJ1 UJ1P
    <- capmap`join-associative UJ1P J M3 (JP:capmap`join M1P M2 M3) UJ2
    <- capmap`join-commutative UJ2 UJ2P
    <- capmap`join-preserves-fresh* F1 F2 JP F3
    <- capmap`fresh-unit-join-implies-update F3 UJ2P U3
    <- capmap`fresh-update-cancels F U F3 U3 nat`eq/ capmap`eq/ DE' ME'
    <- cap`eq-symmetric DE' DE
    <- capmap`eq-symmetric ME' ME
    <- capmap`join-respects-eq JP capmap`eq/ capmap`eq/ ME JP'
    <- capmap`disjoint-join-implies-equiv DJP JP' M2P _ _ M2P1P M2P2 EQVP
    <- capmap`update-respects-eq U1 capmap`eq/ nat`eq/ DE capmap`eq/ U1K.

- : capmap`disjoint-join-implies-equiv/L DJ (J:capmap`join M1 M2 M)
    F (U:capmap`update MP K Xx M) N2P BL R AP AN M2P
    (capmap`domain?/out F1) (capmap`domain?/in (L2:capmap`lookup M2 K Xy)) _ _
    M2P1 (capmap2perm/U M2P2P N2P BL R AP AN F2 U2K)
    (equiv/transitive (equiv/combine equiv/reflexive EQVP) equiv/roll2)
    <- capmap`lookup-implies-fresh-update L2 _ F2 U2
    <- capmap`fresh-update-implies-leq F2 U2 (LE2:capmap`leq M2' M2)
    <- capmap`disjoint-symmetric DJ DJ'
    <- capmap`disjoint-respects-geq* DJ' LE2 (DJP:capmap`disjoint M2' M1)
    <- capmap`fresh-update-implies-unit-join F2 U2 UJ2
    <- capmap`join-associative-converse UJ2 J _ (JP:capmap`join M1 M2' M') UJ2P
    <- capmap`join-preserves-fresh* F1 F2 JP (F3:capmap`fresh M' K)
    <- capmap`fresh-unit-join-implies-update F3 UJ2P U3
    <- capmap`fresh-update-cancels F U F3 U3 nat`eq/ capmap`eq/ DE' ME'
    <- capmap`eq-symmetric ME' ME
    <- cap`eq-symmetric DE' DE
    <- capmap`join-respects-eq JP capmap`eq/ capmap`eq/ ME JP'
    <- capmap`disjoint-symmetric DJP DJP'
    <- capmap`disjoint-join-implies-equiv DJP' JP' M2P _ _ M2P1 M2P2P EQVP
    <- capmap`update-respects-eq U2 capmap`eq/ nat`eq/ DE capmap`eq/ U2K.

- : capmap`disjoint-join-implies-equiv DJ J
    (capmap2perm/U M2P N2P BL R AP AN F U) _ _ M2P1 M2P2 EQV
    <- capmap`domain?-total D1?
    <- capmap`domain?-total D2?
    <- capmap`disjoint-join-implies-equiv/L DJ J F U N2P BL R AP AN M2P
      D1? D2? _ _ M2P1 M2P2 EQV.

%worlds (objvar) (capmap`disjoint-join-implies-equiv/F _ _ _ _ _ _).
%total { } (capmap`disjoint-join-implies-equiv/F _ _ _ _ _ _).

%worlds (objvar) (capmap`disjoint-join-implies-equiv _ _ _ _ _ _ _ _)
  (capmap`disjoint-join-implies-equiv/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (T1 T2) (capmap`disjoint-join-implies-equiv _ _ T1 _ _ _ _ _)
  (capmap`disjoint-join-implies-equiv/L _ _ _ _ _ _ _ _ _ T2 _ _ _ _ _ _ _).


%theorem capmap`disjoint-join-implies-equiv-converse
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2}
    forall {DJ: capmap`disjoint M1 M2}
    {J: capmap`join M1 M2 M}
    {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: capmap2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

%theorem capmap`disjoint-join-implies-equiv-converse/L
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2}
    forall {N} {Z: capmap`size M N}
    {DJ: capmap`disjoint M1 M2}
    {J: capmap`join M1 M2 M}
    {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: capmap2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

- : capmap`disjoint-join-implies-equiv-converse/L
    z _ _ capmap`join/L capmap2perm/0 M2P _ M2P
    (equiv/transitive equiv/commute equiv/identity).

- : capmap`disjoint-join-implies-equiv-converse/L
    z _ _ capmap`join/R M2P capmap2perm/0 _ M2P equiv/identity.

%theorem capmap`disjoint-join-implies-equiv-converse/F
  : forall* {CM} {PM} {B} {M} {Pi1} {Pi2}
    forall {V:void}
    exists {Pi} {M=>Pi: capmap2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

%theorem capmap`disjoint-join-implies-equiv-converse/LL
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2} {MP} {K} {X} {B1} {B2}
    forall {N} {Z: capmap`size M N}
    {DJ: capmap`disjoint M1 M2}
    {J: capmap`join M1 M2 M}
    {F: capmap`fresh MP K}
    {U: capmap`update MP K X M}
    {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    {D1?: capmap`domain? M1 K B1}
    {D2?: capmap`domain? M2 K B2}
    exists {Pi} {M=>Pi: capmap2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

- : capmap`disjoint-join-implies-equiv-converse/LL (s N) Z DJ J
    F U A1 A2 (capmap`domain?/in L1) (capmap`domain?/in L2) _ M2P EQV
    <- capmap`disjoint-lookup-contradiction DJ L1 L2 V
    <- capmap`disjoint-join-implies-equiv-converse/F V _ M2P EQV.

- : capmap`disjoint-join-implies-equiv-converse/LL (s N) Z _ J
    _ U A1 A2 (capmap`domain?/out F1) (capmap`domain?/out F2) _ M2P EQV
    <- capmap`join-preserves-fresh* F1 F2 J F
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- capmap`disjoint-join-implies-equiv-converse/F V _ M2P EQV.

- : capmap`disjoint-join-implies-equiv-converse/LL (s N) Z DJ
    (J:capmap`join M1 M2 M) F (U:capmap`update MP K Xx M) A1 A2
    (capmap`domain?/in _) (capmap`domain?/out F2)
    _ (capmap2perm/U AP N2P BL R APL AN F U)
    (equiv/transitive3
      (equiv/combine (equiv/symmetric EQV1) equiv/reflexive)
      (equiv/symmetric equiv/associate)
      (equiv/combine equiv/reflexive EQVP))
    <- capmap`update-implies-lookup U L
    <- capmap`fresh-join-right-preserves-lookup-converse L F2 J L1
    <- capmap`lookup-implies-fresh-update L1 M1P F1 U1
    <- capmap2perm/U-inversion A1 F1 U1 _ _ N2P _ _ _ _ BL _ R _ APL _ AN _ A1P EQV1
    <- capmap`fresh-update-left-preserves-join-converse* F1 U1 F2 J F U J1
    <- capmap`fresh-update-implies-leq F1 U1 LE1
    <- capmap`disjoint-respects-geq* DJ LE1 DJP
    <- capmap`fresh-update-increases-size-converse Z F U Z1
    <- capmap`disjoint-join-implies-equiv-converse/L N Z1 DJP J1 A1P A2 _ AP EQVP.

- : capmap`disjoint-join-implies-equiv-converse/LL (s N) Z DJ
    (J:capmap`join M1 M2 M) F (U:capmap`update MP K Xx M) A1 A2
    (capmap`domain?/out F1) (capmap`domain?/in _)
    _ (capmap2perm/U AP N2P BL R APL AN F U)
    (equiv/transitive3
      (equiv/combine equiv/reflexive (equiv/symmetric EQV2))
      (equiv/roll2)
      (equiv/combine equiv/reflexive EQVP))
    <- capmap`update-implies-lookup U L
    <- fresh-join-left-preserves-lookup-converse F1 L J L2
    <- capmap`lookup-implies-fresh-update L2 _ F2 U2
    <- capmap2perm/U-inversion A2 F2 U2 _ _ N2P _ _ _ _ BL _ R _ APL _ AN _ A2P EQV2
    <- capmap`fresh-update-right-preserves-join-converse* F1 F2 U2 J F U J2
    <- capmap`fresh-update-implies-leq F2 U2 LE2
    <- capmap`disjoint-symmetric DJ DJ'
    <- capmap`disjoint-respects-geq* DJ' LE2 DJP'
    <- capmap`disjoint-symmetric DJP' DJP
    <- capmap`fresh-update-increases-size-converse Z F U Z1
    <- capmap`disjoint-join-implies-equiv-converse/L N Z1 DJP J2 A1 A2P _ AP EQVP.

- : capmap`disjoint-join-implies-equiv-converse/L _ Z DJ J M2P1 M2P2 _ M2P EQV
    <- capmap`lookup-implies-fresh-update (capmap`lookup/= nat`eq/) _ F U
    <- capmap`domain?-total D1?
    <- capmap`domain?-total D2?
    <- capmap`disjoint-join-implies-equiv-converse/LL
      _ Z DJ J F U M2P1 M2P2 D1? D2? _ M2P EQV.

- : capmap`disjoint-join-implies-equiv-converse DJ J A1 A2 _ A EQV
    <- capmap`size-total Z
    <- capmap`disjoint-join-implies-equiv-converse/L _ Z DJ J A1 A2 _ A EQV.

%worlds (objvar) (capmap`disjoint-join-implies-equiv-converse/F _ _ _ _).
%total { } (capmap`disjoint-join-implies-equiv-converse/F _ _ _ _).

%worlds (objvar) (capmap`disjoint-join-implies-equiv-converse/L _ _ _ _ _ _ _ _ _)
  (capmap`disjoint-join-implies-equiv-converse/LL _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N N1)
  (capmap`disjoint-join-implies-equiv-converse/LL N _ _ _ _ _ _ _ _ _ _ _ _)
  (capmap`disjoint-join-implies-equiv-converse/L N1 _ _ _ _ _ _ _ _).

%worlds (objvar) (capmap`disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).
%total { } (capmap`disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).


%theorem capmap`disjoint-join-implies-equiv*
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {DJ: capmap`disjoint M1 M2}
    {J: capmap`join M1 M2 M}
    {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    {M=>Pi: capmap2perm CM PM B M Pi}
    exists {EQV: (equiv ((Pi1) , (Pi2)) (Pi))}
    true.

- : capmap`disjoint-join-implies-equiv* M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 M=>Pi
    (equiv/transitive (EQV1) (EQV2))
    <- capmap`disjoint-join-implies-equiv-converse
    M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 _ M=>Pi' EQV1
    <- capmap2perm-equiv M=>Pi' M=>Pi
      clsmap`eq/ predmap`eq/ cxt`eq/ capmap`eq/ EQV2.

%worlds (objvar) (capmap`disjoint-join-implies-equiv* _ _ _ _ _ _).
%total {} (capmap`disjoint-join-implies-equiv* _ _ _ _ _ _).


%theorem capmap`partition-implies-permission-combine
  : forall* {M1} {M2} {M} {S22} {CM} {PM} {B} {Pi}
    forall {R: capmap`partition M S22 M1 M2}
    {M=>Pi: capmap2perm CM PM B M Pi}
    exists {Pi1} {Pi2} {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    {EQV: (equiv Pi (Pi1 , Pi2))}
    true.

- : capmap`partition-implies-permission-combine
    M/S22=M1+M2 M=>Pi _ _ M1=>Pi1 M2=>Pi2 (Pi1+Pi2<=>Pi)
    <- capmap`partition-implies-disjoint-join M/S22=M1+M2 M1^M2 M1+M2=M
    <- capmap`disjoint-join-implies-equiv
      M1^M2 M1+M2=M M=>Pi _ _ M1=>Pi1 M2=>Pi2 Pi1+Pi2<=>Pi.

%worlds (objvar) (capmap`partition-implies-permission-combine _ _ _ _ _ _ _).
%total {} (capmap`partition-implies-permission-combine _ _ _ _ _ _ _).


%theorem capmap-split-implies-permission-combine
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi}
    forall {R: capmap-split M M1 M2}
    {M=>Pi: capmap2perm CM PM B M Pi}
    exists {Pi1} {Pi2} {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    {EQV: (equiv Pi (Pi1 , Pi2))}
    true.

- : capmap-split-implies-permission-combine
    M/S22=M1+M2 M=>Pi _ _ M1=>Pi1 M2=>Pi2 (Pi1+Pi2<=>Pi)
    <- capmap-split-implies-disjoint-join M/S22=M1+M2 M1^M2 M1+M2=M
    <- capmap`disjoint-join-implies-equiv
      M1^M2 M1+M2=M M=>Pi _ _ M1=>Pi1 M2=>Pi2 Pi1+Pi2<=>Pi.

%worlds (objvar) (capmap-split-implies-permission-combine _ _ _ _ _ _ _).
%total {} (capmap-split-implies-permission-combine _ _ _ _ _ _ _).


%theorem capmap`partition-implies-permission-combine-converse
  :forall* {M1} {M2} {M} {S22} {CM} {PM} {B} {Pi1} {Pi2}
    forall {R: capmap`partition M S22 M1 M2}
    {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: capmap2perm CM PM B M Pi}
    {EQV: equiv (Pi1 , Pi2) Pi}
    true.

- : capmap`partition-implies-permission-combine-converse SG T1 T2 _ T EQV
    <- capmap`partition-implies-disjoint-join SG X J
    <- capmap`disjoint-join-implies-equiv-converse X J T1 T2 _ T EQV.

%worlds (objvar) (capmap`partition-implies-permission-combine-converse _ _ _ _ _ _).
%total {} (capmap`partition-implies-permission-combine-converse _ _ _ _ _ _).


%theorem capmap-split-implies-permission-combine-converse
  :forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2}
    forall {R: capmap-split M M1 M2}
    {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: capmap2perm CM PM B M Pi}
    {EQV: equiv (Pi1 , Pi2) Pi}
    true.

- : capmap-split-implies-permission-combine-converse SG T1 T2 _ T EQV
    <- capmap-split-implies-disjoint-join SG X J
    <- capmap`disjoint-join-implies-equiv-converse X J T1 T2 _ T EQV.

%worlds (objvar) (capmap-split-implies-permission-combine-converse _ _ _ _ _ _).
%total {} (capmap-split-implies-permission-combine-converse _ _ _ _ _ _).


%theorem capmap-split-implies-permission-combine*
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {R: capmap-split M M1 M2}
    {M=>Pi: capmap2perm CM PM B M Pi}
    {M1=>Pi1: capmap2perm CM PM B M1 Pi1}
    {M2=>Pi2: capmap2perm CM PM B M2 Pi2}
    exists {EQV: (equiv Pi (Pi1 , Pi2))}
    true.

- : capmap-split-implies-permission-combine* M/S22=M1+M2 M=>Pi M1=>Pi1 M2=>Pi2
    (equiv/symmetric (Pi1+Pi2<=>Pi))
    <- capmap-split-implies-disjoint-join M/S22=M1+M2 M1^M2 M1+M2=M
    <- capmap`disjoint-join-implies-equiv*
      M1^M2 M1+M2=M M1=>Pi1 M2=>Pi2 M=>Pi Pi1+Pi2<=>Pi.

%worlds (objvar) (capmap-split-implies-permission-combine* _ _ _ _ _).
%total {} (capmap-split-implies-permission-combine* _ _ _ _ _).


%theorem reftyping-preserves-capmap2perm
  : forall* {N} {CM} {MM} {PM} {B0} {B1} {M0} {M1} {E} {RT} {M} {Pi}
    forall {RTYP: reftyping N CM MM (env/ B0 M0) E (result/expr RT (env/ B1 M1))}
    {B0+M=>Pi: capmap2perm CM PM B0 M Pi}
    exists {B1+M=>Pi: capmap2perm CM PM B1 M Pi}
    true.

%worlds (objvar) (reftyping-preserves-capmap2perm _ _ _).
%trustme %total { } (reftyping-preserves-capmap2perm _ _ _).

% %theorem capmap`leq-partition
%   : forall* {M1} {M} {S}
%     forall {LEQ: capmap`leq M1 M}
%     {DM: capmap`domain M1 S}
%     exists {M2} {M3} {DJ: capmap`disjoint M2 M3}
%     {J: capmap`join M2 M3 M}
%     {DM: capmap`domain M2 S}
%     true.

% %worlds (objvar) (capmap`leq-partition _ _ _ _ _ _ _).
% %total { } (capmap`leq-partition _ _ _ _ _ _ _).


%theorem result2output-respects-eq
  : forall* {CM} {PM} {Rslt} {Rslt'} {Out}
    forall {XX2O: result2output CM PM Rslt Out}
    {EQ: result`eq Rslt Rslt'}
    exists {XX2O: result2output CM PM Rslt' Out}
    true.

- : result2output-respects-eq XX result`eq/ XX.

%worlds (objvar) (result2output-respects-eq _ _ _).
%total { } (result2output-respects-eq _ _ _).



% TODO: respects-eq for methty2proctype and consty2proctype..

% cxt needs to be consistent with clsmap


%theorem clsmap-cxt-capmap-implies-result2output*
  : forall* {CM} {PM} {B} {CAM} {NN} {C} {FM}
    forall {GS} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {CM-B-GS: clsmap-cxt-reftype CM B (reftype/ NN C GS)}
    {CM-B-XX: clsmap-cxt-capmap CM B CAM}
    {CML: clsmap`lookup CM C FM}
    exists {Out}
    {XX=>Out: result2output CM PM
      (result/expr (reftype/ NN C GS) (env/ B CAM)) Out}
    true.

%theorem clsmap-cxt-capmap-implies-result2output/shared
  : forall* {CM} {PM} {B} {CAM} {NN} {C} {FM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {CM-B-XX: clsmap-cxt-capmap CM B CAM}
    {CML: clsmap`lookup CM C FM}
    exists {Out}
    {XX=>Out: result2output CM PM
      (result/expr (reftype/ NN C targets/shared) (env/ B CAM)) Out}
    true.

- : clsmap-cxt-capmap-implies-result2output/shared
    CM-CM CM2PM CM-B CM-B-XX CML _
    (result2output/shared T2PF B=>Pi1 M=>Pi2)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>Pi1
    <- clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM CM-B-XX _ M=>Pi2
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/ CML) _ T2PF.

%worlds (objvar) (clsmap-cxt-capmap-implies-result2output/shared _ _ _ _ _ _ _).
%total {} (clsmap-cxt-capmap-implies-result2output/shared _ _ _ _ _ _ _).


%theorem clsmap-cxt-capmap-implies-result2output/unique
  : forall* {CM} {PM} {B} {M1} {M2} {NN} {C} {FM} {S}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {CM-B-S2: clsmap-cxt-unique-objset CM B NN C S}
    {WF-TGTS: wf-unique-targets (targets/unique S M2)}
    {CM-B-S2: clsmap-cxt-capmap CM B M2}
    {CM-B-CAM: clsmap-cxt-capmap CM B M1}
    {CML: clsmap`lookup CM C FM}
    exists {Out}
    {CAM=>Out: result2output CM PM
       (result/expr (reftype/ NN C (targets/unique S M2)) (env/ B M1)) Out}
    true.

- : clsmap-cxt-capmap-implies-result2output/unique
    CM-CM CM2PM CM-B SOC wf-unique-targets/1
    _ CM-B-XX CML _
    (result2output/unique/1 (set`size/+ Z) capmap`size/0 T2PF S=>G B=>Pi1 M=>Pi2)
    <- set`size-total Z
    <- ({r} clsmap-cxt-unique-objset-implies-set2cond SOC _ (S=>G r))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>Pi1
    <- clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM CM-B-XX _ M=>Pi2
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/ CML) _ T2PF.

- : clsmap-cxt-capmap-implies-result2output/unique
    CM-CM CM2PM CM-B SOC wf-unique-targets/2 CM-B-M2 CM-B-M1 CML _
    (result2output/unique/2 (capmap`size/+ Z) T2PF S=>G B=>Pi1
      M1=>Pi2 M2=>Pi3 MX-M2 X2Q)
    <- capmap`size-total Z
    <- ({r} clsmap-cxt-unique-objset-implies-set2cond SOC _ (S=>G r))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>Pi1
    <- clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM CM-B-M1 _ M1=>Pi2
    <- clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM CM-B-M2 _ M2=>Pi3
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/ CML) _ T2PF
    <- capmap-min-cap-total MX-M2
    <- cap2frac-total X2Q.

%worlds (objvar)
  (clsmap-cxt-capmap-implies-result2output/unique _ _ _ _ _ _ _ _ _ _).
%total {}
  (clsmap-cxt-capmap-implies-result2output/unique _ _ _ _ _ _ _ _ _ _).

- : clsmap-cxt-capmap-implies-result2output*
    targets/shared CM-CM CM2PM CM-B CM-B-GS CM-B-XX CML _ XX=>Out
    <- clsmap-cxt-capmap-implies-result2output/shared CM-CM CM2PM CM-B CM-B-XX
      CML _ XX=>Out.

- : clsmap-cxt-capmap-implies-result2output* (targets/unique _ _)
    CM-CM CM2PM CM-B (clsmap-cxt-reftype/unique _ SOC CM-B-M WF-TGT)
    CM-B-XX CML _ XX=>Out
    <- clsmap-cxt-capmap-implies-result2output/unique
      CM-CM CM2PM CM-B SOC WF-TGT CM-B-M CM-B-XX CML _ XX=>Out.

%worlds (objvar) (clsmap-cxt-capmap-implies-result2output* _ _ _ _ _ _ _ _ _).
%total {} (clsmap-cxt-capmap-implies-result2output* _ _ _ _ _ _ _ _ _).

%abbrev clsmap-cxt-capmap-implies-result2output
  = clsmap-cxt-capmap-implies-result2output* _.


%%%
%%% theorems about leq - basically:
%%%
%%% if M1 is less or equal than M2, and
%%% M1 ==> Pi1, M2 ==> Pi2.
%%% then exists Pi3, such that Pi2 <==> Pi1 , Pi3
%%%

%theorem can-split-permission
  : forall* {Q1} {Pi}
    forall {Q1<1: rat`lst Q1 one}
    exists {Q2} {ADD: rat`add Q1 Q2 one}
    {EQV: equiv Pi ((scale (fraction/ Q1) Pi) , (scale (fraction/ Q2) Pi))}
    true.

- : can-split-permission (Q1<1:rat`lst Q1 one) Q2 Q1+Q2=1
    (equiv/transitive
      (equiv/symmetric equiv/one)
      (equiv/symmetric (equiv/add Q1+Q2=1)))
    <- rat`grt-implies-add Q1<1 Q2 Q2+Q1=1
    <- rat`add-commutative Q2+Q1=1 Q1+Q2=1.

%worlds (objvar) (can-split-permission _ _ _ _).
%total {} (can-split-permission _ _ _ _).


%theorem can-duplicate-borrow
  : forall* {PM} {NN} {C} {PF}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    exists {IMP: {o} implies (PF o) ((PF o) , (PF o))}
    true.

- : can-duplicate-borrow
    (ty2perm/ _ nn2perm/yes annot2perm/borrow)
    ([_] implies/trans5
      (implies/combine
        (implies/duplicate)
        (implies/combine
          (implies/reflexive)
          (implies/duplicate)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/equiv equiv/roll3))
      (implies/equiv equiv/associate)
      (implies/combine
        (implies/combine
          (implies/reflexive)
          (implies/equiv
            (equiv/transitive
              (equiv/symmetric equiv/identity)
              (equiv/commute))))
        (implies/reflexive))).

- : can-duplicate-borrow
    (ty2perm/ _ nn2perm/may annot2perm/borrow)
    ([_] implies/trans3
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/trans3
          (implies/combine
            (implies/reflexive)
            (implies/duplicate))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/reflexive)
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/identity)
                (equiv/commute))))))
      (implies/cond-distribute)
      (implies/equiv equiv/commute)).

%worlds (objvar) (can-duplicate-borrow _ _).
%total {} (can-duplicate-borrow _ _).


%theorem can-duplicate-shared
  : forall* {PM} {NN} {C} {PF}
    forall {T2PF: ty2perm PM (ty/ NN annot/shared C) PF}
    exists {IMP: {o} implies (PF o) ((PF o) , (PF o))}
    true.

- : can-duplicate-shared
    (ty2perm/ _ nn2perm/may annot2perm/shared)
    ([_] implies/trans3
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/trans
          (implies/combine2conj)
          (implies/duplicate)))
      (implies/cond-distribute)
      (implies/combine
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/conj2combine))
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/reflexive)
          (implies/conj2combine)))).

- : can-duplicate-shared
    (ty2perm/ _ nn2perm/yes annot2perm/shared)
    ([_] implies/trans4
      (implies/combine
        (implies/reflexive)
        (implies/combine2conj))
      (implies/combine2conj)
      (implies/duplicate)
      (implies/combine
        (implies/trans
          (implies/conj2combine)
          (implies/combine
            (implies/reflexive)
            (implies/conj2combine)))
        (implies/trans
          (implies/conj2combine)
          (implies/combine
            (implies/reflexive)
            (implies/conj2combine))))).

%worlds (objvar) (can-duplicate-shared _ _).
%total {} (can-duplicate-shared _ _).


%theorem can-duplicate-not-unique
  : forall* {PM} {NN} {C} {PF} {A}
    forall {T2PF: ty2perm PM (ty/ NN A C) PF}
    {NU: not-unique A}
    exists {IMP: {o} implies (PF o) ((PF o) , (PF o))}
    true.

- : can-duplicate-not-unique T2PF not-unique/borrow IMP
    <- can-duplicate-borrow T2PF IMP.

- : can-duplicate-not-unique T2PF not-unique/shared IMP
    <- can-duplicate-shared T2PF IMP.

%worlds (objvar) (can-duplicate-not-unique _ _ _).
%total { } (can-duplicate-not-unique _ _ _).


%theorem clsmap-cxt-lookup-implies-ty2perm
  : forall* {CM} {PM} {T} {B} {Pi} {O} {N}
    forall {CM-B: clsmap-cxt CM B}
    {BL: cxt`lookup B N (cxt-info/ O T)}
    {B2P: cxt2perm CM PM B Pi}
    exists {PF} {T2PF: ty2perm PM T PF}
    {EQV: implies Pi ((PF O) , Pi)}
    true.

%worlds (objvar) (clsmap-cxt-lookup-implies-ty2perm _ _ _ _ _ _).
%trustme %total { } (clsmap-cxt-lookup-implies-ty2perm _ _ _ _ _ _).


%{ This theorem says if we have a class predicate and we
know that this class has a field F, then we can pull out
the nesting fact about F from the predicate. }%

%theorem fldperm-can-lookup
  : forall* {CM} {PM} {C} {FM} {F} {NN} {A} {FC} {CP}
    forall {CM2PM: clsmap2predmap CM PM}
    {PM-L: predmap`lookup PM C CP}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    exists {AF} {PF} {FCP}
    {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM FC FCP}
    {IMP: {o} implies
          (unitperm
            (nonlinear
              (predcall CP (predargs/1 o))))
          (unitperm
            (nonlinear
              (nested ((fldperm F PF) FCP o) o all)))}
    true.

%theorem fldperm-can-lookup/false-imply
  : forall* {PM} {NN} {C} {F:nat} {G} {A}
    forall {V:void}
    exists {AF} {PF:clspred -> object -> permission}
    {CP} {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    {IMP: {o} implies (unitperm (nonlinear (G o)))
        (unitperm
          (nonlinear
            (nested ((fldperm F PF) CP o) o all)))}
    true.

%theorem fldperm-can-lookup/L
  : forall* {CM} {PM} {FM} {F} {NN} {A} {G} {C}
    forall {FM=>G: fldmap2conj CM PM FM ([r] G r) PM}
    {FM-L: fldmap`lookup FM F (ty/ NN A C)}
    exists {AF} {PF} {CP}
    {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    {IMP: {o} implies (unitperm (nonlinear (G o)))
        (unitperm
            (nonlinear
              (nested ((fldperm F PF) CP o) o all)))}
    true.

- : fldperm-can-lookup/L (fldmap2conj/null FMP2G F<=FM=FMP)
    (fldmap`lookup/> FM->F P) AF PF CP A2AF FNN2PF PM->C IMP
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- fldmap`shift-preserves-lookup* FM->F F<=FM=FMP P2 FMP->F
    <- fldperm-can-lookup/L FMP2G FMP->F AF PF CP A2AF FNN2PF PM->C IMP.

- : fldperm-can-lookup/L (fldmap2conj/in _ FNN2P A2AF _ PM-L)
     (fldmap`lookup/= nat`eq/) _ _ _ A2AF FNN2P PM-L
    ([o] implies/trans3
      (implies/conj2combine)
      (implies/combine
        (implies/reflexive)
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
      (implies/equiv equiv/identity)).

- : fldperm-can-lookup/L (fldmap2conj/in FM2G _ _ FM-SH _)
    (fldmap`lookup/> FM-L P) AF PF CP A2AF FNN2P PM-L
    ([o] implies/trans4
      (implies/conj2combine)
      (implies/combine
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
        (I o))
      (implies/equiv equiv/commute)
      (implies/equiv equiv/identity))
    <- nat`plus-swap-succ P P'
    <- nat`plus-commutative P' P''
    <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
    <- fldperm-can-lookup/L FM2G FM-L' AF PF CP A2AF FNN2P PM-L I.

- : fldperm-can-lookup/L
    (fldmap2conj/out F2C
      (F2CF:{f} fldmap2conj _ _ _ ([r] CJ f r) _)
      ([f] PM-U f) _ _ _ _ PM-FS) _ AF PF PD A2AF FNN2P PM-L I
    <- predmap`size-total SZ-PM
    <- predmap`fresh-update-increases-size
      SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
    <- fldmap2conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
    <- predmap`size-total SZ-PMF
    <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
    <- fldmap2conj-implies-predmap-leq F2C PMF<=PM
    <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
    <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
    <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
    <- nat`gt-anti-reflexive SZ-PM>PM F
    <- fldperm-can-lookup/false-imply F AF PF PD A2AF FNN2P PM-L I.

- : fldperm-can-lookup
    CM2PM PM-L CM-L FM-L AF PF CP A2AF FNN2PF PM->FC
    ([o] implies/trans3
      (implies/equiv (EQV o))
      (implies/nonlinear
        (bimplies/trans
          (bimplies/predcall/Y/inline)
          (bimplies/trans
            (bimplies/predcall/+/inline o)
            (bimplies/predcall/0/inline))))
      (IMP o))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- clsmap-predmap-implies-lookup-format CM-PM PM-L _ PM-LP ([o] (PEQ o))
    <- ({o} permission`eq-implies-equiv (PEQ o) (EQV o))
    <- clsmap2predmap-implies-fldmap2conj CM2PM PM-LP CM-L FM2G
    <- fldperm-can-lookup/L FM2G FM-L AF PF CP A2AF FNN2PF PM->FC IMP.

%worlds (objvar) (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).
%total {} (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).

%worlds (objvar) (fldperm-can-lookup/L _ _ _ _ _ _ _ _ _).
%total (FM2G) (fldperm-can-lookup/L FM2G _ _ _ _ _ _ _ _).

%worlds (objvar) (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).
%total {} (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).


%theorem sharedperm-can-be-duplicated
  : forall* {NN} {C} {AF} {PF} {PM} {CP}
    forall {A2AF: annot2perm annot/shared AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    exists {IMP: {r} implies (PF CP r) ((PF CP r) , (PF CP r))}
    true.

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/yes _
    ([r]
      (implies/trans4
        (implies/combine
          (implies/reflexive)
          (implies/combine2conj))
        (implies/combine2conj)
        (implies/duplicate)
        (implies/combine
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))))).

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/may _
    ([r]
      (implies/trans3
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/trans
            (implies/combine2conj)
            (implies/duplicate)))
        (implies/cond-distribute)
        (implies/combine
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/conj2combine))
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/conj2combine))))).

%worlds (objvar) (sharedperm-can-be-duplicated _ _ _ _).
%total {} (sharedperm-can-be-duplicated _ _ _ _).


%theorem sharedperm-can-be-duplicated*
  : forall* {NN} {C} {PF} {PM}
    forall {T2PF: ty2perm PM (ty/ NN annot/shared C) PF}
    exists {IMP: {r} implies (PF r) ((PF r) , (PF r))}
    true.

- : sharedperm-can-be-duplicated*
    (ty2perm/ PM-L NN2PF A2AF) IMP
    <- sharedperm-can-be-duplicated A2AF NN2PF PM-L IMP.

%worlds (objvar) (sharedperm-can-be-duplicated* _ _).
%total {} (sharedperm-can-be-duplicated* _ _).


%{
 This lemma says if we have a partial permission for shared, as well as
 fact that the whole permission for object r is nested in shared, then
 we can carve that permission out, along with the encumbered permission.
 TODO: this lemma could be simpler by eliminating Pi1 and Pi3.
}%

%theorem can-carve-out-of-shared
  : forall* {Pi1} {Pi2} {Pi3} {Q}
    forall {EQV: equiv Pi2 (scale Q (allperm null) , Pi3)}
    exists {IMP: {r} implies
                 ((unitperm
                      (nonlinear
                        (nested (allperm r) null all))) , (Pi1 , Pi2))
                 ((scale Q (allperm r)) ,
                   ((unitperm
                     (encumbered
                       (scale Q (allperm r)) (Pi2))) , (Pi1)))}
    true.

- : can-carve-out-of-shared
    EQV ([r] implies/trans3
          (implies/equiv
            (equiv/transitive
              (equiv/combine
                (equiv/reflexive) equiv/commute)
              (equiv/associate)))
          (implies/combine
            (implies/trans6
              (implies/combine
                implies/reflexive (implies/equiv (EQV)))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans5
                  (implies/combine
                    (implies/scale-into-formula)
                    (implies/reflexive))
                  (implies/equiv (equiv/symmetric equiv/distribute))
                  (implies/scale implies/carve)
                  (implies/equiv equiv/distribute)
                  (implies/combine
                    implies/reflexive
                    (implies/scale-distribute-encumbered)))
                (implies/reflexive))
              (implies/combine
                (implies/reflexive)
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/transitive
                          (EQV)
                          (equiv/commute))
                        (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive implies/chain-implication))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))).

%worlds (objvar) (can-carve-out-of-shared _ _).
%total {} (can-carve-out-of-shared _ _).


%{
 The following two lemmas say if we have a permission converted from
 either unique or borrowed type, then we can "scale from" the permission,
 and remove the fraction (since the permission is actually formule).
}%

%theorem can-scale-from-shared
  : forall* {PM} {PF} {C} {NN} {Q}
    forall {T2PF: ty2perm PM (ty/ NN annot/shared C) PF}
    exists {IMP: {v} implies (scale Q (PF v)) (PF v)}
    true.

- : can-scale-from-shared
    (ty2perm/ _ nn2perm/yes annot2perm/shared)
    ([_] implies/trans
      (implies/equiv
        (equiv/transitive
          (equiv/distribute)
          (equiv/combine
            (equiv/reflexive)
            (equiv/distribute))))
      (implies/combine
        (implies/scale-from-formula)
        (implies/combine
          (implies/scale-from-formula)
          (implies/scale-from-formula)))).

- : can-scale-from-shared
    (ty2perm/ _ nn2perm/may annot2perm/shared)
    ([_] implies/trans
      (implies/scale-distribute-cond)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/zero)
        (implies/trans
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/scale-from-formula)
            (implies/scale-from-formula))))).

%worlds (objvar) (can-scale-from-shared _ _).
%total {} (can-scale-from-shared _ _).


%theorem can-scale-from-borrow
  : forall* {PM} {PF} {C} {NN} {Q}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    exists {IMP: {v} implies (scale Q (PF v)) (PF v)}
    true.

- : can-scale-from-borrow
    (ty2perm/ _ nn2perm/yes annot2perm/borrow)
    ([v] implies/trans
      (implies/equiv
        (equiv/transitive
          (equiv/distribute)
          (equiv/combine
            (equiv/reflexive)
            (equiv/distribute))))
      (implies/combine
        (implies/scale-from-formula)
        (implies/combine
          (implies/equiv
            (equiv/zero))
          (implies/scale-from-formula)))).

- : can-scale-from-borrow
    (ty2perm/ _ nn2perm/may annot2perm/borrow)
    ([_] implies/trans
      (implies/scale-distribute-cond)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/zero)
        (implies/trans
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/equiv equiv/zero)
            (implies/scale-from-formula))))).

%worlds (objvar) (can-scale-from-borrow _ _).
%total {} (can-scale-from-borrow _ _).


%theorem borrow-permission-to-empty
  : forall* {PM} {NN} {C} {PF}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    exists {IMP: {x} implies (PF x) empty}
    true.

- : borrow-permission-to-empty (ty2perm/ _ nn2perm/yes annot2perm/borrow)
    ([_] implies/trans
      (implies/combine implies/nonlinear2empty
        (implies/trans
          (implies/combine implies/reflexive implies/nonlinear2empty)
          (implies/equiv equiv/identity)))
      (implies/equiv equiv/identity)).

- : borrow-permission-to-empty (ty2perm/ _ nn2perm/may annot2perm/borrow)
    ([_] implies/trans
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (implies/trans
          (implies/combine implies/reflexive implies/nonlinear2empty)
          (implies/equiv equiv/identity)))
      (implies/cond-equal)).

%worlds (objvar) (borrow-permission-to-empty _ _).
%total { } (borrow-permission-to-empty _ _).