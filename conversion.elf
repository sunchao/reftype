%% Converting from refty to permission type
%%% $Id: conversion.elf,v 1.2 2012/06/05 04:51:11 csun Exp csun $
%%% created at Feb 10th, 2012

%abbrev world = null.

%abbrev write-shared = (unitperm (basic world all null)).

%abbrev predperm : clspred -> object -> permission
    = [P] [R] (unitperm (nonlinear (predcall P (predargs/1 R)))).



%%% Permission with variables

vperm : type.

vperm/base : permission -> vperm.

vperm/var : ((gterm V) -> vperm) -> vperm.



%%% add two vperms

vperm-add : vperm -> vperm -> vperm -> type.

vperm-add/left
  : vperm-add (vperm/var [v] (VP0 v)) VP1 (vperm/var [v] (VP2 v))
    <- ({v} vperm-add (VP0 v) VP1 (VP2 v)).

vperm-add/right
  : vperm-add VP0 (vperm/var [v] (VP1 v)) (vperm/var [v] (VP2 v))
    <- ({v} vperm-add VP0 (VP1 v) (VP2 v)).

vperm-add/base
  : vperm-add
    (vperm/base
      (unitperm (nonlinear G1) , Pi1 , 
	(unitperm (encumbered Pi1' write-shared))))
    (vperm/base
      (unitperm (nonlinear G2) , Pi2 , 
	(unitperm (encumbered Pi2' write-shared))))
    (vperm/base
      (unitperm (nonlinear (disj G1 G2)) , (Pi1 , Pi2) , 
	(unitperm (encumbered (Pi1' , Pi2') write-shared)))).



%%% effect => permission

efx=>input : efx -> permission -> permission -> type.

efx=>input/write : efx=>input efx/write Pi Pi.

efx=>input/consume : efx=>input efx/consume Pi Pi.


efx=>output : efx -> permission -> permission -> type.

efx=>output/write : efx=>output efx/write Pi Pi.

efx=>output/consume : efx=>output efx/consume Pi empty.



%%% convert the location set into a disjunction of facts

%%% I forgot why I have to convert to disjuctions here..
%%% It seems conditional would be a better choice.


set=>fact : cxt N -> object -> set -> permission -> type.

set=>fact/objequal : cxt N -> object -> set -> formula -> type.

set=>fact/objequal/0 : set=>fact/objequal _ _ set/0 f.

set=>fact/objequal/+
  : set=>fact/objequal B O S (disj (objequal O O') G)
    <- set`add S' (s L) S
    <- cxt-lookup-ty B (s L) O' _
    <- set=>fact/objequal B O S' G.

set=>fact/0 : set=>fact _ _ set/0 empty.

set=>fact/+/z
  : set=>fact B O (set/+ z S)
    (unitperm
      (conditional
        (nested (allperm O) world all)
        (empty) (unitperm (nonlinear G))))
    <- set`shift z S S'
    <- set=>fact/objequal B O S' G.

set=>fact/+/s
  : set=>fact B O (set/+ (s L) S)
    (unitperm
      (conditional
        (f)
        (empty) (unitperm (nonlinear G))))
    <- set=>fact/objequal B O (set/+ (s L) S) G.


%%% Converting a efxmap to two set of permissions:
%%% the first set is all that has target associated,
%%% the second is all that do not.

efxmap=>perm : efxmap -> tgtmap -> clsmap -> predmap -> cxt N ->
	permission -> permission -> type.

efxmap=>perm-helper
  : object -> inner-efxmap -> fldmap -> predmap ->
	set -> permission -> permission -> type.

%%% generate field permissions
%%% (here all fields in set should be unique.)
efxmap=>perm-helper/0
  : efxmap=>perm-helper _ inner-efxmap/0 _ _ _ empty empty.

efxmap=>perm-helper/+/in
  : efxmap=>perm-helper
     O M FM PM S ((unitperm (precise-exists O F PF)) , Pi1) Pi2
    <- inner-efxmap`update M' F X M
    <- inner-efxmap`fresh M' F
    <- set`member S F
    <- fldmap`lookup FM F T
    <- ty=>perm PM T PF
    <- efxmap=>perm-helper O M' FM PM S Pi1 Pi2.

efxmap=>perm-helper/+/out
  : efxmap=>perm-helper
     O M FM PM S Pi1 ((unitperm (precise-exists O F PF)) , Pi2)
    <- inner-efxmap`update M' F X M
    <- inner-efxmap`fresh M' F
    <- set`not-member S F
    <- fldmap`lookup FM F T
    <- ty=>perm PM T PF
    <- efxmap=>perm-helper O M' FM PM S Pi1 Pi2.


efxmap=>perm/0 : efxmap=>perm efxmap/0 _ _ _ _ empty empty.

efxmap=>perm/+/z/in
  : efxmap=>perm XM GM CM PM B ((allperm world) , Pi1) Pi2
    <- efxmap`update XM' z M XM
    <- efxmap`fresh XM' z
    <- tgtmap`domain? GM z true
    <- efxmap=>perm XM' GM CM PM B Pi1 Pi2.

efxmap=>perm/+/z/out
  : efxmap=>perm XM GM CM PM B Pi1 ((allperm world) , Pi2)
    <- efxmap`update XM' z M XM
    <- efxmap`fresh XM' z
    <- tgtmap`domain? GM z false
    <- efxmap=>perm XM' GM CM PM B Pi1 Pi2.

efxmap=>perm/+/in
  : efxmap=>perm XM GM CM PM B (Pi1' , Pi1) (Pi2' , Pi2)
    <- efxmap`update XM' L M XM
    <- efxmap`fresh XM' L
    <- tgtmap`lookup GM L S
    <- cxt-lookup B L O (refty/ (ty/ _ _ C) _ _)
    <- clsmap`lookup CM C FM
    <- efxmap=>perm-helper O M FM PM S Pi1' Pi2'
    <- efxmap=>perm XM' GM CM PM B Pi1 Pi2.

efxmap=>perm/+/out
   : efxmap=>perm XM GM CM PM B Pi1 (Pi2' , Pi2)
      <- efxmap`update XM' L M XM
      <- efxmap`fresh XM' L
      <- tgtmap`fresh GM L
      <- cxt-lookup B L O (refty/ (ty/ _ _ C) _ _)
      <- clsmap`lookup CM C FM
      <- efxmap=>perm-helper O M FM PM set/0 _ Pi2'
      <- efxmap=>perm XM' GM CM PM B Pi1 Pi2.


%%% we will temporarily use output here. 
%%% After we add read effect, we MAY need
%%% to change to vperm.

efxmap=>output
   : clsmap -> predmap -> cxt N -> efxmap -> refty -> expr-output -> type.

%% depending on whether the set include
%% shared target, the output is different.
%% TODO: remove redundancy?

efxmap=>output/may
  : efxmap=>output CM PM B XM (refty/ (ty/ nn/may _ C) S GM)
    (output/exists [r]
      (output/exists [o]
	    (output/expr r
          (unitperm
            (conditional
              (objequal r null)
              (empty)
              ((unitperm
                 (conditional (GF o)
                   (empty) 
                   (unitperm
                     (nonlinear
                       (disj (objequal o r) (G o))))) ,
                 ((allperm o) ,
                   (unitperm
                     (encumbered
                       (allperm o) Pi1))) , Pi2)))))))
    <- efxmap=>perm XM GM CM PM B Pi1 Pi2
    <- predmap`lookup PM C CP
    <- ({o} set=>fact B o S 
         ((unitperm 
            (conditional
              (GF o) (empty)
              (unitperm (nonlinear (G o))))))).

efxmap=>output/yes
  : efxmap=>output CM PM B XM (refty/ (ty/ nn/yes _ C) S GM)
    (output/exists [r]
      (output/exists [o]
	    (output/expr r
          ((unitperm 
             (nonlinear
               (neg(objequal r null)))) ,
            ((unitperm
                 (conditional (GF o)
                   (empty) 
                   (unitperm
                     (nonlinear
                       (disj (objequal o r) (G o))))) ,
                 ((allperm o) ,
                   (unitperm
                     (encumbered
                       (allperm o) Pi1))) , Pi2))))))
    <- efxmap=>perm XM GM CM PM B Pi1 Pi2
    <- predmap`lookup PM C CP
    <- ({o} set=>fact B o S 
         ((unitperm 
            (conditional
              (GF o) (empty)
              (unitperm (nonlinear (G o))))))).


%%% converting efxmap to input

%%% this conversion will create lots of empty permissions
%%% from conversion of both efxmap and inner-efxmap. Maybe
%%% there's a better way to do this...

efxmap=>input : clsmap -> predmap -> cxt N -> efxmap -> permission -> type.

efxmap=>input/obj : clsmap -> predmap -> cxt N -> efxmap -> permission -> type.

efxmap=>input/obj/0 : efxmap=>input/obj _ _ _ efxmap/0 empty.
 
efxmap=>input/obj/+ 
  : efxmap=>input/obj CM PM B XM (Pi1 , Pi2)
    <- efxmap`update XM' L M XM
    <- efxmap`fresh XM' L
    <- cxt-lookup-ty B L O C
    <- clsmap`lookup CM C FM
    <- efxmap=>perm-helper O M FM PM set/0 _ Pi1
    <- efxmap=>input/obj CM PM B XM' Pi2.

efxmap=>input/0 : efxmap=>input _ _ B efxmap/0 empty.

efxmap=>input/+/z
  : efxmap=>input CM PM B (efxmap/+ z _ XM) ((allperm world) , Pi)
    <- efxmap`shift z XM XMS
    <- efxmap=>input/obj CM PM B XMS Pi.

efxmap=>input/+/s
  : efxmap=>input CM PM B (efxmap/+ (s L) M XM) Pi
    <- efxmap=>input/obj CM PM B (efxmap/+ (s L) M XM) Pi.


% %%% context => permission

cxt=>input : cxt N -> permission -> type.

cxt=>input/0 : cxt=>input cxt/nil empty.

cxt=>input/+/unique
   : cxt=>input (cxt/cons _ (refty/ (ty/ _ annot/unique _) _ _) B) Pi
      <- cxt=>input B Pi.

cxt=>input/+/shared
   : cxt=>input (cxt/cons O (refty/ (ty/ NN annot/shared C) _ _) B)
      (unitperm (nonlinear (nested (allperm O) null all)) , Pi)
      <- cxt=>input B Pi.



%%% convert set of fields to field permissions

set=>perm : clsmap -> predmap -> fldmap -> set -> (object -> permission) -> type.

set=>perm/0 : set=>perm _ _ _ set/0 ([_] empty).

set=>perm/+
   : set=>perm CM PM FM S
      ([o] (unitperm (precise-exists o F PF)) , (Pi o))
      <- set`add S' F S
      <- fldmap`lookup FM F T
      <- ty=>perm PM T ([o] PF o)
      <- set=>perm CM PM FM S' ([o] Pi o).


%%% methty => proctype

methty=>proctype* : clsmap -> predmap -> permission
	-> permission -> methty -> proctype -> type.

methty=>proctype/base 
   : methty=>proctype* CM PM Pin Pout (methty/base T)
      (proctype/base Pin
	 (output/exists [o]
	    (output/expr o ((PF o) , Pout))))
      <- ty=>perm PM T ([o] PF o).
	      

%%% here if the argument type is unique, then the read/write sets
%%% associated with it can only be empty. 
methty=>proctype/args 
   : methty=>proctype* CM PM Pin Pout (methty/arg MT (ty/ NN A C) R W)
      (proctype/arg ([r] PTF r))
      <- ty=>perm PM (ty/ NN A C) ([o] PF o)
      <- clsmap`lookup CM C FM
      <- set=>perm CM PM FM R ([o] RPF o)
      <- set=>perm CM PM FM W ([o] WPF o)
      <- ({o} methty=>proctype* CM PM
	    (((PF o) , (RPF o) , (WPF o)) , Pin) (((RPF o) , (WPF o)) , Pout) MT (PTF o)).

%abbrev methty=>proctype
   = [CM][PM][MT][PT] methty=>proctype* CM PM empty empty MT PT.


%abbrev obj-notnull : object -> permission
	= ([r] (unitperm (nonlinear (neg (objequal r null))))).

consty=>proctype* : clsmap -> predmap -> fldmap -> permission -> permission
	-> methty -> (object -> proctype) -> type.

consty=>proctype/base
   : consty=>proctype* CM PM FM Pin Pout
      (methty/base T)
      ([t] (proctype/base
	      (Pin , (obj-notnull t) , (OS t))
	      (output/exists [t]
		 (output/expr t ((PF t) , Pout)))))
      <- ty=>perm PM T ([o] PF o)
      <- fldmap`domain FM S
      <- ({t} allocFields t S (OS t)).

consty=>proctype/args
   : consty=>proctype* CM PM FM Pin Pout
      (methty/arg CT (ty/ NN A C) R W)
      ([t] (proctype/arg ([r] PTF t r)))
      <- ty=>perm PM (ty/ NN A C) ([r] PF r)
      <- clsmap`lookup CM C FM'
      <- set=>perm CM PM FM' R ([o] RPF o)
      <- set=>perm CM PM FM' W ([o] WPF o)
      <- ({r} consty=>proctype* CM PM FM 
	    (((PF r) , (RPF r) , (WPF r)) , Pin)
	    (((RPF r) , (WPF r)) , Pout) CT ([t] PTF t r)).

%abbrev consty=>proctype
   = [CM][PM][FM][CT][PTF] consty=>proctype* CM PM FM empty empty CT PTF.


%%% methmap => progtype

methmap=>progtype : clsmap -> predmap -> methmap -> progtype -> type.

methmap=>progtype/0 : methmap=>progtype _ _ methmap/0 progtype`map/0.

methmap=>progtype/+/const
   : methmap=>progtype CM PM MM W
      <- methmap`update 
	 MM' C (methty/arg CT (ty/ nonnull/yes annot/unique C) _ _) MM
      <- methmap`fresh MM' C
      <- clsmap`lookup CM C FM
      <- consty=>proctype CM PM FM CT ([t] PTF t)
      <- methmap=>progtype CM PM MM' W'
      <- progtype`update W' C (proctype/arg PTF) W.

methmap=>progtype/+/meth
   : methmap=>progtype CM PM MM W
      <- methmap`update MM' C MT MM
      <- methmap`fresh MM' C
      <- clsmap`fresh CM C
      <- methty=>proctype CM PM MT PT
      <- methmap=>progtype CM PM MM' W'
      <- progtype`update W' C PT W.


%%% environment => progtype

env2progtype : clsmap -> methmap -> progtype -> type.

env2progtype/
   : env2progtype CM MM W
      <- clsmap=>predmap CM PM
      <- methmap=>progtype CM PM MM W.


%%% theorems 

%%% theorems about vperm

%%% theorems about efx=>input and efx=>output

%%% theorems about set=>fact

%theorem false-implies-set=>fact :
    forall* {N} {B:cxt N} {O} {S}
    forall  {F:void}
    exists  {G} {S=>G: set=>fact B O S G}
    true.

%worlds () (false-implies-set=>fact _ _ _).
%total  {} (false-implies-set=>fact _ _ _).


%%% theorems about efxmap=>perm<


%%% theorems about efxmap=>output

%%% theorems about efxmap=>input

%theorem false-implies-efxmap=>input :
    forall* {N} {CM} {PM} {B:cxt N} {XM} 
    forall  {F:void}
    exists  {Pi} {XM=>Pi: efxmap=>input CM PM B XM Pi}
    true.       

%worlds () (false-implies-efxmap=>input _ _ _).
%total  {} (false-implies-efxmap=>input _ _ _).


%%% theorems about methty=>proctype

%%% theorems about consty=>proctype


%%% theorems about methmap=>progtype