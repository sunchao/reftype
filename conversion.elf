nn2output : nn -> expr-output -> expr-output -> type.

nn2output/exists 
  : nn2output NN (output/exists [r] (O1 r))
    (output/exists [r] (O2 r))
    <- ({r} nn2output NN (O1 r) (O2 r)).
		   
nn2output/expr/may 
  : {O} nn2output nn/may (output/expr O Pi)
    (output/expr O
      (unitperm (conditional (objequal O null) empty Pi))).

nn2output/expr/yes
  : {O} nn2output nn/yes (output/expr O Pi)
    (output/expr O
      (unitperm (nonlinear (neg (objequal O null))) , Pi)).


set2facts : cxt N -> object -> set -> formula -> type.

set2facts/0 : set2facts _ _ set/0 f.

set2facts/+
  : set2facts B O S (disj (objequal O O') G)
    <- set`add S' L S
    <- cxt-lookup B L O' _
    <- set2facts B O S' G.


efxmap2perm : clsmap -> predmap -> cxt N -> efxmap -> tgtmap
  -> permission -> permission -> type.

efxmap2perm-helper : object -> fldmap -> predmap -> 
  inner-efxmap -> set -> permission -> permission -> type.

efxmap2perm-helper/0
  : efxmap2perm-helper _ _ _ inner-efxmap/0 _ empty empty.

efxmap2perm-helper/+/in
  : efxmap2perm-helper O FM PM M S
    (unitperm (precise-exists O F PF) , Pi1) Pi2
    <- inner-efxmap`update M' F X M
    <- inner-efxmap`fresh M' F
    <- set`member S F
    <- fldmap`lookup FM F T
    <- ty2perm PM T PF
    <- efxmap2perm-helper O FM PM M' S Pi1 Pi2.

efxmap2perm-helper/+/out
  : efxmap2perm-helper O FM PM M S
    Pi1 (unitperm (precise-exists O F PF) , Pi2)
    <- inner-efxmap`update M' F X M
    <- inner-efxmap`fresh M' F
    <- set`not-member S F
    <- fldmap`lookup FM F T
    <- ty2perm PM T PF
    <- efxmap2perm-helper O FM PM M' S Pi1 Pi2.


efxmap2perm/0 : efxmap2perm _ _ _ efxmap/0 _ empty empty.

efxmap2perm/+/in
  : efxmap2perm CM PM B XM GM (Pi3 , Pi1) (Pi4 , Pi2)
    <- efxmap`update XM' L M XM
    <- efxmap`fresh XM' L
    <- tgtmap`lookup GM L S
    <- cxt-lookup B L O (ty/ _ _ C)
    <- clsmap`lookup CM C FM
    <- efxmap2perm-helper O FM PM M S Pi3 Pi4
    <- efxmap2perm CM PM B XM' GM Pi1 Pi2.

efxmap2perm/+/out
  : efxmap2perm CM PM B XM GM Pi1 (Pi4 , Pi2)
    <- efxmap`update XM' L M XM
    <- efxmap`fresh XM' L
    <- tgtmap`fresh GM L
    <- cxt-lookup B L O (ty/ _ _ C)
    <- clsmap`lookup CM C FM
    <- efxmap2perm-helper O FM PM M set/0 _ Pi4
    <- efxmap2perm CM PM B XM' GM Pi1 Pi2.


efxmap2output : clsmap -> predmap -> cxt N -> efxmap 
  -> ty -> tgtmap -> expr-output -> type.

efxmap2output/0
  : efxmap2output CM PM B XM (ty/ NN _ C) GM0 OUT
    <- tgtmap`split GM0 S GM
    <- tgtmap`size GM nat`z
    <- efxmap2perm CM PM B XM GM _ Pi
    <- ({o} set2facts B o S (G o))
    <- nn2output NN 
      (output/exists [o]
	(output/expr o
	  (unitperm (nonlinear (G o)) , Pi))) OUT.

efxmap2output/+
  : efxmap2output CM PM B XM (ty/ NN _ C) GM0 OUT
    <- tgtmap`split GM0 S GM
    <- tgtmap`size GM (nat`s _)
    <- efxmap2perm CM PM B XM GM Pi1 Pi2
    <- ({o} set2facts B o S (G o))
    <- nn2output NN
      (output/exists [o]
	(output/exists [r]
	  (output/expr o
	    (unitperm (nonlinear (disj (objequal o r) (G o))) ,
	    ((allperm r) , (unitperm (encumbered (allperm r) Pi1))) ,
	    Pi2)))) OUT.
	  

% TODO: this is so similar with ty2perm, maybe we can merge them.

create-fact : predmap -> ty -> (object -> permission) -> type. 

create-fact/unique
  : create-fact PM (ty/ NN annot/unique C) ([r] PF CP r)
    <- predmap`lookup PM C CP
    <- nn2perm NN ([_] empty) PF.

create-fact/borrow
  : create-fact PM (ty/ NN annot/unique C) ([r] PF CP r)
    <- predmap`lookup PM C CP
    <- nn2perm NN ([_] empty) PF.

create-fact/shared
  : create-fact PM (ty/ NN annot/unique C) ([r] PF CP r)
    <- predmap`lookup PM C CP
    <- nn2perm
      NN ([o] unitperm (nonlinear (nested (allperm o) null all))) PF.
      

cxt2facts : predmap -> cxt N -> permission -> type.

cxt2facts/0 : cxt2facts PM cxt/nil empty.

cxt2facts/+
  : cxt2facts PM (cxt/cons O T B) ((PF O) , Pi)
    <- create-fact PM T PF
    <- cxt2facts PM B Pi.
	

%%% methty => proctype

methty2proctype* : clsmap -> predmap -> permission
  -> permission -> methty -> proctype -> type.

methty2proctype/base 
  : methty2proctype* CM PM Pin Pout (methty/base T)
    (proctype/base Pin
      (output/exists [o]
	(output/expr o ((PF o) , Pout))))
    <- ty2perm PM T ([o] PF o).
	      

set2perm : clsmap -> predmap -> fldmap -> set ->
  (object -> permission) -> type.

set2perm/0 : set2perm _ _ _ set/0 ([_] empty).

set2perm/+
  : set2perm CM PM FM S
    ([o] (unitperm (precise-exists o F PF)) , (Pi o))
    <- set`add S' F S
    <- fldmap`lookup FM F T
    <- ty2perm PM T ([o] PF o)
    <- set2perm CM PM FM S' ([o] Pi o).

% here if the argument type is unique, then the read/write sets
% associated with it can only be empty. 
methty2proctype/args 
  : methty2proctype* CM PM Pin Pout (methty/arg MT (ty/ NN A C) R W)
    (proctype/arg ([r] PTF r))
    <- ty2perm PM (ty/ NN A C) ([o] PF o)
    <- clsmap`lookup CM C FM
    <- set2perm CM PM FM R ([o] RPF o)
    <- set2perm CM PM FM W ([o] WPF o)
    <- ({o} methty2proctype* CM PM
         (((PF o) , (RPF o) , (WPF o)) , Pin) 
         (((RPF o) , (WPF o)) , Pout) MT (PTF o)).

%abbrev methty2proctype
   = [CM][PM][MT][PT] methty2proctype* CM PM empty empty MT PT.


consty2proctype*
  : clsmap -> predmap -> fldmap -> permission -> 
  permission -> methty -> (object -> proctype) -> type.

consty2proctype/base
  : consty2proctype* CM PM FM Pin Pout
    (methty/base T)
    ([t] (proctype/base
	   (Pin , 
	     (unitperm (nonlinear (neg (objequal t null)))) , 
	     (OS t))
	   (output/exists [t]
	     (output/expr t ((PF t) , Pout)))))
    <- ty2perm PM T ([o] PF o)
    <- fldmap`domain FM S
    <- ({t} allocFields t S (OS t)).

consty2proctype/args
  : consty2proctype* CM PM FM Pin Pout
    (methty/arg CT (ty/ NN A C) R W)
    ([t] (proctype/arg ([r] PTF t r)))
    <- ty2perm PM (ty/ NN A C) ([r] PF r)
    <- clsmap`lookup CM C FM'
    <- set2perm CM PM FM' R ([o] RPF o)
    <- set2perm CM PM FM' W ([o] WPF o)
    <- ({r} consty2proctype* CM PM FM 
	 (((PF r) , (RPF r) , (WPF r)) , Pin)
	 (((RPF r) , (WPF r)) , Pout) CT ([t] PTF t r)).

%abbrev consty2proctype
   = [CM][PM][FM][CT][PTF] consty2proctype* CM PM FM empty empty CT PTF.


%%% methmap => progtype

methmap2progtype : clsmap -> predmap -> methmap -> progtype -> type.

methmap2progtype/0 : methmap2progtype _ _ methmap/0 progtype`map/0.

methmap2progtype/+/const
  : methmap2progtype CM PM MM W
    <- methmap`update 
      MM' C (methty/arg CT (ty/ nonnull/yes annot/unique C) _ _) MM
    <- methmap`fresh MM' C
    <- clsmap`lookup CM C FM
    <- consty2proctype CM PM FM CT ([t] PTF t)
    <- methmap2progtype CM PM MM' W'
    <- progtype`update W' C (proctype/arg PTF) W.

methmap2progtype/+/meth
  : methmap2progtype CM PM MM W
    <- methmap`update MM' C MT MM
    <- methmap`fresh MM' C
    <- clsmap`fresh CM C
    <- methty2proctype CM PM MT PT
    <- methmap2progtype CM PM MM' W'
    <- progtype`update W' C PT W.


%%% environment => progtype

env2progtype : clsmap -> methmap -> progtype -> type.

env2progtype/
  : env2progtype CM MM W
    <- clsmap2predmap CM PM
    <- methmap2progtype CM PM MM W.