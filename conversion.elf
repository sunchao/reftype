%%% Converting *map to permission

%%% ======================= Abbreviations =====================================

%abbrev fldperm
  : object -> nat -> (object -> permission) -> permission
  = [O][F][PF] (unitperm (precise-exists O F ([x] PF x))).

%abbrev cond-fldperm
  : object -> nat -> (object -> permission) -> permission
  = [O][F][PF]
    (unitperm (conditional (objequal O null) empty
                (unitperm (precise-exists O F PF)))).

%abbrev obj-not-null : object -> permission
  = ([r] unitperm (nonlinear (neg (objequal r null)))).

%abbrev encumbered-fldperm
  : object -> (object -> permission) -> clspred -> permission
  = [O][PF][CP] (unitperm
                  (conditional
                    (objequal O null)
                    (empty)
                    (unitperm
                      (encumbered
                        (PF O)
                        (combine
                          (allperm O)
                          (one-predcall CP O)))))).


%%% ======================= Definitions =======================================

%%% Convert a set of object locations to a conditional of objequal
%%% facts. Used in output.

set2cond : cxt -> object -> set -> permission -> type.

set2cond/0 : set2cond _ _ set/0 (unitperm (nonlinear (neg t))).

set2cond/U :
    set2cond B O S' Pi ->
    set`add S' N S ->
    set`not-member S' N ->
    cxt`lookup B N (cxt-info/ O' (ty/ _ _ _)) ->
 set2cond B O S (unitperm (conditional (objequal O O') empty Pi)).


%%% Apply nonnull-ness

apply-nn : nonnull -> (object -> permission) -> (object -> permission) -> type.

apply-nn/may : apply-nn nn/may ([x] PF x)
               ([x] unitperm (conditional (objequal x null) empty (PF x))).

apply-nn/yes : apply-nn nn/yes ([x] PF x)
    ([x] (unitperm (nonlinear (neg (objequal x null))) , (PF x))).


%{
A whole object can be consumed, for instance, in x.f = a, object
a is consumed. In this case, we treated as if all of a's field are
consumed. But, we also need the encumbered permission:
 \forall f (P(a.f) encumbered-in P(a.all))
Given a set of objects, the relation "make-encumbered" construct
such an encumbered permission for each object, using "fldmap2perm".
}%

fldmap2perm : predmap -> object -> fldmap -> set -> permission -> type.

fldmap2perm/0 : fldmap2perm _ _ _ set/0 empty.

fldmap2perm/+ :
    set`shift F S1 S2 ->
    fldmap2perm PM O FM S2 Pi ->
    fldmap`lookup FM F T ->
    ty2perm PM T PF ->
  fldmap2perm PM O FM (set/+ F S1) (unitperm (precise-exists O F PF) , Pi).


fldmap2perm2 : predmap -> object -> fldmap -> permission -> type.

fldmap2perm2/ :
    fldmap`domain FM FS ->
    fldmap2perm PM O FM FS Pi ->
  fldmap2perm2 PM O FM Pi.


%{
Convert a type in a context to a permission
The interesting case is unique type, for which we convert to an
encumbered permissions. The field permissions are recorded in the
capabilities, together with which we can restore the whole permission
for the object, and then used for consumption.
}%

ty2perm2 : predmap -> ty -> (object -> permission) -> type.

ty2perm2/null : ty2perm2 _ ty/null ([x] unitperm (nonlinear (objequal x null))).

ty2perm2/shared :
    ty2perm PM (ty/ NN annot/shared C) PF ->
  ty2perm2 PM (ty/ NN annot/shared C) ([x] PF x).

ty2perm2/borrow :
    ty2perm PM (ty/ NN annot/borrow C) PF ->
  ty2perm2 PM (ty/ NN annot/borrow C) ([x] PF x).

ty2perm2/unique :
    ty2perm PM (ty/ NN annot/borrow C) PF ->
  ty2perm2 PM (ty/ NN annot/unique C) ([x] PF x).


%{
Convert the explicit context to permissions, which
consists of non-null information, class predicate, and,
for shared the nesting facts, for each parameter.
Notice that, unique has the same permission as borrowed
parameter. We use a separate procedure to generate the
encumbered permission for them. So, the cxt should only
contain borrowed and shared types.
}%

cxt2perm : clsmap -> predmap -> cxt -> permission -> type.

cxt2perm/0 : cxt2perm _ _ cxt/0 empty.

cxt2perm/U :
    cxt2perm CM PM B' Pi2 ->
    cxt`fresh B' N ->
    cxt`update B' N (cxt-info/ O T) B ->
    ty2perm2 PM T PF ->
  cxt2perm CM PM B ((PF O) , Pi2).


%%% Create field permission

create-fldperm : clsmap -> predmap -> nat -> nat -> (object -> permission) -> type.

create-fldperm/ :
    clsmap`lookup CM C FM ->
    fldmap`lookup FM F T ->
    ty2perm PM T PF ->
  create-fldperm CM PM C F ([x] PF x).

%{
Convert a capability set (capset) to a set of permissions:
Each entry (O, F) in the capset will be converted to a packed whole
field permission. Note that, the object O in this case must be
not-null, otherwise we cannot do anything on the field F.
To unlock the nonnull, we need to lookup context.
}%

capset2perm : clsmap -> predmap -> cxt -> set -> permission -> type.

capset2perm/0 : capset2perm _ _ _ set/0 empty.

capset2perm/U :
    capset2perm CM PM B CS' Pi2 ->
    nat2pair (s K) (pair/ N F) ->
    cxt`lookup B N (cxt-info/ O (ty/ _ _ C)) ->
    create-fldperm CM PM C F PF ->
    set`not-member CS' (s K) ->
    set`add CS' (s K) CS ->
  capset2perm CM PM B CS (combine
    (unitperm (conditional (objequal O null) empty (fldperm O F PF)))
    Pi2).

capset2perm/z :
    capset2perm CM PM B CS' Pi ->
    set`not-member CS' shared ->
    set`add CS' shared CS ->
  capset2perm CM PM B CS (combine (unitperm (basic null all null)) Pi).


make-encumbered : clsmap -> predmap -> cxt -> set -> permission -> type.

make-encumbered/0 : make-encumbered _ _ _ set/0 empty.

make-encumbered/U :
    make-encumbered CM PM B S' Pi2 ->
    cxt`lookup B N (cxt-info/ O (ty/ NN _ C)) ->
    clsmap`lookup CM C FM ->
    predmap`lookup PM C CP ->
    fldmap`domain FM FS ->
    ({x} fldmap2perm PM x FM FS (PF x)) ->
    set`not-member S' N ->
    set`add S' N S ->
  make-encumbered CM PM B S ((encumbered-fldperm O PF CP) , Pi2).


%%% Convert an input environment (context and capabilities) to a set of
%%% input permissions.

env2input : clsmap -> predmap -> cxt -> env -> permission -> type.

env2input/ :
    make-encumbered CM PM B U PiU ->
    capset2perm CM PM B M PiM ->
  env2input CM PM B (env/ U M) (PiU , PiM).


%%% Convert result to output permissions.

reftype2perm : clsmap -> predmap -> cxt -> reftype -> (object -> object -> permission) -> type.

reftype2perm/shared :
    ty2perm PM (ty/ NN annot/shared C) PF ->
  reftype2perm CM PM _ (reftype/ NN C targets/shared) ([o][_] PF o).

reftype2perm/borrow :
    set`size S (nat`s _) ->
    set`size M nat`z ->
    ty2perm PM (ty/ NN annot/borrow C) PF ->
    ({x} set2cond B x S (GF x)) ->
  reftype2perm CM PM B (reftype/ NN C (targets/unique S M)) ([o][_] (PF o) , (GF o)).

reftype2perm/unique :
    set`size M (nat`s _) ->
    ty2perm PM (ty/ NN annot/unique C) PF ->
    ({x} set2cond B x S (GF x)) ->
    capset2perm CM PM B M Pi ->
  reftype2perm CM PM B (reftype/ NN C (targets/unique S M))
    ([o][r] combine
      (unitperm
        (conditional (objequal o r) empty (GF o)))
      (combine (PF r) (unitperm (encumbered (PF r) Pi)))).

%%% TODO: another reftype2perm for fresh new objects


result2output* : clsmap -> predmap -> cxt -> permission -> result K -> output K -> type.

result2output/expr :
    cxt2perm CM PM B Pi_B ->
    env2input CM PM B V Pi_V ->
    reftype2perm CM PM B RT Pi_T ->
  result2output* CM PM B Pi (result/expr RT V)
    (output/exists [o]
      (output/exists [r]
        (output/expr o
          (combine (combine Pi_B (combine (Pi_T o r) Pi_V)) Pi)))).

result2output/args/0 :
    cxt2perm CM PM B PiB ->
    env2input CM PM B V Pi1 ->
  result2output* CM PM B Pi0 (result/args/0 V) (output/args/0 (Pi0 , (PiB , Pi1))).

result2output/args/+ :
    reftype2perm CM PM B RT ([o][r] PF o r) ->
    make-encumbered CM PM B U PiU ->
    capset2perm CM PM B M PiM ->
    ({o}{r} result2output* CM PM B (((PF o r) , (PiU , PiM)) , Pi) A (AO o r)) ->
  result2output* CM PM B Pi (result/args/+ RT (env/ U M) A)
    (output/exists [o] (output/exists [r] (output/args/+ o (AO o r)))).


%abbrev result2output : clsmap -> predmap -> cxt -> result K -> output K -> type =
    [CM][PM][B][R][O] result2output* CM PM B empty R O.

%%% Convert a method type to a proctype

declared-capset2perm : clsmap -> predmap -> nat -> set -> (object -> permission) -> type.

declared-capset2perm/0 : declared-capset2perm _ _ _ set/0 ([_] empty).

declared-capset2perm/U :
    declared-capset2perm CM PM C M' ([x] Pi2 x) ->
    create-fldperm CM PM C F PF ->
    set`not-member M' F ->
    set`add M' F M ->
  declared-capset2perm CM PM C M
    ([x] combine (unitperm (conditional (objequal x null) empty
      (fldperm x F PF))) (Pi2 x)).


argtype2perm : clsmap -> predmap -> ty -> set
    -> (object -> permission) -> (object -> permission) -> type.

argtype2perm/unique :
    ty2perm PM (ty/ NN annot/unique C) PF ->
  argtype2perm CM PM (ty/ NN annot/unique C) _ ([x] PF x) ([_] empty).

argtype2perm/shared :
    ty2perm PM (ty/ NN annot/shared C) PF ->
  argtype2perm CM PM (ty/ NN annot/shared C) _ ([x] PF x) ([x] PF x).

argtype2perm/borrow :
    declared-capset2perm CM PM C M PF ->
  argtype2perm CM PM (ty/ NN annot/borrow C) M ([x] PF x) ([x] PF x).


methty2proctype* : clsmap -> predmap -> permission -> permission -> methty -> proctype -> type.

methty2proctype/base :
    ty2perm PM T PF ->
  methty2proctype* _ PM Pi1 Pi2 (methty/base T)
    (proctype/base Pi1 (output/exists [r] (output/expr r ((PF r) , Pi2)))).

methty2proctype/arg :
    argtype2perm CM PM T M PF1 PF2 ->
    ({x} methty2proctype* CM PM ((PF1 x) , Pi1) ((PF2 x) , Pi2) MT (PTF x)) ->
  methty2proctype* CM PM Pi1 Pi2 (methty/arg T M MT) (proctype/arg PTF).

%abbrev methty2proctype = [CM][PM][MT][PT] methty2proctype* CM PM empty empty MT PT.


%%% Convert a constructor type to a proctype
consty2proctype* : clsmap -> fldmap -> predmap -> permission ->
     permission -> methty -> (object -> proctype) -> type.

consty2proctype/base :
    fldmap`domain FM S ->
    ({x} allocFields x S (OS x)) ->
    ty2perm PM T PF ->
  consty2proctype* _ FM PM Pi1 Pi2 (methty/base T)
    ([x] proctype/base
      (combine Pi (combine (obj-not-null x) (OS x)))
      (output/exists [r] (output/expr r ((PF r) , Pi2)))).

consty2proctype/arg :
    argtype2perm CM PM T M PF1 PF2 ->
    ({o} consty2proctype* CM FM PM ((PF1 o) , Pi1) ((PF2 o) , Pi2) CT ([t] PTF t o)) ->
  consty2proctype* CM FM PM Pi1 Pi2 (methty/arg T M CT) ([t] proctype/arg (PTF t)).

%abbrev consty2proctype = [CM][FM][PM][MT][PTF] consty2proctype* CM FM PM empty empty MT PTF.


%%% Convert a method map into a progtype.

methmap2progtype : clsmap -> predmap -> methmap -> progtype -> type.

methmap2progtype/0 : methmap2progtype _ _ methmap/0 progtype`map/0.

methmap2progtype/U/c :
    methmap2progtype CM PM MM' W' ->
    clsmap`lookup CM C FM ->
    consty2proctype CM FM PM CT PTF ->
    methmap`fresh MM' N ->
    methmap`update MM' N (methty/arg (ty/ nn/yes annot/unique C) set/0 CT) MM ->
    progtype`update W' N (proctype/arg PTF) W ->
  methmap2progtype CM PM MM W.

methmap2progtype/U/m :
    methmap2progtype CM PM MM' W' ->
    clsmap`fresh CM N ->
    methty2proctype CM PM MT PT ->
    methmap`fresh MM' N ->
    methmap`update MM' N MT MM ->
    progtype`update W' N PT W ->
  methmap2progtype CM PM MM W.



%%% Theorems

%% 1, theorems about set2cond

%theorem false-implies-set2cond
  : forall* {O} {S} {G} {B}
    forall {V:void}
    exists {S=>G: set2cond B O S G}
    true.

%worlds (objvar) (false-implies-set2cond _ _).
%total {} (false-implies-set2cond _ _).


%theorem set2cond-respects-eq
  : forall* {S1} {S2} {O1} {O2} {G1} {G2} {B1} {B2}
    forall {S2G: set2cond B1 O1 S1 G1}
    {E: cxt`eq B1 B2} {E: object`eq O1 O2} {E: set`eq S1 S2}
    {E: permission`eq G1 G2}
    exists {S2G2: set2cond B2 O2 S2 G2}
    true.

- : set2cond-respects-eq S2G cxt`eq/ object`eq/ set`eq/ permission`eq/ S2G.

%worlds (objvar) (set2cond-respects-eq _ _ _ _ _ _).
%total {} (set2cond-respects-eq _ _ _ _ _ _).


%theorem cxt-unique-objset-implies-set2cond
  : forall* {B} {NN} {C} {S} {O}
    forall {CM-B-S: cxt-unique-objset B NN C S}
    exists {G} {S2G: set2cond B O S G}
    true.

- : cxt-unique-objset-implies-set2cond cxt-unique-objset/0 _ set2cond/0.

- : cxt-unique-objset-implies-set2cond
    (cxt-unique-objset/U B-S' BL _ _ F U) _ (set2cond/U S2G' U F BL)
    <- cxt-unique-objset-implies-set2cond B-S' _ S2G'.

%worlds (objvar) (cxt-unique-objset-implies-set2cond _ _ _).
%total (A) (cxt-unique-objset-implies-set2cond A _ _).


%theorem same-class-implies-set2cond
  : forall* {B} {S} {C} {O}
    forall {SOC: same-class B S C}
    exists {G} {S2G: set2cond B O S G}
    true.

- : same-class-implies-set2cond same-class/0 _ set2cond/0.

- : same-class-implies-set2cond (same-class/U SOC' F U BL)
    _ (set2cond/U S2G' U F BL)
    <- same-class-implies-set2cond SOC' _ S2G'.

%worlds (objvar) (same-class-implies-set2cond _ _ _).
%total (B) (same-class-implies-set2cond B _ _).


%theorem clsmap-cxt-objset-implies-set2cond
  : forall* {CM} {B} {S} {O}
    forall {B-S: clsmap-cxt-objset CM B S}
    exists {G} {S2G: set2cond B O S G}
    true.

- : clsmap-cxt-objset-implies-set2cond clsmap-cxt-objset/0 _ set2cond/0.

- : clsmap-cxt-objset-implies-set2cond
    (clsmap-cxt-objset/U B-S' BL CML FS U)
    _ (set2cond/U S'2G U FS BL)
    <- clsmap-cxt-objset-implies-set2cond B-S' _ S'2G.

%worlds () (clsmap-cxt-objset-implies-set2cond _ _ _).
%total (CM) (clsmap-cxt-objset-implies-set2cond CM _ _).


%theorem set2cond/U-inversion
  : forall* {B} {O} {S} {SP} {G} {N}
    forall {S=>G: set2cond B O S G}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    exists {GP} {SP=>GP: set2cond B O SP GP}
    {O'} {T} {BL: cxt`lookup B N (cxt-info/ O' T)}
    {IMP1: implies G (unitperm (conditional (objequal O O') empty GP))}
    {IMP2: implies (unitperm (conditional (objequal O O') empty GP)) G}
    true.

%theorem set2cond/U-inversion/L
  : forall* {B} {O} {S} {SP} {N} {S1} {N1} {G1} {P} {O1'} {T1}
    forall {NM1: set`not-member S1 N1}
    {A1: set`add S1 N1 S}
    {S1=>G1: set2cond B O S1 G1}
    {BL: cxt`lookup B N1 (cxt-info/ O1' T1)}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    {E?: nat`eq? N N1 P}
    exists {GP} {SP=>GP: set2cond B O SP GP}
    {O'} {T} {BL: cxt`lookup B N (cxt-info/ O' T)}
    {IMP1: implies
           (unitperm (conditional (objequal O O1') empty G1))
           (unitperm (conditional (objequal O O') empty GP))}
    {IMP2: implies
           (unitperm (conditional (objequal O O') empty GP))
           (unitperm (conditional (objequal O O1') empty G1))}
    true.

- : set2cond/U-inversion
    (set2cond/U
      (S2G1:set2cond B O S1 G1)
      (U1:set`add S1 N1 S)
      (F1:set`not-member S1 N1)
      (BL1:cxt`lookup B N1 (cxt-info/ O1 _)))
    (F2:set`not-member SP N)
    (U2:set`add SP N S) GP S2G O' T BL IMP1 IMP2
    <- nat`eq?-total E?
    <- set2cond/U-inversion/L F1 U1 S2G1 BL1 F2 U2 E? GP S2G O' T BL IMP1 IMP2.

- : set2cond/U-inversion/L F1 U1 S2G1 BL1 F2 U2 nat`eq?/yes _ S2G _ _ BL1
    (implies/reflexive) (implies/reflexive)
    <- set`not-member-add-cancels F1 U1 F2 U2 nat`eq/ set`eq/ S1=S2
    <- set2cond-respects-eq S2G1 cxt`eq/ object`eq/ S1=S2 permission`eq/ S2G.

%% Need this in implication.elf:
%% (x == o1 ? empty : (x == o2 ? empty : Pi)) ==>
%% (x == o2 ? empty : (x == o1 ? empty : Pi))
% - : set2cond/U-inversion/L F1 U1 S2G1 BL1 F2 U2 (nat`eq?/no N<>N1) _
%     (set2cond/U S2G U4 F4 BL1) _ _ BL3
%     <- set`add-commutes-converse U2 U1 N<>N1 _ U4 U3
%     <- set`add-preserves-not-member-converse F2 U4 F3
%     <- set`add-preserves-not-member-converse F1 U3 F4
%     <- set2cond/U-inversion S2G1 F3 U3 _ S2G _ _ BL3 IMP1 IMP2.

%worlds (objvar) (set2cond/U-inversion _ _ _ _ _ _ _ _ _ _)
  (set2cond/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (N N1) (set2cond/U-inversion N _ _ _ _ _ _ _ _ _)
  (set2cond/U-inversion/L _ _ N1 _ _ _ _ _ _ _ _ _ _ _).


%theorem set2cond-implies
  : forall* {B} {O1} {O2} {S1} {S2} {G1} {G2}
    forall {S1=>G1: set2cond B O1 S1 G1}
    {S2=>G2: set2cond B O2 S2 G2}
    {E: object`eq O1 O2} {E: set`eq S1 S2}
    exists {IMP1: implies G1 G2} {IMP2: implies G2 G1}
    true.

%theorem set2cond-implies/L
  : forall* {O1} {O1'} {O2} {O2'} {G1} {G2}
    forall {OE: object`eq O1 O2} {OE: object`eq O1' O2'}
    {IMP1: implies G1 G2} {IMP2: implies G2 G1}
    exists {IMP1: implies
                  (unitperm (conditional (objequal O1 O1') empty G1))
                  (unitperm (conditional (objequal O2 O2') empty G2))}
    {IMP2: implies (unitperm (conditional (objequal O2 O2') empty G2))
           (unitperm (conditional (objequal O1 O1') empty G1))}
    true.

- : set2cond-implies/L object`eq/ object`eq/ IMP1 IMP2
    (implies/cond-inner bimplies/reflexive bimplies/reflexive
      implies/reflexive IMP1)
    (implies/cond-inner bimplies/reflexive bimplies/reflexive
      implies/reflexive IMP2).

- : set2cond-implies
    set2cond/0 set2cond/0 object`eq/ set`eq/ implies/reflexive implies/reflexive.

- : set2cond-implies (set2cond/U S2G0 F0 U0 L0) S2G OE SE
    (implies/trans IMP1R IMP2P) (implies/trans IMP1P IMP2R)
    <- set2cond/U-inversion S2G U0 F0 _ S2G1 _ _ L1 IMP1P IMP2P
    <- set2cond-implies S2G0 S2G1 OE set`eq/ IMP1Q IMP2Q
    <- cxt`lookup-unique L0 L1 cxt`eq/ nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE' TE
    <- set2cond-implies/L OE OE' IMP1Q IMP2Q IMP1R IMP2R.

%worlds (objvar) (set2cond-implies/L _ _ _ _ _ _).
%total { } (set2cond-implies/L _ _ _ _ _ _).

%worlds (objvar) (set2cond-implies _ _ _ _ _ _).
%total (R) (set2cond-implies R _ _ _ _ _).


%% theorems about apply-nn

%theorem apply-nn-respects-eq
  : forall* {NN} {NN'} {Pi1} {Pi1'} {Pi2} {Pi2'}
    forall {AP: apply-nn NN Pi1 Pi2}
    {AP': apply-nn NN' Pi1' Pi2'}
    {EQ: nonnull`eq NN NN'}
    {EQ: {x} permission`eq (Pi1 x) (Pi1' x)}
    exists {EQ: {x} permission`eq (Pi2 x) (Pi2' x)}
    true.

- : apply-nn-respects-eq AP AP nonnull`eq/ ([_] permission`eq/) ([_] permission`eq/).

%worlds (objvar) (apply-nn-respects-eq _ _ _ _ _).
%total { } (apply-nn-respects-eq _ _ _ _ _).


%theorem apply-nn-total*
  : forall {NN} {Pi}
    exists {Pi2} {AP: apply-nn NN Pi Pi2}
    true.

- : apply-nn-total* nn/yes _ _ apply-nn/yes.

- : apply-nn-total* nn/may _ _ apply-nn/may.

%worlds (objvar) (apply-nn-total* _ _ _ _).
%total { } (apply-nn-total* _ _ _ _).

%abbrev apply-nn-total = apply-nn-total* _ _.


%theorem apply-nn-unique
  : forall* {NN} {NN'} {Pi1} {Pi1'} {Pi2} {Pi2'}
    forall {AP1: apply-nn NN Pi1 Pi2}
    {AP2: apply-nn NN' Pi1' Pi2'}
    {EQ: nonnull`eq NN NN'}
    {EQ: {x} permission`eq (Pi1 x) (Pi1' x)}
    exists {EQ: {x} permission`eq (Pi2 x) (Pi2' x)}
    true.

- : apply-nn-unique AN AN nonnull`eq/ ([_] permission`eq/) ([_] permission`eq/).

%worlds (objvar) (apply-nn-unique _ _ _ _ _).
%total { } (apply-nn-unique _ _ _ _ _).


%% theorems about fldmap2perm

%theorem false-implies-fldmap2perm
  : forall* {PM} {O} {FM} {FS} {Pi}
    forall {V:void} exists {MFP: fldmap2perm PM O FM FS Pi}
    true.

%worlds (objvar) (false-implies-fldmap2perm _ _).
%total { } (false-implies-fldmap2perm _ _).


%theorem fldmap2perm-respects-eq
  : forall* {FS1} {PM1} {PM2} {O1} {O2} {FM1} {FM2} {Pi1} {Pi2} {FS2}
    forall {MFP1: fldmap2perm PM1 O1 FM1 FS1 Pi1}
    {PME: predmap`eq PM1 PM2} {OE: object`eq O1 O2}
    {FME: fldmap`eq FM1 FM2} {FSE: set`eq FS1 FS2}
    {PE: permission`eq Pi1 Pi2}
    exists {MFP2: fldmap2perm PM2 O2 FM2 FS2 Pi2}
    true.

- : fldmap2perm-respects-eq MFP predmap`eq/
    object`eq/ fldmap`eq/ set`eq/ permission`eq/ MFP.

%worlds (objvar) (fldmap2perm-respects-eq _ _ _ _ _ _ _).
%total {} (fldmap2perm-respects-eq _ _ _ _ _ _ _).


%theorem fldmap2perm-total
  : forall* {CM} {C} {PM} {O} {FM} {FS} {FS0}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS0}
    {FS<=FS0: set`leq FS FS0}
    exists {Pi} {MF1: fldmap2perm PM O FM FS Pi}
    true.

%theorem fldmap2perm-total/L
  : forall* {CM} {C} {PM} {O} {FM} {FS0} {FS}
    forall {N} {SZ: set`size FS N}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {DM: fldmap`domain FM FS0}
    {LE: set`leq FS FS0}
    exists {Pi} {MF1: fldmap2perm PM O FM FS Pi}
    true.

- : fldmap2perm-total/L z _ _ _ _ _ set`leq/0 _ fldmap2perm/0.

- : fldmap2perm-total/L (s N) SZ CM-CM CM2PM CML DM-FM=FS0 FS<=FS0 _
    (fldmap2perm/+ SH FS'=>Pi FML T2PF)
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) FS' F!<FS' FS'+F=FS
    <- set`not-member-update-implies-shift F!<FS' FS'+F=FS SH unit`eq/
    <- set`add-implies-member FS'+F=FS F<-FS
    <- set`member-respects-leq F<-FS FS<=FS0 F<-FS0
    <- fldmap`domain-preserves-lookup-converse F<-FS0 DM-FM=FS0 T FML
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- set`not-member-update-implies-leq F!<FS' FS'+F=FS FS'<=FS
    <- set`leq-transitive FS'<=FS FS<=FS0 FS'<=FS0
    <- set`not-member-add-increases-size-converse SZ F!<FS' FS'+F=FS SZ'
    <- fldmap2perm-total/L N SZ' CM-CM CM2PM CML DM-FM=FS0 FS'<=FS0 _ FS'=>Pi.

- : fldmap2perm-total CM-CM CM2PM CML DM LEQ _ MF1
    <- set`size-total SZ
    <- fldmap2perm-total/L _ SZ CM-CM CM2PM CML DM LEQ _ MF1.

%worlds (objvar) (fldmap2perm-total/L _ _ _ _ _ _ _ _ _).
%total (N) (fldmap2perm-total/L N _ _ _ _ _ _ _ _).

%worlds (objvar) (fldmap2perm-total _ _ _ _ _ _ _).
%total { } (fldmap2perm-total _ _ _ _ _ _ _).


%theorem fldmap2perm-unique
  : forall* {PM} {O} {FM} {FS} {Pi}
    {PM'} {O'} {FM'} {FS'} {Pi'}
    forall {MF1: fldmap2perm PM O FM FS Pi}
    {MF1': fldmap2perm PM' O' FM' FS' Pi'}
    {PME: predmap`eq PM PM'} {OE: object`eq O O'}
    {FME: fldmap`eq FM FM'} {FSE: set`eq FS FS'}
    exists {EQ: permission`eq Pi Pi'}
    true.

%theorem fldmap2perm-unique/L
  : forall* {O1} {O2} {N1} {N2} {PF1} {PF2} {Pi1} {Pi2}
    forall {O1=O2: object`eq O1 O2}
    {N1=N2: nat`eq N1 N2}
    {PF1=PF2: {x} permission`eq (PF1 x) (PF2 x)}
    {Pi1=Pi2: permission`eq Pi1 Pi2}
    exists {EQ: permission`eq (unitperm (precise-exists O1 N1 PF1) , Pi1)
                (unitperm (precise-exists O2 N2 PF2) , Pi2)}
    true.

- : fldmap2perm-unique/L object`eq/ nat`eq/
    ([_] permission`eq/) permission`eq/ permission`eq/.

- : fldmap2perm-unique fldmap2perm/0 fldmap2perm/0 predmap`eq/
    object`eq/ fldmap`eq/ set`eq/ permission`eq/.

- : fldmap2perm-unique
    (fldmap2perm/+ SH1 FM2P1 FML1 T2PF1)
    (fldmap2perm/+ SH2 FM2P2 FML2 T2PF2) (PM1=PM2:predmap`eq PM1 PM2)
    (O1=O2:object`eq O1 O2) (FM1=FM2:fldmap`eq FM1 FM2)
    (S1=S2) EQ
    <- set`map/+-preserves-eq-converse S1=S2 (N1=N2:nat`eq N1 N2) _ (SP1=SP2:set`eq SP1 SP2)
    <- set`shift-unique SH1 SH2 N1=N2 SP1=SP2 SQ1=SQ2
    <- fldmap2perm-unique FM2P1 FM2P2 PM1=PM2 O1=O2 FM1=FM2 SQ1=SQ2 Pi1=Pi2
    <- fldmap`lookup-unique FML1 FML2 FM1=FM2 N1=N2 T1=T2
    <- ty2perm-deterministic T2PF1 T2PF2 PM1=PM2 T1=T2 PF1=PF2
    <- fldmap2perm-unique/L O1=O2 N1=N2 PF1=PF2 Pi1=Pi2 EQ.

%worlds (objvar) (fldmap2perm-unique/L _ _ _ _ _).
%total { } (fldmap2perm-unique/L _ _ _ _ _).

%worlds (objvar) (fldmap2perm-unique _ _ _ _ _ _ _).
%total (A) (fldmap2perm-unique A _ _ _ _ _ _).



%theorem fldmap2perm2-total
  : forall* {CM} {C} {PM} {O} {FM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    exists {Pi} {MF1: fldmap2perm2 PM O FM Pi}
    true.

- : fldmap2perm2-total CM-CM CM2PM CML _ (fldmap2perm2/ FM-DM FM2P)
    <- fldmap`domain-total FM-DM
    <- set`leq-reflexive _ LE
    <- fldmap2perm-total CM-CM CM2PM CML FM-DM LE _ FM2P.

%worlds (objvar) (fldmap2perm2-total _ _ _ _ _).
%total { } (fldmap2perm2-total _ _ _ _ _).


%theorem fldmap2perm2-unique
  : forall* {PM1} {PM2} {O1} {O2} {FM1} {FM2} {Pi1} {Pi2}
    forall {FM=>Pi: fldmap2perm2 PM1 O1 FM1 Pi1}
    {FM=>Pi: fldmap2perm2 PM2 O2 FM2 Pi2}
    {PME: predmap`eq PM1 PM2} {OE: object`eq O1 O2}
    {FME: fldmap`eq FM1 FM2}
    exists {PE: permission`eq Pi1 Pi2}
    true.

- : fldmap2perm2-unique (fldmap2perm2/ DM1 FM2P1)
    (fldmap2perm2/ DM2 FM2P2) PME OE FME PE
    <- fldmap`domain-unique DM1 DM2 FME SE
    <- fldmap2perm-unique FM2P1 FM2P2 PME OE FME SE PE.

%worlds (objvar) (fldmap2perm2-unique _ _ _ _ _ _).
%total { } (fldmap2perm2-unique _ _ _ _ _ _).


%% theorems about cxt2perm

%% 2.1 theorems about ty2perm2

%theorem ty2perm2-respects-eq
  : forall* {T1} {T2} {PM1} {PM2} {PF1} {PF2}
    forall {T2PF: ty2perm2 PM1 T1 PF1}
    {PME: predmap`eq PM1 PM2} {TE: ty`eq T1 T2}
    {PFE: {o} permission`eq (PF1 o) (PF2 o)}
    exists {T2PF: ty2perm2 PM2 T2 PF2}
    true.

- : ty2perm2-respects-eq T2PF predmap`eq/ ty`eq/ ([_] permission`eq/) T2PF.

%worlds (objvar) (ty2perm2-respects-eq _ _ _ _ _).
%total { } (ty2perm2-respects-eq _ _ _ _ _).


%theorem ty2perm2-implies/L/unique
  : forall* {Pi1: object -> permission} {Pi2} {CP1} {CP2} {PF1} {PF2}
    forall {FEQ: {o} permission`eq (Pi1 o) (Pi2 o)}
    {PEQ: predicate`eq CP1 CP2} {PF-EQ: {x} equiv (PF1 x) (PF2 x)}
    exists
    {IMP1: {x} implies
           (combine (Pi1 x)
             (unitperm (conditional (objequal x null) empty
                         (unitperm (encumbered (PF1 x)
                                     (combine (allperm x) (one-predcall CP1 x)))))))
           (combine (Pi2 x)
             (unitperm (conditional (objequal x null) empty
                         (unitperm (encumbered (PF2 x)
                                     (combine (allperm x) (one-predcall CP2 x)))))))}
    {IMP2: {x} implies
           (combine (Pi2 x)
             (unitperm (conditional (objequal x null) empty
                         (unitperm (encumbered (PF2 x)
                                     (combine (allperm x) (one-predcall CP2 x)))))))
           (combine (Pi1 x)
             (unitperm (conditional (objequal x null) empty
                         (unitperm (encumbered (PF1 x)
                                     (combine (allperm x) (one-predcall CP1 x)))))))}
    true.

- : ty2perm2-implies/L/unique
     ([_] permission`eq/) predicate`eq/ ([x] EQV x)
    ([x] implies/combine (implies/reflexive)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (implies/equiv-encumbered (EQV x) equiv/reflexive)))
    ([x] implies/combine (implies/reflexive)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/reflexive)
        (implies/equiv-encumbered (equiv/symmetric (EQV x)) equiv/reflexive))).

%worlds (objvar) (ty2perm2-implies/L/unique _ _ _ _ _).
%total  {} (ty2perm2-implies/L/unique _ _ _ _ _).


%theorem ty2perm2-equiv
  : forall* {PM1} {PM2} {T1} {T2} {PF1} {PF2}
    forall {T12PF1: ty2perm2 PM1 T1 PF1}
    {T22PF2: ty2perm2 PM2 T2 PF2}
    {E: predmap`eq PM1 PM2} {EQ: ty`eq T1 T2}
    exists {IMP: {o} implies (PF1 o) (PF2 o)}
    {IMP: {o} implies (PF2 o) (PF1 o)}
    true.

% - : ty2perm2-implies
%     (ty2perm2/unique CML1 PML1 ([x] FM=>PF1 x) T=>Pi1)
%     (ty2perm2/unique CML2 PML2 ([x] FM=>PF2 x) T=>Pi2)
%     (CM-EQ:clsmap`eq CM1 CM2) (PM-EQ:predmap`eq PM1 PM2) T-EQ IMP1 IMP2
%     <- ty-eq-inversion T-EQ NN-EQ A-EQ C-EQ
%     <- clsmap`lookup-unique CML1 CML2 CM-EQ C-EQ FM-EQ
%     <- predmap`lookup-unique PML1 PML2 PM-EQ C-EQ CP-EQ
%     <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ2
%     <- ty2perm-deterministic T=>Pi1 T=>Pi2 PM-EQ T-EQ2 PF-EQ
%     <- ({x} fldmap2perm2-unique (FM=>PF1 x) (FM=>PF2 x) PM-EQ object`eq/ FM-EQ (EQ x))
%     <- ({x} permission`eq-implies-equiv (EQ x) (EQV x))
%     <- ty2perm2-implies/L/unique PF-EQ CP-EQ EQV IMP1 IMP2.

% - : ty2perm2-implies
%     (ty2perm2/borrow T2PF1) (ty2perm2/borrow T2PF2)
%     PM-EQ T-EQ ([x] implies/equiv (EQV x))
%     ([x] implies/equiv (equiv/symmetric (EQV x)))
%     <- ty-eq-inversion T-EQ NN-EQ A-EQ C-EQ
%     <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ2
%     <- ty2perm-deterministic T2PF1 T2PF2 PM-EQ T-EQ2 PF-EQ
%     <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV x)).

% - : ty2perm2-implies
%     (ty2perm2/unique T2PF1) (ty2perm2/unique T2PF2)
%     PM-EQ T-EQ ([x] implies/equiv (EQV x))
%     ([x] implies/equiv (equiv/symmetric (EQV x)))
%     <- ty-eq-inversion T-EQ NN-EQ A-EQ C-EQ
%     <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ2
%     <- ty2perm-deterministic T2PF1 T2PF2 PM-EQ T-EQ2 PF-EQ
%     <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV x)).

% - : ty2perm2-implies
%     (ty2perm2/shared T2PF1) (ty2perm2/shared T2PF2)
%     PM-EQ T-EQ ([x] implies/equiv (EQV x)).
%     ([x] implies/equiv (equiv/symmetric (EQV x)))
%     <- ty-eq-inversion T-EQ NN-EQ A-EQ C-EQ
%     <- ty-preserves-eq NN-EQ annot`eq/ C-EQ T-EQ2
%     <- ty2perm-deterministic T2PF1 T2PF2 PM-EQ T-EQ2 PF-EQ
%     <- ({x} permission`eq-implies-equiv (PF-EQ x) (EQV x)).

% - : ty2perm2-implies ty2perm2/null ty2perm2/null _ _ _ ([_] implies/reflexive)
%     ([_] implies/reflexive).

%worlds (objvar) (ty2perm2-equiv _ _ _ _ _ _).
%trustme %total { } (ty2perm2-equiv _ _ _ _ _ _).


%theorem clsmap-lookup-implies-ty2perm2*
  : forall* {CM} {PM} {FM} {C} {NN}
    forall {A} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    exists {PF} {T2PF: ty2perm2 PM (ty/ NN A C) PF}
    true.

- : clsmap-lookup-implies-ty2perm2*
    annot/shared _ CM2PM CM-L _ (ty2perm2/shared (ty2perm/ PM-L NN2P A2P))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CM-L _ PM-L
    <- annot2perm-total A2P
    <- nn2perm-total NN2P.

- : clsmap-lookup-implies-ty2perm2*
    annot/borrow _ CM2PM CM-L _ (ty2perm2/borrow (ty2perm/ PM-L NN2P A2P))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CM-L _ PM-L
    <- annot2perm-total A2P
    <- nn2perm-total NN2P.

- : clsmap-lookup-implies-ty2perm2*
    annot/unique _ CM2PM CM-L _ (ty2perm2/unique (ty2perm/ PM-L NN2P A2P))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CM-L _ PM-L
    <- annot2perm-total A2P
    <- nn2perm-total NN2P.

%worlds (objvar) (clsmap-lookup-implies-ty2perm2* _ _ _ _ _ _).
%total {} (clsmap-lookup-implies-ty2perm2* _ _ _ _ _ _).

%abbrev clsmap-lookup-implies-ty2perm2 = clsmap-lookup-implies-ty2perm2* _.


%theorem false-implies-cxt2perm
  : forall* {CM} {PM} {B} {Pi}
    forall {F:void} exists {B2P: cxt2perm CM PM B Pi}
    true.

%worlds () (false-implies-cxt2perm _ _).
%total { } (false-implies-cxt2perm _ _).


%theorem cxt2perm-respects-eq
  : forall* {CM} {PM} {B} {Pi} {CM'} {PM'} {B'} {Pi'}
    forall {B2P: cxt2perm CM PM B Pi}
    {CME: clsmap`eq CM CM'} {PME: predmap`eq PM PM'}
    {BE: cxt`eq B B'} {PE: permission`eq Pi Pi'}
    exists {B2P': cxt2perm CM' PM' B' Pi'}
    true.

- : cxt2perm-respects-eq B2P clsmap`eq/ predmap`eq/ cxt`eq/ permission`eq/ B2P.

%worlds (objvar) (cxt2perm-respects-eq _ _ _ _ _ _).
%total { } (cxt2perm-respects-eq _ _ _ _ _ _).


%theorem clsmap-cxt-implies-cxt2perm
  : forall* {CM} {PM} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    exists {Pi:permission} {B=>Pi: cxt2perm CM PM B Pi}
    true.

- : clsmap-cxt-implies-cxt2perm _ _ clsmap-cxt/0 _ cxt2perm/0.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/U CM-B' (clsmap-ty/ L) BF BU)
    _ (cxt2perm/U B2P' BF BU T2PF)
    <- clsmap-lookup-implies-ty2perm2 CM-CM CM2PM L _ T2PF
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B' _ B2P'.

%worlds (objvar) (clsmap-cxt-implies-cxt2perm _ _ _ _ _).
%total (CM-B) (clsmap-cxt-implies-cxt2perm _ _ CM-B _ _).


%theorem cxt2perm/U-inversion
  : forall* {CM} {PM} {B} {Pi} {BP} {N} {O} {T}
    forall {B2P: cxt2perm CM PM B Pi}
    {F: cxt`fresh BP N}
    {U: cxt`update BP N (cxt-info/ O T) B}
    exists {PiP} {BP2P: cxt2perm CM PM BP PiP}
    {PF} {T2P: ty2perm2 PM T PF}
    {E: equiv Pi (combine (PF O) PiP)}
    true.

%theorem cxt2perm/U-inversion/L
  : forall* {CM} {PM} {B} {BP} {N} {O} {T} {B1} {N1} {O1} {T1} {PF1} {Pi1} {P}
    forall {B2P1: cxt2perm CM PM B1 Pi1}
    {F1: cxt`fresh B1 N1}
    {U1: cxt`update B1 N1 (cxt-info/ O1 T1) B}
    {R1: ty2perm2 PM T1 PF1}
    {F: cxt`fresh BP N}
    {U: cxt`update BP N (cxt-info/ O T) B}
    {E?: nat`eq? N N1 P}
    exists {PiP} {BP2P: cxt2perm CM PM BP PiP}
    {PF} {R: ty2perm2 PM T PF}
    {E: equiv (combine (PF1 O1) Pi1) (combine (PF O) PiP)}
    true.

- : cxt2perm/U-inversion/L B2P1 F1 U1 R1 F2 U2 nat`eq?/yes _ B2P _ R
    (equiv/combine PEQV equiv/reflexive)
    <- cxt`fresh-update-cancels F1 U1 F2 U2 nat`eq/ cxt`eq/ CIE BE
    <- cxt2perm-respects-eq B2P1 clsmap`eq/ predmap`eq/ BE permission`eq/ B2P
    <- cxt-info-eq-inversion CIE (OE:object`eq O O') TE
    <- ty2perm2-respects-eq (R1:ty2perm2 PM _ PF)
      predmap`eq/ TE ([_] permission`eq/) R
    <- permission`apply-object-preserves-eq
      (([_] permission`eq/):({o} permission`eq (PF o) (PF o))) OE PE
    <- permission`eq-implies-equiv PE PEQV.

- : cxt2perm/U-inversion/L B2P1 F1 U1 R1 F2 U2 (nat`eq?/no N<>N1)
    _ (cxt2perm/U B2P2 F4 U4 R1) _ R
    (equiv/transitive (equiv/combine equiv/reflexive EQV1) equiv/roll2)
    <- cxt`update-commutes-converse U2 U1 N<>N1 _ U4 U3
    <- cxt`update-preserves-fresh-converse F2 U4 F3
    <- cxt`update-preserves-fresh-converse F1 U3 F4
    <- cxt2perm/U-inversion B2P1 F3 U3 _ B2P2 _ R EQV1.

- : cxt2perm/U-inversion (cxt2perm/U B2P0 F0 U0 R0) F1 U1 _ B2P _ R EQV
    <- nat`eq?-total E?
    <- cxt2perm/U-inversion/L B2P0 F0 U0 R0 F1 U1 E? _ B2P _ R EQV.

%worlds (objvar) (cxt2perm/U-inversion _ _ _ _ _ _ _ _)
  (cxt2perm/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _).
%total (R R0) (cxt2perm/U-inversion R _ _ _ _ _ _ _)
  (cxt2perm/U-inversion/L R0 _ _ _ _ _ _ _ _ _ _ _).


%theorem cxt2perm-implies
  : forall* {CM} {CM'} {PM} {PM'} {B} {B'} {Pi} {Pi'}
    forall {B=>Pi: cxt2perm CM PM B Pi}
    {B=>Pi': cxt2perm CM' PM' B' Pi'}
    {CME: clsmap`eq CM CM'} {PME: predmap`eq PM PM'} {BE: cxt`eq B B'}
    exists {IMP: implies Pi Pi'} {IMP: implies Pi' Pi}
    true.

% - : cxt2perm-implies cxt2perm/0 cxt2perm/0 _ _ _ implies/reflexive implies/reflexive.

% - : cxt2perm-implies (cxt2perm/U B2P0 F0 (U0:cxt`update _ _ (cxt-info/ O T) _)
%                      (R0:ty2perm2 CM0 PM0 T PF0)) B2P CME PME BE
%     (implies/trans
%       (implies/combine (IMP1 O) (IMP3))
%       (implies/equiv (equiv/symmetric EQV1)))
%     (implies/trans
%       (implies/equiv EQV1)
%       (implies/combine (IMP2 O) (IMP4)))
%     <- cxt2perm/U-inversion B2P F0 U0 _ B2P1 _ (R1:ty2perm2 CM1 PM1 T PF1) EQV1
%     <- cxt2perm-implies B2P0 B2P1 CME PME cxt`eq/ IMP3 IMP4
%     <- ty2perm2-implies R0 R1 CME PME ty`eq/ IMP1 IMP2.

%worlds (objvar) (cxt2perm-implies _ _ _ _ _ _ _).
%trustme %total (T) (cxt2perm-implies T _ _ _ _ _ _).


%theorem cxt2perm-lookup-not-shared-can-duplicate
  : forall* {CM} {PM} {B} {PiB} {N} {O} {NN} {A} {C}
    forall {B=>PiB: cxt2perm CM PM B PiB}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {U-OR-B: unique-or-borrow A}
    exists {PF} {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    {IMP: implies PiB (combine (PF O) PiB)}
    true.

- : cxt2perm-lookup-not-shared-can-duplicate
    B=>PiB (BL:cxt`lookup B N (cxt-info/ O _)) unique-or-borrow/borrow _ T2PF
    (implies/trans4
      (implies/equiv EQV)
      (implies/combine (IMP2 O) implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive (implies/equiv (equiv/symmetric EQV))))
    <- cxt`lookup-implies-fresh-update BL BP N!<BP BP+N=B
    <- cxt2perm/U-inversion B=>PiB N!<BP BP+N=B PiBP BP=>PiBP _
      (ty2perm2/borrow T2PF) EQV
    <- can-duplicate-borrow T2PF IMP2.

- : cxt2perm-lookup-not-shared-can-duplicate
    B=>PiB (BL:cxt`lookup B N (cxt-info/ O _)) unique-or-borrow/unique _ T2PF
    (implies/trans4
      (implies/equiv EQV)
      (implies/combine (IMP2 O) implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive (implies/equiv (equiv/symmetric EQV))))
    <- cxt`lookup-implies-fresh-update BL BP N!<BP BP+N=B
    <- cxt2perm/U-inversion B=>PiB N!<BP BP+N=B PiBP BP=>PiBP _
      (ty2perm2/unique T2PF) EQV
    <- can-duplicate-borrow T2PF IMP2.

%worlds (objvar) (cxt2perm-lookup-not-shared-can-duplicate _ _ _ _ _ _).
%total { } (cxt2perm-lookup-not-shared-can-duplicate _ _ _ _ _ _).


%theorem ty2perm2-duplicate-notnull-info
  : forall* {PM} {PF} {A} {C}
    forall {T2PF: ty2perm2 PM (ty/ nn/yes A C) PF}
    exists {IMP: {x} implies (PF x)
                 (combine (unitperm (nonlinear (neg (objequal x null)))) (PF x))}
    true.

- : ty2perm2-duplicate-notnull-info
    (ty2perm2/borrow (ty2perm/ _ nn2perm/yes _))
    ([_] implies/trans
      (implies/combine implies/duplicate implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))).

- : ty2perm2-duplicate-notnull-info
    (ty2perm2/unique (ty2perm/ _ nn2perm/yes _))
    ([_] implies/trans
      (implies/combine implies/duplicate implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))).

- : ty2perm2-duplicate-notnull-info
    (ty2perm2/shared (ty2perm/ _ nn2perm/yes _))
    ([_] implies/trans
      (implies/combine implies/duplicate implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))).

%worlds (objvar) (ty2perm2-duplicate-notnull-info _ _).
%total { } (ty2perm2-duplicate-notnull-info _ _).


%theorem cxt2perm-duplicate-notnull-info
  : forall* {CM} {PM} {N} {Pi} {O} {A} {C} {B}
    forall {B2P: cxt2perm CM PM B Pi}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ nn/yes A C))}
    exists {IMP: implies Pi (combine (unitperm (nonlinear (neg (objequal O null)))) Pi)}
    true.

- : cxt2perm-duplicate-notnull-info B2P BL
    (implies/trans4
      (implies/equiv EQV)
      (implies/combine (IMP _) implies/reflexive)
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine implies/reflexive (implies/equiv (equiv/symmetric EQV))))
    <- cxt`lookup-implies-fresh-update BL BP N!<BP BP+N=B
    <- cxt2perm/U-inversion B2P N!<BP BP+N=B _ B2PP _ T2PF2 EQV
    <- ty2perm2-duplicate-notnull-info T2PF2 IMP.

%worlds (objvar) (cxt2perm-duplicate-notnull-info _ _ _).
%total { } (cxt2perm-duplicate-notnull-info _ _ _).


%%% theorems about create-fldperm

%theorem create-fldperm-unique
  : forall* {CM1} {CM2} {PM1} {PM2} {C1} {C2} {F1} {F2} {PF1} {PF2}
    forall {CF1: create-fldperm CM1 PM1 C1 F1 PF1}
    {CF2: create-fldperm CM2 PM2 C2 F2 PF2}
    {EQ: clsmap`eq CM1 CM2}
    {EQ: predmap`eq PM1 PM2}
    {EQ: nat`eq C1 C2}
    {EQ: nat`eq F1 F2}
    exists {EQ: {x} permission`eq (PF1 x) (PF2 x)}
    true.

- : create-fldperm-unique
    (create-fldperm/ CML1 FML1 T2PF1) (create-fldperm/ CML2 FML2 T2PF2)
    CME PME CE FE PE
    <- clsmap`lookup-unique CML1 CML2 CME CE FME
    <- fldmap`lookup-unique FML1 FML2 FME FE TE
    <- ty2perm-deterministic T2PF1 T2PF2 PME TE PE.

%worlds (objvar) (create-fldperm-unique _ _ _ _ _ _ _).
%total { } (create-fldperm-unique _ _ _ _ _ _ _).


%% 6, theorems about capset2perm

%theorem false-implies-capset2perm
  : forall* {CM} {PM} {B} {M} {Pi}
    forall  {V: void}
    exists  {M=>Pi: capset2perm CM PM B M Pi}
    true.

%worlds (objvar) (false-implies-capset2perm _ _).
%total {} (false-implies-capset2perm _ _).


%theorem capset2perm-respects-eq
  : forall* {CM1} {PM1} {B1} {M1} {Pi1}
    {CM2} {PM2} {B2} {M2} {Pi2}
    forall  {M1=>Pi1: capset2perm CM1 PM1 B1 M1 Pi1}
    {E: clsmap`eq CM1 CM2} {E: predmap`eq PM1 PM2}
    {E: cxt`eq B1 B2} {E: set`eq M1 M2}
    {E: permission`eq Pi1 Pi2}
    exists  {M2=>Pi2: capset2perm CM2 PM2 B2 M2 Pi2}
    true.

- : capset2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/
    cxt`eq/ set`eq/ permission`eq/ M=>Pi.

%worlds (objvar) (capset2perm-respects-eq _ _ _ _ _ _ _).
%total {} (capset2perm-respects-eq _ _ _ _ _ _ _).


%theorem clsmap-cxt-capset-implies-capset2perm
  : forall* {CM} {PM} {B} {M}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B-M: clsmap-cxt-capset CM B M}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    true.

- : clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM
    clsmap-cxt-capset/0 _ capset2perm/0.

- : clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM
    (clsmap-cxt-capset/U CM-B-M' N+F=>K BL CML FML K!<M' M'+K+X=M)
    _ (capset2perm/U M'=>Pi' N+F=>K BL (create-fldperm/ CML FML T2PF)
        K!<M' M'+K+X=M)
    <- set`update-implies-lookup M'+K+X=M M->K=X
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-B-M' _ M'=>Pi'
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF.

- : clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM
    (clsmap-cxt-capset/z CM-B-M' Z!<M' M'+Z=M)
    _ (capset2perm/z M'=>Pi' Z!<M' M'+Z=M)
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-B-M' _ M'=>Pi'.

%worlds (objvar) (clsmap-cxt-capset-implies-capset2perm _ _ _ _ _).
%total (T) (clsmap-cxt-capset-implies-capset2perm _ _ T _ _).


%theorem capset2perm/U-inversion
  : forall* {M} {MP} {CM} {PM} {K} {Pi} {B}
    forall {M2P: capset2perm CM PM B M Pi}
    {FS: set`not-member MP (s K)}
    {U: set`add MP (s K) M}
    exists {N} {F} {K=>N+F: nat2pair (s K) (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {PF} {CT-PF: create-fldperm CM PM C F PF}
    {Pi2} {M2P: capset2perm CM PM B MP Pi2}
    {EQV: equiv
      (combine (unitperm (conditional (objequal O null) empty (fldperm O F PF))) Pi2) Pi}
    true.

- : capset2perm/U-inversion
    (capset2perm/z M2P F1 U1) F U
    _ _ N2P _ _ _ _ BL _ CT-PF _ (capset2perm/z M2P2 F3 U3)
    (equiv/transitive
      (equiv/roll2)
      (equiv/combine equiv/reflexive (EQV)))
    <- nat`succ-implies-gt-zero _ GT
    <- set`update-commutes-converse U U1 (nat`ne/> GT) M U3 U2
    <- set`update-preserves-not-member-converse F U3 F2
    <- set`update-preserves-not-member-converse F1 U2 F3
    <- capset2perm/U-inversion M2P F2 U2 _ _ N2P _ _ _ _ BL _ CT-PF _ M2P2 EQV.

%theorem capset2perm/U-inversion/L
  : forall* {BP} {M} {B} {CM} {PM} {K} {K1} {PF1}
    {MP1} {MP} {Pi21} {NN1} {A1} {C1} {N1} {F1} {O1}
    forall {FS1: set`not-member MP1 (s K1)}
    {U1: set`add MP1 (s K1) M}
    {K=>N+F: nat2pair (s K1) (pair/ N1 F1)}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {CT-PF: create-fldperm CM PM C1 F1 PF1}
    {M2P: capset2perm CM PM B MP1 Pi21}
    {FS2: set`not-member MP (s K)}
    {U2: set`add MP (s K) M}
    {EQ: nat`eq? (s K) (s K1) BP}
    exists {N} {F} {K=>N+F: nat2pair (s K) (pair/ N F)}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {PF} {CT-PF: create-fldperm CM PM C F PF}
    {Pi2} {M2P: capset2perm CM PM B MP Pi2}
    {EQV: equiv
          (combine (unitperm (conditional (objequal O null) empty (fldperm O F PF))) (Pi2))
          (combine (unitperm (conditional (objequal O1 null) empty (fldperm O1 F1 PF1))) Pi21)}
    true.

- : capset2perm/U-inversion/L F1 U1 N2P1 BL1 CT-PF1 M2P1 F2 U2
    nat`eq?/yes _ _ N2P1 _ _ _ _ BL1 _ CT-PF1 _ M2P equiv/reflexive
    <- set`not-member-update-cancels F1 U1 F2 U2 nat`eq/ set`eq/ X1=X2 M1=M2
    <- capset2perm-respects-eq M2P1 clsmap`eq/ predmap`eq/ cxt`eq/ M1=M2 permission`eq/ M2P.

- : capset2perm/U-inversion/L F1 U1 N2P1 BL1 CT-PF1 M2P1 F2 U2
    (nat`eq?/no K<>K1) _ _ N2P2 _ _ _ _ BL2 _ CT-PF2 _
    (capset2perm/U M2P2 N2P1 BL1 CT-PF1 F4 U4)
    (equiv/transitive equiv/roll2 (equiv/combine equiv/reflexive EQV))
    <- set`update-commutes-converse U2 U1 K<>K1 _ U4 U3
    <- set`update-preserves-not-member-converse F2 U4 F3
    <- set`update-preserves-not-member-converse F1 U3 F4
    <- capset2perm/U-inversion M2P1 F3 U3 _ _ N2P2 _ _ _ _ BL2 _ CT-PF2 _ M2P2 EQV.

- : capset2perm/U-inversion
    (capset2perm/U M2P1 N2P1 BL1 CT-PF1 F1 U1) F2 U2 _ _ N2P _ _ _ _ BL _ CT-PF _ M2P EQV
    <- nat`eq?-total E?
    <- capset2perm/U-inversion/L
      F1 U1 N2P1 BL1 CT-PF1 M2P1 F2 U2 E? _ _ N2P _ _ _ _ BL _ CT-PF _ M2P EQV.

%worlds (objvar)
	(capset2perm/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(capset2perm/U-inversion/L _ _ _ _ _ _ _ _  _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (A B)
	(capset2perm/U-inversion A _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
	(capset2perm/U-inversion/L _ _ _ _ _ B _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem capset2perm/z-inversion
  : forall* {M} {MP} {CM} {PM} {Pi} {B}
    forall {M2P: capset2perm CM PM B M Pi}
    {FS: set`not-member MP shared}
    {U: set`add MP shared M}
    exists {Pi2} {M2P: capset2perm CM PM B MP Pi2}
    {EQV: equiv (combine (unitperm (basic null all null)) Pi2) Pi}
    true.

- : capset2perm/z-inversion
    (capset2perm/U M2P N+F=>K BL CF F1 U1) F U
    _ (capset2perm/U M2P2 N+F=>K BL CF F3 U3)
    (equiv/transitive equiv/roll2 (equiv/combine equiv/reflexive EQV))
    <- nat`succ-implies-gt-zero _ GT
    <- set`update-commutes-converse U U1 (nat`ne/< GT) M U3 U2
    <- set`update-preserves-not-member-converse F U3 F2
    <- set`update-preserves-not-member-converse F1 U2 F3
    <- capset2perm/z-inversion M2P F2 U2 _ M2P2 EQV.

- : capset2perm/z-inversion
    (capset2perm/z M2P F1 U1) F U _ M2P2 equiv/reflexive
    <- set`not-member-update-cancels F1 U1 F U nat`eq/ set`eq/ X1=X M1=M
    <- capset2perm-respects-eq M2P clsmap`eq/ predmap`eq/ cxt`eq/ M1=M permission`eq/ M2P2.

%worlds (objvar) (capset2perm/z-inversion _ _ _ _ _ _).
%total (A) (capset2perm/z-inversion A _ _ _ _ _).


%theorem capset2perm-equiv
  : forall* {CM1} {CM2} {PM1} {PM2} {B1} {B2}
    {M1} {M2} {Pi1} {Pi2}
    forall {M1=>Pi1: capset2perm CM1 PM1 B1 M1 Pi1}
    {M2=>Pi2: capset2perm CM2 PM2 B2 M2 Pi2}
    {E: clsmap`eq CM1 CM2}
    {E: predmap`eq PM1 PM2} {E: cxt`eq B1 B2} {E: set`eq M1 M2}
    exists {EQV: equiv Pi1 Pi2}
    true.

%theorem capset2perm-equiv/L/U
  : forall* {F0} {F1} {PF0:object -> permission} {PF1} {O0} {O1} {NN0} {NN1}
    forall {PFE: {x} permission`eq (PF0 x) (PF1 x)}
    {NNE: nonnull`eq NN0 NN1}
    {FE: nat`eq F0 F1}
    {OE: object`eq O0 O1}
    exists {PE: permission`eq
                (unitperm
                  (conditional
                    (objequal O0 null)
                    (empty)
                    (fldperm O0 F0 PF0)))
                (unitperm
                  (conditional
                    (objequal O1 null)
                    (empty)
                    (fldperm O1 F1 PF1)))}
    true.

- : capset2perm-equiv/L/U ([_] permission`eq/) nonnull`eq/
    nat`eq/ object`eq/ permission`eq/.

- : capset2perm-equiv capset2perm/0 capset2perm/0 _ _ _ _ equiv/reflexive.

- : capset2perm-equiv (capset2perm/z M2P0 F0 U0) M2P CME PME BE ME
    (equiv/transitive (equiv/combine equiv/reflexive EQV2) EQV1)
    <- capset2perm/z-inversion M2P F0 U0 _ M2P1 EQV1
    <- capset2perm-equiv M2P0 M2P1 CME PME BE set`eq/ EQV2.

- : capset2perm-equiv (capset2perm/U M2P0 P2K0 L0 R0 F0 U0) M2P CME PME BE ME
    (equiv/transitive (equiv/combine PXEQV EQV2) (EQV1))
    <- capset2perm/U-inversion M2P F0 U0 _ _ P2K1 _ _ _ _ L1 _ R1 _ M2P1 EQV1
    <- capset2perm-equiv M2P0 M2P1 CME PME BE set`eq/ EQV2
    <- nat2pair-unique P2K0 P2K1 nat`eq/ PE
    <- pair-eq-implies-eq PE (NE:nat`eq Nx0 Nx1) (FE:nat`eq Fx0 Fx1)
    <- cxt`lookup-unique L0 L1 BE NE CIE
    <- cxt-info-eq-inversion CIE (OE:object`eq O0 O1) TE
    <- ty-eq-inversion TE (NNE:nonnull`eq NN0 NN1) _ (CE:nat`eq C0 C1)
    <- create-fldperm-unique R0 R1 CME PME CE FE PFE
    <- capset2perm-equiv/L/U PFE NNE FE OE PFE'
    <- permission`eq-implies-equiv PFE' PXEQV.

%worlds (objvar) (capset2perm-equiv/L/U _ _ _ _ _).
%total { } (capset2perm-equiv/L/U _ _ _ _ _).

%worlds (objvar) (capset2perm-equiv _ _ _ _ _ _ _).
%total (R) (capset2perm-equiv R _ _ _ _ _ _).


%%% TODO: This theorem is not used anywhere, so prove it later if necessary.

%theorem capset2perm-respects-geq
  : forall* {M1} {M2} {CM} {PM} {B} {Pi2}
    forall {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {M1<=M2: set`leq M1 M2}
    exists {Pi1} {Pi3} {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {EQV: (equiv Pi2 (Pi1 , Pi3))}
    true.

%theorem capset2perm-respects-geq/L
  : forall* {M1} {M2} {CM} {PM} {B} {Pi22}
    {M2'} {K} {N} {F} {NN} {A} {C} {Pi21} {T} {PF} {O}
    forall {FS: set`not-member M2' K}
    {UD: set`add M2' K M2}
    {K=>NF: nat2pair K (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {CT: create-fldperm CM PM C T PF}
    {AP: apply-nn NN ([x] fldperm x F PF) Pi21}
    {M2'=>Pi22: capset2perm CM PM B M2' Pi22}
    {M1<=M2: set`leq M1 M2}
    {BP} {DM?: set`member? M1 K BP}
    exists {Pi1} {Pi3} {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {EQV: (equiv ((Pi21 O) , Pi22) (Pi1 , Pi3))}
    true.

% - : capset2perm-respects-geq/L K!<M2' M2'+K+X=M2
%     K2NF BL CT AE AP M2'=>Pi22 M1<=M2 _ (capset`domain?/out K!<M1)
%     _ _ M1=>Pi1
%     (equiv/transitive
%       (equiv/combine equiv/reflexive (Pi22<=>Pi1+Pi3))
%       (equiv/reorder))
%     <- set`not-member-update2-preserves-leq-converse
%       M1<=M2 K!<M1 K!<M2' M2'+K+X=M2 M1<=M2'
%     <- capset2perm-respects-geq
%       M2'=>Pi22 M1<=M2' _ _ M1=>Pi1 Pi22<=>Pi1+Pi3.

% - : capset2perm-respects-geq/L K!<M2' M2'+K+X=M2
%     K2NF BL CT X2Q AP M2'=>Pi22 M1<=M2 _ (capset`domain?/in M1->K=X1)
%     _ _ (capset2perm/U M1'=>Pi11 K2NF BL CT X2Q1 AP K!<M1' M1'+K+X1=M1)
%     (equiv/transitive6
%       (equiv/combine (EQV1) (Pi22<=>Pi11+Pi3))
%       (equiv/symmetric equiv/associate)
%       (equiv/combine equiv/reflexive equiv/reorder)
%       (equiv/associate))
%     <- capset`lookup-implies-fresh-update M1->K=X1 M1' K!<M1' M1'+K+X1=M1
%     <- set`not-member-update-preserves-leq-converse M1<=M2
%       K!<M1' M1'+K+X1=M1 K!<M2' M2'+K+X=M2 M1'<=M2' X1<=X
%     <- capset2perm-respects-geq
%       M2'=>Pi22 M1'<=M2' _ _ M1'=>Pi11 Pi22<=>Pi11+Pi3
%     <- cap2frac-permission-respects-geq X2Q X1<=X _ _ X2Q1 EQV1.

% - : capset2perm-respects-geq
%     capset2perm/0 capset`leq/0 _ _ capset2perm/0
%     (equiv/symmetric equiv/identity).

% - : capset2perm-respects-geq
%     (capset2perm/U T' P BL CML FML T2PF AE F U) M1<=M2 _ _ M1=>Pi1 EQV
%     <- capset`domain?-total DM?
%     <- capset2perm-respects-geq/L F U P BL CML FML T2PF AE
%       T' M1<=M2 _ DM? _ _ M1=>Pi1 EQV.

%worlds (objvar)
	(capset2perm-respects-geq _ _ _ _ _ _)
	(capset2perm-respects-geq/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (A1 A2)
	(capset2perm-respects-geq A1 _ _ _ _ _)
	(capset2perm-respects-geq/L _ _ _ _ _ _ A2 _ _ _ _ _ _ _).


%theorem capset2perm-respects-geq*
  : forall* {M1} {M2} {CM} {PM} {B} {Pi1} {Pi2}
    forall {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {M1<=M2: set`leq M1 M2}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    exists {Pi3} {EQV: (equiv Pi2 (Pi1 , Pi3))}
    true.

- : capset2perm-respects-geq* M2=>Pi2 M1<=M2 M1=>Pi1 _
    (equiv/transitive EQV1 (equiv/combine EQV2 equiv/reflexive))
    <- capset2perm-respects-geq M2=>Pi2 M1<=M2 _ _ M1=>Pi1' EQV1
    <- capset2perm-equiv M1=>Pi1' M1=>Pi1 clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/ EQV2.

%worlds (objvar) (capset2perm-respects-geq* _ _ _ _ _).
%total {} (capset2perm-respects-geq* _ _ _ _ _).


%theorem capset`disjoint-join-implies-equiv
  : forall* {M1} {M2} {M} {O} {FM} {PM} {Pi}
    forall {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {M=>Pi: capset2perm O FM PM M Pi}
    exists {Pi1} {Pi2}
    {M1=>Pi1: capset2perm O FM PM M1 Pi1}
    {M2=>Pi2: capset2perm O FM PM M2 Pi2}
    {EQV: equiv Pi (Pi1 , Pi2)}
    true.

- : capset`disjoint-join-implies-equiv _ set`union/L M2P _ _ capset2perm/0 M2P
    (equiv/transitive (equiv/symmetric equiv/identity) equiv/commute).

- : capset`disjoint-join-implies-equiv _ set`union/R M2P
    _ _ M2P capset2perm/0 (equiv/symmetric equiv/identity).

%theorem capset`disjoint-join-implies-equiv/F
  : forall* {CM} {PM} {B} {M1} {M2} {Pix} {Piy}
    forall {V:void}
    exists {Pi1} {Pi2}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {EQV: (equiv (Pix , Piy) (Pi1 , Pi2))}
    true.

%theorem capset`disjoint-join-implies-equiv/L/z
  : forall* {M1} {M2} {M} {MP} {B} {PM} {Piy} {CM} {B1} {B2}
    forall {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {FS: set`not-member MP shared}
    {U: set`add MP shared M}
    {M=>Pi: capset2perm CM PM B MP Piy}
    {IN1?: set`member? M1 shared B1}
    {IN2?: set`member? M2 shared B2}
    exists {Pi1} {Pi2}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {EQV: equiv (combine (unitperm (basic null all null)) Piy) (Pi1 , Pi2)}
    true.

%theorem capset`disjoint-join-implies-equiv/L/U
  : forall* {M1} {M2} {M} {MP} {F} {PF} {B}
    {O} {PM} {Piy} {K} {N} {NN} {A} {CM} {C} {B1} {B2}
    forall {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {FS: set`not-member MP (s K)}
    {U: set`add MP (s K) M}
    {K=>N+F: nat2pair (s K) (pair/ N F)}
    {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {CT: create-fldperm CM PM C F PF}
    {M=>Pi: capset2perm CM PM B MP Piy}
    {IN1?: set`member? M1 (s K) B1}
    {IN2?: set`member? M2 (s K) B2}
    exists {Pi1} {Pi2}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {EQV: equiv (unitperm
                  (conditional
                    (objequal O null)
                    (empty)
                    (fldperm O F PF)) ,
                  (Piy))
          (Pi1 , Pi2)}
    true.

- : capset`disjoint-join-implies-equiv/L/z DJ J F U M2P
    (set`member?/in L1) (set`member?/in L2) _ _ M2P1 M2P2 EQV
    <- set`disjoint-lookup-contradiction DJ L1 L2 V
    <- capset`disjoint-join-implies-equiv/F V _ _ M2P1 M2P2 EQV.

- : capset`disjoint-join-implies-equiv/L/z DJ J _ U _
    (set`member?/out F1) (set`member?/out F2) _ _ M2P1 M2P2 EQV
    <- set`union-preserves-not-member* F1 F2 J F
    <- set`update-implies-lookup U L
    <- set`not-member-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- capset`disjoint-join-implies-equiv/F V _ _ M2P1 M2P2 EQV.

- : capset`disjoint-join-implies-equiv/L/z DJ (J:set`union M1 M2 M)
    F (U:set`add MP shared M) M2P
    (set`member?/in (L1:set`member M1 shared))
    (set`member?/out F2) _ _
    (capset2perm/z M2P1P F1 U1K) M2P2
    (equiv/transitive (equiv/combine equiv/reflexive EQVP)
      (equiv/associate))
    <- set`member-implies-not-member-add L1 _ F1 U1
    <- set`not-member-update-implies-leq F1 U1 LE1
    <- set`disjoint-respects-geq* DJ LE1 (DJP:set`disjoint M1P M2)
    <- set`not-member-update-implies-unit-union F1 U1 UJ1
    <- set`union-commutative UJ1 UJ1P
    <- set`union-associative UJ1P J M3 (JP:set`union M1P M2 M3) UJ2
    <- set`union-commutative UJ2 UJ2P
    <- set`union-preserves-not-member* F1 F2 JP F3
    <- set`not-member-unit-union-implies-update F3 UJ2P U3
    <- set`not-member-update-cancels F U F3 U3 nat`eq/ set`eq/ DE' ME'
    <- set`eq-symmetric ME' ME
    <- set`union-respects-eq JP set`eq/ set`eq/ ME JP'
    <- capset`disjoint-join-implies-equiv DJP JP' M2P _ _ M2P1P M2P2 EQVP
    <- set`update-respects-eq U1 set`eq/ nat`eq/ unit`eq/ set`eq/ U1K.

- : capset`disjoint-join-implies-equiv/L/z DJ (J:set`union M1 M2 M)
    F (U:set`add MP shared M) M2P
    (set`member?/out F1) (set`member?/in (L2:set`member M2 shared)) _ _
    M2P1 (capset2perm/z M2P2P F2 U2K)
    (equiv/transitive (equiv/combine equiv/reflexive EQVP) equiv/roll2)
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- set`not-member-update-implies-leq F2 U2 (LE2:set`leq M2' M2)
    <- set`disjoint-symmetric DJ DJ'
    <- set`disjoint-respects-geq* DJ' LE2 (DJP:set`disjoint M2' M1)
    <- set`not-member-update-implies-unit-union F2 U2 UJ2
    <- set`union-associative-converse UJ2 J _ (JP:set`union M1 M2' M') UJ2P
    <- set`union-preserves-not-member* F1 F2 JP (F3:set`not-member M' shared)
    <- set`not-member-unit-union-implies-update F3 UJ2P U3
    <- set`not-member-update-cancels F U F3 U3 nat`eq/ set`eq/ DE' ME'
    <- set`eq-symmetric ME' ME
    <- set`union-respects-eq JP set`eq/ set`eq/ ME JP'
    <- set`disjoint-symmetric DJP DJP'
    <- capset`disjoint-join-implies-equiv DJP' JP' M2P _ _ M2P1 M2P2P EQVP
    <- set`update-respects-eq U2 set`eq/ nat`eq/ unit`eq/ set`eq/ U2K.

- : capset`disjoint-join-implies-equiv/L/U DJ J F U N2P BL R M2P
    (set`member?/in L1) (set`member?/in L2) _ _ M2P1 M2P2 EQV
    <- set`disjoint-lookup-contradiction DJ L1 L2 V
    <- capset`disjoint-join-implies-equiv/F V _ _ M2P1 M2P2 EQV.

- : capset`disjoint-join-implies-equiv/L/U DJ J _ U _ _ _ _
    (set`member?/out F1) (set`member?/out F2) _ _ M2P1 M2P2 EQV
    <- set`union-preserves-not-member* F1 F2 J F
    <- set`update-implies-lookup U L
    <- set`not-member-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- capset`disjoint-join-implies-equiv/F V _ _ M2P1 M2P2 EQV.

- : capset`disjoint-join-implies-equiv/L/U DJ (J:set`union M1 M2 M)
    F (U:set`add MP (s K) M) N2P BL R M2P
    (set`member?/in (L1:set`member M1 (s K)))
    (set`member?/out F2) _ _
    (capset2perm/U M2P1P N2P BL R F1 U1K) M2P2
    (equiv/transitive (equiv/combine equiv/reflexive EQVP)
      (equiv/associate))
    <- set`member-implies-not-member-add L1 _ F1 U1
    <- set`not-member-update-implies-leq F1 U1 LE1
    <- set`disjoint-respects-geq* DJ LE1 (DJP:set`disjoint M1P M2)
    <- set`not-member-update-implies-unit-union F1 U1 UJ1
    <- set`union-commutative UJ1 UJ1P
    <- set`union-associative UJ1P J M3 (JP:set`union M1P M2 M3) UJ2
    <- set`union-commutative UJ2 UJ2P
    <- set`union-preserves-not-member* F1 F2 JP F3
    <- set`not-member-unit-union-implies-update F3 UJ2P U3
    <- set`not-member-update-cancels F U F3 U3 nat`eq/ set`eq/ DE' ME'
    <- set`eq-symmetric ME' ME
    <- set`union-respects-eq JP set`eq/ set`eq/ ME JP'
    <- capset`disjoint-join-implies-equiv DJP JP' M2P _ _ M2P1P M2P2 EQVP
    <- set`update-respects-eq U1 set`eq/ nat`eq/ unit`eq/ set`eq/ U1K.

- : capset`disjoint-join-implies-equiv/L/U DJ (J:set`union M1 M2 M)
    F (U:set`add MP (s K) M) N2P BL R M2P
    (set`member?/out F1) (set`member?/in (L2:set`member M2 (s K))) _ _
    M2P1 (capset2perm/U M2P2P N2P BL R F2 U2K)
    (equiv/transitive (equiv/combine equiv/reflexive EQVP) equiv/roll2)
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- set`not-member-update-implies-leq F2 U2 (LE2:set`leq M2' M2)
    <- set`disjoint-symmetric DJ DJ'
    <- set`disjoint-respects-geq* DJ' LE2 (DJP:set`disjoint M2' M1)
    <- set`not-member-update-implies-unit-union F2 U2 UJ2
    <- set`union-associative-converse UJ2 J _ (JP:set`union M1 M2' M') UJ2P
    <- set`union-preserves-not-member* F1 F2 JP (F3:set`not-member M' (s K))
    <- set`not-member-unit-union-implies-update F3 UJ2P U3
    <- set`not-member-update-cancels F U F3 U3 nat`eq/ set`eq/ DE' ME'
    <- set`eq-symmetric ME' ME
    <- set`union-respects-eq JP set`eq/ set`eq/ ME JP'
    <- set`disjoint-symmetric DJP DJP'
    <- capset`disjoint-join-implies-equiv DJP' JP' M2P _ _ M2P1 M2P2P EQVP
    <- set`update-respects-eq U2 set`eq/ nat`eq/ unit`eq/ set`eq/ U2K.

- : capset`disjoint-join-implies-equiv DJ J
    (capset2perm/U M2P N2P BL R F U) _ _ M2P1 M2P2 EQV
    <- set`member?-total D1?
    <- set`member?-total D2?
    <- capset`disjoint-join-implies-equiv/L/U DJ J F U N2P BL R M2P
      D1? D2? _ _ M2P1 M2P2 EQV.

- : capset`disjoint-join-implies-equiv DJ J
    (capset2perm/z M2P F U) _ _ M2P1 M2P2 EQV
    <- set`member?-total D1?
    <- set`member?-total D2?
    <- capset`disjoint-join-implies-equiv/L/z DJ J F U M2P
      D1? D2? _ _ M2P1 M2P2 EQV.

%worlds (objvar) (capset`disjoint-join-implies-equiv/F _ _ _ _ _ _).
%total { } (capset`disjoint-join-implies-equiv/F _ _ _ _ _ _).

%worlds (objvar) (capset`disjoint-join-implies-equiv _ _ _ _ _ _ _ _)
  (capset`disjoint-join-implies-equiv/L/U _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  (capset`disjoint-join-implies-equiv/L/z _ _ _ _ _ _ _ _ _ _ _ _).
%total (T1 T2 T3) (capset`disjoint-join-implies-equiv _ _ T1 _ _ _ _ _)
  (capset`disjoint-join-implies-equiv/L/U _ _ _ _ _ _ _ T2 _ _ _ _ _ _ _)
  (capset`disjoint-join-implies-equiv/L/z _ _ _ _ T3 _ _ _ _ _ _ _).


%theorem capset`disjoint-join-implies-equiv-converse
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2}
    forall {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

%theorem capset`disjoint-join-implies-equiv-converse/L
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2}
    forall {N} {Z: set`size M N}
    {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

- : capset`disjoint-join-implies-equiv-converse/L
    z _ _ set`union/L capset2perm/0 M2P _ M2P
    (equiv/transitive equiv/commute equiv/identity).

- : capset`disjoint-join-implies-equiv-converse/L
    z _ _ set`union/R M2P capset2perm/0 _ M2P equiv/identity.

%theorem capset`disjoint-join-implies-equiv-converse/F
  : forall* {CM} {PM} {B} {M} {Pi1} {Pi2}
    forall {V:void}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

%theorem capset`disjoint-join-implies-equiv-converse/LL
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2} {MP} {K} {B1} {B2}
    forall {N} {Z: set`size M N}
    {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {F: set`not-member MP K}
    {U: set`add MP K M}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {D1?: set`member? M1 K B1}
    {D2?: set`member? M2 K B2}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    {EQV: (equiv (Pi1 , Pi2) Pi)}
    true.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z DJ J
    F U A1 A2 (set`member?/in L1) (set`member?/in L2) _ M2P EQV
    <- set`disjoint-lookup-contradiction DJ L1 L2 V
    <- capset`disjoint-join-implies-equiv-converse/F V _ M2P EQV.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z _ J
    _ U A1 A2 (set`member?/out F1) (set`member?/out F2) _ M2P EQV
    <- set`union-preserves-not-member* F1 F2 J F
    <- set`update-implies-lookup U L
    <- set`not-member-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- capset`disjoint-join-implies-equiv-converse/F V _ M2P EQV.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z DJ
    (J:set`union M1 M2 M) F (U:set`add MP shared M) A1 A2
    (set`member?/in _) (set`member?/out F2)
    _ (capset2perm/z AP F U)
    (equiv/transitive3
      (equiv/combine (equiv/symmetric EQV1) equiv/reflexive)
      (equiv/symmetric equiv/associate)
      (equiv/combine equiv/reflexive EQVP))
    <- set`update-implies-lookup U L
    <- set`not-member-union-right-preserves-lookup-converse L F2 J L1
    <- set`member-implies-not-member-add L1 M1P F1 U1
    <- capset2perm/z-inversion A1 F1 U1 _ A1P EQV1
    <- set`not-member-update-left-preserves-union-converse* F1 U1 F2 J F U J1
    <- set`not-member-update-implies-leq F1 U1 LE1
    <- set`disjoint-respects-geq* DJ LE1 DJP
    <- set`not-member-update-increases-size-converse Z F U Z1
    <- capset`disjoint-join-implies-equiv-converse/L N Z1 DJP J1 A1P A2 _ AP EQVP.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z DJ
    (J:set`union M1 M2 M) F (U:set`add MP (s K) M) A1 A2
    (set`member?/in _) (set`member?/out F2)
    _ (capset2perm/U AP N2P BL R F U)
    (equiv/transitive3
      (equiv/combine (equiv/symmetric EQV1) equiv/reflexive)
      (equiv/symmetric equiv/associate)
      (equiv/combine equiv/reflexive EQVP))
    <- set`update-implies-lookup U L
    <- set`not-member-union-right-preserves-member-converse L F2 J L1
    <- set`member-implies-not-member-add L1 M1P F1 U1
    <- capset2perm/U-inversion A1 F1 U1 _ _ N2P _ _ _ _ BL _ R _ A1P EQV1
    <- set`not-member-update-left-preserves-union-converse* F1 U1 F2 J F U J1
    <- set`not-member-update-implies-leq F1 U1 LE1
    <- set`disjoint-respects-geq* DJ LE1 DJP
    <- set`not-member-update-increases-size-converse Z F U Z1
    <- capset`disjoint-join-implies-equiv-converse/L N Z1 DJP J1 A1P A2 _ AP EQVP.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z DJ
    (J:set`union M1 M2 M) F (U:set`add MP shared M) A1 A2
    (set`member?/out F1) (set`member?/in _)
    _ (capset2perm/z AP F U)
    (equiv/transitive3
      (equiv/combine equiv/reflexive (equiv/symmetric EQV2))
      (equiv/roll2)
      (equiv/combine equiv/reflexive EQVP))
    <- set`update-implies-lookup U L
    <- set`not-member-union-left-preserves-lookup-converse F1 L J L2
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- capset2perm/z-inversion A2 F2 U2 _ A2P EQV2
    <- set`not-member-update-right-preserves-union-converse* F1 F2 U2 J F U J2
    <- set`not-member-update-implies-leq F2 U2 LE2
    <- set`disjoint-symmetric DJ DJ'
    <- set`disjoint-respects-geq* DJ' LE2 DJP'
    <- set`disjoint-symmetric DJP' DJP
    <- set`not-member-update-increases-size-converse Z F U Z1
    <- capset`disjoint-join-implies-equiv-converse/L N Z1 DJP J2 A1 A2P _ AP EQVP.

- : capset`disjoint-join-implies-equiv-converse/LL (s N) Z DJ
    (J:set`union M1 M2 M) F (U:set`add MP (s K) M) A1 A2
    (set`member?/out F1) (set`member?/in _)
    _ (capset2perm/U AP N2P BL R F U)
    (equiv/transitive3
      (equiv/combine equiv/reflexive (equiv/symmetric EQV2))
      (equiv/roll2)
      (equiv/combine equiv/reflexive EQVP))
    <- set`update-implies-lookup U L
    <- set`not-member-union-left-preserves-lookup-converse F1 L J L2
    <- set`member-implies-not-member-add L2 _ F2 U2
    <- capset2perm/U-inversion A2 F2 U2 _ _ N2P _ _ _ _ BL _ R _ A2P EQV2
    <- set`not-member-update-right-preserves-union-converse* F1 F2 U2 J F U J2
    <- set`not-member-update-implies-leq F2 U2 LE2
    <- set`disjoint-symmetric DJ DJ'
    <- set`disjoint-respects-geq* DJ' LE2 DJP'
    <- set`disjoint-symmetric DJP' DJP
    <- set`not-member-update-increases-size-converse Z F U Z1
    <- capset`disjoint-join-implies-equiv-converse/L N Z1 DJP J2 A1 A2P _ AP EQVP.

- : capset`disjoint-join-implies-equiv-converse/L _ Z DJ J M2P1 M2P2 _ M2P EQV
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) _ F U
    <- set`member?-total D1?
    <- set`member?-total D2?
    <- capset`disjoint-join-implies-equiv-converse/LL
      _ Z DJ J F U M2P1 M2P2 D1? D2? _ M2P EQV.

- : capset`disjoint-join-implies-equiv-converse DJ J A1 A2 _ A EQV
    <- set`size-total Z
    <- capset`disjoint-join-implies-equiv-converse/L _ Z DJ J A1 A2 _ A EQV.

%worlds (objvar) (capset`disjoint-join-implies-equiv-converse/F _ _ _ _).
%total { } (capset`disjoint-join-implies-equiv-converse/F _ _ _ _).

%worlds (objvar) (capset`disjoint-join-implies-equiv-converse/L _ _ _ _ _ _ _ _ _)
  (capset`disjoint-join-implies-equiv-converse/LL _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N N1)
  (capset`disjoint-join-implies-equiv-converse/LL N _ _ _ _ _ _ _ _ _ _ _ _)
  (capset`disjoint-join-implies-equiv-converse/L N1 _ _ _ _ _ _ _ _).

%worlds (objvar) (capset`disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).
%total { } (capset`disjoint-join-implies-equiv-converse _ _ _ _ _ _ _).


%theorem capset`disjoint-join-implies-equiv*
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {DJ: set`disjoint M1 M2}
    {J: set`union M1 M2 M}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {M=>Pi: capset2perm CM PM B M Pi}
    exists {EQV: (equiv ((Pi1) , (Pi2)) (Pi))}
    true.

- : capset`disjoint-join-implies-equiv* M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 M=>Pi
    (equiv/transitive (EQV1) (EQV2))
    <- capset`disjoint-join-implies-equiv-converse
    M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 _ M=>Pi' EQV1
    <- capset2perm-equiv M=>Pi' M=>Pi
      clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/ EQV2.

%worlds (objvar) (capset`disjoint-join-implies-equiv* _ _ _ _ _ _).
%total {} (capset`disjoint-join-implies-equiv* _ _ _ _ _ _).


%theorem capset-split-implies-permission-combine
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi}
    forall {R: capset-split M M1 M2}
    {M=>Pi: capset2perm CM PM B M Pi}
    exists {Pi1} {Pi2} {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    {EQV: (equiv Pi (Pi1 , Pi2))}
    true.

- : capset-split-implies-permission-combine
    (capset-split/ M1^M2 M1+M2=M) M=>Pi _ _ M1=>Pi1 M2=>Pi2 (Pi1+Pi2<=>Pi)
    <- capset`disjoint-join-implies-equiv
      M1^M2 M1+M2=M M=>Pi _ _ M1=>Pi1 M2=>Pi2 Pi1+Pi2<=>Pi.

%worlds (objvar) (capset-split-implies-permission-combine _ _ _ _ _ _ _).
%total {} (capset-split-implies-permission-combine _ _ _ _ _ _ _).


%theorem capset-split-implies-permission-combine-converse
  :forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2}
    forall {R: capset-split M M1 M2}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    exists {Pi} {M=>Pi: capset2perm CM PM B M Pi}
    {EQV: equiv (Pi1 , Pi2) Pi}
    true.

- : capset-split-implies-permission-combine-converse (capset-split/ X J) T1 T2 _ T EQV
    <- capset`disjoint-join-implies-equiv-converse X J T1 T2 _ T EQV.

%worlds (objvar) (capset-split-implies-permission-combine-converse _ _ _ _ _ _).
%total {} (capset-split-implies-permission-combine-converse _ _ _ _ _ _).


%theorem capset-split-implies-permission-combine*
  : forall* {M1} {M2} {M} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {R: capset-split M M1 M2}
    {M=>Pi: capset2perm CM PM B M Pi}
    {M1=>Pi1: capset2perm CM PM B M1 Pi1}
    {M2=>Pi2: capset2perm CM PM B M2 Pi2}
    exists {EQV: (equiv Pi (Pi1 , Pi2))}
    true.

- : capset-split-implies-permission-combine* (capset-split/ M1^M2 M1+M2=M)
    M=>Pi M1=>Pi1 M2=>Pi2 (equiv/symmetric (Pi1+Pi2<=>Pi))
    <- capset`disjoint-join-implies-equiv*
      M1^M2 M1+M2=M M1=>Pi1 M2=>Pi2 M=>Pi Pi1+Pi2<=>Pi.

%worlds (objvar) (capset-split-implies-permission-combine* _ _ _ _ _).
%total {} (capset-split-implies-permission-combine* _ _ _ _ _).


%theorem cxt-fresh-update-preserves-capset2perm
  : forall* {CM} {PM} {B} {BP} {N} {M} {CI} {Pi}
    forall {B+M=>Pi: capset2perm CM PM B M Pi}
    {BF: cxt`fresh B N}
    {BU: cxt`update B N CI BP}
    exists {BP+M=>Pi: capset2perm CM PM BP M Pi}
    true.

- : cxt-fresh-update-preserves-capset2perm capset2perm/0 _ _ capset2perm/0.

- : cxt-fresh-update-preserves-capset2perm
    (capset2perm/U B+M'=>Pi2 N+F=>K BL CF FS UD) BF BU
    (capset2perm/U BP+M'=>Pi2 N+F=>K BPL CF FS UD)
    <- cxt-fresh-update-preserves-capset2perm B+M'=>Pi2 BF BU BP+M'=>Pi2
    <- cxt`fresh-update-preserves-lookup BL BF BU BPL.

- : cxt-fresh-update-preserves-capset2perm
    (capset2perm/z B+M'=>Pi2 FS UD) BF BU
    (capset2perm/z BP+M'=>Pi2 FS UD)
    <- cxt-fresh-update-preserves-capset2perm B+M'=>Pi2 BF BU BP+M'=>Pi2.

%worlds (objvar) (cxt-fresh-update-preserves-capset2perm _ _ _ _).
%total (M2P) (cxt-fresh-update-preserves-capset2perm M2P _ _ _).


% %theorem subtype-preserves-capset2perm
%   : forall* {CM} {PM} {B0} {B1} {M0} {M1} {RT} {M} {Pi} {T}
%     forall {B0+M=>Pi: capset2perm CM PM B0 M Pi}
%     {SUB: subtype CM RT (env/ B0 M0) T (env/ B1 M1)}
%     exists {B1+M=>Pi: capset2perm CM PM B1 M Pi}
%     true.

% %theorem sub-annot-cap-preserves-capset2perm
%   : forall* {CM} {PM} {M} {Pi} {B0} {M1} {B1} {M2} {GS} {FS} {A}
%     forall {B0+M=>Pi: capset2perm CM PM B0 M Pi}
%     {SUB: sub-annot-cap GS (env/ B0 M1) FS A (env/ B1 M2)}
%     exists {CM-B2-RT: capset2perm CM PM B1 M Pi}
%     true.

% - : sub-annot-cap-preserves-capset2perm B0+M=>Pi
%     (sub-annot-cap/consume _ _ _ R) B1+M=>Pi
%     <- cxt-remove-unique-preserves-capset2perm B0+M=>Pi R B1+M=>Pi.

% - : sub-annot-cap-preserves-capset2perm B+M=>Pi
%     sub-annot-cap/shared2shared B+M=>Pi.

% %worlds (objvar) (sub-annot-cap-preserves-capset2perm _ _ _).
% %total { } (sub-annot-cap-preserves-capset2perm _ _ _).

% - : subtype-preserves-capset2perm B0+M=>Pi
%     (subtype/ _ _ _ _ SUB-A) B1+M=>Pi
%     <- sub-annot-cap-preserves-capset2perm B0+M=>Pi SUB-A B1+M=>Pi.

% - : subtype-preserves-capset2perm B+M=>Pi subtype/null B+M=>Pi.

% - : subtype-preserves-capset2perm B+M=>Pi subtype/maynull B+M=>Pi.

% %worlds (objvar) (subtype-preserves-capset2perm _ _ _).
% %total { } (subtype-preserves-capset2perm _ _ _).


% %theorem reftyping-preserves-capset2perm
%   : forall* {CM} {MM} {PM} {B0} {B1} {M0} {M1} {E} {RT} {M} {Pi}
%     forall {B0+M=>Pi: capset2perm CM PM B0 M Pi}
%     {RTYP: reftyping CM MM (env/ B0 M0) E (result/expr RT (env/ B1 M1))}
%     exists {B1+M=>Pi: capset2perm CM PM B1 M Pi}
%     true.

% %theorem reftyping-preserves-capset2perm/args
%   : forall* {CM} {MM} {PM} {B0} {B1} {M} {M0} {Pi} {A} {MT} {M1} {RT}
%     forall {B0+M=>Pi: capset2perm CM PM B0 M Pi}
%     {RTYP-A: argsRefTyping CM MM (env/ B0 M0) A MT (result/expr RT (env/ B1 M1))}
%     exists {B1+M=>Pi: capset2perm CM PM B1 M Pi}
%     true.

% %theorem reftyping-preserves-capset2perm/args-helper
%   : forall* {CM} {MM} {PM} {B0} {B1} {M} {M0} {Pi} {A} {MT} {M1} {RT0} {RT1} {T} {N}
%     forall {B0+M=>Pi: capset2perm CM PM B0 M Pi}
%     {RTYP-A: argsRefTyping-helper CM MM
%              (result/expr RT0 (env/ B0 M0)) T N A MT (result/expr RT1 (env/ B1 M1))}
%     exists {B1+M=>Pi: capset2perm CM PM B1 M Pi}
%     true.

% - : reftyping-preserves-capset2perm/args-helper B0+M=>Pi
%     (argsRefTyping-helper/base SUB RTYP-A) B2+M=>Pi
%     <- subtype-preserves-capset2perm B0+M=>Pi SUB B1+M=>Pi
%     <- reftyping-preserves-capset2perm/args B1+M=>Pi RTYP-A B2+M=>Pi.

% - : reftyping-preserves-capset2perm/args B0+M=>Pi
%     (argsRefTyping/+ RTYP-E RTYP-A) B2+M=>Pi
%     <- reftyping-preserves-capset2perm B0+M=>Pi RTYP-E B1+M=>Pi
%     <- reftyping-preserves-capset2perm/args-helper B1+M=>Pi RTYP-A B2+M=>Pi.

% - : reftyping-preserves-capset2perm B+M=>Pi (reftyping/lit _ _) B+M=>Pi.

% - : reftyping-preserves-capset2perm B0+M=>Pi
%     (reftyping/read RTYP-E (readRefTyping/base _ _ _ _ _)) B1+M=>Pi
%     <- reftyping-preserves-capset2perm B0+M=>Pi RTYP-E B1+M=>Pi.

% - : reftyping-preserves-capset2perm B0+M=>Pi
%     (reftyping/write RTYP-E1
%       (writeRefTyping/base _ _ _ RTYP-E2 SUB _)) B3+M=>Pi
%     <- reftyping-preserves-capset2perm B0+M=>Pi RTYP-E1 B1+M=>Pi
%     <- reftyping-preserves-capset2perm B1+M=>Pi RTYP-E2 B2+M=>Pi
%     <- subtype-preserves-capset2perm B2+M=>Pi SUB B3+M=>Pi.

% - : reftyping-preserves-capset2perm B0+M=>Pi
%     (reftyping/call _ MM-L RTYP-A) B1+M=>Pi
%     <- reftyping-preserves-capset2perm/args B0+M=>Pi RTYP-A B1+M=>Pi.

% %worlds (objvar) (reftyping-preserves-capset2perm _ _ _)
%   (reftyping-preserves-capset2perm/args _ _ _)
%   (reftyping-preserves-capset2perm/args-helper _ _ _).
% %total (A A1 A2) (reftyping-preserves-capset2perm _ A _)
%   (reftyping-preserves-capset2perm/args _ A1 _)
%   (reftyping-preserves-capset2perm/args-helper _ A2 _).


%theorem env2input-implies
  : forall* {CM} {PM} {B} {V1} {V2} {Pi1} {Pi2}
    forall {V1=>Pi1: env2input CM PM B V1 Pi1}
    {V2=>Pi2: env2input CM PM B V2 Pi2}
    {V1=V2: env`eq V1 V2}
    exists {IMP: implies Pi1 Pi2} {IMP: implies Pi2 Pi1}
    true.

% - : env2input-implies
%     (env2input/ B1=>PiB1 M1=>PiM1)
%     (env2input/ B2=>PiB2 M2=>PiM2) env`eq/
%     (implies/combine IMP1 (implies/equiv PiM1<=>PiM2))
%     (implies/combine IMP2 (implies/equiv (equiv/symmetric PiM1<=>PiM2)))
%     <- cxt2perm-implies B1=>PiB1 B2=>PiB2 clsmap`eq/ predmap`eq/ cxt`eq/ IMP1 IMP2
%     <- capset2perm-equiv M1=>PiM1 M2=>PiM2 clsmap`eq/ predmap`eq/
%       cxt`eq/ set`eq/ PiM1<=>PiM2.

%worlds (objvar) (env2input-implies _ _ _ _ _).
%trustme %total { } (env2input-implies _ _ _ _ _).


%theorem result2output-respects-eq
  : forall* {CM} {PM} {B} {K} {Rslt: result K} {Rslt': result K} {Out}
    forall {XX2O: result2output CM PM B Rslt Out}
    {EQ: result`eq Rslt Rslt'}
    exists {XX2O: result2output CM PM B Rslt' Out}
    true.

- : result2output-respects-eq XX result`eq/ XX.

%worlds (objvar) (result2output-respects-eq _ _ _).
%total { } (result2output-respects-eq _ _ _).



% TODO: respects-eq for methty2proctype and consty2proctype..

% cxt needs to be consistent with clsmap


%theorem clsmap-cxt-reftype-implies-reftype2perm
  : forall* {CM} {PM} {B} {RT}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-GS: clsmap-cxt-reftype CM B RT}
    exists {PF}
    {RT=>Pi: reftype2perm CM PM B RT PF}
    true.

- : clsmap-cxt-reftype-implies-reftype2perm CM-CM CM2PM
    (clsmap-cxt-reftype/unique CML CM-B-S CM-B-M wf-unique-targets/2)
    _ (reftype2perm/unique (set`size/+ SZ) T2PF ([x] S=>G x) M=>PiM)
    <- set`size-total SZ
    <- ({r} cxt-unique-objset-implies-set2cond CM-B-S _ (S=>G r))
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-B-M _ M=>PiM
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/ CML) _ T2PF.

- : clsmap-cxt-reftype-implies-reftype2perm CM-CM CM2PM
    (clsmap-cxt-reftype/unique CML CM-B-S CM-B-M wf-unique-targets/1)
    _ (reftype2perm/borrow (set`size/+ SZ) set`size/0 T2PF ([x] S=>G x))
    <- set`size-total SZ
    <- ({r} cxt-unique-objset-implies-set2cond CM-B-S _ (S=>G r))
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/ CML) _ T2PF.

- : clsmap-cxt-reftype-implies-reftype2perm CM-CM CM2PM
    (clsmap-cxt-reftype/shared CML)
    _ (reftype2perm/shared T2PF)
    <- clsmap-ty-implies-ty2perm CM2PM (clsmap-ty/ CML) _ T2PF.

%worlds (objvar) (clsmap-cxt-reftype-implies-reftype2perm _ _ _ _ _).
%total { } (clsmap-cxt-reftype-implies-reftype2perm _ _ _ _ _).



%% Theorems about make-encumbered

%theorem false-implies-make-encumbered
  : forall* {CM} {PM} {B} {S} {Pi}
    forall {V:void} exists {MF: make-encumbered CM PM B S Pi}
    true.

%worlds (objvar) (false-implies-make-encumbered _ _).
%total { } (false-implies-make-encumbered _ _).


%theorem make-encumbered-respects-eq
  : forall* {PM1} {PM2} {CM1} {CM2} {B1} {B2} {S1} {S2} {Pi1} {Pi2}
    forall {MFP1: make-encumbered CM1 PM1 B1 S1 Pi1}
    {CME: clsmap`eq CM1 CM2}
    {PME: predmap`eq PM1 PM2}
    {BE: cxt`eq B1 B2} {SE: set`eq S1 S2}
    {PE: permission`eq Pi1 Pi2}
    exists {MFP2: make-encumbered CM2 PM2 B2 S2 Pi2}
    true.

- : make-encumbered-respects-eq MFP clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/
    permission`eq/ MFP.

%worlds (objvar) (make-encumbered-respects-eq _ _ _ _ _ _ _).
%total {} (make-encumbered-respects-eq _ _ _ _ _ _ _).


%theorem make-encumbered/U-inversion
  : forall* {CM} {PM} {B} {S} {Pi} {SP} {N}
    forall {MF: make-encumbered CM PM B S Pi}
    {NM: set`not-member SP N}
    {UD: set`add SP N S}
    exists {Pi1} {MFP: make-encumbered CM PM B SP Pi1}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    {CP} {PML: predmap`lookup PM C CP}
    {FS} {DM: fldmap`domain FM FS}
    {PiP} {MF1: {x} fldmap2perm PM x FM FS (PiP x)}
    {EQV: equiv Pi ((encumbered-fldperm O PiP CP), Pi1)}
    true.

%theorem make-encumbered/U-inversion/L
  : forall* {CM} {PM} {B} {S} {SP} {N} {S1} {Pi1} {N1} {O1} {NN1}
    {A1} {C1} {FM1} {FS1} {PiP1} {P} {CP1}
    forall {MF1: make-encumbered CM PM B S1 Pi1}
    {BL1: cxt`lookup B N1 (cxt-info/ O1 (ty/ NN1 A1 C1))}
    {CML1: clsmap`lookup CM C1 FM1}
    {PML1: predmap`lookup PM C1 CP1}
    {DM1: fldmap`domain FM1 FS1}
    {MF11: {x} fldmap2perm PM x FM1 FS1 (PiP1 x)}
    {NM1: set`not-member S1 N1}
    {U1: set`add S1 N1 S}
    {NM: set`not-member SP N}
    {U: set`add SP N S}
    {E?: nat`eq? N N1 P}
    exists {Pi} {MFP: make-encumbered CM PM B SP Pi}
    {O} {NN} {A} {C} {BL: cxt`lookup B N (cxt-info/ O (ty/ NN A C))}
    {FM} {CML: clsmap`lookup CM C FM}
    {CP} {PML: predmap`lookup PM C CP}
    {FS} {DM: fldmap`domain FM FS}
    {PiP} {MF1: {x} fldmap2perm PM x FM FS (PiP x)}
    {EQV: equiv ((encumbered-fldperm O1 PiP1 CP1) , Pi1)
          ((encumbered-fldperm O PiP CP) , Pi)}
    true.

- : make-encumbered/U-inversion/L MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1 F2 U2
    nat`eq?/yes %{=>}% _ MF _ _ _ _ BL1 _ CML1 _ PML1 _ DM1 _ MFO1 equiv/reflexive
    <- set`not-member-add-cancels F1 U1 F2 U2 nat`eq/ set`eq/ SE
    <- make-encumbered-respects-eq MF1 clsmap`eq/ predmap`eq/ cxt`eq/ SE
      permission`eq/ MF.

- : make-encumbered/U-inversion/L MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1 F2 U2
    (nat`eq?/no N<>N1) %{=>}%
    _ (make-encumbered/U MF2 BL1 CML1 PML1 DM1 MFO1 F4 U4)
    _ _ _ _ BL2 _ CML2 _ PML2 _ DM2 _ MFO2
    (equiv/transitive
      (equiv/combine equiv/reflexive EQV)
      (equiv/roll2))
    <- set`add-commutes-converse U2 U1 N<>N1 _ U4 U3
    <- set`add-preserves-not-member-converse F2 U4 F3
    <- set`add-preserves-not-member-converse F1 U3 F4
    <- make-encumbered/U-inversion MF1 F3 U3 _ MF2 _ _ _ _ BL2 _ CML2 _ PML2 _ DM2
      _ MFO2 EQV.

- : make-encumbered/U-inversion (make-encumbered/U MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1)
    F2 U2 _ MF _ _ _ _ BL _ CML _ PML _ DM _ MFO EQV
    <- nat`eq?-total E?
    <- make-encumbered/U-inversion/L MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1
      F2 U2 E? _ MF _ _ _ _ BL _ CML _ PML _ DM _ MFO EQV.

%worlds (objvar) (make-encumbered/U-inversion _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  (make-encumbered/U-inversion/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N N0) (make-encumbered/U-inversion N _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  (make-encumbered/U-inversion/L N0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem make-encumbered-equiv
  : forall* {CM} {PM} {B} {Q} {Pi} {CM'} {PM'} {B'} {Q'} {Pi'}
    forall {MF: make-encumbered CM PM B Q Pi}
    {MF': make-encumbered CM' PM' B' Q' Pi'}
    {CME: clsmap`eq CM CM'} {PME: predmap`eq PM PM'}
    {BE: cxt`eq B B'} {QE: set`eq Q Q'}
    exists {EQV: permission`equiv Pi Pi'}
    true.

%theorem make-encumbered-equiv/L
  : forall* {PF1} {PF2} {CP1} {CP2}
    forall {O1} {O2}
    {EQ: object`eq O1 O2}
    {EQ: predicate`eq CP1 CP2}
    {EQV: {x} permission`eq (PF1 x) (PF2 x)}
    exists {IMP1: permission`eq (encumbered-fldperm O1 PF1 CP1)
                  (encumbered-fldperm O2 PF2 CP2)}
    true.

- : make-encumbered-equiv/L _ _
    object`eq/ predicate`eq/ ([_] permission`eq/) (permission`eq/).

- : make-encumbered-equiv make-encumbered/0 make-encumbered/0 _ _ _ _ equiv/reflexive.

- : make-encumbered-equiv MF
    (make-encumbered/U MF1 BL1 CML1 PML1 DM1 MFO1 F1 U1) CME PME BE SE
    (equiv/transitive
      (EQV1)
      (equiv/combine EQV2 EQV))
    <- make-encumbered/U-inversion MF F1 U1 _ MF0 _ _ _ _ BL0
      _ CML0 _ PML0 _ DM0 _ MFO0 EQV1
    <- cxt`lookup-unique BL0 BL1 BE nat`eq/ CIE
    <- cxt-info-eq-inversion CIE OE TE
    <- ty-eq-inversion TE NNE AE CE
    <- clsmap`lookup-unique CML0 CML1 CME CE FME
    <- predmap`lookup-unique PML0 PML1 PME CE CPE
    <- fldmap`domain-unique DM0 DM1 FME FSE
    <- ({x} fldmap2perm-unique (MFO0 x) (MFO1 x) PME object`eq/ FME FSE (PEQ x))
    <- make-encumbered-equiv MF0 MF1 CME PME BE set`eq/ EQV
    <- make-encumbered-equiv/L _ _ OE CPE PEQ PEQ'
    <- permission`eq-implies-equiv PEQ' EQV2.

%worlds (objvar) (make-encumbered-equiv/L _ _ _ _ _ _).
%total { } (make-encumbered-equiv/L _ _ _ _ _ _).

%worlds (objvar) (make-encumbered-equiv _ _ _ _ _ _ _).
%total (K) (make-encumbered-equiv _ K _ _ _ _ _).


%theorem clsmap-cxt-objset-implies-make-encumbered
  : forall* {CM} {PM} {B} {U}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-U: clsmap-cxt-objset CM B U}
    exists {Pi} {U=>Pi: make-encumbered CM PM B U Pi}
    true.

- : clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM
    clsmap-cxt-objset/0 _ make-encumbered/0.

- : clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM
    (clsmap-cxt-objset/U CM-B-U' BL CML F U) _
    (make-encumbered/U U'=>Pi' BL CML PML FM-DM FM=>PF F U)
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- fldmap`domain-total FM-DM
    <- set`leq-reflexive _ LE
    <- ({x} fldmap2perm-total CM-CM CM2PM CML FM-DM LE _ (FM=>PF x))
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-B-U' _ U'=>Pi'.

%worlds (objvar) (clsmap-cxt-objset-implies-make-encumbered _ _ _ _ _).
%total (A) (clsmap-cxt-objset-implies-make-encumbered _ _ A _ _).


%theorem cxt-fresh-update-preserves-make-encumbered
  : forall* {CM} {PM} {B0} {B1} {O} {U} {PiU} {N} {CI}
    forall {ME: make-encumbered CM PM B0 U PiU}
    {N!<B0: cxt`fresh B0 N}
    {B0+N=B1: cxt`update B0 N (cxt-info/ O CI) B1}
    exists {ME: make-encumbered CM PM B1 U PiU}
    true.

- : cxt-fresh-update-preserves-make-encumbered
    (make-encumbered/U B0+U'=>PiU' B0-L CML PML FM-DM=FS ([x] FS=>PF x)
      N!<U' U'+N=U)
    N!<B0 B0+N=B1
    (make-encumbered/U B1+U'=>PiU' B1-L CML PML FM-DM=FS ([x] FS=>PF x)
      N!<U' U'+N=U)
    <- cxt`fresh-update-preserves-lookup B0-L N!<B0 B0+N=B1 B1-L
    <- cxt-fresh-update-preserves-make-encumbered B0+U'=>PiU' N!<B0 B0+N=B1 B1+U'=>PiU'.

- : cxt-fresh-update-preserves-make-encumbered make-encumbered/0 _ _ make-encumbered/0.

%worlds (objvar) (cxt-fresh-update-preserves-make-encumbered _ _ _ _).
%total (ME) (cxt-fresh-update-preserves-make-encumbered ME _ _ _).


%%% Theorems about env2input and result2output

%theorem clsmap-cxt-env-implies-env2input
  : forall* {CM} {PM} {B} {V}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-V: clsmap-cxt-env CM B V}
    exists {Pi} {V=>Pi: env2input CM PM B V Pi}
    true.

- : clsmap-cxt-env-implies-env2input CM-CM CM2PM
    (clsmap-cxt-env/ CM-B-U CM-B-M) _
    (env2input/ U=>PiU M=>PiM)
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-B-U _ U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-B-M _ M=>PiM.

%worlds (objvar) (clsmap-cxt-env-implies-env2input _ _ _ _ _).
%total { } (clsmap-cxt-env-implies-env2input _ _ _ _ _).


%theorem clsmap-cxt-capset-implies-result2output
  : forall* {CM} {PM} {B} {V} {RT}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {CM-B-RT: clsmap-cxt-reftype CM B RT}
    {CM-B-V: clsmap-cxt-env CM B V}
    exists {Out}
    {XX=>Out: result2output CM PM B (result/expr RT V) Out}
    true.

- : clsmap-cxt-capset-implies-result2output
    CM-CM CM2PM CM-B CM-B-RT (clsmap-cxt-env/ CM-B-U CM-B-M)
    _ (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM) RT=>Pi)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-B-U _ U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-B-M _ M=>PiM
    <- clsmap-cxt-reftype-implies-reftype2perm CM-CM CM2PM CM-B-RT _ RT=>Pi.

%worlds (objvar) (clsmap-cxt-capset-implies-result2output _ _ _ _ _ _ _).
%total {} (clsmap-cxt-capset-implies-result2output _ _ _ _ _ _ _).


%{
theorems about leq - basically:
if M1 is less or equal than M2, and
M1 ==> Pi1, M2 ==> Pi2.
then exists Pi3, such that Pi2 <==> Pi1 , Pi3
}%

%theorem can-split-permission
  : forall* {Q1} {Pi}
    forall {Q1<1: rat`lst Q1 one}
    exists {Q2} {ADD: rat`add Q1 Q2 one}
    {EQV: equiv Pi ((scale (fraction/ Q1) Pi) , (scale (fraction/ Q2) Pi))}
    true.

- : can-split-permission (Q1<1:rat`lst Q1 one) Q2 Q1+Q2=1
    (equiv/transitive
      (equiv/symmetric equiv/one)
      (equiv/symmetric (equiv/add Q1+Q2=1)))
    <- rat`grt-implies-add Q1<1 Q2 Q2+Q1=1
    <- rat`add-commutative Q2+Q1=1 Q1+Q2=1.

%worlds (objvar) (can-split-permission _ _ _ _).
%total {} (can-split-permission _ _ _ _).


%%% If two types are the same except nn is leq, we can
%%% get implies on the corresponding permissions.

%theorem nn-leq-implies-permission-leq
  : forall* {PM} {C} {PF2} {NN2} {NN1} {A}
    forall {T2PF: ty2perm PM (ty/ NN2 A C) PF2}
    {NN2<=NN1: nonnull`leq NN1 NN2}
    exists {PF1} {T2PF: ty2perm PM (ty/ NN1 A C) PF1}
    {IMP: {x} implies (PF2 x) (PF1 x)}
    true.

- : nn-leq-implies-permission-leq T2PF
    (nonnull`leq/= nonnull`eq/) _ T2PF ([_] implies/reflexive).

- : nn-leq-implies-permission-leq
    (ty2perm/ PML nn2perm/yes A2AF)
    (nonnull`leq/<) _ (ty2perm/ PML nn2perm/may A2AF)
    ([_] implies/cond-intro-neg).

%worlds (objvar) (nn-leq-implies-permission-leq _ _ _ _ _).
%total { } (nn-leq-implies-permission-leq _ _ _ _ _).


%theorem nn-leq-implies-permission-leq*
  : forall* {PM} {C} {PF1} {PF2} {NN2} {NN1} {A}
    forall {T2PF: ty2perm PM (ty/ NN2 A C) PF2}
    {NN2<=NN1: nonnull`leq NN1 NN2}
    {T2PF: ty2perm PM (ty/ NN1 A C) PF1}
    exists {IMP: {x} implies (PF2 x) (PF1 x)}
    true.

- : nn-leq-implies-permission-leq* T2PF2 LE T2PF
    ([x] implies/trans (IMP' x) (implies/equiv (PEQV x)))
    <- nn-leq-implies-permission-leq T2PF2 LE _ T2PF' IMP'
    <- ty2perm-deterministic T2PF' T2PF predmap`eq/ ty`eq/ PEF
    <- ({x} permission`eq-implies-equiv (PEF x) (PEQV x)).

%worlds (objvar) (nn-leq-implies-permission-leq* _ _ _ _).
%total { } (nn-leq-implies-permission-leq* _ _ _ _).


%%% Theorems about declared-capset2perm

%theorem declared-capset2perm-equiv
  : forall* {CM1} {CM2} {PM1} {PM2} {C1} {C2} {FS1} {FS2} {PF1} {PF2}
    forall {DCP: declared-capset2perm CM1 PM1 C1 FS1 PF1}
    {DCP: declared-capset2perm CM2 PM2 C2 FS2 PF2}
    {CME: clsmap`eq CM1 CM2}
    {PME: predmap`eq PM1 PM2}
    {CE: nat`eq C1 C2}
    {FSE: set`eq FS1 FS2}
    exists {PEQV: {x} equiv (PF1 x) (PF2 x)}
    true.

%worlds (objvar) (declared-capset2perm-equiv _ _ _ _ _ _ _).
%trustme %total { } (declared-capset2perm-equiv _ _ _ _ _ _ _).