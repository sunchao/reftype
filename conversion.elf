%%% converting *map to permission


% TODO: this is so similar with ty2perm, maybe we can merge them.

annot2perm2 : annot -> (object -> permission) -> type. 

annot2perm2/unique : annot2perm2 annot/unique ([_] empty).

annot2perm2/borrow : annot2perm2 annot/borrow ([_] empty).

annot2perm2/shared
  : annot2perm2 annot/shared
    ([o] unitperm 
      (nonlinear (nested (allperm o) null all))).


ty2perm2 : predmap -> ty -> (object -> permission) -> type.

ty2perm2/null
  : ty2perm2 _ ty/null ([r] (unitperm (nonlinear (objequal r null)))).

ty2perm2/
  : ty2perm2 PM (ty/ NN A C) ([r] PF CP r)
    <- annot2perm2 A AF
    <- nn2perm NN AF PF
    <- predmap`lookup PM C CP.


% make disjunction of objequal facts for object targets.

set2facts : cxt N -> object -> set -> formula -> type.

set2facts/0 : set2facts _ _ set/0 f.

set2facts/+
  : set2facts B O S (disj (objequal O O') G)
    <- set`add S' L S
    <- cxt-lookup B L O' _
    <- set2facts B O S' G.


% convert a efxmap to two set of permissions (encumbered
% and non-encumbered), based on tgtmap.

efxmap2perm : clsmap -> predmap -> cxt N -> efxmap -> tgtmap
  -> permission -> permission -> type.

efxmap2perm-helper : object -> fldmap -> predmap -> 
  inner-efxmap -> set -> permission -> permission -> type.

efxmap2perm-helper/0
  : efxmap2perm-helper _ _ _ inner-efxmap/0 _ empty empty.

efxmap2perm-helper/+/in
  : efxmap2perm-helper O FM PM M S
    (unitperm (precise-exists O F PF) , Pi1) Pi2
    <- inner-efxmap`update M' F X M
    <- inner-efxmap`fresh M' F
    <- set`member S F
    <- fldmap`lookup FM F T
    <- ty2perm PM T PF
    <- efxmap2perm-helper O FM PM M' S Pi1 Pi2.

efxmap2perm-helper/+/out
  : efxmap2perm-helper O FM PM M S
    Pi1 (unitperm (precise-exists O F PF) , Pi2)
    <- inner-efxmap`update M' F X M
    <- inner-efxmap`fresh M' F
    <- set`not-member S F
    <- fldmap`lookup FM F T
    <- ty2perm PM T PF
    <- efxmap2perm-helper O FM PM M' S Pi1 Pi2.


efxmap2perm/0 : efxmap2perm _ _ _ efxmap/0 _ empty empty.

efxmap2perm/+/in
  : efxmap2perm CM PM B XM GM (Pi3 , Pi1) (Pi4 , Pi2)
    <- efxmap`update XM' L M XM
    <- efxmap`fresh XM' L
    <- tgtmap`lookup GM L S
    <- cxt-lookup B L O (ty/ _ _ C)
    <- clsmap`lookup CM C FM
    <- efxmap2perm-helper O FM PM M S Pi3 Pi4
    <- efxmap2perm CM PM B XM' GM Pi1 Pi2.

efxmap2perm/+/out
  : efxmap2perm CM PM B XM GM Pi1 (Pi4 , Pi2)
    <- efxmap`update XM' L M XM
    <- efxmap`fresh XM' L
    <- tgtmap`fresh GM L
    <- cxt-lookup B L O (ty/ _ _ C)
    <- clsmap`lookup CM C FM
    <- efxmap2perm-helper O FM PM M set/0 _ Pi4
    <- efxmap2perm CM PM B XM' GM Pi1 Pi2.


%{ if tgtmap is empty, we shouldn't generate field
  permissions, since otherwise we may have permission like:

   (allperm o) , (unitperm (encumbered (allperm o) empty))

  which is obviously unsound. }%

tgtmap2perm : tgtmap -> 
  (object -> permission) -> (object -> formula) -> 
  permission -> permission -> expr-output -> type.
  
tgtmap2perm/0
  : tgtmap2perm GM PF GF _ Pi2
    (output/exists [o]
      (output/expr o
        (unitperm (nonlinear (GF o)) , Pi2)))
    <- tgtmap`size GM nat`z.

tgtmap2perm/+
  : tgtmap2perm GM PF GF Pi1 Pi2
    (output/exists [o]
      (output/exists [r]
        (output/expr o
          (unitperm (nonlinear (disj (objequal o r) (GF o))) ,
            ((PF r) , (unitperm (encumbered (PF r) Pi1))) ,
            Pi2))))
    <- tgtmap`size GM (nat`s _).



efxmap2output : clsmap -> predmap -> cxt N -> efxmap 
  -> ty -> tgtmap -> expr-output -> type.

efxmap2output/
  : efxmap2output CM PM B XM T GM0 OUT
    <- tgtmap`split GM0 S GM
    <- efxmap2perm CM PM B XM GM Pi1 Pi2
    <- ({o} set2facts B o S (GF o))
    <- ty2perm PM T ([o] PF o)
    <- tgtmap2perm GM PF GF Pi1 Pi2 OUT.



%%% a well-formed context shouldn't contain null type.

cxt2facts : predmap -> cxt N -> permission -> type.

cxt2facts/nil : cxt2facts PM cxt/nil empty.

cxt2facts/cons
  : cxt2facts PM (cxt/cons O T B) ((PF O) , Pi)
    <- ty2perm2 PM T PF
    <- cxt2facts PM B Pi.
	

%%% methty => proctype

methty2proctype* : clsmap -> predmap -> permission
  -> permission -> methty -> proctype -> type.

methty2proctype/base 
  : methty2proctype* CM PM Pin Pout (methty/base T)
    (proctype/base Pin
      (output/exists [o]
	(output/expr o ((PF o) , Pout))))
    <- ty2perm PM T ([o] PF o).
	      

set2perm : clsmap -> predmap -> fldmap -> set ->
  (object -> permission) -> type.

set2perm/0 : set2perm _ _ _ set/0 ([_] empty).

set2perm/+
  : set2perm CM PM FM S
    ([o] (unitperm (precise-exists o F PF)) , (Pi o))
    <- set`add S' F S
    <- fldmap`lookup FM F T
    <- ty2perm PM T ([o] PF o)
    <- set2perm CM PM FM S' ([o] Pi o).

% here if the argument type is unique, then the read/write sets
% associated with it can only be empty. 
methty2proctype/args 
  : methty2proctype* CM PM Pin Pout (methty/arg MT (ty/ NN A C) R W)
    (proctype/arg ([r] PTF r))
    <- ty2perm PM (ty/ NN A C) ([o] PF o)
    <- clsmap`lookup CM C FM
    <- set2perm CM PM FM R ([o] RPF o)
    <- set2perm CM PM FM W ([o] WPF o)
    <- ({o} methty2proctype* CM PM
         (((PF o) , (RPF o) , (WPF o)) , Pin) 
         (((RPF o) , (WPF o)) , Pout) MT (PTF o)).

%abbrev methty2proctype
   = [CM][PM][MT][PT] methty2proctype* CM PM empty empty MT PT.


consty2proctype*
  : clsmap -> predmap -> fldmap -> permission -> 
  permission -> methty -> (object -> proctype) -> type.

consty2proctype/base
  : consty2proctype* CM PM FM Pin Pout
    (methty/base T)
    ([t] (proctype/base
	   (Pin , 
	     (unitperm (nonlinear (neg (objequal t null)))) , 
	     (OS t))
	   (output/exists [t]
	     (output/expr t ((PF t) , Pout)))))
    <- ty2perm PM T ([o] PF o)
    <- fldmap`domain FM S
    <- ({t} allocFields t S (OS t)).

consty2proctype/args
  : consty2proctype* CM PM FM Pin Pout
    (methty/arg CT (ty/ NN A C) R W)
    ([t] (proctype/arg ([r] PTF t r)))
    <- ty2perm PM (ty/ NN A C) ([r] PF r)
    <- clsmap`lookup CM C FM'
    <- set2perm CM PM FM' R ([o] RPF o)
    <- set2perm CM PM FM' W ([o] WPF o)
    <- ({r} consty2proctype* CM PM FM 
	 (((PF r) , (RPF r) , (WPF r)) , Pin)
	 (((RPF r) , (WPF r)) , Pout) CT ([t] PTF t r)).

%abbrev consty2proctype
   = [CM][PM][FM][CT][PTF] consty2proctype* CM PM FM empty empty CT PTF.


%%% methmap => progtype

methmap2progtype : clsmap -> predmap -> methmap -> progtype -> type.

methmap2progtype/0 : methmap2progtype _ _ methmap/0 progtype`map/0.

methmap2progtype/+/const
  : methmap2progtype CM PM MM W
    <- methmap`update 
      MM' C (methty/arg CT (ty/ nonnull/yes annot/unique C) _ _) MM
    <- methmap`fresh MM' C
    <- clsmap`lookup CM C FM
    <- consty2proctype CM PM FM CT ([t] PTF t)
    <- methmap2progtype CM PM MM' W'
    <- progtype`update W' C (proctype/arg PTF) W.

methmap2progtype/+/meth
  : methmap2progtype CM PM MM W
    <- methmap`update MM' C MT MM
    <- methmap`fresh MM' C
    <- clsmap`fresh CM C
    <- methty2proctype CM PM MT PT
    <- methmap2progtype CM PM MM' W'
    <- progtype`update W' C PT W.


%%% environment => progtype

env2progtype : clsmap -> methmap -> progtype -> type.

env2progtype/
  : env2progtype CM MM W
    <- clsmap2predmap CM PM
    <- methmap2progtype CM PM MM W.