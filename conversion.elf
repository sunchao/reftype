%%% converting *map to permission

% make disjunction of objequal facts for object targets.

set2facts : cxt -> object -> set -> formula -> type.

set2facts/0 : set2facts _ _ set/0 f.

set2facts/+
  : set2facts B O S (disj (objequal O O') G)
    <- set`add S' L S
    <- cxt-lookup-index B L O' _
    <- set2facts B O S' G.


% convert a efxmap to a set of permissions.

efxmap2perm : clsmap -> predmap -> cxt -> efxmap -> permission -> type.

inner-efxmap2perm : object -> fldmap -> predmap ->
    inner-efxmap -> permission -> type.

inner-efxmap2perm/0 : inner-efxmap2perm _ _ _ inner-efxmap/0 empty.

inner-efxmap2perm/+ 
  : inner-efxmap2perm O FM PM
    (inner-efxmap/+ F X M) (unitperm (precise-exists O F PF) , Pi) 
    <- fldmap`lookup FM F T
    <- ty2perm PM T PF
    <- inner-efxmap`shift F M MP
    <- inner-efxmap2perm O FM PM MP Pi.


efxmap2perm/0 : efxmap2perm _ _ _ efxmap/0 empty.

efxmap2perm/+
  : efxmap2perm CM PM B (efxmap/+ L M XM) (Pi1 , Pi2)
    <- cxt-lookup-index B L O (ty/ _ _ C)
    <- clsmap`lookup CM C FM
    <- inner-efxmap2perm O FM PM M Pi1
    <- efxmap`shift L XM XMP
    <- efxmap2perm CM PM B XMP Pi2.


%{ if tgtmap is empty, we shouldn't generate field
  permissions, since otherwise we may have permission like:

   (allperm o) , (unitperm (encumbered (allperm o) empty))

  which is obviously unsound. }%

tgtmap2perm : bool -> (object -> permission) -> 
  (object -> formula) -> permission -> permission -> expr-output -> type.
  
tgtmap2perm/false
  : tgtmap2perm false PF GF _ Pi2
    (output/exists [o]
      (output/expr o
        (unitperm (nonlinear (GF o)) , Pi2))).

tgtmap2perm/+
  : tgtmap2perm true PF GF Pi1 Pi2
    (output/exists [o]
      (output/exists [r]
        (output/expr o
          (unitperm (nonlinear (disj (objequal o r) (GF o))) ,
            ((PF r) , (unitperm (encumbered (PF r) Pi1))) ,
            ((allperm null) , Pi2))))).


%abbrev nested-perm : object -> permission =
    [r] (unitperm (nonlinear (nested (allperm r) null all))).


is-tgtmap-empty : tgtmap -> bool -> type.

is-tgtmap-empty/true : is-tgtmap-empty tgtmap/0 true.

is-tgtmap-empty/false : is-tgtmap-empty (tgtmap/+ _ _ _) false.


%%% This is WRONG: it doesn't handle consume/nested effects.

%%% we need to include (allperm r) when value is unique 

reftype+efxmap2output : clsmap -> predmap -> cxt -> 
    reftype -> efxmap -> expr-output -> type.

reftype+efxmap2output/s_
  : reftype+efxmap2output CM PM B
    (reftype/ (ty/ NN annot/shared C) _) XM
    (output/exists [r] 
      (output/expr r ((PF CP r) , ((allperm null) , Pi))))
    <- nn2perm NN ([r] (nested-perm r)) PF
    <- predmap`lookup PM C CP
    <- efxmap2perm CM PM B XM Pi.

reftype+efxmap2output/us
  : reftype+efxmap2output CM PM B
    (reftype/ (ty/ NN annot/unique C) reftgts/shared) XM
    (output/exists [r]
      (output/expr r
        ((PF CP r) , 
          ((unitperm (encumbered (PF CP r) (allperm null))) , Pi))))
    <- nn2perm NN ([r] (allperm r)) PF
    <- predmap`lookup PM C CP
    <- efxmap2perm CM PM B XM Pi.

reftype+efxmap2output/uu
  : reftype+efxmap2output CM PM B
    (reftype/ (ty/ NN annot/unique C) (reftgts/unique S GM)) XM OUT
    <- nn2perm NN ([r] (allperm r)) PF
    <- predmap`lookup PM C CP
    <- efxmap`remove-tgtmap XM GM XM1 XM2
    <- efxmap2perm CM PM B XM1 Pi1
    <- efxmap2perm CM PM B XM2 Pi2
    <- ({o} set2facts B o S (GF o))
    <- is-tgtmap-empty GM BO
    <- tgtmap2perm BO ([o] PF CP o) GF Pi1 Pi2 OUT.


%%% a well-formed context shouldn't contain null type.

cxt2facts : predmap -> cxt -> permission -> type.

cxt2facts/nil : cxt2facts PM cxt/nil empty.

cxt2facts/cons/shared
  : cxt2facts PM
    (cxt/cons O vtype/shared _ B) ((PF CP O) , Pi)
    <- nn2perm NN ([o] (nested-perm o)) PF
    <- predmap`lookup PM C CP
    <- cxt2facts PM B Pi.

cxt2facts/cons/unique
  : cxt2facts PM
    (cxt/cons O (vtype/unique N) T B) ((one-predcall CP O) , Pi)
    <- predmap`lookup PM C CP
    <- cxt2facts PM B Pi.

	
%{%


%%% methty => proctype

methty2proctype* : clsmap -> predmap -> permission
  -> permission -> methty -> proctype -> type.

methty2proctype/base 
  : methty2proctype* CM PM Pin Pout (methty/base T)
    (proctype/base Pin
      (output/exists [o]
	(output/expr o ((PF o) , Pout))))
    <- ty2perm PM T ([o] PF o).
	      

set2perm : clsmap -> predmap -> fldmap -> set ->
  (object -> permission) -> type.

set2perm/0 : set2perm _ _ _ set/0 ([_] empty).

set2perm/+
  : set2perm CM PM FM S
    ([o] (unitperm (precise-exists o F PF)) , (Pi o))
    <- set`add S' F S
    <- fldmap`lookup FM F T
    <- ty2perm PM T ([o] PF o)
    <- set2perm CM PM FM S' ([o] Pi o).




% here if the argument type is unique, then the read/write sets
% associated with it can only be empty. 
methty2proctype/args 
  : methty2proctype* CM PM Pin Pout (methty/arg MT (ty/ NN A C) R W)
    (proctype/arg ([r] PTF r))
    <- ty2perm PM (ty/ NN A C) ([o] PF o)
    <- clsmap`lookup CM C FM
    <- set2perm CM PM FM R ([o] RPF o)
    <- set2perm CM PM FM W ([o] WPF o)
    <- ({o} methty2proctype* CM PM
         (((PF o) , (RPF o) , (WPF o)) , Pin) 
         (((RPF o) , (WPF o)) , Pout) MT (PTF o)).

%abbrev methty2proctype
   = [CM][PM][MT][PT] methty2proctype* CM PM empty empty MT PT.


consty2proctype*
  : clsmap -> predmap -> fldmap -> permission -> 
  permission -> methty -> (object -> proctype) -> type.

consty2proctype/base
  : consty2proctype* CM PM FM Pin Pout
    (methty/base T)
    ([t] (proctype/base
	   (Pin , 
	     (unitperm (nonlinear (neg (objequal t null)))) , 
	     (OS t))
	   (output/exists [t]
	     (output/expr t ((PF t) , Pout)))))
    <- ty2perm PM T ([o] PF o)
    <- fldmap`domain FM S
    <- ({t} allocFields t S (OS t)).

consty2proctype/args
  : consty2proctype* CM PM FM Pin Pout
    (methty/arg CT (ty/ NN A C) R W)
    ([t] (proctype/arg ([r] PTF t r)))
    <- ty2perm PM (ty/ NN A C) ([r] PF r)
    <- clsmap`lookup CM C FM'
    <- set2perm CM PM FM' R ([o] RPF o)
    <- set2perm CM PM FM' W ([o] WPF o)
    <- ({r} consty2proctype* CM PM FM 
	 (((PF r) , (RPF r) , (WPF r)) , Pin)
	 (((RPF r) , (WPF r)) , Pout) CT ([t] PTF t r)).

%abbrev consty2proctype
   = [CM][PM][FM][CT][PTF] consty2proctype* CM PM FM empty empty CT PTF.


%%% methmap => progtype

methmap2progtype : clsmap -> predmap -> methmap -> progtype -> type.

methmap2progtype/0 : methmap2progtype _ _ methmap/0 progtype`map/0.

methmap2progtype/+/const
  : methmap2progtype CM PM MM W
    <- methmap`update 
      MM' C (methty/arg CT (ty/ nonnull/yes annot/unique C) _ _) MM
    <- methmap`fresh MM' C
    <- clsmap`lookup CM C FM
    <- consty2proctype CM PM FM CT ([t] PTF t)
    <- methmap2progtype CM PM MM' W'
    <- progtype`update W' C (proctype/arg PTF) W.

methmap2progtype/+/meth
  : methmap2progtype CM PM MM W
    <- methmap`update MM' C MT MM
    <- methmap`fresh MM' C
    <- clsmap`fresh CM C
    <- methty2proctype CM PM MT PT
    <- methmap2progtype CM PM MM' W'
    <- progtype`update W' C PT W.


%%% environment => progtype

env2progtype : clsmap -> methmap -> progtype -> type.

env2progtype/
  : env2progtype CM MM W
    <- clsmap2predmap CM PM
    <- methmap2progtype CM PM MM W.

%}%

%%% Theorems

%%% set2facts

%theorem cxt-set-implies-set2facts :
    forall* {B} {O} {S}
    forall  {S-B: cxt-set B S}
    exists  {G} {S2G: set2facts B O S G}
    true.

- : cxt-set-implies-set2facts cxt-set/0 f set2facts/0.

- : cxt-set-implies-set2facts 
    (cxt-set/+ S-B SH B-L) _
    (set2facts/+ S=>G B-L A)
    <- cxt-set-implies-set2facts S-B _ S=>G
    <- set`shift-implies-update SH A.

%worlds () (cxt-set-implies-set2facts _ _ _).
%total (S-B) (cxt-set-implies-set2facts S-B _ _).


% inner-efxmap2perm

%theorem inner-efxmap2perm-respects-eq :
    forall* {O1} {O2} {FM1} {FM2} {PM1} {PM2} {M1} {M2} {Pi1} {Pi2}
    forall  {M1=>Pi1: inner-efxmap2perm O1 FM1 PM1 M1 Pi1}
            {EQ: object`eq O1 O2} {EQ: fldmap`eq FM1 FM2}
            {EQ: predmap`eq PM1 PM2} 
            {EQ: inner-efxmap`eq M1 M2} {EQ: permission`eq Pi1 Pi2}
    exists  {M2=>Pi1: inner-efxmap2perm O2 FM2 PM2 M2 Pi2}
    true.

- : inner-efxmap2perm-respects-eq M=>Pi object`eq/ fldmap`eq/
    predmap`eq/ inner-efxmap`eq/ permission`eq/ M=>Pi.

%worlds () (inner-efxmap2perm-respects-eq _ _ _ _ _ _ _).
%total  {} (inner-efxmap2perm-respects-eq _ _ _ _ _ _ _).


% efxmap2perm 

%theorem efxmap2perm-respects-eq :
    forall* {CM1} {PM1} {B1} {XM1} {Pi1}
            {CM2} {PM2} {B2} {XM2} {Pi2}
    forall  {XM1=>Pi1: efxmap2perm CM1 PM1 B1 XM1 Pi1}
            {EQ: clsmap`eq CM1 CM2} {EQ: predmap`eq PM1 PM2}
            {EQ: cxt`eq B1 B2} {EQ: efxmap`eq XM1 XM2}
            {EQ: permission`eq Pi1 Pi2}
    exists  {XM2=>Pi2: efxmap2perm CM2 PM2 B2 XM2 Pi2} 
    true.

- : efxmap2perm-respects-eq XM=>Pi clsmap`eq/ predmap`eq/
    cxt`eq/ efxmap`eq/ permission`eq/ XM=>Pi.

%worlds () (efxmap2perm-respects-eq _ _ _ _ _ _ _).
%total  {} (efxmap2perm-respects-eq _ _ _ _ _ _ _).


%theorem fldmap-inner-efxmap-implies-inner-efxmap2perm :
    forall* {O} {C} {M} {FM} {PM} {CM}
    forall  {CM-CM: clsmap-clsmap CM CM}
            {CM2PM: clsmap2predmap CM PM}
            {CM-L: clsmap`lookup CM C FM}
            {M-FM: fldmap-inner-efxmap FM M}
    exists  {Pi} {M2P: inner-efxmap2perm O FM PM M Pi}
    true.

- : fldmap-inner-efxmap-implies-inner-efxmap2perm 
    _ _ _ fldmap-inner-efxmap/0 _ inner-efxmap2perm/0.

- : fldmap-inner-efxmap-implies-inner-efxmap2perm
    CM-CM CM2PM CM-L (fldmap-inner-efxmap/+ IEF SH FM-L)
    _ (inner-efxmap2perm/+ MP2PP SH T2P FM-L)
    <- lookup-implies-clsmap-fldmap CM-CM CM-L CM-FM
    <- lookup-implies-clsmap-ty CM-FM FM-L CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2P
    <- fldmap-inner-efxmap-implies-inner-efxmap2perm 
      CM-CM CM2PM CM-L IEF _ MP2PP.
      
%worlds () (fldmap-inner-efxmap-implies-inner-efxmap2perm _ _ _ _ _ _).
%total (M) (fldmap-inner-efxmap-implies-inner-efxmap2perm _ _ _ M _ _).


%theorem efxmap-clsmap-implies-efxmap2perm :
    forall* {XM} {CM} {PM} {B}
    forall  {CM-CM: clsmap-clsmap CM CM}
            {CM2PM: clsmap2predmap CM PM}
            {B-XM: cxt-efxmap B CM XM}
    exists  {Pi} {XM=>Pi: efxmap2perm CM PM B XM Pi}
    true.

- : efxmap-clsmap-implies-efxmap2perm _ _ cxt-efxmap/0 _ efxmap2perm/0.
   
- : efxmap-clsmap-implies-efxmap2perm CM-CM CM2PM
    (cxt-efxmap/+ B-XMP SH FM-M CM-L B-L) _
    (efxmap2perm/+ XMP=>Pi2 SH M=>Pi1 CM-L B-L)
    <- efxmap-clsmap-implies-efxmap2perm CM-CM CM2PM B-XMP _ XMP=>Pi2
    <- fldmap-inner-efxmap-implies-inner-efxmap2perm
      CM-CM CM2PM CM-L FM-M _ M=>Pi1.

%worlds () (efxmap-clsmap-implies-efxmap2perm _ _ _ _ _).
%total (T) (efxmap-clsmap-implies-efxmap2perm _ _ T _ _).