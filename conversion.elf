%%% converting *map to permission


%%% Definitions

%abbrev fracperm = fraction -> permission.


set2facts : cxt -> object -> set -> formula -> type.

set2facts/0 : set2facts _ _ set/0 f.

set2facts/U/in
  : set`not-member SP N
    -> set`add SP N S
    -> cxt`lookup B N (cxtv/ O' _)
    -> set2facts B O SP G
    -> set2facts B O S (disj (objequal O O') G).

set2facts/U/out
  : set`not-member SP N
    -> set`add SP N S
    -> cxt`fresh B N
    -> set2facts B O SP G
    -> set2facts B O S G.



apply-efx : bool -> efx -> permission -> fracperm -> type.

apply-efx/read : apply-efx _ efx/read Pi ([f] (scale f Pi)).

apply-efx/write : apply-efx _ efx/write Pi ([_] Pi).

apply-efx/consume/true : apply-efx true efx/consume Pi ([_] Pi).

apply-efx/consume/false : apply-efx false efx/consume Pi ([_] empty).


%{ efxmap to permission.
The boolean is used to control whether converted
permission is input or output.
Entry 0.0 should be converted to shared permission.
clsmap should contain a special key 0, which maps
to a special fldmap. }%

inner-efxmap2perm : bool -> object -> fldmap -> predmap -> 
  inner-efxmap -> fracperm -> type.

inner-efxmap2perm/0 : inner-efxmap2perm _ _ _ _ inner-efxmap/0 ([_] empty).

inner-efxmap2perm/U/in
  : inner-efxmap`fresh MP F
    -> inner-efxmap`update MP F X M
    -> fldmap`lookup FM F T
    -> ty2perm PM T PF
    -> apply-efx P X (unitperm (precise-exists O F PF)) Pi1
    -> inner-efxmap2perm P O FM PM MP Pi2
    -> inner-efxmap2perm P O FM PM M ([f] (Pi1 f), Pi2 f).

inner-efxmap2perm/U/out
  : inner-efxmap`fresh MP F
    -> inner-efxmap`update MP F X M
    -> fldmap`fresh FM F
    -> inner-efxmap2perm P O FM PM MP Pi
    -> inner-efxmap2perm P O FM PM M ([f] Pi f).


%{ converting a efxmap to fractional permissions
note that here to make this judgment total, we need
to have the context consistent with the clsmap. }%

efxmap2perm : bool -> clsmap -> predmap -> cxt -> efxmap -> fracperm -> type.
 
efxmap2perm/0 : efxmap2perm _ _ _ _ efxmap/0 ([_] empty).

efxmap2perm/U/in
  : efxmap`fresh XMP N
    -> efxmap`update XMP N M XM
    -> cxt`lookup B N (cxtv/ O (ty/ _ _ C))
    -> clsmap`lookup CM C FM
    -> inner-efxmap2perm P O FM PM M Pi1
    -> efxmap2perm P CM PM B XMP Pi2
    -> efxmap2perm P CM PM B XM ([f] (Pi1 f) , Pi2 f).

efxmap2perm/U/out
  : efxmap`fresh XMP N
    -> efxmap`update XMP N M XM
    -> cxt`fresh B N
    -> efxmap2perm P CM PM B XMP Pi
    -> efxmap2perm P CM PM B XM ([f] (Pi f)).

efxmap2perm/U/null
  : efxmap`fresh XMP N
    -> efxmap`update XMP N M XM
    -> cxt`lookup B N (cxtv/ O ty/null)
    -> efxmap2perm P CM PM B XMP Pi
    -> efxmap2perm P CM PM B XM ([f] (Pi f)).


%abbrev nested-perm : object -> permission =
    [r] (unitperm (nonlinear (nested (allperm r) null all))).

maybe-efx2perm : maybe-efx -> fracperm -> type.

maybe-efx2perm/nothing : maybe-efx2perm maybe-efx/nothing ([_] empty).

maybe-efx2perm/just
  : maybe-efx2perm (maybe-efx/just X) PF
    <- apply-efx true X (unitperm (basic null all null)) PF.


effects2input : clsmap -> predmap -> cxt -> effects -> fracperm -> type.

effects2input/
  : efxmap2perm true CM PM B XM ([f] Pi1 f)
    -> maybe-efx2perm MX ([f] Pi2 f)
    -> effects2input CM PM B (effects/ XM MX) ([f] Pi1 f , Pi2 f).


%{
06-16-13: efxmap may contain inner-efxmap/0 as value. Do we need to 
remove them first? Maybe not, since tgtmap in reftype should definitely
be well-formed.
}%

effects2output : clsmap -> predmap -> cxt -> 
    reftype -> effects -> (fraction -> expr-output) -> type.

effects2output/shared
  : efxmap2perm false CM PM B XM ([f] Pi1 f)
    -> maybe-efx2perm MX ([f] Pi2 f)
    -> ty2perm PM (ty/ NN annot/shared C) PF 
    -> effects2output CM PM B 
      (reftype/ NN C targets/shared) (effects/ XM MX)
      ([f] output/exists [r]
        (output/expr r
          (combine (scale f (PF r))
            (combine (Pi1 f) (Pi2 f))))).

effects2output/unique/0f
  : tgtmap`size GM z
    -> efxmap2perm false CM PM B XM ([f] Pi1 f)
    -> ({r} set2facts B r S (GF r))
    -> maybe-efx2perm MX ([f] Pi2 f)
    -> ty2perm PM (ty/ NN annot/borrow C) PF
    -> effects2output CM PM B 
      (reftype/ NN C (targets/unique S GM false)) (effects/ XM MX)
      ([f] output/exists [r] 
        (output/expr r
          (combine (scale f (PF r))
            (combine (unitperm (nonlinear (GF r)))
              (combine (Pi1 f) (Pi2 f)))))).
        
effects2output/unique/0t
  : tgtmap`size GM z
    -> efxmap2perm false CM PM B XM ([f] Pi1 f)
    -> ({r} set2facts B r S (GF r))
    -> maybe-efx2perm MX ([f] Pi2 f)
    -> ty2perm PM (ty/ NN annot/unique C) PF
    -> effects2output CM PM B 
      (reftype/ NN C (targets/unique S GM true)) (effects/ XM MX)
      ([f] output/exists [r] 
        (output/expr r
          (combine (Pi1 f)
            (combine (scale f (PF r))
              (unitperm
                (encumbered
                  (scale f (PF r)) (Pi2 f))))))).

effects2output/unique/+f
  : tgtmap`size GM (s _)
    -> efxmap`remove-tgtmap XM GM XM1 XM2
    -> efxmap2perm false CM PM B XM1 ([f] Pi1 f)
    -> efxmap2perm false CM PM B XM2 ([f] Pi2 f)
    -> ({r} set2facts B r S (GF r))
    -> maybe-efx2perm MX ([f] Pi3 f)
    -> ty2perm PM (ty/ NN annot/unique C) PF
    -> effects2output CM PM B
      (reftype/ NN C (targets/unique S GM false)) (effects/ XM MX)
      ([f] output/exists [o]
        (output/exists [r]
          (output/expr o 
            (combine (unitperm (nonlinear (disj (objequal o r) (GF o))))
              (combine (scale f (PF r))
                (combine (unitperm (encumbered (scale f (PF r)) (Pi2 f)))
                  (combine (Pi1 f) (Pi3 f)))))))).

effects2output/unique/+t
  : tgtmap`size GM (s _)
    -> efxmap`remove-tgtmap XM GM XM1 XM2
    -> efxmap2perm false CM PM B XM1 ([f] Pi1 f)
    -> efxmap2perm false CM PM B XM2 ([f] Pi2 f)
    -> ({r} set2facts B r S (GF r))
    -> maybe-efx2perm MX ([f] Pi3 f)
    -> ty2perm PM (ty/ NN annot/unique C) PF
    -> predmap`lookup PM C CP
    -> effects2output CM PM B
      (reftype/ NN C (targets/unique S GM true)) (effects/ XM MX)
      ([f] output/exists [o]
        (output/exists [r]
          (output/expr o 
            (combine (unitperm (nonlinear (disj (objequal o r) (GF o))))
              (combine (scale f (PF r))
                (combine
                  (unitperm
                    (encumbered
                      (scale f (PF r)) (combine (Pi2 f) (Pi3 f))))
                  (Pi1 f))))))).


%{ Context => Permission
Here for unique references, we need to generate encumbered permission
for all fields of its class. This is because we carve the field permissions
out of *all* permission before we check method body, and use each 
field permission individually. But, in case we want to consume a unique
parameter, we need to get back the all permission, with the encumbered
permission. }%

fldmap2perm : predmap -> fldmap -> object -> permission -> type.

fldmap2perm/0 : fldmap2perm _ fldmap/0 _ empty.

fldmap2perm/U
  : fldmap2perm PM FMP O Pi
    -> fldmap`fresh FMP F
    -> fldmap`update FMP F T FM
    -> ty2perm PM T PF
    -> fldmap2perm PM FM O (unitperm (precise-exists O F PF) , Pi).


cxt2perm : clsmap -> predmap -> cxt -> permission -> type.

cxt2perm/0 : cxt2perm _ _ cxt/nil empty.

cxt2perm/U/unique
  : cxt2perm CM PM BP Pi
    -> cxt`fresh BP N 
    -> cxt`update BP N (cxtv/ O (ty/ NN annot/unique C)) B
    -> clsmap`lookup CM C FM
    -> ({o} fldmap2perm PM FM o (AF o))
    -> nn2perm NN AF PF
    -> predmap`lookup PM C CP 
    -> cxt2perm CM PM B ((PF CP O) , Pi).

cxt2perm/U/shared
  : cxt2perm CM PM BP Pi
    -> cxt`fresh BP N 
    -> cxt`update BP N (cxtv/ O (ty/ NN annot/shared C)) B
    -> ty2perm PM (ty/ NN annot/shared C) PF
    -> cxt2perm CM PM B ((PF O) , Pi).

cxt2perm/U/borrow
  : cxt2perm CM PM BP Pi
    -> cxt`fresh BP N 
    -> cxt`update BP N (cxtv/ O (ty/ NN annot/borrow C)) B
    -> ty2perm PM (ty/ NN annot/borrow C) PF
    -> cxt2perm CM PM B ((PF O) , Pi).

cxt2perm/U/null
  : cxt2perm CM PM BP Pi
    -> cxt`fresh BP N
    -> cxt`update BP N (cxtv/ O ty/null) B
    -> cxt2perm CM PM B (unitperm (nonlinear (objequal O null)) , Pi).


% TODO

methty2proctype* : clsmap -> predmap -> permission
  -> permission -> methty -> proctype -> type.

% TODO

%abbrev methty2proctype
  = [CM][PM][MT][PT] methty2proctype* CM PM empty empty MT PT.

consty2proctype*
  : clsmap -> predmap -> fldmap -> permission -> 
  permission -> methty -> (object -> proctype) -> type.

% TODO

%abbrev consty2proctype
   = [CM][PM][FM][CT][PTF] consty2proctype* CM PM FM empty empty CT PTF.


methmap2progtype : clsmap -> predmap -> methmap -> progtype -> type.

env2progtype : clsmap -> methmap -> progtype -> type.

env2progtype/
  : env2progtype CM MM W
    <- clsmap2predmap CM PM
    <- methmap2progtype CM PM MM W.


%%% Theorems

% =========================================
% First, extra permission-related theorems
% =========================================


%theorem permission`eq-implies-equiv
  : forall* {Pi1} {Pi2}
    forall {EQ: permission`eq Pi1 Pi2}
    exists {EQV: equiv Pi1 Pi2}
    true.

- : permission`eq-implies-equiv permission`eq/ equiv/reflexive.

%worlds (objvar | fracvar) (permission`eq-implies-equiv _ _).
%total {} (permission`eq-implies-equiv _ _).


%theorem permission`combine-preserves-eq
  : forall* {Pi1} {Pi2} {Pi3} {Pi4}
    forall {EQ: permission`eq Pi1 Pi3}
    {EQ: permission`eq Pi2 Pi4}
    exists {EQ: permission`eq (Pi1 , Pi2) (Pi3 , Pi4)}
    true.

- : permission`combine-preserves-eq 
    permission`eq/ permission`eq/ permission`eq/.

%worlds (objvar) (permission`combine-preserves-eq _ _ _).
%total {} (permission`combine-preserves-eq _ _ _).


%theorem permission`implies-respects-eq-left
  : forall* {P1} {P2} {P}
    forall {EQ: permission`eq P1 P2}
    {IMP: implies P1 P}
    exists {IMP: implies P2 P}
    true.

- : permission`implies-respects-eq-left permission`eq/ IMP IMP.

%worlds () (permission`implies-respects-eq-left _ _ _).
%total {} (permission`implies-respects-eq-left _ _ _).


%theorem permission`implies-respects-eq-right
  : forall* {P1} {P2} {P}
    forall {EQ: permission`eq P1 P2}
    {IMP: implies P P1}
    exists {IMP: implies P P2}
    true.

- : permission`implies-respects-eq-right permission`eq/ IMP IMP.

%worlds () (permission`implies-respects-eq-right _ _ _).
%total {} (permission`implies-respects-eq-right _ _ _).



% ================
% false-implies-XX
% ================

%theorem false-implies-set2facts
  : forall* {B} {O} {S} {G}
    forall {V:void} 
    exists {S=>G: set2facts B O S G}
    true.

%worlds () (false-implies-set2facts _ _).
%total {} (false-implies-set2facts _ _). 


%theorem false-implies-apply-efx
  : forall* {B} {X} {Pi} {Pi2}
    forall {V:void} 
    exists {AP: apply-efx B X Pi Pi2}
    true.

%worlds () (false-implies-apply-efx _ _).
%total {} (false-implies-apply-efx _ _).

%theorem false-implies-inner-efxmap2perm
  : forall* {P} {O} {FM} {PM} {M} {Pi}
    forall {V:void}
    exists {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
    true.

%worlds (fracvar) (false-implies-inner-efxmap2perm _ _).
%total {} (false-implies-inner-efxmap2perm _ _).


%theorem false-implies-efxmap2perm
  : forall* {CM} {PM} {B} {XM} {P} {Pi}
    forall  {V: void}
    exists  {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    true.

%worlds (fracvar) (false-implies-efxmap2perm _ _).
%total  {} (false-implies-efxmap2perm _ _).


% ================================
% totality (constructive) theorems
% ================================

%theorem set2facts-total/L
  : forall* {B} {O} {S}
    forall {N} {SZ: set`size S N} 
    exists {G} {S=>G: set2facts B O S G}
    true.

- : set2facts-total/L z set`size/0 _ set2facts/0.

%theorem set2facts-total*/U
  : forall* {S} {SP} {B} {N} {P} {O} {GP}
    forall {IN?: cxt`domain? B N P}
    {NM: set`not-member SP N}
    {A: set`add SP N S}
    {SP=>GP: set2facts B O SP GP}
    exists {G} {S=>G: set2facts B O S G}
    true.
    
- : set2facts-total*/U (cxt`domain?/in B->N) F A T _
    (set2facts/U/in F A B->N T).

- : set2facts-total*/U (cxt`domain?/out FS) F A T _
    (set2facts/U/out F A FS T).

%worlds () (set2facts-total*/U _ _ _ _ _ _).
%total {} (set2facts-total*/U _ _ _ _ _ _).

- : set2facts-total/L (s N) SZ _ S=>G
    <- cxt`domain?-total IN?
    <- set`member-implies-not-member-add (set`lookup/= nat`eq/) SP N!<SP SP+N=S
    <- set`not-member-update-increases-size-converse SZ N!<SP SP+N=S SZP
    <- set2facts-total/L N SZP _ SP=>GP
    <- set2facts-total*/U IN? N!<SP SP+N=S SP=>GP _ S=>G.

%worlds () (set2facts-total/L _ _ _ _).
%total (N) (set2facts-total/L N _ _ _). 
    

%theorem set2facts-total*
  : forall* {B} {O}
    forall {S:set}
    exists {G:formula} {S=>G: set2facts B O S G}
    true.

- : set2facts-total* S G S=>G
    <- set`size-total SZ
    <- set2facts-total/L _ SZ G S=>G.

%worlds () (set2facts-total* _ _ _).
%total {} (set2facts-total* _ _ _).

%abbrev set2facts-total = set2facts-total* _ _.


%theorem apply-efx-total*
  : forall {P} {X} {Pi}
    exists {PF} {AP: apply-efx P X Pi PF}
    true.

- : apply-efx-total* _ efx/read _ _ apply-efx/read.

- : apply-efx-total* _ efx/write _ _ apply-efx/write.

- : apply-efx-total* true efx/consume Pi ([_] Pi) apply-efx/consume/true.

- : apply-efx-total* false efx/consume Pi ([_] empty) apply-efx/consume/false.

%worlds (fracvar) (apply-efx-total* _ _ _ _ _).
%total {} (apply-efx-total* _ _ _ _ _).

%abbrev apply-efx-total = apply-efx-total* _ _ _ _.


%theorem maybe-efx2perm-total*
  : forall {MX} 
    exists {Pi} {MX=>Pi: maybe-efx2perm MX Pi}
    true.

- : maybe-efx2perm-total* maybe-efx/nothing _ maybe-efx2perm/nothing.

- : maybe-efx2perm-total* (maybe-efx/just _) _ (maybe-efx2perm/just AP)
    <- apply-efx-total AP.

%worlds () (maybe-efx2perm-total* _ _ _).
%total {} (maybe-efx2perm-total* _ _ _).

%abbrev maybe-efx2perm-total = maybe-efx2perm-total* _ _. 

 
%{ fldmap2perm is NOT total - the field map has to be
consistent with the clsmap. }%

%theorem clsmap-fldmap-implies-fldmap2perm
  : forall* {CM} {PM} {FM} {O}
    forall {CM2PM: clsmap2predmap CM PM}
    {CM-FM: clsmap-fldmap CM FM}
    exists {Pi:permission} {FM=>Pi: fldmap2perm PM FM O Pi}
    true.

%theorem clsmap-fldmap-implies-fldmap2perm/L
  : forall* {CM} {PM} {FM} {O}
    forall {N} {SZ: fldmap`size FM N}
    {CM2PM: clsmap2predmap CM PM}
    {CM-FM: clsmap-fldmap CM FM}
    exists {Pi:permission} {FM=>Pi: fldmap2perm PM FM O Pi}
    true.

- : clsmap-fldmap-implies-fldmap2perm/L 
    _ fldmap`size/0 _ clsmap-fldmap/0 _ fldmap2perm/0.

- : clsmap-fldmap-implies-fldmap2perm/L _ (fldmap`size/+ SZ)
    CM2PM (clsmap-fldmap/+ CM-FMP CM-T) _ (fldmap2perm/U FMS=>PS F U T2PF)
    <- fldmap`shift-total SH-FMP=FMS
    <- fldmap`shift-preserves-size SZ SH-FMP=FMS SZS
    <- shift-preserves-clsmap-fldmap CM-FMP SH-FMP=FMS CM-FMS
    <- fldmap`shift-implies-fresh SH-FMP=FMS F
    <- fldmap`shift-implies-update SH-FMP=FMS U
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- clsmap-fldmap-implies-fldmap2perm/L _ SZS CM2PM CM-FMS _ FMS=>PS.

- : clsmap-fldmap-implies-fldmap2perm CM2PM CM-FM P FM2P
    <- fldmap`size-total SZ
    <- clsmap-fldmap-implies-fldmap2perm/L _ SZ CM2PM CM-FM P FM2P.

%worlds (objvar) (clsmap-fldmap-implies-fldmap2perm/L _ _ _ _ _ _).
%total (N) (clsmap-fldmap-implies-fldmap2perm/L N _ _ _ _ _).

%worlds (objvar) (clsmap-fldmap-implies-fldmap2perm _ _ _ _).
%total {} (clsmap-fldmap-implies-fldmap2perm _ _ _ _).


%theorem clsmap-cxt-implies-cxt2perm
  : forall* {CM} {PM} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    exists {Pi:permission} {B=>Pi: cxt2perm CM PM B Pi}
    true.

- : clsmap-cxt-implies-cxt2perm _ _ clsmap-cxt/nil _ cxt2perm/0.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/cons F (U:cxt`update _ _ (cxtv/ _ (ty/ _ annot/unique _)) _) 
      (clsmap-ty/notnull (clsmap`domain?/in CM-L)) CM-BP) _
    (cxt2perm/U/unique BP2PP F U CM-L FM2P NN2P PM-L)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-BP _ BP2PP
    <- lookup-implies-clsmap-fldmap CM-CM CM-L CM-FM
    <- ({o} clsmap-fldmap-implies-fldmap2perm CM2PM CM-FM _ (FM2P o))
    <- nn2perm-total NN2P
    <- clsmap2predmap-implies-predmap-lookup CM2PM CM-L _ PM-L.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/cons F (U:cxt`update _ _ (cxtv/ _ (ty/ _ annot/shared _)) _) 
      CM-T CM-BP) _ (cxt2perm/U/shared BP2PP F U T2PF)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-BP _ BP2PP
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/cons F (U:cxt`update _ _ (cxtv/ _ (ty/ _ annot/borrow _)) _) 
      CM-T CM-BP) _ (cxt2perm/U/borrow BP2PP F U T2PF)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-BP _ BP2PP
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF.

- : clsmap-cxt-implies-cxt2perm CM-CM CM2PM
    (clsmap-cxt/cons F (U:cxt`update _ _ (cxtv/ _ ty/null) _)
      _ CM-BP) _ (cxt2perm/U/null BP2PP F U)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-BP _ BP2PP.

%worlds (objvar) (clsmap-cxt-implies-cxt2perm _ _ _ _ _).
%total (CM-B) (clsmap-cxt-implies-cxt2perm _ _ CM-B _ _).


%theorem clsmap-fldmap-implies-inner-efxmap2perm
  : forall* {CM} {PM} {FM} {P} {O} {M} 
    forall {CM2PM: clsmap2predmap CM PM}
    {CM-FM: clsmap-fldmap CM FM}
    exists {FP:fracperm} {M=>FP: inner-efxmap2perm P O FM PM M FP}
    true.

%theorem clsmap-fldmap-implies-inner-efxmap2perm/L
  : forall* {P} {O} {M} {CM} {PM} {FM}
    forall {N} {SZ: inner-efxmap`size M N}
    {CM2PM: clsmap2predmap CM PM}
    {CM-FM: clsmap-fldmap CM FM}
    exists {FP:fracperm} {M=>Pi: inner-efxmap2perm P O FM PM M FP}
    true.

- : clsmap-fldmap-implies-inner-efxmap2perm/L
    _ inner-efxmap`size/0 _ _ _ inner-efxmap2perm/0.

%theorem clsmap-fldmap-implies-inner-efxmap2perm/U
  : forall* {FM} {CM} {PM} {M} {MP} {F} {B} {X} {P} {O} {Pi2}
    forall {IN?: fldmap`domain? FM F B}
    {CM2PM: clsmap2predmap CM PM}
    {CM-FM: clsmap-fldmap CM FM}
    {FS: inner-efxmap`fresh MP F}
    {U: inner-efxmap`update MP F X M}
    {MP=>Pi2: inner-efxmap2perm P O FM PM MP Pi2}
    exists {Pi} {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
    true.

- : clsmap-fldmap-implies-inner-efxmap2perm/U (fldmap`domain?/in FM-L)
    CM2PM CM-FM FS U TP _ (inner-efxmap2perm/U/in FS U FM-L T2PF AP TP)
    <- lookup-implies-clsmap-ty CM-FM FM-L CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- apply-efx-total AP.

- : clsmap-fldmap-implies-inner-efxmap2perm/U (fldmap`domain?/out FM-F)
    CM2PM CM-FM FS U TP _ (inner-efxmap2perm/U/out FS U FM-F TP).

- : clsmap-fldmap-implies-inner-efxmap2perm/L (s N) SZ CM2PM CM-FM _ M=>FP
    <- fldmap`domain?-total DM?
    <- inner-efxmap`lookup-implies-fresh-update
      (inner-efxmap`lookup/= nat`eq/) _ FS U
    <- inner-efxmap`fresh-update-increases-size-converse SZ FS U SZP
    <- clsmap-fldmap-implies-inner-efxmap2perm/L N SZP CM2PM CM-FM _ MP=>Pi2
    <- clsmap-fldmap-implies-inner-efxmap2perm/U DM? CM2PM CM-FM FS U MP=>Pi2 _ M=>FP.


- : clsmap-fldmap-implies-inner-efxmap2perm CM2PM CM-FM _ M=>FP
    <- inner-efxmap`size-total SZ
    <- clsmap-fldmap-implies-inner-efxmap2perm/L _ SZ CM2PM CM-FM _ M=>FP.

%worlds (fracvar) (clsmap-fldmap-implies-inner-efxmap2perm/U _ _ _ _ _ _ _ _).
%total {} (clsmap-fldmap-implies-inner-efxmap2perm/U _ _ _ _ _ _ _ _). 

%worlds (fracvar) (clsmap-fldmap-implies-inner-efxmap2perm/L _ _ _ _ _ _).
%total (N) (clsmap-fldmap-implies-inner-efxmap2perm/L N _ _ _ _ _).

%worlds (fracvar) (clsmap-fldmap-implies-inner-efxmap2perm _ _ _ _).
%total {} (clsmap-fldmap-implies-inner-efxmap2perm _ _ _ _). 


%% efxmap2perm is NOT total - needs to have cxt-efxmap


%theorem clsmap-cxt-implies-efxmap2perm
  : forall* {P} {B} {CM} {PM} {XM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    exists {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    true.

%theorem clsmap-cxt-implies-efxmap2perm/L
  : forall* {P} {XM} {CM} {PM} {B}
    forall {N} {SZ: efxmap`size XM N}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    exists {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    true.

- : clsmap-cxt-implies-efxmap2perm/L z efxmap`size/0 _ _ _ _ efxmap2perm/0.

%theorem clsmap-cxt-implies-efxmap2perm/U
  : forall* {B} {N} {P} {XM} {BP} {CM} {PM} {XMP} {M} {Pi2}
    forall {IN?: cxt`domain? B N BP}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {FS: efxmap`fresh XMP N}
    {UD: efxmap`update XMP N M XM}
    {XMP=>Pi2: efxmap2perm P CM PM B XMP Pi2}
    exists {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    true.

- : clsmap-cxt-implies-efxmap2perm/U
    (cxt`domain?/in (B->N:cxt`lookup B N (cxtv/ O (ty/ NN A C))))
    CM-CM CM2PM CM-B FS U TP _
    (efxmap2perm/U/in FS U B->N CM->C M=>Pi1 TP)
    <- clsmap-cxt-lookup CM-B B->N (clsmap-ty/notnull (clsmap`domain?/in CM->C))
    <- lookup-implies-clsmap-fldmap CM-CM CM->C CM-FM
    <- clsmap-fldmap-implies-inner-efxmap2perm CM2PM CM-FM _ M=>Pi1.

- : clsmap-cxt-implies-efxmap2perm/U
    (cxt`domain?/in (B->N:cxt`lookup B N (cxtv/ O ty/null)))
    CM-CM CM2PM CM-B FS U TP _ (efxmap2perm/U/null FS U B->N TP).
    
- : clsmap-cxt-implies-efxmap2perm/U
    (cxt`domain?/out N!<B) CM-CM CM2PM CM-B FS U TP _
    (efxmap2perm/U/out FS U N!<B TP).

- : clsmap-cxt-implies-efxmap2perm/L (s N) SZ CM-CM CM2PM CM-B _ T
    <- cxt`domain?-total IN?
    <- efxmap`lookup-implies-fresh-update (efxmap`lookup/= nat`eq/) XMP FS U
    <- efxmap`fresh-update-increases-size-converse SZ FS U SZP
    <- clsmap-cxt-implies-efxmap2perm/L N SZP CM-CM CM2PM CM-B _ TP
    <- clsmap-cxt-implies-efxmap2perm/U IN? CM-CM CM2PM CM-B FS U TP _ T.


- : clsmap-cxt-implies-efxmap2perm CM-CM CM2PM CM-B _ XM=>Pi
    <- efxmap`size-total SZ
    <- clsmap-cxt-implies-efxmap2perm/L _ SZ CM-CM CM2PM CM-B _ XM=>Pi.

%worlds (fracvar) (clsmap-cxt-implies-efxmap2perm/U _ _ _ _ _ _ _ _ _).
%total {} (clsmap-cxt-implies-efxmap2perm/U _ _ _ _ _ _ _ _ _).

%worlds (fracvar) (clsmap-cxt-implies-efxmap2perm/L _ _ _ _ _ _ _).
%total (N) (clsmap-cxt-implies-efxmap2perm/L N _ _ _ _  _ _).

%worlds () (clsmap-cxt-implies-efxmap2perm _ _ _ _ _).
%total {} (clsmap-cxt-implies-efxmap2perm _ _ _ _ _).
 


% ===================
% uniqueness theorems
% ===================

%% set2facts is NOT unique, but results are "equivalent"

%theorem set2facts-equiv
  : forall* {B1} {B2} {O1} {O2} {S1} {S2} {G1} {G2}
    forall {S1=>G1: set2facts B1 O1 S1 G1}
    {S2=>G2: set2facts B2 O2 S2 G2}
    {E: cxt`eq B1 B2}
    {E: object`eq O1 O2}
    {E: set`eq S1 S2}
    exists {EQV: equiv (unitperm (nonlinear G1)) (unitperm (nonlinear G2))}
    true.

%worlds (objvar | fracvar) (set2facts-equiv _ _ _ _ _ _).
%trustme %total {} (set2facts-equiv _ _ _ _ _ _).


%theorem apply-efx-deterministic 
  : forall* {P1} {P2} {X1} {X2} {Pi1} {Pi2} {PF1} {PF2}
    forall {AP1: apply-efx P1 X1 Pi1 PF1}
    {AP2: apply-efx P2 X2 Pi2 PF2}
    {E: bool`eq P1 P2}
    {E: efx`eq X1 X2}
    {E: permission`eq Pi1 Pi2}
    exists {E: {f} permission`eq (PF1 f) (PF2 f)}
    true.

- : apply-efx-deterministic AP1 AP2
    bool`eq/ efx`eq/ permission`eq/ ([_] permission`eq/).

%worlds () (apply-efx-deterministic _ _ _ _ _ _).
%total {} (apply-efx-deterministic _ _ _ _ _ _).

%abbrev apply-efx-unique = apply-efx-deterministic.


%theorem inner-efxmap2perm-equiv
  : forall* {P1} {P2} {O1} {O2} {FM1} {FM2}
    {PM1} {PM2} {M1} {M2} {Pi1} {Pi2}
    forall {M1=>Pi1: inner-efxmap2perm P1 O1 FM1 PM1 M1 Pi1}
    {M2=>Pi2: inner-efxmap2perm P2 O2 FM2 PM2 M2 Pi2}
    {E: bool`eq P1 P2}
    {E: object`eq O1 O2}
    {E: fldmap`eq FM1 FM2}
    {E: predmap`eq PM1 PM2}
    {E: inner-efxmap`eq M1 M2}
    exists {EQV: {f} equiv (Pi1 f) (Pi2 f)}
    true.

%worlds () (inner-efxmap2perm-equiv _ _ _ _ _ _ _ _).
%trustme %total {} (inner-efxmap2perm-equiv _ _ _ _ _ _ _ _).


%theorem efxmap2perm-equiv
  : forall* {P1} {P2} {CM1} {CM2} {PM1} {PM2} {B1} {B2}
    {XM1} {XM2} {Pi1} {Pi2}
    forall {XM1=>Pi1: efxmap2perm P1 CM1 PM1 B1 XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P2 CM2 PM2 B2 XM2 Pi2}
    {E: bool`eq P1 P2} {E: clsmap`eq CM1 CM2}
    {E: predmap`eq PM1 PM2} {E: cxt`eq B1 B2} {E: efxmap`eq XM1 XM2}
    exists {EQV: {f} equiv (Pi1 f) (Pi2 f)}
    true.

%worlds (fracvar) (efxmap2perm-equiv _ _ _ _ _ _ _ _).
%trustme %total {} (efxmap2perm-equiv _ _ _ _ _ _ _ _).


% =======================
% XX-respects-eq theorems
% =======================

%theorem apply-efx-respects-eq
  : forall* {B1} {B2} {X1} {X2} {P1} {P2} {S1} {S2}
    forall {AP: apply-efx B1 X1 P1 S1}
    {E: bool`eq B1 B2} {E: efx`eq X1 X2}
    {E: permission`eq P1 P2} {E: ({f} permission`eq (S1 f) (S2 f))}
    exists {AP: apply-efx B2 X2 P2 S2}
    true.

- : apply-efx-respects-eq apply-efx/read bool`eq/
    efx`eq/ permission`eq/ ([_] permission`eq/) apply-efx/read.
    
- : apply-efx-respects-eq apply-efx/write bool`eq/
    efx`eq/ permission`eq/ ([_] permission`eq/) apply-efx/write.

- : apply-efx-respects-eq apply-efx/consume/false bool`eq/
    efx`eq/ permission`eq/ ([_] permission`eq/) apply-efx/consume/false.

- : apply-efx-respects-eq apply-efx/consume/true bool`eq/
    efx`eq/ permission`eq/ ([_] permission`eq/) apply-efx/consume/true.

%worlds () (apply-efx-respects-eq _ _ _ _ _ _).
%total {} (apply-efx-respects-eq _ _ _ _ _ _).


%theorem inner-efxmap2perm-respects-eq
  : forall* {P1} {P2} {O1} {O2} {FM1} {FM2} 
    {PM1} {PM2} {M1} {M2} {Pi1} {Pi2} 
    forall {M1=>Pi1: inner-efxmap2perm P1 O1 FM1 PM1 M1 Pi1}
    {E: bool`eq P1 P2} {O: object`eq O1 O2}
    {E: fldmap`eq FM1 FM2} {E: predmap`eq PM1 PM2}
    {E: inner-efxmap`eq M1 M2} {E: ({f} permission`eq (Pi1 f) (Pi2 f))}
    exists {M2=>Pi2: inner-efxmap2perm P2 O2 FM2 PM2 M2 Pi2}
    true.

- : inner-efxmap2perm-respects-eq M=>Pi bool`eq/ object`eq/ fldmap`eq/ 
    predmap`eq/ inner-efxmap`eq/ ([_] permission`eq/) M=>Pi.

%worlds (fracvar) (inner-efxmap2perm-respects-eq _ _ _ _ _ _ _ _).
%total {} (inner-efxmap2perm-respects-eq _ _ _ _ _ _ _ _).


%theorem efxmap2perm-respects-eq
  : forall* {CM1} {PM1} {B1} {XM1} {Pi1} {P1}
    {CM2} {PM2} {B2} {XM2} {Pi2} {P2}
    forall  {XM1=>Pi1: efxmap2perm P1 CM1 PM1 B1 XM1 Pi1}
    {E: bool`eq P1 P2} {E: clsmap`eq CM1 CM2} {E: predmap`eq PM1 PM2}
    {E: cxt`eq B1 B2} {E: efxmap`eq XM1 XM2}
    {E: {f} permission`eq (Pi1 f) (Pi2 f)}
    exists  {XM2=>Pi2: efxmap2perm P2 CM2 PM2 B2 XM2 Pi2} 
    true.

- : efxmap2perm-respects-eq XM=>Pi bool`eq/ clsmap`eq/ predmap`eq/
    cxt`eq/ efxmap`eq/ ([_] permission`eq/) XM=>Pi.

%worlds (fracvar) (efxmap2perm-respects-eq _ _ _ _ _ _ _ _).
%total  {} (efxmap2perm-respects-eq _ _ _ _ _ _ _ _).



% ============================================
% theorems about leq - basically:
%
% if XM1 is less or equal than XM2, and
% XM1 ==> Pi1, XM2 ==> Pi2.
% then exists Pi3, such that Pi2 <==> Pi1 , Pi3
%
% =============================================

%theorem can-split-permission
  : forall* {Q1} {Pi}
    forall {Q1<1: rat`lst Q1 one}
    exists {Q2} {ADD: rat`add Q1 Q2 one}
    {EQV: equiv Pi ((scale (fraction/ Q1) Pi) , (scale (fraction/ Q2) Pi))}
    true.

- : can-split-permission (Q1<1:rat`lst Q1 one) Q2 Q1+Q2=1
    (equiv/transitive
      (equiv/symmetric equiv/one)
      (equiv/symmetric (equiv/add Q1+Q2=1)))
    <- rat`grt-implies-add Q1<1 Q2 Q2+Q1=1
    <- rat`add-commutative Q2+Q1=1 Q1+Q2=1.

%worlds () (can-split-permission _ _ _ _).
%total {} (can-split-permission _ _ _ _).


%% This turns out to be unprovable: we have no information
%% about the fraction variable - it could even be greater than 1!

% %theorem apply-efx-preserves-permission-leq
%   : forall* {X1} {X2} {Pi} {Pi1} {Pi2}
%     forall {X1<=X2: efx`leq X1 X2}
%     {AP-X1: apply-efx true X1 Pi Pi1}
%     {AP-X2: apply-efx true X2 Pi Pi2}
%     exists {Pi3}
%     {Pi2=>Pi1+Pi3: {f} equiv (Pi2 f) (Pi1 f , Pi3 f)}
%     true.

% %worlds (fracvar) (apply-efx-preserves-permission-leq _ _ _ _ _).
% %trustme %total {} (apply-efx-preserves-permission-leq _ _ _ _ _).
    


% =======================================
% deep-disjoint-join-implies-equiv:
%
% If we have two effect maps XM1 and XM2, 
%   and if the following condition holds
%
% 1. XM1^XM2
% 2. XM1+XM2 = XM
% 3. XM1 ==> Pi1
% 4. XM2 ==> Pi2
% 5. XM  ==> Pi
%
% then we can derive: 
% 
% Pi1 , Pi2 <==> Pi
%
% =======================================

%theorem inner-efxmap`disjoint-join-implies-equiv
  : forall* {M1} {M2} {M} {P} {O} {FM} {PM} {Pi1} {Pi2}
    forall {DJ: inner-efxmap`disjoint M1 M2}
    {J: inner-efxmap`join M1 M2 M}
    {M1=>Pi1: inner-efxmap2perm P O FM PM M1 Pi1}
    {M2=>Pi2: inner-efxmap2perm P O FM PM M2 Pi2}
    exists {Pi} {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
    {EQV: ({z} equiv ((Pi1 z) , (Pi2 z)) (Pi z))}
    true.

%theorem inner-efxmap`disjoint-join-implies-equiv/L
  : forall* {M1} {M2} {M} {P} {O} {FM} {PM} {Pi1} {Pi2} 
    forall {N1} {SZ1: inner-efxmap`size M1 N1}
    {N2} {SZ2: inner-efxmap`size M2 N2}
    {DJ: inner-efxmap`disjoint M1 M2}
    {J: inner-efxmap`join M1 M2 M}
    {M1=>Pi1: inner-efxmap2perm P O FM PM M1 Pi1}
    {M2=>Pi2: inner-efxmap2perm P O FM PM M2 Pi2}
    exists {Pi} {M=>Pi: inner-efxmap2perm P O FM PM M Pi}
    {EQV: ({z} equiv ((Pi1 z) , (Pi2 z)) (Pi z))}
    true.

- : inner-efxmap`disjoint-join-implies-equiv 
    M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 Pi M=>Pi EQV
    <- inner-efxmap`size-total SZ-M1
    <- inner-efxmap`size-total SZ-M2
    <- inner-efxmap`disjoint-join-implies-equiv/L
      _ SZ-M1 _ SZ-M2 M1^M2 M1UM2=M M1=>Pi1 M2=>Pi2 Pi M=>Pi EQV.

%worlds (fracvar) 
(inner-efxmap`disjoint-join-implies-equiv/L _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {N1 N2} 
(inner-efxmap`disjoint-join-implies-equiv/L N1 _ N2 _ _ _ _ _ _ _ _).

%worlds (fracvar) (inner-efxmap`disjoint-join-implies-equiv _ _ _ _ _ _ _).
%total {} (inner-efxmap`disjoint-join-implies-equiv _ _ _ _ _ _ _).


%theorem efxmap`deep-disjoint-join-implies-equiv 
  : forall* {XM1} {XM2} {XM} {P} {CM} {PM} {B} {Pi1} {Pi2}
    forall {DJ: efxmap`deep-disjoint XM1 XM2}
    {J: efxmap`join XM1 XM2 XM}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    exists {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    {EQV: ({z} equiv ((Pi1 z) , (Pi2 z)) (Pi z))}
    true.

%theorem efxmap`deep-disjoint-join-implies-equiv/L
  : forall* {XM1} {XM2} {XM} {P} {CM} {PM} {B} {Pi1} {Pi2}
    forall {N1} {SZ1: efxmap`size XM1 N1}
    {N2} {SZ2: efxmap`size XM2 N2}
    {DJ: efxmap`deep-disjoint XM1 XM2}
    {J: efxmap`join XM1 XM2 XM}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    exists {Pi} {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    {EQV: ({z} equiv ((Pi1 z) , (Pi2 z)) (Pi z))}
    true.

- : efxmap`deep-disjoint-join-implies-equiv 
    XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 Pi XM=>Pi EQV
    <- efxmap`size-total SZ1
    <- efxmap`size-total SZ2
    <- efxmap`deep-disjoint-join-implies-equiv/L 
      _ SZ1 _ SZ2 XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 Pi XM=>Pi EQV.

%worlds (fracvar) 
(efxmap`deep-disjoint-join-implies-equiv/L _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {N1 N2}
(efxmap`deep-disjoint-join-implies-equiv/L N1 _ N2 _ _ _ _ _ _ _ _).

%worlds (fracvar) (efxmap`deep-disjoint-join-implies-equiv _ _ _ _ _ _ _).
%total {} (efxmap`deep-disjoint-join-implies-equiv _ _ _ _ _ _ _).


%theorem efxmap`deep-disjoint-join-implies-equiv*
  : forall* {XM1} {XM2} {XM} {P} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {DJ: efxmap`deep-disjoint XM1 XM2}
    {J: efxmap`join XM1 XM2 XM}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    exists {EQV: ({z} equiv ((Pi1 z) , (Pi2 z)) (Pi z))}
    true.

- : efxmap`deep-disjoint-join-implies-equiv*
    XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 XM=>Pi 
    ([f] equiv/transitive (EQV1 f) (EQV2 f))
    <- efxmap`deep-disjoint-join-implies-equiv
    XM1^XM2 XM1UXM2=XM XM1=>Pi1 XM2=>Pi2 _ XM=>Pi' EQV1
    <- efxmap2perm-equiv XM=>Pi' XM=>Pi
      bool`eq/ clsmap`eq/ predmap`eq/ cxt`eq/ efxmap`eq/ EQV2.

%worlds (fracvar) (efxmap`deep-disjoint-join-implies-equiv* _ _ _ _ _ _).
%total {} (efxmap`deep-disjoint-join-implies-equiv* _ _ _ _ _ _).


%theorem efxmap`remove-tgtmap-implies-permission-combine*
  : forall* {XM1} {XM2} {XM} {GM2} {P} {CM} {PM} {B} {Pi1} {Pi2} {Pi}
    forall {R: efxmap`remove-tgtmap XM GM2 XM1 XM2}
    {XM=>Pi: efxmap2perm P CM PM B XM Pi}
    {XM1=>Pi1: efxmap2perm P CM PM B XM1 Pi1}
    {XM2=>Pi2: efxmap2perm P CM PM B XM2 Pi2}
    exists {EQV: ({f} equiv (Pi f) ((Pi1 f) , (Pi2 f)))}
    true.

- : efxmap`remove-tgtmap-implies-permission-combine*
    XM/GM2=XM1+XM2 XM=>Pi XM1=>Pi1 XM2=>Pi2 
    ([f] equiv/symmetric (Pi1+Pi2<=>Pi f))
    <- efxmap`remove-tgtmap-implies-deep-disjoint XM/GM2=XM1+XM2 XM1^XM2
    <- efxmap`remove-tgtmap-implies-join XM/GM2=XM1+XM2 XM1+XM2=XM
    <- efxmap`deep-disjoint-join-implies-equiv* 
      XM1^XM2 XM1+XM2=XM XM1=>Pi1 XM2=>Pi2 XM=>Pi Pi1+Pi2<=>Pi.

%worlds () (efxmap`remove-tgtmap-implies-permission-combine* _ _ _ _ _).
%total {} (efxmap`remove-tgtmap-implies-permission-combine* _ _ _ _ _). 


%theorem efxmap`leq-partition
  : forall* {XM1} {XM} {S} 
    forall {LEQ: efxmap`leq XM1 XM}
    {DM: efxmap`domain XM1 S}
    exists {XM2} {XM3} {DJ: efxmap`deep-disjoint XM2 XM3}
    {J: efxmap`join XM2 XM3 XM}
    {DM: efxmap`domain XM2 S}
    true.

%worlds () (efxmap`leq-partition _ _ _ _ _ _ _).
%trustme %total { } (efxmap`leq-partition _ _ _ _ _ _ _).



% ======================================
% no-consume
% if a efxmap is no-consume, then its 
% converted input and output permissions
% are the same.
% ======================================

%theorem apply-efx-no-consume-same-permission
  : forall* {X} {Pi} {Pi2}
    forall {NC-X: efx`not-consume X}
    {AP: apply-efx true X Pi Pi2}
    exists {AP: apply-efx false X Pi Pi2}
    true.

- : apply-efx-no-consume-same-permission
    efx`not-consume/read apply-efx/read apply-efx/read.

- : apply-efx-no-consume-same-permission
    efx`not-consume/write apply-efx/write apply-efx/write.

%worlds () (apply-efx-no-consume-same-permission _ _ _).
%total {} (apply-efx-no-consume-same-permission _ _ _).
 

%theorem inner-efxmap`no-consume-same-permission
  : forall* {O} {FM} {PM} {M} {Pi}
    forall {NC-M: inner-efxmap`no-consume M}
    {M=>Pi: inner-efxmap2perm true O FM PM M Pi}
    exists {M=>Pi: inner-efxmap2perm false O FM PM M Pi}
    true.

- : inner-efxmap`no-consume-same-permission
    inner-efxmap`no-consume/0 inner-efxmap2perm/0 inner-efxmap2perm/0.

- : inner-efxmap`no-consume-same-permission NC-M
    (inner-efxmap2perm/U/in N!<MP MP+N+X=M FM->N=T T=>PF X=>PF MP=>P2)
    (inner-efxmap2perm/U/in N!<MP MP+N+X=M FM->N=T T=>PF X=>PF2 MP=>P2P)
    <- inner-efxmap`update-implies-lookup MP+N+X=M M->N=X
    <- inner-efxmap`lookup-implies-not-consume NC-M M->N=X NC-X
    <- inner-efxmap`fresh-update-preserves-no-consume-converse
      NC-M N!<MP MP+N+X=M NC-MP
    <- inner-efxmap`no-consume-same-permission NC-MP MP=>P2 MP=>P2P
    <- apply-efx-no-consume-same-permission NC-X X=>PF X=>PF2.

- : inner-efxmap`no-consume-same-permission NC-M
    (inner-efxmap2perm/U/out N!<MP MP+N+X=M F!<FM MP=>P2)
    (inner-efxmap2perm/U/out N!<MP MP+N+X=M F!<FM MP=>P2P)
    <- inner-efxmap`fresh-update-preserves-no-consume-converse
      NC-M N!<MP MP+N+X=M NC-MP
    <- inner-efxmap`no-consume-same-permission NC-MP MP=>P2 MP=>P2P.

%worlds () (inner-efxmap`no-consume-same-permission _ _ _).
%total (T) (inner-efxmap`no-consume-same-permission _ T _).


%theorem efxmap`no-consume-same-permission
  : forall* {XM} {CM} {PM} {B} {Pi}
    forall {NC-XM: efxmap`no-consume XM}
    {XM=>Pi: efxmap2perm true CM PM B XM ([f] Pi f)}
    exists {XM=>Pi: efxmap2perm false CM PM B XM ([f] Pi f)}
    true.

- : efxmap`no-consume-same-permission
    efxmap`no-consume/0 efxmap2perm/0 efxmap2perm/0.

- : efxmap`no-consume-same-permission NC-XM
    (efxmap2perm/U/in N!<XMP XMP+N+M=XM B->N CM->C=FM T+M=>Pi1 T+XMP=>Pi2)
    (efxmap2perm/U/in N!<XMP XMP+N+M=XM B->N CM->C=FM F+M=>Pi1 F+XMP=>Pi2)
    <- efxmap`update-implies-lookup XMP+N+M=XM XM->N=M
    <- efxmap`lookup-implies-no-consume NC-XM XM->N=M NC-M
    <- inner-efxmap`no-consume-same-permission NC-M T+M=>Pi1 F+M=>Pi1
    <- efxmap`fresh-update-preserves-no-consume-converse 
      NC-XM N!<XMP XMP+N+M=XM NC-XMP
    <- efxmap`no-consume-same-permission NC-XMP T+XMP=>Pi2 F+XMP=>Pi2.

- : efxmap`no-consume-same-permission NC-XM
    (efxmap2perm/U/out N!<XMP XMP+N+M=XM N!<B T+XMP=>Pi2)
    (efxmap2perm/U/out N!<XMP XMP+N+M=XM N!<B F+XMP=>Pi2)
    <- efxmap`fresh-update-preserves-no-consume-converse 
      NC-XM N!<XMP XMP+N+M=XM NC-XMP
    <- efxmap`no-consume-same-permission NC-XMP T+XMP=>Pi2 F+XMP=>Pi2.

- : efxmap`no-consume-same-permission NC-XM
    (efxmap2perm/U/null N!<XMP XMP+N+M=XM B->N T+XMP=>Pi2)
    (efxmap2perm/U/null N!<XMP XMP+N+M=XM B->N F+XMP=>Pi2)
    <- efxmap`fresh-update-preserves-no-consume-converse 
      NC-XM N!<XMP XMP+N+M=XM NC-XMP
    <- efxmap`no-consume-same-permission NC-XMP T+XMP=>Pi2 F+XMP=>Pi2.

%worlds () (efxmap`no-consume-same-permission _ _ _).
%total (T) (efxmap`no-consume-same-permission _ T _).
