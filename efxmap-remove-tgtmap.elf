%%% Remove a tgtmap from a efxmap
%%% $Id: efxmap-remove-tgtmap.elf,v 1.3 2013/06/19 03:32:40 csun Exp csun $


%%% Definitions

% Project a efxmap on a tgtmap, and get another efxmap.

efxmap`project : efxmap -> tgtmap -> efxmap -> type.

efxmap`project/0 : efxmap`project efxmap/0 _ efxmap/0.

efxmap`project/U/out
  : efxmap`project XM1P GM XM2
    -> efxmap`fresh XM1P N
    -> efxmap`update XM1P N M XM1
    -> tgtmap`fresh GM N
    -> efxmap`project XM1 GM XM2.

efxmap`project/U/in
  : efxmap`project XM1P GM XM2P
    -> efxmap`fresh XM1P N
    -> efxmap`update XM1P N M1 XM1
    -> tgtmap`lookup GM N S
    -> inner-efxmap`restrict M1 S M2
    -> efxmap`update XM2P N M2 XM2
    -> efxmap`project XM1 GM XM2.


%% in output, the first efxmap is all efx that are preserved, the second
%% efxmap is all efx that are removed.
efxmap`remove-tgtmap : efxmap -> tgtmap -> efxmap -> efxmap -> type.

efxmap`remove-tgtmap/
  : efxmap2tgtmap XM GM
    -> tgtmap`remove GM GM2 GM1
    -> efxmap`project XM GM1 XM1
    -> efxmap`project XM GM2 XM2
    -> efxmap`remove-tgtmap XM GM2 XM1 XM2.



%%% Theorems on projection

%theorem efxmap`false-implies-project
  : forall* {XM} {GM} {XMP} forall {V:void}
    exists {P: efxmap`project XM GM XMP}
    true.

%worlds () (efxmap`false-implies-project _ _).
%total {} (efxmap`false-implies-project _ _).


%theorem efxmap`project-respects-eq
  : forall* {A} {AP} {B} {BP} {C} {CP}
    forall {P: efxmap`project A C B}
    {E: efxmap`eq A AP} {E: tgtmap`eq C CP} {E: efxmap`eq B BP}
    exists {PP: efxmap`project AP CP BP}
    true.

- : efxmap`project-respects-eq P _ _ _ P.

%worlds () (efxmap`project-respects-eq _ _ _ _ _).
%total {} (efxmap`project-respects-eq _ _ _ _ _).


%theorem efxmap`project/in-inversion
  : forall* {XM1} {XM2} {GM} {XM1P} {N} {M} {S} {MP}
    forall {P: efxmap`project XM1 GM XM2}
    {F: efxmap`fresh XM1P N} {U: efxmap`update XM1P N M XM1}
    {L: tgtmap`lookup GM N S} {R: inner-efxmap`restrict M S MP}
    exists {XM2P} {R1: efxmap`project XM1P GM XM2P}
    {U1: efxmap`update XM2P N MP XM2}
    true.

%theorem efxmap`project/in-inversion/in
  : forall* {GM} {XM1} {XM2} {XM1S} {XM2S} {XM1P} {N1} {N2}
    {M1} {M1P} {M2} {M2P} {S} {SP} {B}
    forall {P: efxmap`project XM1S GM XM2S}
    {F: efxmap`fresh XM1S N1} {U: efxmap`update XM1S N1 M1 XM1}
    {L: tgtmap`lookup GM N1 S} {R: inner-efxmap`restrict M1 S M2}
    {U: efxmap`update XM2S N1 M2 XM2}
    {F: efxmap`fresh XM1P N2} {U: efxmap`update XM1P N2 M1P XM1}
    {L: tgtmap`lookup GM N2 SP} {R: inner-efxmap`restrict M1P SP M2P}
    {EQ?: nat`eq? N2 N1 B}
    exists {XM2P} {P1: efxmap`project XM1P GM XM2P}
    {U1: efxmap`update XM2P N2 M2P XM2}
    true.

- :efxmap`project/in-inversion/in
    XM1S+GM=>XM2S N!<XM1S XM1S+N+M1=XM1 GM->N=S M1|S=M2
    XM2S+N+M2=XM2 N!<XM1P XM1P+N+M1P=XM1 GM->N=SP M1P|SP=M2P
    (nat`eq?/yes) _ XM1P+GM=>XM2S XM2S+N+M2P=XM2
    <- efxmap`fresh-update-cancels
      N!<XM1S XM1S+N+M1=XM1 N!<XM1P XM1P+N+M1P=XM1 nat`eq/ efxmap`eq/
      M1=M1P XM1S=XM1P
    <- efxmap`project-respects-eq
      XM1S+GM=>XM2S XM1S=XM1P tgtmap`eq/ efxmap`eq/ XM1P+GM=>XM2S
    <- tgtmap`lookup-unique GM->N=S GM->N=SP tgtmap`eq/ nat`eq/ S=SP
    <- inner-efxmap`restrict-unique M1|S=M2 M1P|SP=M2P M1=M1P S=SP M2=M2P
    <- efxmap`update-respects-eq
      XM2S+N+M2=XM2 efxmap`eq/ nat`eq/ M2=M2P efxmap`eq/ XM2S+N+M2P=XM2.

- : efxmap`project/in-inversion/in
    XM1S+GM=>XM2S N1!<XM1S XM1S+N1+M1=XM1 GM->N1=S M1|S=M2
    XM2S+N1+M2=XM2 N2!<XM1P XM1P+N2+M1P=XM1 GM->N2=SP M1P|SP=M2P
    (nat`eq?/no N2<>N1) _
    (efxmap`project/U/in XM1K+GM=>XM2K
      N1!<XM1K XM1K+N1+M1=XM1P GM->N1=S M1|S=M2 XM2K+N1+M2=XM2U)
    XM2U+N2+M2P=XM2
    <- efxmap`update-commutes-converse
      XM1P+N2+M1P=XM1 XM1S+N1+M1=XM1 N2<>N1 XM1K XM1K+N1+M1=XM1P XM1K+N2+M1P=XM1S
    <- efxmap`update-preserves-fresh-converse N2!<XM1P XM1K+N1+M1=XM1P N2!<XM1K
    <- efxmap`project/in-inversion XM1S+GM=>XM2S N2!<XM1K XM1K+N2+M1P=XM1S
      GM->N2=SP M1P|SP=M2P XM2K XM1K+GM=>XM2K XM2K+N2+M2P=XM2S
    <- efxmap`update-preserves-fresh-converse N1!<XM1S XM1K+N2+M1P=XM1S N1!<XM1K
    <- efxmap`update-commutes XM2K+N2+M2P=XM2S XM2S+N1+M2=XM2
      N2<>N1 XM2U XM2K+N1+M2=XM2U XM2U+N2+M2P=XM2.

- : efxmap`project/in-inversion
    (efxmap`project/U/in XM1S+GM=>XM2S N1!<XM1S XM1S+N1+M1=XM1
      GM->N1=S M1|S=M2 XM2S+N1+M2=XM2) N2!<XM1P XM1P+N2+M1P=XM1
    GM->N2=SP M1P|SP=M2P XM2P XM1P+GM=>XM2P XM2P+N2+M2P=XM2
    <- nat`eq?-total EQ?
    <- efxmap`project/in-inversion/in XM1S+GM=>XM2S N1!<XM1S XM1S+N1+M1=XM1
      GM->N1=S M1|S=M2 XM2S+N1+M2=XM2 N2!<XM1P XM1P+N2+M1P=XM1
    GM->N2=SP M1P|SP=M2P EQ? XM2P XM1P+GM=>XM2P XM2P+N2+M2P=XM2.

- : efxmap`project/in-inversion
    (efxmap`project/U/out XM1S+GM=>XM2 N1!<XM1S XM1S+N1+M=XM1 N1!<GM)
    N2!<XM1P XM1P+N2+MP=XM1 GM->N2=_ R
    _ (efxmap`project/U/out XM1K+GM=>XM2K N1!<XM1K XM1K+N1+M=XM1P
        N1!<GM) XM2K+N2+MP=XM2
    <- tgtmap`fresh-lookup-not-equal N1!<GM GM->N2=_ N1<>N2
    <- efxmap`update-commutes-converse XM1S+N1+M=XM1 XM1P+N2+MP=XM1 N1<>N2
      XM1K XM1K+N2+MP=XM1S XM1K+N1+M=XM1P
    <- efxmap`update-preserves-fresh-converse N2!<XM1P XM1K+N1+M=XM1P N2!<XM1K
    <- efxmap`project/in-inversion XM1S+GM=>XM2 N2!<XM1K XM1K+N2+MP=XM1S
      GM->N2=_ R XM2K XM1K+GM=>XM2K XM2K+N2+MP=XM2
    <- efxmap`update-preserves-fresh-converse N1!<XM1S XM1K+N2+MP=XM1S N1!<XM1K.

%worlds () (efxmap`project/in-inversion _ _ _ _ _ _ _ _ )
(efxmap`project/in-inversion/in _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (P1 P2) (efxmap`project/in-inversion P1 _ _ _ _ _ _ _ )
(efxmap`project/in-inversion/in P2 _ _ _ _ _ _ _ _ _ _ _ _ _).



%theorem efxmap`project/out-inversion
  : forall* {XM1} {XM2} {GM} {XM1P} {N} {M}
    forall {P: efxmap`project XM1 GM XM2}
    {F: efxmap`fresh XM1P N} {U: efxmap`update XM1P N M XM1}
    {F2: tgtmap`fresh GM N}
    exists {P1: efxmap`project XM1P GM XM2}
    true.

%theorem efxmap`project/out-inversion/out
  : forall* {GM} {XM1} {XM2} {XM1S} {XM1P} {N1} {N2}
    {M1} {M1P} {B}
    forall {P: efxmap`project XM1S GM XM2}
    {F: efxmap`fresh XM1S N1} {U: efxmap`update XM1S N1 M1 XM1}
    {GF: tgtmap`fresh GM N1} {F: efxmap`fresh XM1P N2}
    {U: efxmap`update XM1P N2 M1P XM1}
    {GF: tgtmap`fresh GM N2} {EQ?: nat`eq? N2 N1 B}
    exists {P1: efxmap`project XM1P GM XM2}
    true.

- : efxmap`project/out-inversion/out
    XM1S+GM=>XM2 N!<XM1S XM1S+N+M1=XM1 N!<GM
    N!<XM1P XM1P+N+M1P=XM1 _ (nat`eq?/yes) XM1P+GM=>XM2
    <- efxmap`fresh-update-cancels N!<XM1S XM1S+N+M1=XM1
    N!<XM1P XM1P+N+M1P=XM1 nat`eq/ efxmap`eq/ M1=M1P XM1S=XM1P
    <- efxmap`project-respects-eq
      XM1S+GM=>XM2 XM1S=XM1P tgtmap`eq/ efxmap`eq/ XM1P+GM=>XM2.

- : efxmap`project/out-inversion/out
    XM1S+GM=>XM2 N1!<XM1S XM1S+N1+M1=XM1 N1!<GM
    N2!<XM1P XM1P+N2+M1P=XM1 N2!<GM (nat`eq?/no N2<>N1)
    (efxmap`project/U/out XM1K+GM=>XM2 N1!<XM1K XM1K+N1+M1=XM1P N1!<GM)
    <- efxmap`update-commutes-converse
      XM1P+N2+M1P=XM1 XM1S+N1+M1=XM1 N2<>N1 XM1K XM1K+N1+M1=XM1P XM1K+N2+M1P=XM1S
    <- efxmap`update-preserves-fresh-converse N2!<XM1P XM1K+N1+M1=XM1P N2!<XM1K
    <- efxmap`project/out-inversion
      XM1S+GM=>XM2 N2!<XM1K XM1K+N2+M1P=XM1S N2!<GM XM1K+GM=>XM2
    <- efxmap`update-preserves-fresh-converse N1!<XM1S XM1K+N2+M1P=XM1S N1!<XM1K.

- : efxmap`project/out-inversion
    (efxmap`project/U/out XM1S+GM=>XM2 N1!<XM1S XM1S+N1+M1=XM1 N1!<GM)
    N2!<XM1P XM1P+N2+M1P=XM1 N2!<GM XM1P+GM=>XM2
    <- nat`eq?-total EQ?
    <- efxmap`project/out-inversion/out
      XM1S+GM=>XM2 N1!<XM1S XM1S+N1+M1=XM1 N1!<GM
      N2!<XM1P XM1P+N2+M1P=XM1 N2!<GM EQ? XM1P+GM=>XM2.

- : efxmap`project/out-inversion
    (efxmap`project/U/in XM1S+GM=>XM2S N1!<XM1S XM1S+N1+M1=XM1
      GM->N1=S M1|S=M2 XM2S+N1+M2=XM2) N2!<XM1P XM1P+N2+M1P=XM1 N2!<GM
    (efxmap`project/U/in XM1K+GM=>XM2S N1!<XM1K XM1K+N1+M1=XM1P
      GM->N1=S M1|S=M2 XM2S+N1+M2=XM2)
    <- tgtmap`fresh-lookup-not-equal N2!<GM GM->N1=S N2<>N1
    <- efxmap`update-commutes-converse XM1P+N2+M1P=XM1 XM1S+N1+M1=XM1 N2<>N1
      XM1K XM1K+N1+M1=XM1P XM1K+N2+M1P=XM1S
    <- efxmap`update-preserves-fresh-converse N2!<XM1P XM1K+N1+M1=XM1P N2!<XM1K
    <- efxmap`project/out-inversion XM1S+GM=>XM2S N2!<XM1K XM1K+N2+M1P=XM1S
      N2!<GM XM1K+GM=>XM2S
    <- efxmap`update-preserves-fresh-converse N1!<XM1S XM1K+N2+M1P=XM1S N1!<XM1K.

%worlds () (efxmap`project/out-inversion _ _ _ _ _)
	   (efxmap`project/out-inversion/out _ _ _ _ _ _ _ _ _).
%total (P1 P2) (efxmap`project/out-inversion P1 _ _ _ _)
	   (efxmap`project/out-inversion/out P2 _ _ _ _ _ _ _ _).


%theorem efxmap`project-unique
  : forall* {XM1} {XM1P} {XM2} {XM2P} {GM1} {GM1P}
    forall {P1: efxmap`project XM1 GM1 XM2}
    {P2: efxmap`project XM1P GM1P XM2P}
    {E: efxmap`eq XM1 XM1P} {E: tgtmap`eq GM1 GM1P}
    exists {E: efxmap`eq XM2 XM2P}
    true.

- : efxmap`project-unique
    efxmap`project/0 efxmap`project/0 _ _ efxmap`eq/.

- : efxmap`project-unique
    (efxmap`project/U/in XM1S+GM=>XM2S N!<XM1S XM1S+N+M=XM1
      GM->N=S M|S=MP XM2S+N+MP=XM2) P efxmap`eq/ tgtmap`eq/ XM2=XM2P
    <- efxmap`project/in-inversion
      P N!<XM1S XM1S+N+M=XM1 GM->N=S M|S=MP
      XM2SP XM1S+GM=>XM2SP XM2SP+N+MP=XM2P
    <- efxmap`project-unique XM1S+GM=>XM2S XM1S+GM=>XM2SP
      efxmap`eq/ tgtmap`eq/ XM2S=XM2SP
    <- efxmap`update-unique XM2S+N+MP=XM2 XM2SP+N+MP=XM2P
      XM2S=XM2SP nat`eq/ inner-efxmap`eq/ XM2=XM2P.

- : efxmap`project-unique
    (efxmap`project/U/out XM1S+GM=>XM2 N!<XM1S XM1S+N+M=XM1 N!<GM) P
    efxmap`eq/ tgtmap`eq/ XM2=XM2P
    <- efxmap`project/out-inversion P N!<XM1S XM1S+N+M=XM1 N!<GM XM1S+GM=>XM2P
    <- efxmap`project-unique
      XM1S+GM=>XM2 XM1S+GM=>XM2P efxmap`eq/ tgtmap`eq/ XM2=XM2P.

%worlds () (efxmap`project-unique _ _ _ _ _).
%total (P) (efxmap`project-unique P _ _ _ _).


%theorem efxmap`project-total*
  : forall {XM} {GM}
    exists {XMP} {P: efxmap`project XM GM XMP}
    true.

%worlds () (efxmap`project-total* _ _ _ _).
%trustme %total {} (efxmap`project-total* _ _ _ _).

%abbrev efxmap`project-total = efxmap`project-total* _ _ _.


%theorem efxmap`project-implies-leq
  : forall* {GM} {XM} {XMP}
    forall {P: efxmap`project XM GM XMP}
    exists {LE: efxmap`leq XMP XM}
    true.

- : efxmap`project-implies-leq efxmap`project/0 efxmap`leq/0.

- : efxmap`project-implies-leq
    (efxmap`project/U/out P F1 U F2) LE
    <- efxmap`project-implies-leq P LE1
    <- efxmap`fresh-update-implies-leq F1 U LE2
    <- efxmap`leq-transitive LE1 LE2 LE.

- : efxmap`project-implies-leq
    (efxmap`project/U/in P F U1 L R U2) LE
    <- efxmap`project-implies-leq P LE1
    <- inner-efxmap`restrict-implies-leq R LE2
    <- efxmap`update-preserves-leq* LE1 LE2 U2 U1 LE.

%worlds () (efxmap`project-implies-leq _ _).
%total (P) (efxmap`project-implies-leq P _).


%theorem efxmap`fresh-update-right-same-result
  : forall* {XM} {GM} {XMP} {GMP} {N} {S}
    forall {P1: efxmap`project XM GM XMP}
    {F1: efxmap`fresh XM N}
    {F2: tgtmap`fresh GMP N}
    {U: tgtmap`update GMP N S GM}
    exists {P2: efxmap`project XM GMP XMP}
    true.

%worlds () (efxmap`fresh-update-right-same-result _ _ _ _ _).
%trustme %total {} (efxmap`fresh-update-right-same-result _ _ _ _ _).


%theorem efxmap`project-leq-implies-efxmap2tgtmap
  : forall* {XM} {GM} {XMP}
    forall {P: efxmap`project XM GM XMP}
    {LE: tgtmap`leq-efxmap GM XM}
    exists {T: efxmap2tgtmap XMP GM}
    true.

%worlds () (efxmap`project-leq-implies-efxmap2tgtmap _ _ _).
%trustme %total {} (efxmap`project-leq-implies-efxmap2tgtmap _ _ _).



%theorem efxmap`fresh-update-preserves-project-converse
  : forall* {XM} {XM2P} {XMS} {GM2S} {N} {GM2} {M} {S} {MS}
    forall {P1: efxmap`project XM GM2 XM2P}
    {F1: efxmap`fresh XMS N}
    {U1: efxmap`update XMS N M XM}
    {F2: tgtmap`fresh GM2S N}
    {U2: tgtmap`update GM2S N S GM2}
    {R: inner-efxmap`restrict M S MS}
    exists {XM2PS} {F3: efxmap`fresh XM2PS N}
    {U3: efxmap`update XM2PS N MS XM2P}
    {P2: efxmap`project XMS GM2S XM2PS}
    true.

%theorem efxmap`fresh-update-preserves-project-converse/L
  : forall* {N1} {N2} {B} {XMP} {XM2PP} {GM2} {M1} {M2} {M1P}
    {XMS} {S1} {XM} {XM2P} {GM2S} {S2} {MS}
    forall {EQ?: nat`eq? N1 N2 B}
    {P: efxmap`project XMP GM2 XM2PP}
    {F: efxmap`fresh XMP N1}
    {U: efxmap`update XMP N1 M1 XM}
    {L: tgtmap`lookup GM2 N1 S1}
    {R1: inner-efxmap`restrict M1 S1 M1P}
    {U2: efxmap`update XM2PP N1 M1P XM2P}
    {F2: efxmap`fresh XMS N2}
    {U3: efxmap`update XMS N2 M2 XM}
    {F3: tgtmap`fresh GM2S N2}
    {U4: tgtmap`update GM2S N2 S2 GM2}
    {R2: inner-efxmap`restrict M2 S2 MS}
    exists {XM2PS} {F4: efxmap`fresh XM2PS N2}
    {U4: efxmap`update XM2PS N2 MS XM2P}
    {P: efxmap`project XMS GM2S XM2PS}
    true.

- : efxmap`fresh-update-preserves-project-converse/L nat`eq?/yes
    (XMP+GM2=>XM2PP:efxmap`project XMP GM2 XM2PP) N!<XMP XMP+N+M1=XM
    GM2->N=S1 (M1|S1=M1P:inner-efxmap`restrict M1 S1 M1P)
    (XM2PP+N+M1P=XM2P:efxmap`update XM2PP N M1P XM2P)
    N!<XMS XMS+N+M2=XM
    N!<GM2S (GM2S+N+S2=GM2:tgtmap`update GM2S N S2 GM2)
    (M2|S2=MS:inner-efxmap`restrict M2 S2 MS)
    XM2PP N!<XM2PP XM2PP+N+MS=XM2P
    (XMS+GM2S=>XM2PP:efxmap`project XMS GM2S XM2PP)
    <- efxmap`fresh-update-cancels N!<XMP XMP+N+M1=XM N!<XMS XMS+N+M2=XM
      nat`eq/ efxmap`eq/ M1=M2 XMP=XMS
    <- efxmap`project-respects-eq
      XMP+GM2=>XM2PP XMP=XMS tgtmap`eq/ efxmap`eq/ XMS+GM2=>XM2PP
    <- tgtmap`update-implies-lookup GM2S+N+S2=GM2 GM2->N=S2
    <- tgtmap`lookup-unique GM2->N=S1 GM2->N=S2 tgtmap`eq/ nat`eq/ S1=S2
    <- inner-efxmap`restrict-unique M1|S1=M1P M2|S2=MS M1=M2 S1=S2 M1P=MS
    <- efxmap`update-respects-eq XM2PP+N+M1P=XM2P efxmap`eq/ nat`eq/ M1P=MS
      efxmap`eq/ XM2PP+N+MS=XM2P
    <- efxmap`project-implies-leq XMP+GM2=>XM2PP XM2PP<=XMP
    <- efxmap`fresh-respects-geq N!<XMP XM2PP<=XMP N!<XM2PP
    <- efxmap`fresh-update-right-same-result
      XMS+GM2=>XM2PP N!<XMS N!<GM2S GM2S+N+S2=GM2 XMS+GM2S=>XM2PP.

- : efxmap`fresh-update-preserves-project-converse/L (nat`eq?/no N1<>N2)
    (XMP+GM2=>XM2PP:efxmap`project XMP GM2 XM2PP) N1!<XMP XMP+N1+M1=XM
    GM2->N1=S1 (M1|S1=M1P:inner-efxmap`restrict M1 S1 M1P)
    (XM2PP+N1+M1P=XM2P:efxmap`update XM2PP N1 M1P XM2P) N2!<XMS
    (XMS+N2+M2=XM:efxmap`update XMS N2 M2 XM)
    N2!<GM2S (GM2S+N2+S2=GM2:tgtmap`update GM2S N2 S2 GM2)
    (M2|S2=MS:inner-efxmap`restrict M2 S2 MS)
    %{=>}% XM2KK N2!<XM2KK XM2KK+N2+MS=XM2P
    (efxmap`project/U/in XMPS+GM2S=>XM2PS N1!<XMPS XMPS+N1+M1=XMS
      GM2S->N1=S1 M1|S1=M1P XM2PS+N1+M1P=XM2KK)
    <- efxmap`update-commutes-converse
      XMP+N1+M1=XM XMS+N2+M2=XM N1<>N2 XMPS XMPS+N2+M2=XMP XMPS+N1+M1=XMS
    <- efxmap`update-preserves-fresh-converse N2!<XMS XMPS+N1+M1=XMS N2!<XMPS
    <- efxmap`update-preserves-fresh-converse N1!<XMP XMPS+N2+M2=XMP N1!<XMPS
    <- tgtmap`update-preserves-lookup-converse
      GM2->N1=S1 GM2S+N2+S2=GM2 N1<>N2 GM2S->N1=S1
    <- efxmap`fresh-update-preserves-project-converse
      XMP+GM2=>XM2PP N2!<XMPS XMPS+N2+M2=XMP
      N2!<GM2S GM2S+N2+S2=GM2 M2|S2=MS XM2PS N2!<XM2PS XM2PS+N2+MS=XM2PP
      XMPS+GM2S=>XM2PS
    <- nat`ne-symmetric N1<>N2 N2<>N1
    <- efxmap`update-commutes XM2PS+N2+MS=XM2PP XM2PP+N1+M1P=XM2P
      N2<>N1 XM2KK XM2PS+N1+M1P=XM2KK XM2KK+N2+MS=XM2P
    <- efxmap`update-preserves-fresh
      N2!<XM2PS XM2PS+N1+M1P=XM2KK N2<>N1 N2!<XM2KK.

- : efxmap`fresh-update-preserves-project-converse
    (efxmap`project/U/out XMP+GM2=>XM2P N1!<XMP XMP+N1+M1=XM N1!<GM2)
    N2!<XMS XMS+N2+M2=XM N2!<GM2S GM2S+N2+S2=GM2 M2|S2=MS XM2PS N2!<XM2PS
    XM2PS+N2+MS=XM2P
    (efxmap`project/U/out XMPS+GM2S=>XM2PS N1!<XMPS XMPS+N1+M1=XMS N1!<GM2S)
    <- tgtmap`update-implies-lookup GM2S+N2+S2=GM2 GM2->N2=S2
    <- tgtmap`fresh-lookup-not-equal N1!<GM2 GM2->N2=S2 N1<>N2
    <- efxmap`update-commutes-converse
      XMP+N1+M1=XM XMS+N2+M2=XM N1<>N2 XMPS XMPS+N2+M2=XMP XMPS+N1+M1=XMS
    <- tgtmap`update-preserves-fresh-converse N1!<GM2 GM2S+N2+S2=GM2 N1!<GM2S
    <- efxmap`update-preserves-fresh-converse N2!<XMS XMPS+N1+M1=XMS N2!<XMPS
    <- efxmap`update-preserves-fresh-converse N1!<XMP XMPS+N2+M2=XMP N1!<XMPS
    <- efxmap`fresh-update-preserves-project-converse
      XMP+GM2=>XM2P N2!<XMPS XMPS+N2+M2=XMP
      N2!<GM2S GM2S+N2+S2=GM2 M2|S2=MS XM2PS N2!<XM2PS XM2PS+N2+MS=XM2P
      XMPS+GM2S=>XM2PS.

- : efxmap`fresh-update-preserves-project-converse
    (efxmap`project/U/in XMP+GM2=XM2PP N1!<XMP XMP+N1+M1=XM
      GM2->N1=S1 M1|S1=M1P XM2PP+N1+M1P=XM2P) N2!<XMS
    XMS+N2+M2=XM N2!<GM2S GM2S+N2+S2=GM2 M2|S2=MS XM2PS
    N2!<XM2PS XM2PS+N2+MS=XM2P XMS+GM2S=>XM2PS
    <- nat`eq?-total N1==N2?
    <- efxmap`fresh-update-preserves-project-converse/L
      N1==N2? XMP+GM2=XM2PP N1!<XMP XMP+N1+M1=XM
      GM2->N1=S1 M1|S1=M1P XM2PP+N1+M1P=XM2P N2!<XMS
      XMS+N2+M2=XM N2!<GM2S GM2S+N2+S2=GM2 M2|S2=MS XM2PS
      N2!<XM2PS XM2PS+N2+MS=XM2P XMS+GM2S=>XM2PS.

%worlds ()
(efxmap`fresh-update-preserves-project-converse/L
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(efxmap`fresh-update-preserves-project-converse _ _ _ _ _ _ _ _ _ _).
%total (P1 P2)
(efxmap`fresh-update-preserves-project-converse P1 _ _ _ _ _ _ _ _ _)
(efxmap`fresh-update-preserves-project-converse/L
  _ P2 _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem efxmap`project-empty
  : forall {XM} exists {P: efxmap`project XM tgtmap/0 efxmap/0} true.

%theorem efxmap`project-empty/L
  : forall* {XM}
    forall {N} {SZ: efxmap`size XM N}
    exists {P: efxmap`project XM tgtmap/0 efxmap/0}
    true.

- : efxmap`project-empty/L z _ efxmap`project/0.

- : efxmap`project-empty/L (s N) SZ
    (efxmap`project/U/out P F U tgtmap`fresh/0)
    <- efxmap`can-remove SZ (efxmap`lookup/= nat`eq/) _ K SZ- SEQ U F
    <- nat`succ-cancels SEQ EQ
    <- efxmap`size-respects-eq SZ- efxmap`eq/ EQ SZ--
    <- efxmap`project-empty/L N SZ-- P.

- : efxmap`project-empty _ P
    <- efxmap`size-total SZ
    <- efxmap`project-empty/L _ SZ P.

%worlds () (efxmap`project-empty/L _ _ _).
%total (N) (efxmap`project-empty/L N _ _).

%worlds () (efxmap`project-empty _ _).
%total {} (efxmap`project-empty _ _).


%theorem inner-efxmap`restrict-leq-implies-domain
  : forall* {M} {MP} {S} {SP}
    forall {R: inner-efxmap`restrict M SP MP}
    {DM: inner-efxmap`domain M S} {LE: set`leq SP S}
    exists {DM2: inner-efxmap`domain MP SP}
    true.

- : inner-efxmap`restrict-leq-implies-domain M|SP=MP DM-M=S SP<=S DM-MP=SP
    <- inner-efxmap`domain-total DM-MP=SPP
    <- inner-efxmap`restrict-implies-domain-intersection*
      M|SP=MP DM-M=S DM-MP=SPP S^SP=SPP
    <- set`intersection-commutative S^SP=SPP SP^S=SPP
    <- set`leq-implies-intersection SP<=S SP^S=SP
    <- set`intersection-unique SP^S=SPP SP^S=SP set`eq/ set`eq/ SPP=SP
    <- inner-efxmap`domain-respects-eq
      DM-MP=SPP inner-efxmap`eq/ SPP=SP DM-MP=SP.

%worlds () (inner-efxmap`restrict-leq-implies-domain _ _ _ _).
%total {} (inner-efxmap`restrict-leq-implies-domain _ _ _ _).


%theorem efxmap`project-preserves-wf/L
  : forall* {XM} {GM} {XMP}
    forall {N} {SZ: efxmap`size XM N}
    {LE: tgtmap`leq-efxmap GM XM}
    {P: efxmap`project XM GM XMP} {W: tgtmap`wf GM}
    exists {W: efxmap`wf XMP}
    true.

- : efxmap`project-preserves-wf/L _ _ _ P tgtmap`wf/0 WF
    <- efxmap`project-empty _ P2
    <- efxmap`project-unique P2 P efxmap`eq/ tgtmap`eq/ EQ
    <- efxmap`wf-respects-eq efxmap`wf/0 EQ WF.

- : efxmap`project-preserves-wf/L _ SZ GM<=XM
    (efxmap`project/U/out XM1+GM=>XMP N!<XM1 XM1+N+M1=XM N!<GM)
    WF-GM (WF-XMP:efxmap`wf XMP)
    <- efxmap`fresh-update-increases-size-converse SZ N!<XM1 XM1+N+M1=XM SZS
    <- tgtmap`fresh-update2-preserves-leq-efxmap-converse
      GM<=XM N!<GM N!<XM1 XM1+N+M1=XM GM<=XM1
    <- efxmap`project-preserves-wf/L _ SZS GM<=XM1 XM1+GM=>XMP WF-GM WF-XMP.

- : efxmap`project-preserves-wf/L _ SZ GM<=XM
    (efxmap`project/U/in XMP+GM=>XMPP N!<XMP XMP+N+M1=XM
      GM->N=S M1|S=M2 XMPP+N+M2=XMP) WF-GM WF-XMP
    <- tgtmap`lookup-implies-fresh-update GM->N=S GMP N!<GMP GMP+N+S=GM
    <- tgtmap`fresh-update-preserves-leq-efxmap-converse
      GM<=XM N!<GMP GMP+N+S=GM N!<XMP XMP+N+M1=XM GMP<=XMP
    <- efxmap`fresh-update-right-same-result
      XMP+GM=>XMPP N!<XMP N!<GMP GMP+N+S=GM XMP+GMP=>XMPP
    <- tgtmap`fresh-update-preserves-wf-converse
      WF-GM N!<GMP GMP+N+S=GM WF-GMP _
    <- efxmap`fresh-update-increases-size-converse SZ N!<XMP XMP+N+M1=XM SZS
    <- efxmap`project-preserves-wf/L _ SZS GMP<=XMP XMP+GMP=>XMPP WF-GMP WF-XMPP
    <- efxmap`update-implies-lookup XMP+N+M1=XM XM->N=M1
    <- tgtmap`wf-lookup-implies-non-empty WF-GM GM->N=S SZ-S>0
    <- tgtmap`lookup-respects-leq-efxmap*
      GM->N=S GM<=XM XM->N=M1 SP DM-M1=SP S<=SP
    <- inner-efxmap`restrict-leq-implies-domain M1|S=M2 DM-M1=SP S<=SP DM-M2=S
    <- inner-efxmap`domain-preserves-size-converse SZ-S>0 DM-M2=S SZ-M2>0
    <- efxmap`update-preserves-wf WF-XMPP SZ-M2>0 XMPP+N+M2=XMP WF-XMP.

%worlds () (efxmap`project-preserves-wf/L _ _ _ _ _ _).
%total (N) (efxmap`project-preserves-wf/L N _ _ _ _ _).


%theorem efxmap`project-preserves-wf
  : forall* {GM} {XM} {XMP}
    forall {W: tgtmap`wf GM}
    {LE: tgtmap`leq-efxmap GM XM}
    {P: efxmap`project XM GM XMP}
    exists {W: efxmap`wf XMP}
    true.

- : efxmap`project-preserves-wf WF LE P WF2
    <- efxmap`size-total SZ
    <- efxmap`project-preserves-wf/L _ SZ LE P WF WF2.

%worlds () (efxmap`project-preserves-wf _ _ _ _).
%total {} (efxmap`project-preserves-wf _ _ _ _).


%theorem efxmap`fresh-update-preserves-project
  : forall* {XM} {GM} {XMP} {N} {S} {GMP}
    forall {P: efxmap`project XM GM XMP}
    {F: efxmap`fresh XM N} {U: tgtmap`update GM N S GMP}
    exists {P: efxmap`project XM GMP XMP}
    true.

%worlds () (efxmap`fresh-update-preserves-project _ _ _ _).
%trustme %total {} (efxmap`fresh-update-preserves-project _ _ _ _).


%theorem efxmap`project-no-change
  : forall* {XM} {GM}
    forall {XM2GM: efxmap2tgtmap XM GM}
    exists {P: efxmap`project XM GM XM}
    true.

%worlds () (efxmap`project-no-change _ _).
%trustme %total {} (efxmap`project-no-change _ _).


%%% Theorems on remove-tgtmap

%theorem efxmap`false-implies-remove-tgtmap
  : forall* {XM} {GM} {XM1} {XM2}
    forall {V:void}
    exists {R: efxmap`remove-tgtmap XM GM XM1 XM2}
    true.

%worlds () (efxmap`false-implies-remove-tgtmap V R).
%total {} (efxmap`false-implies-remove-tgtmap V R).


%theorem efxmap`remove-tgtmap-respects-eq
  : forall* {XM} {XMP} {GM} {GMP} {XM1} {XM2} {XM1P} {XM2P}
    forall {R: efxmap`remove-tgtmap XM GM XM1 XM2}
    {E: efxmap`eq XM XMP} {E: tgtmap`eq GM GMP}
    {E: efxmap`eq XM1 XM1P} {E: efxmap`eq XM2 XM2P}
    exists {R: efxmap`remove-tgtmap XMP GMP XM1P XM2P}
    true.

- : efxmap`remove-tgtmap-respects-eq
    R efxmap`eq/ tgtmap`eq/ efxmap`eq/ efxmap`eq/ R.

%worlds () (efxmap`remove-tgtmap-respects-eq _ _ _ _ _ _).
%total {} (efxmap`remove-tgtmap-respects-eq _ _ _ _ _ _).


%theorem efxmap`remove-tgtmap-unique
  : forall* {XM} {XMP} {GM} {GMP} {XM1} {XM2} {XM1P} {XM2P}
    forall {R1: efxmap`remove-tgtmap XM GM XM1 XM2}
    {R2: efxmap`remove-tgtmap XMP GMP XM1P XM2P}
    {E: efxmap`eq XM XMP} {E: tgtmap`eq GM GMP}
    exists {E: efxmap`eq XM1 XM1P} {E: efxmap`eq XM2 XM2P}
    true.

- : efxmap`remove-tgtmap-unique
    (efxmap`remove-tgtmap/ T R P1 P2)
    (efxmap`remove-tgtmap/ TP RP P1P P2P) XM-E GM2-E XM1-E XM2-E
    <- efxmap2tgtmap-unique T TP XM-E GM-E
    <- tgtmap`remove-deterministic R RP GM-E GM2-E GM1-E
    <- efxmap`project-unique P1 P1P XM-E GM1-E XM1-E
    <- efxmap`project-unique P2 P2P XM-E GM2-E XM2-E.

%worlds () (efxmap`remove-tgtmap-unique _ _ _ _ _ _).
%total (R) (efxmap`remove-tgtmap-unique R _ _ _ _ _).


%theorem efxmap`remove-tgtmap-total*
  : forall {XM} {GM} {W1: efxmap`wf XM} {W2: tgtmap`wf GM}
    exists {XM1} {XM2} {R: efxmap`remove-tgtmap XM GM XM1 XM2}
    true.

- : efxmap`remove-tgtmap-total*
    _ _ WF1 WF2  _ _ (efxmap`remove-tgtmap/ XM=>GM RM R1 R2)
    <- efxmap2tgtmap-total XM=>GM
    <- efxmap2tgtmap-preserves-wf WF1 XM=>GM WF1x
    <- tgtmap`remove-total WF1x WF2 _ RM
    <- efxmap`project-total R1
    <- efxmap`project-total R2.

%worlds () (efxmap`remove-tgtmap-total* _ _ _ _ _ _ _).
%total {} (efxmap`remove-tgtmap-total* _ _ _ _ _ _ _).

%abbrev efxmap`remove-tgtmap-total = efxmap`remove-tgtmap-total* _ _.


%theorem efxmap`remove-tgtmap-implies-leq
  : forall* {XM} {GM} {XM1} {XM2}
    forall {R: efxmap`remove-tgtmap XM GM XM1 XM2}
    exists {L1: efxmap`leq XM1 XM} {L2: efxmap`leq XM2 XM}
    true.

- : efxmap`remove-tgtmap-implies-leq
    (efxmap`remove-tgtmap/ XM2GM GM/GM2=GM1 XM+GM1=>XM1 XM+GM2=>XM2)
    XM1<=XM XM2<=XM
    <- efxmap`project-implies-leq XM+GM1=>XM1 XM1<=XM
    <- efxmap`project-implies-leq XM+GM2=>XM2 XM2<=XM.

%worlds () (efxmap`remove-tgtmap-implies-leq _ _ _).
%total {} (efxmap`remove-tgtmap-implies-leq _ _ _).


%theorem efxmap`remove-tgtmap-implies-wf
  : forall* {XM} {XM1} {XM2} {GM2}
    forall {LE: tgtmap`leq-efxmap GM2 XM}
    {R: efxmap`remove-tgtmap XM GM2 XM1 XM2}
    exists {W1: efxmap`wf XM1} {W2: efxmap`wf XM2}
    true.

- : efxmap`remove-tgtmap-implies-wf GM2<=XM
    (efxmap`remove-tgtmap/ XM=>GM GM/GM2=GM1 XM+GM1=>XM1 XM+GM2=>XM2)
    WF-XM1 WF-XM2
    <- tgtmap`remove-implies-wf GM/GM2=GM1 WF-GM WF-GM2 WF-GM1
    <- efxmap2tgtmap-preserves-wf-converse WF-GM XM=>GM WF-XM
    <- tgtmap`remove-implies-leq GM/GM2=GM1 GM1<=GM
    <- efxmap`project-preserves-wf
      WF-GM1 (tgtmap`leq-efxmap/ GM1<=GM XM=>GM) XM+GM1=>XM1 WF-XM1
    <- efxmap`project-preserves-wf WF-GM2 GM2<=XM XM+GM2=>XM2 WF-XM2.

%worlds () (efxmap`remove-tgtmap-implies-wf _ _ _ _).
%total {} (efxmap`remove-tgtmap-implies-wf _ _ _ _).


%theorem efxmap`fresh-update-preserves-remove-tgtmap-converse
  : forall* {GM} {GMP} {XM} {XM1} {XM2} {N} {S}
    forall {R: efxmap`remove-tgtmap XM GM XM1 XM2}
    {F1: tgtmap`fresh GMP N} {U1: tgtmap`update GMP N S GM}
    {F2: efxmap`fresh XM N}
    exists {R2: efxmap`remove-tgtmap XM GMP XM1 XM2}
    true.

%theorem efxmap`fresh-update-preserves-remove-tgtmap-converse/L
  : forall* {GM} {GM1} {GM2} {N} {GM2P} {S}
    forall {R: tgtmap`remove GM GM2 GM1}
    {F1: tgtmap`fresh GM N} {F2: tgtmap`fresh GM2P N}
    {U2: tgtmap`update GM2P N S GM2}
    exists {R2: tgtmap`remove GM GM2P GM1}
    true.

- : efxmap`fresh-update-preserves-remove-tgtmap-converse/L
    (tgtmap`remove/ WF-GM WF-GM2 WF-GM1 GM1<=GM GM2^GM1 GM2UGM1=GM0 GM<=GM0)
    N!<GM N!<GM2P GM2P+N=GM2
    (tgtmap`remove/ WF-GM WF-GM2P WF-GM1 GM1<=GM GM2P^GM1 GM2PUGM1=GM0P
    GM<=GM0P)
    <- tgtmap`fresh-update-implies-leq N!<GM2P GM2P+N=GM2 GM2P<=GM2
    <- tgtmap`fresh-update-preserves-wf-converse WF-GM2 N!<GM2P GM2P+N=GM2
    WF-GM2P _
    <- tgtmap`deep-disjoint-respects-geq* GM2^GM1 GM2P<=GM2 GM2P^GM1
    <- tgtmap`fresh-update-implies-unit-join N!<GM2P GM2P+N=GM2 GM2PUN=GM2
    <- tgtmap`join-commutative GM2PUN=GM2 NUGM2P=GM2
    <- tgtmap`join-associative NUGM2P=GM2 GM2UGM1=GM0 GM0P GM2PUGM1=GM0P
    NUGM0P=GM0
    <- tgtmap`join-commutative NUGM0P=GM0 GM0PUN=GM0
    <- tgtmap`fresh-respects-geq N!<GM GM1<=GM N!<GM1
    <- tgtmap`join-preserves-fresh* N!<GM2P N!<GM1 GM2PUGM1=GM0P N!<GM0P
    <- tgtmap`fresh-unit-join-implies-update N!<GM0P GM0PUN=GM0 GM0P+N=GM0
    <- tgtmap`fresh-update2-preserves-leq-converse
      GM<=GM0 N!<GM N!<GM0P GM0P+N=GM0 GM<=GM0P.

%worlds ()
(efxmap`fresh-update-preserves-remove-tgtmap-converse/L _ _ _ _ _).
%total {}
(efxmap`fresh-update-preserves-remove-tgtmap-converse/L _ _ _ _ _).

- : efxmap`fresh-update-preserves-remove-tgtmap-converse
    (efxmap`remove-tgtmap/ XM2GM GM/GM2=GM1 XM|GM1=XM1 XM|GM2=XM2)
    N!<GM2P GM2P+N+S=GM2 N!<XM
    (efxmap`remove-tgtmap/ XM2GM GM/GM2P=GM1 XM|GM1=XM1 XM|GM2P=XM2)
    <- efxmap2tgtmap-preserves-fresh XM2GM N!<XM N!<GM
    <- efxmap`fresh-update-preserves-remove-tgtmap-converse/L
      GM/GM2=GM1 N!<GM N!<GM2P GM2P+N+S=GM2 GM/GM2P=GM1
    <- efxmap`fresh-update-right-same-result
      XM|GM2=XM2 N!<XM N!<GM2P GM2P+N+S=GM2 XM|GM2P=XM2.

%worlds () (efxmap`fresh-update-preserves-remove-tgtmap-converse _ _ _ _ _).
%total {} (efxmap`fresh-update-preserves-remove-tgtmap-converse _ _ _ _ _).


%theorem efxmap`remove-tgtmap-implies-efxmap2tgtmap
  : forall* {XM} {XM1} {XM2} {GM2}
    forall {R: efxmap`remove-tgtmap XM GM2 XM1 XM2}
    {LE: tgtmap`leq-efxmap GM2 XM}
    exists {T: efxmap2tgtmap XM2 GM2}
    true.

- : efxmap`remove-tgtmap-implies-efxmap2tgtmap
    (efxmap`remove-tgtmap/ _ _ _ XM|GM2=>XM2) GM2<=XM XM2=>GM2
    <- efxmap`project-leq-implies-efxmap2tgtmap XM|GM2=>XM2 GM2<=XM XM2=>GM2.

%worlds () (efxmap`remove-tgtmap-implies-efxmap2tgtmap _ _ _).
%total {} (efxmap`remove-tgtmap-implies-efxmap2tgtmap _ _ _).


% a dummy theorem which wraps upon
% efxmap`restrict-tgtmap-implies-efxmap2tgtmap.

%theorem efxmap`remove-tgtmap-leq-implies-domain
  : forall* {XM} {XM1} {XM2} {GM2} {S}
    forall {R: efxmap`remove-tgtmap XM GM2 XM1 XM2}
    {LE: tgtmap`leq-efxmap GM2 XM} {DM: tgtmap`domain GM2 S}
    exists {DM: efxmap`domain XM2 S}
    true.

- : efxmap`remove-tgtmap-leq-implies-domain
    (efxmap`remove-tgtmap/ XM=>GM GM/GM2=GM1 XM|GM1=XM1 XM|GM2=XM2)
    GM2<=XM DM-GM2=S DM-XM2=S
    <- efxmap`project-leq-implies-efxmap2tgtmap
      XM|GM2=XM2 GM2<=XM XM2=>GM2
    <- efxmap2tgtmap-preserves-domain-converse XM2=>GM2 DM-GM2=S DM-XM2=S.

%worlds () (efxmap`remove-tgtmap-leq-implies-domain _ _ _ _).
%total {} (efxmap`remove-tgtmap-leq-implies-domain _ _ _ _).


%theorem efxmap`remove-tgtmap-left-empty
  : forall* {XM2} {GM2}
    forall {W: efxmap`wf XM2} {T: efxmap2tgtmap XM2 GM2}
    exists {R: efxmap`remove-tgtmap XM2 GM2 efxmap/0 XM2}
    true.

- : efxmap`remove-tgtmap-left-empty WF-XM2 XM2=>GM2
    (efxmap`remove-tgtmap/ XM2=>GM2 R XM2|0=0 XM2|GM2=XM2)
    <- efxmap2tgtmap-preserves-wf WF-XM2 XM2=>GM2 WF-GM2
    <- tgtmap`leq-reflexive _ GM2<=GM2
    <- tgtmap`leq-implies-remove-all WF-GM2 WF-GM2 GM2<=GM2 R
    <- efxmap`project-no-change XM2=>GM2 XM2|GM2=XM2
    <- efxmap`project-empty _ XM2|0=0.

%worlds () (efxmap`remove-tgtmap-left-empty _ _ _).
%total {} (efxmap`remove-tgtmap-left-empty _ _ _).


%theorem efxmap`remove-tgtmap-self-implies-empty
  : forall* {XM2} {GM2} {XM1} {XM3}
    forall {W: efxmap`wf XM2}
    {T: efxmap2tgtmap XM2 GM2}
    {R: efxmap`remove-tgtmap XM2 GM2 XM1 XM3}
    exists {E1: efxmap`eq XM1 efxmap/0} {E2: efxmap`eq XM3 XM2}
    true.

- : efxmap`remove-tgtmap-self-implies-empty
    WF-XM2 XM2=>GM2 XM2/GM2=XM1+XM3 XM1=0 XM3=XM2
    <- efxmap`remove-tgtmap-left-empty WF-XM2 XM2=>GM2 XM2/GM2=0+XM2
    <- efxmap`remove-tgtmap-unique
      XM2/GM2=XM1+XM3 XM2/GM2=0+XM2 efxmap`eq/ tgtmap`eq/ XM1=0 XM3=XM2.

%worlds () (efxmap`remove-tgtmap-self-implies-empty _ _ _ _ _).
%total {} (efxmap`remove-tgtmap-self-implies-empty _ _ _ _ _).


%theorem efxmap`remove-tgtmap-implies-join
  : forall* {GM2} {XM} {XM1} {XM2}
    forall {R: efxmap`remove-tgtmap XM GM2 XM1 XM2}
    exists {J: efxmap`join XM1 XM2 XM}
    true.

%worlds () (efxmap`remove-tgtmap-implies-join _ _).
%trustme %total { } (efxmap`remove-tgtmap-implies-join _ _).


%theorem efxmap`remove-tgtmap-implies-deep-disjoint
  : forall* {XM} {GM} {XM1} {XM2}
    forall {R: efxmap`remove-tgtmap XM GM XM1 XM2}
    exists {DJ: efxmap`deep-disjoint XM1 XM2}
    true.

%worlds () (efxmap`remove-tgtmap-implies-deep-disjoint _ _).
%trustme %total {} (efxmap`remove-tgtmap-implies-deep-disjoint _ _).


%theorem efxmap`remove-tgtmap-preserves-leq
  : forall* {XM} {XMP} {GM} {XM1P} {XM2P} {XM1} {XM2}
    forall {L: efxmap`leq XM XMP}
    {R1: efxmap`remove-tgtmap XM GM XM1 XM2}
    {R2: efxmap`remove-tgtmap XMP GM XM1P XM2P}
    exists {L1: efxmap`leq XM1 XM1P} {L2: efxmap`leq XM2 XM2P}
    true.

%worlds () (efxmap`remove-tgtmap-preserves-leq _ _ _ _ _).
%trustme %total { } (efxmap`remove-tgtmap-preserves-leq _ _ _ _ _).


%theorem efxmap`deep-disjoint-join-preserves-wf-converse
  : forall* {XM1} {XM2} {XM}
    forall {DJ: efxmap`deep-disjoint XM1 XM2}
    {J: efxmap`join XM1 XM2 XM} {W: efxmap`wf XM}
    exists {W1: efxmap`wf XM1} {W2: efxmap`wf XM2}
    true.

%worlds () (efxmap`deep-disjoint-join-preserves-wf-converse _ _ _ _ _).
%trustme %total {} (efxmap`deep-disjoint-join-preserves-wf-converse _ _ _ _ _).


%theorem efxmap`remove-tgtmap-leq-implies-leq
  : forall* {XM} {GM2} {XM1} {XM2P} {X} {XM2}
    forall {W1: efxmap`wf XM} {W2: tgtmap`wf GM2}
    {R: efxmap`remove-tgtmap XM GM2 XM1 XM2P}
    {T: tgtmap2efxmap GM2 X XM2} {L1: efxmap`leq XM2 XM}
    exists {L2: efxmap`leq XM2 XM2P}
    true.

- : efxmap`remove-tgtmap-leq-implies-leq
    WF-XM WF-GM2 XM/GM2=XM1+XM2P GM2=>XM2 XM2<=XM XM2<=XM2P
    <- tgtmap2efxmap-preserves-wf WF-GM2 GM2=>XM2 WF-XM2
    <- efxmap`remove-tgtmap-implies-join XM/GM2=XM1+XM2P XM1+XM2P=XM
    <- efxmap`remove-tgtmap-implies-deep-disjoint XM/GM2=XM1+XM2P XM1^XM2P
    <- tgtmap2efxmap-implies-leq-efxmap GM2=>XM2 GM2<=XM2
    <- tgtmap`leq-efxmap-right-transitive GM2<=XM2 XM2<=XM GM2<=XM
    <- efxmap`remove-tgtmap-implies-efxmap2tgtmap XM/GM2=XM1+XM2P GM2<=XM XM2P=>GM2
    <- efxmap`deep-disjoint-symmetric XM1^XM2P XM2P^XM1
    <- efxmap2tgtmap-preserves-deep-disjoint XM2P^XM1 XM2P=>GM2 GM2=>XM2 XM2^XM1
    <- efxmap`deep-disjoint-symmetric XM2^XM1 XM1^XM2
    <- efxmap`deep-disjoint-join-commutative XM1^XM2P XM1+XM2P=XM XM2P+XM1=XM
    <- efxmap`remove-tgtmap-implies-leq XM/GM2=XM1+XM2P XM1<=XM XM2P<=XM
    <- efxmap`deep-disjoint-join-preserves-wf-converse
      XM1^XM2P XM1+XM2P=XM WF-XM WF-XM1 WF-XM2P
    <- efxmap`join-deep-disjoint-right-leq-implies-leq
      WF-XM1 WF-XM2 XM2P+XM1=XM XM1^XM2 XM2<=XM XM2<=XM2P.

%worlds () (efxmap`remove-tgtmap-leq-implies-leq _ _ _ _ _ _).
%total {} (efxmap`remove-tgtmap-leq-implies-leq _ _ _ _ _ _).


%theorem efxmap`fresh-update2-preserves-remove-tgtmap
  : forall* {XM} {XM1} {XM2} {GM} {L} {S} {GMP}
    forall {R: efxmap`remove-tgtmap XM GM XM1 XM2}
    {F1: efxmap`fresh XM L}
    {F2: tgtmap`fresh GM L}
    {U2: tgtmap`update GM L S GMP}
    exists {R: efxmap`remove-tgtmap XM GMP XM1 XM2}
    true.

%worlds () (efxmap`fresh-update2-preserves-remove-tgtmap _ _ _ _ _).
%trustme %total {} (efxmap`fresh-update2-preserves-remove-tgtmap _ _ _ _ _).


%theorem efxmap2tgtmap-right-implies-remove-tgtmap
  : forall* {XM1} {XM2} {GM2} {XM}
    forall {T: efxmap2tgtmap XM2 GM2}
    {DJ: efxmap`deep-disjoint XM1 XM2}
    {J: efxmap`join XM1 XM2 XM}
    exists {R: efxmap`remove-tgtmap XM GM2 XM1 XM2}
    true.

%worlds () (efxmap2tgtmap-right-implies-remove-tgtmap _ _ _ _).
%trustme %total XM2=>GM
(efxmap2tgtmap-right-implies-remove-tgtmap XM2=>GM _ _ _).


%theorem efxmap`remove-tgtmap-associates-join*
  : forall* {XM} {XM1} {XM2} {XM3} {XM4} {GM1} {GM2} {GM}
    forall {R1: efxmap`remove-tgtmap XM GM1 XM1 XM2}
    {R2: efxmap`remove-tgtmap XM1 GM2 XM3 XM4}
    {LE1: tgtmap`leq-efxmap GM1 XM}
    {LE2: tgtmap`leq-efxmap GM2 XM1}
    {J: tgtmap`join GM1 GM2 GM}
    exists {XM5} {J: efxmap`join XM4 XM2 XM5}
    {R2: efxmap`remove-tgtmap XM GM XM3 XM5}
    true.

- : efxmap`remove-tgtmap-associates-join* XM/GM1=XM1+XM2
    XM1/GM2=XM3+XM4 GM1<=XM GM2<=XM1 GM1UGM2=GM XM5 XM4UXM2=XM5 XM/GM=XM3+XM5
    <- efxmap`remove-tgtmap-implies-deep-disjoint XM/GM1=XM1+XM2 XM1^XM2
    <- efxmap`remove-tgtmap-implies-join XM/GM1=XM1+XM2 XM1UXM2=XM
    <- efxmap`remove-tgtmap-implies-deep-disjoint XM1/GM2=XM3+XM4 XM3^XM4
    <- efxmap`remove-tgtmap-implies-join XM1/GM2=XM3+XM4 XM3UXM4=XM1
    <- efxmap`remove-tgtmap-implies-efxmap2tgtmap
      XM/GM1=XM1+XM2 GM1<=XM XM2=>GM1
    <- efxmap`remove-tgtmap-implies-efxmap2tgtmap
      XM1/GM2=XM3+XM4 GM2<=XM1 XM4=>GM2
    <- efxmap`join-associative
      XM3UXM4=XM1 XM1UXM2=XM XM5 XM4UXM2=XM5 XM3UXM5=XM
    <- efxmap`remove-tgtmap-implies-leq XM1/GM2=XM3+XM4 XM3<=XM1 _
    <- efxmap`deep-disjoint-respects-geq* XM1^XM2 XM3<=XM1 XM3^XM2
    <- efxmap`deep-disjoint-symmetric XM3^XM2 XM2^XM3
    <- efxmap`deep-disjoint-symmetric XM3^XM4 XM4^XM3
    <- efxmap`join-preserves-deep-disjoint*
      XM4^XM3 XM2^XM3 XM4UXM2=XM5 XM5^XM3
    <- efxmap`deep-disjoint-symmetric XM5^XM3 XM3^XM5
    <- tgtmap`join-commutative GM1UGM2=GM GM2UGM1=GM
    <- join-preserves-efxmap2tgtmap*
      XM4=>GM2 XM2=>GM1 XM4UXM2=XM5 GM2UGM1=GM XM5=>GM
    <- efxmap2tgtmap-right-implies-remove-tgtmap
      XM5=>GM XM3^XM5 XM3UXM5=XM XM/GM=XM3+XM5.

%worlds () (efxmap`remove-tgtmap-associates-join* _ _ _ _ _ _ _ _).
%total {} (efxmap`remove-tgtmap-associates-join* _ _ _ _ _ _ _ _).


% TODO: restriction on XM1PS

%theorem efxmap`fresh-update-preserves-remove-tgtmap-converse
  : forall* {XM} {XMS} {GM2} {GM2S}
    {XM1P} {XM2P} {N} {M} {S} {MS}
    forall {W1: efxmap`wf XM}
    {W2: tgtmap`wf GM2}
    {R1: efxmap`remove-tgtmap XM GM2 XM1P XM2P}
    {F1: efxmap`fresh XMS N}
    {U1: efxmap`update XMS N M XM}
    {F2: tgtmap`fresh GM2S N}
    {U2: tgtmap`update GM2S N S GM2}
    {R: inner-efxmap`restrict M S MS}
    exists {XM1PS} {XM2PS} {F3: efxmap`fresh XM2PS N}
    {U3: efxmap`update XM2PS N MS XM2P}
    {R2: efxmap`remove-tgtmap XMS GM2S XM1PS XM2PS}
    true.

- : efxmap`fresh-update-preserves-remove-tgtmap-converse WF-XM WF-GM2
    (efxmap`remove-tgtmap/ XM=>GM GM/GM2=GM1 XM|GM1=XM1P XM|GM2=XM2P)
    N!<XMS XMS+N+M=XM N!<GM2S GM2S+N+S=GM2 M|S=MS
    XM1PS XM2PS N!<XM2PS XM2PS+N+MS=XM2P
    (efxmap`remove-tgtmap/ XMS=>GMS GMS/GM2S=GM1S
      XMS|GM1S=XM1PS XMS|GM2S=XM2PS)
    <- fresh-update-preserves-efxmap2tgtmap-converse*
      XM=>GM N!<XMS XMS+N+M=XM GMS DM-M=SP N!<GMS GMS+N+SP=GM XMS=>GMS
    <- efxmap`fresh-update-preserves-wf-converse
      WF-XM N!<XMS XMS+N+M=XM WF-XMS SZ-M>0
    <- efxmap2tgtmap-preserves-wf WF-XMS XMS=>GMS WF-GMS
    <- tgtmap`fresh-update-preserves-wf-converse
      WF-GM2 N!<GM2S GM2S+N+S=GM2 WF-GM2S SZ-S>0
    <- tgtmap`remove-total WF-GMS WF-GM2S GM1S GMS/GM2S=GM1S
    <- efxmap`fresh-update-preserves-project-converse
      XM|GM2=XM2P N!<XMS XMS+N+M=XM N!<GM2S GM2S+N+S=GM2
       M|S=MS XM2PS N!<XM2PS XM2PS+N+MS=XM2P XMS|GM2S=XM2PS
    <- efxmap`project-total XMS|GM1S=XM1PS.

%worlds ()
(efxmap`fresh-update-preserves-remove-tgtmap-converse
  _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(efxmap`fresh-update-preserves-remove-tgtmap-converse
  _ _ _ _ _ _ _ _ _ _ _ _ _).