%theorem reftyping-ok/read
  : forall* {CM} {PM} {W} {R} {R2} {F} {Out} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-R: clsmap-result CM B R}
    {R=>O: result2output CM PM B R Out}
    {R-HELPER: readRefTyping CM R F R2}
    exists {Out'} {Out2} {Out2'}
    {Out2=>Out3: transform Out Out'}
    {TO: result2output CM PM B R2 Out2}
    {TYP: letTyping W Out' ([O] read (lit O) F) Out2'}
    {TRANS2: transform Out2' Out2}
    true.

%%% The IMPOSSIBLE case.
%theorem reftyping-ok/read/F
  : forall* {CM} {PM} {W} {F} {R2} {Out} {B}
    forall {V:void}
    exists {Out'} {Out2} {Out2'}
    {Out2=>Out3: transform Out Out'}
    {TO: result2output CM PM B R2 Out2}
    {TYP: letTyping W Out' ([O] read (lit O) F) Out2'}
    {TRANS2: transform Out2' Out2}
    true.

%worlds (objvar) (reftyping-ok/read/F _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/read/F _ _ _ _ _ _ _ _).


- : reftyping-ok/read CM-CM CM2PM
    (clsmap-result/expr (clsmap-cxt-reftype/unique _ _ _)
      (clsmap-cxt-env/ CM-B _)) _
    (readRefTyping/base _ _
      (make-tgts-and-caps/unique
        (S+F+X=>G: set+nat2set (set/+ _ _) _ set/0) _ _) _ _)
    _ _ _ K1 K2 K3 K4
    <- set`size-total SZ
    <- set+nat2set-preserves-size S+F+X=>G (set`size/+ SZ) SZx
    <- set`size-unique set`size/0 SZx set`eq/ E
    <- nat`eq-contradiction E V
    <- reftyping-ok/read/F V _ _ _ K1 K2 K3 K4.

- : reftyping-ok/read CM-CM CM2PM
    (clsmap-result/expr (clsmap-cxt-reftype/unique _ _ _) _) _
    (readRefTyping/base _ _
      (make-tgts-and-caps/unique
        (S+F+X=>G: set+nat2set set/0 _ (set/+ _ _)) _ _) _ _)
    _ _ _ K1 K2 K3 K4
    <- set`size-total SZ
    <- set+nat2set-preserves-size-converse S+F+X=>G (set`size/+ SZ) SZx
    <- set`size-unique set`size/0 SZx set`eq/ E
    <- nat`eq-contradiction E V
    <- reftyping-ok/read/F V _ _ _ K1 K2 K3 K4.

- : reftyping-ok/read CM-CM CM2PM CM-R R=>Out
    (readRefTyping/base CML FML
      (make-tgts-and-caps/shared (SP:set`split M0 (set/1 shared) M1))
      (consider-ftype/shared SP2) _)
    _ _ _ TRANS
    (result2output/expr B=>Pi1 (env2input/ U=>PiU M=>Pi) (reftype2perm/shared T2PF))
    (letTyping/exists [r]
      (letTyping/base r
        (tTrans
          (transform/trans3
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive4
                    (equiv/associate)
                    (equiv/commute)
                    (equiv/symmetric equiv/associate)
                    (equiv/combine (equiv/symmetric equiv/one) (equiv/reflexive))))
                (implies/combine (implies/reflexive)
                  (implies/combine
                    (implies/combine
                      (implies/equiv-encumbered
                        (equiv/symmetric equiv/one)
                        (equiv/reflexive))
                      (implies/reflexive))
                    (implies/reflexive)))))
            (transform/skolem)
            (transform/inside [v]
              (transform/implies
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      equiv/distribute equiv/reflexive)
                    (equiv/symmetric equiv/associate))))))
          (letTyping/exists [v]
            (letTyping/base null tRead))
          (transform/inside [v]
            (transform/implies
              (implies/trans3
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      (equiv/reflexive)
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/commute)))
                    (equiv/roll3)))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans6
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans4
                        (implies/combine
                          (implies/reflexive)
                          (implies/trans
                            (implies/scale (IMP v))
                            (implies/equiv equiv/distribute)))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans
                            (implies/equiv (equiv/symmetric equiv/distribute))
                            (implies/scale (implies/pack v)))
                          (implies/reflexive))
                        (implies/equiv equiv/commute))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans3
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/linear-modus-ponens) implies/reflexive)
                        (implies/equiv equiv/commute)))
                    (implies/combine
                      (DIS v) implies/reflexive)
                    (implies/combine
                      (implies/reflexive)
                      (implies/equiv
                        (equiv/transitive
                          (equiv/commute)
                          (EQV))))))
                (implies/equiv
                  (equiv/transitive4
                    (equiv/symmetric equiv/associate)
                    (equiv/reorder)
                    (equiv/combine equiv/reflexive equiv/reorder)
                    (equiv/symmetric equiv/identity)))))))))
    (transform/reorder)
    <- before-read/shared CM-CM CM2PM CML FML SP R=>Out
      _ _ _ _ _ T2PF B=>Pi1 U=>PiU (M1=>Pi1:capset2perm _ _ _ M1 Pi1)
      (M2=>Pi2:capset2perm _ _ _ (set/1 shared) Pi2) TRANS
    <- set`split-implies-disjoint-union SP2 _ JOIN
    <- sharedperm-can-be-duplicated* T2PF IMP
    <- can-scale-from-shared T2PF DIS
    <- set`split-implies-disjoint-union SP _ JOIN'
    <- set`union-unique JOIN' JOIN set`eq/ set`eq/ EQ
    <- set`split-implies-permission-combine-converse SP M2=>Pi2 M1=>Pi1 _ M'=>Pi EQV
    <- capset2perm-respects-eq M'=>Pi clsmap`eq/ predmap`eq/ cxt`eq/ EQ permission`eq/ M=>Pi.

% 2, the case when field type is unique

- : reftyping-ok/read CM-CM CM2PM _ R=>Out
    (readRefTyping/base CML FML
      (make-tgts-and-caps/shared SP) consider-ftype/unique _) _ _ _ TRANS
    (result2output/expr B=>Pi1 (env2input/ U=>PiU M1=>Pi1)
      (reftype2perm/unique (set`size/+ set`size/0) T2PF
        ([_] set2cond/0) M2=>Pi2))
    (letTyping/exists [r]
      (letTyping/base r
        (tTrans
          (transform/trans3
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive4
                    (equiv/associate)
                    (equiv/commute)
                    (equiv/symmetric equiv/associate)
                    (equiv/combine (equiv/symmetric equiv/one) (equiv/reflexive))))
                (implies/combine (implies/reflexive)
                  (implies/combine
                    (implies/combine
                      (implies/equiv-encumbered
                        (equiv/symmetric equiv/one)
                        (equiv/reflexive))
                      (implies/reflexive))
                    (implies/reflexive)))))
            (transform/skolem)
            (transform/inside [v]
              (transform/implies
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      equiv/distribute equiv/reflexive)
                    (equiv/symmetric equiv/associate))))))
          (letTyping/exists [v]
            (letTyping/base null tRead))
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans9
                  (implies/combine
                    (repack-fldperm v)
                    (implies/combine
                      (implies/reflexive)
                      (implies/equiv
                        (equiv/transitive
                          (equiv/symmetric equiv/associate)
                          (equiv/combine
                            (equiv/reflexive)
                            (equiv/commute))))))
                  (implies/combine
                    (implies/reflexive)
                    (implies/equiv equiv/roll2))
                  (implies/equiv equiv/associate)
                  (implies/combine
                    (implies/chain-implication)
                    (implies/reflexive))
                  (implies/equiv equiv/roll3)
                  (implies/combine
                    (implies/trans
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans4
                          (implies/empty2true)
                          (implies/nonlinear bimplies/objequal-reflexive)
                          (implies/equiv (equiv/symmetric equiv/identity))
                          (implies/cond-intro))))
                    (implies/equiv equiv/roll2))
                  (implies/equiv (equiv/symmetric equiv/associate))
                  (implies/equiv
                    (equiv/transitive5
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/combine equiv/reflexive equiv/associate)
                          (equiv/associate)))
                      (equiv/symmetric equiv/associate)
                      (equiv/reorder)
                      (equiv/combine equiv/reflexive
                        (equiv/reorder))
                      (equiv/symmetric equiv/identity)))
                  (implies/combine
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/combine (implies/equiv equiv/one)
                            (implies/equiv-encumbered (equiv/one) (equiv/reflexive))))
                        (implies/reflexive)))
                    (implies/reflexive))))
              (transform/reflexive))))))
    (transform/trans
      (transform/inside [x]
        (transform/inside [v]
          (transform/gen-exists v)))
      (transform/rem-unused))
    <- before-read/shared CM-CM CM2PM CML FML SP
      R=>Out _ _ _ _ _ T2PF B=>Pi1 U=>PiU M1=>Pi1 M2=>Pi2 TRANS.

%% 22

- : reftyping-ok/read CM-CM CM2PM
    (clsmap-result/expr (clsmap-cxt-reftype/unique _ CM-B-OS _)
      (clsmap-cxt-env/ CM-B _)) R=>O
    (readRefTyping/base CML FML
      (make-tgts-and-caps/unique S+F+X=>M2 G1=G+M2 (M-M2=M3:set`split M M2 M3))
      (consider-ftype/unique) _) _ _ _
    TRANS (result2output/expr B=>Pi1 (env2input/ U=>PiU M3=>Pi3)
            (reftype2perm/unique SZ-G1 T2PF ([_] set2cond/0) G1=>Pi4))
    (letTyping/exists [r]
      (letTyping/base r
        (tTrans
          (transform/trans3
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive4
                    (equiv/associate)
                    (equiv/commute)
                    (equiv/symmetric equiv/associate)
                    (equiv/combine (equiv/symmetric equiv/one) (equiv/reflexive))))
                (implies/combine (implies/reflexive)
                  (implies/combine
                    (implies/combine
                      (implies/equiv-encumbered
                        (equiv/symmetric equiv/one)
                        (equiv/reflexive))
                      (implies/reflexive))
                    (implies/reflexive)))))
            (transform/skolem)
            (transform/inside [v]
              (transform/implies
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      equiv/distribute equiv/reflexive)
                    (equiv/symmetric equiv/associate))))))
          (letTyping/exists [v]
            (letTyping/base null tRead))
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans4
                  (implies/equiv
                    (equiv/transitive
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/combine
                          (equiv/reflexive)
                          (equiv/commute)))
                      (equiv/roll3)))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans5
                      (implies/combine
                        (repack-fldperm v)
                        (implies/reflexive))
                      (implies/equiv equiv/roll2)
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/chain-implication)
                            (implies/reflexive))))
                      (implies/combine
                        (implies/trans3
                          (implies/equiv (equiv/symmetric equiv/identity))
                          (implies/combine
                            (implies/reflexive)
                            (implies/trans4
                              (implies/empty2true)
                              (implies/nonlinear bimplies/objequal-reflexive)
                              (implies/equiv (equiv/symmetric equiv/identity))
                              (implies/cond-intro)))
                          (implies/equiv equiv/commute))
                        (implies/reflexive))
                      (implies/equiv (equiv/symmetric equiv/associate))))
                  (implies/equiv
                    (equiv/transitive5
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/combine equiv/reflexive equiv/associate)
                          (equiv/associate)))
                      (equiv/symmetric equiv/associate)
                      (equiv/reorder)
                      (equiv/combine equiv/reflexive
                        (equiv/reorder))
                      (equiv/symmetric equiv/identity)))
                  (implies/combine
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/combine (implies/equiv equiv/one)
                            (implies/equiv-encumbered (equiv/one) (equiv/reflexive))))
                        (implies/reflexive)))
                    (implies/reflexive))))
              (transform/reflexive))))))
    (transform/trans
      (transform/inside [x]
        (transform/inside [v]
          (transform/gen-exists v)))
      (transform/rem-unused))
    <- set`split-implies-disjoint-union G1=G+M2 G^M2 G+M2=G1
    <- set`size-total SZ-G
    <- set`size-total SZ-G1P
    <- set`union-implies-leq G+M2=G1 G<=G1 M2<=G1
    <- set`leq-implies-size-le G<=G1 (set`size/+ SZ-G) SZ-G1P LE
    <- ge-succ-implies-succ LE _ E
    <- set`size-respects-eq SZ-G1P set`eq/ E SZ-G1
    <- before-read/unique/2 _ (set`size/+ SZ-G)
      CM-CM CM2PM CML FML S+F+X=>M2 G^M2 G+M2=G1 M-M2=M3
      R=>O CM-B-OS _ T2PF _ B=>Pi1 _ U=>PiU _ M3=>Pi3 _ G1=>Pi4 TRANS.

% 2s

- : reftyping-ok/read CM-CM CM2PM
    (clsmap-result/expr (clsmap-cxt-reftype/unique _ CM-B-OS _)
      (clsmap-cxt-env/ CM-B _)) R=>O
    (readRefTyping/base CML FML
      (make-tgts-and-caps/unique S+F+X=>M2 G1=G+M2
        (M-M2=M3:set`split M M2 M3))
      (consider-ftype/shared SP) (targets-capset/unique G^M)) _ _ _
    TRANS (result2output/expr B=>Pi1 (env2input/ U=>PiU M=>Pi) (reftype2perm/shared T2PF))
    (letTyping/exists [r]
      (letTyping/base r
        (tTrans
          (transform/trans3
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/associate)
                    (equiv/roll2)))
                (implies/combine
                  (implies/equiv (equiv/symmetric equiv/one))
                  (implies/combine implies/reflexive
                    (implies/combine
                      (implies/equiv-encumbered (equiv/symmetric equiv/one) equiv/reflexive)
                      (implies/reflexive))))))
            (transform/skolem)
            (transform/inside [v]
              (transform/implies
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      equiv/distribute equiv/reflexive)
                    (equiv/symmetric equiv/associate))))))
          (letTyping/exists [v]
            (letTyping/base null tRead))
          (transform/inside [v]
            (transform/implies
              (implies/trans10
                (implies/combine
                  (implies/reflexive)
                  (implies/combine
                    (implies/reflexive)
                    (implies/equiv equiv/commute)))
                (implies/combine
                  (repack-fldperm v)
                  (implies/combine
                    (implies/reflexive)
                    (implies/equiv (equiv/symmetric equiv/associate))))
                (implies/combine
                  (implies/reflexive)
                  (implies/equiv equiv/roll2))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/chain-implication)
                  (implies/reflexive))
                (implies/equiv equiv/roll2)
                (implies/combine
                  (implies/trans
                    (implies/scale (DUP v))
                    (implies/equiv equiv/distribute))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (DIS v)
                  (implies/trans5
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/equiv EQV)
                      (implies/reflexive))
                    (implies/equiv equiv/commute)))
                (implies/equiv
                  (equiv/transitive5
                    (equiv/roll2)
                    (equiv/symmetric equiv/associate)
                    (equiv/reorder)
                    (equiv/combine equiv/reflexive equiv/reorder)
                    (equiv/symmetric equiv/identity)))))))))
    (transform/reorder)
    <- set`split-implies-disjoint-union SP _ JOIN
    <- set`split-implies-disjoint-union G1=G+M2 G^M2 G+M2=G1
    <- set`size-total SZ-G
    <- before-read/unique/2 _ (set`size/+ SZ-G)
      CM-CM CM2PM CML FML S+F+X=>M2 G^M2 G+M2=G1 M-M2=M3
      R=>O CM-B-OS _ T2PF _ B=>Pi1 _ U=>PiU Pi3 M3=>Pi3 Pi4 G1=>Pi4 TRANS
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- can-scale-from-shared T2PF DIS
    <- set`split-implies-leq M-M2=M3 M2<=M M3<=M
    <- set`leq-reflexive _ G<=G
    <- set`disjoint-respects-geq G^M G<=G M3<=M G^M3
    <- set`split-implies-disjoint-union M-M2=M3 M2^M3 M2+M3=M
    <- set`union-preserves-disjoint* G^M3 M2^M3 G+M2=G1 G1^M3
    <- set`split-implies-permission-combine-converse
      (set`split/ G1^M3 JOIN) G1=>Pi4 M3=>Pi3 _ M=>Pi EQV.

% 1s

- : reftyping-ok/read CM-CM CM2PM
    (clsmap-result/expr (clsmap-cxt-reftype/unique _ CM-B-OS _)
      (clsmap-cxt-env/ CM-B CM-B-M)) R=>O
    (readRefTyping/base CML FML
      (make-tgts-and-caps/unique S+F+X=>M2 (set`split/ G^M2 set`union/L)
        (M-M2=M3:set`split M M2 M3))
      (consider-ftype/shared (set`split/ _ (M2+M3=M4:set`union M2 M3 M4))) _) _ _ _
    TRANS (result2output/expr B=>Pi1 (env2input/ U=>PiU M4=>Pi) (reftype2perm/shared T2PF))
    (letTyping/exists [r]
      (letTyping/base r
        (tTrans
          (transform/trans3
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive equiv/associate equiv/roll2))
                (implies/combine
                  (implies/equiv (equiv/symmetric equiv/one))
                  (implies/combine implies/reflexive
                    (implies/combine
                      (implies/equiv-encumbered (equiv/symmetric equiv/one) equiv/reflexive)
                      (implies/reflexive))))))
            (transform/skolem)
            (transform/inside [v]
              (transform/implies
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      equiv/distribute equiv/reflexive)
                    (equiv/symmetric equiv/associate))))))
          (letTyping/exists [v]
            (letTyping/base null tRead))
          (transform/inside [v]
            (transform/implies
              (implies/trans10
                (implies/combine
                  (implies/reflexive)
                  (implies/combine
                    (implies/reflexive)
                    (implies/equiv equiv/commute)))
                (implies/combine
                  (repack-fldperm v)
                  (implies/combine
                    (implies/reflexive)
                    (implies/equiv (equiv/symmetric equiv/associate))))
                (implies/combine
                  (implies/reflexive)
                  (implies/equiv equiv/roll2))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/chain-implication)
                  (implies/reflexive))
                (implies/equiv equiv/roll2)
                (implies/combine
                  (implies/trans
                    (implies/scale (DUP v))
                    (implies/equiv equiv/distribute))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (DIS v)
                  (implies/trans5
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/equiv EQV)
                      (implies/reflexive))
                    (implies/equiv equiv/commute)))
                (implies/equiv
                  (equiv/transitive5
                    (equiv/roll2)
                    (equiv/symmetric equiv/associate)
                    (equiv/reorder)
                    (equiv/combine equiv/reflexive equiv/reorder)
                    (equiv/symmetric equiv/identity)))))))))
    (transform/reorder)
    <- set`size-total S-SZ
    <- before-read/borrow CM-B-M CM-CM CM2PM CML FML
      S+F+X=>M2 M-M2=M3 R=>O CM-B-OS (set`size/+ S-SZ) _ T2PF _ B=>Pi1
      _ U=>PiU _ M1=>Pi3 _ M2=>Pi4 TRANS
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- can-scale-from-shared T2PF DIS
    <- set`split-implies-permission-combine-converse
      M-M2=M3 M2=>Pi4 M1=>Pi3 _ M=>Pi EQV
    <- set`split-implies-disjoint-union M-M2=M3 M2^M3 M2+M3=M
    <- set`union-unique M2+M3=M M2+M3=M4 set`eq/ set`eq/ M=M4
    <- capset2perm-respects-eq M=>Pi clsmap`eq/ predmap`eq/ cxt`eq/
      M=M4 permission`eq/ M4=>Pi.

% 12

- : reftyping-ok/read CM-CM CM2PM
    (clsmap-result/expr (clsmap-cxt-reftype/unique _ CM-B-OS _)
      (clsmap-cxt-env/ CM-B CM-B-M)) R=>O
    (readRefTyping/base CML FML
      (make-tgts-and-caps/unique S+F+X=>M2 (set`split/ G^M2 set`union/L)
        (M-M2=M3:set`split M M2 M3))
      (consider-ftype/unique) _) _ _ _
    TRANS (result2output/expr B=>Pi1 (env2input/ U=>PiU M3=>Pi3)
            (reftype2perm/unique SZ-M T2PF ([_] set2cond/0) M2=>Pi2))
    (letTyping/exists [r]
      (letTyping/base r
        (tTrans
          (transform/trans3
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive (equiv/associate) (equiv/roll2)))
                (implies/combine
                  (implies/equiv (equiv/symmetric equiv/one))
                  (implies/combine implies/reflexive
                    (implies/combine
                      (implies/equiv-encumbered (equiv/symmetric equiv/one) equiv/reflexive)
                      (implies/reflexive))))))
            (transform/skolem)
            (transform/inside [v]
              (transform/implies
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      equiv/distribute equiv/reflexive)
                    (equiv/symmetric equiv/associate))))))
          (letTyping/exists [v]
            (letTyping/base null tRead))
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans5
                  (implies/equiv
                    (equiv/combine equiv/reflexive
                      (equiv/combine equiv/reflexive equiv/commute)))
                  (implies/equiv
                    (equiv/transitive
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/combine
                          (equiv/reflexive)
                          (equiv/commute)))
                      (equiv/roll3)))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans5
                      (implies/combine
                        (repack-fldperm v)
                        (implies/reflexive))
                      (implies/equiv equiv/roll2)
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/chain-implication)
                            (implies/reflexive))))
                      (implies/combine
                        (implies/trans3
                          (implies/equiv (equiv/symmetric equiv/identity))
                          (implies/combine
                            (implies/reflexive)
                            (implies/trans4
                              (implies/empty2true)
                              (implies/nonlinear bimplies/objequal-reflexive)
                              (implies/equiv (equiv/symmetric equiv/identity))
                              (implies/cond-intro)))
                          (implies/equiv equiv/commute))
                        (implies/reflexive))
                      (implies/equiv (equiv/symmetric equiv/associate))))
                  (implies/equiv
                    (equiv/transitive5
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/combine equiv/reflexive equiv/associate)
                          (equiv/associate)))
                      (equiv/symmetric equiv/associate)
                      (equiv/reorder)
                      (equiv/combine equiv/reflexive
                        (equiv/reorder))
                      (equiv/symmetric equiv/identity)))
                  (implies/combine
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/combine (implies/equiv equiv/one)
                            (implies/equiv-encumbered (equiv/one) (equiv/reflexive))))
                        (implies/reflexive)))
                    (implies/reflexive))))
              (transform/reflexive))))))
    (transform/trans
      (transform/inside [x]
        (transform/inside [v]
          (transform/gen-exists v)))
      (transform/rem-unused))
    <- set`size-total SZ
    <- set+nat2set-preserves-size S+F+X=>M2 (set`size/+ SZ) SZ-M
    <- before-read/borrow CM-B-M CM-CM CM2PM CML FML
      S+F+X=>M2 M-M2=M3 R=>O CM-B-OS (set`size/+ SZ) _ T2PF _ B=>Pi1
      _ U=>PiU _ M3=>Pi3 _ M2=>Pi2 TRANS.

- : reftyping-ok/read CM-CM CM2PM
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique _ cxt-unique-objset/0 clsmap-cxt-capset/0)
      (clsmap-cxt-env/ CM-B CM-B-M)) R=>O
    (readRefTyping/base CML FML
      (make-tgts-and-caps/unique S+F+X=>M2 (set`split/ G^M2 _)
        (M-M2=M3:set`split M set/0 M3))
      (consider-ftype/unique) _) _ _ _
    TRANS (result2output/expr B=>Pi1 (env2input/ U=>PiU M2=>Pi2)
            (reftype2perm/fresh T2PF))
    (letTyping/exists [r]
      (letTyping/base r
        (tTrans
          (transform/trans3
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive (equiv/associate) (equiv/roll2)))
                (implies/combine
                  (implies/equiv (equiv/symmetric equiv/one))
                  (implies/combine implies/reflexive
                    (implies/combine
                      (implies/reflexive)
                      (implies/reflexive))))))
            (transform/skolem)
            (transform/inside [v]
              (transform/implies
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      equiv/distribute equiv/reflexive)
                    (equiv/symmetric equiv/associate))))))
          (letTyping/exists [v]
            (letTyping/base null tRead))
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/equiv
                  (equiv/combine
                    (equiv/reflexive)
                    (equiv/transitive3
                      (equiv/combine equiv/one
                        (equiv/transitive
                          (equiv/combine equiv/reflexive equiv/commute-identity)
                          (equiv/symmetric equiv/associate)))
                      (equiv/roll3)
                      (equiv/symmetric equiv/identity)))))
              (transform/drop))))))
    (transform/trans
      (transform/inside [x]
        (transform/inside [v]
          (transform/add-unused)))
      (transform/rem-unused))
    <- before-read/fresh CM-B-M CM-CM CM2PM CML FML
      S+F+X=>M2 M-M2=M3 R=>O set`size/0 _ T2PF _ B=>Pi1
      _ U=>PiU _ M2=>Pi2 TRANS.

- : reftyping-ok/read CM-CM CM2PM
    (clsmap-result/expr
      (clsmap-cxt-reftype/unique _ cxt-unique-objset/0 clsmap-cxt-capset/0)
      (clsmap-cxt-env/ CM-B CM-B-M)) R=>O
    (readRefTyping/base CML FML
      (make-tgts-and-caps/unique S+F+X=>M2 (set`split/ G^M2 _)
        (M-M2=M3:set`split M set/0 M3))
      (consider-ftype/shared
        (set`split/ _ (M2+M3=M4:set`union set/0 M3 M4))) _) _ _ _
    TRANS (result2output/expr B=>Pi1 (env2input/ U=>PiU M2=>Pi2')
            (reftype2perm/shared T2PF))
    (letTyping/exists [r]
      (letTyping/base r
        (tTrans
          (transform/trans3
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive (equiv/associate) (equiv/roll2)))
                (implies/combine
                  (implies/equiv (equiv/symmetric equiv/one))
                  (implies/combine implies/reflexive
                    (implies/combine
                      (implies/reflexive)
                      (implies/reflexive))))))
            (transform/skolem)
            (transform/inside [v]
              (transform/implies
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      equiv/distribute equiv/reflexive)
                    (equiv/symmetric equiv/associate))))))
          (letTyping/exists [v]
            (letTyping/base null tRead))
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/equiv
                  (equiv/combine
                    (equiv/reflexive)
                    (equiv/transitive3
                      (equiv/combine equiv/one
                        (equiv/transitive
                          (equiv/combine equiv/reflexive equiv/commute-identity)
                          (equiv/symmetric equiv/associate)))
                      (equiv/roll3)
                      (equiv/symmetric equiv/identity)))))
              (transform/drop))))))
    (transform/trans
      (transform/inside [x]
        (transform/inside [v]
          (transform/add-unused)))
      (transform/rem-unused))
    <- before-read/fresh CM-B-M CM-CM CM2PM CML FML
      S+F+X=>M2 M-M2=M3 R=>O set`size/0 _ T2PF _ B=>Pi1
      _ U=>PiU _ M2=>Pi2 TRANS
    <- set`union-unique set`union/L M2+M3=M4 set`eq/ set`eq/ M3=M4
    <- capset2perm-respects-eq M2=>Pi2 clsmap`eq/ predmap`eq/
      cxt`eq/ M3=M4 gterm#eq/ M2=>Pi2'.

%worlds (objvar) (reftyping-ok/read _ _ _ _ _ _ _ _ _ _ _ _).
%total (K) (reftyping-ok/read _ _ K _ _ _ _ _ _ _ _ _).
