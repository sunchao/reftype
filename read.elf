%%% Checking read

% %theorem effects-join-implies-shared-efx-join
%   : forall* {M1} {M2} {M} {X1} {X2} {X} {S1} {S2} {S} {Q1} {Q2} {Q}
%     forall {J: effects`join (effects/ M1 S1 X1 Q1) (effects/ M2 S2 X2 Q2)
%                (effects/ M S X Q)}
%     exists {XJ: shared-efx`join X1 X2 X}
%     true.

% - : effects-join-implies-shared-efx-join
%     (effects`join/ _ _ _ _ _ _ _ _ _ _ XJ _) XJ.

% %worlds () (effects-join-implies-shared-efx-join _ _).
% %total {} (effects-join-implies-shared-efx-join _ _).


%%% tedius transformations

%theorem reftyping-ok/read/shared
  : forall* {CM} {PM} {W} {B} {FM} {Pi} {M} {S} {SX} {SX'} {G1}
    {GSP} {NN} {A} {FC} {C} {E} {F} {Out} {M'} {S'} {Q} {Q'} {X}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {TI2: effects2input CM PM B (effects/ M S SX Q) Pi}
    {TI3: effects2output CM PM B
          (reftype/ nn/yes C targets/shared) (effects/ M S SX Q) Out}
    {TYE: typing W Pi E Out}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {MTAE: make-targets-and-effects targets/shared F X G1 (effects/ M' S' SX' Q')}
    {CF: consider-ftype G1 A GSP}
    {LE: shared-efx`leq SX' SX}
    exists {Out2} {TO: effects2output CM PM B
                       (reftype/ NN FC GSP) (effects/ M S SX Q) Out2}
    {TYP: typing W Pi (read E F) Out2}
    true.

- : reftyping-ok/read/shared CM-CM CM2PM
    (XX=>Pi1:effects2input CM PM B (effects/ M S SX Q) Pi1)
    XX=>Out TYP-E CML FML
    (make-targets-and-effects/shared CSE) consider-ftype/shared
    SX<=SX' _ (effects2output/shared T2PF SX=>Pi3 XM=>Pi4 B=>Pi1)
    (tTrans2
      (tRead1
        (tTrans2
          (TYP-E)
          (transform/trans
            (TRANS)
            (transform/inside [r]
              (transform/trans3
                (transform/implies
                  (implies/equiv
                    (equiv/transitive
                      (equiv/commute)
                      (equiv/symmetric equiv/associate))))
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          equiv/distribute equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      (equiv/reflexive)
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/commute)))
                    (equiv/roll3)))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans5
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans4
                        (implies/combine
                          (implies/reflexive)
                          (implies/trans
                            (implies/scale (IMP v))
                            (implies/equiv equiv/distribute)))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans
                            (implies/equiv (equiv/symmetric equiv/distribute))
                            (implies/scale (implies/pack v)))
                          (implies/reflexive))
                        (implies/equiv equiv/commute))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans3
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/linear-modus-ponens) implies/reflexive)
                        (implies/equiv equiv/commute)))
                    (implies/combine
                      (DIS v) implies/reflexive)))))))
        (transform/rem-unused)))
    <- create-shared-efx-not-none CSE NC-SX
    <- before-read/shared CM-CM CM2PM CML FML SX<=SX' NC-SX XX=>Out
      _ _ _ _ T2PF B=>Pi1 SX=>Pi3 _ SX2X _ X2Q XM=>Pi4 TRANS
    <- sharedperm-can-be-duplicated* T2PF IMP
    <- can-scale-from-shared T2PF DIS.

- : reftyping-ok/read/shared CM-CM CM2PM XX=>Pi1 XX=>Out TYP-E CML FML
    (make-targets-and-effects/shared CSE) consider-ftype/unique
    SX<=SX' _
    (effects2output/unique/t T2PF SX=>Pi3 X2Q MX SX2X
      efxmap-minimum-efx/0 efxmap2perm/0 XM=>Pi4 XM|0=XM+0
      ([_] set2facts/0) B=>Pi1)
    ((tTrans2
       (tRead1
         (tTrans2
           (TYP-E)
           (transform/trans
             (TRANS)
             (transform/inside [r]
               (transform/trans3
                 (transform/implies
                   (implies/equiv
                     (equiv/transitive
                       (equiv/commute)
                       (equiv/symmetric equiv/associate))))
                 (transform/skolem)
                 (transform/inside [v]
                   (transform/implies
                     (implies/equiv
                       (equiv/transitive
                         (equiv/combine
                           equiv/distribute equiv/reflexive)
                         (equiv/symmetric equiv/associate)))))))))
         (letTyping/exists [v]
           (letTyping/exists [r]
             (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans
                  (implies/equiv
                    (equiv/transitive
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/combine
                          (equiv/reflexive)
                          (equiv/commute)))
                      (equiv/roll3)))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans5
                      (implies/combine
                        (repack-fldperm v)
                        (implies/reflexive))
                      (implies/equiv equiv/roll2)
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/chain-implication)
                            (implies/reflexive))))
                      (implies/combine
                        (implies/trans3
                          (implies/equiv (equiv/symmetric equiv/identity))
                          (implies/combine
                            (implies/reflexive)
                            (gen-objequal-self v))
                          (implies/equiv
                            (equiv/commute)))
                        (implies/combine
                          (implies/equiv-encumbered
                            (equiv/reflexive)
                            (equiv/transitive
                              (equiv/symmetric equiv/identity)
                              (equiv/commute)))
                          (implies/reflexive)))
                      (implies/equiv (equiv/symmetric equiv/associate))))))
              (transform/gen-exists v))))
        (transform/rem-unused)))
    <- create-shared-efx-not-none CSE SX-NN
    <- before-read/shared
      CM-CM CM2PM CML FML SX<=SX' SX-NN XX=>Out _ _ _ _ T2PF B=>Pi1 SX=>Pi3
      _ SX2X _ X2Q XM=>Pi4 TRANS
    <- efxmap`partition-on-empty-set _ XM|0=XM+0
    <- efx/write-is-upper-bound _ MX.

%worlds () (reftyping-ok/read/shared _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/read/shared _ _ _ _ _ _ _ _ _ _ _ _ _).


% this theorem definitely can be improved!

%theorem reftyping-ok/read/unique
  : forall* {CM} {PM} {W} {B} {FM} {Pi} {M2} {SX2}
    {GSP} {NN} {A} {FC} {C} {E} {F} {Out} {M} {SX} {R} {CS} {CQ} {G1}
    forall {S} {G} {SB}
    {CM-B-M: clsmap-cxt-set CM B R} {SOC: same-class B S C}
    {CM-CM: clsmap-clsmap CM CM} {CM2PM: clsmap2predmap CM PM}
    {XX=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique S G SB))
              (effects/ M CS SX CQ) Out}
    {DM: efxmap`domain M R} {G<=M: set`leq G R}
    {TYE: typing W Pi E Out}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {MTAE: make-targets-and-effects
           (targets/unique S G SB) F efx/read G1 (effects/ M2 set/0 SX2 set/0)}
    {CF: consider-ftype G1 A GSP}
    {M2<=M: efxmap`leq M2 M}
    exists {Out2} {TO: effects2output CM PM
                       B (reftype/ NN FC GSP) (effects/ M CS SX CQ) Out2}
    {TYP: typing W Pi (read E F) Out2}
    true.

- : reftyping-ok/read/unique _ _ true
    CM-B-M SOC CM-CM CM2PM XX=>Out DM G<=M TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>G2 G1^G2 G1+G2=G G=>M _ _ ) consider-ftype/shared M2<=M _
    (effects2output/shared T2PF SX=>Pi3 M=>Pi B=>Pi1)
    (tTrans2
      (tRead1
        (tTrans2
          (TYP-E)
          (transform/trans
            (TRANS)
            (transform/inside [r]
              (transform/trans3
                (transform/implies
                  (implies/equiv
                    (equiv/transitive
                      (equiv/commute)
                      (equiv/symmetric equiv/associate))))
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          equiv/distribute equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      (equiv/reflexive)
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/commute)))
                    (equiv/roll3)))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans6
                    (implies/combine
                      (repack-fldperm v)
                      (implies/reflexive))
                    (implies/equiv equiv/roll2)
                    (implies/combine
                      (implies/trans
                        (implies/scale (DUP v))
                        (implies/equiv equiv/distribute))
                      (implies/trans
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/chain-implication)
                          (implies/reflexive))))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans3
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/linear-modus-ponens)
                          (implies/reflexive))
                        (implies/equiv
                          (equiv/transitive3
                            (equiv/commute)
                            (equiv/associate)
                            (equiv/combine
                              (EQV)
                              (equiv/reflexive))))))
                    (implies/combine
                      (DIS v) (implies/reflexive))))))))
        (transform/rem-unused)))
    <- set`size-total S-SZ
    <- set`size-total M-SZ
    <- before-read/unique/t* _ M-SZ CM-B-M CM-CM CM2PM CML FML
      DM G<=M S+F=>G2 G1^G2 G1+G2=G G=>M M2<=M
      XX=>Out SOC S-SZ _ T2PF _ B=>Pi1 _ SX=>Pi3 _ _ SG _ M1=>Pi3 _ M2=>Pi4
      _ MX-M2P _ MX-SX _ MX _ X2Q TRANS
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- can-scale-from-shared T2PF DIS
    <- efxmap`partition-implies-permission-combine-converse
      SG M1=>Pi3 M2=>Pi4 _ M=>Pi EQV.

- : reftyping-ok/read/unique _ _ true
    CM-B-M SOC CM-CM CM2PM XX=>Out DM G<=M TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>G2 G1^G2 G1+G2=G G=>M _ _) consider-ftype/unique M2<=M _
    (effects2output/unique/t
      T2PF SX=>Pi3 X2Q MX MX-SX MX-M2P M2=>Pi4 M1=>Pi3
      SG ([_] set2facts/0) B=>Pi1)
    (tTrans2
      (tRead1
        (tTrans2
          (TYP-E)
          (transform/trans
            (TRANS)
            (transform/inside [r]
              (transform/trans3
                (transform/implies
                  (implies/equiv
                    (equiv/transitive
                      (equiv/commute)
                      (equiv/symmetric equiv/associate))))
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          equiv/distribute equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans
                  (implies/equiv
                    (equiv/transitive
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/combine
                          (equiv/reflexive)
                          (equiv/commute)))
                      (equiv/roll3)))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans5
                      (implies/combine
                        (repack-fldperm v)
                        (implies/reflexive))
                      (implies/equiv equiv/roll2)
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/chain-implication)
                            (implies/reflexive))))
                      (implies/combine
                        (implies/trans3
                          (implies/equiv (equiv/symmetric equiv/identity))
                          (implies/combine
                            (implies/reflexive)
                            (gen-objequal-self v))
                          (implies/equiv equiv/commute))
                        (implies/reflexive))
                      (implies/equiv (equiv/symmetric equiv/associate))))))
              (transform/gen-exists v))))
        (transform/rem-unused)))
    <- set`size-total SZ-S
    <- set`size-total SZ-M1
    <- before-read/unique/t* _ SZ-M1 CM-B-M CM-CM CM2PM CML FML
      DM G<=M S+F=>G2 G1^G2 G1+G2=G G=>M M2<=M
      XX=>Out SOC SZ-S _ T2PF _ B=>Pi1
      _ SX=>Pi3 _ _ SG _ M1=>Pi3 _ M2=>Pi4 _ MX-M2P _ MX-SX _ MX _ X2Q TRANS.

- : reftyping-ok/read/unique _ (set/+ _ _) false
    CM-B-M SOC CM-CM CM2PM XX=>Out DM G<=M TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>G2 G1^G2 G1+G2=G G=>M _ _) consider-ftype/unique
    M2<=M _
    (effects2output/unique/+f T2PF SX=>Pi3 X2Q MX-M M2=>Pi4 M1=>Pi3 SG
      ([_] set2facts/0) B=>Pi1 SZ-MP)
    (tTrans2
      (tRead1
        (tTrans2
          (TYP-E)
          (transform/trans
            (TRANS)
            (transform/inside [r]
              (transform/trans3
                (transform/implies
                  (implies/equiv
                    (equiv/transitive
                      (equiv/commute)
                      (equiv/symmetric equiv/associate))))
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          equiv/distribute equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans
                  (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      (equiv/reflexive)
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/commute)))
                    (equiv/roll3)))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans5
                      (implies/combine
                        (repack-fldperm v)
                        (implies/reflexive))
                      (implies/equiv equiv/roll2)
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/chain-implication)
                            (implies/reflexive))))
                      (implies/combine
                        (implies/trans3
                          (implies/equiv (equiv/symmetric equiv/identity))
                          (implies/combine
                            (implies/reflexive)
                            (gen-objequal-self v))
                          (implies/equiv equiv/commute))
                        (implies/reflexive))
                      (implies/equiv (equiv/symmetric equiv/associate))))))
              (transform/gen-exists v))))
        (transform/rem-unused)))
    <- set`size-total SZ-S
    <- set`size-total SZ-M1
    <- set`join-implies-leq G1+G2=G G1<=G G2<=G
    <- set`size-total SZ-M
    <- set`leq-implies-size-le G1<=G SZ-M1 SZ-M LE
    <- ge-succ-implies-succ LE _ EQ
    <- set`size-respects-eq SZ-M set`eq/ EQ SZ-MP
    <- before-read/unique/+f _ SZ-M1 CM-B-M CM-CM CM2PM CML FML
      DM G<=M S+F=>G2 G1^G2 G1+G2=G G=>M M2<=M
      XX=>Out SOC SZ-S _ T2PF _ B=>Pi1
      _ SX=>Pi3 _ _ SG _ M1=>Pi3 _ M2=>Pi4 _ MX-M _ X2Q TRANS.

- : reftyping-ok/read/unique _ (set/+ _ _) false
    CM-B-M SOC CM-CM CM2PM
    XX=>Out DM G<=M TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>G2 G1^G2 G1+G2=G G=>M _
      (efx-on-shared/false)) (consider-ftype/shared) M2<=M
    _ (effects2output/shared T2PF SX=>Pi3 M=>Pi B=>Pi1)
    ((tTrans2
        (tRead1
          (tTrans2
            (TYP-E)
            (transform/trans
              (TRANS)
              (transform/inside [r]
                (transform/trans3
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/symmetric equiv/associate))))
                  (transform/skolem)
                  (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
          (letTyping/exists [v]
            (letTyping/exists [r]
              (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      (equiv/reflexive)
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/commute)))
                    (equiv/roll3)))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans6
                    (implies/combine
                      (repack-fldperm v)
                      (implies/reflexive))
                    (implies/equiv equiv/roll2)
                    (implies/combine
                      (implies/trans
                        (implies/scale (DUP v))
                        (implies/equiv equiv/distribute))
                      (implies/trans
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/chain-implication)
                          (implies/reflexive))))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans4
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/linear-modus-ponens)
                          (implies/reflexive))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/equiv
                            (equiv/transitive
                              (equiv/commute)
                              (EQV)))
                          (implies/reflexive))))
                    (implies/combine (DIS v) implies/reflexive)))))))
        (transform/rem-unused)))
    <- set`size-total S-SZ
    <- set`size-total M-SZ
    <- before-read/unique/+f _ M-SZ CM-B-M CM-CM CM2PM CML FML
      DM G<=M S+F=>G2 G1^G2 G1+G2=G G=>M M2<=M
      XX=>Out SOC S-SZ _ T2PF _ B=>Pi1
      _ SX=>Pi3 _ _ SG _ M1=>Pi3 _ M2=>Pi4 _ MX' _ X2Q' TRANS
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- can-scale-from-shared T2PF DIS
    <- efxmap`partition-implies-permission-combine-converse
      SG M1=>Pi3 M2=>Pi4 _ M=>Pi EQV.

%theorem reftyping-ok/read/unique/F
  : forall* {CM} {PM} {B} {NN} {FC} {GSP} {M} {SX} {W} {Pi} {E} {F} {CS} {CQ}
    forall {V:void}
    exists {Out2}
    {TO: effects2output CM PM B (reftype/ NN FC GSP) (effects/ M CS SX CQ) Out2}
    {TYP: typing W (Pi) (read E F) (Out2)}
    true.

%worlds () (reftyping-ok/read/unique/F _ _ _ _).
%total {} (reftyping-ok/read/unique/F _ _ _ _).

- : reftyping-ok/read/unique (set/+ _ _) _ _ _ _ _ _ _ _ _ _ _ _
    (make-targets-and-effects/unique
      (S+F=>G: set+nat2set _ F set/0) _ _ _ _ _) _ _ K1 K2 K3
    <- set`size-total SZ
    <- set+nat2set-preserves-size S+F=>G SZ MZ
    <- set`size-unique set`size/0 MZ set`eq/ E
    <- nat`eq-contradiction E V
    <- reftyping-ok/read/unique/F V K1 K2 K3.

- : reftyping-ok/read/unique set/0 _ _ _ _ _ _ _ _ _ _ _ _
    (make-targets-and-effects/unique
      (S+F=>G: set+nat2set set/0 _ (set/+ _ _))
      _ _ _ _ _) _ _ K1 K2 K3
    <- set`size-total SZ
    <- set+nat2set-preserves-size-converse S+F=>G SZ SZx
    <- set`size-unique set`size/0 SZx set`eq/ E
    <- nat`eq-contradiction E V
    <- reftyping-ok/read/unique/F V K1 K2 K3.

- : reftyping-ok/read/unique _ _ _ _ _ _ _ _ _ _ _ _ _
    (make-targets-and-effects/unique
      _ _ _ (T:set2efxmap set/0 _ (efxmap/+ _ _ _)) _ _) _ _ K1 K2 K3
    <- set2efxmap-preserves-size set`size/0 T MZ
    <- efxmap`size-total Z
    <- efxmap`size-unique (efxmap`size/+ Z) MZ efxmap`eq/ Ex
    <- nat`eq-symmetric Ex E
    <- nat`eq-contradiction E V
    <- reftyping-ok/read/unique/F V K1 K2 K3.

- : reftyping-ok/read/unique set/0 set/0 false
    _ _ CM-CM CM2PM XX=>Out _ _ TYP-E CML FML _ _ _ _
    (effects2output/unique/0 T2PF SX=>Pi3 M=>Pi B=>Pi1 set`size/0
      set`size/0)
    (tTrans2
      (tRead1
        (tTrans2
          (TYP-E)
          (transform/trans
            (TRANS)
            (transform/inside [r]
              (transform/trans3
                (transform/trans
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/symmetric equiv/associate))))
                  (transform/implies
                    (implies/equiv
                      (equiv/combine
                        (equiv/symmetric equiv/one)
                        (equiv/reflexive)))))
                (transform/skolem)
                (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans3
              (transform/drop)
              (transform/implies
                (implies/trans
                  (implies/equiv
                    (equiv/transitive
                      (equiv/combine
                        (equiv/one)
                        (equiv/reflexive))
                      (equiv/roll2)))
                  (implies/trans
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/equiv
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/transitive3
                          (equiv/combine
                            (equiv/reflexive)
                            (equiv/commute))
                          (equiv/commute)
                          (equiv/symmetric equiv/associate)))))))
              (transform/drop))))
          (transform/rem-unused)))
    <- before-read/unique/0 CM-CM CM2PM CML FML
      XX=>Out _ T2PF _ B=>Pi1 _ PML _ SX=>Pi3 _ M=>Pi TRANS.

- : reftyping-ok/read/unique set/0 set/0 false
    CM-B-M SOC CM-CM CM2PM XX=>Out _ _ TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>G2 _ _
      G2=>M CX SB=>SX) consider-ftype/shared M2<=M
    _ (effects2output/shared T2PF SX=>Pi3 M=>Pi B=>Pi1)
    (tTrans2
      (tRead1
        (tTrans2
          (TYP-E)
          (transform/trans
            (TRANS)
            (transform/inside [r]
              (transform/trans3
                (transform/trans
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/symmetric equiv/associate))))
                  (transform/implies
                    (implies/equiv
                      (equiv/combine
                        (equiv/symmetric equiv/one)
                        (equiv/reflexive)))))
                (transform/skolem)
                (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans
                  (implies/equiv
                    (equiv/transitive
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/combine
                          (equiv/reflexive)
                          (equiv/commute)))
                      (equiv/roll3)))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans5
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/trans5
                          (implies/equiv
                            (equiv/transitive
                              (equiv/symmetric equiv/distribute)
                              (equiv/one)))
                          (implies/combine
                            (implies/reflexive) (DUP v))
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/pack v)
                            (implies/reflexive))
                          (implies/equiv equiv/commute))
                        (implies/reflexive))
                      (implies/equiv (equiv/symmetric equiv/associate))
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/linear-modus-ponens)
                            (implies/reflexive))))
                      (implies/equiv equiv/roll2)))))
              (transform/trans
                (transform/implies (implies/equiv equiv/roll2))
                (transform/drop)))))
        (transform/rem-unused)))
    <- before-read/unique/0 CM-CM CM2PM CML FML
      XX=>Out _ T2PF _ B=>Pi1 _ PML _ SX=>Pi3 _ M=>Pi TRANS
    <- sharedperm-can-be-duplicated* T2PF DUP.

- : reftyping-ok/read/unique (set/+ _ _) set/0 false
    CM-B-M SOC CM-CM CM2PM XX=>Out DM _ TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>G2 _ _
      G2=>M CX SB=>SX) consider-ftype/shared M2<=M
    _ (effects2output/shared T2PF SX=>Pi3 M=>Pi B=>Pi1)
    ((tTrans2
        (tRead1
          (tTrans2
            (TYP-E)
            (transform/trans
              (TRANS)
              (transform/inside [r]
                (transform/trans3
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/symmetric equiv/associate))))
                  (transform/skolem)
                  (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
          (letTyping/exists [v]
            (letTyping/exists [r]
              (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      (equiv/reflexive)
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/commute)))
                    (equiv/roll3)))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans6
                    (implies/combine
                      (repack-fldperm v)
                      (implies/reflexive))
                    (implies/equiv equiv/roll2)
                    (implies/combine
                      (implies/trans
                        (implies/scale (DUP v))
                        (implies/equiv equiv/distribute))
                      (implies/trans
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/chain-implication)
                          (implies/reflexive))))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans4
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/linear-modus-ponens)
                          (implies/reflexive))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans
                            (implies/equiv equiv/commute)
                            (implies/equiv (EQV)))
                          (implies/reflexive))))
                    (implies/combine (DIS v) implies/reflexive)))))))
        (transform/rem-unused)))
    <- set`size-total S-SZ
    <- before-read/unique/0f DM CM-B-M CM-CM CM2PM CML FML
      S+F=>G2 G2=>M M2<=M XX=>Out SOC S-SZ _ T2PF _ B=>Pi1
      _ SX=>Pi3 _ _ SG _ M1=>Pi3 _ M2=>Pi4 _ MX-M' _ X2Q' TRANS
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- can-scale-from-shared T2PF DIS
    <- efxmap`partition-implies-permission-combine-converse
      SG M1=>Pi3 M2=>Pi4 _ M=>Pi EQV.

- : reftyping-ok/read/unique (set/+ _ _) set/0 false
    CM-B-M SOC CM-CM CM2PM XX=>Out DM _ TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>G2 _ _ G2=>M CX SB=>SX) consider-ftype/unique M2<=M
    _ (effects2output/unique/+f T2PF SX=>Pi3 X2Q MX-M M2=>Pi4 M1=>Pi3 SG
        ([_] set2facts/0) B=>Pi1 SZ-G)
    (tTrans2
      (tRead1
        (tTrans2
          (TYP-E)
          (transform/trans
            (TRANS)
            (transform/inside [r]
              (transform/trans3
                (transform/implies
                  (implies/equiv
                    (equiv/transitive
                      (equiv/commute)
                      (equiv/symmetric equiv/associate))))
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          equiv/distribute equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans
                  (implies/equiv
                    (equiv/transitive
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/combine
                          (equiv/reflexive)
                          (equiv/commute)))
                      (equiv/roll3)))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans5
                      (implies/combine
                        (repack-fldperm v)
                        (implies/reflexive))
                      (implies/equiv equiv/roll2)
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/equiv equiv/associate)
                          (implies/combine
                            (implies/chain-implication)
                            (implies/reflexive))))
                      (implies/combine
                        (implies/trans3
                          (implies/equiv (equiv/symmetric equiv/identity))
                          (implies/combine
                            (implies/reflexive)
                            (gen-objequal-self v))
                          (implies/equiv equiv/commute))
                        (implies/reflexive))
                      (implies/equiv (equiv/symmetric equiv/associate))))))
              (transform/gen-exists v))))
        (transform/rem-unused)))
    <- set`size-total S-SZ
    <- set+nat2set-preserves-size S+F=>G2 S-SZ SZ-G
    <- before-read/unique/0f DM CM-B-M CM-CM CM2PM CML FML
      S+F=>G2 G2=>M M2<=M XX=>Out SOC S-SZ _ T2PF _ B=>Pi1
      _ SX=>Pi3 _ _ SG _ M1=>Pi3 _ M2=>Pi4 _ MX-M _ X2Q TRANS.

%worlds () (reftyping-ok/read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/read
  : forall* {CM} {PM} {W} {B} {FM} {G1}
    {GP} {NN} {A} {FC} {C} {E} {F} {Out} {Pi} {XX} {XX'}
    forall {G} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-G: clsmap-cxt-reftype CM B (reftype/ nn/yes C G)}
    {CM-B-XX: clsmap-cxt-effects CM B XX'}
    {G-XX: targets-effects G XX'}
    {XX2I: effects2input CM PM B XX' Pi}
    {XX2O: effects2output CM PM B (reftype/ nn/yes C G) XX' Out}
    {TYPE: typing W Pi E Out}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {MG: make-targets-and-effects G F efx/read G1 XX}
    {CF: consider-ftype G1 A GP}
    {LE: effects-leq-without-consume XX XX'}
    exists {Out2} {XX2O: effects2output CM PM B (reftype/ NN FC GP) XX' Out2}
    {TYP: typing W Pi (read E F) Out2}
    true.

- : reftyping-ok/read targets/shared CM-CM CM2PM _ _
    _ XX2I XX2O TYPE CML FML MG CF (effects-leq-without-consume/ _ SX2<=SX)
    _ XX2Ox TYP
    <- reftyping-ok/read/shared
      CM-CM CM2PM XX2I XX2O TYPE CML FML MG CF SX2<=SX _ XX2Ox TYP.

- : reftyping-ok/read (targets/unique S G SB) CM-CM CM2PM
    (clsmap-cxt-reftype/unique SOC _ _ _)
    (clsmap-cxt-effects/ _ _ _ _ CM-B-M _)
    (targets-effects/unique DM G<=M _)
    XX2I XX2O TYPE CML FML MG CF (effects-leq-without-consume/ M2<=M _)
    _ XX2Ox TYP
    <- reftyping-ok/read/unique S G SB CM-B-M SOC CM-CM CM2PM XX2O
      DM G<=M TYPE CML FML MG CF M2<=M _ XX2Ox TYP.

%worlds () (reftyping-ok/read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).