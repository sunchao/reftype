%%% Theorems about efxmap-vleq

%theorem efxmap-vleq-reflexive
  : forall* {M}
    exists {M=<=M: efxmap-vleq M M}
    true.

- : efxmap-vleq-reflexive (efxmap-vleq/ DM DM M<=M)
    <- efxmap`domain-total DM
    <- efxmap`leq-reflexive _ M<=M.

%worlds () (efxmap-vleq-reflexive _).
%total { } (efxmap-vleq-reflexive _).


%theorem efxmap-vleq-implies-leq
  : forall* {M} {MP}
    forall {M=<=MP: efxmap-vleq M MP}
    exists {M<=MP: efxmap`leq M MP}
    true.

- : efxmap-vleq-implies-leq
    (efxmap-vleq/ _ _ LE) LE.

%worlds () (efxmap-vleq-implies-leq _ _).
%total { } (efxmap-vleq-implies-leq _ _).


%theorem efxmap-vleq-implies-same-domain
  : forall* {M} {MP}
    forall {M=<=MP: efxmap-vleq M MP}
    exists {M-D-MP: efxmap-same-domain M MP}
    true.

- : efxmap-vleq-implies-same-domain
    (efxmap-vleq/ DM1 DM2 _)
    (efxmap-same-domain/ DM1 DM2).

%worlds () (efxmap-vleq-implies-same-domain _ _).
%total { } (efxmap-vleq-implies-same-domain _ _).


%theorem efxmap-same-domain-implies-domain-left
  : forall* {M} {MP} {S}
    forall {M=<=MP: efxmap-same-domain M MP}
    {DM-M: efxmap`domain M S}
    exists {DM-MP: efxmap`domain MP S}
    true.

- : efxmap-same-domain-implies-domain-left
    (efxmap-same-domain/ DM-M=SP DM-MP=SP) DM-M=S DM-MP=S
    <- efxmap`domain-unique DM-M=SP DM-M=S efxmap`eq/ SP=S
    <- efxmap`domain-respects-eq DM-MP=SP efxmap`eq/ SP=S DM-MP=S.

%worlds () (efxmap-same-domain-implies-domain-left _ _ _).
%total { } (efxmap-same-domain-implies-domain-left _ _ _).


%theorem efxmap-same-domain-implies-domain-right
  : forall* {M} {MP} {S}
    forall {M=<=MP: efxmap-same-domain M MP}
    {DM-MP: efxmap`domain MP S}
    exists {DM-M: efxmap`domain M S}
    true.

- : efxmap-same-domain-implies-domain-right
    (efxmap-same-domain/ DM-M=SP DM-MP=SP) DM-MP=S DM-M=S
    <- efxmap`domain-unique DM-MP=SP DM-MP=S efxmap`eq/ SP=S
    <- efxmap`domain-respects-eq DM-M=SP efxmap`eq/ SP=S DM-M=S.

%worlds () (efxmap-same-domain-implies-domain-right _ _ _).
%total { } (efxmap-same-domain-implies-domain-right _ _ _).


%theorem efxmap-vleq-respects-disjoint
  : forall* {M1} {M1P} {M2} {M2P}
    forall {M1=<=M1P: efxmap-vleq M1 M1P}
    {M2=<=M2P: efxmap-vleq M2 M2P}
    {M1^M2: efxmap`disjoint M1 M2}
    exists {M1P^M2P: efxmap`disjoint M1P M2P}
    true.

%worlds () (efxmap-vleq-respects-disjoint _ _ _ _).
%trustme %total { } (efxmap-vleq-respects-disjoint _ _ _ _).


%%% For this lemma, we actually just need the "same-domain" condition.

%theorem efxmap-vleq-preserves-same-object
  : forall* {M} {MP} {N}
    forall {M-N: efxmap-same-object M N}
    {M<=MP: efxmap-vleq M MP}
    exists {MP-N: efxmap-same-object MP N}
    true.

%worlds () (efxmap-vleq-preserves-same-object _ _ _).
%trustme %total {} (efxmap-vleq-preserves-same-object _ _ _).


%theorem efxmap-map-fields-vleq
  : forall* {M} {MP} {MF}
    forall {M=>MF: efxmap-map-fields M MF}
    {SDM: efxmap-vleq M MP}
    exists {MFP}
    {MP=>MFP: efxmap-map-fields MP MFP}
    {SDM: efxmap-vleq MF MFP}
    true.

%worlds () (efxmap-map-fields-vleq _ _ _ _ _).
%trustme %total { } (efxmap-map-fields-vleq _ _ _ _ _).


%theorem efxmap-map-fields-vleq-converse
  : forall* {M} {MFP} {MF}
    forall {M=>MF: efxmap-map-fields M MF}
    {SDM: efxmap-vleq MF MFP}
    exists {MP}
    {MP=>MFP: efxmap-map-fields MP MFP}
    {SDM: efxmap-vleq M MP}
    true.

%worlds () (efxmap-map-fields-vleq-converse _ _ _ _ _).
%trustme %total { } (efxmap-map-fields-vleq-converse _ _ _ _ _).


%theorem efxmap-map-fields-vleq-converse*
  : forall* {M} {MFP} {MF} {MP}
    forall {M=>MF: efxmap-map-fields M MF}
    {SDM: efxmap-vleq MF MFP}
    {MP=>MFP: efxmap-map-fields MP MFP}
    exists {SDM: efxmap-vleq M MP}
    true.

%worlds () (efxmap-map-fields-vleq-converse* _ _ _ _).
%trustme %total { } (efxmap-map-fields-vleq-converse* _ _ _ _).


%theorem set+map2map-vleq
  : forall* {S} {MF} {M} {MFP}
    forall {S+MF=M: set+map2map S MF M}
    {MF<=MFP: efxmap-vleq MF MFP}
    exists {MP} {S+MFP=MP: set+map2map S MFP MP}
    {MF<=MFP: efxmap-vleq M MP}
    true.

%worlds () (set+map2map-vleq _ _ _ _ _).
%trustme %total {} (set+map2map-vleq _ _ _ _ _).


%{%

This theorem cannot be proved:
Suppose S is {a,b}, and MF is {f:R, g:W}, then M is {a.f:R, b.f:R, a.g:W, b.g:W}
Now, MP could be {a.f:R, b.f:W, a.g:W, b.g:W}, so MFP doesn't exist for this case.

%theorem set+map2map-vleq-converse
  : forall* {S} {MF} {M} {MP}
    forall {S+MF=M: set+map2map S MF M}
    {M<=MP: efxmap-vleq M MP}
    exists {MFP} {S+MFP=MP: set+map2map S MFP MP}
    {MF<=MFP: efxmap-vleq MF MFP}
    true.

%worlds () (set+map2map-vleq-converse _ _ _ _ _).
%trustme %total {} (set+map2map-vleq-converse _ _ _ _ _).

%}%


%theorem set2efxmap-vleq
  : forall* {S} {X} {XP} {M}
    forall {S+MF=M: set2efxmap S X M}
    {X<=XP: efx`leq X XP}
    exists {MP} {S+XP=MP: set2efxmap S XP MP}
    {MF<=MFP: efxmap-vleq M MP}
    true.

%worlds () (set2efxmap-vleq _ _ _ _ _).
%trustme %total {} (set2efxmap-vleq _ _ _ _ _).


%theorem set2efxmap-vleq-converse
  : forall* {S} {X} {XP} {M}
    forall {S+X=M: set2efxmap S X M}
    {X<=XP: efx`leq X XP}
    exists {MP} {S+MFP=MP: set2efxmap S XP MP}
    {MF<=MFP: efxmap-vleq M MP}
    true.

%worlds () (set2efxmap-vleq-converse _ _ _ _ _).
%trustme %total {} (set2efxmap-vleq-converse _ _ _ _ _).


%theorem set2efxmap-vleq-converse*
  : forall* {S} {X} {XP} {M} {MP}
    forall {S+X=M: set2efxmap S X M}
    {X<=XP: efx`leq X XP}
    {S+MFP=MP: set2efxmap S XP MP}
    exists {MF<=MFP: efxmap-vleq M MP}
    true.

%worlds () (set2efxmap-vleq-converse* _ _ _ _).
%trustme %total {} (set2efxmap-vleq-converse* _ _ _ _).


%theorem efxmap-disjoint-join-vleq
  : forall* {M1} {M2} {M} {M1P} {M2P}
    forall {M1^M2: efxmap`disjoint M1 M2}
    {M1+M2=M: efxmap`join M1 M2 M}
    {M1<=M1P: efxmap-vleq M1 M1P}
    {M2<=M2P: efxmap-vleq M2 M2P}
    exists {MP}
    {M1P^M2P: efxmap`disjoint M1P M2P}
    {M1P+M2P=MP: efxmap`join M1P M2P MP}
    {M<=MP: efxmap-vleq M MP}
    true.

%worlds () (efxmap-disjoint-join-vleq _ _ _ _ _ _ _ _).
%trustme %total {} (efxmap-disjoint-join-vleq _ _ _ _ _ _ _ _).


%theorem efxmap-disjoint-join-vleq-converse
  : forall* {M1} {M2} {M} {MP}
    forall {M1^M2: efxmap`disjoint M1 M2}
    {M1+M2=M: efxmap`join M1 M2 M}
    {M<=MP: efxmap-vleq M MP}
    exists {M1P} {M2P}
    {M1P^M2P: efxmap`disjoint M1P M2P}
    {M1P+M2P=MP: efxmap`join M1P M2P MP}
    {M1<=M1P: efxmap-vleq M1 M1P}
    {M2<=M2P: efxmap-vleq M2 M2P}
    true.

%worlds () (efxmap-disjoint-join-vleq-converse _ _ _ _ _ _ _ _ _).
%trustme %total {} (efxmap-disjoint-join-vleq-converse _ _ _ _ _ _ _ _ _).


%theorem efxmap-partition-on-index-vleq
  : forall* {M} {N} {MP} {Mout} {Min}
    forall {M|N=Mout+Min: efxmap-partition-on-index M N Mout Min}
    {M=<=MP: efxmap-vleq M MP}
    exists {MoutP} {MinP}
    {MP|N=MoutP+MinP: efxmap-partition-on-index MP N MoutP MinP}
    {Mout=<=MoutP: efxmap-vleq Mout MoutP}
    {Min=<=MinP: efxmap-vleq Min MinP}
    true.

%worlds () (efxmap-partition-on-index-vleq _ _ _ _ _ _ _).
%trustme %total {} (efxmap-partition-on-index-vleq _ _ _ _ _ _ _).


%theorem efxmap-partition-on-index-vleq-converse
  : forall* {N} {M} {Mout} {MoutP} {Min} {MinP}
    forall {M|N=Mout+Min: efxmap-partition-on-index M N Mout Min}
    {Mout=<=MoutP: efxmap-vleq Mout MoutP}
    {Min=<=MinP: efxmap-vleq Min MinP}
    exists {MP}
    {MP|N=MoutP+MinP: efxmap-partition-on-index MP N MoutP MinP}
    {M=<=MP: efxmap-vleq M MP}
    true.

%worlds () (efxmap-partition-on-index-vleq-converse _ _ _ _ _ _).
%trustme %total {} (efxmap-partition-on-index-vleq-converse _ _ _ _ _ _).


%theorem join-preserves-efxmap-vleq
  : forall* {M1} {M2} {MP1} {MP2} {M}
    forall {M1+M2=M: efxmap`join M1 M2 M}
    {M1=<=MP1: efxmap-vleq M1 MP1}
    {M2=<=MP2: efxmap-vleq M2 MP2}
    exists {MP} {MP1+MP2=MP: efxmap`join MP1 MP2 MP}
    {M=<=MP: efxmap-vleq M MP}
    true.

%worlds () (join-preserves-efxmap-vleq _ _ _ _ _ _).
%trustme %total {} (join-preserves-efxmap-vleq _ _ _ _ _ _).


%theorem efxmap-vleq-preserves-disjoint-left
  : forall* {M1} {M1P} {M2}
    forall {M1^M2: efxmap`disjoint M1 M2}
    {M1=<=M1P: efxmap-vleq M1 M1P}
    exists {M1P^M2: efxmap`disjoint M1P M2}
    true.

- : efxmap-vleq-preserves-disjoint-left M1^M2
    (efxmap-vleq/ DM-M1=S DM-M1P=S M1<=M1P) M1P^M2
    <- efxmap`domain-total DM-M2=S2
    <- efxmap`domain-preserves-disjoint M1^M2 DM-M1=S DM-M2=S2 S^S2
    <- efxmap`domain-preserves-disjoint-converse S^S2 DM-M1P=S DM-M2=S2 M1P^M2.

%worlds () (efxmap-vleq-preserves-disjoint-left _ _ _).
%total { } (efxmap-vleq-preserves-disjoint-left _ _ _).
