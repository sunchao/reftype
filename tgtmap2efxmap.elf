%%% Transform a tgtmap to a efxmap
%%% I could use "alltrans" from library/map-trans.elf
%%% However, what I need here is much simpler.


%%% Definitions

set+nat2tgtmap : set -> nat -> tgtmap -> type.

set+nat2tgtmap/0 : set+nat2tgtmap set/0 _ tgtmap/0.

set+nat2tgtmap/+
  : set+nat2tgtmap (set/+ N S) F (tgtmap/+ N (set/1 F) GM)
    <- set+nat2tgtmap S F GM.


set2inner-efxmap : set -> efx -> inner-efxmap -> type.

set2inner-efxmap/0 : set2inner-efxmap set/0 _ inner-efxmap/0.

set2inner-efxmap/+
  : set2inner-efxmap S X M
    -> set2inner-efxmap (set/+ N S) X (inner-efxmap/+ N X M).


tgtmap2efxmap : tgtmap -> efx -> efxmap -> type.

tgtmap2efxmap/0 : tgtmap2efxmap tgtmap/0 _ efxmap/0.

tgtmap2efxmap/+
  : set2inner-efxmap S X M
    -> tgtmap2efxmap GM X XM
    -> tgtmap2efxmap (tgtmap/+ N S GM) X (efxmap/+ N M XM).



%%% Theorems


%%% set+nat2tgtmap

%theorem set+nat2tgtmap-implies-wf
  : forall* {S} {F} {GM}
    forall {S=>GM: set+nat2tgtmap S F GM}
    exists {W: tgtmap`wf GM}
    true.

- : set+nat2tgtmap-implies-wf set+nat2tgtmap/0 tgtmap`wf/0.

- : set+nat2tgtmap-implies-wf (set+nat2tgtmap/+ S+F=>GM)
    (tgtmap`wf/+ (set`size/+ set`size/0) WF-GM)
    <- set+nat2tgtmap-implies-wf S+F=>GM WF-GM.

%worlds () (set+nat2tgtmap-implies-wf _ _).
%total (T) (set+nat2tgtmap-implies-wf T _).


%theorem shift-preserves-set+nat2tgtmap
  : forall* {S} {SP} {N} {F} {GM}
    forall {S=>GM: set+nat2tgtmap S F GM}
    {SH: set`shift N S SP}
    exists {GMP} {SH: tgtmap`shift N GM GMP}
    {SP=>GMP: set+nat2tgtmap SP F GMP}
    true.

- : shift-preserves-set+nat2tgtmap set+nat2tgtmap/0
    set`shift/0 tgtmap/0 tgtmap`shift/0 set+nat2tgtmap/0.

- : shift-preserves-set+nat2tgtmap
    (set+nat2tgtmap/+ S+F=>GM) (set`shift/+ P) _ (tgtmap`shift/+ P)
    (set+nat2tgtmap/+ S+F=>GM).

%worlds () (shift-preserves-set+nat2tgtmap _ _ _ _ _).
%total {} (shift-preserves-set+nat2tgtmap _ _ _ _ _).


%theorem false-implies-set2inner-efxmap
  : forall* {S} {X} {M}
    forall {V:void}
    exists {S=>M: set2inner-efxmap S X M}
    true.

%worlds () (false-implies-set2inner-efxmap _ _).
%total {} (false-implies-set2inner-efxmap _ _).


%theorem set2inner-efxmap-total*
  : forall {X} {S}
    exists {M} {S=>M: set2inner-efxmap S X M}
    true.

- : set2inner-efxmap-total* _ set/0 inner-efxmap/0 set2inner-efxmap/0.

- : set2inner-efxmap-total* X (set/+ F S) (inner-efxmap/+ F X M)
    (set2inner-efxmap/+ S+X=>M)
    <- set2inner-efxmap-total* X S M S+X=>M.

%worlds () (set2inner-efxmap-total* _ _ _ _).
%total (S) (set2inner-efxmap-total* _ S _ _).

%abbrev set2inner-efxmap-total = set2inner-efxmap-total* _ _ _.


%theorem set2inner-efxmap-respects-eq
  : forall* {S1} {S2} {X1} {X2} {M1} {M2}
    forall {S1=>M1: set2inner-efxmap S1 X1 M1}
    {SE: set`eq S1 S2} {XE: efx`eq X1 X2} {ME: inner-efxmap`eq M1 M2}
    exists {S2=>M2: set2inner-efxmap S2 X2 M2}
    true.

- : set2inner-efxmap-respects-eq
    set2inner-efxmap/0 _ _ _ set2inner-efxmap/0.

- : set2inner-efxmap-respects-eq

    (set2inner-efxmap/+ S=>M) SE XE ME (set2inner-efxmap/+ S=>Mx)
    <- set`map/+-preserves-eq-converse SE NE unit`eq/ SEx
    <- inner-efxmap`map/+-preserves-eq-converse ME _ _ MEx
    <- set2inner-efxmap-respects-eq S=>M SEx XE MEx S=>Mx.

%worlds () (set2inner-efxmap-respects-eq _ _ _ _ _).
%total (T) (set2inner-efxmap-respects-eq T _ _ _ _).


%theorem shift-preserves-set2inner-efxmap*
  : forall* {X} {N} {S} {SP} {M} {MP}
    forall {S=>M: set2inner-efxmap S X M}
    {SH: set`shift N S SP} {SH: inner-efxmap`shift N M MP}
    exists {SP=>MP: set2inner-efxmap SP X MP}
    true.

- : shift-preserves-set2inner-efxmap*
    set2inner-efxmap/0 _ _ set2inner-efxmap/0.

- : shift-preserves-set2inner-efxmap*
    (set2inner-efxmap/+ S=>M) _ _ (set2inner-efxmap/+ S=>M).

%worlds () (shift-preserves-set2inner-efxmap* _ _ _ _).
%total {} (shift-preserves-set2inner-efxmap* _ _ _ _).


%theorem set2inner-efxmap-preserves-size
  : forall* {S} {N} {X} {M}
    forall {SZ: set`size S N} {S=>M: set2inner-efxmap S X M}
    exists {SZ: inner-efxmap`size M N}
    true.

- : set2inner-efxmap-preserves-size
    set`size/0 set2inner-efxmap/0 inner-efxmap`size/0.

- : set2inner-efxmap-preserves-size
    (set`size/+ S-SZ) (set2inner-efxmap/+ S=>M)
    (inner-efxmap`size/+ M-SZ)
    <- set2inner-efxmap-preserves-size S-SZ S=>M M-SZ.

%worlds () (set2inner-efxmap-preserves-size _ _ _).
%total (T) (set2inner-efxmap-preserves-size _ T _).


%theorem set2inner-efxmap-implies-domain
  : forall* {S} {X} {M}
    forall {S=>M: set2inner-efxmap S X M}
    exists {DM: inner-efxmap`domain M S}
    true.

- :  set2inner-efxmap-implies-domain 
    set2inner-efxmap/0 inner-efxmap`domain/0.

- : set2inner-efxmap-implies-domain 
    (set2inner-efxmap/+ S+X=>M) (inner-efxmap`domain/+ DM-M=S)
    <- set2inner-efxmap-implies-domain S+X=>M DM-M=S.

%worlds () (set2inner-efxmap-implies-domain _ _).
%total (A) (set2inner-efxmap-implies-domain A _).


%theorem set2inner-efxmap-preserves-disjoint-join
  : forall* {S} {S1} {S2} {X} {M} 
    forall {S=>M: set2inner-efxmap S X M}
    {DJ: set`disjoint S1 S2} {U: set`union S1 S2 S}
    exists {M1} {M2} {S1=>M1: set2inner-efxmap S1 X M1}
    {S2=>M2: set2inner-efxmap S2 X M2}
    {DJ: inner-efxmap`disjoint M1 M2} {J: inner-efxmap`join M1 M2 M}
    true.

- : set2inner-efxmap-preserves-disjoint-join S2M
    set`disjoint/L set`union/L _ _ set2inner-efxmap/0 S2M 
    inner-efxmap`disjoint/L inner-efxmap`join/L.

- : set2inner-efxmap-preserves-disjoint-join S2M
    set`disjoint/L set`union/R _ _ set2inner-efxmap/0 S2M 
    inner-efxmap`disjoint/L inner-efxmap`join/R.


- : set2inner-efxmap-preserves-disjoint-join S2M
    set`disjoint/R set`union/L _ _ S2M set2inner-efxmap/0 
    inner-efxmap`disjoint/R inner-efxmap`join/L.

- : set2inner-efxmap-preserves-disjoint-join S2M
    set`disjoint/R set`union/R _ _ S2M set2inner-efxmap/0 
    inner-efxmap`disjoint/R inner-efxmap`join/R.

- : set2inner-efxmap-preserves-disjoint-join (set2inner-efxmap/+ SS)
    (set`disjoint/> D1P P1) (set`union/> U1 P2) _ _
    S1=>M1' (set2inner-efxmap/+ S2=>M2) D3 J2
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- set/+-preserves-eq EQ set`eq/ SEQ
    <- set`disjoint-respects-eq D1P SEQ set`eq/ D1K
    <- set2inner-efxmap-preserves-disjoint-join
      SS D1K U1 V _ S1=>M1 S2=>M2 M1^M2 M1UM2=M
    <- nat`plus-swap-succ P2 P2P
    <- nat`plus-commutative P2P P2S
    <- inner-efxmap`shift-total SH
    <- shift-preserves-set2inner-efxmap*
      S1=>M1 (set`shift/+ P2S) SH S1=>M1'
    <- inner-efxmap`shift-left-preserves-disjoint M1^M2 SH D3
    <- inner-efxmap`shift-left-preserves-join M1UM2=M SH J2.

- : set2inner-efxmap-preserves-disjoint-join (set2inner-efxmap/+ SS)
    (set`disjoint/< D1P P1) (set`union/< U1 P2) _ _
    (set2inner-efxmap/+ S1=>M1) S2=>M2' D3 J2
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- set/+-preserves-eq EQ set`eq/ SEQ
    <- set`disjoint-respects-eq D1P set`eq/ SEQ D1
    <- set2inner-efxmap-preserves-disjoint-join
      SS D1 U1 _ _ S1=>M1 S2=>M2 M1^M2 M1UM2=M
    <- nat`plus-swap-succ P2 P2P
    <- nat`plus-commutative P2P P2S
    <- inner-efxmap`shift-total SH
    <- shift-preserves-set2inner-efxmap*
      S2=>M2 (set`shift/+ P2S) SH S2=>M2'
    <- inner-efxmap`shift-right-preserves-disjoint M1^M2 SH D3
    <- inner-efxmap`shift-right-preserves-join M1UM2=M SH J2.

% impossible cases

%theorem set2inner-efxmap-preserves-disjoint-join/L
  : forall* {S1} {S2} {X} {M} 
    forall {V:void} 
    exists {M1} {M2} {S1=>M1: set2inner-efxmap S1 X M1}
    {S2=>M2: set2inner-efxmap S2 X M2}
    {DJ: inner-efxmap`disjoint M1 M2} {J: inner-efxmap`join M1 M2 M}
    true.

%worlds () (set2inner-efxmap-preserves-disjoint-join/L _ _ _ _ _ _ _).
%total {} (set2inner-efxmap-preserves-disjoint-join/L _ _ _ _ _ _ _).

- : set2inner-efxmap-preserves-disjoint-join _
    (set`disjoint/> _ P) (set`union/= _ nat`eq/) 
    _ _ S1=>M1 S2=>M2 M1^M2 M1UM2=M
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT V
    <- set2inner-efxmap-preserves-disjoint-join/L 
      V _ _ S1=>M1 S2=>M2 M1^M2 M1UM2=M.

- : set2inner-efxmap-preserves-disjoint-join _
    (set`disjoint/< _ P) (set`union/= _ nat`eq/) 
    _ _ S1=>M1 S2=>M2 M1^M2 M1UM2=M
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT V
    <- set2inner-efxmap-preserves-disjoint-join/L 
      V _ _ S1=>M1 S2=>M2 M1^M2 M1UM2=M.

- : set2inner-efxmap-preserves-disjoint-join _
    (set`disjoint/< _ P1) (set`union/> _ P2) 
    _ _ S1=>M1 S2=>M2 M1^M2 M1UM2=M
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 V
    <- set2inner-efxmap-preserves-disjoint-join/L 
      V _ _ S1=>M1 S2=>M2 M1^M2 M1UM2=M.

- : set2inner-efxmap-preserves-disjoint-join _
    (set`disjoint/> _ P1) (set`union/< _ P2) 
    _ _ S1=>M1 S2=>M2 M1^M2 M1UM2=M
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 V
    <- set2inner-efxmap-preserves-disjoint-join/L 
      V _ _ S1=>M1 S2=>M2 M1^M2 M1UM2=M.

%worlds () (set2inner-efxmap-preserves-disjoint-join _ _ _ _ _ _ _ _ _).
%total (D) (set2inner-efxmap-preserves-disjoint-join _ D _ _ _ _ _ _ _).



%%% tgtmap2efxmap

%theorem false-implies-tgtmap2efxmap
  : forall* {GM} {X} 
    forall {V:void} 
    exists {XM} {GM+X=>XM: tgtmap2efxmap GM X XM}
    true.

%worlds () (false-implies-tgtmap2efxmap V XM T).
%total {} (false-implies-tgtmap2efxmap V XM T).


%theorem tgtmap2efxmap-respects-eq
  : forall* {GM} {GMP} {XM} {XMP} {X} {XP} 
    forall {GM+X=>XM: tgtmap2efxmap GM X XM}
    {E: tgtmap`eq GM GMP} {E: efx`eq X XP} {E: efxmap`eq XM XMP}
    exists {GMP+XP=>XMP: tgtmap2efxmap GMP XP XMP}
    true.

- : tgtmap2efxmap-respects-eq T tgtmap`eq/ efx`eq/ efxmap`eq/ T.

%worlds () (tgtmap2efxmap-respects-eq _ _ _ _ _).
%total {} (tgtmap2efxmap-respects-eq _ _ _ _ _).


%theorem tgtmap2efxmap-total*
  : forall {GM} {X} 
    exists {XM} {GM+X=>XM: tgtmap2efxmap GM X XM}
    true.

- : tgtmap2efxmap-total* tgtmap/0 _ efxmap/0 tgtmap2efxmap/0.

- : tgtmap2efxmap-total* (tgtmap/+ N S GM) X (efxmap/+ N M XM) 
    (tgtmap2efxmap/+ S=>M GM=>XM)
    <- tgtmap2efxmap-total* GM X XM GM=>XM
    <- set2inner-efxmap-total S=>M.

%worlds () (tgtmap2efxmap-total* _ _ _ _).
%total (GM) (tgtmap2efxmap-total* GM _ _ _).


%theorem shift-preserves-tgtmap2efxmap 
  : forall* {GM} {GMP} {XM} {XMP} {X} {L}
    forall {GM+X=>XM: tgtmap2efxmap GM X XM}
    {SH: tgtmap`shift L GM GMP} {SH: efxmap`shift L XM XMP}
    exists {GMP+X=>XMP: tgtmap2efxmap GMP X XMP}
    true.

- : shift-preserves-tgtmap2efxmap tgtmap2efxmap/0 _ _ tgtmap2efxmap/0.

- : shift-preserves-tgtmap2efxmap
    (tgtmap2efxmap/+ GM=>XM S=>M) _ _ (tgtmap2efxmap/+ GM=>XM S=>M).

%worlds () (shift-preserves-tgtmap2efxmap _ _ _ _).
%total {} (shift-preserves-tgtmap2efxmap _ _ _ _).


%theorem shift-preserves-tgtmap2efxmap-converse
  : forall* {X} {N} {XM} {XMP} {GM} {GMP}
    forall {GMP+X=>XMP: tgtmap2efxmap GMP X XMP}
    {SH: tgtmap`shift N GM GMP} {SH: efxmap`shift N XM XMP}
    exists {GM+X=>XM: tgtmap2efxmap GM X XM}
    true.

- : shift-preserves-tgtmap2efxmap-converse 
     tgtmap2efxmap/0 _ _ tgtmap2efxmap/0.

- : shift-preserves-tgtmap2efxmap-converse
    (tgtmap2efxmap/+ GM=>XM S=>M) (tgtmap`shift/+ P1) (efxmap`shift/+ P2) G
    <- nat`plus-left-cancels P1 P2 nat`eq/ nat`eq/ EQ
    <- nat`eq-symmetric EQ EQ1
    <- tgtmap`map/+-preserves-eq EQ1 set`eq/ tgtmap`eq/ EQP
    <- tgtmap2efxmap-respects-eq
      (tgtmap2efxmap/+ GM=>XM S=>M) EQP efx`eq/ efxmap`eq/ G.

%worlds () (shift-preserves-tgtmap2efxmap-converse _ _ _ _).
%total {} (shift-preserves-tgtmap2efxmap-converse _ _ _ _).


%theorem tgtmap2efxmap-preserves-wf
  : forall* {GM} {X} {XM} 
    forall {W: tgtmap`wf GM}
    {GM+X=>XM: tgtmap2efxmap GM X XM}
    exists {W: efxmap`wf XM}
    true.

- : tgtmap2efxmap-preserves-wf 
    tgtmap`wf/0 tgtmap2efxmap/0 efxmap`wf/0.

- : tgtmap2efxmap-preserves-wf 
    (tgtmap`wf/+ S-SZ WF-GM) 
    (tgtmap2efxmap/+ S=>M GM=>XM)
    (efxmap`wf/+ M-SZ WF-XM)
    <- set2inner-efxmap-preserves-size S-SZ S=>M M-SZ
    <- tgtmap2efxmap-preserves-wf WF-GM GM=>XM WF-XM.

%worlds () (tgtmap2efxmap-preserves-wf _ _ _).
%total (T) (tgtmap2efxmap-preserves-wf _ T _).


%theorem tgtmap2efxmap-preserves-domain
  : forall* {GM} {X} {S} {XM} 
    forall {GM+X=>XM: tgtmap2efxmap GM X XM}
    {DM-GM=S: tgtmap`domain GM S}
    exists {DM-XM=S: efxmap`domain XM S}
    true.

- : tgtmap2efxmap-preserves-domain 
    tgtmap2efxmap/0 tgtmap`domain/0 efxmap`domain/0.

- : tgtmap2efxmap-preserves-domain 
    (tgtmap2efxmap/+ S=>M GM=>XM) (tgtmap`domain/+ DM-GM)
    (efxmap`domain/+ DM-XM)
    <- tgtmap2efxmap-preserves-domain GM=>XM DM-GM DM-XM.

%worlds () (tgtmap2efxmap-preserves-domain _ _ _).
%total (T) (tgtmap2efxmap-preserves-domain T _ _).


%theorem tgtmap2efxmap-preserves-domain-converse
  : forall* {GM} {XM} {S} {X} 
    forall {GM+X=>XM: tgtmap2efxmap GM X XM}
    {DM-XM=S: efxmap`domain XM S}
    exists {DM-GM=S: tgtmap`domain GM S}
    true.

- : tgtmap2efxmap-preserves-domain-converse
    tgtmap2efxmap/0 efxmap`domain/0 tgtmap`domain/0.

- : tgtmap2efxmap-preserves-domain-converse 
    (tgtmap2efxmap/+ S=>M GM=>XM) (efxmap`domain/+ DM-XM)
    (tgtmap`domain/+ DM-GM)
    <- tgtmap2efxmap-preserves-domain-converse GM=>XM DM-XM DM-GM.

%worlds () (tgtmap2efxmap-preserves-domain-converse _ _ _).
%total (T) (tgtmap2efxmap-preserves-domain-converse T _ _).


%theorem tgtmap2efxmap-preserves-fresh
  : forall* {GM} {XM} {N} {X}
    forall {GM+X=>XM: tgtmap2efxmap GM X XM} {F: tgtmap`fresh GM N}
    exists {F: efxmap`fresh XM N}
    true.

- : tgtmap2efxmap-preserves-fresh GM=>XM FS FSP
    <- tgtmap`domain-total DM-GM=S
    <- tgtmap2efxmap-preserves-domain GM=>XM DM-GM=S DM-XM=S
    <- tgtmap`domain-preserves-fresh FS DM-GM=S FSS
    <- efxmap`domain-preserves-fresh-converse FSS DM-XM=S FSP.

%worlds () (tgtmap2efxmap-preserves-fresh _ _ _).
%total {} (tgtmap2efxmap-preserves-fresh _ _ _).


%theorem tgtmap2efxmap-preserves-disjoint 
  : forall* {GM1} {GM2} {X} {XM1} {XM2} 
    forall {GM1^GM2: tgtmap`disjoint GM1 GM2}
    {GM1+X=>XM1: tgtmap2efxmap GM1 X XM1}
    {GM2+X=>XM2: tgtmap2efxmap GM2 X XM2}
    exists {XM1^XM2: efxmap`disjoint XM1 XM2}
    true.

- : tgtmap2efxmap-preserves-disjoint GM1^GM2 GM1=>XM1 GM2=>XM2 XM1^XM2
    <- tgtmap`domain-total DM-GM1=S1
    <- tgtmap`domain-total DM-GM2=S2
    <- tgtmap2efxmap-preserves-domain GM1=>XM1 DM-GM1=S1 DM-XM1=S1
    <- tgtmap2efxmap-preserves-domain GM2=>XM2 DM-GM2=S2 DM-XM2=S2
    <- tgtmap`domain-preserves-disjoint GM1^GM2 DM-GM1=S1 DM-GM2=S2 S1^S2
    <- efxmap`domain-preserves-disjoint-converse
      S1^S2 DM-XM1=S1 DM-XM2=S2 XM1^XM2.

%worlds () (tgtmap2efxmap-preserves-disjoint _ _ _ _).
%total {} (tgtmap2efxmap-preserves-disjoint _ _ _ _).


%theorem tgtmap2efxmap-preserves-disjoint-join
  : forall* {GM1} {GM2} {GM} {X} {XM}
    forall {GM+X=>XM: tgtmap2efxmap GM X XM}
    {GM1^GM2: tgtmap`disjoint GM1 GM2}
    {GM1+GM2=GM: tgtmap`join GM1 GM2 GM}
    exists {XM1} {XM2}
    {GM1+X=>XM1: tgtmap2efxmap GM1 X XM1}
    {GM2+X=>XM2: tgtmap2efxmap GM2 X XM2}
    {XM1^XM2: efxmap`disjoint XM1 XM2}
    {XM1+XM2=XM: efxmap`join XM1 XM2 XM}
    true.

- : tgtmap2efxmap-preserves-disjoint-join
    GM=>XM tgtmap`disjoint/L tgtmap`join/L _ _ tgtmap2efxmap/0 GM=>XM 
    efxmap`disjoint/L efxmap`join/L.

- : tgtmap2efxmap-preserves-disjoint-join
    GM=>XM tgtmap`disjoint/L tgtmap`join/R _ _ tgtmap2efxmap/0 GM=>XM 
    efxmap`disjoint/L efxmap`join/R.

- : tgtmap2efxmap-preserves-disjoint-join
    GM=>XM tgtmap`disjoint/R tgtmap`join/L _ _ GM=>XM tgtmap2efxmap/0 
    efxmap`disjoint/R efxmap`join/L.

- : tgtmap2efxmap-preserves-disjoint-join
    GM=>XM tgtmap`disjoint/R tgtmap`join/R _ _ GM=>XM tgtmap2efxmap/0 
    efxmap`disjoint/R efxmap`join/R.

- : tgtmap2efxmap-preserves-disjoint-join
    (tgtmap2efxmap/+ S=>M GM=>XM)
    (tgtmap`disjoint/> D1P P1) (tgtmap`join/> J1 P2) _ _
    GM1=>XM1x (tgtmap2efxmap/+ S=>M GM2=>XM2) D3 J2
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- tgtmap`map/+-preserves-eq EQ set`eq/ tgtmap`eq/ MEQ
    <- tgtmap`disjoint-respects-eq D1P MEQ tgtmap`eq/ D1
    <- tgtmap2efxmap-preserves-disjoint-join
      GM=>XM D1 J1 V _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-swap-succ P2 P2P
    <- nat`plus-commutative P2P P2S
    <- efxmap`shift-total SH
    <- shift-preserves-tgtmap2efxmap 
      GM1=>XM1 (tgtmap`shift/+ P2S) SH GM1=>XM1x
    <- efxmap`shift-left-preserves-disjoint XM1^XM2 SH D3
    <- efxmap`shift-left-preserves-join XM1UXM2=XM SH J2.

- : tgtmap2efxmap-preserves-disjoint-join
    (tgtmap2efxmap/+ S=>M GM=>XM)
    (tgtmap`disjoint/< D1P P1) (tgtmap`join/< J1 P2) _ _
    (tgtmap2efxmap/+ S=>M GM1=>XM1) GM2=>XM2x D3 J2
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- tgtmap`map/+-preserves-eq EQ set`eq/ tgtmap`eq/ MEQ
    <- tgtmap`disjoint-respects-eq D1P tgtmap`eq/ MEQ D1
    <- tgtmap2efxmap-preserves-disjoint-join
      GM=>XM D1 J1 _ V GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-swap-succ P2 P2P
    <- nat`plus-commutative P2P P2S
    <- efxmap`shift-total SH
    <- shift-preserves-tgtmap2efxmap 
      GM2=>XM2 (tgtmap`shift/+ P2S) SH GM2=>XM2x
    <- efxmap`shift-right-preserves-disjoint XM1^XM2 SH D3
    <- efxmap`shift-right-preserves-join XM1UXM2=XM SH J2.

%theorem tgtmap2efxmap-preserves-disjoint-join/V
  : forall* {GM1} {GM2} {X} {XM} 
    forall {V:void} 
    exists {XM1} {XM2}
    {GM1+X=>XM1: tgtmap2efxmap GM1 X XM1}
    {GM2+X=>XM2: tgtmap2efxmap GM2 X XM2}
    {XM1^XM2: efxmap`disjoint XM1 XM2}
    {XM1+XM2=XM: efxmap`join XM1 XM2 XM}
    true.

%worlds () (tgtmap2efxmap-preserves-disjoint-join/V _ _ _ _ _ _ _).
%total {} (tgtmap2efxmap-preserves-disjoint-join/V _ _ _ _ _ _ _).

- : tgtmap2efxmap-preserves-disjoint-join
    _ (tgtmap`disjoint/< _ P) (tgtmap`join/= _ _ nat`eq/) _ _
    GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- tgtmap2efxmap-preserves-disjoint-join/V
      F _ _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM.

- : tgtmap2efxmap-preserves-disjoint-join
    _ (tgtmap`disjoint/> _ P) (tgtmap`join/= _ _ nat`eq/) _ _
    GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- tgtmap2efxmap-preserves-disjoint-join/V
      F _ _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM.

- : tgtmap2efxmap-preserves-disjoint-join
    _ (tgtmap`disjoint/> _ P1) (tgtmap`join/< _ P2) _ _
    GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- tgtmap2efxmap-preserves-disjoint-join/V
      F _ _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM.

- : tgtmap2efxmap-preserves-disjoint-join
    _ (tgtmap`disjoint/< _ P1) (tgtmap`join/> _ P2) _ _
    GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- tgtmap2efxmap-preserves-disjoint-join/V
      F _ _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM.

%worlds () (tgtmap2efxmap-preserves-disjoint-join _ _ _ _ _ _ _ _ _).
%total (D) (tgtmap2efxmap-preserves-disjoint-join _ D _ _ _ _ _ _ _).


%theorem tgtmap2efxmap-preserves-deep-disjoint-join
  : forall* {GM} {XM} {X} {GM1} {GM2}
    forall {GM+X=>XM: tgtmap2efxmap GM X XM}
    {GM1^GM2: tgtmap`deep-disjoint GM1 GM2}
    {GM1+GM2=GM: tgtmap`join GM1 GM2 GM}
    exists {XM1} {XM2}
    {GM1+X=>XM1: tgtmap2efxmap GM1 X XM1}
    {GM2+X=>XM2: tgtmap2efxmap GM2 X XM2}
    {XM1^XM2: efxmap`deep-disjoint XM1 XM2}
    {XM1+XM2=XM: efxmap`join XM1 XM2 XM}
    true.

- : tgtmap2efxmap-preserves-deep-disjoint-join
    GM=>XM tgtmap`deep-disjoint/L tgtmap`join/L _ _ tgtmap2efxmap/0 GM=>XM 
    efxmap`deep-disjoint/L efxmap`join/L.

- : tgtmap2efxmap-preserves-deep-disjoint-join
    GM=>XM tgtmap`deep-disjoint/L tgtmap`join/R _ _ tgtmap2efxmap/0 GM=>XM 
    efxmap`deep-disjoint/L efxmap`join/R.

- : tgtmap2efxmap-preserves-deep-disjoint-join
    GM=>XM tgtmap`deep-disjoint/R tgtmap`join/L _ _ GM=>XM tgtmap2efxmap/0 
    efxmap`deep-disjoint/R efxmap`join/L.

- : tgtmap2efxmap-preserves-deep-disjoint-join
    GM=>XM tgtmap`deep-disjoint/R tgtmap`join/R _ _ GM=>XM tgtmap2efxmap/0 
    efxmap`deep-disjoint/R efxmap`join/R.

- : tgtmap2efxmap-preserves-deep-disjoint-join 
    (tgtmap2efxmap/+ S=>M GM=>XM) 
    (tgtmap`deep-disjoint/= GM1^GM2 S1^S2 nat`eq/)
    (tgtmap`join/= GM1UGM2=GM S1US2=S nat`eq/) _ _ 
    (tgtmap2efxmap/+ S1=>M1 GM1=>XM1) 
    (tgtmap2efxmap/+ S2=>M2 GM2=>XM2) 
    (efxmap`deep-disjoint/= XM1^XM2 M1^M2 nat`eq/) 
    (efxmap`join/= XM1UXM2=XM M1UM2=M nat`eq/)
    <- tgtmap2efxmap-preserves-deep-disjoint-join 
      GM=>XM GM1^GM2 GM1UGM2=GM _ _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- set2inner-efxmap-preserves-disjoint-join 
      S=>M S1^S2 S1US2=S M1 M2 S1=>M1 S2=>M2 M1^M2 M1UM2=M.

- : tgtmap2efxmap-preserves-deep-disjoint-join
    (tgtmap2efxmap/+ S=>M GM=>XM)
    (tgtmap`deep-disjoint/> D1P P1) (tgtmap`join/> J1 P2) _ _
    GM1=>XM1x (tgtmap2efxmap/+ S=>M GM2=>XM2) D3 J2
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- tgtmap`map/+-preserves-eq EQ set`eq/ tgtmap`eq/ MEQ
    <- tgtmap`deep-disjoint-respects-eq D1P MEQ tgtmap`eq/ D1
    <- tgtmap2efxmap-preserves-deep-disjoint-join
      GM=>XM D1 J1 V _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-swap-succ P2 P2P
    <- nat`plus-commutative P2P P2S
    <- efxmap`shift-total SH
    <- shift-preserves-tgtmap2efxmap 
      GM1=>XM1 (tgtmap`shift/+ P2S) SH GM1=>XM1x
    <- efxmap`shift-left-preserves-deep-disjoint XM1^XM2 SH D3
    <- efxmap`shift-left-preserves-join XM1UXM2=XM SH J2.

- : tgtmap2efxmap-preserves-deep-disjoint-join
    (tgtmap2efxmap/+ S=>M GM=>XM)
    (tgtmap`deep-disjoint/< D1P P1) (tgtmap`join/< J1 P2) _ _
    (tgtmap2efxmap/+ S=>M GM1=>XM1) GM2=>XM2x D3 J2
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- tgtmap`map/+-preserves-eq EQ set`eq/ tgtmap`eq/ MEQ
    <- tgtmap`deep-disjoint-respects-eq D1P tgtmap`eq/ MEQ D1
    <- tgtmap2efxmap-preserves-deep-disjoint-join
      GM=>XM D1 J1 _ V GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-swap-succ P2 P2P
    <- nat`plus-commutative P2P P2S
    <- efxmap`shift-total SH
    <- shift-preserves-tgtmap2efxmap 
      GM2=>XM2 (tgtmap`shift/+ P2S) SH GM2=>XM2x
    <- efxmap`shift-right-preserves-deep-disjoint XM1^XM2 SH D3
    <- efxmap`shift-right-preserves-join XM1UXM2=XM SH J2.

%theorem tgtmap2efxmap-preserves-deep-disjoint-join/V
  : forall* {GM1} {GM2} {X} {XM} 
    forall {V:void} 
    exists {XM1} {XM2}
    {GM1+X=>XM1: tgtmap2efxmap GM1 X XM1}
    {GM2+X=>XM2: tgtmap2efxmap GM2 X XM2}
    {XM1^XM2: efxmap`deep-disjoint XM1 XM2}
    {XM1+XM2=XM: efxmap`join XM1 XM2 XM}
    true.

%worlds () (tgtmap2efxmap-preserves-deep-disjoint-join/V _ _ _ _ _ _ _).
%total {} (tgtmap2efxmap-preserves-deep-disjoint-join/V _ _ _ _ _ _ _).

- : tgtmap2efxmap-preserves-deep-disjoint-join
    _ (tgtmap`deep-disjoint/< _ P) (tgtmap`join/= _ _ nat`eq/) _ _
    GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- tgtmap2efxmap-preserves-deep-disjoint-join/V
      F _ _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM.

- : tgtmap2efxmap-preserves-deep-disjoint-join
    _ (tgtmap`deep-disjoint/> _ P) (tgtmap`join/= _ _ nat`eq/) _ _
    GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- tgtmap2efxmap-preserves-deep-disjoint-join/V
      F _ _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM.

- : tgtmap2efxmap-preserves-deep-disjoint-join
    _ (tgtmap`deep-disjoint/= _ _ nat`eq/) (tgtmap`join/> _ P) _ _
    GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- tgtmap2efxmap-preserves-deep-disjoint-join/V
      F _ _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM.

- : tgtmap2efxmap-preserves-deep-disjoint-join
    _ (tgtmap`deep-disjoint/= _ _ nat`eq/) (tgtmap`join/< _ P) _ _
    GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- tgtmap2efxmap-preserves-deep-disjoint-join/V
      F _ _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM.

- : tgtmap2efxmap-preserves-deep-disjoint-join
    _ (tgtmap`deep-disjoint/> _ P1) (tgtmap`join/< _ P2) _ _
    GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- tgtmap2efxmap-preserves-deep-disjoint-join/V
      F _ _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM.

- : tgtmap2efxmap-preserves-deep-disjoint-join
    _ (tgtmap`deep-disjoint/< _ P1) (tgtmap`join/> _ P2) _ _
    GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- tgtmap2efxmap-preserves-deep-disjoint-join/V
      F _ _ GM1=>XM1 GM2=>XM2 XM1^XM2 XM1UXM2=XM.

%worlds () (tgtmap2efxmap-preserves-deep-disjoint-join _ _ _ _ _ _ _ _ _).
%total (D) (tgtmap2efxmap-preserves-deep-disjoint-join _ D _ _ _ _ _ _ _).