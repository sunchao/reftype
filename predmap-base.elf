%%% class predicate map
%%% map from class ids to their predicates
%%% Chao Sun
%%% $Id: predmap-base.elf,v 1.1 2012/10/15 20:00:52 csun Exp $
%%% Created at Feb 8th, 2012


%%% Functor Use

%{%
#define WORLDS predvar | objvar
#define data clspred
BEGIN_ELF
%abbrev clspred`eq = predicate`eq.
%abbrev clspred`eq/ = predicate`eq/.
%abbrev clspred`meta-eq = predicate`meta-eq.
%abbrev clspred`false-implies-eq = predicate`false-implies-eq.
%abbrev clspred`eq-reflexive = predicate`eq-reflexive.
%abbrev clspred`eq-symmetric = predicate`eq-symmetric.
%abbrev clspred`eq-transitive = predicate`eq-transitive.
%abbrev clspred`leq = clspred`eq.
%abbrev clspred`false-implies-leq = predicate`false-implies-eq.
%abbrev clspred`leq-reflexive = predicate`eq-reflexive.
%abbrev clspred`leq-transitive = predicate`eq-transitive.


%theorem clspred`leq-anti-symmetric :
        forall* {PD1:clspred} {PD2:clspred} 
        forall  {L12: clspred`leq PD1 PD2} {L21: clspred`leq PD2 PD1}
        exists  {E: clspred`eq PD1 PD2}
        true.

- : clspred`leq-anti-symmetric E _ E.

%worlds (predvar | objvar) (clspred`leq-anti-symmetric _ _ _).
%total { } (clspred`leq-anti-symmetric _ _ _).


%theorem clspred`leq-respects-eq :
        forall* {PD1:clspred} {PD2:clspred} {PD3:clspred} {PD4:clspred}
        forall  {L1: clspred`leq PD1 PD2}
                {E1: clspred`eq PD1 PD3}
                {E2: clspred`eq PD2 PD4}
        exists  {L3: clspred`leq PD3 PD4}
        true.

- : clspred`leq-respects-eq L _ _ L.

%worlds (predvar | objvar) (clspred`leq-respects-eq _ _ _ _).
%total { } (clspred`leq-respects-eq _ _ _ _).


#include "map-base.elf"
#include "map-leq.elf"
#include "map-domain.elf"
END_ELF
#undef data
%}%


%%% Renamings

%abbrev predmap = map.
%abbrev predmap/0 = map/0.
%abbrev predmap/+ = map/+.
