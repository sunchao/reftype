%%% effect map

%%% I think we don't need efxmap-value/obj
%%% since we can represent that as the set
%%% of all fields.

%%%% Definitions of Maps

map : type.


map/0 : map.

map/+ : nat -> inner-efxmap -> map -> map.

%abbrev map/1 : nat -> inner-efxmap -> map = [N] [D] (map/+ N D map/0).


%%%% Relations on maps


% equality is defined assuming "ne" is available,
% but 'ne' may be isufficiently inhabited to
% prove things about.


eq? : map -> map -> bool -> type.

%abbrev eq : map -> map -> type = [M1] [M2] eq? M1 M2 true.

%abbrev ne : map -> map -> type = [M1] [M2] eq? M1 M2 false.


eq?/yes : eq M M.

%abbrev eq/ = eq?/yes.

%abbrev eq?/no : ne M1 M2 -> eq? M1 M2 false = [x] x.



lookup : map -> nat -> inner-efxmap -> type.


lookup/= : lookup (map/+ N1 D _) N2 D
    <- nat`eq N1 N2.

lookup/> : lookup (map/+ N1 _ F) N2 D
    <- plus (s N0) N1 N2
    <- lookup F N0 D.


fresh : map -> nat -> type.


fresh/0 : fresh map/0 M.

fresh/< : fresh (map/+ N _ F) M
    <- gt N M.

fresh/> : fresh (map/+ N _ F) M
    <- plus (s M1) N M
    <- fresh F M1.



ne/< : lookup M1 N D -> fresh M2 N -> ne M1 M2.

ne/> : fresh M1 N -> lookup M2 N D -> ne M1 M2.



domain? : map -> nat -> bool -> type.


domain?/in : domain? M N true
    <- lookup M N _.

domain?/out : domain? M N false
    <- fresh M N.



disjoint : map -> map -> type.


disjoint/L : disjoint map/0 M.

disjoint/R : disjoint M map/0.

disjoint/< : disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N0) N1 N2
    <- disjoint M1 (map/+ N0 D2 M2).

disjoint/> : disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N3) N2 N1
    <- disjoint (map/+ N3 D1 M1) M2.



disjoint? : map -> map -> bool -> type.


disjoint?/yes : disjoint M1 M2 -> disjoint? M1 M2 true.

disjoint?/no :
 lookup M1 N D1 ->
 lookup M2 N D2 ->
    disjoint? M1 M2 false.



size : map -> nat -> type.


size/0 : size map/0 z.

size/+ : size (map/+ _ _ M) (s N)
    <- size M N.



%% useful for proving termination on map operations:

bound : map -> nat -> type.


bound/0 : bound map/0 z.

bound/+ : bound (map/+ N1 D M) N3
    <- bound M N2
    <- plus (s N1) N2 N3.


%worlds () (bound _ _).
%unique bound +B -1N.



shift : nat -> map -> map -> type.


shift/0 : shift _ map/0 map/0.

shift/+ : shift N1 (map/+ N2 D M) (map/+ N3 D M)
    <- plus (s N1) N2 N3.


%worlds () (shift _ _ _).
%unique shift +N +M -1M3.



update : map -> nat -> inner-efxmap -> map -> type.


update/0 : update map/0 N D (map/+ N D map/0).

update/= : update (map/+ N1 _ F) N2 D (map/+ N2 D F)
    <- nat`eq N1 N2.

update/< : update (map/+ N1 D1 F) N2 D2 (map/+ N2 D2 (map/+ N3 D1 F))
    <- plus (s N3) N2 N1.

update/> : update (map/+ N1 D1 F1) N2 D2 (map/+ N1 D1 F2)
    <- plus (s N0) N1 N2
    <- update F1 N0 D2 F2.




%%%% Theorems



%%% Theorems about eq


%theorem meta-eq :
 forall {M} {N} {E:eq M N}
 true.
- : meta-eq M M eq/.
%worlds () (meta-eq _ _ _).
%total {} (meta-eq _ _ _).
%reduces M = N (meta-eq M N _).


%theorem false-implies-eq? :
 forall* {M1} {M2} {B}
 forall {F:void}
 exists {E: eq? M1 M2 B}
 true.

%worlds () (false-implies-eq? _ _).
%total { } (false-implies-eq? _ _).

%abbrev false-implies-eq = false-implies-eq?.

%abbrev false-implies-ne = false-implies-eq?.


%theorem eq-reflexive : forall {M} exists {E:eq M M} true.

- : eq-reflexive _ eq/.

%worlds () (eq-reflexive M %{=>}% M=M).
%total {} (eq-reflexive _ _).


%theorem eq?-symmetric :
 forall* {M1} {M2} {B}
 forall {E1: eq? M1 M2 B}
 exists {E2: eq? M2 M1 B}
 true.

- : eq?-symmetric eq/ eq/.

- : eq?-symmetric (ne/< L F) (ne/> F L).

- : eq?-symmetric (ne/> F L) (ne/< L F).


%worlds () (eq?-symmetric _ _).
%total { } (eq?-symmetric _ _).

%abbrev eq-symmetric = eq?-symmetric.

%abbrev ne-symmetric = eq?-symmetric.


%theorem eq-transitive:
 forall* {M1} {M2} {M3}
 forall {E12:eq M1 M2} {E23:eq M2 M3}
 exists {E13:eq M1 M3}
 true.

- : eq-transitive eq/ eq/ eq/.

%worlds () (eq-transitive M1=M2 M2=M3 %{=>}% M1=M3).
%total {} (eq-transitive _ _ _).


%theorem map/+-preserves-eq? :
 forall* {N} {NP} {D} {DP} {F} {FP} {B}
 forall {EN:nat`eq N NP} {ED:inner-efxmap`eq D DP} {EF:eq? F FP B}
 exists {E:eq? (map/+ N D F) (map/+ NP DP FP) B}
 true.

- : map/+-preserves-eq? nat`eq/ inner-efxmap`eq/ eq/ eq/.

- : map/+-preserves-eq? nat`eq/ inner-efxmap`eq/ (ne/< L F)
 (ne/< (lookup/> L P) (fresh/> F P))
    <- plus-total P.

- : map/+-preserves-eq? nat`eq/ inner-efxmap`eq/ (ne/> F L)
 (ne/> (fresh/> F P) (lookup/> L P))
    <- plus-total P.


%worlds () (map/+-preserves-eq? _ _ _ _).
%total { } (map/+-preserves-eq? _ _ _ _).

%abbrev map/+-preserves-eq = map/+-preserves-eq?.

%abbrev map/+-preserves-ne = map/+-preserves-eq?.


%theorem map/+-preserves-eq-converse :
 forall* {N} {NP} {D} {DP} {F} {FP}
 forall {E:eq (map/+ N D F) (map/+ NP DP FP)}
 exists {EN:nat`eq N NP} {ED:inner-efxmap`eq D DP} {EF:eq F FP}
 true.

- : map/+-preserves-eq-converse eq/ nat`eq/ inner-efxmap`eq/ eq/.

%worlds () (map/+-preserves-eq-converse _ _ _ _).
%total {} (map/+-preserves-eq-converse _ _ _ _).


%theorem eq-no-occur :
 forall* {M} {N} {D}
 forall {E:eq M (map/+ N D M)}
 exists {F:void}
 true.

%worlds () (eq-no-occur _ _).
%total {} (eq-no-occur _ _).


%theorem eq-contradiction :
 forall* {N} {D} {M}
 forall {E:eq map/0 (map/+ N D M)}
 exists {F:void}
 true.

%worlds () (eq-contradiction _ _).
%total {} (eq-contradiction _ _).



%%% Theorems about lookup


%theorem false-implies-lookup :
 forall* {M} {N} {D}
 forall {F:void}
 exists {L:lookup M N D}
 true.

%worlds () (false-implies-lookup _ %{=>}% F^N=D).
%total {} (false-implies-lookup _ _).


%theorem lookup-respects-eq :
 forall* {M} {N} {D} {MP} {NP} {DP}
 forall {L:lookup M N D} {EM:eq M MP} {EN:nat`eq N NP} {ED:inner-efxmap`eq D DP}
 exists {LP:lookup MP NP DP}
 true.

- : lookup-respects-eq L eq/ nat`eq/ inner-efxmap`eq/ L.

%worlds () (lookup-respects-eq M^N=D M=MP N=NP D=DP %{=>}% MP^NP=DP).
%total {} (lookup-respects-eq _ _ _ _ _).
%reduces X = Y (lookup-respects-eq X _ _ _ Y).


%theorem meta-reduces-lookup :
 forall* {M1} {M2} {N1} {N2} {D1} {D2}
 forall {F: void}
  {L1: lookup M1 N1 D1}
  {L2: lookup M2 N2 D2}
 true.

%worlds () (meta-reduces-lookup _ _ _).
%total { } (meta-reduces-lookup _ _ _).
%reduces X < Y (meta-reduces-lookup _ X Y).


%theorem lookup/>-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {N0}
 forall {L: lookup (map/+ N1 D1 M1) N2 D2}
  {P: plus (s N0) N1 N2}
 exists {LP: lookup M1 N0 D2}
 true.

- : lookup/>-inversion (LEQ:lookup (map/+ N _ _) N _) P L
    <- plus-implies-gt P nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-lookup F L
    <- meta-reduces-lookup F L LEQ.

- : lookup/>-inversion (lookup/> LP P) PX LPX
    <- plus-right-cancels P PX nat`eq/ nat`eq/ SN0=SNX
    <- succ-cancels SN0=SNX N0=NX
    <- lookup-respects-eq LP eq/ N0=NX inner-efxmap`eq/ LPX.

%worlds () (lookup/>-inversion _ _ _).
%total { } (lookup/>-inversion _ _ _).
%reduces Y < X (lookup/>-inversion X _ Y).


%theorem lookup-deterministic :
 forall* {M} {N} {D} {MP} {NP} {DP}
 forall {L:lookup M N D} {LP:lookup MP NP DP}
               {EM:eq M MP} {EN:nat`eq N NP}
 exists {ED:inner-efxmap`eq D DP}
 true.

%abbrev lookup-unique = lookup-deterministic.

- : lookup-deterministic (lookup/= nat`eq/) (lookup/= nat`eq/) eq/ nat`eq/ inner-efxmap`eq/.

- : lookup-deterministic (lookup/> F^N0=D N0+1+N1=N2)
                         (lookup/> F^N0P=DP N0P+1+N1=N2) eq/ nat`eq/ D=DP
    <- plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- lookup-deterministic F^N0=D F^N0P=DP eq/ N0=N0P D=DP.

%% contradiction cases
- : lookup-deterministic (lookup/= nat`eq/) (lookup/> _ N0+1+N=N)
                         eq/ nat`eq/ D=DP
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N FALSE
    <- inner-efxmap`false-implies-eq FALSE D=DP.

- : lookup-deterministic (lookup/> _ N0+1+N=N) (lookup/= nat`eq/)
                         eq/ nat`eq/ D=DP
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N FALSE
    <- inner-efxmap`false-implies-eq FALSE D=DP.

%worlds () (lookup-deterministic M^N=D MP^NP=DP M=MP N=NP %{=>}% D=DP).
%total (L) (lookup-deterministic L _ _ _ _).


%% lookup is NOT total


%theorem lookup-contradiction :
 forall* {N} {D}
 forall {L:lookup map/0 N D}
 exists {F:void}
 true.

%worlds () (lookup-contradiction _ _).
%total { } (lookup-contradiction _ _).


%theorem lookup-one-choice :
 forall* {N1} {D1} {N2} {D2}
 forall {L:lookup (map/+ N1 D1 map/0) N2 D2}
 exists {NE:nat`eq N1 N2} {DE:inner-efxmap`eq D1 D2}
 true.

- : lookup-one-choice (lookup/= nat`eq/) nat`eq/ inner-efxmap`eq/.

%worlds () (lookup-one-choice _ _ _).
%total { } (lookup-one-choice _ _ _).


%theorem lookup-implies-ge :
        forall* {N1} {D1} {M1} {N} {D}
        forall {L: lookup (map/+ N1 D1 M1) N D}
        exists {G: nat`ge N N1}
        true.

- : lookup-implies-ge (lookup/= nat`eq/) (nat`ge/= nat`eq/).

- : lookup-implies-ge (lookup/> _ P) (nat`ge/> GT)
    <- plus-implies-gt P nat`eq/ GT.

%worlds () (lookup-implies-ge _ _).
%total { } (lookup-implies-ge _ _).



%%% Theorems about fresh


%theorem false-implies-fresh :
 forall* {M} {N} forall {F:void} exists {D:fresh M N} true.

%worlds () (false-implies-fresh _ %{=>}% N-not-in-domain-M).
%total {} (false-implies-fresh _ _).


%theorem fresh-respects-eq :
 forall* {M} {N} {MP} {NP}
 forall {D:fresh M N} {EM:eq M MP} {EN:nat`eq N NP}
 exists {DP:fresh MP NP}
 true.

- : fresh-respects-eq D eq/ nat`eq/ D.

%worlds () (fresh-respects-eq _ _ _ _).
%total {} (fresh-respects-eq _ _ _ _).


%theorem fresh/>-inversion :
 forall* {M} {N} {D} {N1} {N2}
 forall {F: fresh (map/+ N D M) N1}
  {P: plus (s N2) N N1}
 exists {F1: fresh M N2}
 true.

- : fresh/>-inversion (fresh/< G1) P FR
    <- plus-implies-gt P nat`eq/ G
    <- gt-anti-symmetric G1 G F
    <- false-implies-fresh F FR.

- : fresh/>-inversion (fresh/> F1 P1) P F
    <- plus-right-cancels P1 P nat`eq/ nat`eq/ SEQ
    <- succ-cancels SEQ EQ
    <- fresh-respects-eq F1 eq/ EQ F.

%worlds () (fresh/>-inversion _ _ _).
%total { } (fresh/>-inversion _ _ _).


%% fresh is NOT deterministic

%theorem fresh-total* :
 forall {M}
 exists {N} {F:fresh M N}
 true.

- : fresh-total* map/0 z fresh/0.

- : fresh-total* (map/+ N1 _ M) N3 (fresh/> F N+1+N1=N3)
    <- fresh-total* M N F
    <- plus-total* (s N) N1 N3 N+1+N1=N3.

%worlds () (fresh-total* M %{=>}% N N-not-in-domain-of-M).
%total (M) (fresh-total* M _ _).

%abbrev fresh-total = fresh-total* _ _.


%theorem fresh-lookup-not-equal :
 forall* {M} {N1} {N2} {D2}
 forall {F:fresh M N1} {L:lookup M N2 D2}
 exists {NE:nat`ne N1 N2}
 true.

- : fresh-lookup-not-equal (fresh/< N2>N1) (lookup/= nat`eq/) (nat`ne/< N2>N1).

- : fresh-lookup-not-equal (fresh/< N1>N3) (lookup/> _ N0+1+N1=N2)
                           (nat`ne/< N2>N3)
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- gt-transitive N2>N1 N1>N3 N2>N3.

- : fresh-lookup-not-equal (fresh/> _ X+1+N2=N1) (lookup/= nat`eq/) (nat`ne/> N1>N2)
    <- plus-implies-gt X+1+N2=N1 nat`eq/ N1>N2.

- : fresh-lookup-not-equal (fresh/> F N4+1+N1=N3) (lookup/> L N0+1+N1=N2)
                           N3<>N2
    <- fresh-lookup-not-equal F L N4<>N0
    <- succ-preserves-ne N4<>N0 N4+1<>N0+1
    <- plus-right-preserves-ne* N4+1<>N0+1 N4+1+N1=N3 N0+1+N1=N2 N3<>N2.

%worlds () (fresh-lookup-not-equal N1-not-in-domain-of-M M^N2=D %{=>}% N1<>N2).
%total (F) (fresh-lookup-not-equal F _ _).


%theorem fresh-contradiction :
 forall* {M} {N} {D}
 forall {F:fresh (map/+ N D M) N}
        exists {V:void}
 true.

- : fresh-contradiction (fresh/< N>N) V
    <- nat`gt-anti-reflexive N>N V.

- : fresh-contradiction (fresh/> _ N0+1+N=N) V
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N V.

%worlds () (fresh-contradiction _ _).
%total {} (fresh-contradiction _ _).


%theorem ne-implies-unit-map-fresh :
 forall* {N1} {D} {N2}
 forall {NE:nat`ne N1 N2}
 exists {F:fresh (map/+ N1 D map/0) N2}
 true.

- : ne-implies-unit-map-fresh
     (nat`ne/< N1<N2) (fresh/> fresh/0 N0+1+N1=N2)
    <- nat`gt-implies-plus N1<N2 N0 N0+1+N1=N2.

- : ne-implies-unit-map-fresh
     (nat`ne/> N1>N2) (fresh/< N1>N2).

%worlds () (ne-implies-unit-map-fresh _ _).
%total { } (ne-implies-unit-map-fresh _ _).


%theorem plus-right-preserves-fresh* :
 forall* {M} {N1} {D} {N2} {N} {N3} {N4}
        forall {F:fresh (map/+ N1 D M) N2}
               {P1:plus N1 N N3} {P2:plus N2 N N4}
        exists {FP:fresh (map/+ N3 D M) N4}
 true.

- : plus-right-preserves-fresh* (fresh/< N2>N1) N1+N=N3 N2+N=N4 (fresh/< N4>N3)
    <- nat`plus-right-preserves-gt* N2>N1 N1+N=N3 N2+N=N4 N4>N3.

- : plus-right-preserves-fresh* (fresh/> F10 N0+1+N1=N2) N1+N=N3 N2+N=N4
                                (fresh/> F10 N0+1+N3=N4)
    <- nat`plus-associative* N0+1+N1=N2 N2+N=N4 N1+N=N3 N0+1+N3=N4.

%worlds () (plus-right-preserves-fresh* _ _ _ _).
%total {} (plus-right-preserves-fresh* _ _ _ _).


%theorem fresh-lookup-implies-ne :
 forall* {M1} {N1} {M2} {N2} {D2}
 forall {L1:fresh M1 N1}
        {L2:lookup M2 N2 D2}
        {EN:nat`eq N1 N2}
 exists {NM:ne M1 M2}
 true.

- : fresh-lookup-implies-ne F L nat`eq/ (ne/> F L).

%worlds () (fresh-lookup-implies-ne _ _ _ _).
%total { } (fresh-lookup-implies-ne _ _ _ _).



%%% Theorems about eq?/ne


%% false-implies-eq? already done

%theorem eq?-respects-eq :
 forall* {M11} {M12} {M21} {M22} {B}
 forall {N1:eq? M11 M12 B} {E1:eq M11 M21} {E2:eq M12 M22}
 exists {N2:eq? M21 M22 B}
 true.

%abbrev ne-respects-eq = eq?-respects-eq.


%theorem ne-anti-reflexive :
 forall* {M}
 forall {N:ne M M}
 exists {F:void}
 true.

- : ne-anti-reflexive (ne/< L F) V
    <- fresh-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N V.

- : ne-anti-reflexive (ne/> F L) V
    <- fresh-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N V.


%worlds () (ne-anti-reflexive _ _).
%total (N) (ne-anti-reflexive N _).


%theorem eq-ne-implies-false :
        forall* {X} {Y}
        forall {D1:eq X Y} {D2:ne X Y}
        exists {F:void}
        true.

- : eq-ne-implies-false eq/ X<>X F
    <- ne-anti-reflexive X<>X F.

%worlds () (eq-ne-implies-false _ _ _).
%total { } (eq-ne-implies-false _ _ _).




%%% Theorems about map/domain


%theorem false-implies-domain? :
 forall* {M} {N} {D}
 forall {F:void}
 exists {MD:domain? M N D}
 true.

%worlds () (false-implies-domain? _ _).
%total {} (false-implies-domain? _ _).


%theorem domain?-respects-eq :
 forall* {M1} {N1} {B1} {M2} {N2} {B2}
 forall {MD1:domain? M1 N1 B1}
  {EM:eq M1 M2}
  {EN:nat`eq N1 N2}
  {BE:bool`eq B1 B2}
 exists {MD2:domain? M2 N2 B2}
 true.

- : domain?-respects-eq MD eq/ nat`eq/ bool`eq/ MD.

%worlds () (domain?-respects-eq _ _ _ _ _).
%total { } (domain?-respects-eq _ _ _ _ _).


%theorem domain?-deterministic :
 forall* {M1} {N1} {B1} {M2} {N2} {B2}
 forall {MD1:domain? M1 N1 B1}
  {MD2:domain? M2 N2 B2}
  {EM:eq M1 M2}
  {EN:nat`eq N1 N2}
 exists {BE:bool`eq B1 B2}
 true.

%abbrev domain?-unique = domain?-deterministic.

- : domain?-deterministic _ _ _ _ bool`eq/.

- : domain?-deterministic (domain?/in L) (domain?/out F) eq/ nat`eq/ BE
    <- fresh-lookup-not-equal F L NE
    <- nat`ne-anti-reflexive NE V
    <- bool`false-implies-eq V BE.

- : domain?-deterministic (domain?/out F) (domain?/in L) eq/ nat`eq/ BE
    <- fresh-lookup-not-equal F L NE
    <- nat`ne-anti-reflexive NE V
    <- bool`false-implies-eq V BE.

%worlds () (domain?-deterministic _ _ _ _ _).
%total { } (domain?-deterministic _ _ _ _ _).


%theorem domain?-total* :
 forall {M} {N}
 exists {B} {MD:domain? M N B}
 true.

%% we need a lemma
%theorem domain?-map/+-total :
 forall {N1} {D1} {M1} {N2} {C} {CMP:nat`compare N1 N2 C}
 exists {B} {MD:domain? (map/+ N1 D1 M1) N2 B}
 true.

%% and this lemma needs a lemma
%theorem domain?-map/+-complete :
 forall {N1} {D1} {M1} {N2} {N0} {P:plus (s N0) N1 N2}
               {B} {MD1:domain? M1 N0 B}
 exists {MD:domain? (map/+ N1 D1 M1) N2 B}
 true.

- : domain?-total* map/0 N false (domain?/out fresh/0).

- : domain?-total* (map/+ N1 D1 M1) N2 B MD
    <- nat`compare-total* N1 N2 C CMP
    <- domain?-map/+-total N1 D1 M1 N2 C CMP B MD.

- : domain?-map/+-total N1 D1 M1 N2 equal CMP true
                           (domain?/in (lookup/= N1=N2))
    <- equal-implies-eq CMP N1=N2.

- : domain?-map/+-total N1 D1 M1 N2 greater CMP false
                           (domain?/out (fresh/< N1>N2))
    <- greater-implies-gt CMP N1>N2.

- : domain?-map/+-total N1 D1 M1 N2 less CMP B MD
    <- less-implies-lt CMP N2>N1
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- domain?-total* M1 N0 B MD1
    <- domain?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 B MD1 MD.

- : domain?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 true (domain?/in L1)
                              (domain?/in (lookup/> L1 N0+1+N1=N2)).

- : domain?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 false (domain?/out F1)
                              (domain?/out (fresh/> F1 N0+1+N1=N2)).

%worlds () (domain?-map/+-complete _ _ _ _ _ _ _ _ _).
%total {} (domain?-map/+-complete _ _ _ _ _ _ _ _ _).

%worlds () (domain?-total* _ _ _ _)
           (domain?-map/+-total _ _ _ _ _ _ _ _).
%total (M M1) (domain?-total* M _ _ _)
              (domain?-map/+-total _ _ M1 _ _ _ _ _).

%abbrev domain?-total = domain?-total* _ _ _.


%theorem in-implies-lookup :
 forall* {M} {N}
 forall {MD:domain? M N true}
 exists {D} {L:lookup M N D}
 true.

- : in-implies-lookup (domain?/in L) _ L.

%worlds () (in-implies-lookup _ _ _).
%total {} (in-implies-lookup _ _ _).


%theorem out-implies-fresh :
 forall* {M} {N}
 forall {MD:domain? M N false}
 exists {F:fresh M N}
 true.

- : out-implies-fresh (domain?/out F) F.

%worlds () (out-implies-fresh _ _).
%total {} (out-implies-fresh _ _).



%%% Theorems about disjoint


%theorem false-implies-disjoint :
 forall* {M1} {M2}
 forall {F:void}
 exists {D:disjoint M1 M2}
 true.

%worlds () (false-implies-disjoint _ _).
%total { } (false-implies-disjoint _ _).


%theorem disjoint-respects-eq :
 forall* {M1} {M2} {M1P} {M2P}
 forall {A:disjoint M1 M2} {E1:eq M1 M1P} {E2:eq M2 M2P}
 exists {AP:disjoint M1P M2P}
 true.

- : disjoint-respects-eq A eq/ eq/ A.

%worlds () (disjoint-respects-eq _ _ _ _).
%total {} (disjoint-respects-eq _ _ _ _).
%reduces A = AP (disjoint-respects-eq A _ _ AP).


%theorem disjoint/=-contradiction :
 forall* {N1} {D1} {M1} {N2} {D2} {M2}
 forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
        {G:nat`eq N1 N2}
 exists {F:void}
 true.

- : disjoint/=-contradiction (disjoint/< _ N0+1+N=N) nat`eq/ F
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F.

- : disjoint/=-contradiction (disjoint/> _ N3+1+N=N) nat`eq/ F
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F.

%worlds () (disjoint/=-contradiction _ _ _).
%total { } (disjoint/=-contradiction _ _ _).


%theorem disjoint/<-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}
 forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
               {P:plus (s N0) N1 N2}
 exists {AP:disjoint M1 (map/+ N0 D2 M2)}
 true.

- : disjoint/<-inversion (disjoint/< A P) PP AP
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P inner-efxmap`eq/ eq/ M022=M022P
    <- disjoint-respects-eq A eq/ M022=M022P AP.

- : disjoint/<-inversion (disjoint/> AP N3+1+N2=N1) N0+1+N1=N2 A
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M311=M1
    <- false-implies-eq F M2=M022
    <- disjoint-respects-eq AP M311=M1 M2=M022 A.

%worlds () (disjoint/<-inversion _ _ _).
%total {} (disjoint/<-inversion _ _ _).
%reduces AP < A (disjoint/<-inversion A _ AP).


%theorem disjoint/>-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
 forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
        {P:plus (s N3) N2 N1}
 exists {AP:disjoint (map/+ N3 D1 M1) M2}
 true.

- : disjoint/>-inversion (disjoint/> A P) PP AP
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P inner-efxmap`eq/ eq/ M311=M311P
    <- disjoint-respects-eq A M311=M311P eq/ AP.

- : disjoint/>-inversion (disjoint/< AP N0+1+N1=N2) N3+1+N2=N1 A
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M1=M311
    <- false-implies-eq F M022=M2
    <- disjoint-respects-eq AP M1=M311 M022=M2 A.

%worlds () (disjoint/>-inversion _ _ _).
%total { } (disjoint/>-inversion _ _ _).
%reduces AP < A (disjoint/>-inversion A _ AP).


%theorem disjoint-anti-reflexive :
 forall* {M}
 forall {D:disjoint M M}
 exists {E:eq map/0 M}
 true.

- : disjoint-anti-reflexive disjoint/L eq/.

- : disjoint-anti-reflexive disjoint/R eq/.

- : disjoint-anti-reflexive (A:disjoint (map/+ N D M) (map/+ N D M)) E
    <- disjoint/=-contradiction A nat`eq/ F
    <- false-implies-eq F E.

%worlds () (disjoint-anti-reflexive _ _).
%total { } (disjoint-anti-reflexive _ _).


%theorem disjoint-symmetric :
 forall* {M1} {M2}
 forall {D:disjoint M1 M2}
 exists {D:disjoint M2 M1}
 true.

- : disjoint-symmetric disjoint/L disjoint/R.

- : disjoint-symmetric disjoint/R disjoint/L.

- : disjoint-symmetric (disjoint/< D P) (disjoint/> DP P)
    <- disjoint-symmetric D DP.

- : disjoint-symmetric (disjoint/> D P) (disjoint/< DP P)
    <- disjoint-symmetric D DP.

%worlds () (disjoint-symmetric _ _).
%total (D) (disjoint-symmetric D _).


%theorem disjoint-lookup-contradiction :
 forall* {M1} {M2} {N} {D1} {D2}
 forall {A:disjoint M1 M2}
               {L1:lookup M1 N D1} {L2:lookup M2 N D2}
 exists {F:void}
 true.

- : disjoint-lookup-contradiction disjoint/L L _ F
    <- lookup-contradiction L F.

- : disjoint-lookup-contradiction disjoint/R _ L F
    <- lookup-contradiction L F.

- : disjoint-lookup-contradiction (disjoint/< _ N0+1+N=N)
                                  (lookup/= nat`eq/) (lookup/= nat`eq/) F
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : disjoint-lookup-contradiction (disjoint/< _ N0+1+N1=N2)
                                  (lookup/= nat`eq/)
                                  (lookup/> _ N3+1+N2=N1) F
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- gt-anti-symmetric N2>N1 N1>N2 F.

- : disjoint-lookup-contradiction (disjoint/< D N0+1+N1=N2)
                                  (lookup/> L1P N0P+1+N1=N2)
                                  (lookup/= nat`eq/) F
    <- plus-right-cancels N0P+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N0P+1=N0+1
    <- succ-cancels N0P+1=N0+1 N0P=N0
    <- lookup-respects-eq L1P eq/ N0P=N0 inner-efxmap`eq/ L1
    <- disjoint-lookup-contradiction D L1 (lookup/= nat`eq/) F.

- : disjoint-lookup-contradiction (disjoint/< D N0+1+N1=N2)
                                  (lookup/> L1 N1P+1+N1=N)
                                  (lookup/> L2 N2P+1+N2=N) F
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N2P+1+N2=N NX
                                 N2P+1+N0=NX NX+N1+1=N
    <- plus-swap-succ N1P+1+N1=N N1P+N1+1=N
    <- plus-right-cancels NX+N1+1=N N1P+N1+1=N nat`eq/ nat`eq/ NX=N1P
    <- plus-respects-eq N2P+1+N0=NX nat`eq/ nat`eq/ NX=N1P N2P+1+N0=N1P
    <- disjoint-lookup-contradiction D L1 (lookup/> L2 N2P+1+N0=N1P) F.

- : disjoint-lookup-contradiction (disjoint/> _ N3+1+N=N)
                                  (lookup/= nat`eq/) (lookup/= nat`eq/) F
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : disjoint-lookup-contradiction (disjoint/> _ N3+1+N2=N1)
                                  (lookup/> _ N3+1+N1=N2)
                                  (lookup/= nat`eq/) F
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- plus-implies-gt N3+1+N1=N2 nat`eq/ N2>N1
    <- gt-anti-symmetric N1>N2 N2>N1 F.

- : disjoint-lookup-contradiction (disjoint/> D N3+1+N2=N1)
                                  (lookup/= nat`eq/)
                                  (lookup/> L2P N3P+1+N2=N1) F
    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- succ-cancels N3P+1=N3+1 N3P=N3
    <- lookup-respects-eq L2P eq/ N3P=N3 inner-efxmap`eq/ L2
    <- disjoint-lookup-contradiction D (lookup/= nat`eq/) L2 F.

- : disjoint-lookup-contradiction (disjoint/> D N3+1+N2=N1)
                                  (lookup/> L1 N1P+1+N1=N)
                                  (lookup/> L2 N2P+1+N2=N) F
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N1P+1+N1=N NX
                                 N1P+1+N3=NX NX+N2+1=N
    <- plus-swap-succ N2P+1+N2=N N2P+N2+1=N
    <- plus-right-cancels NX+N2+1=N N2P+N2+1=N nat`eq/ nat`eq/ NX=N2P
    <- plus-respects-eq N1P+1+N3=NX nat`eq/ nat`eq/ NX=N2P N1P+1+N3=N2P
    <- disjoint-lookup-contradiction D (lookup/> L1 N1P+1+N3=N2P) L2 F.

%worlds () (disjoint-lookup-contradiction _ _ _ _).
%total (D) (disjoint-lookup-contradiction D _ _ _).


%theorem disjoint-lookup-implies-fresh :
 forall* {M1} {N} {D} {M2}
 forall {L: lookup M1 N D}
  {A: disjoint M1 M2}
 exists {F: fresh M2 N}
 true.

%theorem disjoint-lookup-implies-fresh/L :
 forall* {M1} {N} {D} {M2} {B}
 forall {L: lookup M1 N D}
  {A: disjoint M1 M2}
  {D?: domain? M2 N B}
 exists {F: fresh M2 N}
 true.

- : disjoint-lookup-implies-fresh/L
 L1 A (domain?/in L2) FR
    <- disjoint-lookup-contradiction A L1 L2 F
    <- false-implies-fresh F FR.

- : disjoint-lookup-implies-fresh/L
 _ _ (domain?/out FR) FR.

%worlds () (disjoint-lookup-implies-fresh/L _ _ _ _).
%total { } (disjoint-lookup-implies-fresh/L _ _ _ _).

- : disjoint-lookup-implies-fresh L D F
    <- domain?-total D?
    <- disjoint-lookup-implies-fresh/L L D D? F.

%worlds () (disjoint-lookup-implies-fresh _ _ _).
%total { } (disjoint-lookup-implies-fresh _ _ _).


%theorem shift-left-preserves-disjoint :
 forall* {N} {D} {M1} {M2} {SM1}
 forall {A:disjoint M1 M2} {S1:shift N M1 SM1}
        exists {SA:disjoint SM1 (map/+ N D M2)}
        true.

- : shift-left-preserves-disjoint _ shift/0 disjoint/L.

- : shift-left-preserves-disjoint M111*M2 (shift/+ N+1+N1=N1P)
                              (disjoint/> M111*M2 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-disjoint _ _ _).
%total { } (shift-left-preserves-disjoint _ _ _).


%theorem shift-left-preserves-disjoint-converse :
 forall* {N} {D} {M1} {M2} {SM1}
 forall {SA:disjoint SM1 (map/+ N D M2)} {S1:shift N M1 SM1}
        exists {A:disjoint M1 M2}
 true.

- : shift-left-preserves-disjoint-converse _ shift/0 disjoint/L.

- : shift-left-preserves-disjoint-converse M111*M222 (shift/+ N2+1+N3=N1)
                                           M311*M2
    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1
    <- disjoint/>-inversion M111*M222 N3+1+N2=N1 M311*M2.

%worlds () (shift-left-preserves-disjoint-converse _ _ _).
%total { } (shift-left-preserves-disjoint-converse _ _ _).


%theorem shift-right-preserves-disjoint :
 forall* {N} {D} {M1} {M2} {SM2}
 forall {A:disjoint M1 M2} {S2:shift N M2 SM2}
        exists {SA:disjoint (map/+ N D M1) SM2}
 true.

- : shift-right-preserves-disjoint _ shift/0 disjoint/R.

- : shift-right-preserves-disjoint M1*M222 (shift/+ N+1+N2=N2P)
                               (disjoint/< M1*M222 N2+1+N=N2P)
    <- plus-swap-succ N+1+N2=N2P N+N2+1=N2P
    <- plus-commutative N+N2+1=N2P N2+1+N=N2P.

%worlds () (shift-right-preserves-disjoint _ _ _).
%total { } (shift-right-preserves-disjoint _ _ _).


%theorem shift-right-preserves-disjoint-converse :
 forall* {N} {D} {M1} {M2} {SM2}
 forall {SA:disjoint (map/+ N D M1) SM2} {S2:shift N M2 SM2}
        exists {A:disjoint M1 M2}
 true.

- : shift-right-preserves-disjoint-converse _ shift/0 disjoint/R.

- : shift-right-preserves-disjoint-converse M111*M322 (shift/+ N1+1+N2=N3)
                                            M1*M222
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- disjoint/<-inversion M111*M322 N2+1+N1=N3 M1*M222.

%worlds () (shift-right-preserves-disjoint-converse _ _ _).
%total { } (shift-right-preserves-disjoint-converse _ _ _).


%theorem shift-preserves-disjoint :
 forall* {N} {M1} {M2} {SM1} {SM2}
 forall {A:disjoint M1 M2}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2}
 exists {SA:disjoint SM1 SM2}
 true.

- : shift-preserves-disjoint _ shift/0 _ disjoint/L.

- : shift-preserves-disjoint _ _ shift/0 disjoint/R.

- : shift-preserves-disjoint (disjoint/< M1*M022 N0+1+N1=N2)
                             (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                             (disjoint/< M1*M022 N0+1+N4=N5)
    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4
    <- plus-commutative N+N1+1=N4 N1+1+N=N4
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.

- : shift-preserves-disjoint (disjoint/> M311*M2 N3+1+N2=N1)
                             (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                             (disjoint/> M311*M2 N3+1+N5=N4)
    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5
    <- plus-commutative N+N2+1=N5 N2+1+N=N5
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4.

%worlds () (shift-preserves-disjoint _ _ _ _).
%total { } (shift-preserves-disjoint _ _ _ _).


%theorem shift-preserves-disjoint-converse :
 forall* {N} {M1} {M2} {SM1} {SM2}
 forall {SA:disjoint SM1 SM2}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2}
 exists {A:disjoint M1 M2}
 true.

- : shift-preserves-disjoint-converse _ shift/0 _ disjoint/L.

- : shift-preserves-disjoint-converse _ _ shift/0 disjoint/R.

- : shift-preserves-disjoint-converse (disjoint/< M1*M055 N0+1+N4=N5)
                                      (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
          (disjoint/< M1*M055 N0+1+N1=N2)
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4
    <- plus-associative-converse N1+N+1=N4 N0+1+N4=N5 N2P N0+1+N1=N2P N2P+N+1=N5
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-right-cancels N2P+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2P=N2
    <- plus-respects-eq N0+1+N1=N2P nat`eq/ nat`eq/ N2P=N2 N0+1+N1=N2.

- : shift-preserves-disjoint-converse (disjoint/> M611*M2 N6+1+N5=N4)
                                      (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                                      (disjoint/> M611*M2 N6+1+N2=N1)
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5
    <- plus-associative-converse N2+N+1=N5 N6+1+N5=N4 N1P N6+1+N2=N1P N1P+N+1=N4
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-right-cancels N1P+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1P=N1
    <- plus-respects-eq N6+1+N2=N1P nat`eq/ nat`eq/ N1P=N1 N6+1+N2=N1.

%worlds () (shift-preserves-disjoint-converse _ _ _ _).
%total { } (shift-preserves-disjoint-converse _ _ _ _).


%theorem can-construct-unit-disjoint:
 forall* {N} {D} {M1} {M}
 forall {S: shift N M1 M}
 exists {A: disjoint M (map/+ N D map/0)}
 true.

- : can-construct-unit-disjoint shift/0 disjoint/L.

- : can-construct-unit-disjoint (shift/+ P) (disjoint/> disjoint/R PPP)
    <- plus-swap-succ P PP
    <- plus-commutative PP PPP.

%worlds () (can-construct-unit-disjoint _ _).
%total { } (can-construct-unit-disjoint _ _).


%theorem ne-implies-disjoint :
 forall* {N1} {D1} {N2} {D2}
 forall {NE:nat`ne N1 N2}
 exists {D:disjoint (map/+ N1 D1 map/0) (map/+ N2 D2 map/0)}
 true.

- : ne-implies-disjoint (nat`ne/< N1<N2)
 (disjoint/< disjoint/L N0+1+N1=N2)
    <- gt-implies-plus N1<N2 _ N0+1+N1=N2.

- : ne-implies-disjoint (nat`ne/> N1>N2)
 (disjoint/> disjoint/R N3+1+N2=N1)
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1.

%worlds () (ne-implies-disjoint _ _).
%total { } (ne-implies-disjoint _ _).


%theorem fresh-implies-unit-disjoint :
 forall* {N} {M} {D}
 forall {F:fresh M N}
 exists {D: disjoint M (map/+ N D map/0)}
 true.

- : fresh-implies-unit-disjoint fresh/0 disjoint/L.

- : fresh-implies-unit-disjoint (fresh/< G) (disjoint/> disjoint/R P)
    <- gt-implies-plus G _ P.

- : fresh-implies-unit-disjoint (fresh/> F P) (disjoint/< D P)
    <- fresh-implies-unit-disjoint F D.

%worlds () (fresh-implies-unit-disjoint _ _).
%total (F) (fresh-implies-unit-disjoint F _).



%%% Theorems about size


%theorem false-implies-size :
 forall* {M} {N}
 forall {F:void}
 exists {SZ:size M N}
 true.

%worlds () (false-implies-size _ _).
%total { } (false-implies-size _ _).


%theorem size-total* :
 forall {M}
 exists {N} {MX:size M N}
 true.

- : size-total* map/0 _ size/0.

- : size-total* _ _ (size/+ SZ)
    <- size-total* _ _ SZ.

%worlds () (size-total* _ _ _).
%total (M) (size-total* M _ _).


%abbrev size-total = size-total* _ _.


%theorem size-respects-eq :
 forall* {M1} {M2} {N1} {N2}
 forall {SZ1:size M1 N1}
  {EM:eq M1 M2}
         {EN:nat`eq N1 N2}
 exists {SZ2:size M2 N2}
 true.

- : size-respects-eq S eq/ nat`eq/ S.

%worlds () (size-respects-eq _ _ _ _).
%total { } (size-respects-eq _ _ _ _).


%theorem size-deterministic :
 forall* {M1} {M2} {N1} {N2}
 forall {SZ1:size M1 N1} {SZ2:size M2 N2} {EM:eq M1 M2}
        exists {EN:nat`eq N1 N2}
 true.

%abbrev size-unique = size-deterministic.

- : size-deterministic size/0 size/0 eq/ nat`eq/.

- : size-deterministic (size/+ N1=|M1|) (size/+ N2=|M2|) eq/ N1+1=N2+1
    <- size-deterministic N1=|M1| N2=|M2| eq/ N1=N2
    <- succ-deterministic N1=N2 N1+1=N2+1.

%worlds () (size-deterministic _ _ _ _).
%total (S) (size-deterministic S _ _ _).


%theorem shift-preserves-size :
 forall* {M1} {N1} {M2} {N}
 forall {SZ1: size M1 N1}
  {SH: shift N M1 M2}
 exists {SZ2: size M2 N1}
 true.

- : shift-preserves-size (size/0) (shift/0) (size/0).

- : shift-preserves-size (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size _ _ _).
%total { } (shift-preserves-size _ _ _).


%theorem shift-preserves-size-converse:
 forall* {M1} {N1} {M2} {N}
 forall {SZ2: size M2 N1}
  {SH: shift N M1 M2}
 exists {SZ1: size M1 N1}
 true.

- : shift-preserves-size-converse (size/0) (shift/0) (size/0).

- : shift-preserves-size-converse (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size-converse _ _ _).
%total { } (shift-preserves-size-converse _ _ _).



%%% Theorems about bound

%theorem false-implies-bound :
 forall* {M} {N}
 forall {F:void}
 exists {MX:bound M N}
 true.

%worlds () (false-implies-bound _ _).
%total { } (false-implies-bound _ _).


%theorem bound-respects-eq :
 forall* {M1} {N1} {M2} {N2}
 forall {B1: bound M1 N1}
  {EM: eq M1 M2}
  {EN: nat`eq N1 N2}
 exists {B2: bound M2 N2}
 true.

- : bound-respects-eq B _ _ B.

%worlds () (bound-respects-eq _ _ _ _).
%total { } (bound-respects-eq _ _ _ _).


%theorem bound-unique :
 forall* {M1} {N1} {M2} {N2}
 forall {B1: bound M1 N1}
  {B2: bound M2 N2}
  {EM: eq M1 M2}
 exists {EN: nat`eq N1 N2}
 true.

%abbrev bound-deterministic = bound-unique.

- : bound-unique bound/0 bound/0 _ nat`eq/.

- : bound-unique (bound/+ P1 B1) (bound/+ P2 B2) eq/ EQ2
    <- bound-unique B1 B2 eq/ EQ1
    <- plus-unique P1 P2 nat`eq/ EQ1 EQ2.

%worlds () (bound-unique _ _ _ _).
%total (B) (bound-unique B _ _ _).


%theorem bound-total* :
 forall {M}
 exists {N} {MX:bound M N}
 true.

- : bound-total* map/0 _ bound/0.

- : bound-total* _ _ (bound/+ P MX)
    <- bound-total* _ _ MX
    <- plus-total P.

%worlds () (bound-total* _ _ _).
%total (M) (bound-total* M _ _).


%abbrev bound-total = bound-total* _ _.


%theorem bound-lookup-implies-gt :
        forall* {M} {N} {D} {X}
        forall {B: bound M X}
                {L: lookup M N D}
        exists {G: gt X N}
        true.

- : bound-lookup-implies-gt (bound/+ P _) (lookup/= nat`eq/) G
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- plus-implies-gt Psc (nat`eq/) G.

- : bound-lookup-implies-gt (bound/+ P1 B) (lookup/> L P2) G
    <- bound-lookup-implies-gt B L G1
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- plus-left-preserves-gt* G1 P1 P2sc G.

%worlds () (bound-lookup-implies-gt _ _ _).
%total (B) (bound-lookup-implies-gt B _ _).


%theorem ge-bound-implies-fresh :
 forall* {M} {X} {N}
 forall {B:bound M X} {G:nat`ge N X}
 exists {F:fresh M N}
 true.

- : ge-bound-implies-fresh bound/0 _ fresh/0.

- : ge-bound-implies-fresh (bound/+ M1+1+X1=X B) N>=X (fresh/> F1 N1+1+M1=N)
    <- nat`ge-implies-plus N>=X Y1 Y1+X=N
    <- nat`plus-commutative M1+1+X1=X X1+M1+1=X
    <- nat`plus-associative-converse X1+M1+1=X Y1+X=N N1 Y1+X1=N1 N1+M1+1=N
    <- plus-swap-succ-converse N1+M1+1=N N1+1+M1=N
    <- plus-implies-ge Y1+X1=N1 N1>=X1
    <- ge-bound-implies-fresh B N1>=X1 F1.

%worlds () (ge-bound-implies-fresh _ _ _).
%total (B) (ge-bound-implies-fresh B _ _).



%%% Theorems about shift

%theorem false-implies-shift :
 forall* {M} {N} {MP}
 forall {F:void}
 exists {S:shift N M MP}
 true.
%worlds () (false-implies-shift _ _).
%total { } (false-implies-shift _ _).


%theorem shift-respects-eq :
 forall* {N} {M1} {M2} {NP} {M1P} {M2P}
 forall {S:shift N M1 M2}
               {EN:nat`eq N NP} {E1:eq M1 M1P} {E2:eq M2 M2P}
        exists {SP:shift NP M1P M2P}
 true.

- : shift-respects-eq S nat`eq/ eq/ eq/ S.

%worlds () (shift-respects-eq _ _ _ _ _).
%total { } (shift-respects-eq _ _ _ _ _).


%theorem shift-total* :
 forall {N} {M1}
 exists {M2} {S:shift N M1 M2}
 true.

- : shift-total* N map/0 map/0 shift/0.

- : shift-total* N1 (map/+ N2 D M) (map/+ N3 D M) (shift/+ N1+1+N2=N3)
    <- plus-total N1+1+N2=N3.

%worlds () (shift-total* _ _ _ _).
%total { } (shift-total* _ _ _ _).

%abbrev shift-total = shift-total* _ _ _.


%theorem shift-deterministic :
 forall* {N} {M1} {M2} {NP} {M1P} {M2P}
 forall {S:shift N M1 M2} {SP:shift NP M1P M2P}
        {EN:nat`eq N NP} {EM1:eq M1 M1P}
 exists {EM2:eq M2 M2P}
 true.

%abbrev shift-unique = shift-deterministic.

- : shift-deterministic shift/0 shift/0 nat`eq/ eq/ eq/.

- : shift-deterministic (shift/+ N1+1+N2=N3) (shift/+ N1+1+N2=N3P) nat`eq/ eq/ E
    <- plus-deterministic N1+1+N2=N3 N1+1+N2=N3P nat`eq/ nat`eq/ N3=N3P
    <- map/+-preserves-eq N3=N3P inner-efxmap`eq/ eq/ E.

%worlds () (shift-deterministic _ _ _ _ _).
%total { } (shift-deterministic _ _ _ _ _).


%theorem shift-cancels :
 forall* {N} {M1} {M2} {NP} {M1P} {M2P}
 forall {S:shift N M1 M2} {SP:shift NP M1P M2P}
        {EN:nat`eq N NP} {EM1:eq M2 M2P}
 exists {EM2:eq M1 M1P}
 true.

- : shift-cancels shift/0 shift/0 nat`eq/ eq/ eq/.

- : shift-cancels (shift/+ N1+1+N2=N3) (shift/+ N1+1+N2P=N3) nat`eq/ eq/ E
    <- plus-left-cancels N1+1+N2=N3 N1+1+N2P=N3 nat`eq/ nat`eq/ N2=N2P
    <- map/+-preserves-eq N2=N2P inner-efxmap`eq/ eq/ E.

%worlds () (shift-cancels _ _ _ _ _).
%total { } (shift-cancels _ _ _ _ _).


%theorem shifts-add :
 forall* {N1} {N2} {N3} {M0} {M1} {M3}
 forall {S1:shift N1 M0 M1} {S2:shift N2 M1 M3} {P:plus (s N1) N2 N3}
        exists {S3:shift N3 M0 M3}
 true.

- : shifts-add shift/0 shift/0 _ shift/0.

- : shifts-add (shift/+ N1+1+N4=N5) (shift/+ N2+1+N5=N7) N1+1+N2=N3
               (shift/+ N3+1+N4=N7)
    <- plus-total N3+1+N4=N7P
    <- plus-swap-succ N3+1+N4=N7P N3+N4+1=N7P
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-swap-succ N1+1+N4=N5 N1+N4+1=N5
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- plus-associative* N2+1+N1=N3 N3+N4+1=N7P N1+N4+1=N5 N2+1+N5=N7P
    <- plus-deterministic N2+1+N5=N7P N2+1+N5=N7 nat`eq/ nat`eq/ N7P=N7
    <- plus-respects-eq N3+1+N4=N7P nat`eq/ nat`eq/ N7P=N7 N3+1+N4=N7.

%worlds () (shifts-add _ _ _ _).
%total { } (shifts-add _ _ _ _).


%theorem shifts-add-converse :
 forall* {N1} {N2} {N3} {M0} {M3}
 forall {S3:shift N3 M0 M3} {P:plus (s N1) N2 N3}
 exists {M1} {S1:shift N1 M0 M1} {S2:shift N2 M1 M3}
        true.

- : shifts-add-converse S3 P M1 S1 S2
    <- shift-total S1
    <- shift-total S2P
    <- shifts-add S1 S2P P S3P
    <- shift-deterministic S3P S3 nat`eq/ eq/ M3P=M3
    <- shift-respects-eq S2P nat`eq/ eq/ M3P=M3 S2.

%worlds () (shifts-add-converse _ _ _ _ _).
%total { } (shifts-add-converse _ _ _ _ _).


%theorem shift-preserves-fresh :
        forall* {M1} {N1} {N2} {N0}
        forall {L1:fresh M1 N1}
         {P:plus (s N0) N1 N2}
 exists {M2} {S:shift N0 M1 M2}
  {L2:fresh M2 N2}
 true.

- : shift-preserves-fresh fresh/0 P _ shift/0 fresh/0.

- : shift-preserves-fresh
 (fresh/< G) P _ (shift/+ PP)
 (fresh/< GP)
    <- plus-total PP
    <- plus-left-preserves-gt* G PP P GP.

- : shift-preserves-fresh
 (fresh/> F D+1+N3=N1) N0+1+N1=N2 _ (shift/+ N0+1+N3=N4)
 (fresh/> F D+1+N4=N2)
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative D+1+N3=N1 N1+N0+1=N2 N4 N3+N0+1=N4 D+1+N4=N2
    <- plus-commutative N3+N0+1=N4 N0+1+N3=N4.

%worlds () (shift-preserves-fresh _ _ _ _ _).
%total (F) (shift-preserves-fresh F _ _ _ _).


%theorem shift-preserves-fresh* :
        forall* {M1} {N1} {N2} {N0} {M2}
        forall {L1:fresh M1 N1}
         {P:plus (s N0) N1 N2}
  {S:shift N0 M1 M2}
 exists {L2:fresh M2 N2}
 true.

- : shift-preserves-fresh* F P S1 FP1
    <- shift-preserves-fresh F P _ S2 FP2
    <- shift-deterministic S2 S1 nat`eq/ eq/ EQ
    <- fresh-respects-eq FP2 EQ nat`eq/ FP1.

%worlds () (shift-preserves-fresh* _ _ _ _).
%total { } (shift-preserves-fresh* _ _ _ _).


%theorem shift-preserves-fresh-converse* :
        forall* {M1} {N1} {N2} {M2} {N0}
 forall {L2:fresh M2 N2} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
        exists {L1:fresh M1 N1}
 true.

- : shift-preserves-fresh-converse* fresh/0 shift/0 _ fresh/0.

- : shift-preserves-fresh-converse*
 (fresh/< N1>N) (shift/+ S+1+N2=N1) S+1+NP=N
 (fresh/< N2>NP)
    <- plus-left-cancels-gt S+1+N2=N1 S+1+NP=N nat`eq/ N1>N N2>NP.

- : shift-preserves-fresh-converse*
 (fresh/> F NX+1+N2=N) (shift/+ S+1+N1=N2) S+1+NP=N
        (fresh/> F NX+1+N1=NP)
    <- plus-commutative S+1+N1=N2 N1+S+1=N2
    <- plus-associative-converse N1+S+1=N2 NX+1+N2=N NPP NX+1+N1=NPP NPP+S+1=N
    <- plus-commutative NPP+S+1=N S+1+NPP=N
    <- plus-left-cancels S+1+NPP=N S+1+NP=N nat`eq/ nat`eq/ NPP=NP
    <- plus-respects-eq NX+1+N1=NPP nat`eq/ nat`eq/ NPP=NP NX+1+N1=NP.

%worlds () (shift-preserves-fresh-converse* _ _ _ _).
%total { } (shift-preserves-fresh-converse* _ _ _ _).


%theorem shift-preserves-lookup :
        forall* {M1} {N1} {D} {N0} {M2}
 forall {L1:lookup M1 N1 D} {S:shift N0 M1 M2}
        exists {N2} {P:plus (s N0) N1 N2} {L2:lookup M2 N2 D}
 true.

- : shift-preserves-lookup (lookup/= nat`eq/) (shift/+ N0+1+N1=N2) _
                           N0+1+N1=N2 (lookup/= nat`eq/).

- : shift-preserves-lookup (lookup/> L N3+1+N1=N4) (shift/+ N0+1+N1=N2) _
                           N0+1+N4=N5 (lookup/> L N3+1+N2=N5)
    <- plus-total N0+1+N4=N5
    <- plus-commutative N3+1+N1=N4 N1+N3+1=N4
    <- plus-associative-converse* N1+N3+1=N4 N0+1+N4=N5 N0+1+N1=N2 N2+N3+1=N5
    <- plus-commutative N2+N3+1=N5 N3+1+N2=N5.

%worlds () (shift-preserves-lookup _ _ _ _ _).
%total { } (shift-preserves-lookup _ _ _ _ _).


%theorem shift-preserves-lookup* :
        forall* {M1} {N1} {D} {N0} {M2} {N2}
 forall {L1:lookup M1 N1 D} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
        exists {L2:lookup M2 N2 D}
 true.

- : shift-preserves-lookup* L1 S P L2
    <- shift-preserves-lookup L1 S _ PP L2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- lookup-respects-eq L2P eq/ N2P=N2 inner-efxmap`eq/ L2.

%worlds () (shift-preserves-lookup* _ _ _ _).
%total { } (shift-preserves-lookup* _ _ _ _).


%theorem shift-preserves-lookup-converse :
        forall* {M1} {N0} {D} {N2} {M2}
 forall {L2:lookup M2 N2 D} {S:shift N0 M1 M2}
        exists {N1} {P:plus (s N0) N1 N2} {L1:lookup M1 N1 D}
 true.

- : shift-preserves-lookup-converse (lookup/= nat`eq/) (shift/+ N0+1+N1=N2) _
                                    N0+1+N1=N2 (lookup/= nat`eq/).

- : shift-preserves-lookup-converse (lookup/> L N3+1+N2=N5) (shift/+ N0+1+N1=N2)
                                    _ N0+1+N4=N5 (lookup/> L N3+1+N1=N4)
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse N1+N0+1=N2 N3+1+N2=N5 N4 N3+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.

%worlds () (shift-preserves-lookup-converse _ _ _ _ _).
%total { } (shift-preserves-lookup-converse _ _ _ _ _).


%theorem shift-preserves-lookup-converse* :
        forall* {M1} {N1} {D} {N2} {M2} {N0}
 forall {L2:lookup M2 N2 D} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
        exists {L1:lookup M1 N1 D}
 true.

- : shift-preserves-lookup-converse* L2 S P L1
    <- shift-preserves-lookup-converse L2 S _ PP L1P
    <- plus-left-cancels PP P nat`eq/ nat`eq/ N1P=N1
    <- lookup-respects-eq L1P eq/ N1P=N1 inner-efxmap`eq/ L1.

%worlds () (shift-preserves-lookup-converse* _ _ _ _).
%total { } (shift-preserves-lookup-converse* _ _ _ _).


%theorem shift-implies-fresh* :
 forall* {M} {N1} {N} {NM}
 forall {SH:shift N M NM}
  {GE:nat`ge N N1}
 exists {F:fresh NM N1}
 true.

- : shift-implies-fresh* shift/0 _ fresh/0.

- : shift-implies-fresh*
     (shift/+ SN+N1=N1P) N>=NP
     (fresh/< N1P>NP)
    <- plus-commutative SN+N1=N1P N1+SN=N1P
    <- plus-implies-ge N1+SN=N1P N1P>=SN
    <- ge-succ-implies-gt N1P>=SN N1P>N
    <- gt-transitive-ge N1P>N N>=NP N1P>NP.

%worlds () (shift-implies-fresh* _ _ _).
%total { } (shift-implies-fresh* _ _ _).


%theorem shift-implies-fresh :
 forall* {M} {N} {NM}
 forall {SH:shift N M NM}
 exists {F:fresh NM N}
 true.

- : shift-implies-fresh SH F
    <- shift-implies-fresh* SH (nat`ge/= nat`eq/) F.

%worlds () (shift-implies-fresh _ _).
%total { } (shift-implies-fresh _ _).


%theorem removal-preserves-fresh :
 forall* {N1} {D} {M1} {N2} {M2}
 forall {F1: fresh (map/+ N1 D M1) N2}
  {S: shift N1 M1 M2}
 exists {F2: fresh M2 N2}
 true.

- : removal-preserves-fresh _ _ fresh/0.

- : removal-preserves-fresh (fresh/< GT1) (shift/+ P) (fresh/< GT2)
    <- plus-swap-succ P PS
    <- plus-commutative PS PSC
    <- plus-implies-gt PSC nat`eq/ GT3
    <- gt-transitive GT3 GT1 GT2.

- : removal-preserves-fresh (fresh/> F1 P1) (shift/+ P2) F2
    <- plus-swap-succ P1 PS1
    <- plus-commutative PS1 PSC1
    <- shift-preserves-fresh* F1 PSC1
 (shift/+ P2) F2.

%worlds () (removal-preserves-fresh _ _ _).
%total { } (removal-preserves-fresh _ _ _).


%theorem shift-preserves-size :
 forall* {M} {N1} {N2} {S2M}
 forall {SZ:size M N1} {SH:shift N2 M S2M}
 exists {SHSZ:size S2M N1}
 true.

- : shift-preserves-size size/0 shift/0 size/0.

- : shift-preserves-size (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size _ _ _).
%total { } (shift-preserves-size _ _ _).



%%% Theorems about disjoint?


%theorem disjoint?-total* :
 forall {M1} {M2}
 exists {B} {D:disjoint? M1 M2 B}
 true.

- : disjoint?-total* _ _ _ (disjoint?/yes disjoint/L).

- : disjoint?-total* _ _ _ (disjoint?/yes disjoint/R).

%theorem disjoint?-total*/+ :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {C}
 forall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2} {CMP:nat`compare N1 N2 C}
 exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
 true.

%theorem disjoint?-total*/< :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0} {B1}
 forall {P:plus (s N0) N1 N2}
               {D?1:disjoint? M1 (map/+ N0 D2 M2) B1}
 exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
 true.

%theorem disjoint?-total*/> :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {B1}
 forall {P:plus (s N3) N2 N1}
               {D?1:disjoint? (map/+ N3 D1 M1) M2 B1}
 exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
 true.

- : disjoint?-total* _ _ _ D?
    <- size-total SZ1
    <- size-total SZ2
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?.

- : disjoint?-total*/+ _ _ _ _ (nat`compare/=) _
                       (disjoint?/no (lookup/= nat`eq/) (lookup/= nat`eq/)).

- : disjoint?-total*/+ _ _ _ _ (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- disjoint?-total*/< N0+1+N1=N2 (disjoint?/yes disjoint/L) _ D?.

- : disjoint?-total*/+ _ _ (size/+ SZ1) SZ2 (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- disjoint?-total*/< N0+1+N1=N2 D?1 _ D?.

- : disjoint?-total*/< N0+1+N1=N2 (disjoint?/yes M1*M022) _
                       (disjoint?/yes (disjoint/< M1*M022 N0+1+N1=N2)).

- : disjoint?-total*/< N0+1+N1=N2 (disjoint?/no M1^N3=D1 M022^N3=D2) _
                       (disjoint?/no (lookup/> M1^N3=D1 N3+1+N1=N4) M222^N4=D2)
    <- plus-total N3+1+N1=N4
    <- plus-swap-succ N3+1+N1=N4 N3+N1+1=N4
    <- plus-commutative N3+N1+1=N4 N1+1+N3=N4
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-preserves-lookup* M022^N3=D2 (shift/+ N1+1+N0=N2) N1+1+N3=N4
                               M222^N4=D2.

%worlds () (disjoint?-total*/< _ _ _ _).
%total { } (disjoint?-total*/< _ _ _ _).

- : disjoint?-total*/+ _ _ _ _ (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- disjoint?-total*/> N3+1+N2=N1 (disjoint?/yes disjoint/R) _ D?.

- : disjoint?-total*/+ _ _ SZ1 (size/+ SZ2) (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- disjoint?-total*/> N3+1+N2=N1 D?1 _ D?.

- : disjoint?-total*/> P (disjoint?/yes D) _ (disjoint?/yes (disjoint/> D P)).

- : disjoint?-total*/> N3+1+N2=N1 (disjoint?/no M311^N4=D1 M2^N4=D2) _
                       (disjoint?/no M111^N5=D1 (lookup/> M2^N4=D2 N4+1+N2=N5))
    <- plus-total N4+1+N2=N5
    <- plus-swap-succ N4+1+N2=N5 N4+N2+1=N5
    <- plus-commutative N4+N2+1=N5 N2+1+N4=N5
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- shift-preserves-lookup* M311^N4=D1 (shift/+ N2+1+N3=N1) N2+1+N4=N5
                               M111^N5=D1.

%worlds () (disjoint?-total*/> _ _ _ _).
%total { } (disjoint?-total*/> _ _ _ _).

%worlds () (disjoint?-total*/+ _ _ _ _ _ _ _).
%total [S1 S2] (disjoint?-total*/+ S1 S2 _ _ _ _ _).

%worlds () (disjoint?-total* _ _ _ _).
%total { } (disjoint?-total* _ _ _ _).

%abbrev disjoint?-total = disjoint?-total* _ _ _.



%%% Theorems about update


%theorem false-implies-update :
 forall* {M} {N} {D} {MP}
 forall {F:void}
 exists {U:update M N D MP}
 true.
%worlds () (false-implies-update _ %{=>}% M^N=D->MP).
%total {} (false-implies-update _ _).


%theorem update-respects-eq :
 forall* {M1} {N} {D} {M2} {M1P} {NP} {DP} {M2P}
 forall {U:update M1 N D M2} {EM1:eq M1 M1P}
               {EN:nat`eq N NP} {ED:inner-efxmap`eq D DP} {EM2:eq M2 M2P}
 exists {UP:update M1P NP DP M2P}
 true.
- : update-respects-eq U eq/ nat`eq/ inner-efxmap`eq/ eq/ U.
%worlds () (update-respects-eq M1^N=D->M2 M1=M1P N=NP D=DP M2=M2P
                        %{=>}% M1P^NP=DP->M2P).
%total {} (update-respects-eq _ _ _ _ _ _).
%reduces U = UP (update-respects-eq U _ _ _ _ UP).


%% a technical lemma to help prove reduction arguments

%theorem meta-reduces-update :
 forall* {M1} {M2} {N1} {N2} {D1} {D2} {M1P} {M2P}
 forall {F: void}
  {L1: update M1 N1 D1 M1P}
  {L2: update M2 N2 D2 M2P}
 true.

%worlds () (meta-reduces-update _ _ _).
%total { } (meta-reduces-update _ _ _).
%reduces X < Y (meta-reduces-update _ X Y).


%theorem update/=-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {M2}
 forall {U:update (map/+ N1 D1 M1) N2 D2 M2} {E:nat`eq N1 N2}
        exists {EM:eq (map/+ N2 D2 M1) M2}
 true.

- : update/=-inversion (update/= nat`eq/) nat`eq/ eq/.

- : update/=-inversion (update/< N3+1+N=N) nat`eq/ E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update/=-inversion (update/> U1022 N3+1+N=N) nat`eq/ E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

%worlds () (update/=-inversion _ _ _).
%total { } (update/=-inversion _ _ _).


%theorem update/<-inversion:
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
 forall {U:update (map/+ N1 D1 M1) N2 D2 M2} {P:plus (s N3) N2 N1}
 exists {E:eq (map/+ N2 D2 (map/+ N3 D1 M1)) M2}
 true.

- : update/<-inversion (update/= nat`eq/) N3+1+N=N E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update/<-inversion (update/< N3+1+N2=N1) N3P+1+N2=N1 E
    <- nat`plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- nat`succ-cancels N3P+1=N3+1 N3P=N3
    <- map/+-preserves-eq N3P=N3 inner-efxmap`eq/ eq/ M311P=M311
    <- map/+-preserves-eq nat`eq/ inner-efxmap`eq/ M311P=M311 E.

- : update/<-inversion (update/> _ N0+1+N1=N2) N3+1+N2=N1 E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (update/<-inversion _ _ _).
%total { } (update/<-inversion _ _ _).


%theorem update/>-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {M} {N0}
 forall {U:update (map/+ N1 D1 M1) N2 D2 M} {P:plus (s N0) N1 N2}
 exists {M2} {UP:update M1 N0 D2 M2} {E:eq (map/+ N1 D1 M2) M}
 true.

% a little more complex than might be expected
% because we want to prove reduction
- : update/>-inversion (U: update (map/+ N D1 M1) N D2 (map/+ N D2 M1))
                       N0+1+N=N M1 UP E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E
    <- false-implies-update F UP
    <- meta-reduces-update F UP U.

- : update/>-inversion
 (update/< N3+1+N2=N1: update (map/+ N1 D1 M1) N2 D2 _)
        N0+1+N1=N2 M1 UP E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-update F UP
    <- false-implies-eq F E
    <- meta-reduces-update
 F UP (update/< N3+1+N2=N1: update (map/+ N1 D1 M1) N2 D2 _).

- : update/>-inversion (update/> U N0+1+N1=N2) N0P+1+N1=N2 _ UP eq/
    <- nat`plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- nat`succ-cancels N0+1=N0P+1 N0=N0P
    <- update-respects-eq U eq/ N0=N0P inner-efxmap`eq/ eq/ UP.

%worlds () (update/>-inversion _ _ _ _ _).
%total { } (update/>-inversion _ _ _ _ _).
%reduces UP < U (update/>-inversion U _ _ UP _).


%theorem update-contradiction :
 forall* {M} {N} {D}
 forall {U: update M N D map/0}
 exists {F: void}
 true.

%worlds () (update-contradiction _ _).
%total { } (update-contradiction _ _).


%theorem update-deterministic :
 forall* {M1} {N1} {D1} {M1P} {M2} {N2} {D2} {M2P}
 forall {U1:update M1 N1 D1 M1P} {U2:update M2 N2 D2 M2P}
        {EM:eq M1 M2} {EN:nat`eq N1 N2} {ED:inner-efxmap`eq D1 D2}
 exists {EMP:eq M1P M2P}
 true.

%abbrev update-unique = update-deterministic.

- : update-deterministic update/0 update/0 eq/ nat`eq/ inner-efxmap`eq/ eq/.

- : update-deterministic (update/= nat`eq/) (update/= nat`eq/) eq/ nat`eq/ inner-efxmap`eq/ eq/.

- : update-deterministic (update/< N3+1+N2=N1) (update/< N3P+1+N2=N1)
                         eq/ nat`eq/ inner-efxmap`eq/ M1P=M2P
    <- plus-right-cancels N3+1+N2=N1 N3P+1+N2=N1 nat`eq/ nat`eq/ SN3=SN3P
    <- succ-cancels SN3=SN3P N3E
    <- map/+-preserves-eq N3E inner-efxmap`eq/ eq/ MM1=MM2
    <- map/+-preserves-eq nat`eq/ inner-efxmap`eq/ MM1=MM2 M1P=M2P.

- : update-deterministic (update/> F1^N0=D2->F2 N0+1+N1=N2)
                         (update/> F1^N0P=D2->F2P N0P+1+N1=N2)
                         eq/ nat`eq/ inner-efxmap`eq/ M1P=M2P
    <- plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- update-deterministic F1^N0=D2->F2 F1^N0P=D2->F2P eq/ N0=N0P
                            inner-efxmap`eq/ F2=F2P
    <- map/+-preserves-eq nat`eq/ inner-efxmap`eq/ F2=F2P M1P=M2P.

%% contradiction cases:
- : update-deterministic (update/= nat`eq/) (update/< N3+1+N=N) eq/ nat`eq/ inner-efxmap`eq/ E
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/= nat`eq/) (update/> _ N0+1+N=N) eq/ nat`eq/ inner-efxmap`eq/ E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/< N3+1+N=N) (update/= nat`eq/) eq/ nat`eq/ inner-efxmap`eq/ E
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/< N3+1+N2=N1) (update/> _ N0+1+N1=N2)
                         eq/ nat`eq/ inner-efxmap`eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

- : update-deterministic (update/> _ N0+1+N=N) (update/= nat`eq/) eq/ nat`eq/ inner-efxmap`eq/ E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/> _ N0+1+N1=N2) (update/< N3+1+N2=N1)
                         eq/ nat`eq/ inner-efxmap`eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (update-deterministic M1^N1=D1->M1P M2^N2=D2->M2P M1=M2 N1=N2 D1=D2
                          %{=>}% M1P=M2P).
%total (U) (update-deterministic U _ _ _ _ _).


%theorem update-total* :
 forall {M} {N} {D}
 exists {MP} {U:update M N D MP}
 true.

%% we need a mutually recursive lemma
%theorem update-map/+-total :
 forall {N1} {D1} {M1} {N2} {D2} {C} {CMP:nat`compare N1 N2 C}
 exists {M2} {U:update (map/+ N1 D1 M1) N2 D2 M2}
 true.

- : update-total* map/0 N D (map/+ N D map/0) update/0.

- : update-total* (map/+ N1 D1 M1) N2 D2 M2 U
    <- nat`compare-total* N1 N2 C CMP
    <- update-map/+-total N1 D1 M1 N2 D2 C CMP M2 U.

- : update-map/+-total N1 D1 M1 N2 D2 equal CMP (map/+ N2 D2 M1) (update/= N1=N2)
    <- equal-implies-eq CMP N1=N2.

- : update-map/+-total N1 D1 M1 N2 D2 less CMP (map/+ N1 D1 M1P)
                       (update/> U1 N0+1+N1=N2)
    <- less-implies-lt CMP N2>N1
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- update-total* M1 N0 D2 M1P U1.

- : update-map/+-total N1 D1 M1 N2 D2 greater CMP (map/+ N2 D2 (map/+ N3 D1 M1))
                       (update/< N3+1+N2=N1)
    <- greater-implies-gt CMP N1>N2
    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1.

%worlds () (update-total* M N D %{=>}% MP M^N=D->MP)
           (update-map/+-total _ _ _ _ _ _ _ _ _).
%total (M1 M2) (update-total* M1 _ _ _ _) (update-map/+-total _ _ M2 _ _ _ _ _ _).

%abbrev update-total = update-total* _ _ _ _.


%theorem lookup-implies-update :
        forall* {F} {N} {D}
        forall {L:lookup F N D}
        exists {U:update F N D F}
        true.

- : lookup-implies-update (lookup/= nat`eq/) (update/= nat`eq/).

- : lookup-implies-update (lookup/> L P) (update/> U P)
    <- lookup-implies-update L U.

%worlds () (lookup-implies-update _ _).
%total (L) (lookup-implies-update L _).


%theorem lookup-implies-fresh-update :
        forall* {M2} {N} {D}
        forall {L:lookup M2 N D}
 exists {M1}
  {F: fresh M1 N}
         {U:update M1 N D M2}
        true.

- : lookup-implies-fresh-update (lookup/= nat`eq/) _ fresh/0 update/0.

- : lookup-implies-fresh-update (lookup/= nat`eq/) _ (fresh/< GT) (update/< P)
    <- plus-total P
    <- plus-implies-gt P nat`eq/ GT.

- : lookup-implies-fresh-update (lookup/> L P) _ (fresh/> F P) (update/> U P)
    <- lookup-implies-fresh-update L _ F U.

%worlds () (lookup-implies-fresh-update _ _ _ _).
%total (L) (lookup-implies-fresh-update L _ _ _).


%theorem update-implies-lookup :
 forall* {F} {N} {D} {FP}
 forall {U:update F N D FP}
 exists {L:lookup FP N D}
 true.

- : update-implies-lookup update/0 (lookup/= nat`eq/).

- : update-implies-lookup (update/= nat`eq/) (lookup/= nat`eq/).

- : update-implies-lookup (update/< _) (lookup/= nat`eq/).

- : update-implies-lookup (update/> F^N0=D2->FP N0+1+N1=N2)
                          (lookup/> FP^N0=D2 N0+1+N1=N2)
    <- update-implies-lookup F^N0=D2->FP FP^N0=D2.

%worlds () (update-implies-lookup F^N=D->FP %{=>}% FP^N=D).
%total (U) (update-implies-lookup U _).


%theorem update-preserves-lookup :
 forall* {F} {N1} {D1} {FP} {N2} {D2}
 forall {L:lookup F N2 D2} {U:update F N1 D1 FP} {X:nat`ne N2 N1}
        exists {LP:lookup FP N2 D2}
 true.

%% update/0 is impossible

- : update-preserves-lookup (lookup/= nat`eq/) (update/= nat`eq/) N<>N LP
    <- nat`ne-anti-reflexive N<>N FALSE
    <- false-implies-lookup FALSE LP.

- : update-preserves-lookup (lookup/> L1 P1) (update/= nat`eq/) _ (lookup/> L1 P1).

- : update-preserves-lookup (lookup/= nat`eq/) (update/< N3+1+N2=N1) _
                            (lookup/> (lookup/= nat`eq/) N3+1+N2=N1).

- : update-preserves-lookup (lookup/> L N0+1+N1=N2P) (update/< N3+1+N2=N1) _
       (lookup/> (lookup/> L N0+1+N3=N4)
                 N4+1+N2=N2P)
    <- plus-left-decrease N3+1+N2=N1 N1-1 N1=N1-1+1 N3+N2=N1-1
    <- plus-right-increase N3+N2=N1-1 N3+N2+1=N1-1+1
    <- nat`eq-symmetric N1=N1-1+1 N1-1+1=N1
    <- plus-respects-eq N3+N2+1=N1-1+1 nat`eq/ nat`eq/ N1-1+1=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N0+1+N1=N2P N4 N0+1+N3=N4
                                N4+N2+1=N2P
    <- plus-swap-succ-converse N4+N2+1=N2P N4+1+N2=N2P.

- : update-preserves-lookup (lookup/= nat`eq/) (update/> _ _) _ (lookup/= nat`eq/).

- : update-preserves-lookup (lookup/> L N0+1+N1=N2)
                            ((update/> U N0P+1+N1=N2P)
                             : update (map/+ N1 D1 M1) N2P DP
                                      (map/+ N1 D1 M1P))
                            N2<>N2P
                            ((lookup/> LP N0+1+N1=N2)
                             : lookup (map/+ N1 D1 M1P) N2 D)
    <- plus-right-cancels-ne N0+1+N1=N2 N0P+1+N1=N2P nat`eq/ N2<>N2P N0+1<>N0P+1
    <- succ-preserves-ne-converse N0+1<>N0P+1 N0<>N0P
    <- update-preserves-lookup L U N0<>N0P LP.

%worlds () (update-preserves-lookup F^N2=D2 F^N1=D1->FP N1<>N2 FP^N2=D2).
%total (L) (update-preserves-lookup L _ _ _).


%theorem update-preserves-lookup-converse :
 forall* {F1} {N1} {D1} {F2} {N2} {D2}
 forall {L2:lookup F2 N2 D2} {U:update F1 N1 D1 F2} {X:nat`ne N2 N1}
        exists {L1:lookup F1 N2 D2}
 true.

- : update-preserves-lookup-converse (lookup/= nat`eq/) update/0 N<>N L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/= nat`eq/) N<>N
                                     L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/< N3+1+N2=N1)
                                     N<>N L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/> _ _) _
                                     (lookup/= nat`eq/).

- : update-preserves-lookup-converse (lookup/> L1 P) (update/= nat`eq/) _
                                     (lookup/> L1 P).

- : update-preserves-lookup-converse (lookup/> (lookup/= nat`eq/) N3+1+N2=N4)
                                     (update/< N3+1+N2=N1) _
                                     (lookup/= N1=N4)
    <- plus-deterministic N3+1+N2=N1 N3+1+N2=N4 nat`eq/ nat`eq/ N1=N4.

- : update-preserves-lookup-converse (lookup/> (lookup/> L1 N6+1+N3=N5)
                                               N5+1+N2=N4)
                                     (update/< N3+1+N2=N1) _
                                     (lookup/> L1 N6+1+N1=N4)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-swap-succ N5+1+N2=N4 N5+N2+1=N4
    <- plus-associative* N6+1+N3=N5 N5+N2+1=N4 N3+N2+1=N1 N6+1+N1=N4.

- : update-preserves-lookup-converse (lookup/> L2 N5+1+N1=N4)
                                     (update/> U1 N0+1+N1=N2) N4<>N2
                                     (lookup/> L1 N5+1+N1=N4)
    <- plus-right-cancels-ne N5+1+N1=N4 N0+1+N1=N2 nat`eq/ N4<>N2 N5+1<>N0+1
    <- succ-preserves-ne-converse N5+1<>N0+1 N5<>N0
    <- update-preserves-lookup-converse L2 U1 N5<>N0 L1.

%worlds () (update-preserves-lookup-converse _ _ _ _).
%total (L) (update-preserves-lookup-converse L _ _ _).


%theorem update-preserves-fresh :
 forall* {M1} {N1} {N2} {D} {M2}
 forall {F1:fresh M1 N1} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
 exists {F2:fresh M2 N1}
 true.

- : update-preserves-fresh fresh/0 update/0 (nat`ne/< N>M) (fresh/< N>M).

- : update-preserves-fresh fresh/0 update/0 (nat`ne/> M>N)
                           (fresh/> fresh/0 M1+1+N=M)
    <- gt-implies-plus M>N M1 M1+1+N=M.

- : update-preserves-fresh (fresh/< N>M) (update/= nat`eq/) _ (fresh/< N>M).

- : update-preserves-fresh (fresh/< N1>M) (update/< N3+1+N2=N1) (nat`ne/< N2>M)
                           (fresh/< N2>M).

- : update-preserves-fresh (fresh/< N1>M) (update/< N3+1+N2=N1) (nat`ne/> M>N2)
                           (fresh/> (fresh/< N3>M1) M1+1+N2=M)
    <- gt-implies-plus M>N2 M1 M1+1+N2=M
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-swap-succ M1+1+N2=M M1+N2+1=M
    <- plus-right-cancels-gt N3+N2+1=N1 M1+N2+1=M nat`eq/ N1>M N3>M1.

- : update-preserves-fresh (fresh/< N1>M) (update/> _ _) _ (fresh/< N1>M).

- : update-preserves-fresh (fresh/> F P) (update/= nat`eq/) _ (fresh/> F P).

- : update-preserves-fresh (fresh/> F M1+1+N1=M) (update/< N3+1+N2=N1) _
                           (fresh/> (fresh/> F M1+1+N3=MM) MM+1+N2=M)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 M1+1+N1=M MM M1+1+N3=MM
                                 MM+N2+1=M
    <- plus-swap-succ-converse MM+N2+1=M MM+1+N2=M.

- : update-preserves-fresh (fresh/> F M1+1+N1=M) (update/> U N0+1+N1=N2) M<>N2
                           (fresh/> FP M1+1+N1=M)
    <- plus-right-cancels-ne M1+1+N1=M N0+1+N1=N2 nat`eq/ M<>N2 M1+1<>N0+1
    <- succ-preserves-ne-converse M1+1<>N0+1 M1<>N0
    <- update-preserves-fresh F U M1<>N0 FP.

%worlds () (update-preserves-fresh N1-fresh-M1 M1^N2=D->M2 N1<>N2 N1-fresh-M2).
%total (F) (update-preserves-fresh F _ _ _).


%theorem update-preserves-fresh-converse :
 forall* {M1} {N1} {N2} {D} {M2}
 forall {F1:fresh M2 N1} {U:update M1 N2 D M2}
 exists {F2:fresh M1 N1}
 true.

%theorem update-preserves-fresh-converse-helper :
 forall* {M1} {N1} {N2} {D} {M2} {B} {B2}
 forall {F1:fresh M2 N1} {U:update M1 N2 D M2}
               {D:domain? M1 N1 B} {E:nat`eq? N1 N2 B2}
 exists {F2:fresh M1 N1}
 true.

- : update-preserves-fresh-converse-helper _ _ (domain?/out F) _ F.

- : update-preserves-fresh-converse-helper F2 U (domain?/in L1) (nat`eq?/no N) F1
    <- update-preserves-lookup L1 U N L2
    <- fresh-lookup-not-equal F2 L2 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-fresh F F1.

- : update-preserves-fresh-converse-helper F2 U _ nat`eq?/yes F1
    <- update-implies-lookup U L2
    <- fresh-lookup-not-equal F2 L2 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-fresh F F1.

%worlds () (update-preserves-fresh-converse-helper _ _ _ _ _).
%total { } (update-preserves-fresh-converse-helper _ _ _ _ _).

- : update-preserves-fresh-converse F2 U F1
    <- domain?-total D
    <- nat`eq?-total E
    <- update-preserves-fresh-converse-helper F2 U D E F1.

%worlds () (update-preserves-fresh-converse _ _ _).
%total { } (update-preserves-fresh-converse _ _ _).


%theorem update-is-cause-of-change :
 forall* {M1} {N1} {N2} {M2} {D1} {D2}
 forall {F:fresh M1 N1}
        {U:update M1 N2 D2 M2}
        {L:lookup M2 N1 D1}
 exists {EN:nat`eq N1 N2} {ED:inner-efxmap`eq D1 D2}
 true.

%theorem update-is-cause-of-change/L :
 forall* {M1} {N1} {N2} {M2} {D1} {D2} {B}
 forall {F:fresh M1 N1}
        {U:update M1 N2 D2 M2}
        {L:lookup M2 N1 D1}
        {E:nat`eq? N1 N2 B}
 exists {EN:nat`eq N1 N2} {ED:inner-efxmap`eq D1 D2}
 true.

- : update-is-cause-of-change F U L EN ED
     <- nat`eq?-total E?
     <- update-is-cause-of-change/L F U L E? EN ED.

- : update-is-cause-of-change/L F U L (nat`eq?/yes) nat`eq/ ED
    <- update-implies-lookup U LP
    <- lookup-deterministic L LP eq/ nat`eq/ ED.

- : update-is-cause-of-change/L F U L (nat`eq?/no N1<>N2) EN ED
    <- update-preserves-fresh F U N1<>N2 FP
    <- fresh-lookup-not-equal FP L N1<>N1
    <- nat`ne-anti-reflexive N1<>N1 V
    <- nat`false-implies-eq V EN
    <- inner-efxmap`false-implies-eq V ED.

%worlds () (update-is-cause-of-change/L _ _ _ _ _ _).
%total { } (update-is-cause-of-change/L _ _ _ _ _ _).

%worlds () (update-is-cause-of-change _ _ _ _ _).
%total { } (update-is-cause-of-change _ _ _ _ _).


%theorem update-preserves-membership :
 forall* {M1} {N1} {B} {N2} {D} {M2}
 forall {MD1:domain? M1 N1 B} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
 exists {MD2:domain? M2 N1 B}
 true.

- : update-preserves-membership (domain?/in L) U NE (domain?/in LP)
    <- update-preserves-lookup L U NE LP.

- : update-preserves-membership (domain?/out F) U NE (domain?/out FP)
    <- update-preserves-fresh F U NE FP.

%worlds () (update-preserves-membership _ _ _ _).
%total {} (update-preserves-membership _ _ _ _).


%theorem update-preserves-membership-converse :
 forall* {M1} {N1} {B} {N2} {D} {M2}
 forall {MD2:domain? M2 N1 B} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
 exists {MD1:domain? M1 N1 B}
 true.

- : update-preserves-membership-converse (domain?/in L2) U NE (domain?/in L1)
    <- update-preserves-lookup-converse L2 U NE L1.

- : update-preserves-membership-converse (domain?/out F2) U NE (domain?/out F1)
    <- update-preserves-fresh-converse F2 U F1.

%worlds () (update-preserves-membership-converse _ _ _ _).
%total { } (update-preserves-membership-converse _ _ _ _).


%theorem lookup-update-preserves-membership :
 forall* {M1} {N1} {B} {N2} {D1} {D2} {M2}
 forall {MD1:domain? M1 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
 exists {MD2:domain? M2 N1 B}
 true.

%theorem lookup-update-preserves-membership/L :
 forall* {M1} {N1} {B} {N2} {D1} {D2} {M2} {B2}
 forall {MD1:domain? M1 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
        {EQ?:nat`eq? N1 N2 B2}
 exists {MD2:domain? M2 N1 B}
 true.

- : lookup-update-preserves-membership/L MD1 _ Ux1 (nat`eq?/no N1<>N2) MD2
    <- update-preserves-membership MD1 Ux1 N1<>N2 MD2.

- : lookup-update-preserves-membership/L
 (domain?/in _) _ U (nat`eq?/yes) (domain?/in L2)
    <- update-implies-lookup U L2.

- : lookup-update-preserves-membership/L
 (domain?/out F1) L1 _ nat`eq?/yes (domain?/out F2)
    <- fresh-lookup-not-equal F1 L1 NE
    <- nat`ne-anti-reflexive NE F
    <- false-implies-fresh F F2.

%worlds () (lookup-update-preserves-membership/L _ _ _ _ _).
%total { } (lookup-update-preserves-membership/L _ _ _ _ _).

- : lookup-update-preserves-membership MD1 L1 U MD2
    <- nat`eq?-total EQUAL?
    <- lookup-update-preserves-membership/L MD1 L1 U EQUAL? MD2.

%worlds () (lookup-update-preserves-membership _ _ _ _).
%total { } (lookup-update-preserves-membership _ _ _ _).


%theorem lookup-update-preserves-membership-converse :
 forall* {M1} {N1} {B} {N2} {D1} {D2} {M2}
 forall {MD1:domain? M2 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
 exists {MD2:domain? M1 N1 B}
 true.

- : lookup-update-preserves-membership-converse MD2 ML MU MD1
    <- domain?-total MD1P
    <- lookup-update-preserves-membership MD1P ML MU MD2P
    <- domain?-deterministic MD2P MD2 eq/ nat`eq/ BP=B
    <- domain?-respects-eq MD1P eq/ nat`eq/ BP=B MD1.

%worlds () (lookup-update-preserves-membership-converse _ _ _ _).
%total { } (lookup-update-preserves-membership-converse _ _ _ _).


%theorem update-preserves-in-domain :
 forall* {M1} {N1} {N2} {D} {M2}
 forall {MD1:domain? M1 N1 true} {U:update M1 N2 D M2}
 exists {MD2:domain? M2 N1 true}
 true.

%theorem update-preserves-in-domain/L :
 forall* {M1} {N1} {N2} {D} {M2} {B}
 forall {MD1:domain? M1 N1 true} {U:update M1 N2 D M2}
        {E: nat`eq? N1 N2 B}
 exists {MD2:domain? M2 N1 true}
 true.

- : update-preserves-in-domain/L
 (domain?/in ML1) U (nat`eq?/no N1<>N2) (domain?/in ML2)
    <- update-preserves-lookup ML1 U N1<>N2 ML2.

- : update-preserves-in-domain/L _ U (nat`eq?/yes) (domain?/in ML)
    <- update-implies-lookup U ML.

%worlds () (update-preserves-in-domain/L _ _ _ _).
%total { } (update-preserves-in-domain/L _ _ _ _).

- : update-preserves-in-domain MD1 U MD2
    <- nat`eq?-total E
    <- update-preserves-in-domain/L MD1 U E MD2.

%worlds () (update-preserves-in-domain _ _ _).
%total { } (update-preserves-in-domain _ _ _).


%theorem shift-preserves-update :
 forall* {M1} {N1} {D} {M1P} {N0} {M2}
 forall {U1:update M1 N1 D M1P}
               {S:shift N0 M1 M2}
        exists {N2} {M2P}
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
               {U2:update M2 N2 D M2P}
 true.

- : shift-preserves-update update/0 shift/0 _ _ P (shift/+ P) update/0
    <- plus-total P.

- : shift-preserves-update (update/= nat`eq/) (shift/+ P) _ _ P (shift/+ P)
                           (update/= nat`eq/).

- : shift-preserves-update (update/< N4+1+N1=N3) (shift/+ N0+1+N3=N5) _ _
                           N0+1+N1=N2 (shift/+ N0+1+N1=N2)
                           (update/< N4+1+N2=N5)
    <- plus-commutative N4+1+N1=N3 N1+N4+1=N3
    <- plus-associative-converse N1+N4+1=N3 N0+1+N3=N5 _ N0+1+N1=N2 N2+N4+1=N5
    <- plus-commutative N2+N4+1=N5 N4+1+N2=N5.

- : shift-preserves-update (update/> U N4+1+N3=N1) (shift/+ N0+1+N3=N5) _ _
                           N0+1+N1=N2 (shift/+ N0+1+N3=N5)
                           (update/> U N4+1+N5=N2)
   <- plus-total N0+1+N1=N2
   <- plus-commutative N4+1+N3=N1 N3+N4+1=N1
   <- plus-associative-converse* N3+N4+1=N1 N0+1+N1=N2 N0+1+N3=N5 N5+N4+1=N2
   <- plus-commutative N5+N4+1=N2 N4+1+N5=N2.

%worlds () (shift-preserves-update _ _ _ _ _ _ _).
%total { } (shift-preserves-update _ _ _ _ _ _ _).


%theorem shift-preserves-update* :
 forall* {M1} {N1} {D} {M1P} {N0} {M2} {N2} {M2P}
 forall {U1:update M1 N1 D M1P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
        exists {U2:update M2 N2 D M2P}
 true.

- : shift-preserves-update* U1 S P SS U2
    <- shift-preserves-update U1 S _ _ PP SSP U2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- shift-deterministic SSP SS nat`eq/ eq/ M2P=M2
    <- update-respects-eq U2P eq/ N2P=N2 inner-efxmap`eq/ M2P=M2 U2.

%worlds () (shift-preserves-update* _ _ _ _ _).
%total { } (shift-preserves-update* _ _ _ _ _).


%theorem shift-preserves-update-converse :
 forall* {M1} {N1} {D} {N0} {M2} {N2} {M2P}
        forall {U2:update M2 N2 D M2P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
        exists {M1P} {SS:shift N0 M1P M2P}
        {U1:update M1 N1 D M1P}
 true.

- : shift-preserves-update-converse U2 S P _ SS U1
    <- update-total U1
    <- shift-preserves-update U1 S _ _ PP SSP U2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- update-deterministic U2P U2 eq/ N2P=N2 inner-efxmap`eq/ M2P=M2
    <- shift-respects-eq SSP nat`eq/ eq/ M2P=M2 SS.

%worlds () (shift-preserves-update-converse _ _ _ _ _ _).
%total { } (shift-preserves-update-converse _ _ _ _ _ _).


%theorem shift-preserves-update-converse* :
 forall* {M1} {N1} {D} {N0} {M2} {N2} {M2P} {M1P}
        forall {U2:update M2 N2 D M2P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
 exists {U1:update M1 N1 D M1P}
 true.

- : shift-preserves-update-converse* U2 S P SS U1
    <- shift-preserves-update-converse U2 S P _ SSP U1P
    <- shift-cancels SSP SS nat`eq/ eq/ E
    <- update-respects-eq U1P eq/ nat`eq/ inner-efxmap`eq/ E U1.

%worlds () (shift-preserves-update-converse* _ _ _ _ _).
%total { } (shift-preserves-update-converse* _ _ _ _ _).

%theorem update-commutes-shift-converse :
 forall* {M2} {N2} {D} {M2P} {N0} {M1P}
        forall {U2:update M2 N2 D M2P}
               {SS:shift N0 M1P M2P}
        exists {N1} {M1}
               {P:plus (s N0) N1 N2}
               {S:shift N0 M1 M2}
        {U1:update M1 N1 D M1P}
 true.

- : update-commutes-shift-converse
 update/0 (shift/+ P) _ _ P shift/0 update/0.

- : update-commutes-shift-converse
 (update/= nat`eq/) (shift/+ P) _ _ P (shift/+ P)
 (update/= nat`eq/).

- : update-commutes-shift-converse
 (update/< D1+1+N=N1) (shift/+ D2+1+N2=N) _ _ D2+1+N2=N
 (shift/+ D2+1+N0=N1) (update/< D1+1+N2=N0)
    <- plus-commutative D2+1+N2=N N2+D2+1=N
    <- plus-associative-converse N2+D2+1=N D1+1+N=N1 N0 D1+1+N2=N0 N0+D2+1=N1
    <- plus-commutative N0+D2+1=N1 D2+1+N0=N1.

- : update-commutes-shift-converse
 (update/> U D1+1+N=N1) (shift/+ D2+1+N2=N) _ _ D2+1+N0=N1
 (shift/+ D2+1+N2=N) (update/> U D1+1+N2=N0)
    <- plus-commutative D2+1+N2=N N2+D2+1=N
    <- plus-associative-converse N2+D2+1=N D1+1+N=N1 N0 D1+1+N2=N0 N0+D2+1=N1
    <- plus-commutative N0+D2+1=N1 D2+1+N0=N1.

%worlds () (update-commutes-shift-converse _ _ _ _ _ _ _).
%total { } (update-commutes-shift-converse _ _ _ _ _ _ _).


%theorem fresh-update-preserves-lookup :
 forall* {M} {N1} {D1} {MP} {N2} {D2}
 forall {L:lookup M N2 D2} {F: fresh M N1} {U:update M N1 D1 MP}
        exists {LP:lookup MP N2 D2}
 true.

- : fresh-update-preserves-lookup L F U LP
    <- fresh-lookup-not-equal F L NE
    <- nat`ne-symmetric NE NEs
    <- update-preserves-lookup L U NEs LP.

%worlds () (fresh-update-preserves-lookup _ _ _ _).
%total { } (fresh-update-preserves-lookup _ _ _ _).


%theorem fresh-update-increases-size :
 forall* {M1} {S} {N} {D} {M2}
 forall {S1: size M1 S}
  {F: fresh M1 N}
  {U: update M1 N D M2}
 exists {S2: size M2 (s S)}
 true.

- : fresh-update-increases-size size/0 fresh/0 update/0 (size/+ size/0).

- : fresh-update-increases-size (size/+ S) (fresh/< G) U SP
    <- gt-implies-plus G _ P
    <- update/<-inversion U P E
    <- size-respects-eq (size/+ (size/+ S)) E nat`eq/ SP.

- : fresh-update-increases-size (size/+ S) (fresh/> F P) U SPP
    <- update/>-inversion U P _ UP E
    <- fresh-update-increases-size S F UP SP
    <- size-respects-eq (size/+ SP) E nat`eq/ SPP.

%worlds () (fresh-update-increases-size _ _ _ _).
%total (F) (fresh-update-increases-size F _ _ _).


%theorem fresh-update-increases-size-converse :
 forall* {M1} {S} {N} {D} {M2}
 forall {S2: size M2 (s S)}
  {F: fresh M1 N}
  {U: update M1 N D M2}
 exists {S1: size M1 S}
 true.

- : fresh-update-increases-size-converse S2 F U S1
    <- size-total S1P
    <- fresh-update-increases-size S1P F U S2P
    <- size-deterministic S2P S2 eq/ SNP=SN
    <- succ-cancels SNP=SN NP=N
    <- size-respects-eq S1P eq/ NP=N S1.

%worlds () (fresh-update-increases-size-converse _ _ _ _).
%total { } (fresh-update-increases-size-converse _ _ _ _).


%theorem fresh-update-preserves-disjoint :
 forall* {M1} {M2} {N} {D} {M2P}
 forall {I: disjoint M1 M2}
  {F: fresh M1 N}
  {U: update M2 N D M2P}
 exists {DP: disjoint M1 M2P}
 true.

%theorem fresh-update-preserves-disjoint/L :
 forall* {M1} {M2} {N} {D} {M2P} {B}
 forall {I: disjoint M1 M2}
  {F: fresh M1 N}
  {U: update M2 N D M2P}
  {D?: disjoint? M1 M2P B}
 exists {DP: disjoint M1 M2P}
 true.

- : fresh-update-preserves-disjoint/L _ _ _ (disjoint?/yes DJ) DJ.

- : fresh-update-preserves-disjoint/L D FR U (disjoint?/no L1 L2P) DP
    <- fresh-lookup-not-equal FR L1 NE
    <- nat`ne-symmetric NE NEs
    <- update-preserves-lookup-converse L2P U NEs L2
    <- disjoint-lookup-contradiction D L1 L2 F
    <- false-implies-disjoint F DP.

%worlds () (fresh-update-preserves-disjoint/L _ _ _ _ _).
%total { } (fresh-update-preserves-disjoint/L _ _ _ _ _).

- : fresh-update-preserves-disjoint D F U DP
    <- disjoint?-total D?
    <- fresh-update-preserves-disjoint/L D F U D? DP.

%worlds () (fresh-update-preserves-disjoint _ _ _ _).
%total { } (fresh-update-preserves-disjoint _ _ _ _).


%theorem update-overwrites :
 forall* {M1} {N1} {D1} {M2} {N2} {D2} {M3}
 forall {U1:update M1 N1 D1 M2} {U2:update M2 N2 D2 M3}
        {E:nat`eq N1 N2}
 exists {U12:update M1 N1 D2 M3}
 true.

- : update-overwrites (update/0) (update/= nat`eq/) nat`eq/ (update/0).

- : update-overwrites (update/= nat`eq/) (update/= nat`eq/) nat`eq/ (update/= nat`eq/).

- : update-overwrites (update/< P) (update/= nat`eq/) nat`eq/ (update/< P).

- : update-overwrites (update/> U1 P) (update/> U2 PP) nat`eq/ (update/> U3 P)
    <- plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- update-overwrites U1 U2 N0=N0P U3.

%% contradiction cases
- : update-overwrites (update/0) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/0) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/= nat`eq/) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/= nat`eq/) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/< _) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/< _) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/> _ N0+1+N=N) (update/= nat`eq/) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/> _ N0+1+N1=N2) (update/< N3+1+N2=N1) nat`eq/ U
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-update F U.

%worlds () (update-overwrites M1^N1=D1->M2 M2^N2=D2->M3 N1=N2
                       %{=>}% M1^N1=D2->M3).
%total (U) (update-overwrites U _ _ _).


%theorem update-overwrites-converse :
 forall* {M1} {N1} {D1} {M2} {D2} {M3}
 forall {U12:update M1 N1 D1 M3} {U1:update M1 N1 D2 M2}
 exists {U2:update M2 N1 D1 M3}
 true.

- : update-overwrites-converse U12 U1 U2
    <- update-total U2P
    <- update-overwrites U1 U2P nat`eq/ U12P
    <- update-deterministic U12P U12 eq/ nat`eq/ inner-efxmap`eq/ M2P=M2
    <- update-respects-eq U2P eq/ nat`eq/ inner-efxmap`eq/ M2P=M2 U2.

%worlds () (update-overwrites-converse _ _ _).
%total { } (update-overwrites-converse _ _ _).


%theorem update-may-have-no-effect :
 forall* {M1} {N} {D} {M2}
 forall {L:lookup M1 N D} {U:update M1 N D M2}
 exists {E:eq M1 M2}
 true.

- : update-may-have-no-effect (lookup/= nat`eq/) U E
    <- update/=-inversion U nat`eq/ E.

- : update-may-have-no-effect (lookup/> L1 N0+1+N1=N2) U E
    <- update/>-inversion U N0+1+N1=N2 _ U1 M112=M2
    <- update-may-have-no-effect L1 U1 M1=M2
    <- map/+-preserves-eq nat`eq/ inner-efxmap`eq/ M1=M2 M111=M112
    <- eq-transitive M111=M112 M112=M2 E.

%worlds () (update-may-have-no-effect _ _ _).
%total (L) (update-may-have-no-effect L _ _).


%theorem update-idempotent :
 forall* {M1} {N1} {D1} {M2} {N2} {D2} {M3}
 forall {U1:update M1 N1 D1 M2} {U2:update M2 N2 D2 M3}
        {EN:nat`eq N1 N2} {ED:inner-efxmap`eq D1 D2}
 exists {EM:eq M2 M3}
 true.

- : update-idempotent U1 U2 nat`eq/ inner-efxmap`eq/ M2=M3
    <- update-overwrites U1 U2 nat`eq/ M1^N=D->M3
    <- update-deterministic U1 M1^N=D->M3 eq/ nat`eq/ inner-efxmap`eq/ M2=M3.

%worlds () (update-idempotent M1^N1=D1->M2 M2^N2=D2->M3 N1=N2 D1=D2
                       %{=>}% M2=M3).
%total {} (update-idempotent _ _ _ _ _).


%theorem update-commutes :
 forall* {M} {N1} {D1} {M1} {N2} {D2} {M12}
 forall {U1:update M N1 D1 M1} {U12:update M1 N2 D2 M12}
               {NE:nat`ne N1 N2}
        exists {M2} {U2:update M N2 D2 M2} {U21:update M2 N1 D1 M12}
 true.

- : update-commutes update/0 (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes update/0 (update/< NP+1+N2=N1) _ _ update/0
                    (update/> update/0 NP+1+N2=N1).

- : update-commutes update/0 (update/> update/0 NP+1+N1=N2) _ _ update/0
                    (update/< NP+1+N1=N2).

- : update-commutes (update/= nat`eq/) (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes (update/= nat`eq/) (update/< NP+1+N2=N1) _ _
                    (update/< NP+1+N2=N1) (update/> (update/= nat`eq/) NP+1+N2=N1).

- : update-commutes (update/= nat`eq/) (update/> U NP+1+N1=N2) _ _
                    (update/> U NP+1+N1=N2) (update/= nat`eq/).

- : update-commutes (update/< _) (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes (update/< N1P+1+N1=N) (update/< N2P+1+N2=N1) _ _
                    (update/< N2PP+1+N2=N)
                    (update/> (update/< N1P+1+N2P=N2PP) N2P+1+N2=N1)
    <- plus-swap-succ N2P+1+N2=N1 N2P+N2+1=N1
    <- plus-associative-converse N2P+N2+1=N1 N1P+1+N1=N
                                 N2PP N1P+1+N2P=N2PP N2PP+N2+1=N
    <- plus-swap-succ-converse N2PP+N2+1=N N2PP+1+N2=N.

- : update-commutes ((update/< N11+1+N1=N):update (map/+ N D M) _ _ _)
                  (update/> (update/= nat`eq/) N11+1+N1=N2) _
                    (map/+ N2 D2 M)
                    (update/= N=N2)
                    ((update/< N11+1+N1=N2):update _ N1 D1 _)
    <- plus-deterministic N11+1+N1=N N11+1+N1=N2 nat`eq/ nat`eq/ N=N2.

- : update-commutes (update/< N11+1+N1=N)
                    (update/> (update/< N2PP+1+N2P=N11) N2P+1+N1=N2) _ _
                    (update/< N2PP+1+N2=N) (update/< N2P+1+N1=N2)
    <- plus-swap-succ N11+1+N1=N N11+N1+1=N
    <- plus-swap-succ N2P+1+N1=N2 N2P+N1+1=N2
    <- plus-associative* N2PP+1+N2P=N11 N11+N1+1=N N2P+N1+1=N2
                         N2PP+1+N2=N.

- : update-commutes (update/< N11+1+N1=N)
                    (update/> (update/> U N2PP+1+N11=N2P) N2P+1+N1=N2) _ _
                    (update/> U N2PP+1+N=N2) (update/< N11+1+N1=N)
    <- plus-swap-succ N11+1+N1=N N11+N1+1=N
    <- plus-swap-succ N2P+1+N1=N2 N2P+N1+1=N2
    <- plus-associative* N2PP+1+N11=N2P N2P+N1+1=N2 N11+N1+1=N N2PP+1+N=N2.

- : update-commutes (update/> U N11+1+N=N1) (update/= nat`eq/) _ _
                    (update/= nat`eq/) (update/> U N11+1+N=N1).

- : update-commutes (update/> U N11+1+N=N1) (update/< N2P+1+N2=N) _ _
                    (update/< N2P+1+N2=N)
      (update/> (update/> U N11+1+N2P=N11P) N11P+1+N2=N1)
    <- plus-swap-succ N2P+1+N2=N N2P+N2+1=N
    <- plus-associative-converse N2P+N2+1=N N11+1+N=N1
                                 N11P N11+1+N2P=N11P N11P+N2+1=N1
    <- plus-swap-succ-converse N11P+N2+1=N1 N11P+1+N2=N1.

- : update-commutes (update/> U1 N11+1+N=N1) (update/> U12 N2P+1+N=N2) N1<>N2
                    (map/+ N D M2)
           (update/> U2 N2P+1+N=N2) (update/> U21 N11+1+N=N1)
    <- plus-right-cancels-ne N11+1+N=N1 N2P+1+N=N2 nat`eq/ N1<>N2 N11+1<>N2P+1
    <- succ-preserves-ne-converse N11+1<>N2P+1 N11<>N2P
    <- update-commutes U1 U12 N11<>N2P M2 U2 U21.

%worlds () (update-commutes M^N1=D1->M1 M1^D2=N2->M12 N1<>N2
                     %{=>}% M2 M^N2=D2->M2 M2^N1=D1->M12).
%total (U1) (update-commutes U1 _ _ _ _ _).


%theorem update-commutes* :
 forall* {M} {N1} {D1} {M1} {N2} {D2} {M12} {M2}
 forall {U1:update M N1 D1 M1} {U12:update M1 N2 D2 M12}
               {NE:nat`ne N1 N2} {U2:update M N2 D2 M2}
        exists {U21:update M2 N1 D1 M12}
 true.

- : update-commutes* M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 M^N2=D2->M2 M2^N1=D1->M12
    <- update-commutes M^N1=D1->M1 M1^D2=N2->M12 N1<>N2
                       M2P M^N2=D2->M2P M2P^N1=D1->M12
    <- update-deterministic M^N2=D2->M2P M^N2=D2->M2 eq/ nat`eq/
                            inner-efxmap`eq/ M2P=M2
    <- update-respects-eq M2P^N1=D1->M12 M2P=M2 nat`eq/
                            inner-efxmap`eq/ eq/ M2^N1=D1->M12.

%worlds () (update-commutes* M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 M^N2=D2->M2
                      %{=>}% M2^N1=D1->M12).
%total {} (update-commutes* _ _ _ _ _).


%theorem fresh-update-cancels :
 forall* {M1} {N1} {D1} {M1P}
  {M2} {N2} {D2} {M2P}
 forall {F1: fresh M1 N1}
  {U1: update M1 N1 D1 M1P}
  {F2: fresh M2 N2}
  {U2: update M2 N2 D2 M2P}
  {NE: nat`eq N1 N2}
  {EQP: eq M1P M2P}
 exists {DE: inner-efxmap`eq D1 D2}
  {EQ: eq M1 M2}
 true.

% can never be update/=
- : fresh-update-cancels _ _ FR (update/= nat`eq/) _ eq/ DE E
    <- fresh-contradiction FR F
    <- inner-efxmap`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels FR (update/= nat`eq/) _ _ _ eq/ DE E
    <- fresh-contradiction FR F
    <- inner-efxmap`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels fresh/0 update/0 _ update/0 nat`eq/ eq/ inner-efxmap`eq/ eq/.

- : fresh-update-cancels fresh/0 update/0
 FR (update/> _ P) nat`eq/ eq/ DE E
    <- plus-implies-gt P nat`eq/ GT
    <- gt-anti-reflexive GT F
    <- inner-efxmap`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels
     (fresh/< GT1) U1 (fresh/< GT2) U2 nat`eq/ eq/ DEX E
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 _ DEX EQ12R
    <- map/+-preserves-eq-converse EQ12R NP1=NP2 DE RE
    <- succ-deterministic NP1=NP2 SNP1=SNP2
    <- plus-deterministic P1 P2 SNP1=SNP2 nat`eq/ N1=N2
    <- map/+-preserves-eq N1=N2 DE RE E.

- : fresh-update-cancels
     (fresh/< GT1) U1 (fresh/> _ P2) U2 nat`eq/ eq/ DE E
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- update/>-inversion U2 P2 _ _ EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 _ _
    <- plus-implies-gt P2 nat`eq/ NP1>NP2
    <- gt-respects-eq NP1>NP2 NP1=NP2 nat`eq/ NP2>NP2
    <- gt-anti-reflexive NP2>NP2 F
    <- inner-efxmap`false-implies-eq F DE
    <- false-implies-eq F E.

- : fresh-update-cancels
 (fresh/> F1 P1) UP1 (fresh/> F2 P2) UP2 nat`eq/ eq/ DE E
    <- update/>-inversion UP1 P1 _ U1 EQ1
    <- update/>-inversion UP2 P2 _ U2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 D1=D2 MP1=MP2
    <- plus-right-cancels P1 P2 NP1=NP2 nat`eq/ SN1=SN2
    <- succ-cancels SN1=SN2 N1=N2
    <- fresh-update-cancels F1 U1 F2 U2 N1=N2 MP1=MP2 DE M1=M2
    <- map/+-preserves-eq NP1=NP2 D1=D2 M1=M2 E.

- : fresh-update-cancels
 (fresh/> F1 P1) UP1 (fresh/< GT2) UP2 nat`eq/ eq/ DE E
    <- update/>-inversion UP1 P1 _ _ EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion UP2 P2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 _ _
    <- plus-implies-gt P1 nat`eq/ NP2>NP1
    <- gt-respects-eq NP2>NP1 nat`eq/ NP1=NP2 NP2>NP2
    <- gt-anti-reflexive NP2>NP2 F
    <- inner-efxmap`false-implies-eq F DE
    <- false-implies-eq F E.

%worlds () (fresh-update-cancels _ _ _ _ _ _ _ _).
%total (F) (fresh-update-cancels F _ _ _ _ _ _ _).


% not exactly a converse, but very useful nonetheless
%theorem update-commutes-converse :
 forall* {M2} {N1} {D1} {M1} {N2} {D2} {M3}
 forall {U1:update M2 N1 D1 M3} {U2:update M1 N2 D2 M3}
         {NE:nat`ne N1 N2}
        exists {M0}
  {UX1:update M0 N2 D2 M2} {UX2:update M0 N1 D1 M1}
 true.

%theorem update-commutes-converse/L :
 forall* {M2} {N1} {D1} {M1} {N2} {D2} {M3} {B}
 forall {U1:update M2 N1 D1 M3} {U2:update M1 N2 D2 M3}
         {NE:nat`ne N1 N2}
  {MD?: domain? M2 N1 B}
        exists {M0}
  {UX1:update M0 N2 D2 M2} {UX2:update M0 N1 D1 M1}
 true.

- : update-commutes-converse/L U23 U13 N1<>N2 (domain?/out F2) _ U02 U01
    <- update-implies-lookup U23 L31
    <- update-preserves-lookup-converse L31 U13 N1<>N2 L11
    <- lookup-implies-fresh-update L11 M0 F01 U01
    <- update-commutes U01 U13 N1<>N2 M2X U02X U2X3
    <- update-preserves-fresh F01 U02X N1<>N2 F2X
    <- fresh-update-cancels F2X U2X3 F2 U23 nat`eq/ eq/ _ M2X=M2
    <- update-respects-eq U02X eq/ nat`eq/ inner-efxmap`eq/ M2X=M2 U02.

- : update-commutes-converse/L U23 U13 N1<>N2 (domain?/in L2) _ U02 U01
    <- update-implies-lookup U23 L31
    <- update-preserves-lookup-converse L31 U13 N1<>N2 L11
    <- lookup-implies-fresh-update L11 M0X F0X1 U0X1
    <- update-commutes U0X1 U13 N1<>N2 M2X U0X2X U2X3
    <- lookup-implies-update L2 U22
    <- update-overwrites-converse U22 U23 U32
    <- update-overwrites U2X3 U32 nat`eq/ U2X2
    <- nat`ne-symmetric N1<>N2 N2<>N1
    <- update-commutes U0X2X U2X2 N2<>N1 M0 U0X0 U02
    <- update-overwrites-converse U0X1 U0X0 U01.

%worlds () (update-commutes-converse/L _ _ _ _ _ _ _).
%total { } (update-commutes-converse/L _ _ _ _ _ _ _).

- : update-commutes-converse U23 U13 N1<>N2 M0 U02 U01
    <- domain?-total D?
    <- update-commutes-converse/L U23 U13 N1<>N2 D? M0 U02 U01.

%worlds () (update-commutes-converse _ _ _ _ _ _).
%total { } (update-commutes-converse _ _ _ _ _ _).


%% The following theorem is needed if you want to iteratively
%% do something with a set. It says that you can take out an element
%% and (using the update-preserves-X-converse theorems) get a smaller set
%% that differs only for this element:

%theorem can-remove :
        forall* {M} {S} {N} {D}
 forall {SZ:size M S} {L:lookup M N D}
 exists {M-} {S-} {SZ-:size M- S-} {E:nat`eq (s S-) S}
               {U:update M- N D M} {F:fresh M- N}
 true.

- : can-remove (size/+ _) (lookup/= _) _ _ size/0 nat`eq/ update/0 fresh/0.

- : can-remove (size/+ (size/+ SZ)) (lookup/= nat`eq/) _ _ (size/+ SZ) nat`eq/
               (update/< N3+1+N2=N1) (fresh/< N1>N2)
    <- plus-total N3+1+N2=N1
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2.

- : can-remove (size/+ SZ) (lookup/> LK N0+1+N1=N2) _ _
               (size/+ SZ2) E
               (update/> U2 N0+1+N1=N2) (fresh/> F2 N0+1+N1=N2)
    <- can-remove SZ LK M- S- SZ2 E2 U2 F2
    <- succ-deterministic E2 E.

%worlds () (can-remove _ _ _ _ _ _ _ _).
%total (L) (can-remove _ L _ _ _ _ _ _).


% another version, which requires that you "know" the set is non-empty

%theorem can-remove* :
        forall* {M} {S}
 forall {SZ:size M (s S)}
 exists {MP} {N} {D}
  {SZP:size MP S}
                {U:update MP N D M}
  {F:fresh MP N}
 true.

- : can-remove* (size/+ SZ) MP N D SZP U F
    <- can-remove (size/+ SZ) (lookup/= nat`eq/) MP NP SZPP EQ U F
    <- succ-cancels EQ EQP
    <- size-respects-eq SZPP eq/ EQP SZP.

%worlds () (can-remove* _ _ _ _ _ _ _).
%total { } (can-remove* _ _ _ _ _ _ _).


%theorem shift-implies-update :
 forall* {M1} {N} {M2} {D}
 forall {SH: shift N M1 M2}
 exists {U: update M2 N D (map/+ N D M1)}
 true.

- : shift-implies-update shift/0 update/0.

- : shift-implies-update (shift/+ P) (update/< PSC)
    <- plus-swap-succ P PS
    <- plus-commutative PS PSC.

%worlds () (shift-implies-update _ _).
%total { } (shift-implies-update _ _).


%theorem fresh-update-implies-shift:
 forall* {M} {N} {D} {M1}
 forall {F: fresh M N}
  {U: update M N D (map/+ N D M1)}
 exists {S: shift N M1 M}
 true.

- : fresh-update-implies-shift F U S
    <- shift-total SP
    <- shift-implies-update SP UP
    <- shift-implies-fresh SP FP
    <- fresh-update-cancels FP UP F U nat`eq/ eq/ inner-efxmap`eq/ MEQ
    <- shift-respects-eq SP nat`eq/ eq/ MEQ S.

%worlds () (fresh-update-implies-shift _ _ _).
%total { } (fresh-update-implies-shift _ _ _).




%%%% Map comparison



%%% Definition of leq

%{%
We always define leq? and nle even if we do not have these things in inner-efxmap.
This is simply for uniformity. The relations are crippled if
inner-efxmap does not have the required relation.
%}%


leq? : map -> map -> bool -> type.

%abbrev leq : map -> map -> type = [M1] [M2] leq? M1 M2 true.

%abbrev nle : map -> map -> type = [M1] [M2] leq? M1 M2 false.


leq/0 : leq map/0 M.

leq/= : leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`eq N1 N2
    <- inner-efxmap`leq D1 D2
    <- leq M1 M2.

leq/> : leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N3) N2 N1
    <- leq (map/+ N3 D1 M1) M2.


nle/< : lookup M1 N D1 -> fresh M2 N -> nle M1 M2.


%abbrev leq?/yes : leq M1 M2 -> leq? M1 M2 true = [x] x.

%abbrev leq?/no : nle M1 M2 -> leq? M1 M2 false = [x] x.



%%% Theorems about leq


%theorem false-implies-leq? :
 forall* {M1} {M2} {B}
 forall {F:void}
 exists {L:leq? M1 M2 B}
 true.

%worlds () (false-implies-leq? _ _).
%total {} (false-implies-leq? _ _).

%abbrev false-implies-leq : void -> leq M1 M2 -> type = false-implies-leq?.

%abbrev false-implies-nle : void -> nle M1 M2 -> type = false-implies-leq?.


%theorem leq?-respects-eq :
 forall* {M1} {M2} {M1P} {M2P} {B}
 forall {L:leq? M1 M2 B} {E1:eq M1 M1P} {E2:eq M2 M2P}
 exists {LP:leq? M1P M2P B}
 true.

- : leq?-respects-eq L eq/ eq/ L.

%worlds () (leq?-respects-eq _ _ _ _).
%total { } (leq?-respects-eq _ _ _ _).
%reduces L1 = L2 (leq?-respects-eq L1 _ _ L2).

%abbrev leq-respects-eq = leq?-respects-eq.

%abbrev nle-respects-eq = leq?-respects-eq.


%theorem leq/0-inversion :
 forall* {M1} {M2}
 forall {L:leq M1 M2} {E2:eq M2 map/0}
 exists {E1:eq M1 map/0}
 true.

- : leq/0-inversion leq/0 eq/ eq/.

%worlds () (leq/0-inversion _ _ _).
%total { } (leq/0-inversion _ _ _).


%theorem leq/=-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {M2}
 forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} {EN:nat`eq N1 N2}
 exists {ED:inner-efxmap`leq D1 D2} {EM:leq M1 M2}
 true.

- : leq/=-inversion (leq/= M1<=M2 D1<=D2 nat`eq/) nat`eq/ D1<=D2 M1<=M2.

- : leq/=-inversion (leq/> M311<=M2 N3+1+N=N) nat`eq/ ED M1<=M2
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- inner-efxmap`false-implies-leq F ED
    <- false-implies-eq F M311=M1
    <- leq-respects-eq M311<=M2 M311=M1 eq/ M1<=M2.

%worlds () (leq/=-inversion _ _ _ _).
%total { } (leq/=-inversion _ _ _ _).
%reduces L1 < L (leq/=-inversion L _ _ L1).


%theorem leq/>-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
 forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
               {P:plus (s N3) N2 N1}
 exists {EM:leq (map/+ N3 D1 M1) M2}
 true.

- : leq/>-inversion (leq/= M1<=M2 D1<=D2 nat`eq/) N3+1+N=N M311<=M2
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M1=M311
    <- leq-respects-eq M1<=M2 M1=M311 eq/ M311<=M2.

- : leq/>-inversion (leq/> M311P<=M2 N3P+1+N2=N1) N3+1+N2=N1 M311<=M2
    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- succ-cancels N3P+1=N3+1 N3P=N3
    <- map/+-preserves-eq N3P=N3 inner-efxmap`eq/ eq/ M311P=M311
    <- leq-respects-eq M311P<=M2 M311P=M311 eq/ M311<=M2.

%worlds () (leq/>-inversion _ _ _).
%total { } (leq/>-inversion _ _ _).
%reduces LP < L (leq/>-inversion L _ LP).


%theorem leq-contradiction :
 forall* {N} {D} {M}
 forall {L: leq (map/+ N D M) map/0}
 exists {F: void}
 true.

%worlds () (leq-contradiction _ _).
%total { } (leq-contradiction _ _).


%theorem leq/<-contradiction :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}
 forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
               {P:plus (s N0) N1 N2}
 exists {F:void}
 true.

- : leq/<-contradiction (leq/= _ _ nat`eq/) N0+1+N=N F
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : leq/<-contradiction (leq/> _ N3+1+N2=N1) N0+1+N1=N2 F
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F.

%worlds () (leq/<-contradiction _ _ _).
%total { } (leq/<-contradiction _ _ _).


%theorem leq-reflexive :
 forall {M}
 exists {L:leq M M}
 true.

- : leq-reflexive map/0 leq/0.

- : leq-reflexive (map/+ N D M) (leq/= M<=M D<=D nat`eq/)
    <- inner-efxmap`leq-reflexive D D<=D
    <- leq-reflexive M M<=M.

%worlds () (leq-reflexive _ _).
%total (M) (leq-reflexive M _).


%theorem leq-anti-symmetric :
 forall* {M1} {M2}
 forall {L1: leq M1 M2} {L2:leq M2 M1}
 exists {E: eq M1 M2}
 true.

- : leq-anti-symmetric leq/0 leq/0 eq/.

- : leq-anti-symmetric (leq/= M1<=M2 D1<=D2 nat`eq/)
                       (leq/= M2<=M1 D2<=D1 nat`eq/) E
    <- inner-efxmap`leq-anti-symmetric D1<=D2 D2<=D1 D1=D2
    <- leq-anti-symmetric M1<=M2 M2<=M1 M1=M2
    <- map/+-preserves-eq nat`eq/ D1=D2 M1=M2 E.

- : leq-anti-symmetric (leq/= _ _ nat`eq/) (leq/> _ N3+1+N=N) E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : leq-anti-symmetric (leq/> _ N3+1+N=N) (leq/= _ _ nat`eq/) E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : leq-anti-symmetric (leq/> _ N3+1+N2=N1) (leq/> _ N0+1+N1=N2) E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (leq-anti-symmetric _ _ _).
%total (L) (leq-anti-symmetric L _ _).


%theorem leq-transitive :
 forall* {M1} {M2} {M3}
 forall {L1:leq M1 M2} {L2:leq M2 M3}
 exists {L3:leq M1 M3}
 true.

- : leq-transitive leq/0 _ leq/0.

- : leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) (leq/= M2<=M3 D2<=D3 nat`eq/)
                   (leq/= M1<=M3 D1<=D3 nat`eq/)
    <- inner-efxmap`leq-transitive D1<=D2 D2<=D3 D1<=D3
    <- leq-transitive M1<=M2 M2<=M3 M1<=M3.

- : leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) (leq/> M522<=M3 N5+1+N3=N2)
                   (leq/> M511<=M3 N5+1+N3=N2)
    <- leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) M522<=M3 M511<=M3.

- : leq-transitive (leq/> M011<=M2 N0+1+N=N1) (leq/= M2<=M3 D2<=D3 nat`eq/)
                   (leq/> M011<=M3 N0+1+N=N1)
    <- leq-transitive M011<=M2 M2<=M3 M011<=M3.

- : leq-transitive (leq/> M011<=M2 N0+1+N2=N1) (leq/> M522<=M3 N5+1+N3=N2)
                   (leq/> M411<=M3 N4+1+N3=N1)
    <- nat`plus-swap-succ N5+1+N3=N2 N5+N3+1=N2
    <- nat`plus-associative-converse N5+N3+1=N2 N0+1+N2=N1 N4 N0+1+N5=N4
                                     N4+N3+1=N1
    <- nat`plus-swap-succ-converse N4+N3+1=N1 N4+1+N3=N1
    <- leq-transitive (leq/> M011<=M2 N0+1+N5=N4) M522<=M3 M411<=M3.

%worlds () (leq-transitive _ _ _).
%total (L) (leq-transitive _ L _).


%theorem map/+-preserves-leq? :
 forall* {N1} {N2} {D1} {D2} {M1} {M2} {B}
 forall {E:nat`eq N1 N2} {LD:inner-efxmap`leq D1 D2} {LM:leq? M1 M2 B}
        exists {L:leq? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
 true.

- : map/+-preserves-leq? N1=N2 D1<=D2 M1<=M2 (leq/= M1<=M2 D1<=D2 N1=N2).

- : map/+-preserves-leq? nat`eq/ _ (nle/< L1 F2)
 (nle/< (lookup/> L1 P) (fresh/> F2 P))
    <- plus-total P.


%worlds () (map/+-preserves-leq? _ _ _ _).
%total { } (map/+-preserves-leq? _ _ _ _).

%abbrev map/+-preserves-leq = map/+-preserves-leq?.

%abbrev map/+-preserves-nle = map/+-preserves-leq?.


%theorem lookup-respects-leq :
 forall* {M} {N} {D} {MP}
 forall {L:lookup M N D} {ME:leq M MP}
        exists {DP} {L:lookup MP N DP} {DE:inner-efxmap`leq D DP}
 true.

- : lookup-respects-leq (lookup/= nat`eq/) (leq/= _ D1<=D2 nat`eq/)
                         _ (lookup/= nat`eq/) D1<=D2.

- : lookup-respects-leq (lookup/= nat`eq/) (leq/> M311<=M2 N3+1+N2=N1)
                         D2 (lookup/> L13 N3+1+N2=N1) D1<=D2
    <- lookup-respects-leq (lookup/= nat`eq/) M311<=M2 D2 L13 D1<=D2.

- : lookup-respects-leq (lookup/> L13 N3+1+N2=N1) (leq/= M1<=M2 _ nat`eq/)
                        D2 (lookup/> L13P N3+1+N2=N1) D1<=D2
    <- lookup-respects-leq L13 M1<=M2 D2 L13P D1<=D2.

- : lookup-respects-leq (lookup/> L10 N0+1+N1=N) (leq/> M311<=M2 N3+1+N2=N1)
                        D2 (lookup/> L14P N4+1+N2=N) D1<=D2
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- nat`plus-associative-converse N3+N2+1=N1 N0+1+N1=N
                                     N4 N0+1+N3=N4 N4+N2+1=N
    <- nat`plus-swap-succ-converse N4+N2+1=N N4+1+N2=N
    <- lookup-respects-leq (lookup/> L10 N0+1+N3=N4) M311<=M2 D2 L14P D1<=D2.

%worlds () (lookup-respects-leq _ _ _ _ _).
%total (L) (lookup-respects-leq _ L _ _ _).


%theorem lookup-respects-leq* :
 forall* {M} {N} {D} {MP} {DP}
 forall {L:lookup M N D} {ME:leq M MP}
               {LP:lookup MP N DP}
 exists {DE:inner-efxmap`leq D DP}
 true.

- : lookup-respects-leq* L ME LP DL
    <- lookup-respects-leq L ME _ LPP DLP
    <- lookup-unique LPP LP eq/ nat`eq/ DE
    <- inner-efxmap`leq-respects-eq DLP inner-efxmap`eq/ DE DL.

%worlds () (lookup-respects-leq* _ _ _ _).
%total { } (lookup-respects-leq* _ _ _ _).


%theorem lookup-implies-unit-leq :
 forall* {M} {N} {D}
 forall {L: lookup M N D}
 exists {L: leq (map/+ N D map/0) M}
 true.

- : lookup-implies-unit-leq (lookup/= nat`eq/) (leq/= leq/0 D<=D nat`eq/)
    <- inner-efxmap`leq-reflexive _ D<=D.

- : lookup-implies-unit-leq (lookup/> LO P) (leq/> LE P)
    <- lookup-implies-unit-leq LO LE.

%worlds () (lookup-implies-unit-leq _ _).
%total (L) (lookup-implies-unit-leq L _).


%theorem fresh-respects-geq :
 forall* {M} {MP} {N}
 forall {FP:fresh MP N} {L:leq M MP}
 exists {F:fresh M N}
 true.

- : fresh-respects-geq F leq/0 fresh/0.

- : fresh-respects-geq (fresh/< R) (leq/= _ _ nat`eq/) (fresh/< R).

- : fresh-respects-geq (fresh/< N2>N) (leq/> _ N3+1+N2=N1) (fresh/< N1>N)
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- gt-transitive N1>N2 N2>N N1>N.

- : fresh-respects-geq (fresh/> F20 N0+1+N2=N) (leq/= M1<=M2 _ nat`eq/)
                       (fresh/> F10 N0+1+N2=N)
    <- fresh-respects-geq F20 M1<=M2 F10.

- : {F3110:fresh (map/+ N3 D1 M1) N0}
    {N0+1+N2=N:plus (s N0) N2 N}
    {N3+1+N2=N1:plus (s N3) N2 N1}
    fresh-respects-geq
       (fresh/> F20 N0+1+N2=N: fresh (map/+ N2 D2 M2) N)
       (leq/> M311<=M2 N3+1+N2=N1) FP
    <- fresh-respects-geq F20 M311<=M2 F3110
    <- nat`plus-swap-succ N0+1+N2=N N0+N2+1=N
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-right-preserves-fresh* F3110 N3+N2+1=N1 N0+N2+1=N FP.

%worlds () (fresh-respects-geq _ _ _).
%total (F) (fresh-respects-geq F _ _).


%theorem leq-implies-size-le:
 forall* {M1} {M2} {N1} {N2}
 forall {L:leq M1 M2} {SZ1:size M1 N1} {SZ2:size M2 N2}
 exists {G:ge N2 N1}
 true.

- : leq-implies-size-le leq/0 size/0 N2=|M2| N2>=0
    <- plus-commutative (plus/z:plus z N2 N2) N2+0=N2
    <- plus-implies-ge N2+0=N2 N2>=0.

- : leq-implies-size-le (leq/= M1<=M2 _ _) (size/+ N1=|M1|) (size/+ N2=|M2|)
                        N2+1>=N1+1
    <- leq-implies-size-le M1<=M2 N1=|M1| N2=|M2| N2>=N1
    <- succ-preserves-ge N2>=N1 N2+1>=N1+1.

- : leq-implies-size-le (leq/> M311<=M2 _) (size/+ N1=|M1|) (size/+ N2=|M2|)
                        (ge/> N2+1>N1+1)
    <- leq-implies-size-le M311<=M2 (size/+ N1=|M1|) N2=|M2| N2>=N1+1
    <- succ-implies-gt nat`eq/ N2+1>N2
    <- gt-transitive-ge N2+1>N2 N2>=N1+1 N2+1>N1+1.

%worlds () (leq-implies-size-le _ _ _ _).
%total (L) (leq-implies-size-le L _ _ _).


%theorem leq-implies-bound-le:
 forall* {M1} {M2} {N1} {N2}
 forall {L:leq M1 M2} {BD1:bound M1 N1} {BD2:bound M2 N2}
 exists {G:ge N2 N1}
 true.

- : leq-implies-bound-le leq/0 bound/0 _ N2>=0
    <- plus-commutative plus/z N2+0=N2
    <- plus-implies-ge N2+0=N2 N2>=0.

- : leq-implies-bound-le (leq/= M1<=M2 _ nat`eq/)
                         (bound/+ N+1+N1=N3 DM1<N1)
                         (bound/+ N+1+N2=N4 DM2<N2)
                         N4>=N3
    <- leq-implies-bound-le M1<=M2 DM1<N1 DM2<N2 N2>=N1
    <- plus-left-preserves-ge* N2>=N1 N+1+N2=N4 N+1+N1=N3 N4>=N3.

- : leq-implies-bound-le (leq/> M311<=M2 N3+1+N2=N1)
                         (bound/+ N1+1+N10=N11 DM1<N10)
                         (bound/+ N2+1+N20=N22 DM2<N20)
                         N22>=N11
    <- plus-total N3+1+N10=N13
    <- leq-implies-bound-le M311<=M2 (bound/+ N3+1+N10=N13 DM1<N10) DM2<N20
                            N20>=N13
    <- plus-swap-succ N1+1+N10=N11 N1+N10+1=N11
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- plus-swap-succ N3+1+N10=N13 N3+N10+1=N13
    <- plus-associative* N2+1+N3=N1 N1+N10+1=N11 N3+N10+1=N13 N2+1+N13=N11
    <- plus-left-preserves-ge* N20>=N13 N2+1+N20=N22 N2+1+N13=N11 N22>=N11.

%worlds () (leq-implies-bound-le _ _ _ _).
%total (L) (leq-implies-bound-le L _ _ _).


%theorem shift-left-preserves-leq*:
 forall* {M1} {M2} {N} {SM1} {D}
 forall {L:leq M1 M2}
        {S1:shift N M1 SM1}
 exists {SL:leq SM1 (map/+ N D M2)}
 true.

- : shift-left-preserves-leq* _ shift/0 leq/0.

- : shift-left-preserves-leq* M111<=M2 (shift/+ N+1+N1=N1P)
                              (leq/> M111<=M2 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-leq* _ _ _).
%total { } (shift-left-preserves-leq* _ _ _).


%theorem shift-preserves-leq*:
 forall* {M1} {M2} {N} {SM1} {SM2}
 forall {L:leq M1 M2}
               {S1:shift N M1 SM1}
        {S1:shift N M2 SM2}
 exists {SL:leq SM1 SM2}
 true.

- : shift-preserves-leq* _ shift/0 _ leq/0.

- : shift-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                         (shift/+ N+1+N1=N1P)
                         (shift/+ N+1+N1=N2P)
                         (leq/= M1<=M2 D1<=D2 N1P=N2P)
    <- plus-deterministic N+1+N1=N1P N+1+N1=N2P nat`eq/ nat`eq/ N1P=N2P.

- : shift-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                         (shift/+ N+1+N1=N1P)
                         (shift/+ N+1+N2=N2P)
                         (leq/> M311<=M2 N3+1+N2P=N1P)
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N1P N+1+N2=N2P N2P+N3+1=N1P
    <- plus-commutative N2P+N3+1=N1P N3+1+N2P=N1P.

%worlds () (shift-preserves-leq* _ _ _ _).
%total { } (shift-preserves-leq* _ _ _ _).

%abbrev shift-preserves-leq = shift-preserves-leq*.

%theorem shift-preserves-leq-converse:
 forall* {M1} {M2} {N} {SM1} {SM2}
 forall {L:leq SM1 SM2}
               {S1:shift N M1 SM1}
        {S1:shift N M2 SM2}
 exists {SL:leq M1 M2}
 true.

- : shift-preserves-leq-converse _ shift/0 _ leq/0.

- : shift-preserves-leq-converse (leq/= M1<=M2 D1<=D2 nat`eq/)
          (shift/+ N+1+N1P=N1)
                           (shift/+ N+1+N2P=N1)
                           (leq/= M1<=M2 D1<=D2 N1P=N2P)
    <- plus-left-cancels N+1+N1P=N1 N+1+N2P=N1 nat`eq/ nat`eq/ N1P=N2P.

- : shift-preserves-leq-converse (leq/> M311<=M2 N3+1+N2P=N1P)
                           (shift/+ N+1+N1=N1P)
                          (shift/+ N+1+N2=N2P)
                          (leq/> M311<=M2 N3+1+N2=N1)
    <- plus-commutative N3+1+N2P=N1P N2P+N3+1=N1P
    <- plus-associative N+1+N2=N2P N2P+N3+1=N1P M1 N2+N3+1=M1 N+1+M1=N1P
    <- plus-left-cancels N+1+M1=N1P N+1+N1=N1P nat`eq/ nat`eq/ M1=N1
    <- plus-respects-eq N2+N3+1=M1 nat`eq/ nat`eq/ M1=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1.

%worlds () (shift-preserves-leq-converse _ _ _ _).
%total { } (shift-preserves-leq-converse _ _ _ _).


%theorem disjoint-respects-geq* :
 forall* {M1} {M2} {M1P}
 forall {A:disjoint M1 M2} {E1:leq M1P M1}
 exists {AP:disjoint M1P M2}
 true.

- : disjoint-respects-geq* _ leq/0 disjoint/L.

- : disjoint-respects-geq* disjoint/R _ disjoint/R.

- : disjoint-respects-geq*
 (disjoint/< D1 P) (leq/= L _ nat`eq/)
 (disjoint/< D1P P)
    <- disjoint-respects-geq* D1 L D1P.

- : disjoint-respects-geq*
 (disjoint/> D1 P) (leq/= L DL nat`eq/)
 (disjoint/> D1P P)
    <- disjoint-respects-geq* D1 (leq/= L DL nat`eq/) D1P.

- : disjoint-respects-geq*
 (disjoint/< D1 P1) (leq/> L P2) DP
    <- disjoint-respects-geq* D1 L D1P
    <- plus-swap-succ P1 P1S
    <- plus-swap-succ P2 P2S
    <- plus-commutative P1S P1SC
    <- plus-commutative P2S P2SC
    <- shift-preserves-disjoint D1P (shift/+ P2SC) (shift/+ P1SC) DP.

- : disjoint-respects-geq*
 (disjoint/> D1 N0+1+N1=N2) (leq/> L N3+1+N2=N4) DP
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N3+1+N2=N4 N5 N3+1+N0=N5 N5+N1+1=N4
    <- disjoint-respects-geq* D1 (leq/> L N3+1+N0=N5) D1P
    <- plus-commutative N5+N1+1=N4 N1+1+N5=N4
    <- shift-left-preserves-disjoint D1P (shift/+ N1+1+N5=N4) DP.

%worlds () (disjoint-respects-geq* _ _ _).
%total (D) (disjoint-respects-geq* D _ _).


%theorem disjoint-respects-geq :
 forall* {M1} {M2} {M1P} {M2P}
 forall {A:disjoint M1 M2} {E1:leq M1P M1} {E2:leq M2P M2}
 exists {AP:disjoint M1P M2P}
 true.

- : disjoint-respects-geq M1^M2 M1P<=M1 M2P<=M2 M1P^M2P
    <- disjoint-respects-geq* M1^M2 M1P<=M1 M1P^M2
    <- disjoint-symmetric M1P^M2 M2^M1P
    <- disjoint-respects-geq* M2^M1P M2P<=M2 M2P^M1P
    <- disjoint-symmetric M2P^M1P M1P^M2P.

%worlds () (disjoint-respects-geq _ _ _ _).
%total { } (disjoint-respects-geq _ _ _ _).


%theorem disjoint-leq-implies-empty :
        forall* {M1} {M2}
        forall {D: disjoint M1 M2}
                {L: leq M1 M2}
        exists {E: eq map/0 M1}
        true.


- : disjoint-leq-implies-empty D L E
    <- leq-reflexive _ M<=M
    <- disjoint-respects-geq D M<=M L DD
    <- disjoint-anti-reflexive DD E.

%worlds () (disjoint-leq-implies-empty _ _ _).
%total { } (disjoint-leq-implies-empty _ _ _).


%theorem update-left-preserves-leq*:
 forall* {M1} {M2} {N} {D} {M1P} {M2P}
 forall {L:leq M1 M2}
               {U1:update M1 N D M1P}
        {U2:update M2 N D M2P}
 exists {LP:leq M1P M2P}
 true.

- : update-left-preserves-leq* leq/0 update/0 update/0 (leq/= leq/0 D<=D nat`eq/)
    <- inner-efxmap`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/= nat`eq/)
                          (leq/= leq/0 D<=D nat`eq/)
    <- inner-efxmap`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/< _)
                          (leq/= leq/0 D<=D nat`eq/)
    <- inner-efxmap`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/> U2505 N5+1+N2=N)
                          (leq/> M500<=M5 N5+1+N2=N)
    <- update-left-preserves-leq* leq/0 update/0 U2505 M500<=M5.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/= nat`eq/)
                          (U2:update (map/+ N D2 M2) N D M)
                          M001<=M
    <- update/=-inversion U2 nat`eq/ M002=M
    <- inner-efxmap`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= M1<=M2 D<=D nat`eq/) eq/ M002=M M001<=M.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/< N3+1+N=N1)
                          (U2:update (map/+ N1 D2 M2) N D M)
                          M00M311<=M
    <- update/<-inversion U2 N3+1+N=N1 M00M322=M
    <- inner-efxmap`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= (leq/= M1<=M2 D1<=D2 nat`eq/) D<=D nat`eq/) eq/
                       M00M322=M M00M311<=M.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/> U1303 N3+1+N1=N)
                          (U2:update (map/+ N1 D2 M2) N D M)
                          M113<=M
    <- update/>-inversion U2 N3+1+N1=N M4 U2304 M124=M
    <- update-left-preserves-leq* M1<=M2 U1303 U2304 M3<=M4
    <- leq-respects-eq (leq/= M3<=M4 D1<=D2 nat`eq/) eq/ M124=M M113<=M.

- : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                          (update/= nat`eq/)
     (U2:update (map/+ N2 D2 M2) N1 D M)
                          M101<=M
    <- update/>-inversion U2 N3+1+N2=N1 M4 U2304 M224=M
    <- update-left-preserves-leq* M311<=M2 (update/= nat`eq/) U2304 M301<=M4
    <- leq-respects-eq (leq/> M301<=M4 N3+1+N2=N1) eq/ M224=M M101<=M.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N=N1)
                           (update/< N4+1+N=N1)
                           (update/= nat`eq/) %% hence N=N2
                           (leq/= M411<=M2 D<=D nat`eq/)
     <- nat`plus-right-cancels N3+1+N=N1 N4+1+N=N1 nat`eq/ nat`eq/ N3+1=N4+1
     <- nat`succ-cancels N3+1=N4+1 N3=N4
     <- map/+-preserves-eq N3=N4 inner-efxmap`eq/ eq/ M311=M411
     <- leq-respects-eq M311<=M2 M311=M411 eq/ M411<=M2
     <- inner-efxmap`leq-reflexive _ D<=D.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                           (update/< N4+1+N=N1)
                           (update/< N5+1+N=N2)
                           (leq/= (leq/> M311<=M2 N3+1+N5=N4) D<=D nat`eq/)
     <- nat`plus-swap-succ N5+1+N=N2 N5+N+1=N2
     <- nat`plus-associative-converse N5+N+1=N2 N3+1+N2=N1
                                      N4P N3+1+N5=N4P N4P+N+1=N1
     <- nat`plus-swap-succ N4+1+N=N1 N4+N+1=N1
     <- nat`plus-right-cancels N4P+N+1=N1 N4+N+1=N1 nat`eq/ nat`eq/ N4P=N4
     <- nat`plus-respects-eq N3+1+N5=N4P nat`eq/ nat`eq/ N4P=N4 N3+1+N5=N4
     <- inner-efxmap`leq-reflexive _ D<=D.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                           (update/< N4+1+N=N1)
                           (update/> U2505 N5+1+N2=N)
                           (leq/> M50M411<=M5 N5+1+N2=N)
     <- nat`plus-swap-succ N5+1+N2=N N5+N2+1=N
     <- nat`plus-associative-converse N5+N2+1=N N4+1+N=N1
                                      N3P N4+1+N5=N3P N3P+N2+1=N1
     <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
     <- nat`plus-right-cancels N3P+N2+1=N1 N3+N2+1=N1 nat`eq/ nat`eq/ N3P=N3
     <- nat`plus-respects-eq N4+1+N5=N3P nat`eq/ nat`eq/ N3P=N3 N4+1+N5=N3
     <- update-left-preserves-leq* M311<=M2 (update/< N4+1+N5=N3) U2505
                              M50M411<=M5.

- : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                          (update/> U1404 N4+1+N1=N)
                          (U2:update (map/+ N2 D2 M2) N D M)
                          M114<=M
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- nat`plus-associative-converse N3+N2+1=N1 N4+1+N1=N
                                     N5 N4+1+N3=N5 N5+N2+1=N
    <- nat`plus-swap-succ-converse N5+N2+1=N N5+1+N2=N
    <- update/>-inversion U2 N5+1+N2=N M5 U2505 M225=M
    <- update-left-preserves-leq* M311<=M2 (update/> U1404 N4+1+N3=N5) U2505
                             M314<=M5
    <- leq-respects-eq (leq/> M314<=M5 N3+1+N2=N1) eq/ M225=M M114<=M.

%worlds () (update-left-preserves-leq* _ _ _ _).
%total (U) (update-left-preserves-leq* _ _ U _).


%theorem update-right-preserves-leq*:
 forall* {M} {N} {D1} {D2} {M1P} {M2P}
 forall {L:inner-efxmap`leq D1 D2}
               {U1:update M N D1 M1P}
        {U2:update M N D2 M2P}
 exists {LP:leq M1P M2P}
 true.

- : update-right-preserves-leq* D1<=D2 update/0 update/0
                                (leq/= leq/0 D1<=D2 nat`eq/).

- : update-right-preserves-leq* D1<=D2 (update/= nat`eq/) U2 L
    <- update/=-inversion U2 nat`eq/ M221=M2P
    <- leq-reflexive _ M1<=M1
    <- leq-respects-eq (leq/= M1<=M1 D1<=D2 nat`eq/) eq/ M221=M2P L.

- : update-right-preserves-leq* D1<=D2 (update/< P) U2 L
    <- update/<-inversion U2 P M22311=M2P
    <- leq-reflexive _ M311<=M311
    <- leq-respects-eq (leq/= M311<=M311 D1<=D2 nat`eq/) eq/ M22311=M2P L.

- : update-right-preserves-leq* D1<=D2 (update/> U1 P) U22 L
    <- update/>-inversion U22 P M2P U2 M112=M
    <- update-right-preserves-leq* D1<=D2 U1 U2 M1P<=M2P
    <- inner-efxmap`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= M1P<=M2P D<=D nat`eq/) eq/ M112=M L.

%worlds () (update-right-preserves-leq* _ _ _ _).
%total (U) (update-right-preserves-leq* _ U _ _).


%theorem update-preserves-leq* :
 forall* {M1} {M2} {N} {D1} {D2} {M1P} {M2P}
 forall {L:leq M1 M2} {L:inner-efxmap`leq D1 D2}
               {U1:update M1 N D1 M1P}
        {U2:update M2 N D2 M2P}
 exists {LP:leq M1P M2P}
 true.

- : update-preserves-leq* M1<=M2 D1<=D2 M1^N=D1->M1P M2^N=D2->M2P M1P<=M2P
    <- update-total M2^N=D1->MM
    <- update-left-preserves-leq* M1<=M2 M1^N=D1->M1P M2^N=D1->MM M1P<=MM
    <- update-right-preserves-leq* D1<=D2 M2^N=D1->MM M2^N=D2->M2P MM<=M2P
    <- leq-transitive M1P<=MM MM<=M2P M1P<=M2P.

%worlds () (update-preserves-leq* _ _ _ _ _).
%total { } (update-preserves-leq* _ _ _ _ _).


%theorem fresh-update-preserves-leq-converse :
 forall* {M1} {M2} {N} {D1} {D2} {M1P} {M2P}
 forall {LP:leq M1P M2P}
  {F1:fresh M1 N}
         {U1:update M1 N D1 M1P}
  {F2:fresh M2 N}
  {U2:update M2 N D2 M2P}
 exists {L:leq M1 M2}
  {L:inner-efxmap`leq D1 D2}
 true.

- : fresh-update-preserves-leq-converse
 _ _ _ FR (update/= nat`eq/) L DL
    <- fresh-contradiction FR F
    <- false-implies-leq F L
    <- inner-efxmap`false-implies-leq F DL.

- : fresh-update-preserves-leq-converse
 M1P<=M2P fresh/0 update/0 _ U2 leq/0 D1<=D2
    <- update-implies-lookup U2 L2
    <- lookup-respects-leq* (lookup/= nat`eq/) M1P<=M2P L2 D1<=D2.

- : fresh-update-preserves-leq-converse
 M1P<=M2P (fresh/< GT1) U1 (fresh/< GT2) U2 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U1 P1 EQ1
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1P<=M2Px
    <- leq/=-inversion M1P<=M2Px nat`eq/ D1<=D2 M1s<=M2s
    <- plus-swap-succ P1 P1s
    <- plus-swap-succ P2 P2s
    <- plus-commutative P1s P1sc
    <- plus-commutative P2s P2sc
    <- shift-preserves-leq* M1s<=M2s (shift/+ P1sc) (shift/+ P2sc) M1<=M2.

- : fresh-update-preserves-leq-converse
 M1P<=M2P (fresh/< GT1) U1 fresh/0 update/0 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- eq-symmetric EQ1 EQ1s
    <- leq-respects-eq M1P<=M2P EQ1s eq/ M1Px<=M2P
    <- leq/=-inversion M1Px<=M2P nat`eq/ D1<=D2 M1s<=M2s
    <- leq-contradiction M1s<=M2s F
    <- false-implies-leq F M1<=M2.

- : fresh-update-preserves-leq-converse
 M1P<=M2P (fresh/< GT1) U1 (fresh/> F2R P2) U2 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- update/>-inversion U2 P2 _ U2R EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1P<=M2Px
    <- leq/>-inversion M1P<=M2Px P2 M1PR<=M2PR
    <- plus-swap-succ P2 P2s
    <- plus-associative-converse P2s P1 _ P1R P2Rc
    <- plus-commutative P2Rc P2R
    <- plus-implies-gt P1R nat`eq/ GT1R
    <- fresh-update-preserves-leq-converse
 M1PR<=M2PR (fresh/< GT1R) (update/< P1R) F2R U2R M1R<=M2R D1<=D2
    <- shift-left-preserves-leq* M1R<=M2R (shift/+ P2R) M1<=M2.

%theorem fresh-update-preserves-leq-converse/> :
 forall* {N1} {X1} {M1} {C1} {R1} {D1} {N}
  {N2} {X2} {M2} {C2} {R2} {D2} {CC}
 forall {LP: leq (map/+ N1 X1 M1) (map/+ N2 X2 M2)}
  {P1: plus (s C1) N1 N}
  {F1: fresh R1 C1}
  {U1: update R1 C1 D1 M1}
  {P2: plus (s C2) N2 N}
  {F2: fresh R2 C2}
  {U2: update R2 C2 D2 M2}
  {C12: nat`compare C1 C2 CC}
 exists {L: leq (map/+ N1 X1 R1) (map/+ N2 X2 R2)}
  {DL: inner-efxmap`leq D1 D2}
 true.

- : fresh-update-preserves-leq-converse/>
 LP P1 F1 U1 P2 F2 U2 nat`compare/=
 (leq/= LR XL N1=N2) DL
    <- plus-left-cancels P1 P2 nat`eq/ nat`eq/ N1=N2
    <- leq/=-inversion LP N1=N2 XL LRP
    <- fresh-update-preserves-leq-converse LRP F1 U1 F2 U2 LR DL.

- : fresh-update-preserves-leq-converse/>
 LP C1+1+N1=N F1 U1 C2+1+N2=N F2 U2 (nat`compare/< C2>C1)
 (leq/> LR D+1+N2=N1) DL
    <- gt-implies-plus C2>C1 D D+1+C1=C2
    <- plus-swap-succ C2+1+N2=N C2+N2+1=N
    <- plus-swap-succ D+1+C1=C2 D+C1+1=C2
    <- plus-commutative D+C1+1=C2 C1+1+D=C2
    <- plus-associative C1+1+D=C2 C2+N2+1=N X D+N2+1=X C1+1+X=N
    <- plus-left-cancels C1+1+X=N C1+1+N1=N nat`eq/ nat`eq/ X=N1
    <- plus-swap-succ-converse D+N2+1=X D+1+N2=X
    <- plus-respects-eq D+1+N2=X nat`eq/ nat`eq/ X=N1 D+1+N2=N1
    <- leq/>-inversion LP D+1+N2=N1 LRP
    <- fresh-update-preserves-leq-converse
 LRP (fresh/> F1 C1+1+D=C2) (update/> U1 C1+1+D=C2) F2 U2 LR DL.

- : fresh-update-preserves-leq-converse/>
 LP P1 F1 U1 P2 F2 U2 (nat`compare/> C1>C2) L DL
    <- succ-preserves-gt C1>C2 SC1>SC2
    <- plus-left-reverses-gt P1 P2 SC1>SC2 nat`eq/ N2>N1
    <- gt-implies-plus N2>N1 _ P
    <- leq/<-contradiction LP P F
    <- false-implies-leq F L
    <- inner-efxmap`false-implies-leq F DL.

- : {U1R: update R1 C1 D1 M1} fresh-update-preserves-leq-converse
 M1P<=M2P (fresh/> F1R P1) U1 (fresh/> F2R P2) U2 M1<=M2 D1<=D2
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- update/>-inversion U2 P2 _ U2R EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1PR<=M2PR
    <- nat`compare-total C
    <- fresh-update-preserves-leq-converse/>
 M1PR<=M2PR P1 F1R U1R P2 F2R U2R C M1<=M2 D1<=D2.

- : fresh-update-preserves-leq-converse
 M1P<=M2P (fresh/> F1R P1) U1 fresh/0 update/0 L DL
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- eq-symmetric EQ1 EQ1s
    <- leq-respects-eq M1P<=M2P EQ1s eq/ M1Px<=M2P
    <- leq/<-contradiction M1Px<=M2P P1 F
    <- false-implies-leq F L
    <- inner-efxmap`false-implies-leq F DL.

- : fresh-update-preserves-leq-converse
 M1P<=M2P (fresh/> F1R P1) U1 (fresh/< GT2) U2 L DL
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1PR<=M2PR
    <- leq/<-contradiction M1PR<=M2PR P1 F
    <- false-implies-leq F L
    <- inner-efxmap`false-implies-leq F DL.

%worlds () (fresh-update-preserves-leq-converse _ _ _ _ _ _ _)
                 (fresh-update-preserves-leq-converse/> _ _ _ _ _ _ _ _ _ _).
%total (F2a F2b)
  (fresh-update-preserves-leq-converse _ F1a _ F2a _ _ _)
        (fresh-update-preserves-leq-converse/> _ _ F1b _ _ F2b _ _ _ _).

%theorem fresh-update-implies-leq :
 forall* {M1} {N} {D} {M2}
 forall {F:fresh M1 N} {U:update M1 N D M2}
 exists {L:leq M1 M2}
 true.

- : fresh-update-implies-leq fresh/0 U leq/0.

- : fresh-update-implies-leq (fresh/< N2<N1) U L
    <- gt-implies-plus N2<N1 _ N3+1+N2=N1
    <- update/<-inversion U N3+1+N2=N1 M22311=M2
    <- leq-reflexive _ M311<=M311
    <- leq-respects-eq (leq/> M311<=M311 N3+1+N2=N1) eq/ M22311=M2 L.

- : fresh-update-implies-leq (fresh/> F1 N0+1+N1=N2) U L
    <- update/>-inversion U N0+1+N1=N2 _ U1 M112=M
    <- fresh-update-implies-leq F1 U1 L1
    <- inner-efxmap`leq-reflexive _ DL
    <- leq-respects-eq (leq/= L1 DL nat`eq/) eq/ M112=M L.

%worlds () (fresh-update-implies-leq _ _ _).
%total (F) (fresh-update-implies-leq F _ _).


%theorem lookup-update-preserves-leq :
    forall* {M1} {N} {D1} {D2} {M2}
    forall {L:lookup M1 N D1} {U:update M1 N D2 M2}
           {L:inner-efxmap`leq D1 D2}
    exists {L:leq M1 M2}
    true.

- : lookup-update-preserves-leq (lookup/= nat`eq/) U D1<=D2 L
    <- update/=-inversion U nat`eq/ M221=M2
    <- leq-reflexive _ M1<=M1
    <- leq-respects-eq (leq/= M1<=M1 D1<=D2 nat`eq/) eq/ M221=M2 L.

- : lookup-update-preserves-leq (lookup/> L1 N0+1+N1=N2) U D1<=D2 L
    <- update/>-inversion U N0+1+N1=N2 M2 U1 M112=M
    <- lookup-update-preserves-leq L1 U1 D1<=D2 L1P
    <- inner-efxmap`leq-reflexive _ D1<=D1
    <- leq-respects-eq (leq/= L1P D1<=D1 nat`eq/) eq/ M112=M L.

%worlds () (lookup-update-preserves-leq _ _ _ _).
%total (L) (lookup-update-preserves-leq L _ _ _).


%theorem fresh-update-right-preserves-leq-converse :
    forall* {M1} {M2} {M3} {N} {S}
    forall {M1<=M2: leq M1 M2}
            {N!<M1: fresh M1 N}
            {N!<M3: fresh M3 N}
            {M2+NS=M3: update M3 N S M2}
    exists {M1<=M3: leq M1 M3}
    true.

- : fresh-update-right-preserves-leq-converse
     M1<=M2 N!<M1 N!<M3 M3+NS=M2 M1<=M3
     <- update-total M1+NS=M4
     <- fresh-update-implies-leq N!<M1 M1+NS=M4 M1<=M4
     <- update-implies-lookup M3+NS=M2 M2->N=S
     <- lookup-implies-update M2->N=S M2+NS=M2
     <- update-left-preserves-leq*
 M1<=M2 M1+NS=M4 M2+NS=M2 M4<=M2
     <- fresh-update-preserves-leq-converse
 M4<=M2 N!<M1 M1+NS=M4 N!<M3 M3+NS=M2 M1<=M3 _.

%worlds () (fresh-update-right-preserves-leq-converse _ _ _ _ _).
%total {} (fresh-update-right-preserves-leq-converse _ _ _ _ _).



%%% Theorems about nle


%theorem nle-anti-reflexive :
 forall* {M}
 forall {N:nle M M}
 exists {F:void}
 true.

- : nle-anti-reflexive (nle/< L F) FALSE
    <- fresh-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N FALSE.


%worlds () (nle-anti-reflexive _ _).
%total { } (nle-anti-reflexive _ _).


%theorem nle-implies-ne :
 forall* {M1} {M2}
 forall {N1:nle M1 M2}
 exists {N2:ne M1 M2}
 true.

- : nle-implies-ne (nle/< L F) (ne/< L F).


%worlds () (nle-implies-ne _ _).
%total (N) (nle-implies-ne N _).


%theorem leq-nle-contradiction :
 forall* {M1} {M2}
 forall {L:leq M1 M2} {N1:nle M1 M2}
 exists {F:void}
 true.

- : leq-nle-contradiction M1<=M2 (nle/< L1 F2) FALSE
    <- lookup-respects-leq L1 M1<=M2 _ L2 _
    <- fresh-lookup-not-equal F2 L2 N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N FALSE.


%worlds () (leq-nle-contradiction _ _ _).
%total { } (leq-nle-contradiction _ _ _).



%%%% Map domain

%{%
We define the domain of a map as a set.
This functor can be used with any "map" type.
It should be included after "map-base.elf".
For theorems connecting domains with join and add,
please see the corresponding files.
%}%



%%% Definition of domain


domain : map -> set -> type.


domain/0 : domain map/0 set`map/0.

domain/+ : domain M S ->
 domain (map/+ N _ M) (set`map/+ N unit/ S).

%abbrev domain/1 : domain (map/1 N D) (set/1 N) = (domain/+ domain/0).

%worlds () (domain _ _).
%unique domain +M -1S.



%%% Theorems about domain


%theorem false-implies-domain :
 forall* {M} {S}
 forall {F:void}
 exists {D:domain M S}
 true.

%worlds () (false-implies-domain _ _).
%total {} (false-implies-domain _ _).


%theorem domain-respects-eq :
 forall* {M1} {M2} {S1} {S2}
 forall {A1:domain M1 S1} {E1:eq M1 M2} {E2:set`eq S1 S2}
 exists {A2:domain M2 S2}
 true.

- : domain-respects-eq A eq/ set`eq/ A.

%worlds () (domain-respects-eq _ _ _ _).
%total {} (domain-respects-eq _ _ _ _).
%reduces A = AP (domain-respects-eq A _ _ AP).


%theorem domain-deterministic :
 forall* {M1} {M2} {S1} {S2}
 forall {A1:domain M1 S1}
  {A2:domain M2 S2}
                {E1:eq M1 M2}
 exists {E3:set`eq S1 S2}
 true.

%abbrev domain-unique = domain-deterministic.

- : domain-deterministic domain/0 domain/0 eq/ set`eq/.

- : domain-deterministic (domain/+ D1) (domain/+ D2) eq/ SEP
    <- domain-deterministic D1 D2 eq/ SE
    <- set`map/+-preserves-eq nat`eq/ unit`eq/ SE SEP.

%worlds () (domain-deterministic _ _ _ _).
%total (A) (domain-deterministic A _ _ _).


%theorem domain-total* :
 forall {M}
 exists {S} {A:domain M S}
 true.

%abbrev domain-total = domain-total* _ _.

- : domain-total domain/0.

- : domain-total* _ (set/+ _ _) (domain/+ D)
    <- domain-total D.

%worlds () (domain-total* _ _ _).

%total (M) (domain-total* M _ _).


%theorem domain-empty-implies-empty :
 forall* {M}
 forall {A:domain M set`set/0}
 exists {E1:eq M map/0}
 true.

- : domain-empty-implies-empty domain/0 eq/.

%worlds () (domain-empty-implies-empty _ _).
%total { } (domain-empty-implies-empty _ _).


%theorem domain-preserves-lookup :
 forall* {M} {S} {I} {D}
 forall {DM: lookup M I D}
  {D: domain M S}
 exists {SM: set`lookup S I unit/}
 true.

- : domain-preserves-lookup
 (lookup/= nat`eq/) (domain/+ _)
 (set`lookup/= nat`eq/).

- : domain-preserves-lookup
 (lookup/> ML P) (domain/+ D)
 (set`lookup/> MS P)
    <- domain-preserves-lookup ML D MS.

%worlds () (domain-preserves-lookup _ _ _).
%total (L) (domain-preserves-lookup L _ _).



%theorem domain-preserves-lookup-converse :
 forall* {M} {S} {I}
 forall {SM: set`lookup S I unit/}
  {D: domain M S}
 exists {D} {DM: lookup M I D}
 true.

- : domain-preserves-lookup-converse
 (set`lookup/= nat`eq/) (domain/+ _) _
 (lookup/= nat`eq/).

- : domain-preserves-lookup-converse
 (set`lookup/> SL P) (domain/+ D) _
 (lookup/> ML P)
    <- domain-preserves-lookup-converse SL D _ ML.

%worlds () (domain-preserves-lookup-converse _ _ _ _).
%total (L) (domain-preserves-lookup-converse L _ _ _).



%theorem domain-preserves-fresh :
 forall* {M} {S} {I}
 forall {DM: fresh M I}
  {D: domain M S}
 exists {SM: set`not-member S I}
 true.

- : domain-preserves-fresh
 (fresh/0) domain/0
 (set`not-member/0).

- : domain-preserves-fresh
 (fresh/< P) (domain/+ _)
 (set`not-member/< P).

- : domain-preserves-fresh
 (fresh/> ML P) (domain/+ D)
 (set`not-member/> MS P)
    <- domain-preserves-fresh ML D MS.

%worlds () (domain-preserves-fresh _ _ _).
%total (L) (domain-preserves-fresh L _ _).



%theorem domain-preserves-fresh-converse :
 forall* {M} {S} {I}
 forall {SM: set`not-member S I}
  {D: domain M S}
 exists {DM: fresh M I}
 true.

- : domain-preserves-fresh-converse
 (set`not-member/0) domain/0
 (fresh/0).

- : domain-preserves-fresh-converse
 (set`not-member/< G) (domain/+ _)
 (fresh/< G).

- : domain-preserves-fresh-converse
 (set`not-member/> SL P) (domain/+ D)
 (fresh/> ML P)
    <- domain-preserves-fresh-converse SL D ML.

%worlds () (domain-preserves-fresh-converse _ _ _).
%total (L) (domain-preserves-fresh-converse L _ _).


%theorem domain-preserves-domain? :
 forall* {M} {S} {I} {B}
 forall {DM: domain? M I B}
  {D: domain M S}
 exists {SM: set`member? S I B}
 true.

- : domain-preserves-domain? (domain?/in ML) D (set`member?/in SL)
    <- domain-preserves-lookup ML D SL.

- : domain-preserves-domain? (domain?/out MF) D (set`member?/out SF)
    <- domain-preserves-fresh MF D SF.

%worlds () (domain-preserves-domain? _ _ _).
%total { } (domain-preserves-domain? _ _ _).


%theorem domain-preserves-domain?-converse:
 forall* {M} {S} {I} {B}
 forall {SM: set`member? S I B}
  {D: domain M S}
 exists {DM: domain? M I B}
 true.

- : domain-preserves-domain?-converse (set`member?/in SL) D (domain?/in ML)
    <- domain-preserves-lookup-converse SL D _ ML.

- : domain-preserves-domain?-converse (set`member?/out SF) D (domain?/out MF)
    <- domain-preserves-fresh-converse SF D MF.

%worlds () (domain-preserves-domain?-converse _ _ _).
%total { } (domain-preserves-domain?-converse _ _ _).


%theorem domain-preserves-size :
 forall* {M} {N} {S}
 forall {MS: size M N}
  {D: domain M S}
 exists {SS: set`size S N}
 true.

- : domain-preserves-size (size/0) domain/0 (set`size/0).

- : domain-preserves-size (size/+ MS) (domain/+ D) (set`size/+ SS)
    <- domain-preserves-size MS D SS.

%worlds () (domain-preserves-size _ _ _).
%total (D) (domain-preserves-size _ D _).


%theorem domain-preserves-size-converse :
 forall* {M} {N} {S}
 forall {SS: set`size S N}
  {D: domain M S}
 exists {MS: size M N}
 true.

- : domain-preserves-size-converse (set`size/0) domain/0 (size/0).

- : domain-preserves-size-converse (set`size/+ SS) (domain/+ D) (size/+ MS)
    <- domain-preserves-size-converse SS D MS.

%worlds () (domain-preserves-size-converse _ _ _).
%total (D) (domain-preserves-size-converse _ D _).


%theorem domain-preserves-disjoint :
 forall* {M1} {M2} {S1} {S2}
 forall {D: disjoint M1 M2}
  {DM1: domain M1 S1}
  {DM2: domain M2 S2}
 exists {DP: set`disjoint S1 S2}
 true.

- : domain-preserves-disjoint disjoint/L _ _ set`disjoint/L.

- : domain-preserves-disjoint disjoint/R _ _ set`disjoint/R.

- : domain-preserves-disjoint
 (disjoint/< D P) (domain/+ D1) (domain/+ D2)
 (set`disjoint/< DP P)
    <- domain-preserves-disjoint D D1 (domain/+ D2) DP.

- : domain-preserves-disjoint
 (disjoint/> D P) (domain/+ D1) (domain/+ D2)
 (set`disjoint/> DP P)
    <- domain-preserves-disjoint D (domain/+ D1) D2 DP.

%worlds () (domain-preserves-disjoint _ _ _ _).
%total (D) (domain-preserves-disjoint D _ _ _).


%theorem domain-preserves-disjoint-converse :
 forall* {M1} {M2} {S1} {S2}
 forall {D: set`disjoint S1 S2}
  {DM1: domain M1 S1}
  {DM2: domain M2 S2}
 exists {DP: disjoint M1 M2}
 true.

- : domain-preserves-disjoint-converse set`disjoint/L _ _ disjoint/L.

- : domain-preserves-disjoint-converse set`disjoint/R _ _ disjoint/R.

- : domain-preserves-disjoint-converse
 (set`disjoint/< D P) (domain/+ D1) (domain/+ D2)
 (disjoint/< DP P)
    <- domain-preserves-disjoint-converse D D1 (domain/+ D2) DP.

- : domain-preserves-disjoint-converse
 (set`disjoint/> D P) (domain/+ D1) (domain/+ D2)
 (disjoint/> DP P)
    <- domain-preserves-disjoint-converse D (domain/+ D1) D2 DP.

%worlds () (domain-preserves-disjoint-converse _ _ _ _).
%total (D) (domain-preserves-disjoint-converse D _ _ _).


%theorem domain-preserves-bound :
 forall* {M} {N} {S}
 forall {MS: bound M N}
  {D: domain M S}
 exists {SS: set`bound S N}
 true.

- : domain-preserves-bound (bound/0) domain/0 (set`bound/0).

- : domain-preserves-bound (bound/+ P MS) (domain/+ D) (set`bound/+ P SS)
    <- domain-preserves-bound MS D SS.

%worlds () (domain-preserves-bound _ _ _).
%total (D) (domain-preserves-bound _ D _).


%theorem domain-preserves-bound-converse :
 forall* {M} {N} {S}
 forall {SS: set`bound S N}
  {D: domain M S}
 exists {MS: bound M N}
 true.

- : domain-preserves-bound-converse (set`bound/0) domain/0 (bound/0).

- : domain-preserves-bound-converse
 (set`bound/+ P SS) (domain/+ D) (bound/+ P MS)
    <- domain-preserves-bound-converse SS D MS.

%worlds () (domain-preserves-bound-converse _ _ _).
%total (D) (domain-preserves-bound-converse _ D _).


%theorem shift-preserves-domain* :
 forall* {N} {M1} {M2} {S1} {S2}
 forall {D1:domain M1 S1}
  {S:shift N M1 M2}
  {S:set`shift N S1 S2}
        exists {D2:domain M2 S2}
        true.

- : shift-preserves-domain* domain/0 shift/0 set`shift/0 domain/0.

- : shift-preserves-domain*
 (domain/+ D1) (shift/+ P1) (set`shift/+ P2) D2
    <- plus-deterministic P1 P2 nat`eq/ nat`eq/ N1=N2
    <- set`map/+-preserves-eq N1=N2 unit`eq/ set`eq/ S1=S2
    <- domain-respects-eq (domain/+ D1) eq/ S1=S2 D2.

%worlds () (shift-preserves-domain* _ _ _ _).
%total { } (shift-preserves-domain* _ _ _ _).


%theorem shift-preserves-domain :
 forall* {N} {M1} {M2} {S1}
 forall {D1:domain M1 S1}
  {S:shift N M1 M2}
 exists {S2}
  {S:set`shift N S1 S2}
         {D2:domain M2 S2}
        true.

- : shift-preserves-domain D1 S _ SS D2
    <- set`shift-total SS
    <- shift-preserves-domain* D1 S SS D2.

%worlds () (shift-preserves-domain _ _ _ _ _).
%total { } (shift-preserves-domain _ _ _ _ _).


%theorem shift-preserves-domain-converse :
 forall* {N} {M1} {M2} {S2}
 forall {D1:domain M2 S2}
  {S:shift N M1 M2}
 exists {S1}
  {S:set`shift N S1 S2}
         {D2:domain M1 S1}
        true.

- : shift-preserves-domain-converse domain/0 shift/0 _ set`shift/0 domain/0.

- : shift-preserves-domain-converse
 (domain/+ D) (shift/+ P) _ (set`shift/+ P) (domain/+ D).

%worlds () (shift-preserves-domain-converse _ _ _ _ _).
%total { } (shift-preserves-domain-converse _ _ _ _ _).


%theorem shift-preserves-domain-converse* :
 forall* {N} {M1} {M2} {S1} {S2}
 forall {D1:domain M2 S2}
  {S:shift N M1 M2}
  {S:set`shift N S1 S2}
        exists {D2:domain M1 S1}
        true.

- : shift-preserves-domain-converse* domain/0 shift/0 set`shift/0 domain/0.

- : shift-preserves-domain-converse*
 (domain/+ D1) (shift/+ P1) (set`shift/+ P2) D2
    <- plus-left-cancels P1 P2 nat`eq/ nat`eq/ N1=N2
    <- set`map/+-preserves-eq N1=N2 unit`eq/ set`eq/ S1=S2
    <- domain-respects-eq (domain/+ D1) eq/ S1=S2 D2.

%worlds () (shift-preserves-domain-converse* _ _ _ _).
%total { } (shift-preserves-domain-converse* _ _ _ _).


%abbrev domain-commute-shift = shift-preserves-domain*.

%theorem shift-commute-domain :
 forall* {N} {M1} {M2} {S1} {S2}
 forall {MS: shift N M1 M2}
  {D1: domain M1 S1}
  {D2: domain M2 S2}
 exists {SS: set`shift N S1 S2}
 true.

- : shift-commute-domain shift/0 domain/0 domain/0 set`shift/0.

- : shift-commute-domain (shift/+ P) (domain/+ D1) (domain/+ D2) (set`shift/+ P).

%worlds () (shift-commute-domain _ _ _ _).
%total { } (shift-commute-domain _ _ _ _).


%theorem update-commute-domain:
 forall* {M1} {N} {D} {M2} {S1} {S2}
 forall {U1: update M1 N D M2}
  {D1: domain M1 S1}
  {D2: domain M2 S2}
 exists {U2: set`add S1 N S2}
 true.

- : update-commute-domain (update/0) domain/0 (domain/+ domain/0)
 (set`update/0).

% NB: we cannot use %unique for coverage for both this and the next case.
- : update-commute-domain (update/= nat`eq/) (domain/+ D1) (domain/+ D2) SU
    <- domain-deterministic D1 D2 eq/ S1=S2
    <- set`map/+-preserves-eq nat`eq/ unit`eq/ S1=S2 SE
    <- set`add-respects-eq
 (set`update/= nat`eq/) set`eq/ nat`eq/ SE SU.

% depends on %unique for coverage.
- : update-commute-domain (update/< P) (domain/+ _) (domain/+ (domain/+ _))
 (set`update/< P).

- : update-commute-domain (update/> U1 P) (domain/+ D1) (domain/+ D2)
 (set`update/> U2 P)
    <- update-commute-domain U1 D1 D2 U2.

%worlds () (update-commute-domain _ _ _ _).
%total (U) (update-commute-domain U _ _ _).


%theorem domain-commute-update:
 forall* {M1} {N} {D} {M2} {S1} {S2}
 forall {D1: domain M1 S1}
  {U1: update M1 N D M2}
  {U2: set`add S1 N S2}
 exists {D2: domain M2 S2}
 true.

- : domain-commute-update domain/0 update/0 set`update/0 (domain/+ domain/0).

- : domain-commute-update (domain/+ D) U1 (set`update/= nat`eq/) D2
    <- update/=-inversion U1 nat`eq/ ME
    <- domain-respects-eq (domain/+ D) ME set`eq/ D2.

- : domain-commute-update (domain/+ D) U1 (set`update/< P) D2
    <- update/<-inversion U1 P ME
    <- domain-respects-eq (domain/+ (domain/+ D)) ME set`eq/ D2.

- : domain-commute-update (domain/+ D) U1 (set`update/> SA P) D2P
    <- update/>-inversion U1 P _ U ME
    <- domain-commute-update D U SA D2
    <- domain-respects-eq (domain/+ D2) ME set`eq/ D2P.

%worlds () (domain-commute-update _ _ _ _).
%total (U) (domain-commute-update U _ _ _).


%theorem domain-preserves-leq*:
 forall* {M1} {M2} {S1} {S2}
 forall {U1: leq M1 M2}
  {D1: domain M1 S1}
  {D2: domain M2 S2}
 exists {U2: set`leq S1 S2}
 true.

- : domain-preserves-leq* leq/0 domain/0 _ set`leq/0.

- : domain-preserves-leq* (leq/= L1 _ nat`eq/) (domain/+ D1) (domain/+ D2)
 (set`leq/= L2 unit`eq/ nat`eq/)
    <- domain-preserves-leq* L1 D1 D2 L2.

- : domain-preserves-leq* (leq/> L1 P) (domain/+ D1) (domain/+ D2)
 (set`leq/> L2 P)
    <- domain-preserves-leq* L1 (domain/+ D1) D2 L2.

%worlds () (domain-preserves-leq* _ _ _ _).
%total (L) (domain-preserves-leq* L _ _ _).


%theorem domain-preserves-leq:
 forall* {M1} {M2} {S1}
 forall {L1: leq M1 M2}
  {D1: domain M1 S1}
 exists {S2}
  {D2: domain M2 S2}
  {L2: set`leq S1 S2}
 true.

- : domain-preserves-leq L1 D1 _ D2 L2
    <- domain-total D2
    <- domain-preserves-leq* L1 D1 D2 L2.

%worlds () (domain-preserves-leq _ _ _ _ _).
%total { } (domain-preserves-leq _ _ _ _ _).

%%%% Map addition



%%% Definition of join


join : map -> map -> map -> type.


join/L : join map/0 M M.

join/R : join M map/0 M.

join/= : join (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N1 D3 M3)
    <- nat`eq N1 N2
    <- inner-efxmap`join D1 D2 D3
    <- join M1 M2 M3.

join/< : join (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N1 D1 M3)
    <- nat`plus (s N0) N1 N2
    <- join M1 (map/+ N0 D2 M2) M3.

join/> : join (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N2 D2 M3)
    <- nat`plus (s N3) N2 N1
    <- join (map/+ N3 D1 M1) M2 M3.



%%% Theorems about join


%theorem false-implies-join :
 forall* {M1} {M2} {M3}
 forall {F:void}
 exists {D:join M1 M2 M3}
 true.

%worlds () (false-implies-join _ _).
%total {} (false-implies-join _ _).


%theorem join-respects-eq :
 forall* {M1} {M2} {M3} {M1P} {M2P} {M3P}
 forall {A:join M1 M2 M3} {E1:eq M1 M1P} {E2:eq M2 M2P} {E3:eq M3 M3P}
 exists {AP:join M1P M2P M3P}
 true.

- : join-respects-eq A eq/ eq/ eq/ A.

%worlds () (join-respects-eq _ _ _ _ _).
%total {} (join-respects-eq _ _ _ _ _).
%reduces A = AP (join-respects-eq A _ _ _ AP).


%% A way to get a join fact.

%theorem can-construct-unit-join:
 forall* {N} {D} {M1} {M}
 forall {S: shift N M1 M}
 exists {A: join M (map/+ N D map/0) (map/+ N D M1)}
 true.

- : can-construct-unit-join shift/0 join/L.

- : can-construct-unit-join (shift/+ P) (join/> join/R PPP)
    <- plus-swap-succ P PP
    <- plus-commutative PP PPP.

%worlds () (can-construct-unit-join _ _).
%total { } (can-construct-unit-join _ _).


%% Inversion lemmas for join

%theorem join/=-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {M}
 forall {A:join (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
        {G:nat`eq N1 N2}
 exists {D3} {M3}
        {D:inner-efxmap`join D1 D2 D3}
               {AP:join M1 M2 M3}
               {E:eq M (map/+ N1 D3 M3)}
 true.

- : join/=-inversion (join/= MM DD nat`eq/) _ _ _ DD MM eq/.

- : join/=-inversion (join/< (JP:join _ (map/+ N0 D2 M2) M3) N0+1+N=N) nat`eq/
                     D2 M3 DJ MJ ME
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- inner-efxmap`false-implies-join F DJ
    <- false-implies-eq F (M022=M2:eq (map/+ N0 D2 M2) M2)
    <- join-respects-eq JP eq/ M022=M2 eq/ MJ
    <- false-implies-eq F ME.

- : join/=-inversion (join/> (JP:join (map/+ _ D1 M1) M2 M3) N3+1+N=N) nat`eq/
                     D1 M3 DJ MJ ME
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- inner-efxmap`false-implies-join F DJ
    <- false-implies-eq F (M311=M1:eq (map/+ N3 D1 M1) M1)
    <- join-respects-eq JP M311=M1 eq/ eq/ MJ
    <- false-implies-eq F ME.

%worlds () (join/=-inversion _ _ _ _ _ _ _).
%total {} (join/=-inversion _ _ _ _ _ _ _).
%reduces JP < J (join/=-inversion J _ _ _ _ JP _).


%theorem join/<-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {M} {N0}
 forall {A:join (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
               {P:plus (s N0) N1 N2}
 exists {M3}
               {AP:join M1 (map/+ N0 D2 M2) M3}
               {E:eq M (map/+ N1 D1 M3)}
 true.

- : join/<-inversion (join/< J P) PP _ JP eq/
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P inner-efxmap`eq/ eq/ M022=M022P
    <- join-respects-eq J eq/ M022=M022P eq/ JP.

- : join/<-inversion (join/= JP _ nat`eq/) N0+1+N=N M3 J E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M2=M022
    <- join-respects-eq JP eq/ M2=M022 eq/ J
    <- false-implies-eq F E.

- : join/<-inversion (join/> JP N3+1+N2=N1) N0+1+N1=N2 M3 J E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M311=M1
    <- false-implies-eq F M2=M022
    <- join-respects-eq JP M311=M1 M2=M022 eq/ J
    <- false-implies-eq F E.

%worlds () (join/<-inversion _ _ _ _ _).
%total {} (join/<-inversion _ _ _ _ _).
%reduces JP < J (join/<-inversion J _ _ JP _).


%theorem join/>-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {M}
 forall {A:join (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
        {P:plus (s N3) N2 N1}
 exists {M3}
               {AP:join (map/+ N3 D1 M1) M2 M3}
               {E:eq M (map/+ N2 D2 M3)}
 true.

- : join/>-inversion (join/> J P) PP _ JP eq/
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P inner-efxmap`eq/ eq/ M311=M311P
    <- join-respects-eq J M311=M311P eq/ eq/ JP.

- : join/>-inversion (join/= JP _ nat`eq/) N3+1+N=N M3 J E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M1=M311
    <- join-respects-eq JP M1=M311 eq/ eq/ J
    <- false-implies-eq F E.

- : join/>-inversion (join/< JP N0+1+N1=N2) N3+1+N2=N1 M3 J E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M1=M311
    <- false-implies-eq F M022=M2
    <- join-respects-eq JP M1=M311 M022=M2 eq/ J
    <- false-implies-eq F E.

%worlds () (join/>-inversion _ _ _ _ _).
%total {} (join/>-inversion _ _ _ _ _).
%reduces JP < J (join/>-inversion J _ _ JP _).


%theorem join-deterministic :
 forall* {M1} {M2} {M3} {M1P} {M2P} {M3P}
 forall {A:join M1 M2 M3} {AP:join M1P M2P M3P}
               {E1:eq M1 M1P} {E2:eq M2 M2P}
 exists {E3:eq M3 M3P}
 true.

%abbrev join-unique = join-deterministic.

- : join-deterministic join/L join/L eq/ eq/ eq/.

- : join-deterministic join/L join/R eq/ eq/ eq/.

- : join-deterministic join/R join/L eq/ eq/ eq/.

- : join-deterministic join/R join/R eq/ eq/ eq/.

- : join-deterministic (join/= M1+M2=M3 D1+D2=D3 nat`eq/)
                      (join/= M1+M2=M3P D1+D2=D3P nat`eq/)
        eq/ eq/ M=MP
    <- inner-efxmap`join-deterministic D1+D2=D3 D1+D2=D3P inner-efxmap`eq/ inner-efxmap`eq/ D3=D3P
    <- join-deterministic M1+M2=M3 M1+M2=M3P eq/ eq/ M3=M3P
    <- map/+-preserves-eq nat`eq/ D3=D3P M3=M3P M=MP.

- : join-deterministic (join/< M1+MT=M3 N0+1+N1=N2)
                      (join/< M1+MTP=M3P N0P+1+N1=N2)
        eq/ eq/ M=MP
    <- plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P inner-efxmap`eq/ eq/ MT=MTP
    <- join-deterministic M1+MT=M3 M1+MTP=M3P eq/ MT=MTP M3=M3P
    <- map/+-preserves-eq nat`eq/ inner-efxmap`eq/ M3=M3P M=MP.

- : join-deterministic (join/> MT+M2=M3 N3+1+N2=N1)
                      (join/> MTP+M2=M3P N3P+1+N2=N1) eq/ eq/ E
    <- plus-right-cancels N3+1+N2=N1 N3P+1+N2=N1 nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P inner-efxmap`eq/ eq/ MT=MTP
    <- join-deterministic MT+M2=M3 MTP+M2=M3P MT=MTP eq/ M3=M3P
    <- map/+-preserves-eq nat`eq/ inner-efxmap`eq/ M3=M3P E.

%% contradiction cases:

- : join-deterministic (join/= _ _ nat`eq/) (join/< _ NP+1+N=N) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : join-deterministic (join/= _ _ nat`eq/) (join/> _ NP+1+N=N) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : join-deterministic (join/< _ NP+1+N=N) (join/= _ _ nat`eq/) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : join-deterministic (join/< _ N0+1+N1=N2) (join/> _ N3+1+N2=N1) eq/ eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

- : join-deterministic (join/> _ NP+1+N=N) (join/= _ _ nat`eq/) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : join-deterministic (join/> _ N3+1+N2=N1) (join/< _ N0+1+N1=N2) eq/ eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (join-deterministic _ _ _ _ _).
%total (A) (join-deterministic A _ _ _ _).




%theorem disjoint-join-total :
 forall* {M1} {M2}
 forall {D:disjoint M1 M2}
 exists {M3} {A:join M1 M2 M3}
 true.

- : disjoint-join-total disjoint/L _ join/L.

- : disjoint-join-total disjoint/R _ join/R.

- : disjoint-join-total (disjoint/< D P) _ (join/< J P)
    <- disjoint-join-total D _ J.

- : disjoint-join-total (disjoint/> D P) _ (join/> J P)
    <- disjoint-join-total D _ J.

%worlds () (disjoint-join-total _ _ _).
%total (D) (disjoint-join-total D _ _).


%theorem disjoint-join-commutative :
        forall* {M1} {M2} {M3}
        forall {D: disjoint M1 M2}
                {J: join M1 M2 M3}
        exists {J: join M2 M1 M3}
        true.

- : disjoint-join-commutative _ join/L join/R.

- : disjoint-join-commutative _ join/R join/L.

- : disjoint-join-commutative D (join/= _ _ nat`eq/) J
    <- disjoint/=-contradiction D nat`eq/ F
    <- false-implies-join F J.

- : disjoint-join-commutative D (join/< J1 P) (join/> J1P P)
    <- disjoint/<-inversion D P D1
    <- disjoint-join-commutative D1 J1 J1P.

- : disjoint-join-commutative D (join/> J1 P) (join/< J1P P)
    <- disjoint/>-inversion D P D1
    <- disjoint-join-commutative D1 J1 J1P.

%worlds () (disjoint-join-commutative _ _ _).
%total (J) (disjoint-join-commutative _ J _).


%theorem join-empty-implies-empty :
 forall* {M1} {M2}
 forall {A:join M1 M2 map/0}
 exists {E1:eq M1 map/0} {E2:eq M2 map/0}
 true.

- : join-empty-implies-empty join/L eq/ eq/.

- : join-empty-implies-empty join/R eq/ eq/.

%worlds () (join-empty-implies-empty _ _ _).
%total { } (join-empty-implies-empty _ _ _).


%theorem join-preserves-disjoint* :
 forall* {M1} {M2} {M3} {M4}
 forall {D1:disjoint M1 M4} {D2:disjoint M2 M4}
        {A:join M1 M2 M3}
 exists {D3:disjoint M3 M4}
 true.

% a lemma that counts the size of maps to help prove termination
%theorem join-preserves-disjoint*/L :
 forall* {M1} {M2} {M3} {M4}
 forall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2}
               {D1:disjoint M1 M4} {D2:disjoint M2 M4}
        {A:join M1 M2 M3}
 exists {D3:disjoint M3 M4}
 true.

- : join-preserves-disjoint* D1 D2 J D3
    <- size-total SZ1
    <- size-total SZ2
    <- join-preserves-disjoint*/L _ _ SZ1 SZ2 D1 D2 J D3.

- : join-preserves-disjoint*/L _ _ _ _ disjoint/R _ _ disjoint/R.

- : join-preserves-disjoint*/L _ _ _ _ _ disjoint/R _ disjoint/R.

- : join-preserves-disjoint*/L _ _ _ _ _ D join/L D.

- : join-preserves-disjoint*/L _ _ _ _ D _ join/R D.

- : join-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/< D1 N5+1+N1=N4) D2X
                               (join/= J _ nat`eq/)
                               (disjoint/< D3 N5+1+N1=N4)
    <- disjoint/<-inversion D2X N5+1+N1=N4 D2
    <- join-preserves-disjoint*/L S1 S2 SZ1 SZ2 D1 D2 J D3.

- : join-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/< D1 N5+1+N1=N4) D2X
                               (join/> J N3+1+N2=N1)
                               (disjoint/< D3 N6+1+N2=N4)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N5+1+N1=N4 N6 N5+1+N3=N6 N6+N2+1=N4
    <- plus-swap-succ-converse N6+N2+1=N4 N6+1+N2=N4
    <- disjoint/<-inversion D2X N6+1+N2=N4 D2
    <- plus-swap-succ N5+1+N3=N6 N5+N3+1=N6
    <- plus-commutative N5+N3+1=N6 N3+1+N5=N6
    <- shift-right-preserves-disjoint D1 (shift/+ N3+1+N5=N6) D1<<N3
    <- join-preserves-disjoint*/L (s S1) S2 (size/+ SZ1) SZ2 D1<<N3 D2 J D3.

- : join-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/> D1 N5+1+N4=N1) D2X
                               (join/= J DJ nat`eq/)
                               (disjoint/> D3 N5+1+N4=N1)
    <- disjoint/>-inversion D2X N5+1+N4=N1 D2
    <- join-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2)
                                  D1 D2 (join/= J DJ nat`eq/) D3.

- : join-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/> D1 N5+1+N4=N1) D2X
                               (join/< J N0+1+N1=N2)
                               (disjoint/> D3 N5+1+N4=N1)
    <- plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 N6 N0+1+N5=N6 N6+N4+1=N2
    <- plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2
    <- disjoint/>-inversion D2X N6+1+N4=N2 D2
    <- join-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2)
                                  D1 D2 (join/< J N0+1+N5=N6) D3.

- : join-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               D1X (disjoint/< D2 N6+1+N2=N4)
                               (join/< J N0+1+N1=N2)
                               (disjoint/< D3 N5+1+N1=N4)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N6+1+N2=N4 N5 N6+1+N0=N5 N5+N1+1=N4
    <- plus-swap-succ-converse N5+N1+1=N4 N5+1+N1=N4
    <- disjoint/<-inversion D1X N5+1+N1=N4 D1
    <- plus-swap-succ N6+1+N0=N5 N6+N0+1=N5
    <- plus-commutative N6+N0+1=N5 N0+1+N6=N5
    <- shift-right-preserves-disjoint D2 (shift/+ N0+1+N6=N5) D2<<N0
    <- join-preserves-disjoint*/L S1 (s S2) SZ1 (size/+ SZ2) D1 D2<<N0 J D3.

- : join-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               D1X (disjoint/> D2 N6+1+N4=N2)
                               (join/> J N3+1+N2=N1)
                               (disjoint/> D3 N6+1+N4=N2)
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 N5 N3+1+N6=N5 N5+N4+1=N1
    <- plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1
    <- disjoint/>-inversion D1X N5+1+N4=N1 D1
    <- join-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2)
                                  D1 D2 (join/> J N3+1+N6=N5) D3.

- : join-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/< D1 N5+1+N1=N4)
                               (disjoint/> D2 N6+1+N4=N2) JX D3X
    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 N0 N6+1+N5=N0 N0+N1+1=N2
    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2
    <- join/<-inversion JX N0+1+N1=N2 _ J M=M113
    <- eq-symmetric M=M113 M113=M
    <- join-preserves-disjoint*/L S1 (s S2) SZ1 (size/+ SZ2)
                                  D1 (disjoint/> D2 N6+1+N5=N0) J D3
    <- disjoint-respects-eq (disjoint/< D3 N5+1+N1=N4) M113=M eq/ D3X.

- : join-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/> D1 N5+1+N4=N1)
                               (disjoint/< D2 N6+1+N2=N4) JX D3X
    <- plus-swap-succ N6+1+N2=N4 N6+N2+1=N4
    <- plus-associative-converse N6+N2+1=N4 N5+1+N4=N1 N3 N5+1+N6=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- join/>-inversion JX N3+1+N2=N1 _ J M=M223
    <- eq-symmetric M=M223 M223=M
    <- join-preserves-disjoint*/L _ _ (size/+ SZ1) SZ2
                                  (disjoint/> D1 N5+1+N6=N3) D2 J D3
    <- disjoint-respects-eq (disjoint/< D3 N6+1+N2=N4) M223=M eq/ D3X.

%worlds () (join-preserves-disjoint*/L _ _ _ _ _ _ _ _).
%total {S1 S2 D1} (join-preserves-disjoint*/L S1 S2 _ _ D1 _ _ _).

%worlds () (join-preserves-disjoint* _ _ _ _).
%total { } (join-preserves-disjoint* _ _ _ _).


%abbrev join-left-preserves-disjoint* = join-preserves-disjoint*.

%theorem join-right-preserves-disjoint* :
 forall* {M1} {M2} {M3} {M0}
 forall {D1:disjoint M0 M1} {D2:disjoint M0 M2}
        {A:join M1 M2 M3}
 exists {D3:disjoint M0 M3}
 true.

- : join-right-preserves-disjoint* D1 D2 U D3
    <- disjoint-symmetric D1 D1s
    <- disjoint-symmetric D2 D2s
    <- join-left-preserves-disjoint* D1s D2s U D3s
    <- disjoint-symmetric D3s D3.

%worlds () (join-right-preserves-disjoint* _ _ _ _).
%total { } (join-right-preserves-disjoint* _ _ _ _).


%theorem join-preserves-disjoint-converse:
 forall* {M1} {M2} {M3} {M4}
 forall {D3:disjoint M3 M4}
        {A:join M1 M2 M3}
 exists {D1:disjoint M1 M4} {D2:disjoint M2 M4}
 true.

- : join-preserves-disjoint-converse
 D join/L disjoint/L D.

- : join-preserves-disjoint-converse
 D join/R D disjoint/L.

- : join-preserves-disjoint-converse
 disjoint/R _
 disjoint/R disjoint/R.

- : join-preserves-disjoint-converse
 (disjoint/< D P)
 (join/= J _ nat`eq/)
 (disjoint/< D1 P) (disjoint/< D2 P)
    <- join-preserves-disjoint-converse D J D1 D2.

- : join-preserves-disjoint-converse
        (disjoint/< D P1)
        (join/< J P2)
 (disjoint/< D1 P1) D2S
    <- join-preserves-disjoint-converse D J D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-disjoint D2 (shift/+ P2sc) (shift/+ P1sc) D2S.

- : join-preserves-disjoint-converse
        (disjoint/< D P1)
        (join/> J P2)
 D1S (disjoint/< D2 P1)
    <- join-preserves-disjoint-converse D J D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-disjoint D1 (shift/+ P2sc) (shift/+ P1sc) D1S.

- : join-preserves-disjoint-converse
 (disjoint/> D P1)
 (join/= J DE nat`eq/)
 D1S D2S
    <- join-preserves-disjoint-converse D (join/= J DE nat`eq/) D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- shift-left-preserves-disjoint D1 (shift/+ P1sc) D1S
    <- shift-left-preserves-disjoint D2 (shift/+ P1sc) D2S.

- : join-preserves-disjoint-converse
 (disjoint/> D P1)
 (join/< J P2)
        D1S D2S
    <- plus-swap-succ P1 P1s
    <- plus-associative-converse P1s P2 _ P3 P4s
    <- join-preserves-disjoint-converse D (join/< J P3) D1 D2
    <- plus-commutative P1s P1sc
    <- plus-commutative P4s P4sc
    <- shift-left-preserves-disjoint D1 (shift/+ P1sc) D1S
    <- shift-left-preserves-disjoint D2 (shift/+ P4sc) D2S.

- : join-preserves-disjoint-converse
 (disjoint/> D P1)
 (join/> J P2)
 D1S D2S
    <- plus-swap-succ P1 P1s
    <- plus-associative-converse P1s P2 _ P3 P4s
    <- join-preserves-disjoint-converse D (join/> J P3) D1 D2
    <- plus-commutative P1s P1sc
    <- plus-commutative P4s P4sc
    <- shift-left-preserves-disjoint D1 (shift/+ P4sc) D1S
    <- shift-left-preserves-disjoint D2 (shift/+ P1sc) D2S.

%worlds () (join-preserves-disjoint-converse _ _ _ _).
%total (D) (join-preserves-disjoint-converse D _ _ _).


%theorem disjoint-join-right-cancels :
        forall* {A1} {B1} {C1} {A2} {B2} {C2}
        forall {D1: disjoint A1 B1}
                {J1: join A1 B1 C1}
                {D2: disjoint A2 B2}
                {J2: join A2 B2 C2}
                {EB: eq B1 B2}
                {EC: eq C1 C2}
        exists {EA: eq A1 A2}
        true.

%theorem disjoint-join-right-cancels/L :
 forall* {A} {B} {C}
 forall {D: disjoint A B}
  {J: join A B C}
  {E: eq B C}
 exists {E: eq map/0 A}
 true.

- : disjoint-join-right-cancels/L A^B A+B=B eq/ Z=A
    <- disjoint-symmetric A^B B^A
    <- join-preserves-disjoint-converse B^A A+B=B A^A _
    <- disjoint-anti-reflexive A^A Z=A.

%worlds () (disjoint-join-right-cancels/L _ _ _ _).
%total { } (disjoint-join-right-cancels/L _ _ _ _).

- : disjoint-join-right-cancels
        disjoint/L J1 A2^B J2 eq/ eq/ Z=A2
    <- join-deterministic J1 join/L eq/ eq/ C=B
    <- disjoint-join-right-cancels/L A2^B J2 C=B Z=A2.

- : disjoint-join-right-cancels
        A1^B J1 disjoint/L J2 eq/ eq/ A1=Z
    <- join-deterministic J2 join/L eq/ eq/ C=B
    <- disjoint-join-right-cancels/L A1^B J1 C=B Z=A1
    <- eq-symmetric Z=A1 A1=Z.

- : disjoint-join-right-cancels
        disjoint/R J1 _ J2 eq/ eq/ A1=A2
    <- join-deterministic J1 join/R eq/ eq/ A1=C
    <- join-deterministic join/R J2 eq/ eq/ C=A2
    <- eq-transitive A1=C C=A2 A1=A2.

- : disjoint-join-right-cancels
        (disjoint/< D1P P1) J1 (disjoint/< D2P P2) J2
        eq/ eq/ A111=A222
    <- join/<-inversion J1 P1 _ J1P EQ1
    <- join/<-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C225
    <- map/+-preserves-eq-converse C114=C225 N1=N2 D1=D2 C4=C5
    <- plus-right-cancels P1 P2 N1=N2 nat`eq/ SN4=SN5
    <- succ-cancels SN4=SN5 N4=N5
    <- map/+-preserves-eq N4=N5 inner-efxmap`eq/ eq/ B4=B5
    <- disjoint-join-right-cancels D1P J1P D2P J2P B4=B5 C4=C5 A1=A2
    <- map/+-preserves-eq N1=N2 D1=D2 A1=A2 A111=A222.

- : disjoint-join-right-cancels
        (disjoint/< D1P P1) J1 (disjoint/> D2P P2) J2
        eq/ eq/ EQ
    <- join/<-inversion J1 P1 _ J1P EQ1
    <- join/>-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C225
    <- map/+-preserves-eq-converse C114=C225 N1=N2 _ _
    <- plus-implies-gt P1 nat`eq/ N2>N1
    <- gt-respects-eq N2>N1 nat`eq/ N1=N2 N2>N2
    <- gt-anti-reflexive N2>N2 F
    <- false-implies-eq F EQ.

- : disjoint-join-right-cancels
        (disjoint/> D1P P1) J1 (disjoint/< D2P P2) J2
        eq/ eq/ EQ
    <- join/>-inversion J1 P1 _ J1P EQ1
    <- join/<-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C225
    <- map/+-preserves-eq-converse C114=C225 N1=N2 _ _
    <- plus-implies-gt P2 nat`eq/ N1>N2
    <- gt-respects-eq N1>N2 N1=N2 nat`eq/ N2>N2
    <- gt-anti-reflexive N2>N2 F
    <- false-implies-eq F EQ.

- : disjoint-join-right-cancels
        (disjoint/> D1P P1) J1 (disjoint/> D2P P2) J2
        eq/ eq/ A111=A222
    <- join/>-inversion J1 P1 _ J1P EQ1
    <- join/>-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C115
    <- map/+-preserves-eq-converse C114=C115 _ _ C4=C5
    <- disjoint-join-right-cancels D1P J1P D2P J2P eq/ C4=C5 A411=A511
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-deterministic
        (shift/+ P1sc) (shift/+ P2sc) nat`eq/ A411=A511 A111=A222.

%worlds () (disjoint-join-right-cancels _ _ _ _ _ _ _).
%total (D) (disjoint-join-right-cancels D _ _ _ _ _ _).


%theorem disjoint-join-left-cancels :
        forall* {A1} {B1} {C1} {A2} {B2} {C2}
        forall {D1: disjoint A1 B1}
                {J1: join A1 B1 C1}
                {D2: disjoint A2 B2}
                {J2: join A2 B2 C2}
                {EB: eq A1 A2}
                {EC: eq C1 C2}
        exists {EA: eq B1 B2}
        true.

- : disjoint-join-left-cancels D1 J1 D2 J2 EB EC EA
    <- disjoint-join-commutative D1 J1 J1c
    <- disjoint-join-commutative D2 J2 J2c
    <- disjoint-symmetric D1 D1s
    <- disjoint-symmetric D2 D2s
    <- disjoint-join-right-cancels D1s J1c D2s J2c EB EC EA.

%worlds () (disjoint-join-left-cancels _ _ _ _ _ _ _).
%total { } (disjoint-join-left-cancels _ _ _ _ _ _ _).


%theorem shift-left-preserves-join :
 forall* {N} {D} {M1} {M2} {M3} {SM1}
 forall {A:join M1 M2 M3} {S1:shift N M1 SM1}
        exists {SA:join SM1 (map/+ N D M2) (map/+ N D M3)}
        true.

- : shift-left-preserves-join join/L shift/0 join/L.

- : shift-left-preserves-join join/R shift/0 join/L.

- : shift-left-preserves-join M111+M2=M3 (shift/+ N+1+N1=N1P)
                              (join/> M111+M2=M3 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-join _ _ _).
%total { } (shift-left-preserves-join _ _ _).


%theorem shift-left-preserves-join-converse :
 forall* {N} {D} {M1} {M2} {SM1} {SM3}
 forall {SA:join SM1 (map/+ N D M2) SM3} {S1:shift N M1 SM1}
        exists {M3} {A:join M1 M2 M3} {E:eq (map/+ N D M3) SM3}
 true.

- : shift-left-preserves-join-converse join/L shift/0 _ join/L eq/.

- : shift-left-preserves-join-converse M111+M222=SM3 (shift/+ N2+1+N3=N1) M3
                                       M311+M2=M3 M223=SM3
    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1
    <- join/>-inversion M111+M222=SM3 N3+1+N2=N1 M3 M311+M2=M3 SM3=M223
    <- eq-symmetric SM3=M223 M223=SM3.

%worlds () (shift-left-preserves-join-converse _ _ _ _ _).
%total { } (shift-left-preserves-join-converse _ _ _ _ _).


%theorem shift-right-preserves-join :
 forall* {N} {D} {M1} {M2} {M3} {SM2}
 forall {A:join M1 M2 M3} {S2:shift N M2 SM2}
        exists {SA:join (map/+ N D M1) SM2 (map/+ N D M3)}
 true.

- : shift-right-preserves-join join/L shift/0 join/R.

- : shift-right-preserves-join join/R shift/0 join/R.

- : shift-right-preserves-join M1+M222=M3 (shift/+ N+1+N2=N2P)
                               (join/< M1+M222=M3 N2+1+N=N2P)
    <- plus-swap-succ N+1+N2=N2P N+N2+1=N2P
    <- plus-commutative N+N2+1=N2P N2+1+N=N2P.

%worlds () (shift-right-preserves-join _ _ _).
%total { } (shift-right-preserves-join _ _ _).


%theorem shift-right-preserves-join-converse :
 forall* {N} {D} {M1} {M2} {SM2} {SM3}
 forall {SA:join (map/+ N D M1) SM2 SM3} {S2:shift N M2 SM2}
        exists {M3} {A:join M1 M2 M3} {E:eq (map/+ N D M3) SM3}
 true.

- : shift-right-preserves-join-converse join/R shift/0 _ join/R eq/.

- : shift-right-preserves-join-converse M111+M322=SM3 (shift/+ N1+1+N2=N3)
                                        M3 M1+M222=M3 M133=SM3
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- join/<-inversion M111+M322=SM3 N2+1+N1=N3 M3 M1+M222=M3 SM3=M133
    <- eq-symmetric SM3=M133 M133=SM3.

%worlds () (shift-right-preserves-join-converse _ _ _ _ _).
%total { } (shift-right-preserves-join-converse _ _ _ _ _).


%theorem shift-preserves-join* :
 forall* {N} {M1} {M2} {M3} {SM1} {SM2} {SM3}
 forall {A:join M1 M2 M3}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} {S3:shift N M3 SM3}
 exists {SA:join SM1 SM2 SM3}
 true.

- : shift-preserves-join* join/L shift/0 M2<<N=SM2 M2<<N=SM3 Z+SM2=SM3
    <- shift-deterministic M2<<N=SM2 M2<<N=SM3 nat`eq/ eq/ SM2=SM3
    <- join-respects-eq join/L eq/ eq/ SM2=SM3 Z+SM2=SM3.

- : shift-preserves-join* join/R M1<<N=SM1 shift/0 M1<<N=SM3 SM1+0=SM3
    <- shift-deterministic M1<<N=SM1 M1<<N=SM3 nat`eq/ eq/ SM1=SM3
    <- join-respects-eq join/R eq/ eq/ SM1=SM3 SM1+0=SM3.

- : shift-preserves-join* (join/= M1+M2=M3 D1+D2=D3 nat`eq/)
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N1=N5)
                          (shift/+ N+1+N1=N6)
                          M411+M522=M633
    <- plus-deterministic N+1+N1=N4 N+1+N1=N5 nat`eq/ nat`eq/ N4=N5
    <- plus-deterministic N+1+N1=N4 N+1+N1=N6 nat`eq/ nat`eq/ N4=N6
    <- map/+-preserves-eq N4=N6 inner-efxmap`eq/ eq/ M433=M633
    <- join-respects-eq (join/= M1+M2=M3 D1+D2=D3 N4=N5) eq/ eq/ M433=M633
                        M411+M522=M633.

- : shift-preserves-join* (join/< M1+M022=M3 N0+1+N1=N2)
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                          (shift/+ N+1+N1=N6) M411+M522=M613
    <- plus-deterministic N+1+N1=N4 N+1+N1=N6 nat`eq/ nat`eq/ N4=N6
    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4
    <- plus-commutative N+N1+1=N4 N1+1+N=N4
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5
    <- map/+-preserves-eq N4=N6 inner-efxmap`eq/ eq/ M433=M613
    <- join-respects-eq (join/< M1+M022=M3 N0+1+N4=N5) eq/ eq/ M433=M613
                        M411+M522=M613.

- : shift-preserves-join* (join/> M311+M2=M3 N3+1+N2=N1)
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                          (shift/+ N+1+N2=N6) M411+M522=M623
    <- plus-deterministic N+1+N2=N5 N+1+N2=N6 nat`eq/ nat`eq/ N5=N6
    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5
    <- plus-commutative N+N2+1=N5 N2+1+N=N5
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- map/+-preserves-eq N5=N6 inner-efxmap`eq/ eq/ M523=M623
    <- join-respects-eq (join/> M311+M2=M3 N3+1+N5=N4) eq/ eq/ M523=M623
                        M411+M522=M623.

%worlds () (shift-preserves-join* _ _ _ _ _).
%total { } (shift-preserves-join* _ _ _ _ _).


%theorem shift-preserves-join :
 forall* {N} {M1} {M2} {M3} {SM1} {SM2}
 forall {A:join M1 M2 M3}
                {S1:shift N M1 SM1} {S2:shift N M2 SM2}
 exists {SM3}
  {S3:shift N M3 SM3}
  {SA:join SM1 SM2 SM3}
 true.

- : shift-preserves-join J S1 S2 _ S3 JP
    <- shift-total S3
    <- shift-preserves-join* J S1 S2 S3 JP.

%worlds () (shift-preserves-join _ _ _ _ _ _).
%total { } (shift-preserves-join _ _ _ _ _ _).


%theorem shift-preserves-join-converse :
 forall* {N} {M1} {M2} {SM1} {SM2} {SM3}
 forall {SA:join SM1 SM2 SM3}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2}
 exists {M3} {A:join M1 M2 M3} {S3:shift N M3 SM3}
 true.

- : shift-preserves-join-converse join/L shift/0 M2<<N=SM2 _ join/L M2<<N=SM2.

- : shift-preserves-join-converse join/R M1<<N=SM1 shift/0 _ join/R M1<<N=SM1.

- : shift-preserves-join-converse (join/= M1+M2=M3 D1+D2=D3 nat`eq/)
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N1P=N4)
                                  (map/+ N1 D3 M3) M111+M122P=M133
                                  (shift/+ N+1+N1=N4)
    <- plus-left-cancels N+1+N1=N4 N+1+N1P=N4 nat`eq/ nat`eq/ N1=N1P
    <- map/+-preserves-eq N1=N1P inner-efxmap`eq/ eq/ M122=M122P
    <- join-respects-eq (join/= M1+M2=M3 D1+D2=D3 nat`eq/) eq/ M122=M122P eq/
                        M111+M122P=M133.

- : shift-preserves-join-converse (join/< M1+M055=M3 N0+1+N4=N5)
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) _
      (join/< M1+M055=M3 N0+1+N1=N2)
      (shift/+ N+1+N1=N4)
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4
    <- plus-associative-converse N1+N+1=N4 N0+1+N4=N5 N2P N0+1+N1=N2P N2P+N+1=N5
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-right-cancels N2P+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2P=N2
    <- plus-respects-eq N0+1+N1=N2P nat`eq/ nat`eq/ N2P=N2 N0+1+N1=N2.

- : shift-preserves-join-converse (join/> M611+M2=M3 N6+1+N5=N4)
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) _
                                  (join/> M611+M2=M3 N6+1+N2=N1)
                                  (shift/+ N+1+N2=N5)
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5
    <- plus-associative-converse N2+N+1=N5 N6+1+N5=N4 N1P N6+1+N2=N1P N1P+N+1=N4
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-right-cancels N1P+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1P=N1
    <- plus-respects-eq N6+1+N2=N1P nat`eq/ nat`eq/ N1P=N1 N6+1+N2=N1.

%worlds () (shift-preserves-join-converse _ _ _ _ _ _).
%total { } (shift-preserves-join-converse _ _ _ _ _ _).


% arguably: this should be the non-starred version
%theorem shift-preserves-join-converse* :
 forall* {N} {M3} {SM1} {SM2} {SM3}
 forall {SA:join SM1 SM2 SM3} {S3:shift N M3 SM3}
 exists {M1} {M2}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2}
        {A:join M1 M2 M3}
 true.

- : shift-preserves-join-converse* U shift/0 _ _ shift/0 shift/0 join/L.

- : shift-preserves-join-converse* join/L S _ _ shift/0 S join/L.

- : shift-preserves-join-converse* join/R S _ _ S shift/0 join/R.

- : shift-preserves-join-converse* (join/= U DJ nat`eq/) (shift/+ P) _ _
 (shift/+ P) (shift/+ P) (join/= U DJ nat`eq/).

- : shift-preserves-join-converse* (join/< U D+1+A=B)
 (shift/+ N+1+Y=A) _ _
 (shift/+ N+1+Y=A)
 (shift/+ N+1+Z=B)
 (join/< U D+1+Y=Z)
    <- plus-commutative N+1+Y=A Y+N+1=A
    <- plus-associative-converse Y+N+1=A D+1+A=B Z D+1+Y=Z Z+N+1=B
    <- plus-commutative Z+N+1=B N+1+Z=B.

- : shift-preserves-join-converse* (join/> U D+1+B=A)
 (shift/+ N+1+Y=B) _ _
 (shift/+ N+1+Z=A)
 (shift/+ N+1+Y=B)
 (join/> U D+1+Y=Z)
    <- plus-commutative N+1+Y=B Y+N+1=B
    <- plus-associative-converse Y+N+1=B D+1+B=A Z D+1+Y=Z Z+N+1=A
    <- plus-commutative Z+N+1=A N+1+Z=A.

%worlds () (shift-preserves-join-converse* _ _ _ _ _ _ _).
%total { } (shift-preserves-join-converse* _ _ _ _ _ _ _).


%theorem shift-preserves-join-converse** :
 forall* {N} {M1} {M2} {M3} {SM1} {SM2} {SM3}
 forall {SA:join SM1 SM2 SM3} {S3:shift N M3 SM3}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2}
 exists {A:join M1 M2 M3}
 true.

- : shift-preserves-join-converse** JP S3 S1 S2 J
    <- shift-preserves-join-converse JP S1 S2 _ JX S3X
    <- shift-cancels S3X S3 nat`eq/ eq/ M3X=M3
    <- join-respects-eq JX eq/ eq/ M3X=M3 J.

%worlds () (shift-preserves-join-converse** _ _ _ _ _).
%total { } (shift-preserves-join-converse** _ _ _ _ _).





%theorem lookup-implies-join :
 forall* {M} {N} {D}
 forall {L:lookup M N D}
 exists {M-} {F:fresh M- N}
        {A:join (map/+ N D map/0) M- M}
 true.

- : lookup-implies-join (lookup/= nat`eq/) _
                        (fresh/0) (join/R).

- : lookup-implies-join (lookup/= nat`eq/) _
                        (fresh/< N2>N1)
                        (join/< join/L N0+1+N1=N2)
    <- nat`plus-total N0+1+N1=N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1.

- : lookup-implies-join (lookup/> L N0+1+N1=N2) _
                        (fresh/> F N0+1+N1=N2)
   (join/> A N0+1+N1=N2)
    <- lookup-implies-join L _ F A.

%worlds () (lookup-implies-join _ _ _ _).
%total (L) (lookup-implies-join L _ _ _).


%theorem join-joins-lookup :
 forall* {M1} {M2} {M3} {N} {D1} {D2}
 forall {L1:lookup M1 N D1} {L2:lookup M2 N D2}
               {A:join M1 M2 M3}
 exists {D3} {J:inner-efxmap`join D1 D2 D3} {L3:lookup M3 N D3}
 true.

- : join-joins-lookup (lookup/= nat`eq/) (lookup/= nat`eq/) A
                           _ AD L3
    <- join/=-inversion A nat`eq/ _ _ AD _ M=M133
    <- eq-symmetric M=M133 M133=M
    <- lookup-respects-eq (lookup/= nat`eq/) M133=M nat`eq/ inner-efxmap`eq/ L3.

- : join-joins-lookup (lookup/> L1 N0+1+N1=N2)
                           (lookup/= nat`eq/) A _ AD L3P
    <- join/<-inversion A N0+1+N1=N2 M3 M1+M022=M3 M=M113
    <- join-joins-lookup L1 (lookup/= nat`eq/) M1+M022=M3 _ AD L3
    <- eq-symmetric M=M113 M113=M
    <- lookup-respects-eq (lookup/> L3 N0+1+N1=N2) M113=M nat`eq/ inner-efxmap`eq/ L3P.

- : join-joins-lookup (lookup/= nat`eq/)
                           (lookup/> L2 N3+1+N2=N1) A _ AD L3P
    <- join/>-inversion A N3+1+N2=N1 M3 M311+M2=M3 M=M223
    <- join-joins-lookup (lookup/= nat`eq/) L2 M311+M2=M3 _ AD L3
    <- eq-symmetric M=M223 M223=M
    <- lookup-respects-eq (lookup/> L3 N3+1+N2=N1) M223=M nat`eq/ inner-efxmap`eq/ L3P.

- : join-joins-lookup (lookup/> L1P N4+1+N1=N)
                           (lookup/> L2 N5+1+N2=N)
                           (join/= M1+M2=M3 _ nat`eq/) _ AD
                           (lookup/> L N5+1+N2=N)
    <- plus-right-cancels N4+1+N1=N N5+1+N2=N nat`eq/ nat`eq/ N4+1=N5+1
    <- succ-cancels N4+1=N5+1 N4=N5
    <- lookup-respects-eq L1P eq/ N4=N5 inner-efxmap`eq/ L1
    <- join-joins-lookup L1 L2 M1+M2=M3 _ AD L.

- : join-joins-lookup (lookup/> L1 N4+1+N1=N)
                           (lookup/> L2 N5+1+N2=N)
                           (join/< M1+M022=M3 N0+1+N1=N2) _ AD
      (lookup/> L3 N4+1+N1=N)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N5+1+N2=N N6 N5+1+N0=N6 N6+N1+1=N
    <- plus-swap-succ N4+1+N1=N N4+N1+1=N
    <- plus-right-cancels N6+N1+1=N N4+N1+1=N nat`eq/ nat`eq/ N6=N4
    <- plus-respects-eq N5+1+N0=N6 nat`eq/ nat`eq/ N6=N4 N5+1+N0=N4
    <- join-joins-lookup
       L1 (lookup/> L2 N5+1+N0=N4) M1+M022=M3 _ AD L3.

- : join-joins-lookup (lookup/> L1 N4+1+N1=N)
                           (lookup/> L2 N5+1+N2=N)
                           (join/> M311+M2=M3 N3+1+N2=N1) _ AD
                           (lookup/> L3 N5+1+N2=N)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N4+1+N1=N N6 N4+1+N3=N6 N6+N2+1=N
    <- plus-swap-succ N5+1+N2=N N5+N2+1=N
    <- plus-right-cancels N6+N2+1=N N5+N2+1=N nat`eq/ nat`eq/ N6=N5
    <- plus-respects-eq N4+1+N3=N6 nat`eq/ nat`eq/ N6=N5 N4+1+N3=N5
    <- join-joins-lookup
       (lookup/> L1 N4+1+N3=N5) L2 M311+M2=M3 _ AD L3.

%worlds () (join-joins-lookup _ _ _ _ _ _).
%total (A) (join-joins-lookup _ _ A _ _ _).


%theorem join-joins-lookup* :
 forall* {M1} {M2} {M3} {N} {D1} {D2} {D3}
 forall {L1:lookup M1 N D1} {L2:lookup M2 N D2}
               {A:join M1 M2 M3}
        {J:inner-efxmap`join D1 D2 D3}
 exists {L3:lookup M3 N D3}
 true.

- : join-joins-lookup* L1 L2 A J L3
    <- join-joins-lookup L1 L2 A _ JP L3P
    <- inner-efxmap`join-deterministic JP J inner-efxmap`eq/ inner-efxmap`eq/ D3P=D3
    <- lookup-respects-eq L3P eq/ nat`eq/ D3P=D3 L3.

%worlds () (join-joins-lookup* _ _ _ _ _).
%total { } (join-joins-lookup* _ _ _ _ _).


%theorem join-preserves-fresh* :
 forall* {M1} {M2} {M3} {N}
 forall {F1:fresh M1 N} {F2:fresh M2 N}
               {A:join M1 M2 M3}
 exists {F3:fresh M3 N}
 true.

- : join-preserves-fresh* _ F join/L F.

- : join-preserves-fresh* F _ join/R F.

- : join-preserves-fresh* (fresh/< N<N1) (fresh/< _) (join/= _ _ _)
                          (fresh/< N<N1).

- : join-preserves-fresh* (fresh/< N<N1) (fresh/< _) (join/< _ _)
                          (fresh/< N<N1).

- : join-preserves-fresh* (fresh/< _) (fresh/< N<N2) (join/> _ _)
                          (fresh/< N<N2).

- : join-preserves-fresh* (fresh/< N<N1) (fresh/> F2 N4+1+N2=N) AX F3X
    <- gt-implies-plus N<N1 N0 N0+1+N=N1
    <- plus-swap-succ N4+1+N2=N N4+N2+1=N
    <- plus-associative-converse N4+N2+1=N N0+1+N=N1 N3 N0+1+N4=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- join/>-inversion AX N3+1+N2=N1 M3 A M=M223
    <- plus-implies-gt N0+1+N4=N3 nat`eq/ N4<N3
    <- join-preserves-fresh* (fresh/< N4<N3) F2 A F3
    <- eq-symmetric M=M223 M223=M
    <- fresh-respects-eq (fresh/> F3 N4+1+N2=N) M223=M nat`eq/ F3X.

- : join-preserves-fresh* (fresh/> F1 N3+1+N1=N) (fresh/< N<N2) AX F3X
    <- gt-implies-plus N<N2 N4 N4+1+N=N2
    <- plus-swap-succ N3+1+N1=N N2+N1+1=N
    <- plus-associative-converse N2+N1+1=N N4+1+N=N2 N0 N4+1+N2=N0 N0+N1+1=N2
    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2
    <- join/<-inversion AX N0+1+N1=N2 M3 A M=M113
    <- plus-implies-gt N4+1+N2=N0 nat`eq/ N2<N0
    <- join-preserves-fresh* F1 (fresh/< N2<N0) A F3
    <- eq-symmetric M=M113 M113=M
    <- fresh-respects-eq (fresh/> F3 N3+1+N1=N) M113=M nat`eq/ F3X.

- : join-preserves-fresh* (fresh/> F1 N3+1+N1=N) (fresh/> F2P N4+1+N2=N)
                          (join/= A _ N1=N2) (fresh/> F3 N3+1+N1=N)
    <- plus-right-cancels N3+1+N1=N N4+1+N2=N N1=N2 nat`eq/ N3+1=N4+1
    <- succ-cancels N3+1=N4+1 N3=N4
    <- nat`eq-symmetric N3=N4 N4=N3
    <- fresh-respects-eq F2P eq/ N4=N3 F2
    <- join-preserves-fresh* F1 F2 A F3.

- : join-preserves-fresh* (fresh/> F1 N3+1+N1=N) (fresh/> F2 N4+1+N2=N)
                          (join/< A N0+1+N1=N2) (fresh/> F3 N3+1+N1=N)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N4+1+N2=N N6 N4+1+N0=N6 N6+N1+1=N
    <- plus-swap-succ N3+1+N1=N N3+N1+1=N
    <- plus-right-cancels N6+N1+1=N N3+N1+1=N nat`eq/ nat`eq/ N6=N3
    <- plus-respects-eq N4+1+N0=N6 nat`eq/ nat`eq/ N6=N3 N4+1+N0=N3
    <- join-preserves-fresh* F1 (fresh/> F2 N4+1+N0=N3) A F3.

- : join-preserves-fresh* (fresh/> F1 N3+1+N1=N) (fresh/> F2 N4+1+N2=N)
                          (join/> A N0+1+N2=N1) (fresh/> F3 N4+1+N2=N)
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-associative-converse N0+N2+1=N1 N3+1+N1=N N6 N3+1+N0=N6 N6+N2+1=N
    <- plus-swap-succ N4+1+N2=N N4+N2+1=N
    <- plus-right-cancels N6+N2+1=N N4+N2+1=N nat`eq/ nat`eq/ N6=N4
    <- plus-respects-eq N3+1+N0=N6 nat`eq/ nat`eq/ N6=N4 N3+1+N0=N4
    <- join-preserves-fresh* (fresh/> F1 N3+1+N0=N4) F2 A F3.

%worlds () (join-preserves-fresh* _ _ _ _).
%total (A) (join-preserves-fresh* _ _ A _).


%theorem fresh-join-left-preserves-lookup* :
 forall* {M1} {M2} {M3} {N} {D}
 forall {F1:fresh M1 N} {L2:lookup M2 N D}
               {A:join M1 M2 M3}
 exists {L3:lookup M3 N D}
 true.

- : fresh-join-left-preserves-lookup* _ L join/L L.

- : fresh-join-left-preserves-lookup* (fresh/< N2<N1) (lookup/= nat`eq/) AX L3X
    <- gt-implies-plus N2<N1 N3 N3+1+N2=N1
    <- join/>-inversion AX N3+1+N2=N1 M3 A M=M223
    <- eq-symmetric M=M223 M223=M
    <- lookup-respects-eq (lookup/= nat`eq/) M223=M nat`eq/ inner-efxmap`eq/ L3X.

- : fresh-join-left-preserves-lookup* (fresh/< N<N1) (lookup/> L2 N4+1+N2=N)
                                      AX L3X
    <- gt-implies-plus N<N1 N0 N0+1+N=N1
    <- plus-swap-succ N4+1+N2=N N4+N2+1=N
    <- plus-associative-converse N4+N2+1=N N0+1+N=N1 N3 N0+1+N4=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- join/>-inversion AX N3+1+N2=N1 M3 A M=M223
    <- eq-symmetric M=M223 M223=M
    <- plus-implies-gt N0+1+N4=N3 nat`eq/ N3>N4
    <- fresh-join-left-preserves-lookup* (fresh/< N3>N4) L2 A L3
    <- lookup-respects-eq (lookup/> L3 N4+1+N2=N) M223=M nat`eq/ inner-efxmap`eq/ L3X.

- : fresh-join-left-preserves-lookup* (fresh/> F1 N0+1+N1=N2)
                                      (lookup/= nat`eq/) AX L3X
    <- join/<-inversion AX N0+1+N1=N2 M3 A M=M113
    <- eq-symmetric M=M113 M113=M
    <- fresh-join-left-preserves-lookup* F1 (lookup/= nat`eq/) A L3
    <- lookup-respects-eq (lookup/> L3 N0+1+N1=N2) M113=M nat`eq/ inner-efxmap`eq/ L3X.

- : fresh-join-left-preserves-lookup* (fresh/> F1P N4+1+N1=N)
                                      (lookup/> L2 N5+1+N1=N)
                                      (join/= A _ nat`eq/)
                                      (lookup/> L3 N5+1+N1=N)
    <- plus-right-cancels N4+1+N1=N N5+1+N1=N nat`eq/ nat`eq/ N4+1=N5+1
    <- succ-cancels N4+1=N5+1 N4=N5
    <- fresh-respects-eq F1P eq/ N4=N5 F1
    <- fresh-join-left-preserves-lookup* F1 L2 A L3.

- : fresh-join-left-preserves-lookup* (fresh/> F1 N4+1+N1=N)
                                      (lookup/> L2 N5+1+N2=N)
                                      (join/< A N0+1+N1=N2)
                                      (lookup/> L3 N4+1+N1=N)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N5+1+N2=N N3 N5+1+N0=N3 N3+N1+1=N
    <- plus-swap-succ N4+1+N1=N N4+N1+1=N
    <- plus-right-cancels N3+N1+1=N N4+N1+1=N nat`eq/ nat`eq/ N3=N4
    <- plus-respects-eq N5+1+N0=N3 nat`eq/ nat`eq/ N3=N4 N5+1+N0=N4
    <- fresh-join-left-preserves-lookup* F1 (lookup/> L2 N5+1+N0=N4) A L3.

- : fresh-join-left-preserves-lookup* (fresh/> F1 N4+1+N1=N)
                                      (lookup/> L2 N5+1+N2=N)
                                      (join/> A N3+1+N2=N1)
                                      (lookup/> L3 N5+1+N2=N)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N4+1+N1=N N6 N4+1+N3=N6 N6+N2+1=N
    <- plus-swap-succ N5+1+N2=N N5+N2+1=N
    <- plus-right-cancels N6+N2+1=N N5+N2+1=N nat`eq/ nat`eq/ N6=N5
    <- plus-respects-eq N4+1+N3=N6 nat`eq/ nat`eq/ N6=N5 N4+1+N3=N5
    <- fresh-join-left-preserves-lookup* (fresh/> F1 N4+1+N3=N5) L2 A L3.

%worlds () (fresh-join-left-preserves-lookup* _ _ _ _).
%total (A) (fresh-join-left-preserves-lookup* _ _ A _).


%theorem fresh-join-left-preserves-lookup-converse :
 forall* {M1} {M2} {M3} {N} {D}
 forall {F1:fresh M1 N} {L3:lookup M3 N D}
               {A:join M1 M2 M3}
 exists {L2:lookup M2 N D}
 true.

%theorem fresh-join-left-preserves-lookup-converse/L :
 forall* {M1} {M2} {M3} {N} {D} {B}
 forall {F1:fresh M1 N} {L3:lookup M3 N D}
               {A:join M1 M2 M3}
               {D?:domain? M2 N B}
 exists {L2:lookup M2 N D}
 true.

- : fresh-join-left-preserves-lookup-converse F1 L3 A L2
    <- domain?-total D?
    <- fresh-join-left-preserves-lookup-converse/L F1 L3 A D? L2.

- : fresh-join-left-preserves-lookup-converse/L
     F1 L3 A (domain?/in L2P) L2
    <- fresh-join-left-preserves-lookup* F1 L2P A L3P
    <- lookup-deterministic L3P L3 eq/ nat`eq/ DP=D
    <- lookup-respects-eq L2P eq/ nat`eq/ DP=D L2.

- : fresh-join-left-preserves-lookup-converse/L
     F1 L3 A (domain?/out F2) L2
    <- join-preserves-fresh* F1 F2 A F3
    <- fresh-lookup-not-equal F3 L3 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L2.

%worlds () (fresh-join-left-preserves-lookup-converse/L _ _ _ _ _).
%total { } (fresh-join-left-preserves-lookup-converse/L _ _ _ _ _).

%worlds () (fresh-join-left-preserves-lookup-converse _ _ _ _).
%total { } (fresh-join-left-preserves-lookup-converse _ _ _ _).


%theorem join-left-affects-lookup :
 forall* {M1} {N} {D2} {M2} {M3}
 forall {L:lookup M2 N D2}
        {A:join M1 M2 M3}
 exists {D3}
               {N:lookup M3 N D3}
 true.

%theorem join-left-affects-lookup/L :
 forall* {M1} {N} {D2} {M2} {M3} {B}
 forall {L:lookup M2 N D2}
        {A:join M1 M2 M3}
        {D:domain? M1 N B}
 exists {D3}
               {N:lookup M3 N D3}
 true.

- : join-left-affects-lookup/L L2 A (domain?/in L1) _ L3
    <- join-joins-lookup L1 L2 A _ _ L3.

- : join-left-affects-lookup/L L2 A (domain?/out F1) _ L3
    <- fresh-join-left-preserves-lookup* F1 L2 A L3.

%worlds () (join-left-affects-lookup/L _ _ _ _ _).
%total { } (join-left-affects-lookup/L _ _ _ _ _).

- : join-left-affects-lookup L2 A _ L3
    <- domain?-total D
    <- join-left-affects-lookup/L L2 A D _ L3.

%worlds () (join-left-affects-lookup _ _ _ _).
%total { } (join-left-affects-lookup _ _ _ _).


%theorem disjoint-join-cross-comparable :
 forall* {C} {C1} {C2} {C3} {C4}
 forall {D12:disjoint C1 C2}
  {A12:join C1 C2 C}
  {D34:disjoint C3 C4}
  {A34:join C3 C4 C}
 exists {C13} {C14} {C23} {C24}
        {A1:join C13 C14 C1} {A2:join C23 C24 C2}
        {A3:join C13 C23 C3} {A4:join C14 C24 C4}
 true.

%{%
NB: The client can easily prove all pieces are mutually disjoint.
For example C13 ^ C14 because C13 <= C3 and C14 <= C4 and C3^C4
            C13 ^ C23 because C13 <= C1 and C23 <= C2 and C1^C2
%}%

- : disjoint-join-cross-comparable _ join/L _ C3+C4=C2 _ _ _ _ join/L C3+C4=C2 join/L join/L.

- : disjoint-join-cross-comparable _ join/R _ C3+C4=C1 _ _ _ _ C3+C4=C1 join/R join/R join/R.

- : disjoint-join-cross-comparable _ C1+C2=C4 _ join/L _ _ _ _ join/L join/L join/L C1+C2=C4.

- : disjoint-join-cross-comparable _ C1+C2=C3 _ join/R _ _ _ _ join/R join/R C1+C2=C3 join/R.

- : disjoint-join-cross-comparable D (join/= _ _ nat`eq/) _ _ _ _ _ _
 join/L join/L J1 J2
    <- disjoint/=-contradiction D nat`eq/ F
    <- false-implies-join F J1
    <- false-implies-join F J2.

- : disjoint-join-cross-comparable _ _ D (join/= _ _ nat`eq/) _ _ _ _
 join/L join/L J1 J2
    <- disjoint/=-contradiction D nat`eq/ F
    <- false-implies-join F J1
    <- false-implies-join F J2.

- : disjoint-join-cross-comparable
 D12 (join/< C1+CX2=C N0+1+N1=N2)
 D34 (join/< C3+CX4=C N5+1+N3=N4) _ _ _ _ % NB N1=N3=N
 CY1Y3+CY14=CY1 C2Y3+C24=C2
 CY1Y3+C2Y3=CY3 CY14+C24=C4
    <- disjoint/<-inversion D12 N0+1+N1=N2 D12P
    <- disjoint/<-inversion D34 N5+1+N3=N4 D34P
    <- disjoint-join-cross-comparable D12P C1+CX2=C D34P C3+CX4=C
 C13 C1X4 CX23 CX2X4
 C13+C1X4=C1 CX23+CX2X4=CX2 C13+CX23=C3 C1X4+CX2X4=CX4
    <- shift-total C1X4<<N=CY14
    <- shift-total CX23<<N=C2Y3
    <- shift-total CX2X4<<N=C24
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-right-preserves-join C13+C1X4=C1 C1X4<<N=CY14 CY1Y3+CY14=CY1
    <- shift-preserves-join* CX23+CX2X4=CX2
 CX23<<N=C2Y3 CX2X4<<N=C24 (shift/+ N1+1+N0=N2) C2Y3+C24=C2
    <- shift-right-preserves-join C13+CX23=C3 CX23<<N=C2Y3 CY1Y3+C2Y3=CY3
    <- plus-swap-succ N5+1+N3=N4 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- shift-preserves-join* C1X4+CX2X4=CX4
 C1X4<<N=CY14 CX2X4<<N=C24 (shift/+ N3+1+N5=N4) CY14+C24=C4.

- : disjoint-join-cross-comparable
 D12 (join/< C1+CX2=C N0+1+N1=N2)
 D34 (join/> CX3+C4=C N5+1+N4=N3) _ _ _ _ % NB N1=N4=N
 CY13+CY1Y4=CY1 C23+C2Y4=C2 CY13+C23=C3 CY1Y4+C2Y4=CY4
    <- disjoint/<-inversion D12 N0+1+N1=N2 D12P
    <- disjoint/>-inversion D34 N5+1+N4=N3 D34P
    <- disjoint-join-cross-comparable D12P C1+CX2=C D34P CX3+C4=C
 C1X3 C14 CX2X3 CX24
 C1X3+C14=C1 CX2X3+CX24=CX2 C1X3+CX2X3=CX3 C14+CX24=C4
    <- shift-total C1X3<<N=CY13
    <- shift-total CX2X3<<N=C23
    <- shift-total CX24<<N=C2Y4
    <- shift-left-preserves-join C1X3+C14=C1 C1X3<<N=CY13 CY13+CY1Y4=CY1
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-preserves-join* CX2X3+CX24=CX2
 CX2X3<<N=C23 CX24<<N=C2Y4 (shift/+ N1+1+N0=N2) C23+C2Y4=C2
    <- plus-swap-succ N5+1+N4=N3 N5+N4+1=N3
    <- plus-commutative N5+N4+1=N3 N4+1+N5=N3
    <- shift-preserves-join* C1X3+CX2X3=CX3
 C1X3<<N=CY13 CX2X3<<N=C23 (shift/+ N4+1+N5=N3) CY13+C23=C3
    <- shift-right-preserves-join C14+CX24=C4 CX24<<N=C2Y4 CY1Y4+C2Y4=CY4.

- : disjoint-join-cross-comparable
 D12 (join/> CX1+C2=C N0+1+N2=N1)
        D34 (join/< C3+CX4=C N5+1+N3=N4) _ _ _ _ % NB N2=N3=N
  C1Y3+C14=C1 CY2Y3+CY24=CY2 C1Y3+CY2Y3=CY3 C14+CY24=C4
    <- disjoint/>-inversion D12 N0+1+N2=N1 D12P
    <- disjoint/<-inversion D34 N5+1+N3=N4 D34P
    <- disjoint-join-cross-comparable D12P CX1+C2=C D34P C3+CX4=C
 CX13 CX1X4 C23 C2X4
 CX13+CX1X4=CX1 C23+C2X4=C2 CX13+C23=C3 CX1X4+C2X4=CX4
    <- shift-total CX13<<N=C1Y3
    <- shift-total CX1X4<<N=C14
    <- shift-total C2X4<<N=CY24
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-commutative N0+N2+1=N1 N2+1+N0=N1
    <- shift-preserves-join* CX13+CX1X4=CX1
 CX13<<N=C1Y3 CX1X4<<N=C14 (shift/+ N2+1+N0=N1) C1Y3+C14=C1
    <- shift-right-preserves-join C23+C2X4=C2 C2X4<<N=CY24 CY2Y3+CY24=CY2
    <- shift-left-preserves-join CX13+C23=C3 CX13<<N=C1Y3 C1Y3+CY2Y3=CY3
    <- plus-swap-succ N5+1+N3=N4 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- shift-preserves-join* CX1X4+C2X4=CX4
 CX1X4<<N=C14 C2X4<<N=CY24 (shift/+ N3+1+N5=N4) C14+CY24=C4.

- : disjoint-join-cross-comparable
 D12 (join/> CX1+C2=C N0+1+N2=N1)
 D34 (join/> CX3+C4=C N5+1+N4=N3) _ _ _ _ % NB N2=N4=N
 C13+C1Y4=C1 CY23+CY2Y4=CY2 C13+CY23=C3 C1Y4+CY2Y4=CY4
    <- disjoint/>-inversion D12 N0+1+N2=N1 D12P
    <- disjoint/>-inversion D34 N5+1+N4=N3 D34P
    <- disjoint-join-cross-comparable D12P CX1+C2=C D34P CX3+C4=C
 CX1X3 CX14 C2X3 C2C4
 CX1X3+CX14=CX1 C2X3+C24=C2 CX1X3+C2X3=CX3 CX14+C24=C4
    <- shift-total CX1X3<<N=C13
    <- shift-total CX14<<N=C1Y4
    <- shift-total C2X3<<N=CY23
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-commutative N0+N2+1=N1 N2+1+N0=N1
    <- shift-preserves-join* CX1X3+CX14=CX1
 CX1X3<<N=C13 CX14<<N=C1Y4 (shift/+ N2+1+N0=N1) C13+C1Y4=C1
    <- shift-left-preserves-join C2X3+C24=C2 C2X3<<N=CY23 CY23+CY2Y4=CY2
    <- plus-swap-succ N5+1+N4=N3 N5+N4+1=N3
    <- plus-commutative N5+N4+1=N3 N4+1+N5=N3
    <- shift-preserves-join* CX1X3+C2X3=CX3
 CX1X3<<N=C13 C2X3<<N=CY23 (shift/+ N4+1+N5=N3) C13+CY23=C3
    <- shift-left-preserves-join CX14+C24=C4 CX14<<N=C1Y4 C1Y4+CY2Y4=CY4.

%worlds () (disjoint-join-cross-comparable _ _ _ _ _ _ _ _ _ _ _ _).
%total (A) (disjoint-join-cross-comparable _ A _ _ _ _ _ _ _ _ _ _).


%theorem disjoint-join-left-preserves-lookup* :
 forall* {M1} {M2} {M3} {N} {D}
 forall {L2:lookup M2 N D}
               {X:disjoint M1 M2}
               {A:join M1 M2 M3}
 exists {L3:lookup M3 N D}
 true.

%theorem disjoint-join-left-preserves-lookup*/L :
 forall* {M1} {M2} {M3} {N} {D} {B}
 forall {L2:lookup M2 N D}
               {X:disjoint M1 M2}
               {A:join M1 M2 M3}
               {D?:domain? M1 N B}
 exists {L3:lookup M3 N D}
 true.

- : disjoint-join-left-preserves-lookup* L2 X A L3
    <- domain?-total D?
    <- disjoint-join-left-preserves-lookup*/L L2 X A D? L3.

- : disjoint-join-left-preserves-lookup*/L L2 X A (domain?/in L1) L3
    <- disjoint-lookup-contradiction X L1 L2 F
    <- false-implies-lookup F L3.

- : disjoint-join-left-preserves-lookup*/L L2 X A (domain?/out F1) L3
    <- fresh-join-left-preserves-lookup* F1 L2 A L3.

%worlds () (disjoint-join-left-preserves-lookup*/L _ _ _ _ _).
%total { } (disjoint-join-left-preserves-lookup*/L _ _ _ _ _).

%worlds () (disjoint-join-left-preserves-lookup* _ _ _ _).
%total { } (disjoint-join-left-preserves-lookup* _ _ _ _).


%theorem fresh-update-implies-unit-join:
 forall* {M} {N} {D} {MP}
 forall {F: fresh M N}
  {U: update M N D MP}
 exists {J: join M (map/+ N D map/0) MP}
 true.

- : fresh-update-implies-unit-join
 fresh/0 update/0 join/L.

- : fresh-update-implies-unit-join
 (fresh/< N1>N2) U J
    <- nat`gt-implies-plus N1>N2 N3 SN3+N2=N1
    <- update/<-inversion U SN3+N2=N1 EQ
    <- join-respects-eq (join/> join/R SN3+N2=N1) eq/ eq/ EQ J.

- : fresh-update-implies-unit-join
 (fresh/> F SN0+N1=N2) U J
    <- update/>-inversion U SN0+N1=N2 M1 U1 EQ
    <- fresh-update-implies-unit-join F U1 JP
    <- join-respects-eq (join/< JP SN0+N1=N2) eq/ eq/ EQ J.

%worlds () (fresh-update-implies-unit-join _ _ _).
%total (F) (fresh-update-implies-unit-join F _ _).


%theorem fresh-unit-join-implies-update:
 forall* {M} {N} {D} {MP}
 forall {F: fresh M N}
  {J: join M (map/+ N D map/0) MP}
 exists {U: update M N D MP}
 true.

- : fresh-unit-join-implies-update _ join/L update/0.

- : fresh-unit-join-implies-update
 FR (join/= _ _ nat`eq/) U
    <- fresh-contradiction FR F
    <- false-implies-update F U.

- : fresh-unit-join-implies-update
 F (join/< J1 P) (update/> U1 P)
    <- fresh/>-inversion F P F1
    <- fresh-unit-join-implies-update F1 J1 U1.

- : fresh-unit-join-implies-update
 F (join/> J1 P) U
    <- join-deterministic join/R J1 eq/ eq/ ME
    <- map/+-preserves-eq nat`eq/ inner-efxmap`eq/ ME ME2
    <- update-respects-eq (update/< P) eq/ nat`eq/ inner-efxmap`eq/ ME2 U.

%worlds () (fresh-unit-join-implies-update _ _ _).
%total (J) (fresh-unit-join-implies-update _ J _).


%theorem bound-commute-join* :
 forall* {M1} {M2} {M3} {N1} {N2} {N3}
 forall {B1: bound M1 N1}
  {B2: bound M2 N2}
  {B3: bound M3 N3}
  {J: join M1 M2 M3}
 exists {MX: nat`max N1 N2 N3}
 true.

- : bound-commute-join* (bound/0) B2 B3 join/L M
    <- bound-unique B2 B3 eq/ N2=N3
    <- ge-zero-always _ N2>=0
    <- nat`le-implies-max N2>=0 MP
    <- nat`max-respects-eq MP nat`eq/ nat`eq/ N2=N3 M.

- : bound-commute-join* B1 (bound/0) B3 join/R M
    <- bound-unique B1 B3 eq/ N1=N3
    <- ge-zero-always _ N1>=0
    <- nat`ge-implies-max N1>=0 MP
    <- nat`max-respects-eq MP nat`eq/ nat`eq/ N1=N3 M.

- : bound-commute-join*
 (bound/+ P1 B1) (bound/+ P2 B2) (bound/+ P3 B3)
 (join/= J _ nat`eq/) MP
    <- bound-commute-join* B1 B2 B3 J M
    <- plus-left-preserves-max M P1 P2 P3 MP.

- : bound-commute-join*
 (bound/+ P1 B1) (bound/+ P2 B2) (bound/+ P3 B3)
 (join/< J P) MP
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- plus-swap-succ P2 P2s
    <- plus-associative Psc P2s _ P2Ps PP2
    <- plus-swap-succ-converse P2Ps P2P
    <- bound-commute-join* B1 (bound/+ P2P B2) B3 J M
    <- plus-left-preserves-max M P1 PP2 P3 MP.

- : bound-commute-join*
 (bound/+ P1 B1) (bound/+ P2 B2) (bound/+ P3 B3)
 (join/> J P) MP
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- plus-swap-succ P1 P1s
    <- plus-associative Psc P1s _ P1Ps PP1
    <- plus-swap-succ-converse P1Ps P1P
    <- bound-commute-join* (bound/+ P1P B1) B2 B3 J M
    <- plus-left-preserves-max M PP1 P2 P3 MP.

%worlds () (bound-commute-join* _ _ _ _ _).
%total (J) (bound-commute-join* _ _ _ J _).



%theorem join-implies-leq* :
 forall* {M1} {M2} {M3}
 forall {J:join M1 M2 M3}
        exists {L:leq M1 M3}
 true.

- : join-implies-leq* join/L leq/0.

- : join-implies-leq* join/R M2=M2
    <- leq-reflexive _ M2=M2.

- : join-implies-leq* (join/= M1+M2=M3 D1+D2=D3 nat`eq/)
                      (leq/= M1<=M3 D1<=D3 nat`eq/)
    <- inner-efxmap`join-implies-leq* D1+D2=D3 D1<=D3
    <- join-implies-leq* M1+M2=M3 M1<=M3.

- : join-implies-leq* (join/< M1+_=M3 _) (leq/= M1<=M3 D1<=D1 nat`eq/)
    <- inner-efxmap`leq-reflexive _ D1<=D1
    <- join-implies-leq* M1+_=M3 M1<=M3.

- : join-implies-leq* (join/> M311+M2=M3 P) (leq/> M311<=M3 P)
    <- join-implies-leq* M311+M2=M3 M311<=M3.

%worlds () (join-implies-leq* _ _).
%total (J) (join-implies-leq* J _).


%theorem join-implies-leq :
    forall* {M1} {M2} {M3}
    forall {J: join M1 M2 M3}
    exists {L: leq M1 M3} {L: leq M2 M3}
    true.

- : join-implies-leq join/L leq/0 M2<=M2
    <- leq-reflexive _ M2<=M2.

- : join-implies-leq join/R M2=M2 leq/0
    <- leq-reflexive _ M2=M2.

- : join-implies-leq (join/= M1+M2=M3 D1+D2=D3 nat`eq/)
                      (leq/= M1<=M3 D1<=D3 nat`eq/)
    (leq/= M2<=M3 D2<=D3 nat`eq/)
    <- inner-efxmap`join-implies-leq D1+D2=D3 D1<=D3 D2<=D3
    <- join-implies-leq M1+M2=M3 M1<=M3 M2<=M3.

- : join-implies-leq (join/< M1+M022=M3 P)
    (leq/= M1<=M3 D1<=D1 nat`eq/) (leq/> M022<=M3 P)
    <- inner-efxmap`leq-reflexive _ D1<=D1
    <- join-implies-leq M1+M022=M3 M1<=M3 M022<=M3.

- : join-implies-leq (join/> M311+M2=M3 P)
    (leq/> M311<=M3 P) (leq/= M2<=M3 D2<=D2 nat`eq/)
    <- inner-efxmap`leq-reflexive _ D2<=D2
    <- join-implies-leq M311+M2=M3 M311<=M3 M2<=M3.

%worlds () (join-implies-leq _ _ _).
%total (J) (join-implies-leq J _ _).


%theorem disjoint-leq-implies-join-leq* :
 forall* {C1} {C2} {C} {C3}
 forall {D:disjoint C1 C2}
  {L1:leq C1 C}
  {L2:leq C2 C}
  {J:join C1 C2 C3}
 exists {L3:leq C3 C}
 true.

- : disjoint-leq-implies-join-leq* disjoint/L _ C2<=C Z+C2=C3 C3<=C
    <- join-deterministic join/L Z+C2=C3 eq/ eq/ C2=C3
    <- leq-respects-eq C2<=C C2=C3 eq/ C3<=C.

- : disjoint-leq-implies-join-leq* disjoint/R C1<=C _ C1+0=C3 C3<=C
    <- join-deterministic join/R C1+0=C3 eq/ eq/ C1=C3
    <- leq-respects-eq C1<=C C1=C3 eq/ C3<=C.

- : disjoint-leq-implies-join-leq*
 (disjoint/< C1^C022 P)
 (leq/= C1<=C4 D1<=D4 nat`eq/)
 C222<=C444 C111+C222=C333 C333<=C444
    <- join/<-inversion C111+C222=C333 P _ C1+C022=C5 C333=C115
    <- leq/>-inversion C222<=C444 P C022<=C4
    <- disjoint-leq-implies-join-leq*
 C1^C022 C1<=C4 C022<=C4 C1+C022=C5 C5<=C4
    <- eq-symmetric C333=C115 C115=C333
    <- leq-respects-eq
 (leq/= C5<=C4 D1<=D4 nat`eq/) C115=C333 eq/ C333<=C444.

- : disjoint-leq-implies-join-leq* (disjoint/< C1^C022 N0+1+N1=N2) (leq/> C611<=C4 N6+1+N4=N1) C222<=C444 C111+C222=C333 C333<=C444
    <- join/<-inversion C111+C222=C333 N0+1+N1=N2 _ C1+C022=C5 C333=C115
    <- plus-swap-succ N6+1+N4=N1 N6+N4+1=N1
    <- plus-associative-converse
 N6+N4+1=N1 N0+1+N1=N2 N7 N0+1+N6=N7 N7+N4+1=N2
    <- plus-swap-succ-converse N7+N4+1=N2 N7+1+N4=N2
    <- leq/>-inversion C222<=C444 N7+1+N4=N2 C722<=C4
    <- disjoint-leq-implies-join-leq*
 (disjoint/< C1^C022 N0+1+N6=N7)
 C611<=C4 C722<=C4
 (join/< C1+C022=C5 N0+1+N6=N7) C615<=C4
    <- eq-symmetric C333=C115 C115=C333
    <- leq-respects-eq
 (leq/> C615<=C4 N6+1+N4=N1) C115=C333 eq/ C333<=C444.

- : disjoint-leq-implies-join-leq*
 (disjoint/> C011^C2 P)
 C111<=C444 (leq/= C2<=C4 D2<=D4 nat`eq/)
 C111+C222=C333 C333<=C444
    <- join/>-inversion C111+C222=C333 P _ C011+C2=C5 C333=C225
    <- leq/>-inversion C111<=C444 P C011<=C4
    <- disjoint-leq-implies-join-leq*
 C011^C2 C011<=C4 C2<=C4 C011+C2=C5 C5<=C4
    <- eq-symmetric C333=C225 C225=C333
    <- leq-respects-eq
 (leq/= C5<=C4 D2<=D4 nat`eq/) C225=C333 eq/ C333<=C444.

- : disjoint-leq-implies-join-leq*
 (disjoint/> C011^C2 N0+1+N2=N1)
 C111<=C444 (leq/> C622<=C4 N6+1+N4=N2)
 C111+C222=C333 C333<=C444
    <- join/>-inversion C111+C222=C333 N0+1+N2=N1 _ C011+C2=C5 C333=C225
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-associative-converse
 N6+N4+1=N2 N0+1+N2=N1 N7 N0+1+N6=N7 N7+N4+1=N1
    <- plus-swap-succ-converse N7+N4+1=N1 N7+1+N4=N1
    <- leq/>-inversion C111<=C444 N7+1+N4=N1 C711<=C4
    <- disjoint-leq-implies-join-leq*
 (disjoint/> C011^C2 N0+1+N6=N7)
 C711<=C4 C622<=C4
 (join/> C011+C2=C5 N0+1+N6=N7) C625<=C4
    <- eq-symmetric C333=C225 C225=C333
    <- leq-respects-eq
 (leq/> C625<=C4 N6+1+N4=N2) C225=C333 eq/ C333<=C444.

%worlds () (disjoint-leq-implies-join-leq* _ _ _ _ _).
%total (L) (disjoint-leq-implies-join-leq* _ L _ _ _).

%%% The definition of disjoint is not strong enough for
%%% us. We need to show that even if two map's domain
%%% have intersection, if the inner-efxmap involved in the intersection
%%% are disjoint, then the maps are still disjoint. We call
%%% this 'deep-disjoint'.

deep-disjoint : map -> map -> type.

deep-disjoint/L : deep-disjoint map/0 M.

deep-disjoint/R : deep-disjoint M map/0.

deep-disjoint/=
  : deep-disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`eq N1 N2
    <- inner-efxmap`disjoint D1 D2
    <- deep-disjoint M1 M2.

deep-disjoint/<
  : deep-disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- plus (s N0) N1 N2
    <- deep-disjoint M1 (map/+ N0 D2 M2).

deep-disjoint/>
  : deep-disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- plus (s N3) N2 N1
    <- deep-disjoint (map/+ N3 D1 M1) M2.


deep-disjoint? : map -> map -> bool -> type.

deep-disjoint?/yes
  : deep-disjoint M1 M2 ->
      deep-disjoint? M1 M2 true.

deep-disjoint?/no
  : lookup M1 N D1 ->
    lookup M2 N D2 ->
    inner-efxmap`disjoint? D1 D2 false ->
      deep-disjoint? M1 M2 false.


%%% Theorems

%theorem deep-disjoint?-total* :
 forall {M1} {M2}
 exists {B} {D:deep-disjoint? M1 M2 B}
 true.

- : deep-disjoint?-total* _ _ _
    (deep-disjoint?/yes deep-disjoint/L).

- : deep-disjoint?-total* _ _ _
    (deep-disjoint?/yes deep-disjoint/R).

%theorem deep-disjoint?-total*/+ :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {C}
 forall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2}
        {CMP:nat`compare N1 N2 C}
 exists {B} {D:deep-disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
 true.

%theorem deep-disjoint?-total*/= :
    forall* {N} {D1} {M1} {D2} {M2} {B1} {B2}
    forall {D?: deep-disjoint? M1 M2 B1}
            {ID?: inner-efxmap`disjoint? D1 D2 B2}
    exists {B3} {D: deep-disjoint?
       (map/+ N D1 M1) (map/+ N D2 M2) B3}
    true.

- : deep-disjoint?-total*/=
    (deep-disjoint?/yes X) (inner-efxmap`disjoint?/yes IX)
    _ (deep-disjoint?/yes
 (deep-disjoint/= X IX nat`eq/)).

- : deep-disjoint?-total*/=
    _ (inner-efxmap`disjoint?/no L1 L2)
    _ (deep-disjoint?/no (lookup/= nat`eq/)
      (lookup/= nat`eq/) (inner-efxmap`disjoint?/no L1 L2)).

- : deep-disjoint?-total*/=
    (deep-disjoint?/no L1 L2 IX) (inner-efxmap`disjoint?/yes _)
    _ (deep-disjoint?/no
 (lookup/> L1 P) (lookup/> L2 P) IX)
    <- plus-total P.

%worlds () (deep-disjoint?-total*/= _ _ _ _).
%total {} (deep-disjoint?-total*/= _ _ _ _).


%theorem deep-disjoint?-total*/< :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0} {B1}
 forall {P:plus (s N0) N1 N2}
               {D?1:deep-disjoint? M1 (map/+ N0 D2 M2) B1}
 exists {B} {D:deep-disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
 true.

%theorem deep-disjoint?-total*/> :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {B1}
 forall {P:plus (s N3) N2 N1}
               {D?1:deep-disjoint? (map/+ N3 D1 M1) M2 B1}
 exists {B} {D:deep-disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
 true.

- : deep-disjoint?-total* _ _ _ D?
    <- size-total SZ1
    <- size-total SZ2
    <- nat`compare-total CMP
    <- deep-disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?.

- : deep-disjoint?-total*/+ _ _
    size/0 _ nat`compare/= _ XX
    <- inner-efxmap`disjoint?-total IX
    <- deep-disjoint?-total*/=
      (deep-disjoint?/yes deep-disjoint/L) IX _ XX.

- : deep-disjoint?-total*/+ _ _
    _ size/0 nat`compare/= _ XX
    <- inner-efxmap`disjoint?-total IX
    <- deep-disjoint?-total*/=
      (deep-disjoint?/yes deep-disjoint/R) IX _ XX.

- : deep-disjoint?-total*/+ _ _
    (size/+ SZ1) (size/+ SZ2) (nat`compare/=) _ XX
    <- nat`compare-total CMP
    <- inner-efxmap`disjoint?-total IX
    <- deep-disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ X
    <- deep-disjoint?-total*/= X IX _ XX.

- : deep-disjoint?-total*/+ _ _ _ _ (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- deep-disjoint?-total*/< N0+1+N1=N2
      (deep-disjoint?/yes deep-disjoint/L) _ D?.

- : deep-disjoint?-total*/+ _ _ (size/+ SZ1) SZ2 (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- nat`compare-total CMP
    <- deep-disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- deep-disjoint?-total*/< N0+1+N1=N2 D?1 _ D?.

- : deep-disjoint?-total*/< N0+1+N1=N2
    (deep-disjoint?/yes M1*M022) _
    (deep-disjoint?/yes (deep-disjoint/< M1*M022 N0+1+N1=N2)).

- : deep-disjoint?-total*/< N0+1+N1=N2
    (deep-disjoint?/no M1^N3=D1 M022^N3=D2 IX) _
    (deep-disjoint?/no (lookup/> M1^N3=D1 N3+1+N1=N4) M222^N4=D2 IX)
    <- plus-total N3+1+N1=N4
    <- plus-swap-succ N3+1+N1=N4 N3+N1+1=N4
    <- plus-commutative N3+N1+1=N4 N1+1+N3=N4
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-preserves-lookup*
      M022^N3=D2 (shift/+ N1+1+N0=N2) N1+1+N3=N4 M222^N4=D2.


%worlds () (deep-disjoint?-total*/< _ _ _ _).
%total { } (deep-disjoint?-total*/< _ _ _ _).


- : deep-disjoint?-total*/+ _ _ _ _ (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- deep-disjoint?-total*/>
      N3+1+N2=N1 (deep-disjoint?/yes deep-disjoint/R) _ D?.

- : deep-disjoint?-total*/+ _ _ SZ1
    (size/+ SZ2) (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- nat`compare-total CMP
    <- deep-disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- deep-disjoint?-total*/> N3+1+N2=N1 D?1 _ D?.

- : deep-disjoint?-total*/> P
    (deep-disjoint?/yes D) _
    (deep-disjoint?/yes (deep-disjoint/> D P)).

- : deep-disjoint?-total*/> N3+1+N2=N1
    (deep-disjoint?/no M311^N4=D1 M2^N4=D2 IX) _
    (deep-disjoint?/no M111^N5=D1
      (lookup/> M2^N4=D2 N4+1+N2=N5) IX)
    <- plus-total N4+1+N2=N5
    <- plus-swap-succ N4+1+N2=N5 N4+N2+1=N5
    <- plus-commutative N4+N2+1=N5 N2+1+N4=N5
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- shift-preserves-lookup* M311^N4=D1
      (shift/+ N2+1+N3=N1) N2+1+N4=N5 M111^N5=D1.


%worlds () (deep-disjoint?-total*/> _ _ _ _).
%total { } (deep-disjoint?-total*/> _ _ _ _).

%worlds () (deep-disjoint?-total*/+ _ _ _ _ _ _ _).
%total [S1 S2] (deep-disjoint?-total*/+ S1 S2 _ _ _ _ _).

%worlds () (deep-disjoint?-total* _ _ _ _).
%total { } (deep-disjoint?-total* _ _ _ _).

%abbrev deep-disjoint?-total = deep-disjoint?-total* _ _ _.


%theorem false-implies-deep-disjoint :
    forall* {XM1} {XM2}
    forall {F:void}
    exists {D: deep-disjoint XM1 XM2}
    true.

%worlds () (false-implies-deep-disjoint _ _).
%total {} (false-implies-deep-disjoint _ _).


%theorem meta-reduce-deep-disjoint :
    forall* {M1} {M2} {M3} {M4}
    forall {F:void}
            {D1: deep-disjoint M1 M2}
            {D2: deep-disjoint M3 M4}
    true.

%worlds () (meta-reduce-deep-disjoint _ _ _).
%total {} (meta-reduce-deep-disjoint _ _ _).
%reduces X < Y (meta-reduce-deep-disjoint _ X Y).


%theorem deep-disjoint-respects-eq :
 forall* {M1} {M2} {M1P} {M2P}
 forall {A:deep-disjoint M1 M2}
         {E1:eq M1 M1P} {E2:eq M2 M2P}
 exists {AP:deep-disjoint M1P M2P}
 true.

- : deep-disjoint-respects-eq A eq/ eq/ A.

%worlds () (deep-disjoint-respects-eq _ _ _ _).
%total {} (deep-disjoint-respects-eq _ _ _ _).
%reduces A = AP (deep-disjoint-respects-eq A _ _ AP).



%theorem deep-disjoint/=-inversion :
    forall* {XM1} {XM2} {M1} {M2} {L1} {L2}
    forall {D: deep-disjoint
  (map/+ L1 M1 XM1) (map/+ L2 M2 XM2)}
            {E: nat`eq L1 L2}
    exists {D: inner-efxmap`disjoint M1 M2} {D: deep-disjoint XM1 XM2}
    true.

- : deep-disjoint/=-inversion
    (deep-disjoint/= XM1<>XM2 M1<>M2 nat`eq/) nat`eq/
    M1<>M2 XM1<>XM2.

- : deep-disjoint/=-inversion
    (deep-disjoint/< J SL0+L1=L2) L1=L2 M1<>M2 XM1<>XM2
    <- plus-implies-gt SL0+L1=L2 nat`eq/ L2>L1
    <- nat`eq-ne-implies-false L1=L2 (nat`ne/< L2>L1) F
    <- inner-efxmap`false-implies-disjoint F M1<>M2
    <- false-implies-deep-disjoint F XM1<>XM2
    <- meta-reduce-deep-disjoint F XM1<>XM2 J.

- : deep-disjoint/=-inversion
    (deep-disjoint/> J SL0+L2=L1) L1=L2 M1<>M2 XM1<>XM2
    <- plus-implies-gt SL0+L2=L1 nat`eq/ L1>L2
    <- nat`eq-ne-implies-false L1=L2 (nat`ne/> L1>L2) F
    <- inner-efxmap`false-implies-disjoint F M1<>M2
    <- false-implies-deep-disjoint F XM1<>XM2
    <- meta-reduce-deep-disjoint F XM1<>XM2 J.

%worlds () (deep-disjoint/=-inversion _ _ _ _).
%total {} (deep-disjoint/=-inversion _ _ _ _).
%reduces AP < A (deep-disjoint/=-inversion A _ _ AP).



%theorem deep-disjoint/<-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}
 forall {A:deep-disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
         {P:plus (s N0) N1 N2}
 exists {AP:deep-disjoint M1 (map/+ N0 D2 M2)}
 true.

- : deep-disjoint/<-inversion (deep-disjoint/< A P) PP AP
    <- plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P inner-efxmap`eq/ eq/ M022=M022P
    <- deep-disjoint-respects-eq A eq/ M022=M022P AP.

- : deep-disjoint/<-inversion
    (deep-disjoint/> AP N3+1+N2=N1) N0+1+N1=N2 A
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M311=M1
    <- false-implies-eq F M2=M022
    <- deep-disjoint-respects-eq AP M311=M1 M2=M022 A.

- : deep-disjoint/<-inversion
    (deep-disjoint/= XM1<>XM2 M1<>M2 L1=L2) SN0+L1=L2 J
    <- plus-implies-gt SN0+L1=L2 nat`eq/ L2>L1
    <- nat`eq-ne-implies-false L1=L2 (nat`ne/< L2>L1) F
    <- false-implies-deep-disjoint F J
    <- meta-reduce-deep-disjoint F J XM1<>XM2.

%worlds () (deep-disjoint/<-inversion _ _ _).
%total {} (deep-disjoint/<-inversion _ _ _).
%reduces AP < A (deep-disjoint/<-inversion A _ AP).


%theorem deep-disjoint/>-inversion :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
 forall {A:deep-disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
        {P:plus (s N3) N2 N1}
 exists {AP:deep-disjoint (map/+ N3 D1 M1) M2}
 true.

- : deep-disjoint/>-inversion (deep-disjoint/> A P) PP AP
    <- plus-right-cancels P PP nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P inner-efxmap`eq/ eq/ M311=M311P
    <- deep-disjoint-respects-eq A M311=M311P eq/ AP.

- : deep-disjoint/>-inversion
    (deep-disjoint/< AP N0+1+N1=N2) N3+1+N2=N1 A
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M1=M311
    <- false-implies-eq F M022=M2
    <- deep-disjoint-respects-eq AP M1=M311 M022=M2 A.

- : deep-disjoint/>-inversion
    (deep-disjoint/= XM1<>XM2 M1<>M2 L1=L2) SN3+L2=L1 J
    <- plus-implies-gt SN3+L2=L1 nat`eq/ L1>L2
    <- nat`eq-ne-implies-false L1=L2 (nat`ne/> L1>L2) F
    <- false-implies-deep-disjoint F J
    <- meta-reduce-deep-disjoint F J XM1<>XM2.

%worlds () (deep-disjoint/>-inversion _ _ _).
%total { } (deep-disjoint/>-inversion _ _ _).
%reduces AP < A (deep-disjoint/>-inversion A _ AP).


%theorem deep-disjoint-symmetric :
 forall* {M1} {M2}
 forall {D:deep-disjoint M1 M2}
 exists {D:deep-disjoint M2 M1}
 true.

- : deep-disjoint-symmetric
    deep-disjoint/L deep-disjoint/R.

- : deep-disjoint-symmetric
    deep-disjoint/R deep-disjoint/L.

- : deep-disjoint-symmetric
    (deep-disjoint/< D P) (deep-disjoint/> DP P)
    <- deep-disjoint-symmetric D DP.

- : deep-disjoint-symmetric
    (deep-disjoint/> D P) (deep-disjoint/< DP P)
    <- deep-disjoint-symmetric D DP.

- : deep-disjoint-symmetric
    (deep-disjoint/= M1<>M2 D1<>D2 N1=N2)
    (deep-disjoint/= M2<>M1 D2<>D1 N2=N1)
    <- deep-disjoint-symmetric M1<>M2 M2<>M1
    <- inner-efxmap`disjoint-symmetric D1<>D2 D2<>D1
    <- nat`eq-symmetric N1=N2 N2=N1.

%worlds () (deep-disjoint-symmetric _ _).
%total (D) (deep-disjoint-symmetric D _).



%theorem shift-preserves-deep-disjoint :
    forall* {N} {M1} {M2} {SM1} {SM2}
   forall {A:deep-disjoint M1 M2}
           {S1:shift N M1 SM1} {S2:shift N M2 SM2}
   exists {SA:deep-disjoint SM1 SM2}
   true.

- : shift-preserves-deep-disjoint
    _ shift/0 _ deep-disjoint/L.

- : shift-preserves-deep-disjoint
    _ _ shift/0 deep-disjoint/R.

- : shift-preserves-deep-disjoint
    (deep-disjoint/< M1*M022 N0+1+N1=N2)
    (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
    (deep-disjoint/< M1*M022 N0+1+N4=N5)
    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4
    <- plus-commutative N+N1+1=N4 N1+1+N=N4
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.

- : shift-preserves-deep-disjoint
    (deep-disjoint/> M311*M2 N3+1+N2=N1)
    (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
    (deep-disjoint/> M311*M2 N3+1+N5=N4)
    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5
    <- plus-commutative N+N2+1=N5 N2+1+N=N5
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4.

- : shift-preserves-deep-disjoint
    (deep-disjoint/= M1<>M2 D1<>D2 nat`eq/)
    (shift/+ P1) (shift/+ P2)
    (deep-disjoint/= M1<>M2 D1<>D2 N3=N4)
    <- plus-deterministic P1 P2 nat`eq/ nat`eq/ N3=N4.

%worlds () (shift-preserves-deep-disjoint _ _ _ _).
%total { } (shift-preserves-deep-disjoint _ _ _ _).



%theorem shift-preserves-deep-disjoint-converse :
 forall* {N} {M1} {M2} {SM1} {SM2}
 forall {SA:deep-disjoint SM1 SM2}
         {S1:shift N M1 SM1} {S2:shift N M2 SM2}
 exists {A:deep-disjoint M1 M2}
 true.

- : shift-preserves-deep-disjoint-converse
    _ shift/0 _ deep-disjoint/L.

- : shift-preserves-deep-disjoint-converse
    _ _ shift/0 deep-disjoint/R.

- : shift-preserves-deep-disjoint-converse
    (deep-disjoint/< M1*M055 N0+1+N4=N5)
    (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
    (deep-disjoint/< M1*M055 N0+1+N1=N2)
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4
    <- plus-associative-converse
      N1+N+1=N4 N0+1+N4=N5 N2P N0+1+N1=N2P N2P+N+1=N5
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-right-cancels N2P+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2P=N2
    <- plus-respects-eq N0+1+N1=N2P nat`eq/ nat`eq/ N2P=N2 N0+1+N1=N2.

- : shift-preserves-deep-disjoint-converse
    (deep-disjoint/> M611*M2 N6+1+N5=N4)
    (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
    (deep-disjoint/> M611*M2 N6+1+N2=N1)
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5
    <- plus-associative-converse
      N2+N+1=N5 N6+1+N5=N4 N1P N6+1+N2=N1P N1P+N+1=N4
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-right-cancels N1P+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1P=N1
    <- plus-respects-eq N6+1+N2=N1P nat`eq/ nat`eq/ N1P=N1 N6+1+N2=N1.

- : shift-preserves-deep-disjoint-converse
    (deep-disjoint/= M1<>M2 D1<>D2 nat`eq/)
    (shift/+ P1) (shift/+ P2)
    (deep-disjoint/= M1<>M2 D1<>D2 EQ)
    <- plus-left-cancels P1 P2 nat`eq/ nat`eq/ EQ.

%worlds () (shift-preserves-deep-disjoint-converse _ _ _ _).
%total { } (shift-preserves-deep-disjoint-converse _ _ _ _).


%theorem shift-left-preserves-deep-disjoint :
 forall* {N} {D} {M1} {M2} {SM1}
 forall {A:deep-disjoint M1 M2} {S1:shift N M1 SM1}
        exists {SA:deep-disjoint SM1 (map/+ N D M2)}
        true.

- : shift-left-preserves-deep-disjoint
    _ shift/0 deep-disjoint/L.

- : shift-left-preserves-deep-disjoint M111*M2 (shift/+ N+1+N1=N1P)
    (deep-disjoint/> M111*M2 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-deep-disjoint _ _ _).
%total { } (shift-left-preserves-deep-disjoint _ _ _).


%theorem shift-left-preserves-deep-disjoint-converse :
 forall* {N} {D} {M1} {M2} {SM1}
 forall {SA:deep-disjoint SM1 (map/+ N D M2)}
         {S1:shift N M1 SM1}
  exists {A:deep-disjoint M1 M2}
 true.

- : shift-left-preserves-deep-disjoint-converse
    _ shift/0 deep-disjoint/L.

- : shift-left-preserves-deep-disjoint-converse
    M111*M222 (shift/+ N2+1+N3=N1) M311*M2
    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1
    <- deep-disjoint/>-inversion M111*M222 N3+1+N2=N1 M311*M2.

%worlds () (shift-left-preserves-deep-disjoint-converse _ _ _).
%total { } (shift-left-preserves-deep-disjoint-converse _ _ _).


%theorem shift-right-preserves-deep-disjoint :
 forall* {N} {D} {M1} {M2} {SM2}
 forall {A:deep-disjoint M1 M2} {S2:shift N M2 SM2}
        exists {SA:deep-disjoint (map/+ N D M1) SM2}
 true.

- : shift-right-preserves-deep-disjoint _ shift/0 deep-disjoint/R.

- : shift-right-preserves-deep-disjoint M1*M222 (shift/+ N+1+N2=N2P)
                               (deep-disjoint/< M1*M222 N2+1+N=N2P)
    <- plus-swap-succ N+1+N2=N2P N+N2+1=N2P
    <- plus-commutative N+N2+1=N2P N2+1+N=N2P.

%worlds () (shift-right-preserves-deep-disjoint _ _ _).
%total { } (shift-right-preserves-deep-disjoint _ _ _).


%theorem shift-right-preserves-deep-disjoint-converse :
 forall* {N} {D} {M1} {M2} {SM2}
 forall {SA:deep-disjoint (map/+ N D M1) SM2} {S2:shift N M2 SM2}
        exists {A:deep-disjoint M1 M2}
 true.

- : shift-right-preserves-deep-disjoint-converse
    _ shift/0 deep-disjoint/R.

- : shift-right-preserves-deep-disjoint-converse
    M111*M322 (shift/+ N1+1+N2=N3) M1*M222
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- deep-disjoint/<-inversion M111*M322 N2+1+N1=N3 M1*M222.

%worlds () (shift-right-preserves-deep-disjoint-converse _ _ _).
%total { } (shift-right-preserves-deep-disjoint-converse _ _ _).


%theorem join-preserves-deep-disjoint* :
 forall* {M1} {M2} {M3} {M4}
 forall {D1: deep-disjoint M1 M4} {D2: deep-disjoint M2 M4}
        {A: join M1 M2 M3}
 exists {D3:deep-disjoint M3 M4}
 true.

% a lemma that counts the size of maps to help prove termination
%theorem join-preserves-deep-disjoint*/L :
 forall* {M1} {M2} {M3} {M4}
 forall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2}
         {D1:deep-disjoint M1 M4} {D2:deep-disjoint M2 M4}
        {A:join M1 M2 M3}
 exists {D3:deep-disjoint M3 M4}
 true.

- : join-preserves-deep-disjoint* D1 D2 J D3
    <- size-total SZ1
    <- size-total SZ2
    <- join-preserves-deep-disjoint*/L _ _ SZ1 SZ2 D1 D2 J D3.

- : join-preserves-deep-disjoint*/L
    _ _ _ _ deep-disjoint/R _ _ deep-disjoint/R.

- : join-preserves-deep-disjoint*/L
    _ _ _ _ _ deep-disjoint/R _ deep-disjoint/R.

- : join-preserves-deep-disjoint*/L _ _ _ _ _ D join/L D.

- : join-preserves-deep-disjoint*/L _ _ _ _ D _ join/R D.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/< D1 N5+1+N1=N4) D2X
    (join/= J _ nat`eq/)
    (deep-disjoint/< D3 N5+1+N1=N4)
    <- deep-disjoint/<-inversion D2X N5+1+N1=N4 D2
    <- join-preserves-deep-disjoint*/L S1 S2 SZ1 SZ2 D1 D2 J D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/< D1 N5+1+N1=N4) D2X
    (join/> J N3+1+N2=N1)
    (deep-disjoint/< D3 N6+1+N2=N4)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse
      N3+N2+1=N1 N5+1+N1=N4 N6 N5+1+N3=N6 N6+N2+1=N4
    <- plus-swap-succ-converse N6+N2+1=N4 N6+1+N2=N4
    <- deep-disjoint/<-inversion D2X N6+1+N2=N4 D2
    <- plus-swap-succ N5+1+N3=N6 N5+N3+1=N6
    <- plus-commutative N5+N3+1=N6 N3+1+N5=N6
    <- shift-right-preserves-deep-disjoint
      D1 (shift/+ N3+1+N5=N6) D1<<N3
    <- join-preserves-deep-disjoint*/L
      (s S1) S2 (size/+ SZ1) SZ2 D1<<N3 D2 J D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/> D1 N5+1+N4=N1) D2X
    (join/= J DJ nat`eq/)
    (deep-disjoint/> D3 N5+1+N4=N1)
    <- deep-disjoint/>-inversion D2X N5+1+N4=N1 D2
    <- join-preserves-deep-disjoint*/L
      _ _ (size/+ SZ1) (size/+ SZ2)
      D1 D2 (join/= J DJ nat`eq/) D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/> D1 N5+1+N4=N1) D2X
    (join/< J N0+1+N1=N2)
    (deep-disjoint/> D3 N5+1+N4=N1)
    <- plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- plus-associative-converse
      N5+N4+1=N1 N0+1+N1=N2 N6 N0+1+N5=N6 N6+N4+1=N2
    <- plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2
    <- deep-disjoint/>-inversion D2X N6+1+N4=N2 D2
    <- join-preserves-deep-disjoint*/L
      _ _ (size/+ SZ1) (size/+ SZ2)
      D1 D2 (join/< J N0+1+N5=N6) D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    D1X (deep-disjoint/< D2 N6+1+N2=N4)
    (join/< J N0+1+N1=N2)
    (deep-disjoint/< D3 N5+1+N1=N4)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse
      N0+N1+1=N2 N6+1+N2=N4 N5 N6+1+N0=N5 N5+N1+1=N4
    <- plus-swap-succ-converse N5+N1+1=N4 N5+1+N1=N4
    <- deep-disjoint/<-inversion D1X N5+1+N1=N4 D1
    <- plus-swap-succ N6+1+N0=N5 N6+N0+1=N5
    <- plus-commutative N6+N0+1=N5 N0+1+N6=N5
    <- shift-right-preserves-deep-disjoint
      D2 (shift/+ N0+1+N6=N5) D2<<N0
    <- join-preserves-deep-disjoint*/L
      S1 (s S2) SZ1 (size/+ SZ2) D1 D2<<N0 J D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    D1X (deep-disjoint/> D2 N6+1+N4=N2)
    (join/> J N3+1+N2=N1)
    (deep-disjoint/> D3 N6+1+N4=N2)
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-associative-converse
      N6+N4+1=N2 N3+1+N2=N1 N5 N3+1+N6=N5 N5+N4+1=N1
    <- plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1
    <- deep-disjoint/>-inversion D1X N5+1+N4=N1 D1
    <- join-preserves-deep-disjoint*/L
      _ _ (size/+ SZ1) (size/+ SZ2)
      D1 D2 (join/> J N3+1+N6=N5) D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/< D1 N5+1+N1=N4)
    (deep-disjoint/> D2 N6+1+N4=N2) JX D3X
    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- plus-associative-converse
      N5+N1+1=N4 N6+1+N4=N2 N0 N6+1+N5=N0 N0+N1+1=N2
    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2
    <- join/<-inversion JX N0+1+N1=N2 _ J M=M113
    <- eq-symmetric M=M113 M113=M
    <- join-preserves-deep-disjoint*/L
      S1 (s S2) SZ1 (size/+ SZ2)
      D1 (deep-disjoint/> D2 N6+1+N5=N0) J D3
    <- deep-disjoint-respects-eq
      (deep-disjoint/< D3 N5+1+N1=N4) M113=M eq/ D3X.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/> D1 N5+1+N4=N1)
    (deep-disjoint/< D2 N6+1+N2=N4) JX D3X
    <- plus-swap-succ N6+1+N2=N4 N6+N2+1=N4
    <- plus-associative-converse
      N6+N2+1=N4 N5+1+N4=N1 N3 N5+1+N6=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- join/>-inversion JX N3+1+N2=N1 _ J M=M223
    <- eq-symmetric M=M223 M223=M
    <- join-preserves-deep-disjoint*/L _ _ (size/+ SZ1) SZ2
      (deep-disjoint/> D1 N5+1+N6=N3) D2 J D3
    <- deep-disjoint-respects-eq
      (deep-disjoint/< D3 N6+1+N2=N4) M223=M eq/ D3X.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= D1 X1 nat`eq/) (deep-disjoint/= D2 X2 nat`eq/)
    (join/= J MJ nat`eq/) (deep-disjoint/= DD XX nat`eq/)
    <- join-preserves-deep-disjoint*/L _ _ SZ1 SZ2 D1 D2 J DD
    <- inner-efxmap`join-preserves-disjoint* X1 X2 MJ XX.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= D1 X nat`eq/)
    (deep-disjoint/> D2 P1) (join/< J P2)
    (deep-disjoint/= DDD X nat`eq/)
    <- plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ
    <- succ-cancels EQ EQP
    <- map/+-preserves-eq EQP inner-efxmap`eq/ eq/ MEQ
    <- eq-symmetric MEQ MEQP
    <- join-respects-eq J eq/ MEQP eq/ JP
    <- join-preserves-deep-disjoint*/L
      _ _ SZ1 (size/+ SZ2) D1 D2 JP DDD.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= D1 X nat`eq/)
    (deep-disjoint/< D2 P1) (join/> J P2)
    (deep-disjoint/< DDD P1)
    <- plus-right-cancels P2 P1 nat`eq/ nat`eq/ EQ
    <- succ-cancels EQ EQP
    <- join-preserves-deep-disjoint*/L
      _ _ (size/+ SZ1) SZ2 (deep-disjoint/= D1 X EQP) D2 J DDD.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/> D1 P) (deep-disjoint/= D2 X nat`eq/)
    (join/> J PP) (deep-disjoint/= DD X nat`eq/)
    <- plus-right-cancels PP P nat`eq/ nat`eq/ EQ
    <- succ-cancels EQ EQP
    <- map/+-preserves-eq EQP inner-efxmap`eq/ eq/ MEQ
    <- join-respects-eq J MEQ eq/ eq/ JP
    <- join-preserves-deep-disjoint*/L
      _ _ (size/+ SZ1) SZ2 D1 D2 JP DD.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/< D1 P1) (deep-disjoint/= D2 X nat`eq/)
    (join/< J P2)
    (deep-disjoint/< DDD P1)
    <- plus-right-cancels P2 P1 nat`eq/ nat`eq/ EQ
    <- succ-cancels EQ EQP
    <- join-preserves-deep-disjoint*/L
      _ _ SZ1 (size/+ SZ2) D1 (deep-disjoint/= D2 X EQP) J DDD.

%%% all the impossible cases

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= D1 X1 nat`eq/) (deep-disjoint/= D2 X2 nat`eq/)
    (join/> J P) DD
    <- plus-implies-gt P nat`eq/ GT
    <- nat`eq-ne-implies-false nat`eq/ (nat`ne/> GT) F
    <- false-implies-deep-disjoint F DD.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= D1 X1 nat`eq/) (deep-disjoint/= D2 X2 nat`eq/)
    (join/< J P) DD
    <- plus-implies-gt P nat`eq/ GT
    <- nat`eq-ne-implies-false nat`eq/ (nat`ne/> GT) F
    <- false-implies-deep-disjoint F DD.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= _ _ nat`eq/)
    (deep-disjoint/< _ P) (join/= _ _ nat`eq/) DD
    <- plus-implies-gt P nat`eq/ GT
    <- nat`eq-ne-implies-false nat`eq/ (nat`ne/> GT) F
    <- false-implies-deep-disjoint F DD.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= _ _ nat`eq/)
    (deep-disjoint/> _ P) (join/= _ _ nat`eq/) DD
    <- plus-implies-gt P nat`eq/ GT
    <- nat`eq-ne-implies-false nat`eq/ (nat`ne/> GT) F
    <- false-implies-deep-disjoint F DD.

%worlds () (join-preserves-deep-disjoint*/L _ _ _ _ _ _ _ _).
%total {S1 S2 D1} (join-preserves-deep-disjoint*/L S1 S2 _ _ D1 _ _ _).

%worlds () (join-preserves-deep-disjoint* _ _ _ _).
%total { } (join-preserves-deep-disjoint* _ _ _ _).


%abbrev join-left-preserves-deep-disjoint* = join-preserves-deep-disjoint*.


%theorem join-right-preserves-deep-disjoint* :
 forall* {M1} {M2} {M3} {M0}
 forall {D1:deep-disjoint M0 M1}
         {D2:deep-disjoint M0 M2}
        {A:join M1 M2 M3}
 exists {D3:deep-disjoint M0 M3}
 true.

- : join-right-preserves-deep-disjoint* D1 D2 U D3
    <- deep-disjoint-symmetric D1 D1s
    <- deep-disjoint-symmetric D2 D2s
    <- join-left-preserves-deep-disjoint* D1s D2s U D3s
    <- deep-disjoint-symmetric D3s D3.

%worlds () (join-right-preserves-deep-disjoint* _ _ _ _).
%total { } (join-right-preserves-deep-disjoint* _ _ _ _).


%theorem join-preserves-deep-disjoint-converse:
 forall* {M1} {M2} {M3} {M4}
 forall {D3:deep-disjoint M3 M4}
        {A:join M1 M2 M3}
 exists {D1:deep-disjoint M1 M4} {D2:deep-disjoint M2 M4}
 true.

- : join-preserves-deep-disjoint-converse
    D join/L deep-disjoint/L D.

- : join-preserves-deep-disjoint-converse
    D join/R D deep-disjoint/L.

- : join-preserves-deep-disjoint-converse
    deep-disjoint/R _
    deep-disjoint/R deep-disjoint/R.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/< D P)
    (join/= J _ nat`eq/)
    (deep-disjoint/< D1 P) (deep-disjoint/< D2 P)
    <- join-preserves-deep-disjoint-converse D J D1 D2.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/< D P1)
    (join/< J P2)
    (deep-disjoint/< D1 P1) D2S
    <- join-preserves-deep-disjoint-converse D J D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-deep-disjoint
      D2 (shift/+ P2sc) (shift/+ P1sc) D2S.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/< D P1)
    (join/> J P2)
    D1S (deep-disjoint/< D2 P1)
    <- join-preserves-deep-disjoint-converse D J D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-deep-disjoint
      D1 (shift/+ P2sc) (shift/+ P1sc) D1S.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/> D P1)
    (join/= J DE nat`eq/)
    D1S D2S
    <- join-preserves-deep-disjoint-converse
      D (join/= J DE nat`eq/) D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- shift-left-preserves-deep-disjoint D1 (shift/+ P1sc) D1S
    <- shift-left-preserves-deep-disjoint D2 (shift/+ P1sc) D2S.

- : join-preserves-deep-disjoint-converse
 (deep-disjoint/> D P1)
 (join/< J P2)
        D1S D2S
    <- plus-swap-succ P1 P1s
    <- plus-associative-converse P1s P2 _ P3 P4s
    <- join-preserves-deep-disjoint-converse D (join/< J P3) D1 D2
    <- plus-commutative P1s P1sc
    <- plus-commutative P4s P4sc
    <- shift-left-preserves-deep-disjoint D1 (shift/+ P1sc) D1S
    <- shift-left-preserves-deep-disjoint D2 (shift/+ P4sc) D2S.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/> D P1)
    (join/> J P2)
    D1S D2S
    <- plus-swap-succ P1 P1s
    <- plus-associative-converse P1s P2 _ P3 P4s
    <- join-preserves-deep-disjoint-converse D (join/> J P3) D1 D2
    <- plus-commutative P1s P1sc
    <- plus-commutative P4s P4sc
    <- shift-left-preserves-deep-disjoint D1 (shift/+ P4sc) D1S
    <- shift-left-preserves-deep-disjoint D2 (shift/+ P1sc) D2S.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/= D X nat`eq/) (join/= J P nat`eq/)
    (deep-disjoint/= D1 X1 nat`eq/) (deep-disjoint/= D2 X2 nat`eq/)
    <- join-preserves-deep-disjoint-converse D J D1 D2
    <- inner-efxmap`join-preserves-disjoint-converse X P X1 X2.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/= D X nat`eq/) (join/< J P)
    (deep-disjoint/= D1 X nat`eq/) (deep-disjoint/> D2 P)
    <- join-preserves-deep-disjoint-converse D J D1 D2.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/= D X nat`eq/) (join/> J P)
    (deep-disjoint/> D1 P) (deep-disjoint/= D2 X nat`eq/)
    <- join-preserves-deep-disjoint-converse D J D1 D2.


%worlds () (join-preserves-deep-disjoint-converse _ _ _ _).
%total (D) (join-preserves-deep-disjoint-converse D _ _ _).


%theorem deep-disjoint-lookup-implies-disjoint :
 forall* {M1} {M2} {N} {D1} {D2}
 forall {A:deep-disjoint M1 M2}
        {L1:lookup M1 N D1} {L2:lookup M2 N D2}
 exists {IX:inner-efxmap`disjoint D1 D2}
 true.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/= _ X nat`eq/)
    (lookup/= nat`eq/) (lookup/= nat`eq/) X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/= X _ nat`eq/)
    (lookup/> L1 P1) (lookup/> L2 P2) XX
    <- plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ
    <- succ-cancels EQ NEQ
    <- lookup-respects-eq L1 eq/ NEQ inner-efxmap`eq/ L1P
    <- deep-disjoint-lookup-implies-disjoint X L1P L2 XX.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/= _ _ nat`eq/)
    (lookup/> _ P) (lookup/= nat`eq/) X
    <- plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- inner-efxmap`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/= _ _ nat`eq/)
    (lookup/= nat`eq/) (lookup/> _ P) X
    <- plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- inner-efxmap`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/< _ N0+1+N=N)
    (lookup/= nat`eq/) (lookup/= nat`eq/) X
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- inner-efxmap`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/< _ P1)
    (lookup/= nat`eq/) (lookup/> _ P2) X
    <- plus-implies-gt P1 nat`eq/ GT1
    <- plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- inner-efxmap`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/< D N0+1+N1=N2)
    (lookup/> L1P N0P+1+N1=N2)
    (lookup/= nat`eq/) F
    <- plus-right-cancels N0P+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N0P+1=N0+1
    <- succ-cancels N0P+1=N0+1 N0P=N0
    <- lookup-respects-eq L1P eq/ N0P=N0 inner-efxmap`eq/ L1
    <- deep-disjoint-lookup-implies-disjoint D L1 (lookup/= nat`eq/) F.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/< D N0+1+N1=N2)
    (lookup/> L1 N1P+1+N1=N)
    (lookup/> L2 N2P+1+N2=N) F
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N2P+1+N2=N NX
                                 N2P+1+N0=NX NX+N1+1=N
    <- plus-swap-succ N1P+1+N1=N N1P+N1+1=N
    <- plus-right-cancels NX+N1+1=N N1P+N1+1=N nat`eq/ nat`eq/ NX=N1P
    <- plus-respects-eq N2P+1+N0=NX nat`eq/ nat`eq/ NX=N1P N2P+1+N0=N1P
    <- deep-disjoint-lookup-implies-disjoint
      D L1 (lookup/> L2 N2P+1+N0=N1P) F.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/> _ N3+1+N=N)
    (lookup/= nat`eq/) (lookup/= nat`eq/) X
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- inner-efxmap`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/> _ N3+1+N2=N1)
    (lookup/> _ N3+1+N1=N2)
    (lookup/= nat`eq/) X
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- plus-implies-gt N3+1+N1=N2 nat`eq/ N2>N1
    <- gt-anti-symmetric N1>N2 N2>N1 F
    <- inner-efxmap`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/> D N3+1+N2=N1)
    (lookup/= nat`eq/)
    (lookup/> L2P N3P+1+N2=N1) F
    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- succ-cancels N3P+1=N3+1 N3P=N3
    <- lookup-respects-eq L2P eq/ N3P=N3 inner-efxmap`eq/ L2
    <- deep-disjoint-lookup-implies-disjoint D (lookup/= nat`eq/) L2 F.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/> D N3+1+N2=N1)
    (lookup/> L1 N1P+1+N1=N)
    (lookup/> L2 N2P+1+N2=N) F
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N1P+1+N1=N NX
                                 N1P+1+N3=NX NX+N2+1=N
    <- plus-swap-succ N2P+1+N2=N N2P+N2+1=N
    <- plus-right-cancels NX+N2+1=N N2P+N2+1=N nat`eq/ nat`eq/ NX=N2P
    <- plus-respects-eq N1P+1+N3=NX nat`eq/ nat`eq/ NX=N2P N1P+1+N3=N2P
    <- deep-disjoint-lookup-implies-disjoint
      D (lookup/> L1 N1P+1+N3=N2P) L2 F.

%worlds () (deep-disjoint-lookup-implies-disjoint _ _ _ _).
%total (D) (deep-disjoint-lookup-implies-disjoint D _ _ _).


%theorem fresh-update-preserves-deep-disjoint :
 forall* {M1} {M2} {N} {D} {M2P}
 forall {I: deep-disjoint M1 M2}
  {F: fresh M1 N}
  {U: update M2 N D M2P}
 exists {DP: deep-disjoint M1 M2P}
 true.

%theorem fresh-update-preserves-deep-disjoint/L :
    forall* {M1} {M2} {N} {D} {M2P} {B}
    forall {I: deep-disjoint M1 M2}
           {F: fresh M1 N}
           {U: update M2 N D M2P}
           {D?: deep-disjoint? M1 M2P B}
    exists {DP: deep-disjoint M1 M2P}
    true.

- : fresh-update-preserves-deep-disjoint/L
    _ _ _ (deep-disjoint?/yes DJ) DJ.

- : fresh-update-preserves-deep-disjoint/L
    D FR U (deep-disjoint?/no
      L1 L2P (inner-efxmap`disjoint?/no LL1 LL2)) XXX
    <- fresh-lookup-not-equal FR L1 NE
    <- nat`ne-symmetric NE NEs
    <- update-preserves-lookup-converse L2P U NEs L2
    <- deep-disjoint-lookup-implies-disjoint D L1 L2 IX
    <- inner-efxmap`disjoint-lookup-contradiction IX LL1 LL2 F
    <- false-implies-deep-disjoint F XXX.

%worlds () (fresh-update-preserves-deep-disjoint/L _ _ _ _ _).
%total { } (fresh-update-preserves-deep-disjoint/L _ _ _ _ _).

- : fresh-update-preserves-deep-disjoint D F U DP
    <- deep-disjoint?-total D?
    <- fresh-update-preserves-deep-disjoint/L D F U D? DP.

%worlds () (fresh-update-preserves-deep-disjoint _ _ _ _).
%total { } (fresh-update-preserves-deep-disjoint _ _ _ _).



%theorem deep-disjoint-respects-geq*/L :
    forall* {M1} {M2} {M1P}
    forall {N1} {SZ1: size M1 N1}
           {N2} {SZ2: size M2 N2}
           {A:deep-disjoint M1 M2}
           {E1:leq M1P M1}
    exists {AP:deep-disjoint M1P M2}
    true.

- : deep-disjoint-respects-geq*/L _ (size/+ SZ1)
    _ (size/+ SZ2)
    (deep-disjoint/< D1 P) (leq/= L _ nat`eq/)
    (deep-disjoint/< D1P P)
    <- deep-disjoint-respects-geq*/L
      _ SZ1 _ (size/+ SZ2) D1 L D1P.

- : deep-disjoint-respects-geq*/L _ _ _ _
    _ leq/0 deep-disjoint/L.

- : deep-disjoint-respects-geq*/L _ _ _ _
    deep-disjoint/R _ deep-disjoint/R.

- : deep-disjoint-respects-geq*/L
    _ (size/+ SZ1) _ (size/+ SZ2)
    (deep-disjoint/> D1 P) (leq/= L DL nat`eq/)
    (deep-disjoint/> D1P P)
    <- deep-disjoint-respects-geq*/L
      _ (size/+ SZ1) _ SZ2 D1 (leq/= L DL nat`eq/) D1P.

- : deep-disjoint-respects-geq*/L
    _ (size/+ SZ1) _ (size/+ SZ2)
    (deep-disjoint/< D1 P1) (leq/> L P2) DP
    <- deep-disjoint-respects-geq*/L
      _ SZ1 _ (size/+ SZ2) D1 L D1P
    <- plus-swap-succ P1 P1S
    <- plus-swap-succ P2 P2S
    <- plus-commutative P1S P1SC
    <- plus-commutative P2S P2SC
    <- shift-preserves-deep-disjoint
      D1P (shift/+ P2SC) (shift/+ P1SC) DP.

- : deep-disjoint-respects-geq*/L
    _ (size/+ SZ1) _ (size/+ SZ2)
    (deep-disjoint/> D1 N0+1+N1=N2) (leq/> L N3+1+N2=N4) DP
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse
      N0+N1+1=N2 N3+1+N2=N4 N5 N3+1+N0=N5 N5+N1+1=N4
    <- deep-disjoint-respects-geq*/L _ (size/+ SZ1) _ SZ2
      D1 (leq/> L N3+1+N0=N5) D1P
    <- plus-commutative N5+N1+1=N4 N1+1+N5=N4
    <- shift-left-preserves-deep-disjoint
      D1P (shift/+ N1+1+N5=N4) DP.

- : deep-disjoint-respects-geq*/L
    _ (size/+ SZ1) _ (size/+ SZ2)
    (deep-disjoint/= XM1^XM2 M1^M2 nat`eq/)
    (leq/= XM1P<=XM1 M1P<=M1 nat`eq/)
    (deep-disjoint/= XM1P^XM2 M1P^M2 nat`eq/)
    <- deep-disjoint-respects-geq*/L _ SZ1 _ SZ2
      XM1^XM2 XM1P<=XM1 XM1P^XM2
    <- inner-efxmap`disjoint-respects-geq*
      M1^M2 M1P<=M1 M1P^M2.

- : deep-disjoint-respects-geq*/L
    _ (size/+ SZ1) _ (size/+ SZ2)
    (deep-disjoint/= XM1^XM2 _ nat`eq/)
    (leq/> N3XM1P<=XM1 N3+1+N2=N1) XM1P^XM2
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- shift-total SH2
    <- shift-preserves-leq N3XM1P<=XM1
      (shift/+ N2+1+N3=N1) SH2 N1XM1P<=XM1S
    <- shift-total SH3
    <- shift-preserves-deep-disjoint XM1^XM2 SH2 SH3 XM1S^XM2S
    <- shift-preserves-size SZ1 SH2 SZ1P
    <- shift-preserves-size SZ2 SH3 SZ2P
    <- deep-disjoint-respects-geq*/L
      _ SZ1P _ SZ2P XM1S^XM2S N1XM1P<=XM1S XM1P^XM2S
    <- shift-implies-update SH3 UD3
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- fresh-update-preserves-deep-disjoint
      XM1P^XM2S (fresh/< N1>N2) UD3 XM1P^XM2.

%worlds () (deep-disjoint-respects-geq*/L _ _ _ _ _ _ _).
%total {N1 N2} (deep-disjoint-respects-geq*/L N1 _ N2 _ _ _ _).


%theorem deep-disjoint-respects-geq* :
    forall* {M1} {M2} {M1P}
    forall {A:deep-disjoint M1 M2}
           {E1:leq M1P M1}
    exists {AP:deep-disjoint M1P M2}
    true.

- : deep-disjoint-respects-geq* A E1 AP
    <- size-total SZ1
    <- size-total SZ2
    <- deep-disjoint-respects-geq*/L _ SZ1 _ SZ2 A E1 AP.

%worlds () (deep-disjoint-respects-geq* _ _ _).
%total {} (deep-disjoint-respects-geq* _ _ _).


%theorem deep-disjoint-respects-geq :
 forall* {M1} {M2} {M1P} {M2P}
 forall {A:deep-disjoint M1 M2}
        {E1:leq M1P M1} {E2:leq M2P M2}
 exists {AP:deep-disjoint M1P M2P}
 true.

- : deep-disjoint-respects-geq M1^M2 M1P<=M1 M2P<=M2 M1P^M2P
    <- deep-disjoint-respects-geq* M1^M2 M1P<=M1 M1P^M2
    <- deep-disjoint-symmetric M1P^M2 M2^M1P
    <- deep-disjoint-respects-geq* M2^M1P M2P<=M2 M2P^M1P
    <- deep-disjoint-symmetric M2P^M1P M1P^M2P.

%worlds () (deep-disjoint-respects-geq _ _ _ _).
%total { } (deep-disjoint-respects-geq _ _ _ _).


%% NOTE: deep-disjoint is NOT anti-reflexive:
%% we could have same keys point to empty inner map.

% %theorem deep-disjoint-anti-reflexive :
% forall* {M}
% forall {D:deep-disjoint M M}
% exists {E:eq map/0 M}
% true.

% %worlds () (deep-disjoint-anti-reflexive _ _).
% %total { } (deep-disjoint-anti-reflexive _ _).

% %theorem deep-disjoint-leq-implies-empty :
% forall* {M1} {M2}
% forall {D: deep-disjoint M1 M2}
% {L: leq M1 M2}
% exists {E: eq map/0 M1}
% true.

% %worlds () (deep-disjoint-leq-implies-empty _ _ _).
% %total { } (deep-disjoint-leq-implies-empty _ _ _).


%theorem disjoint-implies-deep-disjoint :
    forall* {M1} {M2}
    forall {D: disjoint M1 M2}
    exists {D: deep-disjoint M1 M2}
    true.

- : disjoint-implies-deep-disjoint
    disjoint/L deep-disjoint/L.

- : disjoint-implies-deep-disjoint
    disjoint/R deep-disjoint/R.

- : disjoint-implies-deep-disjoint
    (disjoint/< D P) (deep-disjoint/< DP P)
    <- disjoint-implies-deep-disjoint D DP.

- : disjoint-implies-deep-disjoint
    (disjoint/> D P) (deep-disjoint/> DP P)
    <- disjoint-implies-deep-disjoint D DP.

%worlds () (disjoint-implies-deep-disjoint _ _).
%total (D) (disjoint-implies-deep-disjoint D _).


%% short of good name for this one

%theorem shift-inside-right-preserves-deep-disjoint :
    forall* {M1} {M2} {D} {N} {SM2}
    forall {D: deep-disjoint M1 (map/+ N D M2)}
            {S: shift N M2 SM2}
    exists {D: deep-disjoint M1 SM2}
    true.

- : shift-inside-right-preserves-deep-disjoint D SH DD
    <- can-construct-unit-join SH J
    <- deep-disjoint-symmetric D D1
    <- join-preserves-deep-disjoint-converse D1 J DD1 DD2
    <- deep-disjoint-symmetric DD1 DD.

%worlds () (shift-inside-right-preserves-deep-disjoint _ _ _).
%total (D) (shift-inside-right-preserves-deep-disjoint D _ _).


%theorem shift-inside-left-preserves-deep-disjoint :
    forall* {M1} {M2} {D} {N} {SM1}
    forall {D: deep-disjoint (map/+ N D M1) M2}
            {S: shift N M1 SM1}
    exists {D: deep-disjoint SM1 M2}
    true.

- : shift-inside-left-preserves-deep-disjoint D SH DD
    <- can-construct-unit-join SH J
    <- join-preserves-deep-disjoint-converse D J DD _.

%worlds () (shift-inside-left-preserves-deep-disjoint _ _ _).
%total (D) (shift-inside-left-preserves-deep-disjoint D _ _).


%theorem shift-inside-preserves-deep-disjoint :
    forall* {M1} {M2} {D1} {D2} {N1} {N2} {SM1} {SM2}
    forall {D: deep-disjoint
                (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
            {S: shift N1 M1 SM1} {S: shift N2 M2 SM2}
    exists {D: deep-disjoint SM1 SM2}
    true.

- : shift-inside-preserves-deep-disjoint
    D shift/0 _ deep-disjoint/L.

- : shift-inside-preserves-deep-disjoint
    D _ shift/0 deep-disjoint/R.

- : shift-inside-preserves-deep-disjoint
    (deep-disjoint/= M1<>M2 D1<>D2 nat`eq/)
    (shift/+ P1) (shift/+ P2) M3<>M4
    <- shift-preserves-deep-disjoint
      M1<>M2 (shift/+ P1) (shift/+ P2) M3<>M4.

- : shift-inside-preserves-deep-disjoint
    (deep-disjoint/< A P) (shift/+ P1) (shift/+ P2) DD
    <- plus-swap-succ P PS
    <- plus-commutative PS PP
    <- shift-preserves-deep-disjoint
      A (shift/+ P1) (shift/+ PP) DPPP
    <- shift-inside-right-preserves-deep-disjoint
      DPPP (shift/+ P2) DD.

- : shift-inside-preserves-deep-disjoint
    (deep-disjoint/> D P) (shift/+ P1) (shift/+ P2) DD
    <- plus-swap-succ P PS
    <- plus-commutative PS PP
    <- shift-preserves-deep-disjoint
      D (shift/+ PP) (shift/+ P2) DPPP
    <- shift-inside-left-preserves-deep-disjoint
      DPPP (shift/+ P1) DD.

%worlds () (shift-inside-preserves-deep-disjoint _ _ _ _).
%total {} (shift-inside-preserves-deep-disjoint _ _ _ _).


%%% shouldn't need this lemma!

%theorem update-disjoint-implies-disjoint/L :
    forall* {N} {D1} {D2} {M} {MP}
    forall {U: update M N D2 MP}
            {D: inner-efxmap`disjoint D1 D2}
    exists {D: deep-disjoint (map/+ N D1 map/0) MP}
    true.

- : update-disjoint-implies-disjoint/L
    update/0 X
    (deep-disjoint/= deep-disjoint/L X nat`eq/).

- : update-disjoint-implies-disjoint/L
    (update/> U P) X (deep-disjoint/> DD P)
    <- update-disjoint-implies-disjoint/L U X DD.

- : update-disjoint-implies-disjoint/L
    (update/< P) X
    (deep-disjoint/= deep-disjoint/L X nat`eq/).

- : update-disjoint-implies-disjoint/L
    (update/= nat`eq/) X
    (deep-disjoint/= deep-disjoint/L X nat`eq/).

%worlds () (update-disjoint-implies-disjoint/L _ _ _).
%total (U) (update-disjoint-implies-disjoint/L U _ _).


%theorem update-disjoint-implies-disjoint :
    forall* {XM1} {XM2} {M1} {M2} {L} {XM1S} {XM2S}
    forall {D: deep-disjoint XM1 XM2}
            {U: update XM1 L M1 XM1S}
            {U: update XM2 L M2 XM2S}
            {D: inner-efxmap`disjoint M1 M2}
    exists {D: deep-disjoint XM1S XM2S}
    true.

- : update-disjoint-implies-disjoint
    _ update/0 update/0 X
    (deep-disjoint/= deep-disjoint/L X nat`eq/).

- : update-disjoint-implies-disjoint
    _ update/0 (update/= nat`eq/)
    M1<>M2 (deep-disjoint/= deep-disjoint/L M1<>M2 nat`eq/).

- : update-disjoint-implies-disjoint
    _ (update/= nat`eq/) update/0 X
    (deep-disjoint/= deep-disjoint/R X nat`eq/).

- : update-disjoint-implies-disjoint
    deep-disjoint/L update/0 (update/> U P) X
    (deep-disjoint/> DD P)
    <- update-disjoint-implies-disjoint/L U X DD.

- : update-disjoint-implies-disjoint
    deep-disjoint/R (update/> U P) update/0 X
    (deep-disjoint/< DD P)
    <- inner-efxmap`disjoint-symmetric X XP
    <- update-disjoint-implies-disjoint/L U XP DP
    <- deep-disjoint-symmetric DP DD.

- : update-disjoint-implies-disjoint
    _ (update/< P) update/0 X
    (deep-disjoint/= deep-disjoint/R X nat`eq/).

- : update-disjoint-implies-disjoint
    XM1<>XM2 (update/= nat`eq/) (update/= nat`eq/)
    IM1<>IM2 (deep-disjoint/= XM1S<>XM2S IM1<>IM2 nat`eq/)
    <- deep-disjoint/=-inversion XM1<>XM2 nat`eq/ _ XM1S<>XM2S.

- : update-disjoint-implies-disjoint
    D (update/< P) (update/= nat`eq/) M1<>M2
    (deep-disjoint/= DP M1<>M2 nat`eq/)
    <- deep-disjoint/>-inversion D P DP.

- : update-disjoint-implies-disjoint
    D (update/= nat`eq/) (update/< P) M1<>M2
    (deep-disjoint/= DP M1<>M2 nat`eq/)
    <- deep-disjoint/<-inversion D P DP.


- : update-disjoint-implies-disjoint
    D (update/> U P) (update/= nat`eq/) M1<>M2
    (deep-disjoint/< DD P)
    <- deep-disjoint/<-inversion D P DP
    <- update-disjoint-implies-disjoint
      DP U (update/= nat`eq/) M1<>M2 DD.

- : update-disjoint-implies-disjoint D
    (update/= nat`eq/) (update/> U P) X
    (deep-disjoint/> DD P)
    <- deep-disjoint/>-inversion D P D1
    <- update-disjoint-implies-disjoint
      D1 (update/= nat`eq/) U X DD.

- : update-disjoint-implies-disjoint
    D (update/> U P) (update/< P1) M1<>M2
    (deep-disjoint/< DPP P)
    <- plus-associative-converse P P1 N6 SN4+SN5=N6 N6+N1=N2
    <- plus-left-preserves-positive SN4+SN5=N6 nat`eq/ _ EQ
    <- plus-respects-eq SN4+SN5=N6 nat`eq/ nat`eq/ EQ (plus/s N4+SN5=N6)
    <- plus-right-preserves-positive N4+SN5=N6 nat`eq/ _ EQ2
    <- plus-respects-eq N6+N1=N2 EQ nat`eq/ nat`eq/ SN8+N1=N2
    <- deep-disjoint/<-inversion D SN8+N1=N2 DP
    <- plus-swap-succ-converse N4+SN5=N6 SN4+N5=N6
    <- update-disjoint-implies-disjoint
      DP U (update/< SN4+N5=N6) M1<>M2 DPP.

- : update-disjoint-implies-disjoint
    D (update/< P1) (update/> U P) M1<>M2
    (deep-disjoint/> DPP P)
    <- plus-associative-converse P P1 N6 SN4+SN5=N6 N6+N1=N2
    <- plus-left-preserves-positive SN4+SN5=N6 nat`eq/ _ EQ
    <- plus-respects-eq SN4+SN5=N6 nat`eq/ nat`eq/ EQ (plus/s N4+SN5=N6)
    <- plus-right-preserves-positive N4+SN5=N6 nat`eq/ _ EQ2
    <- plus-respects-eq N6+N1=N2 EQ nat`eq/ nat`eq/ SN8+N1=N2
    <- deep-disjoint/>-inversion D SN8+N1=N2 DP
    <- plus-swap-succ-converse N4+SN5=N6 SN4+N5=N6
    <- update-disjoint-implies-disjoint
      DP (update/< SN4+N5=N6) U M1<>M2 DPP.

- : update-disjoint-implies-disjoint
    D (update/< P1) (update/< P2) M1<>M2
    (deep-disjoint/= DP M1<>M2 nat`eq/)
    <- plus-swap-succ P1 P1S
    <- plus-commutative P1S P1P
    <- plus-swap-succ P2 P2S
    <- plus-commutative P2S P2P
    <- shift-preserves-deep-disjoint-converse
      D (shift/+ P1P) (shift/+ P2P) DP.

- : update-disjoint-implies-disjoint
    (deep-disjoint/= M1<>M2 D1<>D2 nat`eq/)
    (update/> U1 P1) (update/> U2 P2) DDD
    (deep-disjoint/= M1<>M2' D1<>D2 nat`eq/)
    <- plus-right-cancels P1 P2 nat`eq/ nat`eq/ E
    <- succ-cancels E EP
    <- update-respects-eq
      U1 eq/ EP inner-efxmap`eq/ eq/ U1P
    <- update-disjoint-implies-disjoint M1<>M2 U1P U2 DDD M1<>M2'.

- : update-disjoint-implies-disjoint
    (deep-disjoint/< D P)
    (update/> U1 P1)
    (update/> U2 P2) DDD (deep-disjoint/< XXX P)
    <- plus-associative-converse P P2 _ P3 P4
    <- plus-right-cancels P4 P1 nat`eq/ nat`eq/ E
    <- plus-respects-eq P3 nat`eq/ nat`eq/ E P5
    <- plus-right-decrease P5 _ EE P7
    <- succ-cancels EE EQ
    <- nat`eq-symmetric EQ EQP
    <- plus-respects-eq P7 nat`eq/ nat`eq/ EQP P6
    <- update-disjoint-implies-disjoint
      D U1 (update/> U2 P6) DDD XXX.

- : update-disjoint-implies-disjoint
    (deep-disjoint/> D P)
    (update/> U1 P1) (update/> U2 P2) DDD
    (deep-disjoint/> D1 P)
    <- plus-associative-converse P P1 _ P3 P4
    <- plus-right-cancels P4 P2 nat`eq/ nat`eq/ E
    <- plus-respects-eq P3 nat`eq/ nat`eq/ E P5
    <- plus-right-decrease P5 _ EE P7
    <- succ-cancels EE EQ
    <- nat`eq-symmetric EQ EQP
    <- plus-respects-eq P7 nat`eq/ nat`eq/ EQP P6
    <- update-disjoint-implies-disjoint
      D (update/> U1 P6) U2 DDD D1.

- : update-disjoint-implies-disjoint
    _ update/0 (update/< _) M1<>M2
    (deep-disjoint/= deep-disjoint/L M1<>M2 nat`eq/).

%worlds () (update-disjoint-implies-disjoint _ _ _ _ _).
%total (D) (update-disjoint-implies-disjoint D _ _ _ _).



%%%%% map-restrict.elf
%%%%% Restricting a map to a domain inside a set.
%%%%% This file is one of the add-ons to the map ``functor''
%%%%% It requires set and map-base and
%%%%% optionally map-domain, map-leq, map-join, map-scale


%%%% Definitions


%%% restriction

restrict : map -> set -> map -> type.


restrict/0 : restrict map/0 _ map/0.

restrict/out :
 restrict M1 S M2 ->
 not-member S N ->
 fresh M1 N ->
 update M1 N D M1P ->
    restrict M1P S M2.

restrict/in :
 restrict M1 S M2 ->
 member S N ->
 fresh M1 N ->
 update M1 N D M1P ->
 update M2 N D M2P ->
    restrict M1P S M2P.




%%%% Theorems


%%% Theorems about restrict


%theorem false-implies-restrict :
 forall* {S1} {S2} {S3}
 forall {F:void}
 exists {D:restrict S1 S2 S3}
 true.

%worlds () (false-implies-restrict _ _).
%total {} (false-implies-restrict _ _).


%theorem restrict-respects-eq :
 forall* {S1} {S2} {S3} {T1} {T2} {T3}
 forall {DS:restrict S1 S2 S3}
               {E1:eq S1 T1} {E2:set`eq S2 T2} {E3:eq S3 T3}
 exists {DT:restrict T1 T2 T3}
 true.

- : restrict-respects-eq R eq/ set`eq/ eq/ R.

%worlds () (restrict-respects-eq _ _ _ _ _).
%total {} (restrict-respects-eq _ _ _ _ _).
%reduces R = RP (restrict-respects-eq R _ _ _ RP).


%theorem restrict-total* :
 forall {S1} {S2}
 exists {S3} {R:restrict S1 S2 S3}
 true.

%abbrev restrict-total = restrict-total* _ _ _.

%theorem restrict-total/L1 :
        forall* {A} {S}
 forall {N}
         {Z: size A N}
        exists {C}
  {R:restrict A S C}
 true.

- : restrict-total/L1 nat`z _ _ restrict/0.

%theorem restrict-total/L2 :
        forall* {A} {S} {X} {B} {D}
 forall {N}
         {Z: size A N}
  {L: lookup A X D}
  {M: set`member? S X B}
        exists {C}
  {R:restrict A S C}
 true.

- : restrict-total/L1 (s _) Z _ R
    <- set`member?-total M?
    <- restrict-total/L2 _ Z (lookup/= nat`eq/) M? _ R.

- : restrict-total/L2 (s _) Z L (set`member?/in S<-X) _
 (restrict/in R1 S<-X A1</-X A1+X->D=A C1+X->D=C)
    <- lookup-implies-fresh-update L _ A1</-X A1+X->D=A
    <- fresh-update-increases-size-converse Z A1</-X A1+X->D=A Z1
    <- restrict-total/L1 _ Z1 _ R1
    <- update-total C1+X->D=C.

- : restrict-total/L2 (s _) Z L (set`member?/out S</-X) _
 (restrict/out R1 S</-X A1</-X A1+X->D=A)
    <- lookup-implies-fresh-update L _ A1</-X A1+X->D=A
    <- fresh-update-increases-size-converse Z A1</-X A1+X->D=A Z1
    <- restrict-total/L1 _ Z1 _ R1.

%worlds () (restrict-total/L2 _ _ _ _ _ _)
    (restrict-total/L1 _ _ _ _).
%total (N2 N1)
    (restrict-total/L2 N2 _ _ _ _ _)
    (restrict-total/L1 N1 _ _ _).

- : restrict-total R
    <- size-total SZ
    <- restrict-total/L1 _ SZ _ R.

%worlds () (restrict-total* _ _ _ _).
%total { } (restrict-total* _ _ _ _).


%theorem restrict/in-inversion:
 forall* {A} {S} {C} {N} {D} {A1}
 forall {R: restrict A S C}
  {M: member S N}
  {F: fresh A1 N}
  {U: update A1 N D A}
 exists {C1}
  {R1: restrict A1 S C1}
  {U1: update C1 N D C}
 true.

%theorem restrict/in-inversion/in:
 forall* {A0} {S} {C0} {N0} {D0} {N} {D} {A1} {A} {C} {B}
 forall {R0: restrict A0 S C0}
  {M0: member S N0}
  {F0: fresh A0 N0}
  {UA: update A0 N0 D0 A}
  {UC: update C0 N0 D0 C}
  {M: member S N}
  {F: fresh A1 N}
  {U: update A1 N D A}
  {NEQ?: nat`eq? N N0 B}
 exists {C1}
  {R1: restrict A1 S C1}
  {U1: update C1 N D C}
 true.

- : restrict/in-inversion/in R0 M0 F0 UA UC M F U (nat`eq?/yes) _ R0P UCP
    <- fresh-update-cancels F0 UA F U nat`eq/ eq/ D0=D A0=A1
    <- restrict-respects-eq R0 A0=A1 set`eq/ eq/ R0P
    <- update-respects-eq UC eq/ nat`eq/ D0=D eq/ UCP.

- : restrict/in-inversion/in R0 M0 F0 UA UC M F U (nat`eq?/no N<>N0) _
 (restrict/in R2 M0 F2 UA1 UC1) UC3
    <- update-commutes-converse U UA N<>N0 _ UA1 U1
    <- update-preserves-fresh-converse F UA1 F1
    <- restrict/in-inversion R0 M F1 U1 _ R2 UC2
    <- update-preserves-fresh-converse F0 U1 F2
    <- update-commutes UC2 UC N<>N0 _ UC1 UC3.

- : restrict/in-inversion
 (restrict/in R0 M0 F0 UA0 UC0) M F U _ R UC
    <- nat`eq?-total NEQ?
    <- restrict/in-inversion/in R0 M0 F0 UA0 UC0 M F U NEQ? _ R UC.

- : restrict/in-inversion
 (restrict/out R0 NM0 F0 UA0) M F U _
 (restrict/out R2 NM0 F2 UA1) UC
    <- not-member-member-not-equal NM0 M (NE:nat`ne N0 N)
    <- update-commutes-converse UA0 U NE _ U1 UA1
    <- update-preserves-fresh-converse F UA1 F1
    <- restrict/in-inversion R0 M F1 U1 _ R2 UC
    <- update-preserves-fresh-converse F0 U1 F2.

%worlds () (restrict/in-inversion _ _ _ _ _ _ _)
    (restrict/in-inversion/in _ _ _ _ _ _ _ _ _ _ _ _).
%total (R R1) (restrict/in-inversion R _ _ _ _ _ _)
    (restrict/in-inversion/in R1 _ _ _ _ _ _ _ _ _ _ _).

%theorem restrict/out-inversion:
 forall* {A} {S} {C} {N} {D} {A1}
 forall {R: restrict A S C}
  {NM: not-member S N}
  {F: fresh A1 N}
  {U: update A1 N D A}
 exists {R1: restrict A1 S C}
 true.

%theorem restrict/out-inversion/out:
 forall* {A0} {S} {N0} {D0} {N} {D} {A1} {A} {C} {B}
 forall {R0: restrict A0 S C}
  {M0: not-member S N0}
  {F0: fresh A0 N0}
  {UA: update A0 N0 D0 A}
  {NM: not-member S N}
  {F: fresh A1 N}
  {U: update A1 N D A}
  {NEQ?: nat`eq? N N0 B}
 exists {R1: restrict A1 S C}
 true.

- : restrict/out-inversion/out R0 NM0 F0 UA0 NM F U (nat`eq?/yes) R0P
    <- fresh-update-cancels F0 UA0 F U nat`eq/ eq/ D0=D A0=A1
    <- restrict-respects-eq R0 A0=A1 set`eq/ eq/ R0P.

- : restrict/out-inversion/out R0 NM0 F0 UA0 NM F U (nat`eq?/no N<>N0)
 (restrict/out R2 NM0 F2 UA1)
    <- update-commutes-converse U UA0 N<>N0 _ UA1 U1
    <- update-preserves-fresh-converse F UA1 F1
    <- restrict/out-inversion R0 NM F1 U1 R2
    <- update-preserves-fresh-converse F0 U1 F2.

- : restrict/out-inversion
 (restrict/out R0 NM0 F0 UA0) NM F U R
    <- nat`eq?-total NEQ?
    <- restrict/out-inversion/out R0 NM0 F0 UA0 NM F U NEQ? R.

- : restrict/out-inversion
 (restrict/in R0 M0 F0 UA0 UC) NM F U
 (restrict/in R2 M0 F2 UA1 UC)
    <- not-member-member-not-equal NM M0 (N<>N0:nat`ne N N0)
    <- update-commutes-converse U UA0 N<>N0 _ UA1 U1
    <- update-preserves-fresh-converse F UA1 F1
    <- restrict/out-inversion R0 NM F1 U1 R2
    <- update-preserves-fresh-converse F0 U1 F2.

%worlds () (restrict/out-inversion _ _ _ _ _)
    (restrict/out-inversion/out _ _ _ _ _ _ _ _ _).
%total (R R1) (restrict/out-inversion R _ _ _ _)
    (restrict/out-inversion/out R1 _ _ _ _ _ _ _ _).


%theorem restrict-unique :
 forall* {S1} {S2} {S3} {T1} {T2} {T3}
 forall {RS:restrict S1 S2 S3} {RT:restrict T1 T2 T3}
        {E1:eq S1 T1} {E2:set`eq S2 T2}
 exists {E3:eq S3 T3}
 true.

%abbrev restrict-deterministic = restrict-unique.

- : restrict-unique restrict/0 restrict/0 _ _ eq/.

- : restrict-unique
 (restrict/in R1 M1 F1 UA1 UC1) R eq/ set`eq/ NEQ
    <- restrict/in-inversion R M1 F1 UA1 _ R2 UC2
    <- restrict-unique R1 R2 eq/ set`eq/ C1=C2
    <- update-unique UC1 UC2 C1=C2 nat`eq/ inner-efxmap`eq/ NEQ.

- : restrict-unique
 (restrict/out R1 NM1 F1 U1) R eq/ set`eq/ NEQ
    <- restrict/out-inversion R NM1 F1 U1 R2
    <- restrict-unique R1 R2 eq/ set`eq/ NEQ.

%worlds () (restrict-unique _ _ _ _ _).
%total (R) (restrict-unique R _ _ _ _).


%theorem restrict-preserves-lookup:
 forall* {A} {S} {C} {X} {D}
 forall {L: lookup A X D}
  {R: restrict A S C}
  {L: set`member S X}
 exists {L: lookup C X D}
 true.

- : restrict-preserves-lookup LA R M LC
    <- lookup-implies-fresh-update LA _ F UA
    <- restrict/in-inversion R M F UA _ R1 UC
    <- update-implies-lookup UC LC.

%worlds () (restrict-preserves-lookup _ _ _ _).
%total { } (restrict-preserves-lookup _ _ _ _).


%theorem restrict-preserves-fresh:
 forall* {A} {N} {S} {C}
 forall {FA: fresh A N}
  {R: restrict A S C}
 exists {FC: fresh C N}
 true.

- : restrict-preserves-fresh _ restrict/0 fresh/0.

- : restrict-preserves-fresh FAP (restrict/in R M F U UP) FCP
    <- update-implies-lookup U L
    <- fresh-lookup-not-equal FAP L N<>N0
    <- update-preserves-fresh-converse FAP U FA
    <- restrict-preserves-fresh FA R FC
    <- update-preserves-fresh FC UP N<>N0 FCP.

- : restrict-preserves-fresh FAP (restrict/out R _ _ U) FC
    <- update-preserves-fresh-converse FAP U FA
    <- restrict-preserves-fresh FA R FC.

%worlds () (restrict-preserves-fresh _ _ _).
%total (R) (restrict-preserves-fresh _ R _).


%theorem restrict-preserves-lookup-converse:
 forall* {A} {N} {S} {C} {D}
 forall {LC: lookup C N D}
  {R: restrict A S C}
 exists {LA: lookup A N D}
 true.

%theorem restrict-preserves-lookup-converse/L:
 forall* {A} {N} {S} {C} {D} {B} {B1}
 forall {LC: lookup C N D}
  {R: restrict A S C}
  {D?: domain? A N B}
  {M?: member? S N B1}
 exists {LA: lookup A N D}
 true.

- : restrict-preserves-lookup-converse/L LC R (domain?/in LAP) (member?/in M) LA
    <- lookup-implies-fresh-update LAP _ F U
    <- restrict/in-inversion R M F U _ R1 UP
    <- update-implies-lookup UP LCP
    <- lookup-unique LCP LC eq/ nat`eq/ DP=D
    <- lookup-respects-eq LAP eq/ nat`eq/ DP=D LA.

- : restrict-preserves-lookup-converse/L LC R (domain?/out FA) _ LA
    <- restrict-preserves-fresh FA R FC
    <- fresh-lookup-not-equal FC LC N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F LA.

- : restrict-preserves-lookup-converse/L LC R (domain?/in LA) (member?/out NM) L
    <- lookup-implies-fresh-update LA _ FA U
    <- restrict/out-inversion R NM FA U R2
    <- restrict-preserves-fresh FA R2 FC
    <- fresh-lookup-not-equal FC LC N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L.

%worlds () (restrict-preserves-lookup-converse/L _ _ _ _ _).
%total { } (restrict-preserves-lookup-converse/L _ _ _ _ _).

- : restrict-preserves-lookup-converse LC R LA
    <- domain?-total D?
    <- member?-total M?
    <- restrict-preserves-lookup-converse/L LC R D? M? LA.

%worlds () (restrict-preserves-lookup-converse _ _ _).
%total { } (restrict-preserves-lookup-converse _ _ _).


%theorem restrict-left-preserves-disjoint:
 forall* {A} {C} {E} {S} {T}
 forall {D: set`disjoint S T}
  {R1: restrict A S C}
  {R2: restrict A T E}
 exists {D: disjoint C E}
 true.

- : restrict-left-preserves-disjoint _ restrict/0 restrict/0 disjoint/R.

- : restrict-left-preserves-disjoint S^T
 (restrict/in R1 M1 F1 U1 U1P) R C1P^C2P
    <- disjoint-member-implies-not-member M1 S^T NM2
    <- restrict/out-inversion R NM2 F1 U1 R2
    <- restrict-left-preserves-disjoint S^T R1 R2 C1^C2P
    <- restrict-preserves-fresh F1 R2 F2P
    <- disjoint-symmetric C1^C2P C2P^C1
    <- fresh-update-preserves-disjoint C2P^C1 F2P U1P C2P^C1P
    <- disjoint-symmetric C2P^C1P C1P^C2P.

%theorem restrict-left-preserves-disjoint/L :
 forall* {S} {T} {A1} {C1} {N} {X} {A1P} {C2P} {B}
 forall {D: set`disjoint S T}
  {R1: restrict A1 S C1}
  {NM1: not-member S N}
  {F1: fresh A1 N}
  {U1: update A1 N X A1P}
  {R2P: restrict A1P T C2P}
  {M?: member? T N B}
 exists {D: disjoint C1 C2P}
 true.

- : restrict-left-preserves-disjoint/L S^T R1 NM1 F1 U1 R2P
 (member?/in M2) C1^C2P
    <- restrict/in-inversion R2P M2 F1 U1 _ R2 U2
    <- restrict-left-preserves-disjoint S^T R1 R2 C1^C2
    <- restrict-preserves-fresh F1 R1 F1P
    <- fresh-update-preserves-disjoint C1^C2 F1P U2 C1^C2P.

- : restrict-left-preserves-disjoint/L S^T R1 NM1 F1 U1 R2P
 (member?/out NM2) C1^C2
    <- restrict/out-inversion R2P NM2 F1 U1 R2
    <- restrict-left-preserves-disjoint S^T R1 R2 C1^C2.

- : restrict-left-preserves-disjoint S^T
 (restrict/out R1 NM1 F1 U1) R C1^C2P
    <- member?-total M?
    <- restrict-left-preserves-disjoint/L S^T R1 NM1 F1 U1 R M? C1^C2P.

%worlds () (restrict-left-preserves-disjoint _ _ _ _)
 (restrict-left-preserves-disjoint/L _ _ _ _ _ _ _ _).
%total (R1 R2) (restrict-left-preserves-disjoint _ R1 _ _)
 (restrict-left-preserves-disjoint/L _ R2 _ _ _ _ _ _).


%theorem restrict-right-preserves-disjoint:
 forall* {A} {C} {E} {G} {S} {T}
 forall {D: disjoint A E}
  {R1: restrict A S C}
  {R2: restrict E T G}
 exists {D: disjoint C G}
 true.

%theorem restrict-right-preserves-disjoint/L:
 forall* {A} {C} {E} {G} {S} {T} {B}
 forall {D: disjoint A E}
  {R1: restrict A S C}
  {R2: restrict E T G}
  {D: disjoint? C G B}
 exists {D: disjoint C G}
 true.

- : restrict-right-preserves-disjoint/L A^E A|S=C E|T=G (disjoint?/yes C^G) C^G.

- : restrict-right-preserves-disjoint/L A^E A|S=C E|T=G
 (disjoint?/no LC LG) C^G
    <- restrict-preserves-lookup-converse LC A|S=C LA
    <- restrict-preserves-lookup-converse LG E|T=G LE
    <- disjoint-lookup-contradiction A^E LA LE F
    <- false-implies-disjoint F C^G.

%worlds () (restrict-right-preserves-disjoint/L _ _ _ _ _).
%total { } (restrict-right-preserves-disjoint/L _ _ _ _ _).

- : restrict-right-preserves-disjoint A^E A|S=C E|T=G C^G
    <- disjoint?-total D?
    <- restrict-right-preserves-disjoint/L A^E A|S=C E|T=G D? C^G.

%worlds () (restrict-right-preserves-disjoint _ _ _ _).
%total { } (restrict-right-preserves-disjoint _ _ _ _).


%theorem fresh-add-preserves-restrict:
 forall* {A} {B1} {C} {B2} {N}
 forall {R1: restrict A B1 C}
  {F: fresh A N}
  {U: set`add B1 N B2}
 exists {R2: restrict A B2 C}
 true.

- : fresh-add-preserves-restrict restrict/0 _ _ restrict/0.

- : fresh-add-preserves-restrict
 (restrict/in R1 B1->N F1 U1 UP1) F A
 (restrict/in R2 B2->N F1 U1 UP1)
    <- update-preserves-fresh-converse F U1 FP
    <- fresh-add-preserves-restrict R1 FP A R2
    <- add-preserves-member B1->N A B2->N.

- : fresh-add-preserves-restrict
 (restrict/out R1 B1-/>N F1 U1) F A
 (restrict/out R2 B2-/>N F1 U1)
    <- update-preserves-fresh-converse F U1 FP
    <- fresh-add-preserves-restrict R1 FP A R2
    <- update-implies-lookup U1 L1
    <- fresh-lookup-not-equal F L1 NEs
    <- nat`ne-symmetric NEs NE
    <- add-preserves-not-member B1-/>N A NE B2-/>N.

%worlds () (fresh-add-preserves-restrict _ _ _ _).
%total (R) (fresh-add-preserves-restrict R _ _ _).


%theorem restrict-commute-update*:
 forall* {A1} {B1} {C1} {N} {D}
  {A2} {B2} {C2}
 forall {R1: restrict A1 B1 C1}
  {UA: update A1 N D A2}
  {A: set`add B1 N B2}
  {UC: update C1 N D C2}
 exists {R2: restrict A2 B2 C2}
 true.

%theorem restrict-commute-update/L:
 forall* {A1} {B1} {C1} {N} {D}
  {A2} {B2} {C2} {B} {BP}
 forall {R1: restrict A1 B1 C1}
  {UA: update A1 N D A2}
  {A: set`add B1 N B2}
  {UC: update C1 N D C2}
  {D?: domain? A1 N B}
  {M?: member? B1 N BP}
 exists {R2: restrict A2 B2 C2}
 true.

- : restrict-commute-update/L
 R UA B1+N=B2 UC (domain?/out FA) _
 (restrict/in RP B2->N FA UA UC)
    <- fresh-add-preserves-restrict R FA B1+N=B2 RP
    <- add-implies-member B1+N=B2 B2->N.

- : restrict-commute-update/L
 R1 UA1 B1+N=B2 UC1 (domain?/in LA) (member?/in B1->N)
 (restrict/in R3 B2->N FA2 UA3 UC3)
    <- lookup-implies-fresh-update LA _ FA2 UA2
    <- restrict/in-inversion R1 B1->N FA2 UA2 _ R2 UC2
    <- fresh-add-preserves-restrict R2 FA2 B1+N=B2 R3
    <- add-implies-member B1+N=B2 B2->N
    <- update-overwrites UA2 UA1 nat`eq/ UA3
    <- update-overwrites UC2 UC1 nat`eq/ UC3.

- : restrict-commute-update/L
 R1 UA1 B1+N=B2 UC1 (domain?/in LA) (member?/out B1-/>N)
 (restrict/in R3 B2->N FA2 UA3 UC1)
    <- lookup-implies-fresh-update LA _ FA2 UA2
    <- restrict/out-inversion R1 B1-/>N FA2 UA2 R2
    <- fresh-add-preserves-restrict R2 FA2 B1+N=B2 R3
    <- add-implies-member B1+N=B2 B2->N
    <- update-overwrites UA2 UA1 nat`eq/ UA3.

%worlds () (restrict-commute-update/L _ _ _ _ _ _ _).
%total { } (restrict-commute-update/L _ _ _ _ _ _ _).

- : restrict-commute-update* R UA AB UC RP
    <- domain?-total D?
    <- member?-total M?
    <- restrict-commute-update/L R UA AB UC D? M? RP.

%worlds () (restrict-commute-update* _ _ _ _ _).
%total { } (restrict-commute-update* _ _ _ _ _).


%theorem restrict-reorders :
 forall* {A} {B} {C} {D} {E}
 forall {R1: restrict A B C}
  {R2: restrict C D E}
 exists {F}
  {R3: restrict A D F}
  {R4: restrict F B E}
 true.

- : restrict-reorders restrict/0 restrict/0 _ restrict/0 restrict/0.

%theorem restrict-reorders/out:
 forall* {A} {S} {C} {T} {E} {N} {B} {AP} {D}
 forall {R1: restrict A S C}
  {R2: restrict C T E}
  {M?: member? S N B}
  {NM: not-member T N}
  {FA: fresh A N}
  {UA: update A N D AP}
 exists {CP}
  {R3: restrict AP S CP}
  {R4: restrict CP T E}
 true.

- : restrict-reorders/out R1 R2 (member?/in M1) NM2 FA UA _
 (restrict/in R1 M1 FA UA UC)
 (restrict/out R2 NM2 FC UC)
    <- restrict-preserves-fresh FA R1 FC
    <- update-total UC.

- : restrict-reorders/out R1 R2 (member?/out NM1) NM2 FA UA _
 (restrict/out R1 NM1 FA UA) R2.

%worlds () (restrict-reorders/out _ _ _ _ _ _ _ _ _).
%total { } (restrict-reorders/out _ _ _ _ _ _ _ _ _).

- : restrict-reorders
 (restrict/out A1|S=C S-/>N FA1 UA) C|T=E _
 R3 R4
     <- restrict-reorders A1|S=C C|T=E _ A1|T=F1 F1|S=E
     <- member?-total M?
     <- restrict-reorders/out A1|T=F1 F1|S=E M? S-/>N FA1 UA _ R3 R4.

%theorem restrict-reorders/in :
 forall* {A1} {S} {C1} {N} {D} {A2} {C2} {T} {E} {B}
 forall {R1: restrict A1 S C1}
  {M: member S N}
  {FA: fresh A1 N}
  {UA: update A1 N D A2}
  {UC: update C1 N D C2}
  {R2: restrict C2 T E}
  {M?: member? T N B}
 exists {F}
  {R3: restrict A2 T F}
  {R4: restrict F S E}
 true.

- : restrict-reorders/in A1|S=C1 S->N FA1 UA UC R2 (member?/out T-/>N) _
 (restrict/out A1|T=F T-/>N FA1 UA) F|S=E
    <- restrict-preserves-fresh FA1 A1|S=C1 FC1
    <- restrict/out-inversion R2 T-/>N FC1 UC C1|T=E
    <- restrict-reorders A1|S=C1 C1|T=E _ A1|T=F F|S=E.

- : restrict-reorders/in A1|S=C1 S->N FA1 UA UC R2 (member?/in T->N) _
 (restrict/in A1|T=F1 T->N FA1 UA UF)
 (restrict/in F1|S=E1 S->N FF1 UF UE)
    <- restrict-preserves-fresh FA1 A1|S=C1 FC1
    <- restrict/in-inversion R2 T->N FC1 UC _ C1|T=E1 UE
    <- restrict-reorders A1|S=C1 C1|T=E1 _ A1|T=F1 F1|S=E1
    <- update-total UF
    <- restrict-preserves-fresh FA1 A1|T=F1 FF1.

- : restrict-reorders
 (restrict/in A1|S=C1 S->N FA1 UA UC) C|T=E _ R3 R4
     <- member?-total M?
     <- restrict-reorders/in A1|S=C1 S->N FA1 UA UC C|T=E M? _ R3 R4.

%worlds () (restrict-reorders _ _ _ _ _)
 (restrict-reorders/in _ _ _ _ _ _ _ _ _ _).
%total (R1 R2) (restrict-reorders R1 _ _ _ _)
 (restrict-reorders/in R2 _ _ _ _ _ _ _ _ _).

%theorem restrict-reorders* :
 forall* {A} {B} {C} {D} {E} {F}
 forall {R1: restrict A B C}
  {R2: restrict C D E}
  {R3: restrict A D F}
 exists {R4: restrict F B E}
 true.

- : restrict-reorders* R1 R2 R3 R4
    <- restrict-reorders R1 R2 _ R3P R4P
    <- restrict-unique R3P R3 eq/ set`eq/ FP=F
    <- restrict-respects-eq R4P FP=F set`eq/ eq/ R4.

%worlds () (restrict-reorders* _ _ _ _).
%total { } (restrict-reorders* _ _ _ _).


%theorem restrict-associates-intersection* :
 forall* {A} {C} {E} {S} {T} {V}
 forall {R1: restrict A S C}
  {R2: restrict C T E}
  {I: intersection S T V}
 exists {R3: restrict A V E}
 true.

- : restrict-associates-intersection* restrict/0 restrict/0 _ restrict/0.

- : restrict-associates-intersection*
 (restrict/out A1|S=C S-/>N FA1 UA) C|T=E I
 (restrict/out A1|V=E V-/>N FA1 UA)
    <- restrict-associates-intersection* A1|S=C C|T=E I A1|V=E
    <- intersection-right-preserves-not-member S-/>N I V-/>N.

%theorem restrict-associates-intersection*/L :
 forall* {A} {C} {E} {S} {T} {V} {B} {A1} {C1} {D} {N}
 forall {R1: restrict A1 S C1}
  {M: member S N}
  {F1: fresh A1 N}
  {UA: update A1 N D A}
  {UC: update C1 N D C}
  {R2: restrict C T E}
  {I: intersection S T V}
  {M?: member? T N B}
 exists {R3: restrict A V E}
 true.

- : restrict-associates-intersection*/L
 A1|S=C1 S->N FA1 UA UC C|T=E I (member?/out T-/>N)
 (restrict/out A1|V=E V-/>N FA1 UA)
    <- restrict-preserves-fresh FA1 A1|S=C1 FC1
    <- restrict/out-inversion C|T=E T-/>N FC1 UC C1|T=E
    <- restrict-associates-intersection* A1|S=C1 C1|T=E I A1|V=E
    <- intersection-left-preserves-not-member T-/>N I V-/>N.

- : restrict-associates-intersection*/L
 A1|S=C1 S->N FA1 UA UC C|T=E I (member?/in T->N)
 (restrict/in A1|V=E1 V->N FA1 UA UE)
    <- restrict-preserves-fresh FA1 A1|S=C1 FC1
    <- restrict/in-inversion C|T=E T->N FC1 UC _ C1|T=E1 UE
    <- restrict-associates-intersection* A1|S=C1 C1|T=E1 I A1|V=E1
    <- intersection-preserves-member S->N T->N I V->N.

- : restrict-associates-intersection*
 (restrict/in A1|S=C1 S->N FA1 UA UC) C|T=E I R
    <- member?-total M?
    <- restrict-associates-intersection*/L A1|S=C1 S->N FA1 UA UC C|T=E I M? R.

%worlds () (restrict-associates-intersection* _ _ _ _)
    (restrict-associates-intersection*/L _ _ _ _ _ _ _ _ _).
%total (R1 R2) (restrict-associates-intersection* R1 _ _ _)
        (restrict-associates-intersection*/L R2 _ _ _ _ _ _ _ _).


%theorem restrict-associates-intersection :
 forall* {A} {C} {E} {S} {T}
 forall {R1: restrict A S C}
  {R2: restrict C T E}
 exists {V} {I: intersection S T V}
  {R3: restrict A V E}
 true.

- : restrict-associates-intersection R1 R2 _ I R3
    <- intersection-total I
    <- restrict-associates-intersection* R1 R2 I R3.

%worlds () (restrict-associates-intersection _ _ _ _ _).
%total { } (restrict-associates-intersection _ _ _ _ _).


%theorem restrict-associates-intersection-converse* :
 forall* {A} {E} {S} {T} {V} {C}
 forall {R3: restrict A V E}
  {I: intersection S T V}
  {R1: restrict A S C}
 exists {R2: restrict C T E}
 true.

- : restrict-associates-intersection-converse* R3 I R1 R2
    <- restrict-total R2P
    <- restrict-associates-intersection* R1 R2P I R3P
    <- restrict-unique R3P R3 eq/ set`eq/ NEQ
    <- restrict-respects-eq R2P eq/ set`eq/ NEQ R2.

%worlds () (restrict-associates-intersection-converse* _ _ _ _).
%total { } (restrict-associates-intersection-converse* _ _ _ _).


%theorem restrict-associates-intersection-converse :
 forall* {A} {E} {S} {T} {V}
 forall {R3: restrict A V E}
  {I: intersection S T V}
 exists {C}
  {R1: restrict A S C}
  {R2: restrict C T E}
 true.

- : restrict-associates-intersection-converse R3 I _ R1 R2
    <- restrict-total R1
    <- restrict-associates-intersection-converse* R3 I R1 R2.

%worlds () (restrict-associates-intersection-converse _ _ _ _ _).
%total { } (restrict-associates-intersection-converse _ _ _ _ _).


%theorem empty-restriction:
 forall* {A}
 exists {R: restrict A set`0 map/0}
 true.

%theorem empty-restriction/L:
 forall* {A}
 forall {N} {Z: size A N}
 exists {R: restrict A set`0 map/0}
 true.

- : empty-restriction/L _ _ restrict/0.

- : empty-restriction/L _ ZP
 (restrict/out R set`not-member/0 F U)
    <- lookup-implies-fresh-update (lookup/= nat`eq/) _ F U
    <- fresh-update-increases-size-converse ZP F U Z
    <- empty-restriction/L _ Z R.

%worlds () (empty-restriction/L _ _ _).
%total (N) (empty-restriction/L N _ _).

- : empty-restriction R
    <- size-total Z
    <- empty-restriction/L _ Z R.

%worlds () (empty-restriction _).
%total { } (empty-restriction _).


%theorem fresh-implies-unit-restriction-empty:
 forall* {A} {N}
 forall {F: fresh A N}
 exists {R: restrict A (set/1 N) map/0}
 true.

%theorem fresh-implies-unit-restriction-empty/L:
 forall* {A} {N}
 forall {S} {PZ: size A S}
  {F: fresh A N}
 exists {R: restrict A (set/1 N) map/0}
 true.

- : fresh-implies-unit-restriction-empty/L z size/0 fresh/0 restrict/0.

- : fresh-implies-unit-restriction-empty/L _ Z FA
 (restrict/out R NM F U)
    <- lookup-implies-fresh-update (lookup/= nat`eq/) _ F U
    <- fresh-update-increases-size-converse Z F U ZP
    <- update-preserves-fresh-converse FA U FP
    <- fresh-implies-unit-restriction-empty/L _ ZP FP R
    <- fresh-lookup-not-equal FA (lookup/= nat`eq/) NE
    <- ne-implies-unit-map-not-member NE NM.

%worlds () (fresh-implies-unit-restriction-empty/L _ _ _ _).
%total (S) (fresh-implies-unit-restriction-empty/L S _ _ _).

- : fresh-implies-unit-restriction-empty F R
    <- size-total Z
    <- fresh-implies-unit-restriction-empty/L _ Z F R.

%worlds () (fresh-implies-unit-restriction-empty _ _).
%total { } (fresh-implies-unit-restriction-empty _ _).


%theorem lookup-implies-unit-restriction:
 forall* {A} {N} {D}
 forall {L: lookup A N D}
 exists {R: restrict A (set/1 N) (map/1 N D)}
 true.

- : lookup-implies-unit-restriction L
 (restrict/in A1|N=0 member/1 FA1 UA update/0)
    <- lookup-implies-fresh-update L _ FA1 UA
    <- fresh-implies-unit-restriction-empty FA1 A1|N=0.

%worlds () (lookup-implies-unit-restriction _ _).
%total { } (lookup-implies-unit-restriction _ _).


%theorem fresh-update-implies-restrict :
 forall* {A} {N} {D} {B}
 forall {F: fresh A N}
  {U: update A N D B}
 exists {R: restrict B (set/1 N) (map/+ N D map/0)}
 true.

- : fresh-update-implies-restrict A-/>N U
 (restrict/in R member/1 A-/>N U update/0)
    <- fresh-implies-unit-restriction-empty A-/>N R.

%worlds () (fresh-update-implies-restrict _ _ _).
%total { } (fresh-update-implies-restrict _ _ _).


%theorem restrict-idempotent :
 forall* {A} {B} {C}
 forall {R:restrict A B C}
 exists {R:restrict C B C}
 true.

- : restrict-idempotent A|B=C C|B=C
    <- restrict-total C|B=E
    <- intersection-idempotent B^B=B
    <- restrict-associates-intersection* A|B=C C|B=E B^B=B A|B=E
    <- restrict-unique A|B=E A|B=C eq/ set`eq/ E=C
    <- restrict-respects-eq C|B=E eq/ set`eq/ E=C C|B=C.

%worlds () (restrict-idempotent _ _).
%total { } (restrict-idempotent _ _).


%theorem restrict-implies-domain-leq* :
 forall* {A} {S} {C} {DC}
 forall {R:restrict A S C}
  {D: domain C DC}
 exists {L: set`leq DC S}
 true.

- : restrict-implies-domain-leq* restrict/0 domain/0 set`leq/0.

- : restrict-implies-domain-leq*
 (restrict/in R M F U UP) DC1 D1<=S
    <- domain-total DC
    <- restrict-implies-domain-leq* R DC D<=S
    <- update-commute-domain UP DC DC1 D+N=D1
    <- member-implies-add M S+N=S
    <- set`add-preserves-leq* D<=S D+N=D1 S+N=S D1<=S.

- : restrict-implies-domain-leq*
 (restrict/out R NM F U) DC D<=S
    <- restrict-implies-domain-leq* R DC D<=S.

%worlds () (restrict-implies-domain-leq* _ _ _).
%total (R) (restrict-implies-domain-leq* R _ _).


%theorem restrict-implies-domain-leq :
 forall* {A} {S} {C}
 forall {R:restrict A S C}
 exists {DC}
  {D: domain C DC}
  {L: set`leq DC S}
 true.

- : restrict-implies-domain-leq restrict/0 _ domain/0 set`leq/0.

- : restrict-implies-domain-leq
 (restrict/in R M F U UP) _ DC1 D1<=S
    <- restrict-implies-domain-leq R _ DC D<=S
    <- domain-total DC1
    <- update-commute-domain UP DC DC1 D+N=D1
    <- member-implies-add M S+N=S
    <- set`add-preserves-leq* D<=S D+N=D1 S+N=S D1<=S.

- : restrict-implies-domain-leq
 (restrict/out R NM F U) _ DC D<=S
    <- restrict-implies-domain-leq R _ DC D<=S.

%worlds () (restrict-implies-domain-leq _ _ _ _).
%total (R) (restrict-implies-domain-leq R _ _ _).


%theorem restrict-implies-domain-intersection* :
 forall* {A} {S} {C} {DC} {DA}
 forall {R: restrict A S C}
  {D1: domain A DA}
  {D2: domain C DC}
 exists {L: set`intersection DA S DC}
 true.

- : restrict-implies-domain-intersection*
 restrict/0 domain/0 domain/0 intersection/L.

- : restrict-implies-domain-intersection*
 (restrict/in R M F UA UC) DAP DCP DAP^S=DCP
    <- domain-total DA
    <- domain-total DC
    <- restrict-implies-domain-intersection*
 R DA DC DA^S=DC
    <- update-commute-domain UA DA DAP DA+N=DAP
    <- update-commute-domain UC DC DCP DC+N=DCP
    <- add-implies-unit-union DA+N=DAP DAUN=DAP
    <- add-implies-unit-union DC+N=DCP DCUN=DCP
    <- set`member-implies-unit-leq M N<=S
    <- leq-implies-intersection N<=S N^S=N
    <- intersection-right-factors-over-union*
 DA^S=DC N^S=N
  DCUN=DCP DAUN=DAP
 DAP^S=DCP.

- : restrict-implies-domain-intersection*
 (restrict/out R NM F U) DAP DC DAP^S=DC
    <- domain-total DA
    <- restrict-implies-domain-intersection* R DA DC DA^S=DC
    <- update-commute-domain U DA DAP DA+N=DAP
    <- add-implies-unit-union DA+N=DAP DAUN=DAP
    <- set`not-member-implies-unit-disjoint NM S^N
    <- set`disjoint-symmetric S^N N^S
    <- disjoint-intersection-empty N^S N^S=0
    <- intersection-right-factors-over-union*
 DA^S=DC N^S=0
  union/R DAUN=DAP
 DAP^S=DC.

%worlds () (restrict-implies-domain-intersection* _ _ _ _).
%total (R) (restrict-implies-domain-intersection* R _ _ _).


%theorem domain-leq-implies-no-restriction:
 forall* {A} {S} {D}
 forall {X: domain A D}
  {L: set`leq D S}
 exists {R: restrict A S A}
 true.

%theorem domain-leq-implies-no-restriction/L:
 forall* {A} {S} {D}
 forall {N}
  {Z: size A N}
  {X: domain A D}
  {L: set`leq D S}
 exists {R: restrict A S A}
 true.

- : domain-leq-implies-no-restriction/L nat`z size/0 domain/0 _ restrict/0.

- : domain-leq-implies-no-restriction/L (s _) Z DA (DA<=S :set`leq DAX S)
 (restrict/in R1 M F U U)
    <- lookup-implies-fresh-update (lookup/= nat`eq/) _ F U
    <- domain-preserves-lookup (lookup/= nat`eq/) DA MA
    <- set`member-respects-leq MA DA<=S M
    <- fresh-update-increases-size-converse Z F U Z1
    <- domain-total DA1
    <- update-commute-domain U DA1 DA DA1+N=DA
    <- set`add-implies-leq DA1+N=DA DA1<=DA
    <- set`leq-transitive DA1<=DA DA<=S DA1<=S
    <- domain-leq-implies-no-restriction/L _ Z1 DA1 DA1<=S R1.

%worlds () (domain-leq-implies-no-restriction/L _ _ _ _ _).
%total (N) (domain-leq-implies-no-restriction/L N _ _ _ _).

- : domain-leq-implies-no-restriction DA DA<=S R
    <- size-total Z
    <- domain-leq-implies-no-restriction/L _ Z DA DA<=S R.

%worlds () (domain-leq-implies-no-restriction _ _ _).
%total { } (domain-leq-implies-no-restriction _ _ _).


%theorem domain-disjoint-implies-restrict-empty:
 forall* {A} {S} {D}
 forall {X: domain A D}
  {L: set`disjoint D S}
 exists {R: restrict A S map/0}
 true.

%theorem domain-disjoint-implies-restrict-empty/L:
 forall* {A} {S} {D}
 forall {N}
  {Z: size A N}
  {X: domain A D}
  {L: set`disjoint D S}
 exists {R: restrict A S map/0}
 true.

- : domain-disjoint-implies-restrict-empty/L nat`z _ domain/0 _ restrict/0.

- : domain-disjoint-implies-restrict-empty/L (s _) Z DA (DA^S :set`disjoint DAX S)
 (restrict/out R1 NM F U)
    <- lookup-implies-fresh-update (lookup/= nat`eq/) _ F U
    <- domain-preserves-lookup (lookup/= nat`eq/) DA MA
    <- disjoint-member-implies-not-member MA DA^S NM
    <- fresh-update-increases-size-converse Z F U Z1
    <- domain-total DA1
    <- update-commute-domain U DA1 DA DA1+N=DA
    <- set`add-implies-leq DA1+N=DA DA1<=DA
    <- set`disjoint-respects-geq* DA^S DA1<=DA DA1^S
    <- domain-disjoint-implies-restrict-empty/L _ Z1 DA1 DA1^S R1.

%worlds () (domain-disjoint-implies-restrict-empty/L _ _ _ _ _).
%total (N) (domain-disjoint-implies-restrict-empty/L N _ _ _ _).

- : domain-disjoint-implies-restrict-empty DA DJ R
    <- size-total Z
    <- domain-disjoint-implies-restrict-empty/L _ Z DA DJ R.

%worlds () (domain-disjoint-implies-restrict-empty _ _ _).
%total { } (domain-disjoint-implies-restrict-empty _ _ _).



%theorem restrict-implies-leq :
 forall* {S1} {S2} {S3}
 forall {D:restrict S1 S2 S3}
 exists {L:leq S3 S1}
 true.

- : restrict-implies-leq restrict/0 leq/0.

- : restrict-implies-leq (restrict/out R _ F U) C<=A
    <- restrict-implies-leq R C<=A1
    <- fresh-update-implies-leq F U A1<=A
    <- leq-transitive C<=A1 A1<=A C<=A.

- : restrict-implies-leq (restrict/in R _ F U UP) C<=A
    <- restrict-implies-leq R C1<=A1
    <- update-left-preserves-leq* C1<=A1 UP U C<=A.

%worlds () (restrict-implies-leq _ _).
%total (R) (restrict-implies-leq R _).


%theorem restrict-right-preserves-leq :
 forall* {A} {B} {C} {D} {E}
 forall {L: leq A D}
  {R: restrict A B C}
  {RP: restrict D B E}
 exists {LP: leq C E}
 true.

- : restrict-right-preserves-leq leq/0 restrict/0 _ leq/0.

- : restrict-right-preserves-leq A<=D
 (restrict/out A1|B=C B-/>N FA1 UA) D|B=E C<=E
    <- update-implies-lookup UA LA
    <- lookup-respects-leq LA A<=D _ LD _
    <- lookup-implies-fresh-update LD _ FD1 UD
    <- restrict/out-inversion D|B=E B-/>N FD1 UD D1|B=E
    <- fresh-update-preserves-leq-converse A<=D FA1 UA FD1 UD A1<=D1 _
    <- restrict-right-preserves-leq A1<=D1 A1|B=C D1|B=E C<=E.

- : restrict-right-preserves-leq A<=D
 (restrict/in A1|B=C1 B->N FA1 UA UC) D|B=E C<=E
    <- update-implies-lookup UA LA
    <- lookup-respects-leq LA A<=D _ LD _
    <- lookup-implies-fresh-update LD _ FD1 UD
    <- restrict/in-inversion D|B=E B->N FD1 UD _ D1|B=E1 UE
    <- fresh-update-preserves-leq-converse A<=D FA1 UA FD1 UD A1<=D1 LE
    <- restrict-right-preserves-leq A1<=D1 A1|B=C1 D1|B=E1 C1<=E1
    <- update-preserves-leq* C1<=E1 LE UC UE C<=E.

%worlds () (restrict-right-preserves-leq _ _ _ _).
%total (R) (restrict-right-preserves-leq _ R _ _).


%theorem restrict-left-preserves-leq :
        forall* {A} {B} {C} {D} {E}
        forall {L: set`leq B D}
                {R1: restrict A B C}
                {R2: restrict A D E}
        exists {LP: leq C E}
        true.

- : restrict-left-preserves-leq S<=T A|S=C A|T=E C<=E
    <- restrict-total E|S=G
    <- leq-implies-intersection S<=T S^T=S
    <- intersection-commutative S^T=S T^S=S
    <- restrict-associates-intersection* A|T=E E|S=G T^S=S A|S=G
    <- restrict-unique A|S=G A|S=C eq/ set`eq/ G=C
    <- restrict-respects-eq E|S=G eq/ set`eq/ G=C E|S=C
    <- restrict-implies-leq E|S=C C<=E.

%worlds () (restrict-left-preserves-leq _ _ _ _).
%total { } (restrict-left-preserves-leq _ _ _ _).



%theorem restrict-characterization:
 forall* {A} {B} {C} {DB} {DC} {S}
 forall {J1: join C B A}
  {D2: domain C DC}
  {L3: set`leq DC S}
  {D4: domain B DB}
  {D5: set`disjoint DB S}
 exists {R: restrict A S C}
 true.

%theorem restrict-characterization/L:
 forall* {A} {B} {C} {DB} {DC} {S}
 forall {N}
  {Z: size A N}
  {J1: join C B A}
  {D2: domain C DC}
  {L3: set`leq DC S}
  {D4: domain B DB}
  {D5: set`disjoint DB S}
 exists {R: restrict A S C}
 true.

- : restrict-characterization/L _ _ join/L _ _ D D^S R
    <- domain-disjoint-implies-restrict-empty D D^S R.

- : restrict-characterization/L _ _ join/R D D<=S _ _ R
    <- domain-leq-implies-no-restriction D D<=S R.

- : restrict-characterization/L (s _) _ (join/= _ _ nat`eq/) DC DC<=S DB DB^S R
    <- domain-preserves-lookup (lookup/= nat`eq/) DC DC->N
    <- domain-preserves-lookup (lookup/= nat`eq/) DB DB->N
    <- set`disjoint-symmetric DB^S S^DB
    <- set`disjoint-respects-geq* S^DB DC<=S DC^DB
    <- set`disjoint-member-contradiction DC^DB DC->N DB->N F
    <- false-implies-restrict F R.

- : restrict-characterization/L (s _) ZP (join/< J1 P) DC DC<=S DB DB^S
 (restrict/in A1|S=C1 S->N FA1 UA UC)
    <- domain-preserves-lookup (lookup/= nat`eq/) DC DC->N
    <- member-respects-leq DC->N DC<=S S->N
    <- shift-total SHA
    <- shift-total SHC
    <- shift-implies-fresh SHA FA1
    <- shift-implies-fresh SHC FC1
    <- shift-implies-update SHA UA
    <- shift-implies-update SHC UC
    <- fresh-update-increases-size-converse ZP FA1 UA Z
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- shift-preserves-join* J1 SHC (shift/+ Psc) SHA J
    <- domain-total DC1
    <- update-commute-domain UC DC1 DC DC1+N=DC
    <- set`add-implies-leq DC1+N=DC DC1<=DC
    <- set`leq-transitive DC1<=DC DC<=S DC1<=S
    <- restrict-characterization/L _ Z J DC1 DC1<=S DB DB^S A1|S=C1.

- : restrict-characterization/L (s _) ZP (join/> J1 P) DC DC<=S DB DB^S
 (restrict/out A1|S=C S-/>N FA1 UA)
    <- domain-preserves-lookup (lookup/= nat`eq/) DB DB->N
    <- disjoint-member-implies-not-member DB->N DB^S S-/>N
    <- shift-total SHA
    <- shift-total SHB
    <- shift-implies-fresh SHA FA1
    <- shift-implies-update SHA UA
    <- shift-implies-update SHB UB
    <- fresh-update-increases-size-converse ZP FA1 UA Z
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- shift-preserves-join* J1 (shift/+ Psc) SHB SHA J
    <- domain-total DB1
    <- update-commute-domain UB DB1 DB DB1+N=DB
    <- set`add-implies-leq DB1+N=DB DB1<=DB
    <- set`disjoint-respects-geq* DB^S DB1<=DB DB1^S
    <- restrict-characterization/L _ Z J DC DC<=S DB1 DB1^S A1|S=C.

%worlds () (restrict-characterization/L _ _ _ _ _ _ _ _).
%total (N) (restrict-characterization/L N _ _ _ _ _ _ _).

- : restrict-characterization CUB=A DC DC<=S DB DB^S R
    <- size-total Z
    <- restrict-characterization/L _ Z CUB=A DC DC<=S DB DB^S R.

%worlds () (restrict-characterization _ _ _ _ _ _).
%total { } (restrict-characterization _ _ _ _ _ _).


%%% Renamings

%abbrev efxmap = map.
%abbrev efxmap/0 = map/0.
%abbrev efxmap/+ = map/+.
%abbrev efxmap`map = map.
%abbrev efxmap`map/0 = map/0.
%abbrev efxmap`map/+ = map/+.
%abbrev efxmap`map/1 = map/1.
%abbrev efxmap`eq? = eq?.
%abbrev efxmap`eq = eq.
%abbrev efxmap`ne = ne.
%abbrev efxmap`eq?/yes = eq?/yes.
%abbrev efxmap`eq/ = eq/.
%abbrev efxmap`eq?/no = eq?/no.
%abbrev efxmap`lookup = lookup.
%abbrev efxmap`lookup/= = lookup/=.
%abbrev efxmap`lookup/> = lookup/>.
%abbrev efxmap`fresh = fresh.
%abbrev efxmap`fresh/0 = fresh/0.
%abbrev efxmap`fresh/< = fresh/<.
%abbrev efxmap`fresh/> = fresh/>.
%abbrev efxmap`ne/< = ne/<.
%abbrev efxmap`ne/> = ne/>.
%abbrev efxmap`domain? = domain?.
%abbrev efxmap`domain?/in = domain?/in.
%abbrev efxmap`domain?/out = domain?/out.
%abbrev efxmap`disjoint = disjoint.
%abbrev efxmap`disjoint/L = disjoint/L.
%abbrev efxmap`disjoint/R = disjoint/R.
%abbrev efxmap`disjoint/< = disjoint/<.
%abbrev efxmap`disjoint/> = disjoint/>.
%abbrev efxmap`disjoint? = disjoint?.
%abbrev efxmap`disjoint?/yes = disjoint?/yes.
%abbrev efxmap`disjoint?/no = disjoint?/no.
%abbrev efxmap`size = size.
%abbrev efxmap`size/0 = size/0.
%abbrev efxmap`size/+ = size/+.
%abbrev efxmap`bound = bound.
%abbrev efxmap`bound/0 = bound/0.
%abbrev efxmap`bound/+ = bound/+.
%abbrev efxmap`shift = shift.
%abbrev efxmap`shift/0 = shift/0.
%abbrev efxmap`shift/+ = shift/+.
%abbrev efxmap`update = update.
%abbrev efxmap`update/0 = update/0.
%abbrev efxmap`update/= = update/=.
%abbrev efxmap`update/< = update/<.
%abbrev efxmap`update/> = update/>.
%abbrev efxmap`meta-eq = meta-eq.
%abbrev efxmap`false-implies-eq? = false-implies-eq?.
%abbrev efxmap`false-implies-eq = false-implies-eq.
%abbrev efxmap`false-implies-ne = false-implies-ne.
%abbrev efxmap`eq-reflexive = eq-reflexive.
%abbrev efxmap`eq?-symmetric = eq?-symmetric.
%abbrev efxmap`eq-symmetric = eq-symmetric.
%abbrev efxmap`ne-symmetric = ne-symmetric.
%abbrev efxmap`eq-transitive = eq-transitive.
%abbrev efxmap`map/+-preserves-eq? = map/+-preserves-eq?.
%abbrev efxmap`map/+-preserves-eq = map/+-preserves-eq.
%abbrev efxmap`map/+-preserves-ne = map/+-preserves-ne.
%abbrev efxmap`map/+-preserves-eq-converse = map/+-preserves-eq-converse.
%abbrev efxmap`eq-no-occur = eq-no-occur.
%abbrev efxmap`eq-contradiction = eq-contradiction.
%abbrev efxmap`false-implies-lookup = false-implies-lookup.
%abbrev efxmap`lookup-respects-eq = lookup-respects-eq.
%abbrev efxmap`meta-reduces-lookup = meta-reduces-lookup.
%abbrev efxmap`lookup/>-inversion = lookup/>-inversion.
%abbrev efxmap`lookup-deterministic = lookup-deterministic.
%abbrev efxmap`lookup-unique = lookup-unique.
%abbrev efxmap`lookup-contradiction = lookup-contradiction.
%abbrev efxmap`lookup-one-choice = lookup-one-choice.
%abbrev efxmap`lookup-implies-ge = lookup-implies-ge.
%abbrev efxmap`false-implies-fresh = false-implies-fresh.
%abbrev efxmap`fresh-respects-eq = fresh-respects-eq.
%abbrev efxmap`fresh/>-inversion = fresh/>-inversion.
%abbrev efxmap`fresh-total* = fresh-total*.
%abbrev efxmap`fresh-total = fresh-total.
%abbrev efxmap`fresh-lookup-not-equal = fresh-lookup-not-equal.
%abbrev efxmap`fresh-contradiction = fresh-contradiction.
%abbrev efxmap`ne-implies-unit-map-fresh = ne-implies-unit-map-fresh.
%abbrev efxmap`plus-right-preserves-fresh* = plus-right-preserves-fresh*.
%abbrev efxmap`fresh-lookup-implies-ne = fresh-lookup-implies-ne.
%abbrev efxmap`eq?-respects-eq = eq?-respects-eq.
%abbrev efxmap`ne-respects-eq = ne-respects-eq.
%abbrev efxmap`ne-anti-reflexive = ne-anti-reflexive.
%abbrev efxmap`eq-ne-implies-false = eq-ne-implies-false.
%abbrev efxmap`false-implies-domain? = false-implies-domain?.
%abbrev efxmap`domain?-respects-eq = domain?-respects-eq.
%abbrev efxmap`domain?-deterministic = domain?-deterministic.
%abbrev efxmap`domain?-unique = domain?-unique.
%abbrev efxmap`domain?-total* = domain?-total*.
%abbrev efxmap`domain?-map/+-total = domain?-map/+-total.
%abbrev efxmap`domain?-map/+-complete = domain?-map/+-complete.
%abbrev efxmap`domain?-total = domain?-total.
%abbrev efxmap`in-implies-lookup = in-implies-lookup.
%abbrev efxmap`out-implies-fresh = out-implies-fresh.
%abbrev efxmap`false-implies-disjoint = false-implies-disjoint.
%abbrev efxmap`disjoint-respects-eq = disjoint-respects-eq.
%abbrev efxmap`disjoint/=-contradiction = disjoint/=-contradiction.
%abbrev efxmap`disjoint/<-inversion = disjoint/<-inversion.
%abbrev efxmap`disjoint/>-inversion = disjoint/>-inversion.
%abbrev efxmap`disjoint-anti-reflexive = disjoint-anti-reflexive.
%abbrev efxmap`disjoint-symmetric = disjoint-symmetric.
%abbrev efxmap`disjoint-lookup-contradiction = disjoint-lookup-contradiction.
%abbrev efxmap`disjoint-lookup-implies-fresh = disjoint-lookup-implies-fresh.
%abbrev efxmap`disjoint-lookup-implies-fresh/L = disjoint-lookup-implies-fresh/L.
%abbrev efxmap`shift-left-preserves-disjoint = shift-left-preserves-disjoint.
%abbrev efxmap`shift-left-preserves-disjoint-converse = shift-left-preserves-disjoint-converse.
%abbrev efxmap`shift-right-preserves-disjoint = shift-right-preserves-disjoint.
%abbrev efxmap`shift-right-preserves-disjoint-converse = shift-right-preserves-disjoint-converse.
%abbrev efxmap`shift-preserves-disjoint = shift-preserves-disjoint.
%abbrev efxmap`shift-preserves-disjoint-converse = shift-preserves-disjoint-converse.
%abbrev efxmap`can-construct-unit-disjoint = can-construct-unit-disjoint.
%abbrev efxmap`ne-implies-disjoint = ne-implies-disjoint.
%abbrev efxmap`fresh-implies-unit-disjoint = fresh-implies-unit-disjoint.
%abbrev efxmap`false-implies-size = false-implies-size.
%abbrev efxmap`size-total* = size-total*.
%abbrev efxmap`size-total = size-total.
%abbrev efxmap`size-respects-eq = size-respects-eq.
%abbrev efxmap`size-deterministic = size-deterministic.
%abbrev efxmap`size-unique = size-unique.
%abbrev efxmap`shift-preserves-size = shift-preserves-size.
%abbrev efxmap`shift-preserves-size-converse = shift-preserves-size-converse.
%abbrev efxmap`false-implies-bound = false-implies-bound.
%abbrev efxmap`bound-respects-eq = bound-respects-eq.
%abbrev efxmap`bound-unique = bound-unique.
%abbrev efxmap`bound-deterministic = bound-deterministic.
%abbrev efxmap`bound-total* = bound-total*.
%abbrev efxmap`bound-total = bound-total.
%abbrev efxmap`bound-lookup-implies-gt = bound-lookup-implies-gt.
%abbrev efxmap`ge-bound-implies-fresh = ge-bound-implies-fresh.
%abbrev efxmap`false-implies-shift = false-implies-shift.
%abbrev efxmap`shift-respects-eq = shift-respects-eq.
%abbrev efxmap`shift-total* = shift-total*.
%abbrev efxmap`shift-total = shift-total.
%abbrev efxmap`shift-deterministic = shift-deterministic.
%abbrev efxmap`shift-unique = shift-unique.
%abbrev efxmap`shift-cancels = shift-cancels.
%abbrev efxmap`shifts-add = shifts-add.
%abbrev efxmap`shifts-add-converse = shifts-add-converse.
%abbrev efxmap`shift-preserves-fresh = shift-preserves-fresh.
%abbrev efxmap`shift-preserves-fresh* = shift-preserves-fresh*.
%abbrev efxmap`shift-preserves-fresh-converse* = shift-preserves-fresh-converse*.
%abbrev efxmap`shift-preserves-lookup = shift-preserves-lookup.
%abbrev efxmap`shift-preserves-lookup* = shift-preserves-lookup*.
%abbrev efxmap`shift-preserves-lookup-converse = shift-preserves-lookup-converse.
%abbrev efxmap`shift-preserves-lookup-converse* = shift-preserves-lookup-converse*.
%abbrev efxmap`shift-implies-fresh* = shift-implies-fresh*.
%abbrev efxmap`shift-implies-fresh = shift-implies-fresh.
%abbrev efxmap`removal-preserves-fresh = removal-preserves-fresh.
%abbrev efxmap`shift-preserves-size = shift-preserves-size.
%abbrev efxmap`disjoint?-total* = disjoint?-total*.
%abbrev efxmap`disjoint?-total*/+ = disjoint?-total*/+.
%abbrev efxmap`disjoint?-total*/< = disjoint?-total*/<.
%abbrev efxmap`disjoint?-total*/> = disjoint?-total*/>.
%abbrev efxmap`disjoint?-total = disjoint?-total.
%abbrev efxmap`false-implies-update = false-implies-update.
%abbrev efxmap`update-respects-eq = update-respects-eq.
%abbrev efxmap`meta-reduces-update = meta-reduces-update.
%abbrev efxmap`update/=-inversion = update/=-inversion.
%abbrev efxmap`update/<-inversion = update/<-inversion.
%abbrev efxmap`update/>-inversion = update/>-inversion.
%abbrev efxmap`update-contradiction = update-contradiction.
%abbrev efxmap`update-deterministic = update-deterministic.
%abbrev efxmap`update-unique = update-unique.
%abbrev efxmap`update-total* = update-total*.
%abbrev efxmap`update-map/+-total = update-map/+-total.
%abbrev efxmap`update-total = update-total.
%abbrev efxmap`lookup-implies-update = lookup-implies-update.
%abbrev efxmap`lookup-implies-fresh-update = lookup-implies-fresh-update.
%abbrev efxmap`update-implies-lookup = update-implies-lookup.
%abbrev efxmap`update-preserves-lookup = update-preserves-lookup.
%abbrev efxmap`update-preserves-lookup-converse = update-preserves-lookup-converse.
%abbrev efxmap`update-preserves-fresh = update-preserves-fresh.
%abbrev efxmap`update-preserves-fresh-converse = update-preserves-fresh-converse.
%abbrev efxmap`update-preserves-fresh-converse-helper = update-preserves-fresh-converse-helper.
%abbrev efxmap`update-is-cause-of-change = update-is-cause-of-change.
%abbrev efxmap`update-is-cause-of-change/L = update-is-cause-of-change/L.
%abbrev efxmap`update-preserves-membership = update-preserves-membership.
%abbrev efxmap`update-preserves-membership-converse = update-preserves-membership-converse.
%abbrev efxmap`lookup-update-preserves-membership = lookup-update-preserves-membership.
%abbrev efxmap`lookup-update-preserves-membership/L = lookup-update-preserves-membership/L.
%abbrev efxmap`lookup-update-preserves-membership-converse = lookup-update-preserves-membership-converse.
%abbrev efxmap`update-preserves-in-domain = update-preserves-in-domain.
%abbrev efxmap`update-preserves-in-domain/L = update-preserves-in-domain/L.
%abbrev efxmap`shift-preserves-update = shift-preserves-update.
%abbrev efxmap`shift-preserves-update* = shift-preserves-update*.
%abbrev efxmap`shift-preserves-update-converse = shift-preserves-update-converse.
%abbrev efxmap`shift-preserves-update-converse* = shift-preserves-update-converse*.
%abbrev efxmap`update-commutes-shift-converse = update-commutes-shift-converse.
%abbrev efxmap`fresh-update-preserves-lookup = fresh-update-preserves-lookup.
%abbrev efxmap`fresh-update-increases-size = fresh-update-increases-size.
%abbrev efxmap`fresh-update-increases-size-converse = fresh-update-increases-size-converse.
%abbrev efxmap`fresh-update-preserves-disjoint = fresh-update-preserves-disjoint.
%abbrev efxmap`fresh-update-preserves-disjoint/L = fresh-update-preserves-disjoint/L.
%abbrev efxmap`update-overwrites = update-overwrites.
%abbrev efxmap`update-overwrites-converse = update-overwrites-converse.
%abbrev efxmap`update-may-have-no-effect = update-may-have-no-effect.
%abbrev efxmap`update-idempotent = update-idempotent.
%abbrev efxmap`update-commutes = update-commutes.
%abbrev efxmap`update-commutes* = update-commutes*.
%abbrev efxmap`fresh-update-cancels = fresh-update-cancels.
%abbrev efxmap`update-commutes-converse = update-commutes-converse.
%abbrev efxmap`update-commutes-converse/L = update-commutes-converse/L.
%abbrev efxmap`can-remove = can-remove.
%abbrev efxmap`can-remove* = can-remove*.
%abbrev efxmap`shift-implies-update = shift-implies-update.
%abbrev efxmap`fresh-update-implies-shift = fresh-update-implies-shift.
%abbrev efxmap`leq? = leq?.
%abbrev efxmap`leq = leq.
%abbrev efxmap`nle = nle.
%abbrev efxmap`leq/0 = leq/0.
%abbrev efxmap`leq/= = leq/=.
%abbrev efxmap`leq/> = leq/>.
%abbrev efxmap`nle/< = nle/<.
%abbrev efxmap`leq?/yes = leq?/yes.
%abbrev efxmap`leq?/no = leq?/no.
%abbrev efxmap`false-implies-leq? = false-implies-leq?.
%abbrev efxmap`false-implies-leq = false-implies-leq.
%abbrev efxmap`false-implies-nle = false-implies-nle.
%abbrev efxmap`leq?-respects-eq = leq?-respects-eq.
%abbrev efxmap`leq-respects-eq = leq-respects-eq.
%abbrev efxmap`nle-respects-eq = nle-respects-eq.
%abbrev efxmap`leq/0-inversion = leq/0-inversion.
%abbrev efxmap`leq/=-inversion = leq/=-inversion.
%abbrev efxmap`leq/>-inversion = leq/>-inversion.
%abbrev efxmap`leq-contradiction = leq-contradiction.
%abbrev efxmap`leq/<-contradiction = leq/<-contradiction.
%abbrev efxmap`leq-reflexive = leq-reflexive.
%abbrev efxmap`leq-anti-symmetric = leq-anti-symmetric.
%abbrev efxmap`leq-transitive = leq-transitive.
%abbrev efxmap`map/+-preserves-leq? = map/+-preserves-leq?.
%abbrev efxmap`map/+-preserves-leq = map/+-preserves-leq.
%abbrev efxmap`map/+-preserves-nle = map/+-preserves-nle.
%abbrev efxmap`lookup-respects-leq = lookup-respects-leq.
%abbrev efxmap`lookup-respects-leq* = lookup-respects-leq*.
%abbrev efxmap`lookup-implies-unit-leq = lookup-implies-unit-leq.
%abbrev efxmap`fresh-respects-geq = fresh-respects-geq.
%abbrev efxmap`leq-implies-size-le = leq-implies-size-le.
%abbrev efxmap`leq-implies-bound-le = leq-implies-bound-le.
%abbrev efxmap`shift-left-preserves-leq* = shift-left-preserves-leq*.
%abbrev efxmap`shift-preserves-leq* = shift-preserves-leq*.
%abbrev efxmap`shift-preserves-leq = shift-preserves-leq.
%abbrev efxmap`shift-preserves-leq-converse = shift-preserves-leq-converse.
%abbrev efxmap`disjoint-respects-geq* = disjoint-respects-geq*.
%abbrev efxmap`disjoint-respects-geq = disjoint-respects-geq.
%abbrev efxmap`disjoint-leq-implies-empty = disjoint-leq-implies-empty.
%abbrev efxmap`update-left-preserves-leq* = update-left-preserves-leq*.
%abbrev efxmap`update-right-preserves-leq* = update-right-preserves-leq*.
%abbrev efxmap`update-preserves-leq* = update-preserves-leq*.
%abbrev efxmap`fresh-update-preserves-leq-converse = fresh-update-preserves-leq-converse.
%abbrev efxmap`fresh-update-preserves-leq-converse/> = fresh-update-preserves-leq-converse/>.
%abbrev efxmap`fresh-update-implies-leq = fresh-update-implies-leq.
%abbrev efxmap`lookup-update-preserves-leq = lookup-update-preserves-leq.
%abbrev efxmap`fresh-update-right-preserves-leq-converse = fresh-update-right-preserves-leq-converse.
%abbrev efxmap`nle-anti-reflexive = nle-anti-reflexive.
%abbrev efxmap`nle-implies-ne = nle-implies-ne.
%abbrev efxmap`leq-nle-contradiction = leq-nle-contradiction.
%abbrev efxmap`domain = domain.
%abbrev efxmap`domain/0 = domain/0.
%abbrev efxmap`domain/+ = domain/+.
%abbrev efxmap`domain/1 = domain/1.
%abbrev efxmap`false-implies-domain = false-implies-domain.
%abbrev efxmap`domain-respects-eq = domain-respects-eq.
%abbrev efxmap`domain-deterministic = domain-deterministic.
%abbrev efxmap`domain-unique = domain-unique.
%abbrev efxmap`domain-total* = domain-total*.
%abbrev efxmap`domain-total = domain-total.
%abbrev efxmap`domain-empty-implies-empty = domain-empty-implies-empty.
%abbrev efxmap`domain-preserves-lookup = domain-preserves-lookup.
%abbrev efxmap`domain-preserves-lookup-converse = domain-preserves-lookup-converse.
%abbrev efxmap`domain-preserves-fresh = domain-preserves-fresh.
%abbrev efxmap`domain-preserves-fresh-converse = domain-preserves-fresh-converse.
%abbrev efxmap`domain-preserves-domain? = domain-preserves-domain?.
%abbrev efxmap`domain-preserves-domain?-converse = domain-preserves-domain?-converse.
%abbrev efxmap`domain-preserves-size = domain-preserves-size.
%abbrev efxmap`domain-preserves-size-converse = domain-preserves-size-converse.
%abbrev efxmap`domain-preserves-disjoint = domain-preserves-disjoint.
%abbrev efxmap`domain-preserves-disjoint-converse = domain-preserves-disjoint-converse.
%abbrev efxmap`domain-preserves-bound = domain-preserves-bound.
%abbrev efxmap`domain-preserves-bound-converse = domain-preserves-bound-converse.
%abbrev efxmap`shift-preserves-domain* = shift-preserves-domain*.
%abbrev efxmap`shift-preserves-domain = shift-preserves-domain.
%abbrev efxmap`shift-preserves-domain-converse = shift-preserves-domain-converse.
%abbrev efxmap`shift-preserves-domain-converse* = shift-preserves-domain-converse*.
%abbrev efxmap`domain-commute-shift = domain-commute-shift.
%abbrev efxmap`shift-commute-domain = shift-commute-domain.
%abbrev efxmap`update-commute-domain = update-commute-domain.
%abbrev efxmap`domain-commute-update = domain-commute-update.
%abbrev efxmap`domain-preserves-leq* = domain-preserves-leq*.
%abbrev efxmap`domain-preserves-leq = domain-preserves-leq.
%abbrev efxmap`join = join.
%abbrev efxmap`join/L = join/L.
%abbrev efxmap`join/R = join/R.
%abbrev efxmap`join/= = join/=.
%abbrev efxmap`join/< = join/<.
%abbrev efxmap`join/> = join/>.
%abbrev efxmap`false-implies-join = false-implies-join.
%abbrev efxmap`join-respects-eq = join-respects-eq.
%abbrev efxmap`can-construct-unit-join = can-construct-unit-join.
%abbrev efxmap`join/=-inversion = join/=-inversion.
%abbrev efxmap`join/<-inversion = join/<-inversion.
%abbrev efxmap`join/>-inversion = join/>-inversion.
%abbrev efxmap`join-deterministic = join-deterministic.
%abbrev efxmap`join-unique = join-unique.
%abbrev efxmap`disjoint-join-total = disjoint-join-total.
%abbrev efxmap`disjoint-join-commutative = disjoint-join-commutative.
%abbrev efxmap`join-empty-implies-empty = join-empty-implies-empty.
%abbrev efxmap`join-preserves-disjoint* = join-preserves-disjoint*.
%abbrev efxmap`join-preserves-disjoint*/L = join-preserves-disjoint*/L.
%abbrev efxmap`join-left-preserves-disjoint* = join-left-preserves-disjoint*.
%abbrev efxmap`join-right-preserves-disjoint* = join-right-preserves-disjoint*.
%abbrev efxmap`join-preserves-disjoint-converse = join-preserves-disjoint-converse.
%abbrev efxmap`disjoint-join-right-cancels = disjoint-join-right-cancels.
%abbrev efxmap`disjoint-join-right-cancels/L = disjoint-join-right-cancels/L.
%abbrev efxmap`disjoint-join-left-cancels = disjoint-join-left-cancels.
%abbrev efxmap`shift-left-preserves-join = shift-left-preserves-join.
%abbrev efxmap`shift-left-preserves-join-converse = shift-left-preserves-join-converse.
%abbrev efxmap`shift-right-preserves-join = shift-right-preserves-join.
%abbrev efxmap`shift-right-preserves-join-converse = shift-right-preserves-join-converse.
%abbrev efxmap`shift-preserves-join* = shift-preserves-join*.
%abbrev efxmap`shift-preserves-join = shift-preserves-join.
%abbrev efxmap`shift-preserves-join-converse = shift-preserves-join-converse.
%abbrev efxmap`shift-preserves-join-converse* = shift-preserves-join-converse*.
%abbrev efxmap`shift-preserves-join-converse** = shift-preserves-join-converse**.
%abbrev efxmap`lookup-implies-join = lookup-implies-join.
%abbrev efxmap`join-joins-lookup = join-joins-lookup.
%abbrev efxmap`join-joins-lookup* = join-joins-lookup*.
%abbrev efxmap`join-preserves-fresh* = join-preserves-fresh*.
%abbrev efxmap`fresh-join-left-preserves-lookup* = fresh-join-left-preserves-lookup*.
%abbrev efxmap`fresh-join-left-preserves-lookup-converse = fresh-join-left-preserves-lookup-converse.
%abbrev efxmap`fresh-join-left-preserves-lookup-converse/L = fresh-join-left-preserves-lookup-converse/L.
%abbrev efxmap`join-left-affects-lookup = join-left-affects-lookup.
%abbrev efxmap`join-left-affects-lookup/L = join-left-affects-lookup/L.
%abbrev efxmap`disjoint-join-cross-comparable = disjoint-join-cross-comparable.
%abbrev efxmap`disjoint-join-left-preserves-lookup* = disjoint-join-left-preserves-lookup*.
%abbrev efxmap`disjoint-join-left-preserves-lookup*/L = disjoint-join-left-preserves-lookup*/L.
%abbrev efxmap`fresh-update-implies-unit-join = fresh-update-implies-unit-join.
%abbrev efxmap`fresh-unit-join-implies-update = fresh-unit-join-implies-update.
%abbrev efxmap`bound-commute-join* = bound-commute-join*.
%abbrev efxmap`join-implies-leq* = join-implies-leq*.
%abbrev efxmap`join-implies-leq = join-implies-leq.
%abbrev efxmap`disjoint-leq-implies-join-leq* = disjoint-leq-implies-join-leq*.
%abbrev efxmap`deep-disjoint = deep-disjoint.
%abbrev efxmap`deep-disjoint/L = deep-disjoint/L.
%abbrev efxmap`deep-disjoint/R = deep-disjoint/R.
%abbrev efxmap`deep-disjoint/= = deep-disjoint/=.
%abbrev efxmap`deep-disjoint/< = deep-disjoint/<.
%abbrev efxmap`deep-disjoint/> = deep-disjoint/>.
%abbrev efxmap`deep-disjoint? = deep-disjoint?.
%abbrev efxmap`deep-disjoint?/yes = deep-disjoint?/yes.
%abbrev efxmap`deep-disjoint?/no = deep-disjoint?/no.
%abbrev efxmap`deep-disjoint?-total* = deep-disjoint?-total*.
%abbrev efxmap`deep-disjoint?-total*/+ = deep-disjoint?-total*/+.
%abbrev efxmap`deep-disjoint?-total*/= = deep-disjoint?-total*/=.
%abbrev efxmap`deep-disjoint?-total*/< = deep-disjoint?-total*/<.
%abbrev efxmap`deep-disjoint?-total*/> = deep-disjoint?-total*/>.
%abbrev efxmap`deep-disjoint?-total = deep-disjoint?-total.
%abbrev efxmap`false-implies-deep-disjoint = false-implies-deep-disjoint.
%abbrev efxmap`meta-reduce-deep-disjoint = meta-reduce-deep-disjoint.
%abbrev efxmap`deep-disjoint-respects-eq = deep-disjoint-respects-eq.
%abbrev efxmap`deep-disjoint/=-inversion = deep-disjoint/=-inversion.
%abbrev efxmap`deep-disjoint/<-inversion = deep-disjoint/<-inversion.
%abbrev efxmap`deep-disjoint/>-inversion = deep-disjoint/>-inversion.
%abbrev efxmap`deep-disjoint-symmetric = deep-disjoint-symmetric.
%abbrev efxmap`shift-preserves-deep-disjoint = shift-preserves-deep-disjoint.
%abbrev efxmap`shift-preserves-deep-disjoint-converse = shift-preserves-deep-disjoint-converse.
%abbrev efxmap`shift-left-preserves-deep-disjoint = shift-left-preserves-deep-disjoint.
%abbrev efxmap`shift-left-preserves-deep-disjoint-converse = shift-left-preserves-deep-disjoint-converse.
%abbrev efxmap`shift-right-preserves-deep-disjoint = shift-right-preserves-deep-disjoint.
%abbrev efxmap`shift-right-preserves-deep-disjoint-converse = shift-right-preserves-deep-disjoint-converse.
%abbrev efxmap`join-preserves-deep-disjoint* = join-preserves-deep-disjoint*.
%abbrev efxmap`join-preserves-deep-disjoint*/L = join-preserves-deep-disjoint*/L.
%abbrev efxmap`join-left-preserves-deep-disjoint* = join-left-preserves-deep-disjoint*.
%abbrev efxmap`join-right-preserves-deep-disjoint* = join-right-preserves-deep-disjoint*.
%abbrev efxmap`join-preserves-deep-disjoint-converse = join-preserves-deep-disjoint-converse.
%abbrev efxmap`deep-disjoint-lookup-implies-disjoint = deep-disjoint-lookup-implies-disjoint.
%abbrev efxmap`fresh-update-preserves-deep-disjoint = fresh-update-preserves-deep-disjoint.
%abbrev efxmap`fresh-update-preserves-deep-disjoint/L = fresh-update-preserves-deep-disjoint/L.
%abbrev efxmap`deep-disjoint-respects-geq*/L = deep-disjoint-respects-geq*/L.
%abbrev efxmap`deep-disjoint-respects-geq* = deep-disjoint-respects-geq*.
%abbrev efxmap`deep-disjoint-respects-geq = deep-disjoint-respects-geq.
%abbrev efxmap`disjoint-implies-deep-disjoint = disjoint-implies-deep-disjoint.
%abbrev efxmap`shift-inside-right-preserves-deep-disjoint = shift-inside-right-preserves-deep-disjoint.
%abbrev efxmap`shift-inside-left-preserves-deep-disjoint = shift-inside-left-preserves-deep-disjoint.
%abbrev efxmap`shift-inside-preserves-deep-disjoint = shift-inside-preserves-deep-disjoint.
%abbrev efxmap`update-disjoint-implies-disjoint/L = update-disjoint-implies-disjoint/L.
%abbrev efxmap`update-disjoint-implies-disjoint = update-disjoint-implies-disjoint.
%abbrev efxmap`restrict = restrict.
%abbrev efxmap`restrict/0 = restrict/0.
%abbrev efxmap`restrict/out = restrict/out.
%abbrev efxmap`restrict/in = restrict/in.
%abbrev efxmap`false-implies-restrict = false-implies-restrict.
%abbrev efxmap`restrict-respects-eq = restrict-respects-eq.
%abbrev efxmap`restrict-total* = restrict-total*.
%abbrev efxmap`restrict-total = restrict-total.
%abbrev efxmap`restrict-total/L1 = restrict-total/L1.
%abbrev efxmap`restrict-total/L2 = restrict-total/L2.
%abbrev efxmap`restrict/in-inversion = restrict/in-inversion.
%abbrev efxmap`restrict/in-inversion/in = restrict/in-inversion/in.
%abbrev efxmap`restrict/out-inversion = restrict/out-inversion.
%abbrev efxmap`restrict/out-inversion/out = restrict/out-inversion/out.
%abbrev efxmap`restrict-unique = restrict-unique.
%abbrev efxmap`restrict-deterministic = restrict-deterministic.
%abbrev efxmap`restrict-preserves-lookup = restrict-preserves-lookup.
%abbrev efxmap`restrict-preserves-fresh = restrict-preserves-fresh.
%abbrev efxmap`restrict-preserves-lookup-converse = restrict-preserves-lookup-converse.
%abbrev efxmap`restrict-preserves-lookup-converse/L = restrict-preserves-lookup-converse/L.
%abbrev efxmap`restrict-left-preserves-disjoint = restrict-left-preserves-disjoint.
%abbrev efxmap`restrict-left-preserves-disjoint/L = restrict-left-preserves-disjoint/L.
%abbrev efxmap`restrict-right-preserves-disjoint = restrict-right-preserves-disjoint.
%abbrev efxmap`restrict-right-preserves-disjoint/L = restrict-right-preserves-disjoint/L.
%abbrev efxmap`fresh-add-preserves-restrict = fresh-add-preserves-restrict.
%abbrev efxmap`restrict-commute-update* = restrict-commute-update*.
%abbrev efxmap`restrict-commute-update/L = restrict-commute-update/L.
%abbrev efxmap`restrict-reorders = restrict-reorders.
%abbrev efxmap`restrict-reorders/out = restrict-reorders/out.
%abbrev efxmap`restrict-reorders/in = restrict-reorders/in.
%abbrev efxmap`restrict-reorders* = restrict-reorders*.
%abbrev efxmap`restrict-associates-intersection* = restrict-associates-intersection*.
%abbrev efxmap`restrict-associates-intersection*/L = restrict-associates-intersection*/L.
%abbrev efxmap`restrict-associates-intersection = restrict-associates-intersection.
%abbrev efxmap`restrict-associates-intersection-converse* = restrict-associates-intersection-converse*.
%abbrev efxmap`restrict-associates-intersection-converse = restrict-associates-intersection-converse.
%abbrev efxmap`empty-restriction = empty-restriction.
%abbrev efxmap`empty-restriction/L = empty-restriction/L.
%abbrev efxmap`fresh-implies-unit-restriction-empty = fresh-implies-unit-restriction-empty.
%abbrev efxmap`fresh-implies-unit-restriction-empty/L = fresh-implies-unit-restriction-empty/L.
%abbrev efxmap`lookup-implies-unit-restriction = lookup-implies-unit-restriction.
%abbrev efxmap`fresh-update-implies-restrict = fresh-update-implies-restrict.
%abbrev efxmap`restrict-idempotent = restrict-idempotent.
%abbrev efxmap`restrict-implies-domain-leq* = restrict-implies-domain-leq*.
%abbrev efxmap`restrict-implies-domain-leq = restrict-implies-domain-leq.
%abbrev efxmap`restrict-implies-domain-intersection* = restrict-implies-domain-intersection*.
%abbrev efxmap`domain-leq-implies-no-restriction = domain-leq-implies-no-restriction.
%abbrev efxmap`domain-leq-implies-no-restriction/L = domain-leq-implies-no-restriction/L.
%abbrev efxmap`domain-disjoint-implies-restrict-empty = domain-disjoint-implies-restrict-empty.
%abbrev efxmap`domain-disjoint-implies-restrict-empty/L = domain-disjoint-implies-restrict-empty/L.
%abbrev efxmap`restrict-implies-leq = restrict-implies-leq.
%abbrev efxmap`restrict-right-preserves-leq = restrict-right-preserves-leq.
%abbrev efxmap`restrict-left-preserves-leq = restrict-left-preserves-leq.
%abbrev efxmap`restrict-characterization = restrict-characterization.
%abbrev efxmap`restrict-characterization/L = restrict-characterization/L.
%abbrev efxmap`efxmap = efxmap.
%abbrev efxmap`efxmap/0 = efxmap/0.
%abbrev efxmap`efxmap/+ = efxmap/+.
