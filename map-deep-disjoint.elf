%%% The definition of disjoint is not strong enough for
%%% us. We need to show that even if two map's domain
%%% have intersection, if the data involved in the intersection
%%% are disjoint, then the maps are still disjoint. We call
%%% this 'deep-disjoint'.
%%% $Id$

deep-disjoint : map -> map -> type.

deep-disjoint/L : deep-disjoint map/0 M.

deep-disjoint/R : deep-disjoint M map/0.

deep-disjoint/=
  : deep-disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`eq N1 N2
    <- data`disjoint D1 D2
    <- deep-disjoint M1 M2.

deep-disjoint/< 
  : deep-disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- plus (s N0) N1 N2
    <- deep-disjoint M1 (map/+ N0 D2 M2).

deep-disjoint/>
  : deep-disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- plus (s N3) N2 N1
    <- deep-disjoint (map/+ N3 D1 M1) M2.


deep-disjoint? : map -> map -> bool -> type.

deep-disjoint?/yes
  : deep-disjoint M1 M2 ->
      deep-disjoint? M1 M2 true.
				 
deep-disjoint?/no
  : lookup M1 N D1 ->
    lookup M2 N D2 -> 
    data`disjoint? D1 D2 false -> 
      deep-disjoint? M1 M2 false.


%%% Theorems 

%theorem deep-disjoint?-total* :
 forall {M1} {M2}
 exists {B} {D:deep-disjoint? M1 M2 B}
 true.

- : deep-disjoint?-total* _ _ _
    (deep-disjoint?/yes deep-disjoint/L).

- : deep-disjoint?-total* _ _ _
    (deep-disjoint?/yes deep-disjoint/R).

%theorem deep-disjoint?-total*/+ :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {C}
 forall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2} 
        {CMP:nat`compare N1 N2 C}
 exists {B} {D:deep-disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
 true.

%theorem deep-disjoint?-total*/= :
    forall* {N} {D1} {M1} {D2} {M2} {B1} {B2}
    forall  {D?: deep-disjoint? M1 M2 B1}
            {ID?: data`disjoint? D1 D2 B2}
    exists  {B3} {D: deep-disjoint?
		     (map/+ N D1 M1) (map/+ N D2 M2) B3}
    true.

- : deep-disjoint?-total*/= 
    (deep-disjoint?/yes X) (data`disjoint?/yes IX)
    _ (deep-disjoint?/yes
	(deep-disjoint/= X IX nat`eq/)).

- : deep-disjoint?-total*/= 
    _ (data`disjoint?/no L1 L2)
    _ (deep-disjoint?/no (lookup/= nat`eq/)
      (lookup/= nat`eq/) (data`disjoint?/no L1 L2)).

- : deep-disjoint?-total*/=
    (deep-disjoint?/no L1 L2 IX) (data`disjoint?/yes _)
    _ (deep-disjoint?/no
	(lookup/> L1 P) (lookup/> L2 P) IX)
    <- plus-total P.
    
%worlds () (deep-disjoint?-total*/= _ _ _ _).
%total  {} (deep-disjoint?-total*/= _ _ _ _).


%theorem deep-disjoint?-total*/< :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0} {B1}
 forall {P:plus (s N0) N1 N2}
               {D?1:deep-disjoint? M1 (map/+ N0 D2 M2) B1}
 exists {B} {D:deep-disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
 true.

%theorem deep-disjoint?-total*/> :
 forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {B1}
 forall {P:plus (s N3) N2 N1}
               {D?1:deep-disjoint? (map/+ N3 D1 M1) M2 B1}
 exists {B} {D:deep-disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
 true.

- : deep-disjoint?-total* _ _ _ D?
    <- size-total SZ1
    <- size-total SZ2
    <- nat`compare-total CMP
    <- deep-disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?.

- : deep-disjoint?-total*/+ _ _
    size/0 _ nat`compare/= _ XX
    <- data`disjoint?-total IX
    <- deep-disjoint?-total*/=
      (deep-disjoint?/yes deep-disjoint/L) IX _ XX.

- : deep-disjoint?-total*/+ _ _
    _ size/0 nat`compare/= _ XX
    <- data`disjoint?-total IX
    <- deep-disjoint?-total*/=
      (deep-disjoint?/yes deep-disjoint/R) IX _ XX.

- : deep-disjoint?-total*/+ _ _
    (size/+ SZ1) (size/+ SZ2) (nat`compare/=) _ XX
    <- nat`compare-total CMP
    <- data`disjoint?-total IX
    <- deep-disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ X
    <- deep-disjoint?-total*/= X IX _ XX.

- : deep-disjoint?-total*/+ _ _ _ _ (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- deep-disjoint?-total*/< N0+1+N1=N2
      (deep-disjoint?/yes deep-disjoint/L) _ D?.

- : deep-disjoint?-total*/+ _ _ (size/+ SZ1) SZ2 (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- nat`compare-total CMP
    <- deep-disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- deep-disjoint?-total*/< N0+1+N1=N2 D?1 _ D?.

- : deep-disjoint?-total*/< N0+1+N1=N2 
    (deep-disjoint?/yes M1*M022) _
    (deep-disjoint?/yes (deep-disjoint/< M1*M022 N0+1+N1=N2)).

- : deep-disjoint?-total*/< N0+1+N1=N2
    (deep-disjoint?/no M1^N3=D1 M022^N3=D2 IX) _
    (deep-disjoint?/no (lookup/> M1^N3=D1 N3+1+N1=N4) M222^N4=D2 IX)
    <- plus-total N3+1+N1=N4
    <- plus-swap-succ N3+1+N1=N4 N3+N1+1=N4
    <- plus-commutative N3+N1+1=N4 N1+1+N3=N4
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-preserves-lookup*
      M022^N3=D2 (shift/+ N1+1+N0=N2) N1+1+N3=N4 M222^N4=D2.
      

%worlds () (deep-disjoint?-total*/< _ _ _ _).
%total { } (deep-disjoint?-total*/< _ _ _ _).


- : deep-disjoint?-total*/+ _ _ _ _ (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- deep-disjoint?-total*/>
      N3+1+N2=N1 (deep-disjoint?/yes deep-disjoint/R) _ D?.

- : deep-disjoint?-total*/+ _ _ SZ1
    (size/+ SZ2) (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- nat`compare-total CMP
    <- deep-disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- deep-disjoint?-total*/> N3+1+N2=N1 D?1 _ D?.

- : deep-disjoint?-total*/> P
    (deep-disjoint?/yes D) _
    (deep-disjoint?/yes (deep-disjoint/> D P)).

- : deep-disjoint?-total*/> N3+1+N2=N1
    (deep-disjoint?/no M311^N4=D1 M2^N4=D2 IX) _
    (deep-disjoint?/no M111^N5=D1
      (lookup/> M2^N4=D2 N4+1+N2=N5) IX)
    <- plus-total N4+1+N2=N5
    <- plus-swap-succ N4+1+N2=N5 N4+N2+1=N5
    <- plus-commutative N4+N2+1=N5 N2+1+N4=N5
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- shift-preserves-lookup* M311^N4=D1
      (shift/+ N2+1+N3=N1) N2+1+N4=N5 M111^N5=D1.
      

%worlds () (deep-disjoint?-total*/> _ _ _ _).
%total { } (deep-disjoint?-total*/> _ _ _ _).

%worlds () (deep-disjoint?-total*/+ _ _ _ _ _ _ _).
%total [S1 S2] (deep-disjoint?-total*/+ S1 S2 _ _ _ _ _).

%worlds () (deep-disjoint?-total* _ _ _ _).
%total { } (deep-disjoint?-total* _ _ _ _).

%abbrev deep-disjoint?-total = deep-disjoint?-total* _ _ _.
  

%theorem false-implies-deep-disjoint :
    forall* {XM1} {XM2}
    forall  {F:void}
    exists  {D: deep-disjoint XM1 XM2}
    true.

%worlds () (false-implies-deep-disjoint _ _).
%total  {} (false-implies-deep-disjoint _ _).


%theorem meta-reduce-deep-disjoint :
    forall* {M1} {M2} {M3} {M4}
    forall  {F:void}
            {D1: deep-disjoint M1 M2}
            {D2: deep-disjoint M3 M4}
    true.

%worlds () (meta-reduce-deep-disjoint _ _ _).
%total  {} (meta-reduce-deep-disjoint _ _ _).
%reduces X < Y (meta-reduce-deep-disjoint _ X Y).


%theorem deep-disjoint-respects-eq :
	forall* {M1} {M2} {M1P} {M2P}
	forall {A:deep-disjoint M1 M2} 
         {E1:eq M1 M1P} {E2:eq M2 M2P} 
	exists {AP:deep-disjoint M1P M2P}
	true.

- : deep-disjoint-respects-eq A eq/ eq/ A.

%worlds () (deep-disjoint-respects-eq _ _ _ _).
%total {} (deep-disjoint-respects-eq _ _ _ _).
%reduces A = AP (deep-disjoint-respects-eq A _ _ AP).



%theorem deep-disjoint/=-inversion :
    forall* {XM1} {XM2} {M1} {M2} {L1} {L2}
    forall  {D: deep-disjoint
		(map/+ L1 M1 XM1) (map/+ L2 M2 XM2)}
            {E: nat`eq L1 L2}
    exists  {D: data`disjoint M1 M2} {D: deep-disjoint XM1 XM2}
    true.

- : deep-disjoint/=-inversion 
    (deep-disjoint/= XM1<>XM2 M1<>M2 nat`eq/) nat`eq/
    M1<>M2 XM1<>XM2.

- : deep-disjoint/=-inversion
    (deep-disjoint/< J SL0+L1=L2) L1=L2 M1<>M2 XM1<>XM2
    <- plus-implies-gt SL0+L1=L2 nat`eq/ L2>L1
    <- nat`eq-ne-implies-false L1=L2 (nat`ne/< L2>L1) F
    <- data`false-implies-disjoint F M1<>M2
    <- false-implies-deep-disjoint F XM1<>XM2
    <- meta-reduce-deep-disjoint F XM1<>XM2 J.

- : deep-disjoint/=-inversion
    (deep-disjoint/> J SL0+L2=L1) L1=L2 M1<>M2 XM1<>XM2
    <- plus-implies-gt SL0+L2=L1 nat`eq/ L1>L2
    <- nat`eq-ne-implies-false L1=L2 (nat`ne/> L1>L2) F
    <- data`false-implies-disjoint F M1<>M2
    <- false-implies-deep-disjoint F XM1<>XM2
    <- meta-reduce-deep-disjoint F XM1<>XM2 J.

%worlds () (deep-disjoint/=-inversion _ _ _ _).
%total  {} (deep-disjoint/=-inversion _ _ _ _).
%reduces AP < A (deep-disjoint/=-inversion A _ _ AP).



%theorem deep-disjoint/<-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}
	forall {A:deep-disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
         {P:plus (s N0) N1 N2} 	       
	exists {AP:deep-disjoint M1 (map/+ N0 D2 M2)}
	true.

- : deep-disjoint/<-inversion (deep-disjoint/< A P) PP AP
    <- plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P data`eq/ eq/ M022=M022P
    <- deep-disjoint-respects-eq A eq/ M022=M022P AP.

- : deep-disjoint/<-inversion
    (deep-disjoint/> AP N3+1+N2=N1) N0+1+N1=N2 A
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M311=M1
    <- false-implies-eq F M2=M022
    <- deep-disjoint-respects-eq AP M311=M1 M2=M022 A.

- : deep-disjoint/<-inversion
    (deep-disjoint/= XM1<>XM2 M1<>M2 L1=L2) SN0+L1=L2 J
    <- plus-implies-gt SN0+L1=L2 nat`eq/ L2>L1
    <- nat`eq-ne-implies-false L1=L2 (nat`ne/< L2>L1) F
    <- false-implies-deep-disjoint F J
    <- meta-reduce-deep-disjoint F J XM1<>XM2.

%worlds () (deep-disjoint/<-inversion _ _ _).
%total {}  (deep-disjoint/<-inversion _ _ _).
%reduces AP < A (deep-disjoint/<-inversion A _ AP).


%theorem deep-disjoint/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
	forall {A:deep-disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
	       {P:plus (s N3) N2 N1}
	exists {AP:deep-disjoint (map/+ N3 D1 M1) M2}
	true.

- : deep-disjoint/>-inversion (deep-disjoint/> A P) PP AP
    <- plus-right-cancels P PP nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P data`eq/ eq/ M311=M311P
    <- deep-disjoint-respects-eq A M311=M311P eq/ AP.

- : deep-disjoint/>-inversion
    (deep-disjoint/< AP N0+1+N1=N2) N3+1+N2=N1 A
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M1=M311
    <- false-implies-eq F M022=M2
    <- deep-disjoint-respects-eq AP M1=M311 M022=M2 A.

- : deep-disjoint/>-inversion
    (deep-disjoint/= XM1<>XM2 M1<>M2 L1=L2) SN3+L2=L1 J
    <- plus-implies-gt SN3+L2=L1 nat`eq/ L1>L2
    <- nat`eq-ne-implies-false L1=L2 (nat`ne/> L1>L2) F
    <- false-implies-deep-disjoint F J
    <- meta-reduce-deep-disjoint F J XM1<>XM2.

%worlds () (deep-disjoint/>-inversion _ _ _).
%total { } (deep-disjoint/>-inversion _ _ _).
%reduces AP < A (deep-disjoint/>-inversion A _ AP).


%theorem deep-disjoint-symmetric :
	forall* {M1} {M2}
	forall {D:deep-disjoint M1 M2} 
	exists {D:deep-disjoint M2 M1}
	true.

- : deep-disjoint-symmetric
    deep-disjoint/L deep-disjoint/R.

- : deep-disjoint-symmetric
    deep-disjoint/R deep-disjoint/L.

- : deep-disjoint-symmetric
    (deep-disjoint/< D P) (deep-disjoint/> DP P)
    <- deep-disjoint-symmetric D DP.

- : deep-disjoint-symmetric
    (deep-disjoint/> D P) (deep-disjoint/< DP P)
    <- deep-disjoint-symmetric D DP.

- : deep-disjoint-symmetric
    (deep-disjoint/= M1<>M2 D1<>D2 N1=N2) 
    (deep-disjoint/= M2<>M1 D2<>D1 N2=N1)
    <- deep-disjoint-symmetric M1<>M2 M2<>M1
    <- data`disjoint-symmetric D1<>D2 D2<>D1
    <- nat`eq-symmetric N1=N2 N2=N1.

%worlds () (deep-disjoint-symmetric _ _).
%total (D) (deep-disjoint-symmetric D _).



%theorem shift-preserves-deep-disjoint :
    forall* {N} {M1} {M2} {SM1} {SM2}
	  forall {A:deep-disjoint M1 M2} 
           {S1:shift N M1 SM1} {S2:shift N M2 SM2}
  	exists {SA:deep-disjoint SM1 SM2}
	  true.

- : shift-preserves-deep-disjoint 
    _ shift/0 _ deep-disjoint/L.

- : shift-preserves-deep-disjoint 
    _ _ shift/0 deep-disjoint/R.

- : shift-preserves-deep-disjoint
    (deep-disjoint/< M1*M022 N0+1+N1=N2)
    (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
    (deep-disjoint/< M1*M022 N0+1+N4=N5)
    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4
    <- plus-commutative N+N1+1=N4 N1+1+N=N4
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.

- : shift-preserves-deep-disjoint
    (deep-disjoint/> M311*M2 N3+1+N2=N1)
    (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
    (deep-disjoint/> M311*M2 N3+1+N5=N4)
    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5
    <- plus-commutative N+N2+1=N5 N2+1+N=N5
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4.

- : shift-preserves-deep-disjoint 
    (deep-disjoint/= M1<>M2 D1<>D2 nat`eq/)
    (shift/+ P1) (shift/+ P2)
    (deep-disjoint/= M1<>M2 D1<>D2 N3=N4)
    <- plus-deterministic P1 P2 nat`eq/ nat`eq/ N3=N4.

%worlds () (shift-preserves-deep-disjoint _ _ _ _).
%total { } (shift-preserves-deep-disjoint _ _ _ _).



%theorem shift-preserves-deep-disjoint-converse :
	forall* {N} {M1} {M2} {SM1} {SM2}
	forall {SA:deep-disjoint SM1 SM2}
         {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	exists {A:deep-disjoint M1 M2}
	true.

- : shift-preserves-deep-disjoint-converse
    _ shift/0 _ deep-disjoint/L.

- : shift-preserves-deep-disjoint-converse
    _ _ shift/0 deep-disjoint/R.

- : shift-preserves-deep-disjoint-converse
    (deep-disjoint/< M1*M055 N0+1+N4=N5)
    (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
    (deep-disjoint/< M1*M055 N0+1+N1=N2)
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4
    <- plus-associative-converse
      N1+N+1=N4 N0+1+N4=N5 N2P N0+1+N1=N2P N2P+N+1=N5
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-right-cancels N2P+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2P=N2
    <- plus-respects-eq N0+1+N1=N2P nat`eq/ nat`eq/ N2P=N2 N0+1+N1=N2.
                                  
- : shift-preserves-deep-disjoint-converse
    (deep-disjoint/> M611*M2 N6+1+N5=N4)
    (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
    (deep-disjoint/> M611*M2 N6+1+N2=N1)
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5
    <- plus-associative-converse
      N2+N+1=N5 N6+1+N5=N4 N1P N6+1+N2=N1P N1P+N+1=N4
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-right-cancels N1P+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1P=N1
    <- plus-respects-eq N6+1+N2=N1P nat`eq/ nat`eq/ N1P=N1 N6+1+N2=N1.

- : shift-preserves-deep-disjoint-converse
    (deep-disjoint/= M1<>M2 D1<>D2 nat`eq/)
    (shift/+ P1) (shift/+ P2) 
    (deep-disjoint/= M1<>M2 D1<>D2 EQ)
    <- plus-left-cancels P1 P2 nat`eq/ nat`eq/ EQ.

%worlds () (shift-preserves-deep-disjoint-converse _ _ _ _).
%total { } (shift-preserves-deep-disjoint-converse _ _ _ _).


%theorem shift-left-preserves-deep-disjoint :
	forall* {N} {D} {M1} {M2} {SM1}
	forall {A:deep-disjoint M1 M2} {S1:shift N M1 SM1}
        exists {SA:deep-disjoint SM1 (map/+ N D M2)}
        true.

- : shift-left-preserves-deep-disjoint
    _ shift/0 deep-disjoint/L.

- : shift-left-preserves-deep-disjoint M111*M2 (shift/+ N+1+N1=N1P)
    (deep-disjoint/> M111*M2 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-deep-disjoint _ _ _).
%total { } (shift-left-preserves-deep-disjoint _ _ _).


%theorem shift-left-preserves-deep-disjoint-converse :
	forall* {N} {D} {M1} {M2} {SM1}
	forall {SA:deep-disjoint SM1 (map/+ N D M2)} 
         {S1:shift N M1 SM1}
  exists {A:deep-disjoint M1 M2}
	true.

- : shift-left-preserves-deep-disjoint-converse
    _ shift/0 deep-disjoint/L.

- : shift-left-preserves-deep-disjoint-converse 
    M111*M222 (shift/+ N2+1+N3=N1) M311*M2
    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1
    <- deep-disjoint/>-inversion M111*M222 N3+1+N2=N1 M311*M2.

%worlds () (shift-left-preserves-deep-disjoint-converse _ _ _).
%total { } (shift-left-preserves-deep-disjoint-converse _ _ _).


%theorem shift-right-preserves-deep-disjoint :
	forall* {N} {D} {M1} {M2} {SM2}
	forall {A:deep-disjoint M1 M2} {S2:shift N M2 SM2}
        exists {SA:deep-disjoint (map/+ N D M1) SM2}
	true.

- : shift-right-preserves-deep-disjoint _ shift/0 deep-disjoint/R.

- : shift-right-preserves-deep-disjoint M1*M222 (shift/+ N+1+N2=N2P)
                               (deep-disjoint/< M1*M222 N2+1+N=N2P)
    <- plus-swap-succ N+1+N2=N2P N+N2+1=N2P
    <- plus-commutative N+N2+1=N2P N2+1+N=N2P.

%worlds () (shift-right-preserves-deep-disjoint _ _ _).
%total { } (shift-right-preserves-deep-disjoint _ _ _).


%theorem shift-right-preserves-deep-disjoint-converse :
	forall* {N} {D} {M1} {M2} {SM2}
	forall {SA:deep-disjoint (map/+ N D M1) SM2} {S2:shift N M2 SM2}
        exists {A:deep-disjoint M1 M2}
	true.

- : shift-right-preserves-deep-disjoint-converse
    _ shift/0 deep-disjoint/R.

- : shift-right-preserves-deep-disjoint-converse
    M111*M322 (shift/+ N1+1+N2=N3) M1*M222
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- deep-disjoint/<-inversion M111*M322 N2+1+N1=N3 M1*M222.

%worlds () (shift-right-preserves-deep-disjoint-converse _ _ _).
%total { } (shift-right-preserves-deep-disjoint-converse _ _ _).


%theorem join-preserves-deep-disjoint* :
	forall* {M1} {M2} {M3} {M4}
	forall {D1: deep-disjoint M1 M4} {D2: deep-disjoint M2 M4}
	       {A: join M1 M2 M3}
	exists {D3:deep-disjoint M3 M4}
	true.

% a lemma that counts the size of maps to help prove termination
%theorem join-preserves-deep-disjoint*/L :
	forall* {M1} {M2} {M3} {M4}
	forall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2}
         {D1:deep-disjoint M1 M4} {D2:deep-disjoint M2 M4}
	       {A:join M1 M2 M3}
	exists {D3:deep-disjoint M3 M4}
	true.

- : join-preserves-deep-disjoint* D1 D2 J D3
    <- size-total SZ1
    <- size-total SZ2
    <- join-preserves-deep-disjoint*/L _ _ SZ1 SZ2 D1 D2 J D3.

- : join-preserves-deep-disjoint*/L
    _ _ _ _ deep-disjoint/R _ _ deep-disjoint/R.

- : join-preserves-deep-disjoint*/L
    _ _ _ _ _ deep-disjoint/R _ deep-disjoint/R.

- : join-preserves-deep-disjoint*/L _ _ _ _ _ D join/L D.

- : join-preserves-deep-disjoint*/L _ _ _ _ D _ join/R D.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/< D1 N5+1+N1=N4) D2X 
    (join/= J _ nat`eq/)
    (deep-disjoint/< D3 N5+1+N1=N4)
    <- deep-disjoint/<-inversion D2X N5+1+N1=N4 D2
    <- join-preserves-deep-disjoint*/L S1 S2 SZ1 SZ2 D1 D2 J D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/< D1 N5+1+N1=N4) D2X
    (join/> J N3+1+N2=N1)
    (deep-disjoint/< D3 N6+1+N2=N4)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse
      N3+N2+1=N1 N5+1+N1=N4 N6 N5+1+N3=N6 N6+N2+1=N4
    <- plus-swap-succ-converse N6+N2+1=N4 N6+1+N2=N4
    <- deep-disjoint/<-inversion D2X N6+1+N2=N4 D2
    <- plus-swap-succ N5+1+N3=N6 N5+N3+1=N6
    <- plus-commutative N5+N3+1=N6 N3+1+N5=N6
    <- shift-right-preserves-deep-disjoint
      D1 (shift/+ N3+1+N5=N6) D1<<N3
    <- join-preserves-deep-disjoint*/L
      (s S1) S2 (size/+ SZ1) SZ2 D1<<N3 D2 J D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/> D1 N5+1+N4=N1) D2X 
    (join/= J DJ nat`eq/)
    (deep-disjoint/> D3 N5+1+N4=N1)
    <- deep-disjoint/>-inversion D2X N5+1+N4=N1 D2
    <- join-preserves-deep-disjoint*/L 
      _ _ (size/+ SZ1) (size/+ SZ2) 
      D1 D2 (join/= J DJ nat`eq/) D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/> D1 N5+1+N4=N1) D2X
    (join/< J N0+1+N1=N2)
    (deep-disjoint/> D3 N5+1+N4=N1)
    <- plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- plus-associative-converse
      N5+N4+1=N1 N0+1+N1=N2 N6 N0+1+N5=N6 N6+N4+1=N2
    <- plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2
    <- deep-disjoint/>-inversion D2X N6+1+N4=N2 D2
    <- join-preserves-deep-disjoint*/L
      _ _ (size/+ SZ1) (size/+ SZ2) 
      D1 D2 (join/< J N0+1+N5=N6) D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    D1X (deep-disjoint/< D2 N6+1+N2=N4) 
    (join/< J N0+1+N1=N2)
    (deep-disjoint/< D3 N5+1+N1=N4)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse
      N0+N1+1=N2 N6+1+N2=N4 N5 N6+1+N0=N5 N5+N1+1=N4
    <- plus-swap-succ-converse N5+N1+1=N4 N5+1+N1=N4
    <- deep-disjoint/<-inversion D1X N5+1+N1=N4 D1
    <- plus-swap-succ N6+1+N0=N5 N6+N0+1=N5
    <- plus-commutative N6+N0+1=N5 N0+1+N6=N5
    <- shift-right-preserves-deep-disjoint 
      D2 (shift/+ N0+1+N6=N5) D2<<N0
    <- join-preserves-deep-disjoint*/L 
      S1 (s S2) SZ1 (size/+ SZ2) D1 D2<<N0 J D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    D1X (deep-disjoint/> D2 N6+1+N4=N2)
    (join/> J N3+1+N2=N1)
    (deep-disjoint/> D3 N6+1+N4=N2)
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-associative-converse
      N6+N4+1=N2 N3+1+N2=N1 N5 N3+1+N6=N5 N5+N4+1=N1
    <- plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1
    <- deep-disjoint/>-inversion D1X N5+1+N4=N1 D1
    <- join-preserves-deep-disjoint*/L
      _ _ (size/+ SZ1) (size/+ SZ2) 
      D1 D2 (join/> J N3+1+N6=N5) D3.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/< D1 N5+1+N1=N4)
    (deep-disjoint/> D2 N6+1+N4=N2) JX D3X
    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- plus-associative-converse
      N5+N1+1=N4 N6+1+N4=N2 N0 N6+1+N5=N0 N0+N1+1=N2
    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2
    <- join/<-inversion JX N0+1+N1=N2 _ J M=M113
    <- eq-symmetric M=M113 M113=M
    <- join-preserves-deep-disjoint*/L
      S1 (s S2) SZ1 (size/+ SZ2)
      D1 (deep-disjoint/> D2 N6+1+N5=N0) J D3
    <- deep-disjoint-respects-eq
      (deep-disjoint/< D3 N5+1+N1=N4) M113=M eq/ D3X.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/> D1 N5+1+N4=N1)
    (deep-disjoint/< D2 N6+1+N2=N4) JX D3X
    <- plus-swap-succ N6+1+N2=N4 N6+N2+1=N4
    <- plus-associative-converse
      N6+N2+1=N4 N5+1+N4=N1 N3 N5+1+N6=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- join/>-inversion JX N3+1+N2=N1 _ J M=M223
    <- eq-symmetric M=M223 M223=M
    <- join-preserves-deep-disjoint*/L _ _ (size/+ SZ1) SZ2
      (deep-disjoint/> D1 N5+1+N6=N3) D2 J D3
    <- deep-disjoint-respects-eq
      (deep-disjoint/< D3 N6+1+N2=N4) M223=M eq/ D3X.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= D1 X1 nat`eq/) (deep-disjoint/= D2 X2 nat`eq/)
    (join/= J MJ nat`eq/) (deep-disjoint/= DD XX nat`eq/)
    <- join-preserves-deep-disjoint*/L _ _ SZ1 SZ2 D1 D2 J DD
    <- data`join-preserves-disjoint* X1 X2 MJ XX.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= D1 X nat`eq/) 
    (deep-disjoint/> D2 P1) (join/< J P2)
    (deep-disjoint/= DDD X nat`eq/)
    <- plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ
    <- succ-cancels EQ EQP
    <- map/+-preserves-eq EQP data`eq/ eq/ MEQ
    <- eq-symmetric MEQ MEQP
    <- join-respects-eq J eq/ MEQP eq/ JP
    <- join-preserves-deep-disjoint*/L
      _ _ SZ1 (size/+ SZ2) D1 D2 JP DDD.
      
- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= D1 X nat`eq/) 
    (deep-disjoint/< D2 P1) (join/> J P2) 
    (deep-disjoint/< DDD P1)
    <- plus-right-cancels P2 P1 nat`eq/ nat`eq/ EQ
    <- succ-cancels EQ EQP
    <- join-preserves-deep-disjoint*/L
      _ _ (size/+ SZ1) SZ2 (deep-disjoint/= D1 X EQP) D2 J DDD.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/> D1 P) (deep-disjoint/= D2 X nat`eq/) 
    (join/> J PP) (deep-disjoint/= DD X nat`eq/)
    <- plus-right-cancels PP P nat`eq/ nat`eq/ EQ
    <- succ-cancels EQ EQP
    <- map/+-preserves-eq EQP data`eq/ eq/ MEQ
    <- join-respects-eq J MEQ eq/ eq/ JP
    <- join-preserves-deep-disjoint*/L
      _ _ (size/+ SZ1) SZ2 D1 D2 JP DD.
      
- : join-preserves-deep-disjoint*/L 
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/< D1 P1) (deep-disjoint/= D2 X nat`eq/)
    (join/< J P2)
    (deep-disjoint/< DDD P1)
    <- plus-right-cancels P2 P1 nat`eq/ nat`eq/ EQ
    <- succ-cancels EQ EQP
    <- join-preserves-deep-disjoint*/L
      _ _ SZ1 (size/+ SZ2) D1 (deep-disjoint/= D2 X EQP) J DDD.

%%% all the impossible cases

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= D1 X1 nat`eq/) (deep-disjoint/= D2 X2 nat`eq/)
    (join/> J P) DD
    <- plus-implies-gt P nat`eq/ GT
    <- nat`eq-ne-implies-false nat`eq/ (nat`ne/> GT) F
    <- false-implies-deep-disjoint F DD.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= D1 X1 nat`eq/) (deep-disjoint/= D2 X2 nat`eq/)
    (join/< J P) DD
    <- plus-implies-gt P nat`eq/ GT
    <- nat`eq-ne-implies-false nat`eq/ (nat`ne/> GT) F
    <- false-implies-deep-disjoint F DD.
 
- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= _ _ nat`eq/) 
    (deep-disjoint/< _ P) (join/= _ _ nat`eq/) DD
    <- plus-implies-gt P nat`eq/ GT
    <- nat`eq-ne-implies-false nat`eq/ (nat`ne/> GT) F
    <- false-implies-deep-disjoint F DD.

- : join-preserves-deep-disjoint*/L
    (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
    (deep-disjoint/= _ _ nat`eq/) 
    (deep-disjoint/> _ P) (join/= _ _ nat`eq/) DD
    <- plus-implies-gt P nat`eq/ GT
    <- nat`eq-ne-implies-false nat`eq/ (nat`ne/> GT) F
    <- false-implies-deep-disjoint F DD.

%worlds () (join-preserves-deep-disjoint*/L _ _ _ _ _ _ _ _).
%total {S1 S2 D1} (join-preserves-deep-disjoint*/L S1 S2 _ _ D1 _ _ _).

%worlds () (join-preserves-deep-disjoint* _ _ _ _).
%total { } (join-preserves-deep-disjoint* _ _ _ _).


%abbrev join-left-preserves-deep-disjoint* = join-preserves-deep-disjoint*.


%theorem join-right-preserves-deep-disjoint* :
	forall* {M1} {M2} {M3} {M0}
	forall {D1:deep-disjoint M0 M1} 
         {D2:deep-disjoint M0 M2}
	       {A:join M1 M2 M3}
	exists {D3:deep-disjoint M0 M3}
	true.

- : join-right-preserves-deep-disjoint* D1 D2 U D3
    <- deep-disjoint-symmetric D1 D1s
    <- deep-disjoint-symmetric D2 D2s
    <- join-left-preserves-deep-disjoint* D1s D2s U D3s
    <- deep-disjoint-symmetric D3s D3.

%worlds () (join-right-preserves-deep-disjoint* _ _ _ _).
%total { } (join-right-preserves-deep-disjoint* _ _ _ _).


%theorem join-preserves-deep-disjoint-converse:
	forall* {M1} {M2} {M3} {M4}
	forall {D3:deep-disjoint M3 M4}
	       {A:join M1 M2 M3}
	exists {D1:deep-disjoint M1 M4} {D2:deep-disjoint M2 M4}
	true.

- : join-preserves-deep-disjoint-converse
    D join/L deep-disjoint/L D.

- : join-preserves-deep-disjoint-converse
    D join/R D deep-disjoint/L.

- : join-preserves-deep-disjoint-converse
    deep-disjoint/R _
    deep-disjoint/R deep-disjoint/R.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/< D P)
    (join/= J _ nat`eq/)
    (deep-disjoint/< D1 P) (deep-disjoint/< D2 P)
    <- join-preserves-deep-disjoint-converse D J D1 D2.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/< D P1)
    (join/< J P2)
    (deep-disjoint/< D1 P1) D2S
    <- join-preserves-deep-disjoint-converse D J D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-deep-disjoint 
      D2 (shift/+ P2sc) (shift/+ P1sc) D2S.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/< D P1)
    (join/> J P2)
    D1S (deep-disjoint/< D2 P1)
    <- join-preserves-deep-disjoint-converse D J D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-deep-disjoint 
      D1 (shift/+ P2sc) (shift/+ P1sc) D1S.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/> D P1)
    (join/= J DE nat`eq/)
    D1S D2S
    <- join-preserves-deep-disjoint-converse
      D (join/= J DE nat`eq/) D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- shift-left-preserves-deep-disjoint D1 (shift/+ P1sc) D1S
    <- shift-left-preserves-deep-disjoint D2 (shift/+ P1sc) D2S.

- : join-preserves-deep-disjoint-converse
	(deep-disjoint/> D P1)
	(join/< J P2)
        D1S D2S
    <- plus-swap-succ P1 P1s
    <- plus-associative-converse P1s P2 _ P3 P4s
    <- join-preserves-deep-disjoint-converse D (join/< J P3) D1 D2
    <- plus-commutative P1s P1sc
    <- plus-commutative P4s P4sc
    <- shift-left-preserves-deep-disjoint D1 (shift/+ P1sc) D1S
    <- shift-left-preserves-deep-disjoint D2 (shift/+ P4sc) D2S.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/> D P1)
    (join/> J P2)
    D1S D2S
    <- plus-swap-succ P1 P1s
    <- plus-associative-converse P1s P2 _ P3 P4s
    <- join-preserves-deep-disjoint-converse D (join/> J P3) D1 D2
    <- plus-commutative P1s P1sc
    <- plus-commutative P4s P4sc
    <- shift-left-preserves-deep-disjoint D1 (shift/+ P4sc) D1S
    <- shift-left-preserves-deep-disjoint D2 (shift/+ P1sc) D2S.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/= D X nat`eq/) (join/= J P nat`eq/) 
    (deep-disjoint/= D1 X1 nat`eq/) (deep-disjoint/= D2 X2 nat`eq/)
    <- join-preserves-deep-disjoint-converse D J D1 D2
    <- data`join-preserves-disjoint-converse X P X1 X2.

- : join-preserves-deep-disjoint-converse
    (deep-disjoint/= D X nat`eq/) (join/< J P) 
    (deep-disjoint/= D1 X nat`eq/) (deep-disjoint/> D2 P)
    <- join-preserves-deep-disjoint-converse D J D1 D2.
    
- : join-preserves-deep-disjoint-converse
    (deep-disjoint/= D X nat`eq/) (join/> J P) 
    (deep-disjoint/> D1 P) (deep-disjoint/= D2 X nat`eq/)
    <- join-preserves-deep-disjoint-converse D J D1 D2.
    

%worlds () (join-preserves-deep-disjoint-converse _ _ _ _).
%total (D) (join-preserves-deep-disjoint-converse D _ _ _).


%theorem deep-disjoint-lookup-implies-disjoint :
 forall* {M1} {M2} {N} {D1} {D2}
 forall {A:deep-disjoint M1 M2}
        {L1:lookup M1 N D1} {L2:lookup M2 N D2}
 exists {IX:data`disjoint D1 D2}
 true.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/= _ X nat`eq/) 
    (lookup/= nat`eq/) (lookup/= nat`eq/) X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/= X _ nat`eq/)
    (lookup/> L1 P1) (lookup/> L2 P2) XX
    <- plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ
    <- succ-cancels EQ NEQ
    <- lookup-respects-eq L1 eq/ NEQ data`eq/ L1P
    <- deep-disjoint-lookup-implies-disjoint X L1P L2 XX.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/= _ _ nat`eq/)
    (lookup/> _ P) (lookup/= nat`eq/) X
    <- plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- data`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/= _ _ nat`eq/)
    (lookup/= nat`eq/) (lookup/> _ P) X
    <- plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- data`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/< _ N0+1+N=N)
    (lookup/= nat`eq/) (lookup/= nat`eq/) X
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- data`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/< _ P1)
    (lookup/= nat`eq/) (lookup/> _ P2) X
    <- plus-implies-gt P1 nat`eq/ GT1
    <- plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- data`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/< D N0+1+N1=N2)
    (lookup/> L1P N0P+1+N1=N2)
    (lookup/= nat`eq/) F
    <- plus-right-cancels N0P+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N0P+1=N0+1
    <- succ-cancels N0P+1=N0+1 N0P=N0
    <- lookup-respects-eq L1P eq/ N0P=N0 data`eq/ L1
    <- deep-disjoint-lookup-implies-disjoint D L1 (lookup/= nat`eq/) F.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/< D N0+1+N1=N2)
    (lookup/> L1 N1P+1+N1=N)
    (lookup/> L2 N2P+1+N2=N) F
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N2P+1+N2=N NX
                                 N2P+1+N0=NX NX+N1+1=N
    <- plus-swap-succ N1P+1+N1=N N1P+N1+1=N
    <- plus-right-cancels NX+N1+1=N N1P+N1+1=N nat`eq/ nat`eq/ NX=N1P
    <- plus-respects-eq N2P+1+N0=NX nat`eq/ nat`eq/ NX=N1P N2P+1+N0=N1P
    <- deep-disjoint-lookup-implies-disjoint
      D L1 (lookup/> L2 N2P+1+N0=N1P) F.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/> _ N3+1+N=N)
    (lookup/= nat`eq/) (lookup/= nat`eq/) X
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- data`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/> _ N3+1+N2=N1)
    (lookup/> _ N3+1+N1=N2)
    (lookup/= nat`eq/) X
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- plus-implies-gt N3+1+N1=N2 nat`eq/ N2>N1
    <- gt-anti-symmetric N1>N2 N2>N1 F
    <- data`false-implies-disjoint F X.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/> D N3+1+N2=N1)
    (lookup/= nat`eq/)
    (lookup/> L2P N3P+1+N2=N1) F
    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- succ-cancels N3P+1=N3+1 N3P=N3
    <- lookup-respects-eq L2P eq/ N3P=N3 data`eq/ L2
    <- deep-disjoint-lookup-implies-disjoint D (lookup/= nat`eq/) L2 F.

- : deep-disjoint-lookup-implies-disjoint
    (deep-disjoint/> D N3+1+N2=N1)
    (lookup/> L1 N1P+1+N1=N)
    (lookup/> L2 N2P+1+N2=N) F
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N1P+1+N1=N NX
                                 N1P+1+N3=NX NX+N2+1=N
    <- plus-swap-succ N2P+1+N2=N N2P+N2+1=N
    <- plus-right-cancels NX+N2+1=N N2P+N2+1=N nat`eq/ nat`eq/ NX=N2P
    <- plus-respects-eq N1P+1+N3=NX nat`eq/ nat`eq/ NX=N2P N1P+1+N3=N2P
    <- deep-disjoint-lookup-implies-disjoint
      D (lookup/> L1 N1P+1+N3=N2P) L2 F.

%worlds () (deep-disjoint-lookup-implies-disjoint _ _ _ _).
%total (D) (deep-disjoint-lookup-implies-disjoint D _ _ _).


%theorem fresh-update-preserves-deep-disjoint :
 forall* {M1} {M2} {N} {D} {M2P}
 forall {I: deep-disjoint M1 M2}
  {F: fresh M1 N}
  {U: update M2 N D M2P}
 exists {DP: deep-disjoint M1 M2P}
 true.

%theorem fresh-update-preserves-deep-disjoint/L :
    forall* {M1} {M2} {N} {D} {M2P} {B}
    forall {I: deep-disjoint M1 M2}
           {F: fresh M1 N}
           {U: update M2 N D M2P}
           {D?: deep-disjoint? M1 M2P B}
    exists {DP: deep-disjoint M1 M2P}
    true.

- : fresh-update-preserves-deep-disjoint/L
    _ _ _ (deep-disjoint?/yes DJ) DJ.

- : fresh-update-preserves-deep-disjoint/L 
    D FR U (deep-disjoint?/no 
	     L1 L2P (data`disjoint?/no LL1 LL2)) XXX
    <- fresh-lookup-not-equal FR L1 NE
    <- nat`ne-symmetric NE NEs
    <- update-preserves-lookup-converse L2P U NEs L2
    <- deep-disjoint-lookup-implies-disjoint D L1 L2 IX
    <- data`disjoint-lookup-contradiction IX LL1 LL2 F
    <- false-implies-deep-disjoint F XXX.

%worlds () (fresh-update-preserves-deep-disjoint/L _ _ _ _ _).
%total { } (fresh-update-preserves-deep-disjoint/L _ _ _ _ _).

- : fresh-update-preserves-deep-disjoint D F U DP
    <- deep-disjoint?-total D?
    <- fresh-update-preserves-deep-disjoint/L D F U D? DP.

%worlds () (fresh-update-preserves-deep-disjoint _ _ _ _).
%total { } (fresh-update-preserves-deep-disjoint _ _ _ _).


%theorem deep-disjoint-respects-geq*/L :
    forall* {M1} {M2} {M1P}
    forall {N1} {SZ1: size M1 N1}
           {N2} {SZ2: size M2 N2}
           {A:deep-disjoint M1 M2} 
           {E1:leq M1P M1}
    exists {AP:deep-disjoint M1P M2}
    true.

- : deep-disjoint-respects-geq*/L _ (size/+ SZ1) 
    _ (size/+ SZ2)
    (deep-disjoint/< D1 P) (leq/= L _ nat`eq/)
    (deep-disjoint/< D1P P)
    <- deep-disjoint-respects-geq*/L 
      _ SZ1 _ (size/+ SZ2) D1 L D1P.
    
- : deep-disjoint-respects-geq*/L _ _ _ _
    _ leq/0 deep-disjoint/L.

- : deep-disjoint-respects-geq*/L _ _ _ _
    deep-disjoint/R _ deep-disjoint/R.

- : deep-disjoint-respects-geq*/L
    _ (size/+ SZ1) _ (size/+ SZ2)
    (deep-disjoint/> D1 P) (leq/= L DL nat`eq/)
    (deep-disjoint/> D1P P)
    <- deep-disjoint-respects-geq*/L
      _ (size/+ SZ1) _ SZ2 D1 (leq/= L DL nat`eq/) D1P.

- : deep-disjoint-respects-geq*/L 
    _ (size/+ SZ1) _ (size/+ SZ2)
    (deep-disjoint/< D1 P1) (leq/> L P2) DP
    <- deep-disjoint-respects-geq*/L 
      _ SZ1 _ (size/+ SZ2) D1 L D1P
    <- plus-swap-succ P1 P1S
    <- plus-swap-succ P2 P2S
    <- plus-commutative P1S P1SC
    <- plus-commutative P2S P2SC
    <- shift-preserves-deep-disjoint
      D1P (shift/+ P2SC) (shift/+ P1SC) DP.

- : deep-disjoint-respects-geq*/L 
    _ (size/+ SZ1) _ (size/+ SZ2)
    (deep-disjoint/> D1 N0+1+N1=N2) (leq/> L N3+1+N2=N4) DP
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse 
      N0+N1+1=N2 N3+1+N2=N4 N5 N3+1+N0=N5 N5+N1+1=N4
    <- deep-disjoint-respects-geq*/L _ (size/+ SZ1) _ SZ2
      D1 (leq/> L N3+1+N0=N5) D1P
    <- plus-commutative N5+N1+1=N4 N1+1+N5=N4
    <- shift-left-preserves-deep-disjoint
      D1P (shift/+ N1+1+N5=N4) DP.

- : deep-disjoint-respects-geq*/L 
    _ (size/+ SZ1) _ (size/+ SZ2)
    (deep-disjoint/= XM1^XM2 M1^M2 nat`eq/)
    (leq/= XM1P<=XM1 M1P<=M1 nat`eq/) 
    (deep-disjoint/= XM1P^XM2 M1P^M2 nat`eq/)
    <- deep-disjoint-respects-geq*/L _ SZ1 _ SZ2
      XM1^XM2 XM1P<=XM1 XM1P^XM2
    <- data`disjoint-respects-geq*
      M1^M2 M1P<=M1 M1P^M2.

- : deep-disjoint-respects-geq*/L 
    _ (size/+ SZ1) _ (size/+ SZ2)
    (deep-disjoint/= XM1^XM2 _ nat`eq/)
    (leq/> N3XM1P<=XM1 N3+1+N2=N1) XM1P^XM2
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- shift-total SH2
    <- shift-preserves-leq N3XM1P<=XM1
      (shift/+ N2+1+N3=N1) SH2 N1XM1P<=XM1S
    <- shift-total SH3
    <- shift-preserves-deep-disjoint XM1^XM2 SH2 SH3 XM1S^XM2S
    <- shift-preserves-size SZ1 SH2 SZ1P
    <- shift-preserves-size SZ2 SH3 SZ2P
    <- deep-disjoint-respects-geq*/L
      _ SZ1P _ SZ2P XM1S^XM2S N1XM1P<=XM1S XM1P^XM2S
    <- shift-implies-update SH3 UD3
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- fresh-update-preserves-deep-disjoint
      XM1P^XM2S (fresh/< N1>N2) UD3 XM1P^XM2.
      
%worlds () (deep-disjoint-respects-geq*/L _ _ _ _ _ _ _).
%total {N1 N2} (deep-disjoint-respects-geq*/L N1 _ N2 _ _ _ _).


%theorem deep-disjoint-respects-geq* :
    forall* {M1} {M2} {M1P}
    forall {A:deep-disjoint M1 M2} 
           {E1:leq M1P M1}
    exists {AP:deep-disjoint M1P M2}
    true.

- : deep-disjoint-respects-geq* A E1 AP
    <- size-total SZ1
    <- size-total SZ2
    <- deep-disjoint-respects-geq*/L _ SZ1 _ SZ2 A E1 AP.

%worlds () (deep-disjoint-respects-geq* _ _ _).
%total  {} (deep-disjoint-respects-geq* _ _ _).


%theorem deep-disjoint-respects-geq :
 forall* {M1} {M2} {M1P} {M2P}
 forall {A:deep-disjoint M1 M2} 
        {E1:leq M1P M1} {E2:leq M2P M2}
 exists {AP:deep-disjoint M1P M2P}
 true.

- : deep-disjoint-respects-geq M1^M2 M1P<=M1 M2P<=M2 M1P^M2P
    <- deep-disjoint-respects-geq* M1^M2 M1P<=M1 M1P^M2
    <- deep-disjoint-symmetric M1P^M2 M2^M1P
    <- deep-disjoint-respects-geq* M2^M1P M2P<=M2 M2P^M1P
    <- deep-disjoint-symmetric M2P^M1P M1P^M2P.

%worlds () (deep-disjoint-respects-geq _ _ _ _).
%total { } (deep-disjoint-respects-geq _ _ _ _).


%% NOTE: deep-disjoint is NOT anti-reflexive:
%% we could have same keys point to empty inner map.

% %theorem deep-disjoint-anti-reflexive :
%     forall* {M}
%     forall {D:deep-disjoint M M}
%     exists {E:eq map/0 M}
%     true.

% %worlds () (deep-disjoint-anti-reflexive _ _).
% %total { } (deep-disjoint-anti-reflexive _ _).

% %theorem deep-disjoint-leq-implies-empty :
%     forall* {M1} {M2}
%     forall {D: deep-disjoint M1 M2}
%            {L: leq M1 M2}
%     exists {E: eq map/0 M1}
%     true.

% %worlds () (deep-disjoint-leq-implies-empty _ _ _).
% %total { } (deep-disjoint-leq-implies-empty _ _ _).


%theorem disjoint-implies-deep-disjoint :
    forall* {M1} {M2}
    forall  {D: disjoint M1 M2}
    exists  {D: deep-disjoint M1 M2}
    true.

- : disjoint-implies-deep-disjoint 
    disjoint/L deep-disjoint/L.

- : disjoint-implies-deep-disjoint 
    disjoint/R deep-disjoint/R.

- : disjoint-implies-deep-disjoint 
    (disjoint/< D P) (deep-disjoint/< DP P)
    <- disjoint-implies-deep-disjoint D DP.

- : disjoint-implies-deep-disjoint 
    (disjoint/> D P) (deep-disjoint/> DP P)
    <- disjoint-implies-deep-disjoint D DP.

%worlds () (disjoint-implies-deep-disjoint _ _).
%total (D) (disjoint-implies-deep-disjoint D _).


%% short of good name for this one

%theorem shift-inside-right-preserves-deep-disjoint :
    forall* {M1} {M2} {D} {N} {SM2}
    forall  {D: deep-disjoint M1 (map/+ N D M2)}
            {S: shift N M2 SM2}
    exists  {D: deep-disjoint M1 SM2}
    true.

- : shift-inside-right-preserves-deep-disjoint D SH DD
    <- can-construct-unit-join SH J
    <- deep-disjoint-symmetric D D1
    <- join-preserves-deep-disjoint-converse D1 J DD1 DD2
    <- deep-disjoint-symmetric DD1 DD.
    
%worlds () (shift-inside-right-preserves-deep-disjoint _ _ _).
%total  (D) (shift-inside-right-preserves-deep-disjoint D _ _).


%theorem shift-inside-left-preserves-deep-disjoint :
    forall* {M1} {M2} {D} {N} {SM1}
    forall  {D: deep-disjoint (map/+ N D M1) M2}
            {S: shift N M1 SM1}
    exists  {D: deep-disjoint SM1 M2}
    true.

- : shift-inside-left-preserves-deep-disjoint D SH DD
    <- can-construct-unit-join SH J
    <- join-preserves-deep-disjoint-converse D J DD _.

%worlds () (shift-inside-left-preserves-deep-disjoint _ _ _).
%total  (D) (shift-inside-left-preserves-deep-disjoint D _ _).
    

%theorem shift-inside-preserves-deep-disjoint :
    forall* {M1} {M2} {D1} {D2} {N1} {N2} {SM1} {SM2}
    forall  {D: deep-disjoint
                (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
            {S: shift N1 M1 SM1} {S: shift N2 M2 SM2}
    exists  {D: deep-disjoint SM1 SM2}
    true.

- : shift-inside-preserves-deep-disjoint
    D shift/0 _ deep-disjoint/L.

- : shift-inside-preserves-deep-disjoint
    D _ shift/0 deep-disjoint/R.

- : shift-inside-preserves-deep-disjoint
    (deep-disjoint/= M1<>M2 D1<>D2 nat`eq/)
    (shift/+ P1) (shift/+ P2) M3<>M4
    <- shift-preserves-deep-disjoint 
      M1<>M2 (shift/+ P1) (shift/+ P2) M3<>M4.

- : shift-inside-preserves-deep-disjoint
    (deep-disjoint/< A P) (shift/+ P1) (shift/+ P2) DD
    <- plus-swap-succ P PS
    <- plus-commutative PS PP
    <- shift-preserves-deep-disjoint
      A (shift/+ P1) (shift/+ PP) DPPP
    <- shift-inside-right-preserves-deep-disjoint
      DPPP (shift/+ P2) DD.

- : shift-inside-preserves-deep-disjoint
    (deep-disjoint/> D P) (shift/+ P1) (shift/+ P2) DD
    <- plus-swap-succ P PS
    <- plus-commutative PS PP
    <- shift-preserves-deep-disjoint 
      D (shift/+ PP) (shift/+ P2) DPPP
    <- shift-inside-left-preserves-deep-disjoint
      DPPP (shift/+ P1) DD.

%worlds () (shift-inside-preserves-deep-disjoint _ _ _ _).
%total  {} (shift-inside-preserves-deep-disjoint _ _ _ _).


%%% shouldn't need this lemma!

%theorem update-disjoint-implies-disjoint/L :
    forall* {N} {D1} {D2} {M} {MP}
    forall  {U: update M N D2 MP}
            {D: data`disjoint D1 D2}
    exists  {D: deep-disjoint (map/+ N D1 map/0) MP}
    true.

- : update-disjoint-implies-disjoint/L
    update/0 X
    (deep-disjoint/= deep-disjoint/L X nat`eq/).

- : update-disjoint-implies-disjoint/L
    (update/> U P) X (deep-disjoint/> DD P)
    <- update-disjoint-implies-disjoint/L U X DD.

- : update-disjoint-implies-disjoint/L 
    (update/< P) X 
    (deep-disjoint/= deep-disjoint/L X nat`eq/).

- : update-disjoint-implies-disjoint/L
    (update/= nat`eq/) X
    (deep-disjoint/= deep-disjoint/L X nat`eq/).

%worlds () (update-disjoint-implies-disjoint/L _ _ _).
%total  (U) (update-disjoint-implies-disjoint/L U _ _).


%theorem update-disjoint-implies-disjoint :
    forall* {XM1} {XM2} {M1} {M2} {L} {XM1S} {XM2S}
    forall  {D: deep-disjoint XM1 XM2}
            {U: update XM1 L M1 XM1S}
            {U: update XM2 L M2 XM2S}
            {D: data`disjoint M1 M2}
    exists  {D: deep-disjoint XM1S XM2S}
    true.

- : update-disjoint-implies-disjoint 
    _ update/0 update/0 X
    (deep-disjoint/= deep-disjoint/L X nat`eq/).

- : update-disjoint-implies-disjoint
    _ update/0 (update/= nat`eq/)
    M1<>M2 (deep-disjoint/= deep-disjoint/L M1<>M2 nat`eq/).

- : update-disjoint-implies-disjoint
    _ (update/= nat`eq/) update/0 X
    (deep-disjoint/= deep-disjoint/R X nat`eq/).

- : update-disjoint-implies-disjoint
    deep-disjoint/L update/0 (update/> U P) X 
    (deep-disjoint/> DD P)
    <- update-disjoint-implies-disjoint/L U X DD.
      
- : update-disjoint-implies-disjoint
    deep-disjoint/R (update/> U P) update/0 X 
    (deep-disjoint/< DD P)
    <- data`disjoint-symmetric X XP
    <- update-disjoint-implies-disjoint/L U XP DP
    <- deep-disjoint-symmetric DP DD.

- : update-disjoint-implies-disjoint
    _ (update/< P) update/0 X 
    (deep-disjoint/= deep-disjoint/R X nat`eq/).
      
- : update-disjoint-implies-disjoint
    XM1<>XM2 (update/= nat`eq/) (update/= nat`eq/)
    IM1<>IM2 (deep-disjoint/= XM1S<>XM2S IM1<>IM2 nat`eq/)
    <- deep-disjoint/=-inversion XM1<>XM2 nat`eq/ _ XM1S<>XM2S.

- : update-disjoint-implies-disjoint
    D (update/< P) (update/= nat`eq/) M1<>M2
    (deep-disjoint/= DP M1<>M2 nat`eq/)
    <- deep-disjoint/>-inversion D P DP.

- : update-disjoint-implies-disjoint
    D (update/= nat`eq/) (update/< P) M1<>M2
    (deep-disjoint/= DP M1<>M2 nat`eq/)
    <- deep-disjoint/<-inversion D P DP.


- : update-disjoint-implies-disjoint
    D (update/> U P) (update/= nat`eq/) M1<>M2 
    (deep-disjoint/< DD P)
    <- deep-disjoint/<-inversion D P DP
    <- update-disjoint-implies-disjoint 
      DP U (update/= nat`eq/) M1<>M2 DD.

- : update-disjoint-implies-disjoint D
    (update/= nat`eq/) (update/> U P) X 
    (deep-disjoint/> DD P)
    <- deep-disjoint/>-inversion D P D1
    <- update-disjoint-implies-disjoint
      D1 (update/= nat`eq/) U X DD.
         
- : update-disjoint-implies-disjoint
    D (update/> U P) (update/< P1) M1<>M2
    (deep-disjoint/< DPP P)
    <- plus-associative-converse P P1 N6 SN4+SN5=N6 N6+N1=N2
    <- plus-left-preserves-positive SN4+SN5=N6 nat`eq/ _ EQ
    <- plus-respects-eq SN4+SN5=N6 nat`eq/ nat`eq/ EQ (plus/s N4+SN5=N6)
    <- plus-right-preserves-positive N4+SN5=N6 nat`eq/ _ EQ2
    <- plus-respects-eq N6+N1=N2 EQ nat`eq/ nat`eq/ SN8+N1=N2
    <- deep-disjoint/<-inversion D SN8+N1=N2 DP
    <- plus-swap-succ-converse N4+SN5=N6 SN4+N5=N6
    <- update-disjoint-implies-disjoint 
      DP U (update/< SN4+N5=N6) M1<>M2 DPP.

- : update-disjoint-implies-disjoint
    D (update/< P1) (update/> U P) M1<>M2 
    (deep-disjoint/> DPP P)
    <- plus-associative-converse P P1 N6 SN4+SN5=N6 N6+N1=N2
    <- plus-left-preserves-positive SN4+SN5=N6 nat`eq/ _ EQ
    <- plus-respects-eq SN4+SN5=N6 nat`eq/ nat`eq/ EQ (plus/s N4+SN5=N6)
    <- plus-right-preserves-positive N4+SN5=N6 nat`eq/ _ EQ2
    <- plus-respects-eq N6+N1=N2 EQ nat`eq/ nat`eq/ SN8+N1=N2
    <- deep-disjoint/>-inversion D SN8+N1=N2 DP
    <- plus-swap-succ-converse N4+SN5=N6 SN4+N5=N6
    <- update-disjoint-implies-disjoint
      DP (update/< SN4+N5=N6) U M1<>M2 DPP.

- : update-disjoint-implies-disjoint
    D (update/< P1) (update/< P2) M1<>M2 
    (deep-disjoint/= DP M1<>M2 nat`eq/)
    <- plus-swap-succ P1 P1S
    <- plus-commutative P1S P1P
    <- plus-swap-succ P2 P2S
    <- plus-commutative P2S P2P
    <- shift-preserves-deep-disjoint-converse
      D (shift/+ P1P) (shift/+ P2P) DP.

- : update-disjoint-implies-disjoint
    (deep-disjoint/= M1<>M2 D1<>D2 nat`eq/)
    (update/> U1 P1) (update/> U2 P2) DDD
    (deep-disjoint/= M1<>M2' D1<>D2 nat`eq/)
    <- plus-right-cancels P1 P2 nat`eq/ nat`eq/ E
    <- succ-cancels E EP
    <- update-respects-eq 
      U1 eq/ EP data`eq/ eq/ U1P
    <- update-disjoint-implies-disjoint M1<>M2 U1P U2 DDD M1<>M2'.
      
- : update-disjoint-implies-disjoint
    (deep-disjoint/< D P)
    (update/> U1 P1)
    (update/> U2 P2) DDD (deep-disjoint/< XXX P)
    <- plus-associative-converse P P2 _ P3 P4
    <- plus-right-cancels P4 P1 nat`eq/ nat`eq/ E
    <- plus-respects-eq P3 nat`eq/ nat`eq/ E P5
    <- plus-right-decrease P5 _ EE P7
    <- succ-cancels EE EQ
    <- nat`eq-symmetric EQ EQP
    <- plus-respects-eq P7 nat`eq/ nat`eq/ EQP P6
    <- update-disjoint-implies-disjoint 
      D U1 (update/> U2 P6) DDD XXX. 

- : update-disjoint-implies-disjoint
    (deep-disjoint/> D P)
    (update/> U1 P1) (update/> U2 P2) DDD
    (deep-disjoint/> D1 P)
    <- plus-associative-converse P P1 _ P3 P4
    <- plus-right-cancels P4 P2 nat`eq/ nat`eq/ E
    <- plus-respects-eq P3 nat`eq/ nat`eq/ E P5
    <- plus-right-decrease P5 _ EE P7
    <- succ-cancels EE EQ
    <- nat`eq-symmetric EQ EQP
    <- plus-respects-eq P7 nat`eq/ nat`eq/ EQP P6
    <- update-disjoint-implies-disjoint
      D (update/> U1 P6) U2 DDD D1.

- : update-disjoint-implies-disjoint
    _ update/0 (update/< _) M1<>M2 
    (deep-disjoint/= deep-disjoint/L M1<>M2 nat`eq/).

%worlds () (update-disjoint-implies-disjoint _ _ _ _ _).
%total (D) (update-disjoint-implies-disjoint D _ _ _ _).



%{%
#ifdef DATA_JOIN_IS_LUB
%}%

%theorem deep-disjoint-leq-implies-join-leq* :
  	forall* {C1} {C2} {C} {C3}
	  forall	{D: deep-disjoint C1 C2}
		        {L1:leq C1 C}
         		{L2:leq C2 C}
        		{J: join C1 C2 C3}
   	exists	{L3:leq C3 C}
  	true.

- : deep-disjoint-leq-implies-join-leq*
    (deep-disjoint/= C1^C2 S1^S2 nat`eq/)
    (leq/= C1<=C S1<=S nat`eq/)
    (leq/= C2<=C S2<=S nat`eq/) J LEQ
    <- join/=-inversion J nat`eq/ _ _ S1US2=S3 C1UC2=C3 C3=C4
    <- deep-disjoint-leq-implies-join-leq* C1^C2 C1<=C C2<=C C1UC2=C3 C3<=C
    <- data`join-is-lub S1US2=S3 S1<=S S2<=S S3<=S
    <- eq-symmetric C3=C4 C4=C3
    <- leq-respects-eq (leq/= C3<=C S3<=S nat`eq/) C4=C3 eq/ LEQ.

- : deep-disjoint-leq-implies-join-leq*
    (deep-disjoint/= _ _ nat`eq/)
    (leq/> _ SN3+N1=N1) (leq/= _ _ nat`eq/) J LEQ
    <- plus-implies-gt SN3+N1=N1 nat`eq/ N1>N1
    <- nat`gt-anti-reflexive N1>N1 F
    <- false-implies-leq F LEQ.

- : deep-disjoint-leq-implies-join-leq*
    (deep-disjoint/= _ _ nat`eq/)
    (leq/= _ _ nat`eq/) (leq/> _ SN3+N1=N1) J LEQ
    <- plus-implies-gt SN3+N1=N1 nat`eq/ N1>N1
    <- nat`gt-anti-reflexive N1>N1 F
    <- false-implies-leq F LEQ.

- : deep-disjoint-leq-implies-join-leq* 
    (deep-disjoint/= C1^C2 S1^S2 nat`eq/)
    (leq/> K1C1<=C SK1+N=N1) (leq/> K2C2<=C SK2+N=N1) J LEQ
    <- join/=-inversion J nat`eq/ _ _ S1US2=S3 C1UC2=C3 C3=C4
    <- plus-right-cancels SK1+N=N1 SK2+N=N1 nat`eq/ nat`eq/ SK1=SK2
    <- succ-cancels SK1=SK2 K1=K2
    <- deep-disjoint-leq-implies-join-leq* 
      (deep-disjoint/= C1^C2 S1^S2 K1=K2) K1C1<=C K2C2<=C 
      (join/= C1UC2=C3 S1US2=S3 K1=K2) K1C3<=C
    <- eq-symmetric C3=C4 C4=C3
    <- leq-respects-eq (leq/> K1C3<=C SK1+N=N1) C4=C3 eq/ LEQ.

- : deep-disjoint-leq-implies-join-leq* 
    deep-disjoint/L _ C2<=C Z+C2=C3 C3<=C
    <- join-deterministic join/L Z+C2=C3 eq/ eq/ C2=C3
    <- leq-respects-eq C2<=C C2=C3 eq/ C3<=C.

- : deep-disjoint-leq-implies-join-leq* deep-disjoint/R C1<=C _ C1+0=C3 C3<=C
    <- join-deterministic join/R C1+0=C3 eq/ eq/ C1=C3
    <- leq-respects-eq C1<=C C1=C3 eq/ C3<=C.

- : deep-disjoint-leq-implies-join-leq* 
	(deep-disjoint/< C1^C022 P) 
	(leq/= C1<=C4 D1<=D4 nat`eq/) 
	C222<=C444 C111+C222=C333 C333<=C444
    <- join/<-inversion C111+C222=C333 P _ C1+C022=C5 C333=C115
    <- leq/>-inversion C222<=C444 P C022<=C4
    <- deep-disjoint-leq-implies-join-leq* 
	C1^C022 C1<=C4 C022<=C4 C1+C022=C5 C5<=C4
    <- eq-symmetric C333=C115 C115=C333
    <- leq-respects-eq 
	(leq/= C5<=C4 D1<=D4 nat`eq/) C115=C333 eq/ C333<=C444.

- : deep-disjoint-leq-implies-join-leq* (deep-disjoint/< C1^C022 N0+1+N1=N2) (leq/> C611<=C4 N6+1+N4=N1) C222<=C444 C111+C222=C333 C333<=C444
    <- join/<-inversion C111+C222=C333 N0+1+N1=N2 _ C1+C022=C5 C333=C115
    <- plus-swap-succ N6+1+N4=N1 N6+N4+1=N1
    <- plus-associative-converse 
	N6+N4+1=N1 N0+1+N1=N2 N7 N0+1+N6=N7 N7+N4+1=N2
    <- plus-swap-succ-converse N7+N4+1=N2 N7+1+N4=N2
    <- leq/>-inversion C222<=C444 N7+1+N4=N2 C722<=C4
    <- deep-disjoint-leq-implies-join-leq* 
	(deep-disjoint/< C1^C022 N0+1+N6=N7) 
	C611<=C4 C722<=C4 
	(join/< C1+C022=C5 N0+1+N6=N7) C615<=C4
    <- eq-symmetric C333=C115 C115=C333
    <- leq-respects-eq 
	(leq/> C615<=C4 N6+1+N4=N1) C115=C333 eq/ C333<=C444.

- : deep-disjoint-leq-implies-join-leq* 
	(deep-disjoint/> C011^C2 P) 
	C111<=C444 (leq/= C2<=C4 D2<=D4 nat`eq/) 
	C111+C222=C333 C333<=C444
    <- join/>-inversion C111+C222=C333 P _ C011+C2=C5 C333=C225
    <- leq/>-inversion C111<=C444 P C011<=C4
    <- deep-disjoint-leq-implies-join-leq* 
	C011^C2 C011<=C4 C2<=C4 C011+C2=C5 C5<=C4
    <- eq-symmetric C333=C225 C225=C333
    <- leq-respects-eq 
	(leq/= C5<=C4 D2<=D4 nat`eq/) C225=C333 eq/ C333<=C444.

- : deep-disjoint-leq-implies-join-leq* 
	(deep-disjoint/> C011^C2 N0+1+N2=N1) 
	C111<=C444 (leq/> C622<=C4 N6+1+N4=N2)
	C111+C222=C333 C333<=C444
    <- join/>-inversion C111+C222=C333 N0+1+N2=N1 _ C011+C2=C5 C333=C225
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-associative-converse 
	N6+N4+1=N2 N0+1+N2=N1 N7 N0+1+N6=N7 N7+N4+1=N1
    <- plus-swap-succ-converse N7+N4+1=N1 N7+1+N4=N1
    <- leq/>-inversion C111<=C444 N7+1+N4=N1 C711<=C4
    <- deep-disjoint-leq-implies-join-leq* 
	(deep-disjoint/> C011^C2 N0+1+N6=N7) 
	C711<=C4 C622<=C4 
	(join/> C011+C2=C5 N0+1+N6=N7) C625<=C4
    <- eq-symmetric C333=C225 C225=C333
    <- leq-respects-eq 
	(leq/> C625<=C4 N6+1+N4=N2) C225=C333 eq/ C333<=C444.

%worlds () (deep-disjoint-leq-implies-join-leq* _ _ _ _ _).
%total (L) (deep-disjoint-leq-implies-join-leq* _ L _ _ _).

%{%
#endif /* DATA_JOIN_IS_LUB */
%}%