%%% Effect Map
%%% $Id: efxmap-base.elf,v 1.2 2013/05/29 16:57:11 csun Exp csun $


% Well-formed efxmap contains non-empty inner-efxmap as value

inner-efxmap`wf : inner-efxmap -> type.

inner-efxmap`wf/ : inner-efxmap`wf D <- inner-efxmap`size D (nat`s _).


inner-efxmap`nwf : inner-efxmap -> type.

inner-efxmap`nwf/ : inner-efxmap`nwf D <- inner-efxmap`size D nat`z.


inner-efxmap`join-preserves-wf
  : inner-efxmap`wf D1
    -> inner-efxmap`wf D2
    -> inner-efxmap`join D1 D2 D3
    -> inner-efxmap`wf D3
    -> type.
%mode inner-efxmap`join-preserves-wf +W1 +W2 +J -W3.

- : inner-efxmap`join-preserves-wf 
    (inner-efxmap`wf/ SZ1) (inner-efxmap`wf/ SZ2) J (inner-efxmap`wf/ SZ3P)
    <- inner-efxmap`join-implies-leq J LE _
    <- inner-efxmap`size-total SZ3
    <- inner-efxmap`leq-implies-size-le LE SZ1 SZ3 GE
    <- nat`ge-implies-plus GE _ P
    <- nat`plus-right-preserves-positive P nat`eq/ _ EQ
    <- inner-efxmap`size-respects-eq SZ3 inner-efxmap`eq/ EQ SZ3P.

%worlds () (inner-efxmap`join-preserves-wf _ _ _ _).
%total { } (inner-efxmap`join-preserves-wf _ _ _ _).


inner-efxmap`wf-nwf-contradiction
  : inner-efxmap`wf D
    -> inner-efxmap`nwf D
    -> void 
    -> type.
%mode inner-efxmap`wf-nwf-contradiction +W +NW -V.

- : inner-efxmap`wf-nwf-contradiction 
    (inner-efxmap`wf/ SZ1) (inner-efxmap`nwf/ SZ2) V
    <- inner-efxmap`size-unique SZ2 SZ1 inner-efxmap`eq/ E
    <- nat`eq-contradiction E V.

%worlds () (inner-efxmap`wf-nwf-contradiction _ _ _).
%total { } (inner-efxmap`wf-nwf-contradiction _ _ _).


inner-efxmap`leq-preserves-wf
  : inner-efxmap`wf D
    -> inner-efxmap`leq D DP
    -> inner-efxmap`wf DP
    -> type.
%mode inner-efxmap`leq-preserves-wf +W +L -WP.

- : inner-efxmap`leq-preserves-wf
    (inner-efxmap`wf/ SZ) LE (inner-efxmap`wf/ SZ2)
    <- inner-efxmap`size-total SZP
    <- inner-efxmap`leq-implies-size-le LE SZ SZP GE
    <- nat`ge-implies-plus GE _ P
    <- nat`plus-right-preserves-positive P nat`eq/ _ EQ
    <- inner-efxmap`size-respects-eq SZP inner-efxmap`eq/ EQ SZ2.

%worlds () (inner-efxmap`leq-preserves-wf _ _ _).
%total { } (inner-efxmap`leq-preserves-wf _ _ _).



% Restricting a inner-efxmap according to a tgtmap 

trans : nat -> inner-efxmap -> tgtmap -> inner-efxmap -> type.

trans/in : tgtmap`lookup GM N S
         -> inner-efxmap`restrict M S MP
         -> trans N M GM MP.

trans/out : tgtmap`fresh GM N
            -> trans N _ GM inner-efxmap/0.


trans-unique
  : trans N D1 X1 D1P
    -> trans N D2 X2 D2P
    -> inner-efxmap`eq D1 D2
    -> tgtmap`eq X1 X2
    -> inner-efxmap`eq D1P D2P
    -> type.
%mode trans-unique +T1 +T2 +E1 +E2 -E3.

- : trans-unique 
    (trans/in L1 R1) (trans/in L2 R2)
    D1=D2 X1=X2 D1P=D2P
    <- tgtmap`lookup-unique L1 L2 X1=X2 nat`eq/ S1=S2
    <- inner-efxmap`restrict-unique R1 R2 D1=D2 S1=S2 D1P=D2P. 

- : trans-unique
    (trans/out _) (trans/out _) _ _ inner-efxmap`eq/.

- : trans-unique
    (trans/in L _) (trans/out F) D1=D2 X1=X2 D1P=D2P
    <- tgtmap`lookup-respects-eq L X1=X2 nat`eq/ set`eq/ LP
    <- tgtmap`fresh-lookup-not-equal F LP N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- inner-efxmap`false-implies-eq V D1P=D2P.

- : trans-unique
    (trans/out F) (trans/in L _) D1=D2 X1=X2 D1P=D2P
    <- tgtmap`lookup-respects-eq L X1=X2 nat`eq/ set`eq/ LP
    <- tgtmap`fresh-lookup-not-equal F LP N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- inner-efxmap`false-implies-eq V D1P=D2P.

%worlds () (trans-unique _ _ _ _ _).
%total  {} (trans-unique _ _ _ _ _).


trans-total* : {N} {D} {X} {DP} trans N D X DP -> type.
%mode trans-total* +N +D +X -DP -T.

trans-total*/L
  : {N} {D} {X} {B} tgtmap`domain? X N B
    -> {DP} trans N D X DP
    -> type.
%mode trans-total*/L +N +D +X +B +DM -DP -T.

- : trans-total*/L _ _ _ true
    (tgtmap`domain?/in L) _ (trans/in L R)
    <- inner-efxmap`restrict-total R.

- : trans-total*/L _ _ _ false
    (tgtmap`domain?/out F) _ (trans/out F).

%worlds () (trans-total*/L _ _ _ _ _ _ _).
%total  {} (trans-total*/L _ _ _ _ _ _ _).

- : trans-total* N D X DP T
    <- tgtmap`domain?-total DM?
    <- trans-total*/L N D X B DM? DP T.

%worlds () (trans-total* _ _ _ _ _).
%total  {} (trans-total* _ _ _ _ _).


trans-right-preserves-leq*
  : inner-efxmap`leq D1 D2
    -> trans N D1 X D1P
    -> trans N D2 X D2P
    -> inner-efxmap`leq D1P D2P
    -> type.
%mode trans-right-preserves-leq* +LE1 +T1 +T2 -LE2.

- : trans-right-preserves-leq*
    D1<=D2 (trans/in L1 R1) (trans/in L2 R2) D1P<=D2P
    <- tgtmap`lookup-unique L1 L2 tgtmap`eq/ nat`eq/ S1=S2
    <- inner-efxmap`restrict-respects-eq R1 inner-efxmap`eq/ S1=S2
    inner-efxmap`eq/ R1x
    <- inner-efxmap`restrict-right-preserves-leq D1<=D2 R1x R2 D1P<=D2P.

- : trans-right-preserves-leq*
    _ (trans/out _) (trans/out _) D1P<=D2P
    <- inner-efxmap`leq-reflexive _ D1P<=D2P.

- : trans-right-preserves-leq*
    _ (trans/in L _) (trans/out F) LE
    <- tgtmap`fresh-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- inner-efxmap`false-implies-leq V LE.

- : trans-right-preserves-leq*
    _ (trans/out F) (trans/in L _) LE
    <- tgtmap`fresh-lookup-not-equal F L N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- inner-efxmap`false-implies-leq V LE.

%worlds () (trans-right-preserves-leq* _ _ _ _).
%total  {} (trans-right-preserves-leq* _ _ _ _).


trans-left-preserves-leq*
  : tgtmap`leq X1 X2
    -> trans N D X1 D1P
    -> trans N D X2 D2P
    -> inner-efxmap`leq D1P D2P
    -> type.
%mode trans-left-preserves-leq* +LE1 +T1 +T2 -LE2.

- : trans-left-preserves-leq*
    X1<=X2 (trans/in L1 R1) (trans/in L2 R2) D1P<=D2P
    <- tgtmap`lookup-respects-leq* L1 X1<=X2 L2 S1<=S2
    <- inner-efxmap`restrict-left-preserves-leq S1<=S2 R1 R2 D1P<=D2P.

- : trans-left-preserves-leq*
    _ (trans/out _) (trans/out _) LE
    <- inner-efxmap`leq-reflexive _ LE.

- : trans-left-preserves-leq*
    X1<=X2 (trans/in L _) (trans/out F) LE
    <- tgtmap`lookup-respects-leq L X1<=X2 _ LP _
    <- tgtmap`fresh-lookup-not-equal F LP N<>N
    <- nat`ne-anti-reflexive N<>N V
    <- inner-efxmap`false-implies-leq V LE.

- : trans-left-preserves-leq*
    X1<=X2 (trans/out F) (trans/in L _) inner-efxmap`leq/0.

%worlds () (trans-left-preserves-leq* _ _ _ _).
%total  {} (trans-left-preserves-leq* _ _ _ _).


trans-implies-leq
  : trans N M1 GM M2
    -> inner-efxmap`leq M2 M1
    -> type.
%mode trans-implies-leq +T -LE.

- : trans-implies-leq (trans/in _ R) LE
    <- inner-efxmap`restrict-implies-leq R LE.

- : trans-implies-leq (trans/out _) inner-efxmap`leq/0.

%worlds () (trans-implies-leq _ _).
%total { } (trans-implies-leq _ _).


fresh-update-preserves-trans-converse
  : trans N1 M GM MP
    -> tgtmap`fresh GMP N2
    -> tgtmap`update GMP N2 S GM
    -> nat`ne N1 N2 
    -> trans N1 M GMP MP
    -> type.
%mode fresh-update-preserves-trans-converse +T1 +F1 +U1 +NE -T2.

- : fresh-update-preserves-trans-converse
    (trans/in L R) F U NE (trans/in LP R)
    <- tgtmap`update-preserves-lookup-converse L U NE LP.

- : fresh-update-preserves-trans-converse
    (trans/out FP) F U _ (trans/out FPP)
    <- tgtmap`fresh-update-implies-leq F U LE
    <- tgtmap`fresh-respects-geq FP LE FPP.

%worlds () (fresh-update-preserves-trans-converse _ _ _ _ _).
%total { } (fresh-update-preserves-trans-converse _ _ _ _ _).


%{%
#define data inner-efxmap
#define arg tgtmap
#define DATA_JOIN_DETERMINISTIC 1
#define DATA_JOIN_COMMUTATIVE 1
#define DATA_JOIN_IMPLIES_LEQ 1
#define DATA_JOIN_ASSOCIATIVE 1
#define MAP_TRANS_UNIQUE 1
#define MAP_TRANS_TOTAL 1
#define MAP_TRANS_LEQ 1
BEGIN_ELF
#include "map-base.elf"
#include "map-leq.elf"
#include "map-join.elf"
#include "map-domain.elf"
#include "map-deep-disjoint.elf"
#include "map-restrict.elf"
#include "map-restrict-extra.elf"
#include "map-trans.elf"
#include "map-wf.elf"
END_ELF
#undef data
#undef arg
%}%

%%% Renamings

%abbrev efxmap = map.
%abbrev efxmap/0 = map/0.
%abbrev efxmap/+ = map/+.
%abbrev efxmap/1 : nat -> nat -> efx -> map
  = [N][F][X] (map/+ N (inner-efxmap/+ F X inner-efxmap/0) map/0).