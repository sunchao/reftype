%%% Mapping from (obj,field) to efx
%%% $Id$


efx`is-consume? : efx -> bool -> type.

efx`is-consume?/read : efx`is-consume? efx/read false.

efx`is-consume?/write : efx`is-consume? efx/write false.

efx`is-consume?/consume : efx`is-consume? efx/consume true.

%abbrev efx`is-consume?@ : nat -> efx -> bool -> type = [N][X][B] efx`is-consume? X B.


%{%
#define data efx
#define relation efx`is-consume?@
#define allrelation is-consume?
#define arg bool
#define DATA_JOIN_DETERMINISTIC 1
#define DATA_JOIN_IMPLIES_LEQ 1
#define DATA_JOIN_ASSOCIATIVE 1
#define DATA_JOIN_COMMUTATIVE 1
#define DATA_JOIN_DISJOINT_RIGHT_LEQ_IMPLIES_LEQ 1
#define DATA_NE 1
BEGIN_ELF
#include "map-base.elf"
#include "map-leq.elf"
#include "map-join.elf"
#include "map-domain.elf"
#include "map-restrict.elf"
#include "map-all.elf"
END_ELF
#undef arg
#undef data
%}%


%%% Extra theorems about is-consume?


%theorem efx`no-consume-respects-geq
  : forall* {X} {XP}
    forall {PX: efx`is-consume? X false}
    {L: efx`leq XP X}
    exists {PX: efx`is-consume? XP false}
    true.

- : efx`no-consume-respects-geq
    efx`is-consume?/read (efx`geq/= efx`eq/) efx`is-consume?/read.

- : efx`no-consume-respects-geq
    efx`is-consume?/write (efx`geq/> efx`grt/wr) efx`is-consume?/read.

- : efx`no-consume-respects-geq
    efx`is-consume?/write (efx`geq/= efx`eq/) efx`is-consume?/write.

%worlds () (efx`no-consume-respects-geq _ _ _).
%total {} (efx`no-consume-respects-geq _ _ _).


%theorem no-consume-respects-geq
  : forall* {M} {MP}
    forall {PX: is-consume? M false}
    {L: leq MP M}
    exists {PX: is-consume? MP false}
    true.

- : no-consume-respects-geq _ leq/0 is-consume?/0.

%theorem no-consume-respects-geq/L
  : forall* {M} {MP} {MS} {N} {X} {B}
    forall {PX: is-consume? MS false}
    {F: fresh MS N}
    {U: update MS N X M}
    {PX: efx`is-consume? X false}
    {L: leq MP M}
    {DM?: domain? MP N B}
    exists {PX: is-consume? MP false}
    true.

- : no-consume-respects-geq/L
    PX-MS FS US PX-X MP<=M (domain?/in L) (is-consume?/U PX-MK PX-XP FK UK)
    <- lookup-implies-fresh-update L MK FK UK
    <- fresh-update-preserves-leq-converse MP<=M FK UK FS US MK<=MS XP<=X
    <- no-consume-respects-geq PX-MS MK<=MS PX-MK
    <- efx`no-consume-respects-geq PX-X XP<=X PX-XP.

- : no-consume-respects-geq/L PX-MS FS US PX-X MP<=M (domain?/out FP) PX-MP
    <- fresh-update2-preserves-leq-converse MP<=M FP FS US MP<=MS
    <- no-consume-respects-geq PX-MS MP<=MS PX-MP.

- : no-consume-respects-geq (is-consume?/U PX-MS PX-X FS US) MP<=M PX-MP
    <- domain?-total DM?
    <- no-consume-respects-geq/L PX-MS FS US PX-X MP<=M DM? PX-MP.

%worlds () (no-consume-respects-geq _ _ _)
	(no-consume-respects-geq/L _ _ _ _ _ _ _).
%total (P1 P2) (no-consume-respects-geq P1 _ _)
	(no-consume-respects-geq/L P2 _ _ _ _ _ _).


% We want something stronger than map-restrict - we need
% to keep BOTH the selected ones and the "unselected" ones.

partition : map -> set -> map -> map -> type.

partition/ : domain M R
             -> set`remove R S Q
             -> restrict M Q M1
             -> restrict M S M2
             -> partition M S M1 M2.


%%% Theorems about partition

%theorem partition-implies-leq
  : forall* {M} {S} {M1} {M2}
    forall {P: partition M S M1 M2}
    exists {M1<=M: leq M1 M} {M2<=M: leq M2 M}
    true.

- : partition-implies-leq (partition/ DM RM R1 R2) LE1 LE2
    <- restrict-implies-leq R1 LE1
    <- restrict-implies-leq R2 LE2.

%worlds () (partition-implies-leq _ _ _).
%total {} (partition-implies-leq _ _ _).




%%% Exports

%abbrev efxmap = map.
%abbrev efxmap/0 = map/0.
%abbrev efxmap/+ = map/+.
