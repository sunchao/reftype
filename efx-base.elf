% Unit Effect
% $Id: efx-base.elf,v 1.6 2013/09/28 16:35:04 csun Exp csun $

%%% Definitions

efx : type.	%name efx X.

efx/read : efx.

efx/write : efx.


% equality

eq : efx -> efx -> type.

eq/ : eq X X.


% grt

grt : efx -> efx -> type.

grt/wr : grt efx/write efx/read.


% compare

cmp : efx -> efx -> comp -> type.

cmp/= : cmp X X equal.

cmp/< : cmp X Y less <- grt Y X.

cmp/> : cmp X Y greater <- grt X Y.


% join

join : efx -> efx -> efx -> type.

join/= : join X X X.

join/< : join X1 X2 X2 <- grt X2 X1.

join/> : join X1 X2 X1 <- grt X1 X2.


%%% Basic Theorems

%theorem false-implies-grt
  : forall* {X1} {X2} forall {F:void} exists {X1>X2: grt X1 X2} true.

%worlds () (false-implies-grt _ _).
%total {} (false-implies-grt _ _).


%theorem grt-anti-reflexive
  : forall* {X} forall {X>X: grt X X} exists {F:void} true.

%worlds () (grt-anti-reflexive _ _).
%total {} (grt-anti-reflexive _ _).


%theorem grt-transitive
  : forall* {X1} {X2} {X3}
    forall {X1>X2: grt X1 X2}
    {X2>X3: grt X2 X3}
    exists {X1>X3: grt X1 X3}
    true.

%worlds () (grt-transitive _ _ _).
%total {} (grt-transitive _ _ _).


%theorem grt-anti-symmetric
  : forall* {X1} {X2}
    forall {X1>X2: grt X1 X2}
    {X2>X1: grt X2 X1}
    exists {F:void}
    true.

%worlds () (grt-anti-symmetric _ _ _).
%total {} (grt-anti-symmetric _ _ _).


%theorem cmp-total*
  : forall {X1} {X2}
    exists {CMP} {P: cmp X1 X2 CMP}
    true.

- : cmp-total* _ _ equal cmp/=.

- : cmp-total* efx/read efx/write less (cmp/< grt/wr).

- : cmp-total* efx/write efx/read greater (cmp/> grt/wr).

%worlds () (cmp-total* _ _ _ _).
%total {} (cmp-total* _ _ _ _).

%abbrev cmp-total = cmp-total* _ _ _.

%{%
#define TYPE efx
#define EQ eq
#define GT grt
#define GE geq
#define NE ne
#define COMP cmp
#define LT ltn
#define LE leq
BEGIN_ELF
#include "EQ.i"
#include "GE.i"
#include "NE.i"
#include "LT.i"
#include "LE.i"
END_ELF
%}%


%theorem grt-respects-eq :
 forall* {X1} {X2} {X1P} {X2P}
 forall {G:grt X1 X2} {E1:eq X1 X1P} {E2:eq X2 X2P}
 exists {GP:grt X1P X2P}
 true.

- : grt-respects-eq X1>X2 eq/ eq/ X1>X2.

%worlds () (grt-respects-eq X1>X2 X1=X1P X2=X2P %{=>}% X1P>X2P).
%total {} (grt-respects-eq _ _ _ _).


% Definition for leq/nle

%abbrev nle = grt.

%abbrev false-implies-nle = false-implies-grt.

%abbrev nle-respects-eq = grt-respects-eq.

%abbrev nle-anti-reflexive = grt-anti-reflexive.



leq? : efx -> efx -> bool -> type.


leq?/yes : leq X1 X2 -> leq? X1 X2 true.

leq?/no : nle X1 X2 -> leq? X1 X2 false.



%theorem nle-implies-ne :
 forall* {X1} {X2}
 forall {G:grt X1 X2}
 exists {N:ne X1 X2}
 true.

- : nle-implies-ne X1>X2 (ne/> X1>X2).

%worlds () (nle-implies-ne _ _).
%total { } (nle-implies-ne _ _).


%theorem leq-nle-contradiction :
 forall* {X1} {X2}
 forall {L:leq X1 X2}
        {G:grt X1 X2}
 exists {F:void}
 true.

- : leq-nle-contradiction X2>=X1 X1>X2 F
    <- geq-transitive-grt X2>=X1 X1>X2 X2>X2
    <- grt-anti-reflexive X2>X2 F.

%worlds () (leq-nle-contradiction _ _ _).
%total { } (leq-nle-contradiction _ _ _).



%%% Theorems about leq?


%theorem leq?-total* :
 forall {X1} {X2}
 exists {B} {L:leq? X1 X2 B}
 true.

%abbrev leq?-total = leq?-total* _ _ _.

%theorem leq?-total** :
 forall* {X1} {X2} {C}
 forall {CMP:cmp X1 X2 C}
 exists {B} {L?:leq? X1 X2 B}
 true.

- : leq?-total L?
    <- cmp-total CMP
    <- leq?-total** CMP _ L?.

- : leq?-total** (cmp/< X1<X2) _ (leq?/yes (geq/> X1<X2)).

- : leq?-total** (cmp/=) _ (leq?/yes (geq/= eq/)).

- : leq?-total** (cmp/> X1>X2) _ (leq?/no X1>X2).

%worlds () (leq?-total** _ _ _).
%total { } (leq?-total** _ _ _).

%worlds () (leq?-total* _ _ _ _).
%total { } (leq?-total* _ _ _ _).



%%% Theorems about join

%theorem false-implies-join
  : forall* {X1} {X2} {X3}
    forall {F:void}
    exists {J: join X1 X2 X3}
    true.

%worlds () (false-implies-join _ _).
%total {} (false-implies-join _ _).


%theorem join-respects-eq
  : forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
    forall {J: join X1 X2 X3}
    {E: eq X1 Y1} {E: eq X2 Y2}
    {E: eq X3 Y3}
    exists {J: join Y1 Y2 Y3}
    true.

- : join-respects-eq J eq/ eq/ eq/ J.

%worlds () (join-respects-eq _ _ _ _ _).
%total {} (join-respects-eq _ _ _ _ _).


%theorem join-deterministic
  : forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
    forall {J: join X1 X2 X3} {J: join Y1 Y2 Y3}
    {E: eq X1 Y1} {E: eq X2 Y2}
    exists {E: eq X3 Y3}
    true.

- : join-deterministic J J eq/ eq/ eq/.

%worlds () (join-deterministic _ _ _ _ _).
%total {} (join-deterministic _ _ _ _ _).


%theorem join-total*
  : forall {X1} {X2}
    exists {X} {J: join X1 X2 X}
    true.

%theorem join-total*/L
  : forall* {X1} {X2}
    forall {C} {CMP: cmp X1 X2 C}
    exists {X} {J: join X1 X2 X}
    true.

- : join-total*/L equal _ _ join/=.

- : join-total*/L less (cmp/< GRT) _ (join/< GRT).

- : join-total*/L greater (cmp/> GRT) _ (join/> GRT).

%worlds () (join-total*/L _ _ _ _).
%total {} (join-total*/L _ _ _ _).

- : join-total* _ _ _ J
    <- cmp-total CMP
    <- join-total*/L _ CMP _ J.

%worlds () (join-total* _ _ _ _).
%total {} (join-total* _ _ _ _).

%abbrev join-total = join-total* _ _ _.


%theorem join-preserves-grt
  : forall* {X1} {X2} {X3} {X}
    forall {X>X1: grt X X1} {X>X2: grt X X2}
    {J: join X1 X2 X3}
    exists {X>X3: grt X X3}
    true.

- : join-preserves-grt grt/wr grt/wr join/= grt/wr.

%worlds () (join-preserves-grt _ _ _ _).
%total {} (join-preserves-grt _ _ _ _).


%theorem join-associative
  : forall* {X1} {X2} {X3} {X4} {X7}
    forall {J: join X1 X2 X3} {J: join X3 X4 X7}
    exists {X6} {J: join X2 X4 X6} {J: join X1 X6 X7}
    true.

- : join-associative join/= join/= _ join/= join/=.

- : join-associative join/= (join/< GRT) _ (join/< GRT) (join/< GRT).

- : join-associative join/= (join/> GRT) _ (join/> GRT) join/=.

- : join-associative (join/< GRT) join/= _ join/= (join/< GRT).

- : join-associative (join/< GRT) (join/< GRT1) _ (join/< GRT1) (join/< GRT2)
    <- grt-transitive GRT1 GRT GRT2.

- : join-associative (join/< GRT) (join/> GRT1) _ (join/> GRT1) (join/< GRT).

- : join-associative (join/> GRT) join/= _ (join/< GRT) join/=.

- : join-associative (join/> GRT) (join/< GRT1) _ (join/< GRT2) (join/< GRT1)
    <- grt-transitive GRT1 GRT GRT2.

- : join-associative (join/> GRT) (join/> GRT1) _ J1 (join/> GRT2)
    <- join-total J1
    <- join-preserves-grt GRT GRT1 J1 GRT2.

%worlds () (join-associative _ _ _ _ _).
%total {} (join-associative _ _ _ _ _).


%theorem join-commutative
  : forall* {X1} {X2} {X}
    forall {J12: join X1 X2 X}
    exists {J21: join X2 X1 X}
    true.

- : join-commutative join/= join/=.

- : join-commutative (join/< GRT) (join/> GRT).

- : join-commutative (join/> GRT) (join/< GRT).

%worlds () (join-commutative _ _).
%total {} (join-commutative _ _).


%theorem join-implies-leq*
  : forall* {X1} {X2} {X3}
    forall {J: join X1 X2 X3}
    exists {X1<=X3: leq X1 X3}
    true.

- : join-implies-leq* join/= (geq/= eq/).

- : join-implies-leq* (join/< GRT) (geq/> GRT).

- : join-implies-leq* (join/> GRT) (geq/= eq/).

%worlds () (join-implies-leq* _ _).
%total {} (join-implies-leq* _ _).


%theorem join-implies-leq
  : forall* {X1} {X2} {X3}
    forall {J: join X1 X2 X3}
    exists {X1<=X3: leq X1 X3} {X2<=X3: leq X2 X3}
    true.

- : join-implies-leq join/= (geq/= eq/) (geq/= eq/).

- : join-implies-leq (join/< GRT) (geq/> GRT) (geq/= eq/).

- : join-implies-leq (join/> GRT) (geq/= eq/) (geq/> GRT).

%worlds () (join-implies-leq _ _ _).
%total {} (join-implies-leq _ _ _).


%{%
#define EQ eq
#define OPN join
#define OP(X,Y) X+Y
BEGIN_ELF
#include "OPN-assoc.i"
END_ELF
#undef OP
#undef OPN
#undef EQ
%}%


%{%
#define data efx
#define GT grt
#define LT ltn
#define GE geq
#define LE leq
#define EQ eq
#define COMP cmp
BEGIN_ELF
#include "minmax.elf"
END_ELF
%}%


%theorem efx/write-is-upper-bound
  : forall {X} exists {MX: min efx/write X X} true.

- : efx/write-is-upper-bound efx/write min/=.

- : efx/write-is-upper-bound efx/read (min/> grt/wr).

%worlds (objvar) (efx/write-is-upper-bound _ _).
%total {} (efx/write-is-upper-bound _ _).



%%% Abbreviations

