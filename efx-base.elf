% Unit Effect
% $Id: efx-base.elf,v 1.1 2013/09/18 20:48:29 csun Exp csun $

%%% Definitions

efx : type.	%name efx X.

efx/read : efx.

efx/write : efx.

efx/consume : efx.


% equality

eq : efx -> efx -> type.

eq/ : eq X X.


% grt

grt : efx -> efx -> type.

grt/cw : grt efx/consume efx/write.

grt/cr : grt efx/consume efx/read.

grt/wr : grt efx/write efx/read.


% compare

cmp : efx -> efx -> comp -> type.

cmp/= : cmp X X equal.

cmp/< : cmp X Y less <- grt Y X.

cmp/> : cmp X Y greater <- grt X Y.


% join

join : efx -> efx -> efx -> type.

join/rr : join efx/read efx/read efx/read.

join/rw : join efx/read efx/write efx/write.

join/wr : join efx/write efx/read efx/write.

join/ww : join efx/write efx/write efx/write.



%%% Basic Theorems

%theorem false-implies-grt
  : forall* {X1} {X2} forall {F:void} exists {X1>X2: grt X1 X2} true.

%worlds () (false-implies-grt _ _).
%total {} (false-implies-grt _ _).


%theorem grt-anti-reflexive
  : forall* {X} forall {X>X: grt X X} exists {F:void} true.

%worlds () (grt-anti-reflexive _ _).
%total {} (grt-anti-reflexive _ _).


%theorem grt-transitive
  : forall* {X1} {X2} {X3}
    forall {X1>X2: grt X1 X2}
    {X2>X3: grt X2 X3}
    exists {X1>X3: grt X1 X3}
    true.

- : grt-transitive grt/cw grt/wr grt/cr.

%worlds () (grt-transitive _ _ _).
%total {} (grt-transitive _ _ _).


%theorem grt-anti-symmetric
  : forall* {X1} {X2}
    forall {X1>X2: grt X1 X2}
    {X2>X1: grt X2 X1}
    exists {F:void}
    true.

%worlds () (grt-anti-symmetric _ _ _).
%total {} (grt-anti-symmetric _ _ _).


%theorem cmp-total*
  : forall {X1} {X2}
    exists {CMP} {P: cmp X1 X2 CMP}
    true.

- : cmp-total* _ _ equal cmp/=.

- : cmp-total* efx/read efx/write less (cmp/< grt/wr).

- : cmp-total* efx/read efx/consume less (cmp/< grt/cr).

- : cmp-total* efx/write efx/consume less (cmp/< grt/cw).

- : cmp-total* efx/consume efx/write greater (cmp/> grt/cw).

- : cmp-total* efx/consume efx/read greater (cmp/> grt/cr).

- : cmp-total* efx/write efx/read greater (cmp/> grt/wr).

%worlds () (cmp-total* _ _ _ _).
%total {} (cmp-total* _ _ _ _).

%abbrev cmp-total = cmp-total* _ _ _.

%{%
#define TYPE efx
#define EQ eq
#define GT grt
#define GE geq
#define NE ne
#define COMP cmp
#define LT ltn
#define LE leq
BEGIN_ELF
#include "EQ.i"
#include "GE.i"
#include "NE.i"
#include "LT.i"
#include "LE.i"
END_ELF
%}%

%%% Theorems about join

%theorem false-implies-join
  : forall* {X1} {X2} {X3}
    forall {F:void}
    exists {J: join X1 X2 X3}
    true.

%worlds () (false-implies-join _ _).
%total {} (false-implies-join _ _).


%theorem join-respects-eq
  : forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
    forall {J: join X1 X2 X3}
    {E: eq X1 Y1} {E: eq X2 Y2}
    {E: eq X3 Y3}
    exists {J: join Y1 Y2 Y3}
    true.

- : join-respects-eq J eq/ eq/ eq/ J.

%worlds () (join-respects-eq _ _ _ _ _).
%total {} (join-respects-eq _ _ _ _ _).


%theorem join-deterministic
  : forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
    forall {J: join X1 X2 X3} {J: join Y1 Y2 Y3}
    {E: eq X1 Y1} {E: eq X2 Y2}
    exists {E: eq X3 Y3}
    true.

- : join-deterministic J J eq/ eq/ eq/.

%worlds () (join-deterministic _ _ _ _ _).
%total {} (join-deterministic _ _ _ _ _).


%theorem join-associative
  : forall* {X1} {X2} {X3} {X4} {X7}
    forall {J: join X1 X2 X3} {J: join X3 X4 X7}
    exists {X6} {J: join X2 X4 X6} {J: join X1 X6 X7}
    true.

- : join-associative join/rr join/rr _ join/rr join/rr.

- : join-associative join/rr join/rw _ join/rw join/rw.

- : join-associative join/rw join/wr _ join/wr join/rw.

- : join-associative join/rw join/ww _ join/ww join/rw.

- : join-associative join/wr join/wr _ join/rr join/wr.

- : join-associative join/wr join/ww _ join/rw join/ww.

- : join-associative join/ww join/wr _ join/wr join/ww.

- : join-associative join/ww join/ww _ join/ww join/ww.

%worlds () (join-associative _ _ _ _ _).
%total {} (join-associative _ _ _ _ _).


%theorem join-commutative
  : forall* {X1} {X2} {X}
    forall {J12: join X1 X2 X}
    exists {J21: join X2 X1 X}
    true.

- : join-commutative join/rr join/rr.

- : join-commutative join/rw join/wr.

- : join-commutative join/wr join/rw.

- : join-commutative join/ww join/ww.

%worlds () (join-commutative _ _).
%total {} (join-commutative _ _).


%theorem join-implies-leq*
  : forall* {X1} {X2} {X3}
    forall {J: join X1 X2 X3}
    exists {X1<=X3: leq X1 X3}
    true.

- : join-implies-leq* join/rr (geq/= eq/).

- : join-implies-leq* join/rw (geq/> grt/wr).

- : join-implies-leq* join/wr (geq/= eq/).

- : join-implies-leq* join/ww (geq/= eq/).

%worlds () (join-implies-leq* _ _).
%total {} (join-implies-leq* _ _).


%theorem join-implies-leq
  : forall* {X1} {X2} {X3}
    forall {J: join X1 X2 X3}
    exists {X1<=X3: leq X1 X3} {X2<=X3: leq X2 X3}
    true.

- : join-implies-leq join/rr (geq/= eq/) (geq/= eq/).

- : join-implies-leq join/rw (geq/> grt/wr) (geq/= eq/).

- : join-implies-leq join/wr (geq/= eq/) (geq/> grt/wr).

- : join-implies-leq join/ww (geq/= eq/) (geq/= eq/).

%worlds () (join-implies-leq _ _ _).
%total {} (join-implies-leq _ _ _).

%{%
#define EQ eq
#define OPN join
#define OP(X,Y) X+Y
BEGIN_ELF
#include "OPN-assoc.i"
END_ELF
#undef OP
#undef OPN
#undef EQ
%}%

%%% Abbreviations

