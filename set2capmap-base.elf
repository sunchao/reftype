%%% Converting a set of (obj,fld)s to a capmap

cap-id : nat -> unit -> cap -> cap -> type.

cap-id/ : cap-id N _ X X.


%%% Theorems

%theorem cap-id-eq
  : forall* {N} {U} {X1} {X2}
    forall {ID: cap-id N U X1 X2}
    exists {E: cap`eq X1 X2}
    true.

- : cap-id-eq cap-id/ cap`eq/.

%worlds () (cap-id-eq _ _).
%total {} (cap-id-eq _ _).


%theorem cap-id-total*
  : forall {N} {U} {X1}
    exists {X2} {SE: cap-id N U X1 X2}
    true.

- : cap-id-total* _ _ _ _ cap-id/.

%worlds () (cap-id-total* _ _ _ _ _).
%total {} (cap-id-total* _ _ _ _ _).

%abbrev cap-id-total = cap-id-total* _ _ _ _.


%theorem cap-id-unique
  : forall* {N1} {U1} {X1} {Y1} {N2} {U2} {X2} {Y2}
    forall {SE1: cap-id N1 U1 X1 Y1}
    {SE2: cap-id N2 U2 X2 Y2}
    {E: nat`eq N1 N2} {E: unit`eq U1 U2}
    {E: cap`eq X1 X2}
    exists {E: cap`eq Y1 Y2}
    true.

- : cap-id-unique S1 S2 nat`eq/ unit`eq/ cap`eq/ cap`eq/.

%worlds () (cap-id-unique _ _ _ _ _ _).
%total {} (cap-id-unique _ _ _ _ _ _).


%theorem cap-id-right-cancels
  : forall* {N} {U1} {U2} {X1} {Y1} {X2} {Y2}
    forall {SE1: cap-id N U1 X1 Y1}
    {SE2: cap-id N U2 X2 Y2}
    {E: cap`eq X1 X2} {E: cap`eq Y1 Y2}
    exists {E: unit`eq U1 U2}
    true.

- : cap-id-right-cancels cap-id/ cap-id/ _ _ unit`eq/.

%worlds () (cap-id-right-cancels _ _ _ _ _).
%total {} (cap-id-right-cancels _ _ _ _ _).


%theorem cap-id-right-preserves-leq*
  : forall* {N} {U1} {U2} {X} {Y1} {Y2}
    forall {U1<=U2: unit`eq U1 U2}
    {SE1: cap-id N U1 X Y1}
    {SE2: cap-id N U2 X Y2}
    exists {Y1<=Y2: cap`leq Y1 Y2}
    true.

- : cap-id-right-preserves-leq* unit`eq/ cap-id/ cap-id/ Y1<=Y2
    <- cap`leq-reflexive _ Y1<=Y2.

%worlds () (cap-id-right-preserves-leq* _ _ _ _).
%total {} (cap-id-right-preserves-leq* _ _ _ _).


%theorem cap-id-left-preserves-leq*
  : forall* {N} {U} {X1} {X2} {Y1} {Y2}
    forall {X1<=X2: cap`leq X1 X2}
    {T1: cap-id N U X1 Y1}
    {T2: cap-id N U X2 Y2}
    exists {Y1<=Y2: cap`leq Y1 Y2}
    true.

- : cap-id-left-preserves-leq* L cap-id/ cap-id/ L.

%worlds () (cap-id-left-preserves-leq* _ _ _ _).
%total {} (cap-id-left-preserves-leq* _ _ _ _).

%{%
#define map1 set
#define data1 unit
#define map2 capmap
#define data2 cap
#define trans cap-id
#define alltrans set2capmap
#define arg cap
#define MAP_TRANS_CANCEL 1
#define MAP_LEQ 1
#define MAP_TRANS_LEQ 1
#define MAP_TRANS_TOTAL 1
BEGIN_ELF
#include "map-trans2.elf"
END_ELF
#undef data1
#undef data2
%}%


%theorem fresh-update-preserves-set2capmap-converse2
  : forall* {M} {G} {GP} {X} {F} {S}
    forall {T: set2capmap G X M}
    {FS: set`fresh GP F} {U: set`update GP F S G}
    exists {MP}
    {FS: capmap`fresh MP F} {U: capmap`update MP F X M}
    {T: set2capmap GP X MP}
    true.

- : fresh-update-preserves-set2capmap-converse2 T NM A MP F U TP
    <- fresh-update-preserves-set2capmap-converse T NM A _ _ ID F Ux TPx
    <- cap-id-eq ID Ex
    <- cap`eq-symmetric Ex E
    <- update-respects-eq Ux eq/ nat`eq/ E eq/ U
    <- set2capmap-respects-eq TPx set`eq/ cap`eq/ eq/ TP.

%worlds () (fresh-update-preserves-set2capmap-converse2 _ _ _ _ _ _ _).
%total {} (fresh-update-preserves-set2capmap-converse2 _ _ _ _ _ _ _).


%theorem set2capmap-implies-domain
  : forall* {S} {X} {M}
    forall {T: set2capmap S X M}
    exists {DM: capmap`domain M S}
    true.

- : set2capmap-implies-domain set2capmap/0 capmap`domain/0.

- : set2capmap-implies-domain
    (set2capmap/U SP=>MP cap-id/ N!<SP SP+N=S MP+N=M) DM-M
    <- set2capmap-implies-domain SP=>MP DM-MP
    <- capmap`domain-commute-update DM-MP MP+N=M SP+N=S DM-M.

%worlds () (set2capmap-implies-domain _ _).
%total (T) (set2capmap-implies-domain T _).


%theorem partition-leq-implies-leq
  : forall* {M} {M1} {M2P} {X} {M2} {S}
    forall {P: partition M S M1 M2P}
    {T: set2capmap S X M2} {LE: leq M2 M}
    exists {LE: leq M2 M2P}
    true.

%theorem partition-leq-implies-leq/L
  : forall* {M} {M2} {M2P} {S} {X}
    forall {N} {SZ: size M N}
    {R2: restrict M S M2P}
    {T: set2capmap S X M2} {LE: leq M2 M}
    exists {LE: leq M2 M2P}
    true.

- : partition-leq-implies-leq/L _ _ restrict/0 _ leq/0 leq/0.

%theorem partition-leq-implies-leq/U/in
  : forall* {M2S} {M2P} {F} {Z} {MS} {S} {M} {M2} {X} {B}
    forall {N} {SZ: size M N}
    {U: update M2S F Z M2P}
    {R2: restrict MS S M2S}
    {MB: set`member S F}
    {U: update MS F Z M} {FS: fresh MS F}
    {T: set2capmap S X M2} {LE: leq M2 M}
    {IN?: domain? M2 F B}
    exists {LE: leq M2 M2P}
    true.

- : partition-leq-implies-leq/U/in (s N) SZ M2S+F+Z=M2P
    MS|S=M2S F<-S MS+F+Z=M F!<MS S+X=>M2 M2<=M (domain?/in M2->F=XP) M2<=M2P
    <- set`member-implies-not-member-add F<-S SP F!<SP SP+F=S
    <- fresh-update-preserves-set2capmap-converse2
      S+X=>M2 F!<SP SP+F=S M2U F!<M2U M2U+F+XP=M2 SP+X=>M2U
    <- fresh-update-preserves-leq-converse
      M2<=M F!<M2U M2U+F+XP=M2 F!<MS MS+F+Z=M M2U<=MS XP<=Z
    <- fresh-add-preserves-restrict-converse MS|S=M2S F!<MS SP+F=S MS|SP=M2S
    <- fresh-update-increases-size-converse SZ F!<MS MS+F+Z=M SZP
    <- partition-leq-implies-leq/L N SZP MS|SP=M2S SP+X=>M2U M2U<=MS M2U<=M2S
    <- update-preserves-leq* M2U<=M2S XP<=Z M2U+F+XP=M2 M2S+F+Z=M2P M2<=M2P.

- : partition-leq-implies-leq/U/in (s N) SZ M2S+F+Z=M2P
    MS|S=M2S F<-S MS+F+Z=M F!<MS S+X=>M2 M2<=M (domain?/out F!<M2) M2<=M2P
    <- fresh-update2-preserves-leq-converse M2<=M F!<M2 F!<MS MS+F+Z=M M2<=MS
    <- fresh-update-increases-size-converse SZ F!<MS MS+F+Z=M SZP
    <- partition-leq-implies-leq/L N SZP MS|S=M2S S+X=>M2 M2<=MS M2<=M2S
    <- restrict-implies-leq MS|S=M2S M2S<=MS
    <- fresh-respects-geq F!<MS M2S<=MS F!<M2S
    <- fresh-update-implies-leq F!<M2S M2S+F+Z=M2P M2S<=M2P
    <- leq-transitive M2<=M2S M2S<=M2P M2<=M2P.

- : partition-leq-implies-leq/L N SZ
    (restrict/in MS|S=M2S F<-S F!<MS MS+F+Z=M M2S+F+Z=M2P) S+X=>M2 M2<=M M2<=M2P
    <- domain?-total DM?
    <- partition-leq-implies-leq/U/in N SZ M2S+F+Z=M2P MS|S=M2S F<-S
      MS+F+Z=M F!<MS S+X=>M2 M2<=M DM? M2<=M2P.

- : partition-leq-implies-leq/L (s N) SZ
    (restrict/out MS|S=M2P F!<S F!<MS MS+F+Z=M) S+X=>M2 M2<=M M2<=M2P
    <- set2capmap-preserves-fresh F!<S S+X=>M2 F!<M2
    <- fresh-update2-preserves-leq-converse M2<=M F!<M2 F!<MS MS+F+Z=M M2<=MS
    <- fresh-update-increases-size-converse SZ F!<MS MS+F+Z=M SZP
    <- partition-leq-implies-leq/L N SZP MS|S=M2P S+X=>M2 M2<=MS M2<=M2P.

%worlds () (partition-leq-implies-leq/L _ _ _ _ _ _)
	(partition-leq-implies-leq/U/in _ _ _ _ _ _ _ _ _ _ _).
%total (N1 N2) (partition-leq-implies-leq/U/in N1 _ _ _ _ _ _ _ _ _ _)
	(partition-leq-implies-leq/L N2 _ _ _ _ _).


- : partition-leq-implies-leq (partition/ _ _ _ R) T LE LE2
    <- size-total Z
    <- partition-leq-implies-leq/L _ Z R T LE LE2.

%worlds () (partition-leq-implies-leq _ _ _ _).
%total {} (partition-leq-implies-leq _ _ _ _).