%%% Facts about consuming effects


% =================================
% ========= Definitions ===========
% =================================

efx`not-consume : efx -> type.

efx`not-consume/none : efx`not-consume efx/none.

efx`not-consume/read : efx`not-consume efx/read.

efx`not-consume/write : efx`not-consume efx/write.


inner-efxmap`no-consume : inner-efxmap -> type.

inner-efxmap`no-consume/0 : inner-efxmap`no-consume inner-efxmap/0.

inner-efxmap`no-consume/U
  : inner-efxmap`no-consume MP
    -> inner-efxmap`fresh MP N
    -> inner-efxmap`update MP N X M
    -> efx`not-consume X
    -> inner-efxmap`no-consume M.


efxmap`no-consume : efxmap -> type.

efxmap`no-consume/0 : efxmap`no-consume efxmap/0.

efxmap`no-consume/U
  : efxmap`no-consume XMP
    -> efxmap`fresh XMP N
    -> efxmap`update XMP N M XM
    -> inner-efxmap`no-consume M
    -> efxmap`no-consume XM.


maybe-efx`no-consume : maybe-efx -> type.

maybe-efx`no-consume/nothing
  : maybe-efx`no-consume maybe-efx/nothing.

maybe-efx`no-consume/just
  : maybe-efx`no-consume (maybe-efx/just X) <- efx`not-consume X.


effects`no-consume : effects -> type.

effects`no-consume/
  : effects`no-consume (effects/ XM MX)
    <- efxmap`no-consume XM
    <- maybe-efx`no-consume MX.


% =====================================
% ============= Theorems ==============
% =====================================


%%% efx`not-consume

%theorem efx`not-consume-respects-eq
  : forall* {X1} {X2}
    forall {NC: efx`not-consume X1}
    {E: efx`eq X1 X2}
    exists {NC: efx`not-consume X2}
    true.

- : efx`not-consume-respects-eq NC efx`eq/ NC.

%worlds () (efx`not-consume-respects-eq _ _ _).
%total {} (efx`not-consume-respects-eq _ _ _).


%theorem efx`join-not-consume
  : forall* {X1} {X2} {X}
    forall {J: efx`join X1 X2 X}
    {NC: efx`not-consume X2}
    exists {NC: efx`not-consume X}
    true.

- : efx`join-not-consume
    efx`join/rr efx`not-consume/read efx`not-consume/read.

- : efx`join-not-consume
    efx`join/wr efx`not-consume/read efx`not-consume/write.

- : efx`join-not-consume
    efx`join/rw efx`not-consume/write efx`not-consume/write.

- : efx`join-not-consume
    efx`join/ww efx`not-consume/write efx`not-consume/write.

- : efx`join-not-consume efx`join/n_ NC NC.

%worlds () (efx`join-not-consume _ _ _).
%trustme %total {} (efx`join-not-consume _ _ _).


%theorem efx`not-consume-respects-geq
  : forall* {X} {XP}
    forall {NC: efx`not-consume X}
    {L: efx`leq XP X}
    exists {NC: efx`not-consume XP}
    true.

- : efx`not-consume-respects-geq
    efx`not-consume/none (efx`leq/eq efx`eq/) efx`not-consume/none.

- : efx`not-consume-respects-geq
    efx`not-consume/read (efx`leq/eq efx`eq/) efx`not-consume/read.

- : efx`not-consume-respects-geq
    efx`not-consume/write (efx`leq/lt lt/rw) efx`not-consume/read.

- : efx`not-consume-respects-geq
    efx`not-consume/write (efx`leq/eq efx`eq/) efx`not-consume/write.

- : efx`not-consume-respects-geq
    efx`not-consume/write (efx`leq/lt efx`lt/nw) efx`not-consume/none.

%worlds () (efx`not-consume-respects-geq _ _ _).
%total {} (efx`not-consume-respects-geq _ _ _).


%theorem inner-efxmap`join-lookup-not-consume
  : forall* {M1} {M2} {M} {N} {X}
    forall {J: inner-efxmap`join M1 M2 M}
    {L: inner-efxmap`lookup M2 N X}
    {NC: efx`not-consume X}
    exists {XP} {L: inner-efxmap`lookup M N XP}
    {NC: efx`not-consume XP}
    true.

%theorem inner-efxmap`join-lookup-not-consume/L
  : forall* {M1} {M2} {M} {N} {B} {X2}
    forall {DM?: inner-efxmap`domain? M1 N B}
    {J: inner-efxmap`join M1 M2 M}
    {L: inner-efxmap`lookup M2 N X2}
    {NC: efx`not-consume X2}
    exists {X} {L: inner-efxmap`lookup M N X}
    {NC: efx`not-consume X}
    true.

- : inner-efxmap`join-lookup-not-consume/L
    (inner-efxmap`domain?/in M1->N=X1) M1+M2=M M2->N=X2 NC-X2 _ M->N=X NC-X
    <- inner-efxmap`join-joins-lookup
      M1->N=X1 M2->N=X2 M1+M2=M X X1+X2=X M->N=X
    <- efx`join-not-consume X1+X2=X NC-X2 NC-X.

- : inner-efxmap`join-lookup-not-consume/L
    (inner-efxmap`domain?/out N!<M1) M1+M2=M M2->N=X2 NC-X2 _ M->N=X2 NC-X2
    <- inner-efxmap`fresh-join-left-preserves-lookup*
      N!<M1 M2->N=X2 M1+M2=M M->N=X2.

%worlds () (inner-efxmap`join-lookup-not-consume/L _ _ _ _ _ _ _).
%total {} (inner-efxmap`join-lookup-not-consume/L _ _ _ _ _ _ _).

- : inner-efxmap`join-lookup-not-consume J L NC _ LP NCP
    <- inner-efxmap`domain?-total DM?
    <- inner-efxmap`join-lookup-not-consume/L DM? J L NC _ LP NCP.

%worlds () (inner-efxmap`join-lookup-not-consume _ _ _ _ _ _).
%total {} (inner-efxmap`join-lookup-not-consume _ _ _ _ _ _).



%%% inner-efxmap`no-consume

%theorem inner-efxmap`false-implies-no-consume
  : forall* {M} forall {V:void} exists {NC: inner-efxmap`no-consume M} true.

%worlds () (inner-efxmap`false-implies-no-consume _ _).
%total {} (inner-efxmap`false-implies-no-consume _ _).


%theorem inner-efxmap`no-consume-respects-eq
  : forall* {M1} {M2}
    forall {NC1: inner-efxmap`no-consume M1}
    {E: inner-efxmap`eq M1 M2}
    exists {NC2: inner-efxmap`no-consume M2}
    true.

- : inner-efxmap`no-consume-respects-eq NC inner-efxmap`eq/ NC.

%worlds () (inner-efxmap`no-consume-respects-eq _ _ _).
%total {} (inner-efxmap`no-consume-respects-eq _ _ _).


%theorem inner-efxmap`lookup-implies-not-consume
  : forall* {M} {N} {X}
    forall {NC: inner-efxmap`no-consume M}
    {L: inner-efxmap`lookup M N X}
    exists {NC: efx`not-consume X}
    true.

%theorem inner-efxmap`lookup-implies-not-consume/L
  : forall* {N1} {N2} {B} {MP} {M} {X1} {X2}
    forall {E?: nat`eq? N1 N2 B}
    {NCP: inner-efxmap`no-consume MP}
    {F: inner-efxmap`fresh MP N1}
    {U: inner-efxmap`update MP N1 X1 M}
    {NC1: efx`not-consume X1}
    {L: inner-efxmap`lookup M N2 X2}
    exists {NC2: efx`not-consume X2}
    true.

- : inner-efxmap`lookup-implies-not-consume/L nat`eq?/yes
    _ _ MP+N+X1=M NC-X1 M->N=X2 NC-X2
    <- inner-efxmap`update-implies-lookup MP+N+X1=M M->N=X1
    <- inner-efxmap`lookup-unique M->N=X1 M->N=X2 inner-efxmap`eq/ nat`eq/ X1=X2
    <- efx`not-consume-respects-eq NC-X1 X1=X2 NC-X2.

- : inner-efxmap`lookup-implies-not-consume/L (nat`eq?/no N1<>N2)
    NC-MP N1!<MP MP+N1+X1=M NC-X1 M->N2=X2 NC-X2
    <- nat`ne-symmetric N1<>N2 N2<>N1
    <- inner-efxmap`update-preserves-lookup-converse
      M->N2=X2 MP+N1+X1=M N2<>N1 MP->N2=X2
    <- inner-efxmap`lookup-implies-not-consume NC-MP MP->N2=X2 NC-X2.

- : inner-efxmap`lookup-implies-not-consume
    (inner-efxmap`no-consume/U NC-MP N1!<MP MP+N1+X1=M NC-X1) M->N2=X2 NC-X2
    <- nat`eq?-total N1==N2?
    <- inner-efxmap`lookup-implies-not-consume/L N1==N2?
      NC-MP N1!<MP MP+N1+X1=M NC-X1 M->N2=X2 NC-X2.

%worlds () (inner-efxmap`lookup-implies-not-consume _ _ _)
(inner-efxmap`lookup-implies-not-consume/L _ _ _ _ _ _ _).
%total (NC1 NC2) (inner-efxmap`lookup-implies-not-consume NC1 _ _)
(inner-efxmap`lookup-implies-not-consume/L _ NC2 _ _ _ _ _).


%theorem inner-efxmap`update-preserves-no-consume
  : forall* {M} {MP} {N} {X}
    forall {NC: inner-efxmap`no-consume MP}
    {U: inner-efxmap`update MP N X M}
    {NC: efx`not-consume X}
    exists {NC: inner-efxmap`no-consume M}
    true.

- : inner-efxmap`update-preserves-no-consume
    inner-efxmap`no-consume/0 inner-efxmap`update/0 NC-X
    (inner-efxmap`no-consume/U inner-efxmap`no-consume/0
      inner-efxmap`fresh/0 inner-efxmap`update/0 NC-X).

%theorem inner-efxmap`update-preserves-no-consume/L
  : forall* {N1} {N2} {B} {MPP} {X1} {MP} {X2} {M}
    forall {E?: nat`eq? N1 N2 B}
    {NCP: inner-efxmap`no-consume MPP}
    {F: inner-efxmap`fresh MPP N1}
    {U: inner-efxmap`update MPP N1 X1 MP}
    {NC1: efx`not-consume X1}
    {U2: inner-efxmap`update MP N2 X2 M}
    {NC2: efx`not-consume X2}
    exists {NC: inner-efxmap`no-consume M}
    true.

- : inner-efxmap`update-preserves-no-consume/L
    nat`eq?/yes NC-MPP N!<MPP MPP+N+X1=MP _ MP+N+X2=M NC-X2
    (inner-efxmap`no-consume/U NC-MPP N!<MPP MPP+N+X2=M NC-X2)
    <- inner-efxmap`update-overwrites MPP+N+X1=MP MP+N+X2=M nat`eq/ MPP+N+X2=M.

- : inner-efxmap`update-preserves-no-consume/L
    (nat`eq?/no N1<>N2) NC-MPP N1!<MPP MPP+N1+X1=MP NC-X1 MP+N2+X2=M NC-X2
    (inner-efxmap`no-consume/U NC-MPS N1!<MPS MPS+N1+X1=M NC-X1)
    <- inner-efxmap`update-commutes
       MPP+N1+X1=MP MP+N2+X2=M N1<>N2 MPS MPP+N2+X2=MPS MPS+N1+X1=M
    <- inner-efxmap`update-preserves-fresh N1!<MPP MPP+N2+X2=MPS N1<>N2 N1!<MPS
    <- inner-efxmap`update-preserves-no-consume
      NC-MPP MPP+N2+X2=MPS NC-X2 NC-MPS.

- : inner-efxmap`update-preserves-no-consume
    (inner-efxmap`no-consume/U NC-MPP N1!<MPP MPP+N1+X1=MP NC-X1)
    MP+N2+X2=M NC-X2 NC-M
    <- nat`eq?-total N1==N2?
    <- inner-efxmap`update-preserves-no-consume/L
      N1==N2? NC-MPP N1!<MPP MPP+N1+X1=MP NC-X1 MP+N2+X2=M NC-X2 NC-M.

%worlds ()
(inner-efxmap`update-preserves-no-consume _ _ _ _)
(inner-efxmap`update-preserves-no-consume/L _ _ _ _  _ _ _ _).
%total (NC1 NC2)  (inner-efxmap`update-preserves-no-consume NC1 _ _ _)
(inner-efxmap`update-preserves-no-consume/L _ NC2 _ _ _ _ _ _).


%theorem inner-efxmap`fresh-update-preserves-no-consume-converse
  : forall* {M} {MP} {N} {X}
    forall {NC: inner-efxmap`no-consume M}
    {F: inner-efxmap`fresh MP N}
    {U: inner-efxmap`update MP N X M}
    exists {NC: inner-efxmap`no-consume MP}
    true.

%theorem inner-efxmap`fresh-update-preserves-no-consume-converse/U
  : forall* {N1} {N2} {B} {MP1} {MP2} {X1} {X2} {M}
    forall {E?: nat`eq? N1 N2 B}
    {NC: inner-efxmap`no-consume MP1}
    {F1: inner-efxmap`fresh MP1 N1}
    {U1: inner-efxmap`update MP1 N1 X1 M}
    {NC1: efx`not-consume X1}
    {F2: inner-efxmap`fresh MP2 N2}
    {U2: inner-efxmap`update MP2 N2 X2 M}
    exists {NC2: inner-efxmap`no-consume MP2}
    true.

- : inner-efxmap`fresh-update-preserves-no-consume-converse/U nat`eq?/yes
    NC-MP1 N!<MP1 MP1+N+X1=M NC-X1 N!<MP2 MP2+N+X2=M NC-MP2
    <- inner-efxmap`fresh-update-cancels N!<MP1 MP1+N+X1=M N!<MP2
      MP2+N+X2=M nat`eq/ inner-efxmap`eq/ X1=X2 MP1=MP2
    <- inner-efxmap`no-consume-respects-eq NC-MP1 MP1=MP2 NC-MP2.

- : inner-efxmap`fresh-update-preserves-no-consume-converse/U (nat`eq?/no N1<>N2)
    NC-MP1 N1!<MP1 MP1+N1+X1=M NC-X1 N2!<MP2 MP2+N2+X2=M
    (inner-efxmap`no-consume/U NC-MP0 N1!<MP0 MP0+N1+X1=MP2 NC-X1)
    <- inner-efxmap`update-commutes-converse
      MP1+N1+X1=M MP2+N2+X2=M N1<>N2 MP0 MP0+N2+X2=MP1 MP0+N1+X1=MP2
    <- inner-efxmap`update-preserves-fresh-converse N1!<MP1 MP0+N2+X2=MP1 N1!<MP0
    <- inner-efxmap`update-preserves-fresh-converse N2!<MP2 MP0+N1+X1=MP2 N2!<MP0
    <- inner-efxmap`fresh-update-preserves-no-consume-converse
      NC-MP1 N2!<MP0 MP0+N2+X2=MP1 NC-MP0.

- : inner-efxmap`fresh-update-preserves-no-consume-converse
    (inner-efxmap`no-consume/U NC-MP1 N1!<MP1 MP1+N1+X1=M NC-X1)
    N2!<MP2 MP2+N2+X2=M NC-MP2
    <- nat`eq?-total N1==N2?
    <- inner-efxmap`fresh-update-preserves-no-consume-converse/U
      N1==N2? NC-MP1 N1!<MP1 MP1+N1+X1=M NC-X1 N2!<MP2 MP2+N2+X2=M NC-MP2.

%worlds ()
(inner-efxmap`fresh-update-preserves-no-consume-converse _ _ _ _)
(inner-efxmap`fresh-update-preserves-no-consume-converse/U _ _ _ _ _ _ _ _).
%total (NC1 NC2)
(inner-efxmap`fresh-update-preserves-no-consume-converse NC1 _ _ _)
(inner-efxmap`fresh-update-preserves-no-consume-converse/U _ NC2 _ _ _ _ _ _).


%theorem inner-efxmap`no-consume-respects-geq
  : forall* {M} {MP}
    forall {NC: inner-efxmap`no-consume M}
    {L: inner-efxmap`leq MP M}
    exists {NC: inner-efxmap`no-consume MP}
    true.

- : inner-efxmap`no-consume-respects-geq
    _ inner-efxmap`leq/0 inner-efxmap`no-consume/0.

%theorem inner-efxmap`no-consume-respects-geq/L
  : forall* {M} {MP} {MS} {N} {X} {B}
    forall {NC: inner-efxmap`no-consume MS}
    {F: inner-efxmap`fresh MS N}
    {U: inner-efxmap`update MS N X M}
    {NC: efx`not-consume X}
    {L: inner-efxmap`leq MP M}
    {DM?: inner-efxmap`domain? MP N B}
    exists {NC: inner-efxmap`no-consume MP}
    true.

- : inner-efxmap`no-consume-respects-geq/L
    NC-MS N!<MS MS+N+X=M NC-X MP<=M (inner-efxmap`domain?/in MP->N=XP)
    (inner-efxmap`no-consume/U NC-MK N!<MK MK+N+XP=MP NC-XP)
    <- inner-efxmap`lookup-implies-fresh-update MP->N=XP MK N!<MK MK+N+XP=MP
    <- inner-efxmap`fresh-update-preserves-leq-converse
      MP<=M N!<MK MK+N+XP=MP N!<MS MS+N+X=M MK<=MS XP<=X
    <- inner-efxmap`no-consume-respects-geq NC-MS MK<=MS NC-MK
    <- efx`not-consume-respects-geq NC-X XP<=X NC-XP.

- : inner-efxmap`no-consume-respects-geq/L
    NC-MS N!<MS MS+N+X=M NC-X MP<=M (inner-efxmap`domain?/out N!<MP) NC-MP
    <- inner-efxmap`fresh-update2-preserves-leq-converse
      MP<=M N!<MP N!<MS MS+N+X=M MP<=MS
    <- inner-efxmap`no-consume-respects-geq NC-MS MP<=MS NC-MP.

- : inner-efxmap`no-consume-respects-geq
    (inner-efxmap`no-consume/U NC-MS N!<MS MS+N+X=M NC-X) MP<=M NC-MP
    <- inner-efxmap`domain?-total DM?
    <- inner-efxmap`no-consume-respects-geq/L
      NC-MS N!<MS MS+N+X=M NC-X MP<=M DM? NC-MP.

%worlds () (inner-efxmap`no-consume-respects-geq _ _ _)
(inner-efxmap`no-consume-respects-geq/L _ _ _ _ _ _ _).
%total (C1 C2) (inner-efxmap`no-consume-respects-geq C1 _ _)
(inner-efxmap`no-consume-respects-geq/L C2 _ _ _ _ _ _).



%%% efxmap`no-consume

%theorem efxmap`false-implies-no-consume
  : forall* {M} forall {V:void} exists {NC: efxmap`no-consume M} true.

%worlds () (efxmap`false-implies-no-consume _ _).
%total {} (efxmap`false-implies-no-consume _ _).


%theorem efxmap`no-consume-respects-eq
  : forall* {M} {MP}
    forall {NC: efxmap`no-consume M}
    {E: efxmap`eq M MP}
    exists {NCP: efxmap`no-consume MP}
    true.

- : efxmap`no-consume-respects-eq NC _ NC.

%worlds () (efxmap`no-consume-respects-eq _ _ _).
%total {} (efxmap`no-consume-respects-eq _ _ _).


%theorem efxmap`lookup-implies-no-consume
  : forall* {XM} {N} {M}
    forall {NC: efxmap`no-consume XM}
    {L: efxmap`lookup XM N M}
    exists {NC: inner-efxmap`no-consume M}
    true.

%theorem efxmap`lookup-implies-no-consume/L
  : forall* {N1} {N2} {B} {XMP} {M1} {XM} {M2}
    forall {E?: nat`eq? N1 N2 B}
    {NC: efxmap`no-consume XMP}
    {F: efxmap`fresh XMP N1}
    {U: efxmap`update XMP N1 M1 XM}
    {NC1: inner-efxmap`no-consume M1}
    {L2: efxmap`lookup XM N2 M2}
    exists {NC2: inner-efxmap`no-consume M2}
    true.

- : efxmap`lookup-implies-no-consume/L nat`eq?/yes
    _ _ XMP+N+M1=XM NC-M1 XM->N=M2 NC-M2
    <- efxmap`update-implies-lookup XMP+N+M1=XM XM->N=M1
    <- efxmap`lookup-unique XM->N=M1 XM->N=M2 efxmap`eq/ nat`eq/ M1=M2
    <- inner-efxmap`no-consume-respects-eq NC-M1 M1=M2 NC-M2.

- : efxmap`lookup-implies-no-consume/L (nat`eq?/no N1<>N2)
    NC-XMP N1!<XMP XMP+N1+M1=XM NC-M1 XM->N2=M2 NC-M2
    <- nat`ne-symmetric N1<>N2 N2<>N1
    <- efxmap`update-preserves-lookup-converse
      XM->N2=M2 XMP+N1+M1=XM N2<>N1 XMP->N2=M2
    <- efxmap`lookup-implies-no-consume NC-XMP XMP->N2=M2 NC-M2.

- : efxmap`lookup-implies-no-consume
    (efxmap`no-consume/U NC-XMP N1!<XMP XMP+N1+M1=XM NC-M1) XM->N2=M2 NC-M2
    <- nat`eq?-total N1==N2?
    <- efxmap`lookup-implies-no-consume/L N1==N2?
      NC-XMP N1!<XMP XMP+N1+M1=XM NC-M1 XM->N2=M2 NC-M2.

%worlds () (efxmap`lookup-implies-no-consume _ _ _)
(efxmap`lookup-implies-no-consume/L _ _ _ _ _ _ _).
%total (NC1 NC2) (efxmap`lookup-implies-no-consume NC1 _ _)
(efxmap`lookup-implies-no-consume/L _ NC2 _ _ _ _ _).


%theorem efxmap`update-preserves-no-consume
  : forall* {M} {MP} {N} {X}
    forall {NC: efxmap`no-consume MP}
    {U: efxmap`update MP N X M}
    {NC: inner-efxmap`no-consume X}
    exists {NC: efxmap`no-consume M}
    true.

- : efxmap`update-preserves-no-consume
    efxmap`no-consume/0 efxmap`update/0 NC-X
    (efxmap`no-consume/U efxmap`no-consume/0
      efxmap`fresh/0 efxmap`update/0 NC-X).

%theorem efxmap`update-preserves-no-consume/L
  : forall* {N1} {N2} {B} {MPP} {X1} {X2} {MP} {M}
    forall {E?: nat`eq? N1 N2 B}
    {NC: efxmap`no-consume MPP}
    {F: efxmap`fresh MPP N1}
    {U: efxmap`update MPP N1 X1 MP}
    {NC1: inner-efxmap`no-consume X1}
    {U2: efxmap`update MP N2 X2 M}
    {NC: inner-efxmap`no-consume X2}
    exists {NCM: efxmap`no-consume M}
    true.

- : efxmap`update-preserves-no-consume/L
    nat`eq?/yes NC-MPP N!<MPP MPP+N+X1=MP _ MP+N+X2=M NC-X2
    (efxmap`no-consume/U NC-MPP N!<MPP MPP+N+X2=M NC-X2)
    <- efxmap`update-overwrites MPP+N+X1=MP MP+N+X2=M nat`eq/ MPP+N+X2=M.

- : efxmap`update-preserves-no-consume/L
    (nat`eq?/no N1<>N2) NC-MPP N1!<MPP MPP+N1+X1=MP NC-X1 MP+N2+X2=M NC-X2
    (efxmap`no-consume/U NC-MPS N1!<MPS MPS+N1+X1=M NC-X1)
    <- efxmap`update-commutes
       MPP+N1+X1=MP MP+N2+X2=M N1<>N2 MPS MPP+N2+X2=MPS MPS+N1+X1=M
    <- efxmap`update-preserves-fresh N1!<MPP MPP+N2+X2=MPS N1<>N2 N1!<MPS
    <- efxmap`update-preserves-no-consume
      NC-MPP MPP+N2+X2=MPS NC-X2 NC-MPS.

- : efxmap`update-preserves-no-consume
    (efxmap`no-consume/U NC-MPP N1!<MPP MPP+N1+X1=MP NC-X1)
    MP+N2+X2=M NC-X2 NC-M
    <- nat`eq?-total N1==N2?
    <- efxmap`update-preserves-no-consume/L
      N1==N2? NC-MPP N1!<MPP MPP+N1+X1=MP NC-X1 MP+N2+X2=M NC-X2 NC-M.

%worlds ()
(efxmap`update-preserves-no-consume _ _ _ _)
(efxmap`update-preserves-no-consume/L _ _ _ _  _ _ _ _).
%total (NC1 NC2) (efxmap`update-preserves-no-consume NC1 _ _ _)
(efxmap`update-preserves-no-consume/L _ NC2 _ _ _ _ _ _).


%theorem efxmap`fresh-update-preserves-no-consume-converse
  : forall* {M} {MP} {N} {X}
    forall {NC: efxmap`no-consume M}
    {F: efxmap`fresh MP N}
    {U: efxmap`update MP N X M}
    exists {NC: efxmap`no-consume MP}
    true.

%theorem efxmap`fresh-update-preserves-no-consume-converse/U
  : forall* {M} {N1} {N2} {B} {MP1} {MP2} {X1} {X2}
    forall {E?: nat`eq? N1 N2 B}
    {NC1: efxmap`no-consume MP1}
    {F1: efxmap`fresh MP1 N1}
    {U1: efxmap`update MP1 N1 X1 M}
    {NC1: inner-efxmap`no-consume X1}
    {F2: efxmap`fresh MP2 N2}
    {U2: efxmap`update MP2 N2 X2 M}
    exists {NC: efxmap`no-consume MP2}
    true.

- : efxmap`fresh-update-preserves-no-consume-converse/U nat`eq?/yes
    NC-MP1 N!<MP1 MP1+N+X1=M NC-X1 N!<MP2 MP2+N+X2=M NC-MP2
    <- efxmap`fresh-update-cancels N!<MP1 MP1+N+X1=M N!<MP2
      MP2+N+X2=M nat`eq/ efxmap`eq/ X1=X2 MP1=MP2
    <- efxmap`no-consume-respects-eq NC-MP1 MP1=MP2 NC-MP2.

- : efxmap`fresh-update-preserves-no-consume-converse/U
    (nat`eq?/no N1<>N2)
    NC-MP1 N1!<MP1 MP1+N1+X1=M NC-X1 N2!<MP2 MP2+N2+X2=M
    (efxmap`no-consume/U NC-MP0 N1!<MP0 MP0+N1+X1=MP2 NC-X1)
    <- efxmap`update-commutes-converse
      MP1+N1+X1=M MP2+N2+X2=M N1<>N2 MP0 MP0+N2+X2=MP1 MP0+N1+X1=MP2
    <- efxmap`update-preserves-fresh-converse N1!<MP1 MP0+N2+X2=MP1 N1!<MP0
    <- efxmap`update-preserves-fresh-converse N2!<MP2 MP0+N1+X1=MP2 N2!<MP0
    <- efxmap`fresh-update-preserves-no-consume-converse
      NC-MP1 N2!<MP0 MP0+N2+X2=MP1 NC-MP0.

- : efxmap`fresh-update-preserves-no-consume-converse
    (efxmap`no-consume/U NC-MP1 N1!<MP1 MP1+N1+X1=M NC-X1)
    N2!<MP2 MP2+N2+X2=M NC-MP2
    <- nat`eq?-total N1==N2?
    <- efxmap`fresh-update-preserves-no-consume-converse/U
      N1==N2? NC-MP1 N1!<MP1 MP1+N1+X1=M NC-X1 N2!<MP2 MP2+N2+X2=M NC-MP2.

%worlds ()
(efxmap`fresh-update-preserves-no-consume-converse _ _ _ _)
(efxmap`fresh-update-preserves-no-consume-converse/U _ _ _ _ _ _ _ _).
%total (NC1 NC2)
(efxmap`fresh-update-preserves-no-consume-converse NC1 _ _ _)
(efxmap`fresh-update-preserves-no-consume-converse/U _ NC2 _ _ _ _ _ _).


%theorem efxmap`no-consume-respects-geq
  : forall* {M} {MP}
    forall {NC: efxmap`no-consume M}
    {L: efxmap`leq MP M}
    exists {NC: efxmap`no-consume MP}
    true.

- : efxmap`no-consume-respects-geq _ efxmap`leq/0 efxmap`no-consume/0.

%theorem efxmap`no-consume-respects-geq/L
  : forall* {M} {MP} {MS} {N} {X} {B}
    forall {NC: efxmap`no-consume MS}
    {F: efxmap`fresh MS N}
    {U: efxmap`update MS N X M}
    {NC: inner-efxmap`no-consume X}
    {L: efxmap`leq MP M}
    {DM?: efxmap`domain? MP N B}
    exists {NC: efxmap`no-consume MP}
    true.

- : efxmap`no-consume-respects-geq/L
    NC-MS N!<MS MS+N+X=M NC-X MP<=M (efxmap`domain?/in MP->N=XP)
    (efxmap`no-consume/U NC-MK N!<MK MK+N+XP=MP NC-XP)
    <- efxmap`lookup-implies-fresh-update MP->N=XP MK N!<MK MK+N+XP=MP
    <- efxmap`fresh-update-preserves-leq-converse
      MP<=M N!<MK MK+N+XP=MP N!<MS MS+N+X=M MK<=MS XP<=X
    <- efxmap`no-consume-respects-geq NC-MS MK<=MS NC-MK
    <- inner-efxmap`no-consume-respects-geq NC-X XP<=X NC-XP.

- : efxmap`no-consume-respects-geq/L
    NC-MS N!<MS MS+N+X=M NC-X MP<=M (efxmap`domain?/out N!<MP) NC-MP
    <- efxmap`fresh-update2-preserves-leq-converse
      MP<=M N!<MP N!<MS MS+N+X=M MP<=MS
    <- efxmap`no-consume-respects-geq NC-MS MP<=MS NC-MP.

- : efxmap`no-consume-respects-geq
    (efxmap`no-consume/U NC-MS N!<MS MS+N+X=M NC-X) MP<=M NC-MP
    <- efxmap`domain?-total DM?
    <- efxmap`no-consume-respects-geq/L
      NC-MS N!<MS MS+N+X=M NC-X MP<=M DM? NC-MP.

%worlds () (efxmap`no-consume-respects-geq _ _ _)
(efxmap`no-consume-respects-geq/L _ _ _ _ _ _ _).
%total (C1 C2) (efxmap`no-consume-respects-geq C1 _ _)
(efxmap`no-consume-respects-geq/L C2 _ _ _ _ _ _).


%theorem inner-efxmap`join-no-consume-right
  : forall* {M1} {M2} {M1P} {M2P} {M} {S}
    forall {DM: inner-efxmap`domain M2 S}
    {NC: inner-efxmap`no-consume M2}
    {J: inner-efxmap`join M1 M2 M}
    {SS: select-set M S M1P M2P}
    exists {NC: inner-efxmap`no-consume M2P}
    true.

- : inner-efxmap`join-no-consume-right
    DM-M2=S NC-M inner-efxmap`join/L M+S=>M1P+M2P NC-M2P
    <- select-set-implies-leq M+S=>M1P+M2P _ M2P<=M
    <- inner-efxmap`no-consume-respects-geq NC-M M2P<=M NC-M2P.

- : inner-efxmap`join-no-consume-right
    inner-efxmap`domain/0 _ inner-efxmap`join/R SS NC
    <- select-set-right-empty _ SS2
    <- select-set-unique SS2 SS inner-efxmap`eq/ set`eq/ E1 E2
    <- inner-efxmap`no-consume-respects-eq inner-efxmap`no-consume/0 E2 NC.

%theorem inner-efxmap`join-no-consume-right/U
  : forall* {M1} {M2S} {G2S} {N} {B} {G2} {M} {M2} {M1P} {M2P} {D}
    forall {DM?: inner-efxmap`domain? M1 N B}
    {T: inner-efxmap`domain M2S G2S}
    {FS: set`not-member G2S N}
    {U: set`add G2S N G2}
    {NC: inner-efxmap`no-consume M2S}
    {FS: inner-efxmap`fresh M2S N}
    {U: inner-efxmap`update M2S N D M2}
    {NC: efx`not-consume D}
    {J: inner-efxmap`join M1 M2 M}
    {SG: select-set M G2 M1P M2P}
    exists {NC: inner-efxmap`no-consume M2P}
    true.

- : inner-efxmap`join-no-consume-right/U (inner-efxmap`domain?/out N!<M1)
    M2S=>G2S N!<G2S G2S+N+S=G2 NC-M2S N!<M2S M2S+N+D=M2 NC-D
    M1+M2=M M+G2=M1P+M2P NC-M2P
    <- inner-efxmap`fresh-update-implies-unit-join N!<M2S M2S+N+D=M2 M2S+D=M2
    <- inner-efxmap`join-associative-converse M2S+D=M2 M1+M2=M MS M1+M2S=MS MS+D=M
    <- inner-efxmap`join-preserves-fresh* N!<M1 N!<M2S M1+M2S=MS N!<MS
    <- inner-efxmap`fresh-unit-join-implies-update N!<MS MS+D=M MS+N+D=M
    <- fresh-update-preserves-select-set-converse
      M+G2=M1P+M2P N!<MS (MS+N+D=M:inner-efxmap`update MS N D M)
      N!<G2S G2S+N+S=G2 _ M2PS+N+D=M2P MS+G2S=M1P+M2PS
    <- inner-efxmap`join-no-consume-right M2S=>G2S NC-M2S
      M1+M2S=MS MS+G2S=M1P+M2PS NC-M2PS
    <- inner-efxmap`update-preserves-no-consume
      NC-M2PS M2PS+N+D=M2P NC-D NC-M2P.

- : inner-efxmap`join-no-consume-right/U (inner-efxmap`domain?/in M1->N=D1)
    M2S=>G2S N!<G2S G2S+N+S2=G2 NC-M2S N!<M2S M2S+N+D2=M2 NC-D2
    M1+M2=M M+G2=M1P+M2P NC-M2P
    <- inner-efxmap`lookup-implies-fresh-update M1->N=D1 M1S N!<M1S M1S+N+D1=M1
    <- inner-efxmap`fresh-update-preserves-join-converse N!<M1S M1S+N+D1=M1
      N!<M2S M2S+N+D2=M2 M1+M2=M MS M1S+M2S=MS D1+D2=D N!<MS MS+N+D=M
    <- fresh-update-preserves-select-set-converse
      M+G2=M1P+M2P N!<MS MS+N+D=M N!<G2S G2S+N+S2=G2
      M2PS M2PS+N+D=M2P MS+G2S=M1P+M2PS
    <- inner-efxmap`join-no-consume-right
      M2S=>G2S NC-M2S M1S+M2S=MS MS+G2S=M1P+M2PS NC-M2PS
    <- efx`join-not-consume D1+D2=D NC-D2 NC-D
    <- inner-efxmap`update-preserves-no-consume NC-M2PS M2PS+N+D=M2P NC-D NC-M2P.

- : inner-efxmap`join-no-consume-right M2=>G2
    (inner-efxmap`no-consume/U NC-M2S N!<M2S M2S+N+D2=M2 NC-D2) M1+M2=M
    M+G2=M1P+M2P NC-M2P
    <- inner-efxmap`update-implies-lookup M2S+N+D2=M2 M2->N=D2
    <- inner-efxmap`domain-preserves-lookup M2->N=D2 M2=>G2 N<-G2
    <- set`member-implies-not-member-add N<-G2 G2S N!<G2S G2S+N=G2
    <- inner-efxmap`domain-commute-fresh-update-converse
      M2=>G2 N!<M2S M2S+N+D2=M2 N!<G2S G2S+N=G2 M2S=>G2S
    <- inner-efxmap`domain?-total DM?
    <- inner-efxmap`join-no-consume-right/U DM? M2S=>G2S
      N!<G2S G2S+N=G2 NC-M2S N!<M2S M2S+N+D2=M2
      NC-D2 M1+M2=M M+G2=M1P+M2P NC-M2P.

%worlds () (inner-efxmap`join-no-consume-right _ _ _ _ _)
(inner-efxmap`join-no-consume-right/U _ _ _ _ _ _ _ _ _ _ _).
%total (NC1 NC2) (inner-efxmap`join-no-consume-right _ NC1 _ _ _)
(inner-efxmap`join-no-consume-right/U _ _ _ _ NC2 _ _ _ _ _ _).


% ==== constructors of which result is no-consume  ====================
% =====================================================================

%theorem set2inner-efxmap-no-consume
  : forall* {S} {X} {M}
    forall {NC: efx`not-consume X}
    {T: set2inner-efxmap S X M}
    exists {NC: inner-efxmap`no-consume M}
    true.

- : set2inner-efxmap-no-consume _ set2inner-efxmap/0
    inner-efxmap`no-consume/0.

- : set2inner-efxmap-no-consume NC (set2inner-efxmap/U T NM U U2) NC-M
    <- set2inner-efxmap-no-consume NC T NC-MP
    <- inner-efxmap`update-preserves-no-consume NC-MP U2 NC NC-M.

%worlds () (set2inner-efxmap-no-consume _ _ _).
%total (T) (set2inner-efxmap-no-consume _ T _).


%theorem tgtmap2efxmap-no-consume
  : forall* {GM} {XM} {X}
    forall {NC-X: efx`not-consume X}
    {GM=>XM: tgtmap2efxmap GM X XM}
    exists {NC-XM: efxmap`no-consume XM}
    true.

- : tgtmap2efxmap-no-consume _ tgtmap2efxmap/0 efxmap`no-consume/0.

- : tgtmap2efxmap-no-consume
    NC-X (tgtmap2efxmap/U GP+X=>MP S+X=>M F U U1)
    (efxmap`no-consume/U NC-MP F1 U1 NC-M)
    <- tgtmap2efxmap-no-consume NC-X GP+X=>MP NC-MP
    <- set2inner-efxmap-no-consume NC-X S+X=>M NC-M
    <- tgtmap2efxmap-preserves-fresh F GP+X=>MP F1.

%worlds () (tgtmap2efxmap-no-consume _ _ _).
%total (A) (tgtmap2efxmap-no-consume _ A _). 


%theorem equiv-empty-no-consume
  : forall* {G} {M}
    forall {E: equiv-empty G}
    {M2G: efxmap2tgtmap M G}
    exists {NC: efxmap`no-consume M}
    true.

- : equiv-empty-no-consume equiv-empty/0 efxmap2tgtmap/0 efxmap`no-consume/0.

- : equiv-empty-no-consume
    (equiv-empty/U E-GP N1!<GP GP+N1+0=G)
    M2G (efxmap`no-consume/U NC F2 U DNC)
    <- efxmap2tgtmap/UP-inversion M2G N1!<GP GP+N1+0=G _ _ M2G2 DM U
    <- equiv-empty-no-consume E-GP M2G2 NC
    <- inner-efxmap`domain-empty-implies-empty DM E
    <- inner-efxmap`eq-symmetric E EP
    <- efxmap2tgtmap-preserves-fresh-converse N1!<GP M2G2 F2
    <- inner-efxmap`no-consume-respects-eq inner-efxmap`no-consume/0 EP DNC.

%worlds () (equiv-empty-no-consume _ _ _).
%total (E) (equiv-empty-no-consume E _ _).


%theorem set+nat2tgtmap-no-consume
  : forall* {S} {F} {GM} {X} {XM}
    forall {T: set+nat2tgtmap S F GM}
    {T2: tgtmap2efxmap GM X XM}
    {NC: efx`not-consume X}
    exists {NC: efxmap`no-consume XM}
    true.

- : set+nat2tgtmap-no-consume
    set+nat2tgtmap/0 tgtmap2efxmap/0 _ efxmap`no-consume/0.

- : set+nat2tgtmap-no-consume
    (set+nat2tgtmap/U SP=>GP N!<SP SP+N=S GP+N+F=G)
    G=>M NC-X NC-M
    <- set+nat2tgtmap-preserves-fresh SP=>GP N!<SP N!<GP
    <- tgtmap2efxmap/U-inversion G=>M N!<GP GP+N+F=G MP D GP=>MP S=>D MP+N+D=M
    <- set+nat2tgtmap-no-consume SP=>GP GP=>MP NC-X NC-MP
    <- set2inner-efxmap-no-consume NC-X S=>D NC-D
    <- efxmap`update-preserves-no-consume NC-MP MP+N+D=M NC-D NC-M.

%worlds () (set+nat2tgtmap-no-consume _ _ _ _).
%total (T) (set+nat2tgtmap-no-consume T _ _ _).


%theorem set2inner-efxmap-no-consume
  : forall* {S} {M} {X}
    forall {NC: efx`not-consume X}
    {S2M: set2inner-efxmap S X M}
    exists {NC: inner-efxmap`no-consume M}
    true.

- : set2inner-efxmap-no-consume
    _ set2inner-efxmap/0 inner-efxmap`no-consume/0.

- : set2inner-efxmap-no-consume NC-X
    (set2inner-efxmap/U TP NM A U)
    (inner-efxmap`no-consume/U NC-MP F U NC-X)
    <- set2inner-efxmap-no-consume NC-X TP NC-MP
    <- set2inner-efxmap-preserves-fresh NM TP F.

%worlds () (set2inner-efxmap-no-consume _ _ _).
%total (T) (set2inner-efxmap-no-consume _ T _).


%theorem tgtmap2efxmap-no-consume
  : forall* {G} {M} {X}
    forall {NC: efx`not-consume X}
    {G2M: tgtmap2efxmap G X M}
    exists {NC: efxmap`no-consume M}
    true.

- : tgtmap2efxmap-no-consume _ tgtmap2efxmap/0 efxmap`no-consume/0.

- : tgtmap2efxmap-no-consume
    NC-X (tgtmap2efxmap/U TP ST F U UP)
    (efxmap`no-consume/U NC-MP F2 UP NC-M)
    <- tgtmap2efxmap-no-consume NC-X TP NC-MP
    <- tgtmap2efxmap-preserves-fresh F TP F2
    <- set2inner-efxmap-no-consume NC-X ST NC-M.

%worlds () (tgtmap2efxmap-no-consume _ _ _).
%total (T) (tgtmap2efxmap-no-consume _ T _).

% ============================================================================

% ================================================================
% This lemma shows that, if we have a efxmap XM2 that contains
% no consume effect, and we have XM1 `join` XM2 = XM, then
% if we remove all targets in XM2 from XM, and get XM1P, XM2P,
% we can show XM2P also doesn't contain any consume effect.
% From another lemma we can also get the fact that XM2P has same
% targets as XM2. Thus, if XM2P gets converted to permission
% Pi1, and XM2 converted to permission Pi2, we can infer that
% Pi1 = Pi2 , Pi3, for some Pi3.
% ================================================================

%theorem efxmap`join-no-consume-right
  : forall* {M2} {G2} {M1} {M} {M1P} {M2P}
    forall {T: efxmap2tgtmap M2 G2}
    {NC: efxmap`no-consume M2}
    {J: efxmap`join M1 M2 M}
    {SG: select-tgtmap M G2 M1P M2P}
    exists {NC-M2: efxmap`no-consume M2P}
    true.

- : efxmap`join-no-consume-right
    M2=>G2 NC-M efxmap`join/L M+G2=>M1P+M2P NC-M2P
    <- select-tgtmap-implies-leq M+G2=>M1P+M2P _ M2P<=M
    <- efxmap`no-consume-respects-geq NC-M M2P<=M NC-M2P.

- : efxmap`join-no-consume-right
    M2G efxmap`no-consume/0 efxmap`join/R SG NC-M2
    <- efxmap2tgtmap-unique M2G efxmap2tgtmap/0 efxmap`eq/ M=0
    <- select-tgtmap-respects-eq SG efxmap`eq/ M=0 efxmap`eq/ efxmap`eq/ SG2
    <- select-tgtmap-right-equiv-empty SG2 _ E T EE-G2
    <- equiv-empty-no-consume EE-G2 T NC-M2.

%theorem efxmap`join-no-consume-right/U
  : forall* {M1} {M2S} {G2S} {N} {B} {S} {G2} {M} {M2} {M1P} {M2P} {D}
    forall {DM?: efxmap`domain? M1 N B}
    {T: efxmap2tgtmap M2S G2S}
    {FS: tgtmap`fresh G2S N}
    {U: tgtmap`update G2S N S G2}
    {NC: efxmap`no-consume M2S}
    {FS: efxmap`fresh M2S N}
    {U: efxmap`update M2S N D M2}
    {NC: inner-efxmap`no-consume D}
    {DM: inner-efxmap`domain D S}
    {J: efxmap`join M1 M2 M}
    {SG: select-tgtmap M G2 M1P M2P}
    exists {NC: efxmap`no-consume M2P}
    true.

- : efxmap`join-no-consume-right/U (efxmap`domain?/out N!<M1)
    M2S=>G2S N!<G2S G2S+N+S=G2 NC-M2S N!<M2S M2S+N+M=M2 NC-M
    (DM-M=S:inner-efxmap`domain D S) M1+M2=M M+G2=M1P+M2P NC-M2P
    <- efxmap`fresh-update-implies-unit-join N!<M2S M2S+N+M=M2 M2S+M=M2
    <- efxmap`join-associative-converse M2S+M=M2 M1+M2=M MS M1+M2S=MS MS+M=M
    <- efxmap`join-preserves-fresh* N!<M1 N!<M2S M1+M2S=MS N!<MS
    <- efxmap`fresh-unit-join-implies-update N!<MS MS+M=M MS+N+M=M
    <- fresh-update-preserves-select-tgtmap-converse
      M+G2=M1P+M2P N!<MS MS+N+M=M N!<G2S G2S+N+S=G2 M1PS M2PS _ _
      SS (M1PS+N+D1=M1P:efxmap`update M1PS N D1 M1P)
      (M2PS+N+D2=M2P:efxmap`update M2PS N D2 M2P)
      (MS+G2S=M1PS+M2PS:select-tgtmap MS G2S M1PS M2PS)
    <- select-set-self SS DM-M=S D=D2
    <- efxmap`join-no-consume-right M2S=>G2S NC-M2S
      M1+M2S=MS MS+G2S=M1PS+M2PS NC-M2PS
    <- inner-efxmap`no-consume-respects-eq NC-M D=D2 NC-D2
    <- efxmap`update-preserves-no-consume
      NC-M2PS M2PS+N+D2=M2P NC-D2 NC-M2P.

- : efxmap`join-no-consume-right/U (efxmap`domain?/in M1->N=D1)
    M2S=>G2S N!<G2S G2S+N+S2=G2 NC-M2S N!<M2S M2S+N+D2=M2 NC-D2 DM-D2=S2
    M1+M2=M M+G2=M1P+M2P NC-M2P
    <- efxmap`lookup-implies-fresh-update M1->N=D1 M1S N!<M1S M1S+N+D1=M1
    <- efxmap`fresh-update-preserves-join-converse N!<M1S M1S+N+D1=M1
      N!<M2S M2S+N+D2=M2 M1+M2=M MS M1S+M2S=MS D1+D2=D N!<MS MS+N+D=M
    <- fresh-update-preserves-select-tgtmap-converse
      M+G2=M1P+M2P N!<MS MS+N+D=M N!<G2S G2S+N+S2=G2
      M1PS M2PS _ _ SS N!<M2PS M2PS+N+DS=M2P MS+G2S=M1P+M2PS
    <- inner-efxmap`join-no-consume-right DM-D2=S2 NC-D2 D1+D2=D SS NC-MS
    <- efxmap`join-no-consume-right M2S=>G2S NC-M2S M1S+M2S=MS MS+G2S=M1P+M2PS NC-M2PS
    <- efxmap`update-preserves-no-consume NC-M2PS M2PS+N+DS=M2P NC-MS NC-M2P.

- : efxmap`join-no-consume-right M2=>G2
    (efxmap`no-consume/U NC-M2S N!<M2S M2S+N+M2=M2 NC-M2) M1+M2=M
    M+G2=M1P+M2P NC-M2P
    <- efxmap`update-implies-lookup M2S+N+M2=M2 M2->N=M2
    <- efxmap2tgtmap-lookup-implies-lookup M2=>G2 M2->N=M2 S2 DM-M2=S2 G2->N=S2
    <- tgtmap`lookup-implies-fresh-update G2->N=S2 G2S N!<G2S G2S+N+S2=G2
    <- fresh-update-preserves-efxmap2tgtmap-converse*
      M2=>G2 N!<M2S M2S+N+M2=M2 N!<G2S G2S+N+S2=G2 M2S=>G2S
    <- efxmap`domain?-total DM?
    <- efxmap`join-no-consume-right/U DM? M2S=>G2S
      N!<G2S G2S+N+S2=G2 NC-M2S N!<M2S M2S+N+M2=M2
      NC-M2 DM-M2=S2 M1+M2=M M+G2=M1P+M2P NC-M2P.

%worlds () (efxmap`join-no-consume-right _ _ _ _ _)
(efxmap`join-no-consume-right/U _ _ _ _ _ _ _ _ _ _ _ _).
%total (NC1 NC2) (efxmap`join-no-consume-right _ NC1 _ _ _)
(efxmap`join-no-consume-right/U _ _ _ _ NC2 _ _ _ _ _ _ _).



%theorem efx`join-no-consume-commutative
  : forall* {X1} {X2} {X}
    forall {NC-X2: efx`not-consume X2}
    {X1+X2=X: efx`join X1 X2 X}
    exists {X2+X1=X: efx`join X2 X1 X}
    true.

- : efx`join-no-consume-commutative
    efx`not-consume/read efx`join/rr efx`join/rr.

- : efx`join-no-consume-commutative
    efx`not-consume/read efx`join/wr efx`join/rw.

- : efx`join-no-consume-commutative
    efx`not-consume/write efx`join/rw efx`join/wr.

- : efx`join-no-consume-commutative
    efx`not-consume/write efx`join/ww efx`join/ww.

%worlds () (efx`join-no-consume-commutative _ _ _).
%total {} (efx`join-no-consume-commutative _ _ _). 


%theorem inner-efxmap`join-no-consume-commutative
  : forall* {M1} {M2} {M}
    forall {NC-M2: inner-efxmap`no-consume M2}
    {M1+M2=M: inner-efxmap`join M1 M2 M}
    exists {M2+M1=M: inner-efxmap`join M2 M1 M}
    true.

%worlds () (inner-efxmap`join-no-consume-commutative _ _ _).
%trustme %total {} (inner-efxmap`join-no-consume-commutative _ _ _).


%theorem efxmap`join-no-consume-commutative
  : forall* {XM1} {XM2} {XM}
    forall {NC-XM2: efxmap`no-consume XM2}
    {XM1+XM2=XM: efxmap`join XM1 XM2 XM}
    exists {XM2+XM1=XM: efxmap`join XM2 XM1 XM}
    true.

%worlds () (efxmap`join-no-consume-commutative _ _ _).
%trustme %total {} (efxmap`join-no-consume-commutative _ _ _).
