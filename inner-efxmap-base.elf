%%% inner effect map
%%% $Id: inner-efxmap-base.elf,v 1.1 2013/05/06 02:38:40 csun Exp csun $

% 
%{%
#define data efx
#define DATA_JOIN_DETERMINISTIC 1
#define DATA_JOIN_IMPLIES_LEQ 1
#define DATA_JOIN_ASSOCIATIVE 1
BEGIN_ELF
#include "map-base.elf"
#include "map-leq.elf"
#include "map-join.elf"
#include "map-join-leq.elf"

%theorem join-implies-leq :
    forall* {M1} {M2} {M3}
    forall  {J: join M1 M2 M3}
    exists  {L: leq M1 M3} {L: leq M2 M3}
    true.

- : join-implies-leq join/L leq/0 M2<=M2
    <- leq-reflexive _ M2<=M2.

- : join-implies-leq join/R M2=M2 leq/0
    <- leq-reflexive _ M2=M2.

- : join-implies-leq (join/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                      (leq/= M1<=M3 D1<=D3 nat`eq/)
    (leq/= M2<=M3 D2<=D3 nat`eq/)
    <- data`join-implies-leq D1+D2=D3 D1<=D3 D2<=D3
    <- join-implies-leq M1+M2=M3 M1<=M3 M2<=M3.

- : join-implies-leq (join/< M1+M022=M3 P) 
    (leq/= M1<=M3 D1<=D1 nat`eq/) (leq/> M022<=M3 P)
    <- data`leq-reflexive _ D1<=D1
    <- join-implies-leq M1+M022=M3 M1<=M3 M022<=M3.

- : join-implies-leq (join/> M311+M2=M3 P) 
    (leq/> M311<=M3 P) (leq/= M2<=M3 D2<=D2 nat`eq/)
    <- data`leq-reflexive _ D2<=D2
    <- join-implies-leq M311+M2=M3 M311<=M3 M2<=M3.

%worlds () (join-implies-leq _ _ _).
%total (J) (join-implies-leq J _ _).

#include "map-domain.elf"
#include "map-restrict.elf"
#include "map-restrict-extra.elf"
END_ELF

#undef data
%}%

%abbrev inner-efxmap = map.
%abbrev inner-efxmap/0 = map/0.
%abbrev inner-efxmap/+ = map/+.