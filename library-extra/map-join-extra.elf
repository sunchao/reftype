%%% Extra theorems about map-join



fresh-update-preserves-join-converse
  : fresh M1P N
    -> update M1P N D1 M1
    -> fresh M2P N
    -> update M2P N D2 M2
    -> join M1 M2 M
    -> {MP} join M1P M2P MP
    -> data`join D1 D2 D
    -> fresh MP N
    -> update MP N D M
    -> type.
%mode fresh-update-preserves-join-converse +F1 +U1 +F2 +U2 +J -MP -JP -DJ -F3 -U3.

- : fresh-update-preserves-join-converse 
    (N!<M1P:fresh M1P N) M1P+N+D1=M1 
    (N!<M2P:fresh M2P N) M2P+N+D2=M2
    (M1+M2=M:join M1 M2 M) MP M1P+M2P=MP D1+D2=D N!<MP MP+N+D=M
    <- fresh-update-implies-unit-join N!<M1P M1P+N+D1=M1 M1P+D1=M1
    <- fresh-update-implies-unit-join N!<M2P M2P+N+D2=M2 M2P+D2=M2
    <- join-associative M1P+D1=M1 M1+M2=M D1M2 D1+M2=D1M2 M1P+D1M2=M
    <- fresh-implies-unit-disjoint N!<M2P M2P^D2
    <- disjoint-join-commutative M2P^D2 M2P+D2=M2 D2+M2P=M2
    <- join-associative-converse 
      D2+M2P=M2 D1+M2=D1M2 D1D2 D1+D2=D1D2 D1D2+M2P=D1M2
    <- join/=-inversion D1+D2=D1D2 nat`eq/ _ _ D1+D2=D _ D1D2=D
    <- eq-symmetric D1D2=D D=D1D2
    <- fresh-implies-unit-disjoint N!<M2P M2P^D
    <- disjoint-respects-eq M2P^D eq/ D=D1D2 M2P^D1D2
    <- disjoint-symmetric M2P^D1D2 D1D2^M2P
    <- disjoint-join-commutative D1D2^M2P D1D2+M2P=D1M2 M2P+D1D2=D1M2
    <- join-associative-converse 
      M2P+D1D2=D1M2 M1P+D1M2=M MP M1P+M2P=MP MP+D1D2=M
    <- join-respects-eq MP+D1D2=M eq/ D1D2=D eq/ MP+D=M
    <- join-preserves-fresh* N!<M1P N!<M2P M1P+M2P=MP N!<MP
    <- fresh-unit-join-implies-update N!<MP MP+D=M MP+N+D=M.

%worlds (WORLDS) (fresh-update-preserves-join-converse _ _ _ _ _ _ _ _ _ _).
%total {} (fresh-update-preserves-join-converse _ _ _ _ _ _ _ _ _ _).


join-preserves-fresh-update-left
  : join M1S M2S MS
    -> fresh M1S N
    -> update M1S N D M1
    -> fresh M2S N
    -> {M} join M1 M2S M
    -> fresh MS N 
    -> update MS N D M
    -> type.
%mode join-preserves-fresh-update-left +J +F1 +U1 +F2 -M -J2 -F3 -U3.

- : join-preserves-fresh-update-left
    M1S+M2S=MS N!<M1S M1S+N+D=M1 N!<M2S M M1+M2S=M N!<MS MS+N+D=M
    <- fresh-update-implies-unit-join N!<M1S M1S+N+D=M1 M1S+D=M1
    <- join-preserves-fresh* N!<M1S N!<M2S M1S+M2S=MS N!<MS
    <- update-total MS+N+D=M
    <- fresh-update-implies-unit-join N!<MS MS+N+D=M MS+D=M
    <- fresh-implies-unit-disjoint N!<MS MS^M
    <- disjoint-join-commutative MS^M MS+D=M M+MS=M
    <- join-associative  M1S+M2S=MS MS+D=M MK M2S+D=MK M1S+MK=M
    <- fresh-implies-unit-disjoint N!<M2S M2S^M
    <- disjoint-join-commutative M2S^M M2S+D=MK M+M2S=MK
    <- join-associative-converse M+M2S=MK M1S+MK=M MQ M1S+D=MQ MQ+M2S=M
    <- fresh-unit-join-implies-update N!<M1S M1S+D=MQ M1S+N+D=MQ
    <- update-unique M1S+N+D=MQ M1S+N+D=M1 eq/ nat`eq/ data`eq/ MQ=M1
    <- join-respects-eq MQ+M2S=M MQ=M1 eq/ eq/ M1+M2S=M.

%worlds (WORLDS) (join-preserves-fresh-update-left _ _ _ _ _ _ _ _).
%total {} (join-preserves-fresh-update-left _ _ _ _ _ _ _ _).


%{%
#ifdef MAP_LEQ
#ifdef DATA_JOIN_IMPLIES_LEQ
#ifndef DATA_JOIN_COMMUTATIVE
%}%

%theorem join-implies-leq :
	forall* {M1} {M2} {M3}
	forall {J:join M1 M2 M3}
        exists {L1:leq M1 M3} {L2:leq M2 M3}
	true.

- : join-implies-leq join/L leq/0 M2=M2
    <- leq-reflexive _ M2=M2.

- : join-implies-leq join/R M1=M1 leq/0
    <- leq-reflexive _ M1=M1.

- : join-implies-leq (join/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                      (leq/= M1<=M3 D1<=D3 nat`eq/)
                      (leq/= M2<=M3 D2<=D3 nat`eq/)
    <- data`join-implies-leq D1+D2=D3 D1<=D3 D2<=D3
    <- join-implies-leq M1+M2=M3 M1<=M3 M2<=M3.

- : join-implies-leq (join/< M1+M211=M3 P) (leq/= M1<=M3 D1<=D1 nat`eq/)
    (leq/> M211<=M3 P)
    <- data`leq-reflexive _ D1<=D1
    <- join-implies-leq M1+M211=M3 M1<=M3 M211<=M3.	

- : join-implies-leq (join/> M311+M2=M3 P) (leq/> M311<=M3 P) 
    (leq/= M2<=M3 D2<=D2 nat`eq/)
    <- data`leq-reflexive _ D2<=D2
    <- join-implies-leq M311+M2=M3 M311<=M3 M2<=M3.

%worlds (WORLDS) (join-implies-leq _ _ _).
%total (J) (join-implies-leq J _ _).

%{%
#endif /* DATA_JOIN_IMPLIES_LEQ */
#endif /* DATA_JOIN_COMMUTATIVE */
%}%


%theorem join-disjoint-right-leq-implies-leq/L :
    forall* {M1} {M2} {M3} {M}
    forall  {N1} {SZ: size M1 N1} 
            {N2} {SZ: size M2 N2}
            {M1UM2=M: join M1 M2 M}
            {M2^M3: disjoint M2 M3}
            {M3<=M: leq M3 M}
    exists  {M3<=M1: leq M3 M1}
    true.

- : join-disjoint-right-leq-implies-leq/L _ _ _ _ join/L D LE LE2
    <- disjoint-symmetric D DP
    <- disjoint-leq-implies-empty DP LE EE
    <- eq-symmetric EE E
    <- leq-reflexive _ LE3
    <- leq-respects-eq LE3 eq/ E LE2.

- : join-disjoint-right-leq-implies-leq/L _ _ _ _ join/R _ LE LE.

- : join-disjoint-right-leq-implies-leq/L
    _ _ _ _ _ disjoint/R _ leq/0.

- : join-disjoint-right-leq-implies-leq/L _ _ _ _
    (join/< _ P1) (disjoint/< _ P2)
    (leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- false-implies-leq F LE.

% SHP and SH2 unified.
- : join-disjoint-right-leq-implies-leq/L _ (size/+ SZ)
    _ (size/+ SZ2)
    (join/< J P1) D (leq/> LE P2) (leq/> LE3P P2)
    <- nat`plus-swap-succ P1 P1P
    <- nat`plus-commutative P1P P1S
    <- shift-total SH
    <- shift-preserves-join J SH (shift/+ P1S) _ SHP JP
    <- nat`plus-swap-succ P2 P2P
    <- nat`plus-commutative P2P P2S
    <- shift-preserves-leq LE (shift/+ P2S) SHP LE2
    <- shift-preserves-size SZ SH SZK
    <- join-disjoint-right-leq-implies-leq/L
      _ SZK _ (size/+ SZ2) JP D LE2 LE3
    <- shift-preserves-leq-converse LE3 (shift/+ P2S) SH LE3P.

- : join-disjoint-right-leq-implies-leq/L
    _ (size/+ SZ) _ (size/+ SZ2)
    (join/< J P1) (disjoint/> D P2)
    (leq/= LE M-LE nat`eq/) (leq/= LEE M-LE nat`eq/)
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- map/+-preserves-eq EQ data`eq/ eq/ MEQ
    <- join-respects-eq J eq/ MEQ eq/ JP
    <- join-disjoint-right-leq-implies-leq/L
      _ SZ _ (size/+ SZ2) JP D LE LEE.

- : join-disjoint-right-leq-implies-leq/L 
    _ (size/+ SZ) _ (size/+ SZ2)
    (join/> J P1) (disjoint/< D P2) (leq/> LE P3) LEE2
    <- nat`plus-right-cancels P2 P3 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- map/+-preserves-eq EQ data`eq/ eq/ MEQ
    <- disjoint-respects-eq D eq/ MEQ DP
    <- join-disjoint-right-leq-implies-leq/L 
      _ (size/+ SZ) _ SZ2 J DP LE LEE
    <- nat`plus-swap-succ P3 P3S
    <- nat`plus-commutative P3S P3P
    <- nat`plus-swap-succ P1 P1S
    <- nat`plus-commutative P1S P1P
    <- shift-preserves-leq
      LEE (shift/+ P3P) (shift/+ P1P) LEE2.

- : join-disjoint-right-leq-implies-leq/L _ _ _ _
    (join/= _ _ nat`eq/) (disjoint/< _ P)
    (leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : join-disjoint-right-leq-implies-leq/L _ _ _ _
    (join/= _ _ nat`eq/) (disjoint/> _ P)
    (leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : join-disjoint-right-leq-implies-leq/L _ _ _ _
    (join/> _ _) (disjoint/< _ P)
    (leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : join-disjoint-right-leq-implies-leq/L _ _ _ _
    (join/> _ _) (disjoint/> _ P) 
    (leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- false-implies-leq F LE.

- : join-disjoint-right-leq-implies-leq/L _ _ _ _
    (join/= _ _ nat`eq/) (disjoint/> _ P1) 
    (leq/> _ P2) LE
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- false-implies-leq F LE.

- : join-disjoint-right-leq-implies-leq/L
    _ (size/+ SZ) _ (size/+ SZ2)
    (join/= J M-J nat`eq/) (disjoint/< D P1) 
    (leq/> LE P2) (leq/> LEP P2)
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- map/+-preserves-eq EQ data`eq/ eq/ MEQ
    <- disjoint-respects-eq D eq/ MEQ DP
    <- join-disjoint-right-leq-implies-leq/L _ SZ _ SZ2 J DP LE LEP.

- : join-disjoint-right-leq-implies-leq/L _ _ _ _
    (join/> _ _) (disjoint/> _ P1) (leq/> _ P2) LE
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- false-implies-leq F LE.

%worlds (WORLDS) (join-disjoint-right-leq-implies-leq/L _ _ _ _ _ _ _ _).
%total {N1 N2} (join-disjoint-right-leq-implies-leq/L N1 _ N2 _ _ _ _ _).



%theorem join-disjoint-right-leq-implies-leq :
    forall* {M1} {M2} {M3} {M}
    forall  {M1UM2=M: join M1 M2 M}
            {M2^M3: disjoint M2 M3}
            {M3<=M: leq M3 M}
    exists  {M3<=M1: leq M3 M1}
    true.

- : join-disjoint-right-leq-implies-leq U D LE LE2
    <- size-total SZ1
    <- size-total SZ2
    <- join-disjoint-right-leq-implies-leq/L _ SZ1 _ SZ2 U D LE LE2.

%worlds (WORLDS) (join-disjoint-right-leq-implies-leq _ _ _ _).
%total {} (join-disjoint-right-leq-implies-leq _ _ _ _).


%{%
#ifdef JOIN_COMMUTATIVE
%}%
%theorem join-disjoint-leq-implies-leq
  : forall* {M1} {M2} {M3} {M}
    forall {M1UM2=M: join M1 M2 M}
    {M2^M3: disjoint M1 M3}
    {M3<=M: leq M3 M}
    exists {M3<=M1: leq M3 M2}
    true.

- : join-disjoint-leq-implies-leq J X L LP
    <- join-commutative J JP
    <- join-right-leq-implies-leq JP X L LP.

%worlds () (join-disjoint-leq-implies-leq _ _ _ _).
%total {} (join-disjoint-leq-implies-leq _ _ _ _).

%{%
#endif /* JOIN_COMMUTATIVE */
#endif /* MAP_LEQ */
%}%