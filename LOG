2013-02-19
----------

Cannot check expression like:

  let x = {a, a.f} in x.g end

The reason is permission for a.f is encumbered while checking
x.g.

2013-03-04
----------

Right now I am using a special target 0.0 to represent 
the world target. However, this causes much problem in 
transformation. Maybe we don't need to represent the "world" target
at all. 

2013-03-05
----------

Looks like we need a special treatment on shared type. 
For shared type, it should be associated with no target, since all
effects are mapped to the world object, and we enforce that
the input and output both have write shared effects.

Checking shared targets should be pretty easy, suppose we have a 
expression a.b.c...f, then on the path from f to a, any of them
is shared type, then the target should be shared, otherwise it
will be unique, and have a set and tgtmap associated.

[after a lot of changes...]

A problem occured when proving s.u, 
we need to have this unique permission in the output. However,
the current transformation only takes reftgts as input, and thus
will produce a nesting fact about the result value, which is 
not correct. 

 
Let's consider the four possible cases:

base (e)       field  (f)      result targets      result effects
unique         unique          unique {e.f}        X e.f
unique         shared          shared              X shared
shared         unique          
shared         shared         

