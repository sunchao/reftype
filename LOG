2013-02-19
----------

Cannot check expression like:

  let x = {a, a.f} in x.g end

The reason is permission for a.f is encumbered while checking
x.g.

2013-03-04
----------

Right now I am using a special target 0.0 to represent 
the world target. However, this causes much problem in 
transformation. Maybe we don't need to represent the "world" target
at all. 

2013-03-05
----------

Looks like we need a special treatment on shared type. 
For shared type, it should be associated with no target, since all
effects are mapped to the world object, and we enforce that
the input and output both have write shared effects.

Checking shared targets should be pretty easy, suppose we have a 
expression a.b.c...f, then on the path from f to a, any of them
is shared type, then the target should be shared, otherwise it
will be unique, and have a set and tgtmap associated.

[after a lot of changes...]

A problem occured when proving s.u, 
we need to have this unique permission in the output. However,
the current transformation only takes reftgts as input, and thus
will produce a nesting fact about the result value, which is 
not correct. 

 
Let's consider the four possible cases:

base (e)       field  (f)      result targets      result effects
unique         unique          unique {e.f}        X e.f
unique         shared          shared              X shared
shared         unique          
shared         shared         

2013-03-21
----------
In the typing rules for read, we have a restriction
that the object target set should be disjoint with the
key sets of field target set. This is because the case:

(if x < 3 then a else a.f).f

To type check the above, we first need to type check
if x < 3 then a else a.f, and get following permission as output:

\exists z \exists r
    (r == r_a \/ r == r' + 
    z(r'.all -> 0 + P(r')) + z(r'.all -> 0 + P(r')) --+- 
    \exists r_f z(r.f -> r_f + r_f.all -> 0 + P(r_f)))

(assuming f is unique)

The input effect for above is "read a.f"

Then, to check the whole expression, we have "write a.f" as 
input effect, and we have essentially the same permission
as above except the fraction z is removed. 

The problem is we cannot use this permission to read field f,
since we need (\exists r_f (r.f -> r_f + r_f.all -> 0 + P(r_f)))
to check the "then" case, but this permission is encumbered
by the "else" case. 
