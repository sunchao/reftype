%%% Explicit type context.
%%% A context is a mapping from object to its identifier and type
%%% Each object in context is associated with an unique natural number,
%%% and we need to enforce this property for every well-formed context.

%%% Definitions

cxt : type. %name cxt B.

cxt/nil : cxt.

% here the nat is the identifier for the object
cxt/cons : nat -> object -> ty -> cxt -> cxt.


cxt`eq : cxt -> cxt -> type.

cxt`eq/ : cxt`eq B B.


%{
 Two objects are not equal if their representing nat is
 not equal (of course). This is defined in simple-concur/object.elf,
 but is later overwritten by frac-nesting/permission.elf.
}%

object`ne : object -> object -> type.

object`ne/ : nat`ne N1 N2 -> object`ne (object/ N1) (object/ N2).


% lookup operation

cxt`lookup : cxt -> nat -> object -> ty -> type.

cxt`lookup/hit : cxt`lookup (cxt/cons N O T B) N O T.

cxt`lookup/miss
  : cxt`lookup (cxt/cons N' _ _ B) N O T
    <- cxt`lookup B N O T.


cxt`lookup-obj : cxt -> object -> nat -> ty -> type.

cxt`lookup-obj/hit : cxt`lookup-obj (cxt/cons N O T B) O N T.

cxt`lookup-obj/miss
  : cxt`lookup-obj (cxt/cons _ O' _ B) O N T
    <- cxt`lookup-obj B O N T.


%%% Theorems

%theorem cxt`lookup-obj-respects-eq
  : forall* {B1} {B2} {O1} {O2} {T1} {T2} {N1} {N2}
    forall {L: cxt`lookup-obj B1 O1 N1 T1}
    {E: cxt`eq B1 B2} {E: object`eq O1 O2}
    {E: nat`eq N1 N2} {E: ty`eq T1 T2}
    exists {L: cxt`lookup-obj B2 O2 N2 T2}
    true.

- : cxt`lookup-obj-respects-eq L cxt`eq/ object`eq/ nat`eq/ ty`eq/ L.

%worlds (objvar) (cxt`lookup-obj-respects-eq _ _ _ _ _ _).
%total {} (cxt`lookup-obj-respects-eq _ _ _ _ _ _).


%theorem cxt`lookup-respects-eq
  : forall* {B1} {B2} {O1} {O2} {T1} {T2} {N1} {N2}
    forall {L: cxt`lookup B1 N1 O1 T1}
    {E: cxt`eq B1 B2} {E: nat`eq N1 N2}
    {E: object`eq O1 O2} {E: ty`eq T1 T2}
    exists {L: cxt`lookup B2 N2 O2 T2}
    true.

- : cxt`lookup-respects-eq L cxt`eq/ nat`eq/ object`eq/ ty`eq/ L.

%worlds (objvar) (cxt`lookup-respects-eq _ _ _ _ _ _).
%total {} (cxt`lookup-respects-eq _ _ _ _ _ _).


%theorem cxt`eq/cons-inversion
  : forall* {O1} {O2} {T1} {T2} {B1} {B2} {N1} {N2}
    forall {E: cxt`eq (cxt/cons N1 O1 T1 B1) (cxt/cons N2 O2 T2 B2)}
    exists {OE: object`eq O1 O2} {NE: nat`eq N1 N2}
    {E: ty`eq T1 T2} {E: cxt`eq B1 B2}
    true.

- : cxt`eq/cons-inversion cxt`eq/ object`eq/ nat`eq/ ty`eq/ cxt`eq/.

%worlds (objvar) (cxt`eq/cons-inversion _ _ _ _ _).
%total {} (cxt`eq/cons-inversion _ _ _ _ _).


%theorem cxt`lookup-obj-unique
  : forall* {B1} {B2} {O1} {O2} {T1} {T2} {N1} {N2}
    forall {L1: cxt`lookup-obj B1 O1 N1 T1}
    {L2: cxt`lookup-obj B2 O2 N2 T2}
    {E: cxt`eq B1 B2} {E: object`eq O1 O2}
    exists {E: nat`eq N1 N2} {E: ty`eq T1 T2}
    true.

- : cxt`lookup-obj-unique cxt`lookup-obj/hit cxt`lookup-obj/hit
    cxt`eq/ object`eq/ nat`eq/ ty`eq/.

- : cxt`lookup-obj-unique
    (cxt`lookup-obj/miss L1 N1) (cxt`lookup-obj/miss L2 N2) CE OE NE TE
    <- cxt`eq/cons-inversion CE _ _ _ CE1
    <- cxt`lookup-obj-unique L1 L2 CE1 OE NE TE.

- : cxt`lookup-obj-unique (cxt`lookup-obj/hit)
    (cxt`lookup-obj/miss _ (object`ne/ N<>N)) cxt`eq/ object`eq/ NE E
    <- nat`ne-anti-reflexive N<>N F
    <- nat`false-implies-eq F NE
    <- ty`false-implies-eq F E.

- : cxt`lookup-obj-unique (cxt`lookup-obj/miss _ (object`ne/ N<>N))
    (cxt`lookup-obj/hit) cxt`eq/ object`eq/ NE E
    <- nat`ne-anti-reflexive N<>N F
    <- nat`false-implies-eq F NE
    <- ty`false-implies-eq F E.

%worlds (objvar) (cxt`lookup-obj-unique _ _ _ _ _ _).
%total (L) (cxt`lookup-obj-unique L _ _ _ _ _).


%theorem cxt-lookup-obj-implies-lookup
  : forall* {B} {N} {O} {T}
    forall {BLO: cxt`lookup-obj B O N T}
    exists {BL: cxt`lookup B N O T}
    true.

- : cxt-lookup-obj-implies-lookup cxt`lookup-obj/hit cxt`lookup/hit.

- : cxt-lookup-obj-implies-lookup (cxt`lookup-obj/miss BLO _)
    (cxt`lookup/miss BL _)
    <- cxt-lookup-obj-implies-lookup BLO BL.

%worlds () (cxt-lookup-obj-implies-lookup _ _).
%total { } (cxt-lookup-obj-implies-lookup _ _).