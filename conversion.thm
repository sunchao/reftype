%%% Theorems about conversion

%theorem reftyping-ok/expr
  : forall* {CM} {PM} {MM} {W} {K} {E: term K} {R: result K} {V} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-V: clsmap-cxt-env CM B V}
    {RTYP: reftyping CM MM B V E R}
    exists {PiB} {Pi} {Out}
    {B=>PiB: cxt2perm PM B PiB}
    {XX2I: env2input CM PM B V Pi}
    {XX2O: result2output CM PM B R Out}
    {TYP: typing W (PiB , Pi) E Out}
    true.

%theorem reftyping-ok/args
  : forall* {CM} {PM} {MM} {B} {V} {A} {MT} {AR} {W}
    forall {Pi0} {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-V: clsmap-cxt-env CM B V}
    {RTYP: argsRefTyping CM MM B V A MT AR}
    exists {PiB} {Pi} {Out}
    {B=>PiB: cxt2perm PM B PiB}
    {V=>Pi: env2input CM PM B V Pi}
    {TYP: typing W (Pi0 , (PiB , Pi)) A Out}
    {R=>Out: result2output* CM PM B Pi0 AR Out}
    true.

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ _))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1) (sub-annot/fresh _))
      (ATYP:argsRefTyping CM MM B _ A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/combine
                            (equiv/transitive
                              (equiv/combine (PiB0<=>PiB1 o r p)
                                (equiv/combine equiv/reflexive (PiV1<=>PiV11 o r p)))
                              (equiv/reorder))
                            (equiv/symmetric equiv/identity))
                          (equiv/swap)))
                      (equiv/commute)
                      (equiv/swap))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 capset2perm/0) RT=>PiT  AR=>AOut)
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0) V1=>PiV1
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-B-U1 CM-B-M1))
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , empty)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U1 CM-B-M1) ATYP _
         _ _ (B=>PiB1 x o p) (V1=>PiV11 x o p) (TYP-A x o p) (AR=>AOut x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- ({x}{o}{p} env2input-unique V1=>PiV1 (V1=>PiV11 x o p) env`eq/ (PiV1<=>PiV11 x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ (env/ U1 M1)))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/borrow (S+FS=>MF:set+set2set S FS MF)
          (M1-MF=M2:set`split M1 MF M2)))
      (ATYP:argsRefTyping CM MM B (env/ U1 M2) A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine
                        (implies/combine (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/equiv (PiU1<=>PiU1P o r p))
                              (implies/equiv
                                (equiv/transitive
                                  (PiM1<=>PiMF+PiM2)
                                  (equiv/combine equiv/reflexive (PiM2<=>PiM2P o r p)))))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive5
                        (equiv/combine equiv/reflexive
                          (equiv/transitive
                            (equiv/identity)
                            (equiv/reorder)))
                        (equiv/associate)
                        (equiv/combine equiv/reflexive
                          (equiv/roll3))
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive3
                            (equiv/combine equiv/reflexive
                              (equiv/transitive (equiv/symmetric equiv/identity) equiv/commute))
                            (equiv/symmetric equiv/associate)
                            (equiv/commute))
                          (equiv/reflexive))))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 MF=>PiMF) RT=>PiT AR=>AOut)
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0)
        (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-U1 CM-M1))
    <- set`split-implies-leq M1-MF=M2 MF<=M1 M2<=M1
    <- clsmap-cxt-capset-respects-geq CM-M1 M2<=M1 CM-M2
    <- set`split-implies-permission-combine M1-MF=M2 M1=>PiM1
      PiMF PiM2 MF=>PiMF M2=>PiM2 PiM1<=>PiMF+PiM2
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , PiMF)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U1 CM-M2) ATYP _
         _ _ (B=>PiB1 x o p) (env2input/ (U1=>PiU1P x o p) (M2=>PiM2P x o p))
         (TYP-A x o p) (AR=>AOut x o p))
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} capset2perm-equiv M2=>PiM2 (M2=>PiM2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiM2<=>PiM2P x o p))
    <- ({x}{o}{p} make-encumbered-equiv U1=>PiU1 (U1=>PiU1P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiU1<=>PiU1P x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ (env/ U1 M1)))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/unique CML DM-FM=FS (S+FS=>MF:set+set2set S FS MF)
          (M1-MF=M2:set`split M1 MF M2) (S<=U1:set`leq S U1)
          (U1-S=U2: set`remove U1 S U2) _))
      (ATYP:argsRefTyping CM MM B (env/ U2 M2) A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine
                        (implies/combine (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/equiv
                                (equiv/transitive
                                  PiU1<=>PiS+PiU2
                                  (equiv/combine equiv/reflexive (PiU2<=>PiU2P o r p))))
                              (implies/equiv
                                (equiv/transitive
                                  (PiM1<=>PiMF+PiM2)
                                  (equiv/combine equiv/reflexive (PiM2<=>PiM2P o r p)))))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive4
                        (equiv/combine equiv/reflexive
                          (equiv/transitive
                            (equiv/combine
                              (equiv/transitive
                                (equiv/combine (equiv/reflexive) % PiB1
                                  (equiv/transitive
                                    (equiv/combine (equiv/reflexive) % Pif
                                      (equiv/swap-middle))
                                    (equiv/associate)))
                                (equiv/reorder))
                              (equiv/reflexive))
                            (equiv/commute)))
                        (equiv/associate)
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive
                            (equiv/combine (equiv/identity) equiv/reflexive)
                            (equiv/commute))
                          (equiv/reflexive))))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ S=>PiS MF=>PiMF) RT=>PiT AR=>AOut)
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0)
        (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-U1 CM-M1))
    <- set`remove-implies-leq U1-S=U2 U2<=U1
    <- clsmap-cxt-objset-respects-geq CM-U1 U2<=U1 CM-U2
    <- set`split-implies-leq M1-MF=M2 MF<=M1 M2<=M1
    <- clsmap-cxt-capset-respects-geq CM-M1 M2<=M1 CM-M2
    <- make-encumbered-intro S<=U1 U1-S=U2 U1=>PiU1 PiS PiU2 S=>PiS U2=>PiU2 PiU1<=>PiS+PiU2
    <- set`split-implies-permission-combine M1-MF=M2 M1=>PiM1
      PiMF PiM2 MF=>PiMF M2=>PiM2 PiM1<=>PiMF+PiM2
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (PiS , PiMF)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U2 CM-M2) ATYP _
         _ _ (B=>PiB1 x o p) (env2input/ (U2=>PiU2P x o p) (M2=>PiM2P x o p))
         (TYP-A x o p) (AR=>AOut x o p))
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} capset2perm-equiv M2=>PiM2 (M2=>PiM2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
      set`eq/ (PiM2<=>PiM2P x o p))
    <- ({x}{o}{p} make-encumbered-equiv U2=>PiU2 (U2=>PiU2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiU2<=>PiU2P x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ _))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/shared))
      (ATYP:argsRefTyping CM MM B _ A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans3
                    (implies/combine implies/reflexive
                      (implies/combine
                        (implies/combine
                          (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/equiv (PiV1<=>PiV11 o r p))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/combine equiv/reflexive
                          (equiv/transitive3
                            (equiv/combine (equiv/roll2) equiv/reflexive)
                            (equiv/commute)
                            (equiv/associate)))
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive
                            (equiv/commute)
                            (equiv/combine equiv/commute equiv/reflexive))
                          (equiv/reflexive))))
                    (implies/combine
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/equiv (equiv/symmetric equiv/identity)))
                        (implies/reflexive))
                      (implies/reflexive))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 capset2perm/0) RT=>PiT  AR=>AOut)
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0) V1=>PiV1
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-B-U1 CM-B-M1))
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , empty)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U1 CM-B-M1) ATYP _
         _ _ (B=>PiB1 x o p) (V1=>PiV11 x o p) (TYP-A x o p) (AR=>AOut x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- ({x}{o}{p} env2input-unique V1=>PiV1 (V1=>PiV11 x o p) env`eq/ (PiV1<=>PiV11 x o p)).

- : reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-B-V
    (argsRefTyping/0) _ _ _ B=>PiB V=>Pi
    (tTrans2 tArgs0
      (transform/args/0
        (implies/reflexive)))
    (result2output/args/0 B=>PiB V=>Pi)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>PiB
    <- clsmap-cxt-env-implies-env2input CM-CM CM2PM CM-B-V _ V=>Pi.


%theorem reftyping-ok/expr/write
  : forall* {CM} {MM} {PM} {W} {F} {E2} {G} {T} {Out1} {Rslt1} {Rslt2} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-Rslt: clsmap-result CM B Rslt1}
    {Rslt1=>Out1: result2output CM PM B Rslt1 Out1}
    {RTYP-H: writeRefTyping CM MM B Rslt1 F E2 G T Rslt2}
    exists {Out1'} {Out2} {Out2'}
    {Out1=>Out1': transform Out1 Out1'}
    {Rslt2=>Out2: result2output CM PM B Rslt2 Out2}
    {TYP: letTyping W Out1' ([O] write (lit O) F E2) Out2'}
    {Out2'=>Out2: transform Out2' Out2}
    true.

%theorem reftyping-ok/expr/write/L2
  : forall* {CM} {NN1} {G1} {U1} {M2} {NN} {N1} {A} {FS} {X8} {U2} {M3} {FM} {FC}
    forall {CML: clsmap`lookup CM FC FM}
    {DM: fldmap`domain FM FS}
    {SUB:subtype CM FS (reftype/ NN1 N1 G1) (env/ U1 M2) (ty/ NN A FC) X8 (env/ U2 M3)}
    exists {CML: clsmap`lookup CM N1 FM}
    true.

%worlds (gtermvar) (reftyping-ok/expr/write/L2 _ _ _ _).
%trustme %total { } (reftyping-ok/expr/write/L2 _ _ _ _).


- : reftyping-ok/expr/write CM-CM CM-MM CM2PM MM2W CM-B CM-R1 R1=>Out1
    (writeRefTyping/base (CML:clsmap`lookup CM C FM) FML
      (MG:make-tgts-and-caps M0 G0 F (targets/unique set/0 M _) M1)
      (RTYP-E2:reftyping CM MM B (env/ U0 M1) E2 (result/expr _ (env/ U1 M2)))
      (SUB:subtype _ _ _ (env/ U1 M2) (ty/ NN A FC) _ (env/ U2 M3))
      (CF:consider-ftype _ M3 A G2 M4)) _ _ _
    (transform/trans
      (TRANS-1)
      (transform/inside [x]
        (transform/inside [p:permission]
          (transform/implies
            (implies/trans
              (implies/equiv
                (equiv/transitive
                  (equiv/combine (PiU0'<=>PiU0) equiv/reflexive)
                  (equiv/roll2)))
              (implies/combine (implies/equiv (PiB'<=>PiB)) implies/reflexive))))))
    R3=>Out3
    (letTyping/exists [x] (letTyping/exists [p] (letTyping/base x (TYP x p))))
    (transform/trans transform/rem-unused (transform/rem-unused))
    <- make-tgts-and-caps-consistent/1 CM-CM CML FML CM-R1 MG (clsmap-cxt-env/ _ CM-B-M1)
    <- clsmap-result/expr-inversion CM-R1 _ (clsmap-cxt-env/ CM-B-U0 _)
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U0 CM-B-M1) RTYP-E2
      PiB _ Out2 B=>PiB (env2input/ (U0=>PiU0: make-encumbered CM PM B U0 PiU0)
                          (M1=>Pi2:capset2perm CM PM B M1 Pi2)) R2=>Out2 TYP-E2
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B
      (clsmap-cxt-env/ CM-B-U0 CM-B-M1) RTYP-E2 CM-R2
    <- before-read CM-CM CM2PM CML FML R1=>Out1 MG CM-R1
      PiB' _ Pi2' PiU0' _ T2PF B=>PiB' U0=>PiU0' R-FMT TRANS-1
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-not-borrow CM-FM FML NB
    <- make-before-write-format CM2PM CM-R2 SUB NB R2=>Out2 _ TRANS-2 BW-FMT
    <- do-write M1=>Pi2 R-FMT SUB T2PF
      (tTrans2 TYP-E2 TRANS-2) BW-FMT CF _ TYP R3=>Out3
    <- make-encumbered-equiv U0=>PiU0' U0=>PiU0
      clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/ PiU0'<=>PiU0
    <- cxt2perm-equiv B=>PiB' B=>PiB predmap`eq/ cxt`eq/ PiB'<=>PiB.

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _)))
      ty2reftype/unique) _ _ _
    (B=>PiB)
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM)
      (reftype2perm/borrow (set`size/+ set`size/0) set`size/0
        T2PF ([_] (set2cond/U set2cond/0 set`update/0 set`not-member/0 BL))))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans5
            (implies/combine
              (implies/trans5
                (implies/equiv PiB<=>PiF+PiBP)
                (implies/combine (DUP O) implies/reflexive)
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric PiB<=>PiF+PiBP)))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/equiv equiv/commute)
                  (implies/combine (gen-objequal-self-cond _) implies/reflexive))))
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive
                (implies/equiv equiv/associate))
              (implies/reflexive))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _ (ty2perm2/unique T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-borrow T2PF DUP.

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit
      (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _))) ty2reftype/borrow) _ _ _
    B=>PiB
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM)
      (reftype2perm/borrow (set`size/+ set`size/0) set`size/0
        T2PF ([_] (set2cond/U set2cond/0 set`update/0 set`not-member/0 BL))))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans5
            (implies/combine
              (implies/trans5
                (implies/equiv PiB<=>PiF+PiBP)
                (implies/combine (DUP O) implies/reflexive)
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric PiB<=>PiF+PiBP)))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/equiv equiv/commute)
                  (implies/combine (gen-objequal-self-cond _) implies/reflexive))))
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive
                (implies/equiv equiv/associate))
              (implies/reflexive))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _
      (ty2perm2/borrow T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-borrow T2PF DUP.

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit
      (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _)))
      ty2reftype/shared) _ _ _
    B=>PiB
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM) (reftype2perm/shared T2PF))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans3
            (implies/combine
              (implies/trans5
                (implies/equiv (PiB<=>PiF+PiBP))
                (implies/combine (DUP O) (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric (PiB<=>PiF+PiBP))))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/equiv (equiv/symmetric equiv/identity))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _
      (ty2perm2/shared T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-shared T2PF DUP.

- : reftyping-ok/expr (CM-CM:clsmap-clsmap CM CM) CM-MM
    CM2PM MM2W CM-B CM-V (reftyping/read RTYP-E RTYP-HELPER) PiB Pi Out B=>PiB V=>Pi R2=>Out2
    (tTrans2 (tRead1 (tTrans2 (TYP-E) (TRANS)) LTYP) TRANS2)
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V RTYP-E _ _ _ B=>PiB V=>Pi R=>Out TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-E CM-R
    <- reftyping-ok/read CM-CM CM2PM CM-R R=>Out RTYP-HELPER _ _ _
      TRANS R2=>Out2 LTYP TRANS2.

- : reftyping-ok/expr
    (CM-CM:clsmap-clsmap CM CM) (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W
    (CM-B0:clsmap-cxt CM B0) (CM-V0: clsmap-cxt-env CM B0 V0)
    (reftyping/let
      (RTYP-E0:reftyping CM MM B0 V0 E0 (result/expr (reftype/ NN C targets/shared) V1))
      (letRefTyping/base/shared (CML:clsmap`lookup CM C FM)
        (N!<B0:cxt`fresh B0 (s N))
        ([x] (B0+N=B1:{x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) x)
        ([x] (RTYP-E1: {x} reftyping CM MM (B1 x) V1 (F x)
                       (result/expr (reftype/ NN1 C1 G1) V2)) x)
        N!<G1))
    PiB0 Pi0 Out1 B0=>PiB0 V0=>Pi R1=>Out1
    (tTrans2
      (tLet
        (tTrans2
          (TYP-E0)
          (TRANS))
        (letTyping/exists [x]
          (letTyping/exists [o]
            (letTyping/exists [p]
              (letTyping/base x
                (tTrans
                  (transform/implies
                    (implies/combine
                      (implies/equiv (PiB1<=>PiB1' x))
                      (implies/equiv (Pi<=>Pi' x))))
                  (letTyping/base null (TYP-E1 x))
                  (transform/reflexive)))))))
      (TRANS2))
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B0 CM-V0 RTYP-E0 CM-R0
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0 RTYP-E0
      _ _ _ B0=>PiB0 V0=>Pi R0=>Out0 TYP-E0
    <- letRefTyping-helper/base/shared/before N!<B0 B0+N=B1
      CM-B0 CM-R0 R0=>Out0 PiB1 Pi1 CM-B1 CM-V1 V1=>Pi1 B1=>PiB1 TRANS
    <-({x} reftyping-ok/expr CM-CM CM-MM CM2PM MM2W (CM-B1 x) (CM-V1 x)
        (RTYP-E1 x) _ _ _ (B1=>PiB1' x) (V1=>Pi1' x) (R1=>Out1' x) (TYP-E1 x))
    <- ({x} reftyping-implies-clsmap-result CM-CM CM-MM (CM-B1 x) (CM-V1 x) (RTYP-E1 x) (CM-R1 x))
    <- letRefTyping-helper/base/shared/after _ N!<G1 N!<B0 B0+N=B1
      ([x] CM-R1 x) ([x] R1=>Out1' x) _ R1=>Out1 TRANS2
    <- ({x} cxt2perm-equiv (B1=>PiB1 x) (B1=>PiB1' x) predmap`eq/
         cxt`eq/ (PiB1<=>PiB1' x))
    <- ({x} env2input-unique (V1=>Pi1 x) (V1=>Pi1' x) env`eq/ (Pi<=>Pi' x)).

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0
    (reftyping/let RTYP-E0
      (letRefTyping/base/unique
        CML DM-FM=FS S+FS=M2 N!<B0 B0+N=B1
        SP N!<U1 U1+N=U2 M0-M2=M4 N+FS=M3
        M5-M3=M4 ([x] RTYP-E1 x) N!<G1 M6-M3=M7 M8-M2=M7 M9-M1=M8
        N!<U4 U4+N=U3 U4+S=U5)) PiB0 Pi0 Out3 B0=>PiB0 V0=>Pi R1=>Out1
    (tTrans2
      (tLet
        (tTrans2
          (TYP-E0)
          (TRANS))
        (letTyping/exists [x]
          (letTyping/exists [o]
            (letTyping/exists [p]
              (letTyping/base x
                (tTrans
                  (transform/implies
                    (implies/combine implies/reflexive
                      (implies/combine
                        (implies/equiv (PiB1<=>PiB1' x))
                        (implies/equiv (Pi<=>Pi' x)))))
                  (letTyping/base null (TYP-E1' x o p))
                  (transform/reflexive)))))))
      (TRANS2))
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0 RTYP-E0
      PiB0 Pi0 Out0 B0=>PiB0 V0=>Pi R0=>Out0 TYP-E0
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B0 CM-V0 RTYP-E0 CM-R0
    <- set`split-implies-leq-remove SP S<=U0 U0-S=U1
    <- letRefTyping-helper/base/unique CM-CM CM2PM CM-B0 CML DM-FM=FS
      S+FS=M2 N!<B0 B0+N=B1 S<=U0 U0-S=U1 U1+N=U2 M0-M2=M4 N+FS=M3
      M5-M3=M4 CM-R0 R0=>Out0 ([x] Pi1 x) ([x] Pi2 x) ([x] PiB1 x)
      CM-B1 CM-V1 V1=>Pi B1=>PiB1 EC-FMT TRANS
    <-({x} reftyping-ok/expr CM-CM CM-MM CM2PM MM2W (CM-B1 x) (CM-V1 x)
        (RTYP-E1 x) (PiB1' x) (Pi1' x) (Out1' x)
        (B1=>PiB1' x) (V1=>Pi' x) (R1=>Out1' x) (TYP-E1 x))
    <- ({x} cxt2perm-equiv (B1=>PiB1 x) (B1=>PiB1' x) predmap`eq/
         cxt`eq/ (PiB1<=>PiB1' x))
    <- letRefTyping-helper/base/unique/L6 G1 N!<G1 N!<B0 B0+N=B1
      CML DM-FM=FS N+FS=M3 EC-FMT R1=>Out1' M6-M3=M7 M8-M2=M7 M9-M1=M8
      N!<U4 U4+N=U3 U4+S=U5 ([x] Out1 x) Out3 EA R1=>Out1 TRANS2
    <- ({x}{o}{p} typing-frame* (TYP-E1 x) (EA x o p) (TYP-E1' x o p))
    <- ({x} env2input-unique (V1=>Pi x) (V1=>Pi' x) env`eq/ (Pi<=>Pi' x)).


%%% IDEA:
%%% After checking E1, we get a permission output like the following:
%%%  (PiB , (PiF , PiF --|- Pi2 , Pi3))
%%% We then can combine PiB and Pi3 to check E2
%%% Then, subtype ensures that we have enough permission to be consumed,
%%% we can then check the "write".

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/write RTYP-E1 RTYP-E2) PiB Pi _ B=>PiB V=>Pi R3=>Out3
    (tTrans2 (tWrite1 (tTrans2 (TYP-E1) (TRANS1)) (LTYP)) (TRANS2))
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W
      CM-B CM-V RTYP-E1 PiB Pi Out1 B=>PiB V=>Pi R1=>Out1 TYP-E1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-E1 CM-R1
    <- reftyping-ok/expr/write CM-CM CM-MM CM2PM MM2W
      CM-B CM-R1 R1=>Out1 RTYP-E2 _ _ _ TRANS1 R3=>Out3 LTYP TRANS2.

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/call FS MML ARTYP CRTYP) _ _ _ B=>PiB V=>PiV R=>O
    (tTrans2
      (tCall WL
        (tTrans
          (transform/implies
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/identity)
                (equiv/commute))))
          (letTyping/base null ATYP)
          (TRANS1))
        CTYP)
      (TRANS2))
    <- clsmap-methmap-implies-methty2proctype CM-CM CM2PM CM-MM MM2W FS MML _ WL MT=>PT
    <- reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-V ARTYP
      _ _ _ B=>PiB V=>PiV ATYP AR=>AO
    <- reftyping-ok/call CM-CM CM-MM CM-B CM2PM MM2W CM-V ARTYP AR=>AO MT=>PT
      CRTYP _ _ _ TRANS1 CTYP TRANS2 R=>O.

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/const CML DM MML ARTYP CRTYP) _ _ _ B=>PiB V=>PiV R=>O
    (tTrans2
      (tCall WL
        (tTrans2
          (tArgs1
            (tTrans2
              (tAlloc ([t] AF t))
              (transform/inside [t]
                (transform/implies
                  (implies/equiv
                    (equiv/transitive
                      (equiv/commute)
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/symmetric equiv/identity)
                          (equiv/commute))))))))
            (letTyping/exists [t] (letTyping/base t (tArgs (ATYP2 t)))))
          (transform/inside [t] (transform/args/+ (TRANS1 t))))
        (callTyping/exists [t] (callTyping/arg t (CTYP t))))
      (transform/trans
        (transform/inside [t] (TRANS2 t))
        (transform/rem-unused)))
    <- clsmap-methmap-implies-consty2proctype CM-CM CM2PM CM-MM MM2W CML MML _ WL CT=>PT
    <- reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-V ARTYP
      _ _ _ B=>PiB V=>PiV ATYP AR=>AO
    <- allocFields-total _ AF
    <- reftyping-ok/const CM-CM CM-MM CM-B CM2PM MM2W CM-V
      ARTYP AR=>AO CT=>PT CRTYP DM AF _ _ _ _ EA TRANS1 CTYP TRANS2 R=>O
    <- ({t} typing-frame* ATYP (EA t) (ATYP2 t)).

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/eq RTYP1 RTYP2 RCT1 RCT2) _ _ _ B=>PiB V0=>PiV0 R=>O TYP
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP1
      PiB _ _ B=>PiB V0=>PiV0 R1=>O1 TYP1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP1
      (clsmap-result/expr CM-B-RT1 CM-V1)
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP2
      PiB' _ _ B=>PiB' V1=>PiV1 R2=>O2 TYP2
    <- cxt2perm-equiv B=>PiB B=>PiB' predmap`eq/ cxt`eq/ PiB<=>PiB'
    <- reftyping-ok/eq CM-CM CM2PM B=>PiB V0=>PiV0 TYP1 R1=>O1
      (tTrans
        (transform/implies
          (implies/combine (implies/equiv (PiB<=>PiB')) implies/reflexive))
        (letTyping/base null (TYP2))
        (transform/reflexive))
      V1=>PiV1
      R2=>O2 RCT1 RCT2 _ TYP R=>O.

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/not RTYP) _ _ _ B=>PiB V0=>PiV0 R=>O' (tNot TYP NV)
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP
      _ _ _ B=>PiB V0=>PiV0 R=>O TYP
    <- reftyping-ok/not/L R=>O _ NV R=>O'.

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/and RTYP-C1 RTYP-C2) _ _ _ B=>PiB V0=>PiV0 R=>O
    (tTrans2
      (tAnd TYP-C1 AND-HELP-C2)
      (TRANS))
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP-C1
      PiB _ _ B=>PiB V0=>PiV0 R1=>O1 TYP-C1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP-C1 (clsmap-result/cond CM-V1)
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-C2
      PiB' _ _ B=>PiB' V1=>PiV1 R2=>O2 TYP-C2
    <- reftyping-ok/and B=>PiB' V1=>PiV1 R1=>O1 R2=>O2 TYP-C2 _ _ AND-HELP-C2 TRANS R=>O.

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/sub RTYP SUB (clsmap-result/expr CM-RT1 CM-V2)) PiB _ _ B=>PiB V0=>PiV0
    (result2output/expr (B=>PiB':cxt2perm PM B PiB') V2=>PiV2 RT1=>PF1)
    (tTrans2 TYP0
      (transform/trans3
        (transform/inside [_]
          (transform/inside [_]
            (transform/inside [_]
              (transform/implies (implies/equiv equiv/identity)))))
      (TRANS)
        (transform/inside [_]
          (transform/inside [_]
            (transform/inside [_]
              (transform/implies (implies/equiv (equiv/symmetric equiv/identity))))))))
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0
      RTYP (clsmap-result/expr CM-RT0 CM-V1)
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP _ _ _ B=>PiB V0=>PiV0
      (result2output/expr B=>PiB' V1=>PiV1 RT0=>PF0) TYP0
    <- reftype-sub-transform _ CM-CM CM2PM B=>PiB' CM-RT0 CM-RT1 SUB RT0=>PF0 V1=>PiV1
      _ _ RT1=>PF1 V2=>PiV2 TRANS.

- : reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/if RTYP-C RTYP-E1 RTYP-E2) _ _ _ B=>PiB V0=>PiV0 R1=>O1
    (tTrans2
      (tIf
        (TYP-C)
        (IF-TYP))
      (TRANS))
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP-C
      PiB _ _ B=>PiB V0=>PiV0 R0=>O0 TYP-C
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP-C (clsmap-result/cond CM-V1)
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-E1
      PiB1 PiV1 _ B=>PiB1 V1=>PiV1 R1=>O1 TYP-E1
    <- reftyping-ok/expr CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-E2
      PiB2 PiV1' _ B=>PiB2 V1=>PiV1' R2=>O2 TYP-E2
    <- result2output/expr-trans R1=>O1 R2=>O2 result`eq/ TRANS0 TRANS1
    <- cxt2perm-equiv B=>PiB1 B=>PiB2 predmap`eq/ cxt`eq/ PiB1<=>PiB2
    <- env2input-unique V1=>PiV1 V1=>PiV1' env`eq/ PiV1<=>PiV1'
    <- reftyping-ok/if B=>PiB1 V1=>PiV1 R0=>O0 TYP-E1
      (tTrans
        (transform/implies
          (implies/equiv
            (equiv/combine PiB1<=>PiB2 PiV1<=>PiV1')))
        (letTyping/base null TYP-E2)
        (TRANS1))
      _ IF-TYP TRANS.

%worlds (gtermvar) (reftyping-ok/expr _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(reftyping-ok/expr/write _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(reftyping-ok/args _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

%total (T WT AT) (reftyping-ok/expr _ _ _ _ _ _ T _ _ _ _ _ _ _)
(reftyping-ok/expr/write _ _ _ _ _ _ _ WT _ _ _ _ _ _ _)
(reftyping-ok/args _ _ _ _ _ _ _ AT _ _ _ _ _ _ _).