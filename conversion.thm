%%% Theorems about conversion

%theorem reftyping-ok
  : forall* {CM} {PM} {MM} {W} {K} {E: term K} {R: result K} {V} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-V: clsmap-cxt-env CM B V}
    {RTYP: reftyping CM MM B V E R}
    exists {PiB} {Pi} {Out}
    {B=>PiB: cxt2perm PM B PiB}
    {XX2I: env2input CM PM B V Pi}
    {XX2O: result2output CM PM B R Out}
    {TYP: typing W (PiB , Pi) E Out}
    true.

%theorem reftyping-ok/args
  : forall* {CM} {PM} {MM} {B} {V} {A} {MT} {AR} {W}
    forall {Pi0} {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-V: clsmap-cxt-env CM B V}
    {RTYP: argsRefTyping CM MM B V A MT AR}
    exists {PiB} {Pi} {Out}
    {B=>PiB: cxt2perm PM B PiB}
    {V=>Pi: env2input CM PM B V Pi}
    {TYP: typing W (Pi0 , (PiB , Pi)) A Out}
    {R=>Out: result2output* CM PM B Pi0 AR Out}
    true.

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ _))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1) (sub-annot/fresh _))
      (ATYP:argsRefTyping CM MM B _ A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/combine
                            (equiv/transitive
                              (equiv/combine (PiB0<=>PiB1 o r p)
                                (equiv/combine equiv/reflexive (PiV1<=>PiV11 o r p)))
                              (equiv/reorder))
                            (equiv/symmetric equiv/identity))
                          (equiv/swap)))
                      (equiv/commute)
                      (equiv/swap))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 capset2perm/0) RT=>PiT  AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0) V1=>PiV1
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-B-U1 CM-B-M1))
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , empty)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U1 CM-B-M1) ATYP _
         _ _ (B=>PiB1 x o p) (V1=>PiV11 x o p) (TYP-A x o p) (AR=>AOut x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- ({x}{o}{p} env2input-unique V1=>PiV1 (V1=>PiV11 x o p) env`eq/ (PiV1<=>PiV11 x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ (env/ U1 M1)))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/borrow (S+FS=>MF:set+set2set S FS MF)
          (M1-MF=M2:set`split M1 MF M2)))
      (ATYP:argsRefTyping CM MM B (env/ U1 M2) A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine
                        (implies/combine (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/equiv (PiU1<=>PiU1P o r p))
                              (implies/equiv
                                (equiv/transitive
                                  (PiM1<=>PiMF+PiM2)
                                  (equiv/combine equiv/reflexive (PiM2<=>PiM2P o r p)))))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive5
                        (equiv/combine equiv/reflexive
                          (equiv/transitive
                            (equiv/identity)
                            (equiv/reorder)))
                        (equiv/associate)
                        (equiv/combine equiv/reflexive
                          (equiv/roll3))
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive3
                            (equiv/combine equiv/reflexive
                              (equiv/transitive (equiv/symmetric equiv/identity) equiv/commute))
                            (equiv/symmetric equiv/associate)
                            (equiv/commute))
                          (equiv/reflexive))))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 MF=>PiMF) RT=>PiT AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0)
        (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-U1 CM-M1))
    <- set`split-implies-leq M1-MF=M2 MF<=M1 M2<=M1
    <- clsmap-cxt-capset-respects-geq CM-M1 M2<=M1 CM-M2
    <- set`split-implies-permission-combine M1-MF=M2 M1=>PiM1
      PiMF PiM2 MF=>PiMF M2=>PiM2 PiM1<=>PiMF+PiM2
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , PiMF)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U1 CM-M2) ATYP _
         _ _ (B=>PiB1 x o p) (env2input/ (U1=>PiU1P x o p) (M2=>PiM2P x o p))
         (TYP-A x o p) (AR=>AOut x o p))
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} capset2perm-equiv M2=>PiM2 (M2=>PiM2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiM2<=>PiM2P x o p))
    <- ({x}{o}{p} make-encumbered-equiv U1=>PiU1 (U1=>PiU1P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiU1<=>PiU1P x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ (env/ U1 M1)))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/unique CML DM-FM=FS (S+FS=>MF:set+set2set S FS MF)
          (M1-MF=M2:set`split M1 MF M2) (S<=U1:set`leq S U1)
          (U1-S=U2: set`remove U1 S U2) _))
      (ATYP:argsRefTyping CM MM B (env/ U2 M2) A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine
                        (implies/combine (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/equiv
                                (equiv/transitive
                                  PiU1<=>PiS+PiU2
                                  (equiv/combine equiv/reflexive (PiU2<=>PiU2P o r p))))
                              (implies/equiv
                                (equiv/transitive
                                  (PiM1<=>PiMF+PiM2)
                                  (equiv/combine equiv/reflexive (PiM2<=>PiM2P o r p)))))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive4
                        (equiv/combine equiv/reflexive
                          (equiv/transitive
                            (equiv/combine
                              (equiv/transitive
                                (equiv/combine (equiv/reflexive) % PiB1
                                  (equiv/transitive
                                    (equiv/combine (equiv/reflexive) % Pif
                                      (equiv/swap-middle))
                                    (equiv/associate)))
                                (equiv/reorder))
                              (equiv/reflexive))
                            (equiv/commute)))
                        (equiv/associate)
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive
                            (equiv/combine (equiv/identity) equiv/reflexive)
                            (equiv/commute))
                          (equiv/reflexive))))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ S=>PiS MF=>PiMF) RT=>PiT AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0)
        (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-U1 CM-M1))
    <- set`remove-implies-leq U1-S=U2 U2<=U1
    <- clsmap-cxt-objset-respects-geq CM-U1 U2<=U1 CM-U2
    <- set`split-implies-leq M1-MF=M2 MF<=M1 M2<=M1
    <- clsmap-cxt-capset-respects-geq CM-M1 M2<=M1 CM-M2
    <- make-encumbered-intro S<=U1 U1-S=U2 U1=>PiU1 PiS PiU2 S=>PiS U2=>PiU2 PiU1<=>PiS+PiU2
    <- set`split-implies-permission-combine M1-MF=M2 M1=>PiM1
      PiMF PiM2 MF=>PiMF M2=>PiM2 PiM1<=>PiMF+PiM2
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (PiS , PiMF)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U2 CM-M2) ATYP _
         _ _ (B=>PiB1 x o p) (env2input/ (U2=>PiU2P x o p) (M2=>PiM2P x o p))
         (TYP-A x o p) (AR=>AOut x o p))
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} capset2perm-equiv M2=>PiM2 (M2=>PiM2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
      set`eq/ (PiM2<=>PiM2P x o p))
    <- ({x}{o}{p} make-encumbered-equiv U2=>PiU2 (U2=>PiU2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiU2<=>PiU2P x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ _))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/shared))
      (ATYP:argsRefTyping CM MM B _ A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans3
                    (implies/combine implies/reflexive
                      (implies/combine
                        (implies/combine
                          (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/equiv (PiV1<=>PiV11 o r p))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/combine equiv/reflexive
                          (equiv/transitive3
                            (equiv/combine (equiv/roll2) equiv/reflexive)
                            (equiv/commute)
                            (equiv/associate)))
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive
                            (equiv/commute)
                            (equiv/combine equiv/commute equiv/reflexive))
                          (equiv/reflexive))))
                    (implies/combine
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/equiv (equiv/symmetric equiv/identity)))
                        (implies/reflexive))
                      (implies/reflexive))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 capset2perm/0) RT=>PiT  AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0) V1=>PiV1
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-B-U1 CM-B-M1))
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , empty)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U1 CM-B-M1) ATYP _
         _ _ (B=>PiB1 x o p) (V1=>PiV11 x o p) (TYP-A x o p) (AR=>AOut x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- ({x}{o}{p} env2input-unique V1=>PiV1 (V1=>PiV11 x o p) env`eq/ (PiV1<=>PiV11 x o p)).

- : reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-B-V
    (argsRefTyping/0) _ _ _ B=>PiB V=>Pi
    (tTrans2 tArgs0
      (transform/args/0
        (implies/reflexive)))
    (result2output/args/0 B=>PiB V=>Pi)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>PiB
    <- clsmap-cxt-env-implies-env2input CM-CM CM2PM CM-B-V _ V=>Pi.


%theorem reftyping-ok/expr/write
  : forall* {CM} {MM} {PM} {W} {F} {E2} {G} {T} {Out1} {Rslt1} {Rslt2} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-Rslt: clsmap-result CM B Rslt1}
    {Rslt1=>Out1: result2output CM PM B Rslt1 Out1}
    {RTYP-H: writeRefTyping CM MM B Rslt1 F E2 G T Rslt2}
    exists {Out1'} {Out2} {Out2'}
    {Out1=>Out1': transform Out1 Out1'}
    {Rslt2=>Out2: result2output CM PM B Rslt2 Out2}
    {TYP: letTyping W Out1' ([O] write (lit O) F E2) Out2'}
    {Out2'=>Out2: transform Out2' Out2}
    true.

%theorem reftyping-ok/expr/write/L2
  : forall* {CM} {NN1} {G1} {U1} {M2} {NN} {N1} {A} {FS} {X8} {U2} {M3} {FM} {FC}
    forall {CML: clsmap`lookup CM FC FM}
    {DM: fldmap`domain FM FS}
    {SUB:subtype CM FS (reftype/ NN1 N1 G1) (env/ U1 M2) (ty/ NN A FC) X8 (env/ U2 M3)}
    exists {CML: clsmap`lookup CM N1 FM}
    true.

%worlds (gtermvar) (reftyping-ok/expr/write/L2 _ _ _ _).
%trustme %total { } (reftyping-ok/expr/write/L2 _ _ _ _).


- : reftyping-ok/expr/write CM-CM CM-MM CM2PM MM2W CM-B CM-R1 R1=>Out1
    (writeRefTyping/base (CML:clsmap`lookup CM C FM) FML
      (MG:make-tgts-and-caps M0 G0 F (targets/unique set/0 M _) M1)
      (RTYP-E2:reftyping CM MM B (env/ U0 M1) E2 (result/expr _ (env/ U1 M2)))
      (SUB:subtype _ _ _ (env/ U1 M2) (ty/ NN A FC) _ (env/ U2 M3))
      (CF:consider-ftype _ M3 A G2 M4)) _ _ _
    (transform/trans
      (TRANS-1)
      (transform/inside [x]
        (transform/inside [p:permission]
          (transform/implies
            (implies/trans
              (implies/equiv
                (equiv/transitive
                  (equiv/combine (PiU0'<=>PiU0) equiv/reflexive)
                  (equiv/roll2)))
              (implies/combine (implies/equiv (PiB'<=>PiB)) implies/reflexive))))))
    R3=>Out3
    (letTyping/exists [x] (letTyping/exists [p] (letTyping/base x (TYP x p))))
    (transform/trans transform/rem-unused (transform/rem-unused))
    <- make-tgts-and-caps-consistent/1 CM-CM CML FML CM-R1 MG (clsmap-cxt-env/ _ CM-B-M1)
    <- clsmap-result/expr-inversion CM-R1 _ (clsmap-cxt-env/ CM-B-U0 _)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U0 CM-B-M1) RTYP-E2
      PiB _ Out2 B=>PiB (env2input/ (U0=>PiU0: make-encumbered CM PM B U0 PiU0)
                          (M1=>Pi2:capset2perm CM PM B M1 Pi2)) R2=>Out2 TYP-E2
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B
      (clsmap-cxt-env/ CM-B-U0 CM-B-M1) RTYP-E2 CM-R2
    <- before-read CM-CM CM2PM CML FML R1=>Out1 MG CM-R1
      PiB' _ Pi2' PiU0' _ T2PF B=>PiB' U0=>PiU0' R-FMT TRANS-1
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-not-borrow CM-FM FML NB
    <- make-before-write-format CM2PM CM-R2 SUB NB R2=>Out2 _ TRANS-2 BW-FMT
    <- do-write M1=>Pi2 R-FMT SUB T2PF
      (tTrans2 TYP-E2 TRANS-2) BW-FMT CF _ TYP R3=>Out3
    <- make-encumbered-equiv U0=>PiU0' U0=>PiU0
      clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/ PiU0'<=>PiU0
    <- cxt2perm-equiv B=>PiB' B=>PiB predmap`eq/ cxt`eq/ PiB'<=>PiB.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _)))
      ty2reftype/unique) _ _ _
    (B=>PiB)
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM)
      (reftype2perm/borrow (set`size/+ set`size/0) set`size/0
        T2PF ([_] (set2cond/U set2cond/0 set`update/0 set`not-member/0 BL))))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans5
            (implies/combine
              (implies/trans5
                (implies/equiv PiB<=>PiF+PiBP)
                (implies/combine (DUP O) implies/reflexive)
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric PiB<=>PiF+PiBP)))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/equiv equiv/commute)
                  (implies/combine (gen-objequal-self-cond _) implies/reflexive))))
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive
                (implies/equiv equiv/associate))
              (implies/reflexive))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _ (ty2perm2/unique T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-borrow T2PF DUP.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit
      (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _))) ty2reftype/borrow) _ _ _
    B=>PiB
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM)
      (reftype2perm/borrow (set`size/+ set`size/0) set`size/0
        T2PF ([_] (set2cond/U set2cond/0 set`update/0 set`not-member/0 BL))))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans5
            (implies/combine
              (implies/trans5
                (implies/equiv PiB<=>PiF+PiBP)
                (implies/combine (DUP O) implies/reflexive)
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric PiB<=>PiF+PiBP)))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/equiv equiv/commute)
                  (implies/combine (gen-objequal-self-cond _) implies/reflexive))))
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive
                (implies/equiv equiv/associate))
              (implies/reflexive))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _
      (ty2perm2/borrow T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-borrow T2PF DUP.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit
      (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _)))
      ty2reftype/shared) _ _ _
    B=>PiB
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM) (reftype2perm/shared T2PF))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans3
            (implies/combine
              (implies/trans5
                (implies/equiv (PiB<=>PiF+PiBP))
                (implies/combine (DUP O) (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric (PiB<=>PiF+PiBP))))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/equiv (equiv/symmetric equiv/identity))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _
      (ty2perm2/shared T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-shared T2PF DUP.

- : reftyping-ok (CM-CM:clsmap-clsmap CM CM) CM-MM
    CM2PM MM2W CM-B CM-V (reftyping/read RTYP-E RTYP-HELPER) PiB Pi Out B=>PiB V=>Pi R2=>Out2
    (tTrans2 (tRead1 (tTrans2 (TYP-E) (TRANS)) LTYP) TRANS2)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V RTYP-E _ _ _ B=>PiB V=>Pi R=>Out TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-E CM-R
    <- reftyping-ok/read CM-CM CM2PM CM-R R=>Out RTYP-HELPER _ _ _
      TRANS R2=>Out2 LTYP TRANS2.

- : reftyping-ok
    (CM-CM:clsmap-clsmap CM CM) (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W
    (CM-B0:clsmap-cxt CM B0) (CM-V0: clsmap-cxt-env CM B0 V0)
    (reftyping/let
      (RTYP-E0:reftyping CM MM B0 V0 E0 (result/expr (reftype/ NN C targets/shared) V1))
      (letRefTyping/base/shared (CML:clsmap`lookup CM C FM)
        (N!<B0:cxt`fresh B0 (s N))
        ([x] (B0+N=B1:{x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) x)
        ([x] (RTYP-E1: {x} reftyping CM MM (B1 x) V1 (F x)
                       (result/expr (reftype/ NN1 C1 G1) V2)) x)
        N!<G1))
    PiB0 Pi0 Out1 B0=>PiB0 V0=>Pi R1=>Out1
    (tTrans2
      (tLet
        (tTrans2
          (TYP-E0)
          (TRANS))
        (letTyping/exists [x]
          (letTyping/exists [o]
            (letTyping/exists [p]
              (letTyping/base x
                (tTrans
                  (transform/implies
                    (implies/combine
                      (implies/equiv (PiB1<=>PiB1' x))
                      (implies/equiv (Pi<=>Pi' x))))
                  (letTyping/base null (TYP-E1 x))
                  (transform/reflexive)))))))
      (TRANS2))
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B0 CM-V0 RTYP-E0 CM-R0
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0 RTYP-E0
      _ _ _ B0=>PiB0 V0=>Pi R0=>Out0 TYP-E0
    <- letRefTyping-helper/base/shared/before N!<B0 B0+N=B1
      CM-B0 CM-R0 R0=>Out0 PiB1 Pi1 CM-B1 CM-V1 V1=>Pi1 B1=>PiB1 TRANS
    <-({x} reftyping-ok CM-CM CM-MM CM2PM MM2W (CM-B1 x) (CM-V1 x)
        (RTYP-E1 x) _ _ _ (B1=>PiB1' x) (V1=>Pi1' x) (R1=>Out1' x) (TYP-E1 x))
    <- ({x} reftyping-implies-clsmap-result CM-CM CM-MM (CM-B1 x) (CM-V1 x) (RTYP-E1 x) (CM-R1 x))
    <- letRefTyping-helper/base/shared/after _ N!<G1 N!<B0 B0+N=B1
      ([x] CM-R1 x) ([x] R1=>Out1' x) _ R1=>Out1 TRANS2
    <- ({x} cxt2perm-equiv (B1=>PiB1 x) (B1=>PiB1' x) predmap`eq/
         cxt`eq/ (PiB1<=>PiB1' x))
    <- ({x} env2input-unique (V1=>Pi1 x) (V1=>Pi1' x) env`eq/ (Pi<=>Pi' x)).

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0
    (reftyping/let RTYP-E0
      (letRefTyping/base/unique
        CML DM-FM=FS S+FS=M2 N!<B0 B0+N=B1
        SP N!<U1 U1+N=U2 M0-M2=M4 N+FS=M3
        M5-M3=M4 ([x] RTYP-E1 x) N!<G1 M6-M3=M7 M8-M2=M7 M9-M1=M8
        N!<U4 U4+N=U3 U4+S=U5)) PiB0 Pi0 Out3 B0=>PiB0 V0=>Pi R1=>Out1
    (tTrans2
      (tLet
        (tTrans2
          (TYP-E0)
          (TRANS))
        (letTyping/exists [x]
          (letTyping/exists [o]
            (letTyping/exists [p]
              (letTyping/base x
                (tTrans
                  (transform/implies
                    (implies/combine implies/reflexive
                      (implies/combine
                        (implies/equiv (PiB1<=>PiB1' x))
                        (implies/equiv (Pi<=>Pi' x)))))
                  (letTyping/base null (TYP-E1' x o p))
                  (transform/reflexive)))))))
      (TRANS2))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0 RTYP-E0
      PiB0 Pi0 Out0 B0=>PiB0 V0=>Pi R0=>Out0 TYP-E0
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B0 CM-V0 RTYP-E0 CM-R0
    <- set`split-implies-leq-remove SP S<=U0 U0-S=U1
    <- letRefTyping-helper/base/unique CM-CM CM2PM CM-B0 CML DM-FM=FS
      S+FS=M2 N!<B0 B0+N=B1 S<=U0 U0-S=U1 U1+N=U2 M0-M2=M4 N+FS=M3
      M5-M3=M4 CM-R0 R0=>Out0 ([x] Pi1 x) ([x] Pi2 x) ([x] PiB1 x)
      CM-B1 CM-V1 V1=>Pi B1=>PiB1 EC-FMT TRANS
    <-({x} reftyping-ok CM-CM CM-MM CM2PM MM2W (CM-B1 x) (CM-V1 x)
        (RTYP-E1 x) (PiB1' x) (Pi1' x) (Out1' x)
        (B1=>PiB1' x) (V1=>Pi' x) (R1=>Out1' x) (TYP-E1 x))
    <- ({x} cxt2perm-equiv (B1=>PiB1 x) (B1=>PiB1' x) predmap`eq/
         cxt`eq/ (PiB1<=>PiB1' x))
    <- letRefTyping-helper/base/unique/L6 G1 N!<G1 N!<B0 B0+N=B1
      CML DM-FM=FS N+FS=M3 EC-FMT R1=>Out1' M6-M3=M7 M8-M2=M7 M9-M1=M8
      N!<U4 U4+N=U3 U4+S=U5 ([x] Out1 x) Out3 EA R1=>Out1 TRANS2
    <- ({x}{o}{p} typing-frame* (TYP-E1 x) (EA x o p) (TYP-E1' x o p))
    <- ({x} env2input-unique (V1=>Pi x) (V1=>Pi' x) env`eq/ (Pi<=>Pi' x)).


%%% IDEA:
%%% After checking E1, we get a permission output like the following:
%%%  (PiB , (PiF , PiF --|- Pi2 , Pi3))
%%% We then can combine PiB and Pi3 to check E2
%%% Then, subtype ensures that we have enough permission to be consumed,
%%% we can then check the "write".

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/write RTYP-E1 RTYP-E2) PiB Pi _ B=>PiB V=>Pi R3=>Out3
    (tTrans2 (tWrite1 (tTrans2 (TYP-E1) (TRANS1)) (LTYP)) (TRANS2))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W
      CM-B CM-V RTYP-E1 PiB Pi Out1 B=>PiB V=>Pi R1=>Out1 TYP-E1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-E1 CM-R1
    <- reftyping-ok/expr/write CM-CM CM-MM CM2PM MM2W
      CM-B CM-R1 R1=>Out1 RTYP-E2 _ _ _ TRANS1 R3=>Out3 LTYP TRANS2.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/call FS MML ARTYP CRTYP) _ _ _ B=>PiB V=>PiV R=>O
    (tTrans2
      (tCall WL
        (tTrans
          (transform/implies
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/identity)
                (equiv/commute))))
          (letTyping/base null ATYP)
          (TRANS1))
        CTYP)
      (TRANS2))
    <- methmap`lookup-implies-fresh-update MML _ MM-FS MM-UD
    <- methmap2progtype/U/m-inversion MM2W FS MM-FS MM-UD _ _ _ MT=>PT W-UD
    <- progtype`update-implies-lookup W-UD WL
    <- reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-V ARTYP
      _ _ _ B=>PiB V=>PiV ATYP AR=>AO
    <- reftyping-ok/call CM-CM CM-MM CM-B CM2PM MM2W CM-V ARTYP AR=>AO MT=>PT
      CRTYP _ _ _ TRANS1 CTYP TRANS2 R=>O.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/const CML DM MML ARTYP CRTYP) _ _ _ B=>PiB V=>PiV R=>O
    (tTrans2
      (tCall WL
        (tTrans2
          (tArgs1
            (tTrans2
              (tAlloc ([t] AF t))
              (transform/inside [t]
                (transform/implies
                  (implies/equiv
                    (equiv/transitive
                      (equiv/commute)
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/symmetric equiv/identity)
                          (equiv/commute))))))))
            (letTyping/exists [t] (letTyping/base t (tArgs (ATYP2 t)))))
          (transform/inside [t] (transform/args/+ (TRANS1 t))))
        (callTyping/exists [t] (callTyping/arg t (CTYP t))))
      (transform/trans
        (transform/inside [t] (TRANS2 t))
        (transform/rem-unused)))
    <- methmap`lookup-implies-fresh-update MML _ MM-FS MM-UD
    <- methmap2progtype/U/c-inversion MM2W CML MM-FS MM-UD _ _ _ CT=>PT W-UD
    <- progtype`update-implies-lookup W-UD WL
    <- reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-V ARTYP
      _ _ _ B=>PiB V=>PiV ATYP AR=>AO
    <- allocFields-total _ AF
    <- reftyping-ok/const CM-CM CM-MM CM-B CM2PM MM2W CM-V
      ARTYP AR=>AO CT=>PT CRTYP DM AF _ _ _ _ EA TRANS1 CTYP TRANS2 R=>O
    <- ({t} typing-frame* ATYP (EA t) (ATYP2 t)).

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/eq RTYP1 RTYP2 RCT1 RCT2) _ _ _ B=>PiB V0=>PiV0 R=>O TYP
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP1
      PiB _ _ B=>PiB V0=>PiV0 R1=>O1 TYP1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP1
      (clsmap-result/expr CM-B-RT1 CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP2
      PiB' _ _ B=>PiB' V1=>PiV1 R2=>O2 TYP2
    <- cxt2perm-equiv B=>PiB B=>PiB' predmap`eq/ cxt`eq/ PiB<=>PiB'
    <- reftyping-ok/eq CM-CM CM2PM B=>PiB V0=>PiV0 TYP1 R1=>O1
      (tTrans
        (transform/implies
          (implies/combine (implies/equiv (PiB<=>PiB')) implies/reflexive))
        (letTyping/base null (TYP2))
        (transform/reflexive))
      V1=>PiV1
      R2=>O2 RCT1 RCT2 _ TYP R=>O.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/not RTYP) _ _ _ B=>PiB V0=>PiV0 R=>O' (tNot TYP NV)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP
      _ _ _ B=>PiB V0=>PiV0 R=>O TYP
    <- reftyping-ok/not/L R=>O _ NV R=>O'.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/and RTYP-C1 RTYP-C2) _ _ _ B=>PiB V0=>PiV0 R=>O
    (tTrans2
      (tAnd TYP-C1 AND-HELP-C2)
      (TRANS))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP-C1
      PiB _ _ B=>PiB V0=>PiV0 R1=>O1 TYP-C1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP-C1 (clsmap-result/cond CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-C2
      PiB' _ _ B=>PiB' V1=>PiV1 R2=>O2 TYP-C2
    <- reftyping-ok/and B=>PiB' V1=>PiV1 R1=>O1 R2=>O2 TYP-C2 _ _ AND-HELP-C2 TRANS R=>O.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/sub RTYP SUB (clsmap-result/expr CM-RT1 CM-V2)) PiB _ _ B=>PiB V0=>PiV0
    (result2output/expr (B=>PiB':cxt2perm PM B PiB') V2=>PiV2 RT1=>PF1)
    (tTrans2 TYP0
      (transform/trans3
        (transform/inside [_]
          (transform/inside [_]
            (transform/inside [_]
              (transform/implies (implies/equiv equiv/identity)))))
      (TRANS)
        (transform/inside [_]
          (transform/inside [_]
            (transform/inside [_]
              (transform/implies (implies/equiv (equiv/symmetric equiv/identity))))))))
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0
      RTYP (clsmap-result/expr CM-RT0 CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP _ _ _ B=>PiB V0=>PiV0
      (result2output/expr B=>PiB' V1=>PiV1 RT0=>PF0) TYP0
    <- reftype-sub-transform _ CM-CM CM2PM B=>PiB' CM-RT0 CM-RT1 SUB RT0=>PF0 V1=>PiV1
      _ _ RT1=>PF1 V2=>PiV2 TRANS.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/if RTYP-C RTYP-E1 RTYP-E2) _ _ _ B=>PiB V0=>PiV0 R1=>O1
    (tTrans2
      (tIf
        (TYP-C)
        (IF-TYP))
      (TRANS))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP-C
      PiB _ _ B=>PiB V0=>PiV0 R0=>O0 TYP-C
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP-C (clsmap-result/cond CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-E1
      PiB1 PiV1 _ B=>PiB1 V1=>PiV1 R1=>O1 TYP-E1
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-E2
      PiB2 PiV1' _ B=>PiB2 V1=>PiV1' R2=>O2 TYP-E2
    <- result2output/expr-trans R1=>O1 R2=>O2 result`eq/ TRANS0 TRANS1
    <- cxt2perm-equiv B=>PiB1 B=>PiB2 predmap`eq/ cxt`eq/ PiB1<=>PiB2
    <- env2input-unique V1=>PiV1 V1=>PiV1' env`eq/ PiV1<=>PiV1'
    <- reftyping-ok/if B=>PiB1 V1=>PiV1 R0=>O0 TYP-E1
      (tTrans
        (transform/implies
          (implies/equiv
            (equiv/combine PiB1<=>PiB2 PiV1<=>PiV1')))
        (letTyping/base null TYP-E2)
        (TRANS1))
      _ IF-TYP TRANS.

%worlds (gtermvar) (reftyping-ok _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(reftyping-ok/expr/write _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(reftyping-ok/args _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

%total (T WT AT) (reftyping-ok _ _ _ _ _ _ T _ _ _ _ _ _ _)
(reftyping-ok/expr/write _ _ _ _ _ _ _ WT _ _ _ _ _ _ _)
(reftyping-ok/args _ _ _ _ _ _ _ AT _ _ _ _ _ _ _).



%%% Method Typing


% Checking method type against func

methtymatch* : env -> env -> clsmap -> methmap -> cxt -> func -> methty -> type.

%%% if we have sub rule, then RT should match T,
%%% hence subtype will not be needed.

methtymatch/base :
    ty2new-reftype T RT ->
    reftyping CM MM B Vin E (result/expr RT Vout) ->
  methtymatch* Vin Vout CM MM B (func/0 E) (methty/base T).

methtymatch/args/shared :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
    ({x} methtymatch* Vin Vout CM MM (B1 x) (F x) MT) ->
  methtymatch* Vin Vout CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/shared C) _ MT).

methtymatch/args/unique :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) ->
    clsmap`lookup CM C FM ->
    fldmap`domain FM FS ->
    nat+set2set (s N) FS Mf ->
    set`add Uin (s N) Uin' ->
    set`union Min Mf Min' ->
    ({x} methtymatch* (env/ Uin' Min') Vout CM MM (B1 x) (F x) MT) ->
  methtymatch* (env/ Uin Min) Vout CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/unique C) _ MT).

methtymatch/args/borrow :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/borrow C)) (B1 x)) ->
    nat+set2set (s N) FS Mf ->
    set`union Min Mf Min' ->
    set`union Mout Mf Mout' ->
    ({x} methtymatch* (env/ Uin Min') (env/ Uout Mout') CM MM (B1 x) (F x) MT) ->
  methtymatch* (env/ Uin Min) (env/ Uout Mout) CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/borrow C) FS MT).

%abbrev methtymatch = [CM][MM][F][MT] methtymatch* empty-env empty-env CM MM cxt/0 F MT.


%%% Theorems about matching methmap with proctype

%theorem methtymatch-respects-eq
  : forall* {CM} {MM} {F1} {F2} {MT1} {MT2}
    forall {F1-MT1: methtymatch CM MM F1 MT1}
    {F1=F2: func`eq F1 F2}
    {MT1=MT2: methty`eq MT1 MT2}
    exists {F2-MT2: methtymatch CM MM F2 MT2}
    true.

- : methtymatch-respects-eq M func`eq/ methty`eq/ M.

%worlds (gtermvar) (methtymatch-respects-eq _ _ _ _).
%total { } (methtymatch-respects-eq _ _ _ _).


%theorem shift-preserves-progtypematch
  : forall* {W} {W1} {W2} {G1} {G2} {N}
    forall {PM: progtypematch* W W1 G1}
    {SH: progtype`shift N W1 W2}
    {SH: prog`shift N G1 G2}
    exists {PM: progtypematch* W W2 G2}
    true.

- : shift-preserves-progtypematch PM progtype`shift/0 prog`shift/0 PM.

- : shift-preserves-progtypematch (progtypematch/+ PM PTM) _ _ (progtypematch/+ PM PTM).

%worlds (gtermvar) (shift-preserves-progtypematch _ _ _ _).
%total { } (shift-preserves-progtypematch _ _ _ _).


%theorem shift-preserves-progtypematch-converse/L
  : forall* {W} {W1} {G1} {FUN} {PT} {N1} {N2}
    forall {W1-G1: progtypematch* W W1 G1}
		{F-P: proctypematch W FUN PT}
		{N1=N2: nat`eq N1 N2}
    exists {W2-G2: progtypematch* W (progtype`map/+ N1 PT W1) (prog`map/+ N2 FUN G1)}
    true.

- : shift-preserves-progtypematch-converse/L W1-G1 F-P nat`eq/ (progtypematch/+ W1-G1 F-P).

%worlds (gtermvar) (shift-preserves-progtypematch-converse/L _ _ _ _).
%total { } (shift-preserves-progtypematch-converse/L _ _ _ _).


%theorem shift-preserves-progtypematch-converse
  : forall* {W} {W1} {W2} {G1} {G2} {N}
    forall {PM: progtypematch* W W2 G2}
    {SH: progtype`shift N W1 W2}
    {SH: prog`shift N G1 G2}
    exists {PM: progtypematch* W W1 G1}
    true.

- : shift-preserves-progtypematch-converse PM progtype`shift/0 prog`shift/0 PM.

- : shift-preserves-progtypematch-converse
    (progtypematch/+ W1-G1 F-P) (progtype`shift/+ P1) (prog`shift/+ P2) W2-G2
    <- nat`plus-left-cancels P1 P2 nat`eq/ nat`eq/ N1=N2
    <- shift-preserves-progtypematch-converse/L W1-G1 F-P N1=N2 W2-G2.

%worlds (gtermvar) (shift-preserves-progtypematch-converse _ _ _ _).
%total (PM) (shift-preserves-progtypematch-converse PM _ _ _).


%theorem methmap2progtype-preserves-fresh
  : forall* {PM} {CM} {MM} {W} {N}
    forall {MM2W: methmap2progtype PM CM MM W}
    {FS: methmap`fresh MM N}
    exists {FS: progtype`fresh W N}
    true.

%worlds (gtermvar) (methmap2progtype-preserves-fresh _ _ _).
%trustme %total { } (methmap2progtype-preserves-fresh MW _ _).


%theorem methtymatch-implies-proctypematch*/L1
  : forall* {CM} {PM} {B} {T} {RT} {PF}
    forall {T=>RT: ty2new-reftype T RT}
    {RT=>PF: reftype2perm CM PM B RT ([o][r][p] PF o r p)}
    exists {PF'} {T=>PF': ty2perm PM T ([x] PF' x)}
    {EQ: {o}{r}{p} permission`eq (PF o r p) (PF' o)}
    true.

- : methtymatch-implies-proctypematch*/L1
    ty2new-reftype/unique (reftype2perm/fresh T2PF) _ T2PF ([_][_][_] permission`eq/).

- : methtymatch-implies-proctypematch*/L1
    ty2new-reftype/shared (reftype2perm/shared T2PF) _ T2PF ([_][_][_] permission`eq/).

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L1 _ _ _ _ _).
%total { } (methtymatch-implies-proctypematch*/L1 _ _ _ _ _).


%theorem methtymatch-implies-proctypematch*/L2
  : forall* {CM} {B} {M0} {N} {FS} {M1}
    forall {CM-B-OS: clsmap-cxt-capset CM B M0}
    {N!<B: cxt`fresh B (s N)}
    {N+FS=>M1: nat+set2set (s N) FS M1}
    exists {DJ: set`disjoint M0 M1}
    true.

%theorem methtymatch-implies-proctypematch*/L2L
  : forall* {N} {FS} {M}
    forall {N+FS=>M: nat+set2set (s N) FS M}
    exists {NM: set`not-member M z}
    true.

%theorem methtymatch-implies-proctypematch*/L2L/L
  : forall* {N} {FS} {M}
    forall {N+FS=>M: nat+set2set (s N) FS M}
    {B} {MB?: set`member? M z B}
    exists {NM: set`not-member M z}
    true.

- : methtymatch-implies-proctypematch*/L2L/L N+FS=>M true (set`member?/in Z<-M) NM
    <- set`lookup-implies-not-member-update Z<-M M' Z!<M' M'+Z=M
    <- nat+set2set/UP-inversion N+FS=>M Z!<M' M'+Z=M FSP _ _ N+F=Z _
    <- nat2pair-deterministic/0 N+F=Z PE
    <- pair-eq-implies-eq PE EQ' _
    <- nat`eq-symmetric EQ' EQ
    <- nat`eq-contradiction EQ V
    <- set`false-implies-not-member V NM.

- : methtymatch-implies-proctypematch*/L2L/L _ false (set`member?/out NM) NM.

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L2L/L _ _ _ _).
%total { } (methtymatch-implies-proctypematch*/L2L/L _ _ _ _).

- : methtymatch-implies-proctypematch*/L2L N+FS=>M NM
    <- set`member?-total MB?
    <- methtymatch-implies-proctypematch*/L2L/L N+FS=>M _ MB? NM.

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L2L _ _).
%total { } (methtymatch-implies-proctypematch*/L2L _ _).


- : methtymatch-implies-proctypematch*/L2 clsmap-cxt-capset/0 _ _ set`disjoint/L.

- : methtymatch-implies-proctypematch*/L2 _ _ nat+set2set/0 set`disjoint/R.

- : methtymatch-implies-proctypematch*/L2 (clsmap-cxt-capset/z CM-B-M0P Z!<M0P M0P+Z=M0)
    N!<B N+FS=>M1 M0^M1
    <- methtymatch-implies-proctypematch*/L2 CM-B-M0P N!<B N+FS=>M1 M0P^M1
    <- methtymatch-implies-proctypematch*/L2L N+FS=>M1 Z!<M1
    <- set`disjoint-symmetric M0P^M1 M1^M0P
    <- set`not-member-add-preserves-disjoint M1^M0P Z!<M1 M0P+Z=M0 M1^M0
    <- set`disjoint-symmetric M1^M0 M0^M1.

- : methtymatch-implies-proctypematch*/L2
    (clsmap-cxt-capset/U CM-B-M0P N+F=K BL _ CML FML K!<M0P M0P+K=M0)
    N!<B N+FS=>M1 M0^M1
    <- cxt`fresh-lookup-not-equal N!<B BL (NE:nat`ne (s N) N0)
    <- nat+set2set-nat-ne-implies-disjoint/L N+FS=>M1 NE N+F=K K!<M1
    <- methtymatch-implies-proctypematch*/L2 CM-B-M0P N!<B N+FS=>M1 M0P^M1
    <- set`disjoint-symmetric M0P^M1 M1^M0P
    <- set`not-member-add-preserves-disjoint M1^M0P K!<M1 M0P+K=M0 M1^M0
    <- set`disjoint-symmetric M1^M0 M0^M1.

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L2 _ _ _ _).
%total (A) (methtymatch-implies-proctypematch*/L2 A _ _ _).


%%% Here Piin should be PiB + PiVin, and Piout should be PiB + PiVout
%theorem methtymatch-implies-proctypematch*
  : forall* {CM} {MM} {PM} {B} {W} {MT} {F} {Vin} {Vout}
    {PT} {PiB} {Piin} {Piout} {PiVin} {PiVout}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-Vin: clsmap-cxt-env CM B Vin}
    {CM-B-Vout: clsmap-cxt-env CM B Vout}
    {B=>PiB: cxt2perm PM B PiB}
    {Vin=>Piin: env2input CM PM B Vin PiVin}
    {Vout=>Piout: env2input CM PM B Vout PiVout}
    {IMP: implies Piin (PiB , PiVin)}
    {IMP: implies (PiB , PiVout) Piout}
    {CM-MT: clsmap-methty CM MT}
    {MC: methtymatch* Vin Vout CM MM B F MT}
    {MT=>PT: methty2proctype* CM PM Piin Piout MT PT}
    exists {PC: proctypematch W F PT}
    true.

- : methtymatch-implies-proctypematch*
    CM-CM CM-MM CM2PM MM2W CM-B CM-B-Vin CM-B-Vout
    (B=>PiB:cxt2perm PM B PiB)
    (Vin=>PiVin:env2input CM PM B Vin PiVin)
    (Vout=>PiVout:env2input CM PM B Vout PiVout)
    IMP0 IMP1
    (clsmap-methty/base CM-T)
    (methtymatch/base T=>RT RTYP)
    (methty2proctype/base (T2PF:ty2perm PM T PF))
    (proctypematch/base
      (tTrans
        (transform/implies
          (implies/trans IMP0
            (implies/equiv (equiv/combine PiB<=>PiB' PiVin<=>PiVin'))))
        (letTyping/base null TYP)
        (transform/inside [o]
          (transform/trans3
            (transform/inside [r]
              (transform/inside [p]
                (transform/implies
                  (implies/trans4
                    (implies/equiv equiv/identity)
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/combine
                          (equiv/transitive (EQV o r p) (PF'<=>PF o))
                          (PiVout'<=>PiVout))))
                    (implies/equiv equiv/reorder)
                    (implies/combine implies/reflexive
                      (implies/trans
                        (implies/combine (implies/equiv PiB''<=>PiB) implies/reflexive)
                        (IMP1)))))))
            (transform/rem-unused)
            (transform/rem-unused)))))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-Vin RTYP PiB' PiVin' _ B=>PiB'
      Vin=>PiVin'
      (result2output/expr
        (B=>PiB'':cxt2perm PM B PiB'')
        (Vout=>PiVout':env2input CM PM B Vout PiVout')
        RT=>PF) TYP
    <- env2input-unique Vin=>PiVin Vin=>PiVin' env`eq/ PiVin<=>PiVin'
    <- methtymatch-implies-proctypematch*/L1 T=>RT RT=>PF PF' T2PF' EQ
    <- ({o}{r}{p} permission`eq-implies-equiv (EQ o r p) (EQV o r p))
    <- cxt2perm-equiv B=>PiB B=>PiB' predmap`eq/ cxt`eq/ PiB<=>PiB'
    <- cxt2perm-equiv B=>PiB'' B=>PiB predmap`eq/ cxt`eq/ PiB''<=>PiB
    <- env2input-unique Vout=>PiVout' Vout=>PiVout env`eq/ PiVout'<=>PiVout
    <- ty2perm-deterministic T2PF' T2PF predmap`eq/ ty`eq/ PF'=PF
    <- ({x} permission`eq-implies-equiv (PF'=PF x) (PF'<=>PF x)).

- : methtymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (CM-B0-Vin:clsmap-cxt-env CM B0 Vin)
    (CM-B0-Vout:clsmap-cxt-env CM B0 Vout)
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (B0+Vin=>PiVin:env2input CM PM B0 Vin PiVin)
    (B0+Vout=>PiVout:env2input CM PM B0 Vout PiVout)
    (IMP0:implies Piin (PiB0 , PiVin))
    (IMP1:implies (PiB0 , PiVout) Piout)
    (clsmap-methty/args CM-MT CML DM LE)
    (methtymatch/args/shared N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) x)
      ([x] MC x))
    (methty2proctype/arg
      (argtype2perm/shared T2PF) MT=>PT)
    (proctypematch/arg PC)
    <- cxt`fresh-update-preserves-env2input B0+Vin=>PiVin N!<B0 B0+N=B1 B1+Vin=>PiVin
    <- cxt`fresh-update-preserves-env2input B0+Vout=>PiVout N!<B0 B0+N=B1 B1+Vout=>PiVout
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vin N!<B0 B0+N=B1 CM-B1-Vin
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vout N!<B0 B0+N=B1 CM-B1-Vout
    <- ({x} methtymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (CM-B1-Vin x) (CM-B1-Vout x)
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/shared T2PF))
         (B1+Vin=>PiVin x) (B1+Vout=>PiVout x)
         (implies/trans
           (implies/combine implies/reflexive (IMP0))
           (implies/associate))
         (implies/trans
           (implies/symmetric-associate)
           (implies/combine implies/reflexive IMP1))
         (CM-MT) (MC x) (MT=>PT x)
         (PC x)).

- : methtymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (clsmap-cxt-env/ CM-B0-Uin CM-B0-Min)
    (clsmap-cxt-env/ CM-B0-Uout CM-B0-Mout)
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (env2input/ (B0+Uin=>PiUin:make-encumbered CM PM B0 Uin PiUin)
      (B0+Min=>PiMin:capset2perm CM PM B0 Min PiMin))
    (env2input/ (B0+Uout=>PiUout:make-encumbered CM PM B0 Uout PiUout)
      (B0+Mout=>PiMout:capset2perm CM PM B0 Mout PiMout))
    (IMP0) (IMP1)
    (clsmap-methty/args CM-MT (CML2:clsmap`lookup CM C FM2)
      (DM2:fldmap`domain FM2 FS2) LE2)
    (methtymatch/args/borrow N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/borrow C)) (B1 x)) x)
      (N+FS=>Mf:nat+set2set (s N) FS3 Mf) (Min+Mf=Min':set`union Min Mf Min')
      (Mout+Mf=Mout':set`union Mout Mf Mout')
      ([x] MC x))
    (methty2proctype/arg
      (argtype2perm/borrow (CML:clsmap`lookup CM C FM)
        (DM:fldmap`domain FM FS) LE FS=>PF T2PFB) MT=>PT)
    (proctypematch/arg PC)
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- cxt`fresh-update-preserves-make-encumbered B0+Uin=>PiUin N!<B0 B0+N=B1 B1+Uin=>PiUin
    <- cxt`fresh-update-preserves-capset2perm B0+Min=>PiMin N!<B0 B0+N=B1 B1+Min=>PiMin
    <- cxt`fresh-update-preserves-make-encumbered B0+Uout=>PiUout N!<B0 B0+N=B1 B1+Uout=>PiUout
    <- cxt`fresh-update-preserves-capset2perm B0+Mout=>PiMout N!<B0 B0+N=B1 B1+Mout=>PiMout
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uin N!<B0 B0+N=B1 CM-B1-Uin
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Min N!<B0 B0+N=B1 CM-B1-Min
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uout N!<B0 B0+N=B1 CM-B1-Uout
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Mout N!<B0 B0+N=B1 CM-B1-Mout
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} nat+set2set-implies-clsmap-cxt-capset/L CML DM LE (B1-L x) not-shared/borrow
         N+FS=>Mf (CM-B1-Mf x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Min x) (CM-B1-Mf x) Min+Mf=Min'
         (CM-B1-Min' x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Mout x) (CM-B1-Mf x) Mout+Mf=Mout'
         (CM-B1-Mout' x))
    <- letRefTyping-helper/base/unique/L4L2* CML FS=>PF B1-L N+FS=>Mf _ B1+Mf=>PiMf IMP5 IMP6
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Min N!<B0 N+FS=>Mf Min^Mf
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Mout N!<B0 N+FS=>Mf Mout^Mf
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Min^Mf Min+Mf=Min')
         (B1+Min=>PiMin x) (B1+Mf=>PiMf x) _ (B1+Min'=>PiMin' x) (EQV1 x))
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Mout^Mf Mout+Mf=Mout')
         (B1+Mout=>PiMout x) (B1+Mf=>PiMf x) _ (B1+Mout'=>PiMout' x) (EQV2 x))
    <- not-unique-perm-implies-empty T2PFB not-unique/borrow IMP7
    <- ({x} methtymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (clsmap-cxt-env/ (CM-B1-Uin x) (CM-B1-Min' x))
         (clsmap-cxt-env/ (CM-B1-Uout x) (CM-B1-Mout' x))
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/borrow T2PFB))
         (env2input/ (B1+Uin=>PiUin x) (B1+Min'=>PiMin' x))
         (env2input/ (B1+Uout=>PiUout x) (B1+Mout'=>PiMout' x))
         (implies/trans3
           (implies/combine implies/reflexive (IMP0))
           (implies/equiv equiv/swap-middle)
           (implies/combine implies/reflexive
             (implies/trans3
               (implies/combine (IMP5 x) implies/reflexive)
               (implies/equiv equiv/reorder)
               (implies/combine implies/reflexive
                 (implies/trans implies/commute (implies/equiv (EQV1 x)))))))
         (implies/trans4
           (implies/combine
             (implies/trans
               (implies/combine (IMP7 x) implies/reflexive)
               (implies/commute-identity))
             (implies/trans
               (implies/combine
                 (implies/reflexive)
                 (implies/trans
                   (implies/equiv (equiv/symmetric (EQV2 x)))
                   (implies/combine implies/reflexive (IMP6 x))))
               (implies/associate)))
           (implies/associate)
           (implies/combine (IMP1) implies/reflexive)
           (implies/commute))
         (CM-MT) (MC x) (MT=>PT x)
         (PC x)).

- : methtymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (clsmap-cxt-env/ CM-B0-Uin CM-B0-Min)
    CM-B0-Vout
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (env2input/ (B0+Uin=>PiUin:make-encumbered CM PM B0 Uin PiUin)
      (B0+Min=>PiMin:capset2perm CM PM B0 Min PiMin))
    (B0+Vout=>PiVout:env2input CM PM B0 Vout PiVout)
    (IMP0)
    (IMP1:implies (PiB0 , PiVout) Piout)
    (clsmap-methty/args CM-MT (CML2:clsmap`lookup CM C FM2)
      (DM2:fldmap`domain FM2 FS2) LE)
    (methtymatch/args/unique N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) x)
      (CML:clsmap`lookup CM C FM) (DM:fldmap`domain FM FS)
      (N+FS=>Mf:nat+set2set (s N) FS Mf) (Uin+N=Uin':set`add Uin (s N) Uin')
      (Min+Mf=Min':set`union Min Mf Min')
      ([x] MC x))
    (methty2proctype/arg
      (argtype2perm/unique T2PF) MT=>PT)
    (proctypematch/arg PC)
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- cxt`fresh-update-preserves-make-encumbered B0+Uin=>PiUin N!<B0 B0+N=B1 B1+Uin=>PiUin
    <- cxt`fresh-update-preserves-capset2perm B0+Min=>PiMin N!<B0 B0+N=B1 B1+Min=>PiMin
    <- cxt`fresh-update-preserves-env2input B0+Vout=>PiVout N!<B0 B0+N=B1 B1+Vout=>PiVout
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uin N!<B0 B0+N=B1 CM-B1-Uin
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Min N!<B0 B0+N=B1 CM-B1-Min
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vout N!<B0 B0+N=B1 CM-B1-Vout
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- cxt`domain-total (DM-B0=BS0:cxt`domain B0 BS0)
    <- clsmap-cxt-objset-implies-domain-leq CM-B0-Uin DM-B0=BS0 Uin<=BS0
    <- cxt`domain-preserves-fresh N!<B0 DM-B0=BS0 N!<BS0
    <- set`not-member-respects-geq N!<BS0 Uin<=BS0 N!<Uin
    <- ({x} nat+set2set-implies-clsmap-cxt-capset CML DM (B1-L x) not-shared/unique
         N+FS=>Mf (CM-B1-Mf x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Min x) (CM-B1-Mf x) Min+Mf=Min'
         (CM-B1-Min' x))
    <- letRefTyping-helper/base/unique/L4L1** CM-CM CM2PM CML PML DM T2PF _ _ FS=>PF T2PFB IMP4
    <- letRefTyping-helper/base/unique/L4L2* CML FS=>PF B1-L N+FS=>Mf _ B1+Mf=>PiMf IMP5 _
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Min N!<B0 N+FS=>Mf Min^Mf
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Min^Mf Min+Mf=Min')
         (B1+Min=>PiMin x) (B1+Mf=>PiMf x) _ (B1+Min'=>PiMin' x) (EQV x))
    <- not-unique-perm-implies-empty T2PFB not-unique/borrow IMP7
    <- ({x} methtymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (clsmap-cxt-env/
           (clsmap-cxt-objset/U (CM-B1-Uin x) (B1-L x) CML N!<Uin Uin+N=Uin')
           (CM-B1-Min' x))
         (CM-B1-Vout x)
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/unique T2PFB))
         (env2input/
           (make-encumbered/U (B1+Uin=>PiUin x) (B1-L x) CML PML DM
             FS=>PF N!<Uin Uin+N=Uin')
           (B1+Min'=>PiMin' x))
         (B1+Vout=>PiVout x)
         (implies/trans5
           (implies/combine (IMP4 x) (IMP0))
           (implies/equiv equiv/swap-middle)
           (implies/combine
             (implies/equiv equiv/swap) (implies/reflexive))
           (implies/symmetric-associate)
           (implies/combine implies/reflexive
             (implies/trans3
               (implies/combine implies/reflexive implies/reorder)
               (implies/associate)
               (implies/combine implies/reflexive
                 (implies/trans3
                   (implies/commute)
                   (implies/combine implies/reflexive (IMP5 x))
                   (implies/equiv (EQV x)))))))
         (implies/trans
           (implies/symmetric-associate)
           (implies/combine (IMP7 x) (IMP1)))
         (CM-MT) (MC x) (MT=>PT x)
         (PC x)).

%worlds (gtermvar) (methtymatch-implies-proctypematch* _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (M) (methtymatch-implies-proctypematch* _ _ _ _ _ _ _ _ _ _ _ _ _ M _ _).


%theorem methtymatch-implies-proctypematch
  : forall* {CM} {MM} {PM} {W} {MT} {F} {PT}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-MT: clsmap-methty CM MT}
    {F-MT: methtymatch CM MM F MT}
    {MT=>PT: methty2proctype CM PM MT PT}
    exists {PC: proctypematch W F PT}
    true.

- : methtymatch-implies-proctypematch CM-CM CM-MM CM2PM MM2W
    CM-MT F-MT MT=>PT F-PT
    <- methtymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
      clsmap-cxt/0
      (clsmap-cxt-env/ clsmap-cxt-objset/0 clsmap-cxt-capset/0)
      (clsmap-cxt-env/ clsmap-cxt-objset/0 clsmap-cxt-capset/0)
      (cxt2perm/0)
      (env2input/ make-encumbered/0 capset2perm/0)
      (env2input/ make-encumbered/0 capset2perm/0)
      (implies/trans
        (implies/symmetric-identity)
        (implies/combine implies/reflexive (implies/symmetric-identity)))
      (implies/trans
        (implies/combine implies/reflexive implies/identity)
        (implies/identity))
      CM-MT F-MT MT=>PT F-PT.

%worlds (gtermvar) (methtymatch-implies-proctypematch _ _ _ _ _ _ _ _).
%total { } (methtymatch-implies-proctypematch _ _ _ _ _ _ _ _).



%%% A set of helper relations to prove the case of constymatch

%%% Bijection between raw field permissions and set members

set-rawfldperm : set -> (object -> permission) -> type.

set-rawfldperm/0 : set-rawfldperm set/0 ([_] empty).

set-rawfldperm/+
  : set-rawfldperm S ([t] (unitperm (basic t F null)) , (B t))
    <- set`union S1 (set/1 F) S
    <- set`not-member S1 F
    <- set-rawfldperm S1 B.


%%% Bijection between assembled field permissions and set members

set-fldpred : predmap -> fldmap -> set -> (object -> permission) -> type.

set-fldpred/0 : set-fldpred _ _ set/0 ([_] empty).

set-fldpred/+
  : set-fldpred PM FM S ([t] ((unitperm (precise-exists t F PF)) , (R t)))
    <- fldmap`lookup FM F T
    <- ty2perm PM T PF
    <- set`union S1 (set/1 F) S
    <- set`not-member S1 F
    <- set-fldpred PM FM S1 ([t] R t).


%%% Relation between set of fields and expr in constructor
%%% it simply says all fields appeared in the expr must be
%%% in the set.

set-expr : set -> (object -> expr) -> type.

set-expr/0 : set-expr _ ([t] lit t).

set-expr/+
  : set-expr S ([t] (seq (write (lit t) F _)) (B t))
    <- set`member S F
    <- set-expr S B.


%%% Property of nonnull set

nonnull-set : fldmap -> set -> type.

nonnull-set/0 : nonnull-set _ set/0.

nonnull-set/+
  : nonnull-set FM S
    <- fldmap`lookup FM F (ty/ nn/yes _ _)
    <- set`not-member SP F % this is not necessary, but will make proof easier
    <- set`add SP F S
    <- nonnull-set FM SP.


maynull-set : fldmap -> set -> type.

maynull-set/0 : maynull-set _ set/0.

maynull-set/+
  : maynull-set FM S
    <- fldmap`lookup FM F (ty/ nn/may _ _)
    <- set`not-member SP F
    <- set`add SP F S
    <- maynull-set FM SP.


%%% Select nonnull fields

select-nn-fields : fldmap -> set -> type.

select-nn-fields/0 : select-nn-fields fldmap/0 set`set/0.

select-nn-fields/+/in
 : select-nn-fields (fldmap/+ F (ty/ nn/yes _ _) M) S
    <- fldmap`shift F M M'
    <- select-nn-fields M' S'
    <- set`union S' (set/1 F) S.

select-nn-fields/+/result
  : select-nn-fields (fldmap/+ F (ty/ nn/may _ _) M) S
    <- fldmap`shift F M M'
    <- select-nn-fields M' S.


%%% Some Lemmas

%theorem fldmap-shift-preserves-fresh
  : forall* {M1} {M2} {N} {F} {T}
    forall {NM: fldmap`fresh (fldmap`map/+ F T M1) N}
    {SH: fldmap`shift F M1 M2}
    exists {NM: fldmap`fresh M2 N}
    true.

- : fldmap-shift-preserves-fresh _ fldmap`shift/0 fldmap`fresh/0.

- : fldmap-shift-preserves-fresh FS (fldmap`shift/+ SF+N2=N3) FS1
    <- nat`plus-swap-succ SF+N2=N3 F+SN2=N3
    <- nat`plus-commutative F+SN2=N3 SN2+F=N3
    <- fldmap`update-preserves-fresh-converse FS (fldmap`update/< SN2+F=N3) FS1.

%worlds () (fldmap-shift-preserves-fresh _ _ _).
%total (SH) (fldmap-shift-preserves-fresh _ SH _).


%%% Theorems about set-rawfldperm

%theorem set-rawfldperm-respects-eq
  : forall* {S1} {P1} {S2} {P2}
    forall {SR: set-rawfldperm S1 ([t] P1 t)}
		{EQ: set`eq S1 S2} {EQ: {t} permission`eq (P1 t) (P2 t)}
    exists {SR: set-rawfldperm S2 ([t] P2 t)}
    true.

- : set-rawfldperm-respects-eq SR set`eq/ ([_] permission`eq/) SR.

%worlds (gtermvar) (set-rawfldperm-respects-eq _ _ _ _).
%total { } (set-rawfldperm-respects-eq _ _ _ _).


%theorem allocfields-implies-set-rawfldperm
  :	forall* {FM} {S} {P1}
    forall {DM: fldmap`domain FM S}
		{SR: {t} allocFields t S (P1 t)}
    exists {P2} {I: {t} implies (P1 t) (P2 t)}
    {SR: set-rawfldperm S ([t] P2 t)}
    true.

- : allocfields-implies-set-rawfldperm
    fldmap`domain/0 ([_] allocFields/0) _ ([_] implies/reflexive) set-rawfldperm/0.


- : allocfields-implies-set-rawfldperm
    (fldmap`domain/+ DM-FM) ([t] allocFields/+ F<<S=SP (SP->PP t))
    _ ([t] implies/trans
        (implies/equiv equiv/commute)
        (implies/combine
          (implies/reflexive)
          (I t)))
    (set-rawfldperm/+ SP-B F/SP SPUF=S)
    <- fldmap`shift-total F<<FM=FMP
    <- fldmap`shift-preserves-domain* DM-FM F<<FM=FMP F<<S=SP DM-FMP
    <- allocfields-implies-set-rawfldperm DM-FMP SP->PP _ ([t] I t) SP-B
    <- set`shift-implies-not-member F<<S=SP F/SP
    <- set`shift-implies-update F<<S=SP SP+N=S
    <- set`add-implies-unit-union SP+N=S SPUF=S.

%worlds (gtermvar) (allocfields-implies-set-rawfldperm _ _ _ _ _).
%total (SR) (allocfields-implies-set-rawfldperm _ SR _ _ _).


%%% Theorems about set-fldpred

%theorem set-fldpred-respects-eq
  :	forall* {PM1} {PM2} {FM1} {FM2} {S1} {S2} {P1} {P2}
    forall {SF: set-fldpred PM1 FM1 S1 ([t] P1 t)}
		{EQ: predmap`eq PM1 PM2} {EQ: fldmap`eq FM1 FM2}
		{EQ: set`eq S1 S2} {EQ: {o} permission`eq (P1 o) (P2 o)}
    exists {SF: set-fldpred PM2 FM2 S2 ([t] P2 t)}
    true.

- : set-fldpred-respects-eq SF predmap`eq/ fldmap`eq/ set`eq/ ([_] permission`eq/) SF.

%worlds () (set-fldpred-respects-eq _ _ _ _ _ _).
%total { } (set-fldpred-respects-eq _ _ _ _ _ _).


%theorem set-fldpred-shrink-fldmap
  : forall* {PM} {FM1} {FM} {S} {R} {F} {T}
    forall {SF: set-fldpred PM FM1 S ([t] (R t))}
    {FS: set`not-member S F}
    {U: fldmap`update FM F T FM1}
    exists {SF: set-fldpred PM FM S ([t] (R t))}
    true.

- : set-fldpred-shrink-fldmap set-fldpred/0 _ _ set-fldpred/0.

- : set-fldpred-shrink-fldmap
    (set-fldpred/+ S1-R N/S1 S1UN=S T2PF FM1-L) F/S FM+F=FM1
    (set-fldpred/+ S1-R1 N/S1 S1UN=S T2PF FM-L)
    <- set`union-preserves-not-member-converse* F/S S1UN=S F/S1 _
    <- set-fldpred-shrink-fldmap S1-R F/S1 FM+F=FM1 S1-R1
    <- set`union-left-preserves-member* (set`lookup/= nat`eq/) S1UN=S N#S
    <- set`not-member-lookup-not-equal F/S N#S F!=N
    <- nat`ne-symmetric F!=N N!=F
    <- fldmap`update-preserves-lookup-converse FM1-L FM+F=FM1 N!=F FM-L.

%worlds (objvar) (set-fldpred-shrink-fldmap _ _ _ _).
%total (SF) (set-fldpred-shrink-fldmap SF _ _ _).


%theorem false-implies-implies-var
  : forall* {P1: object -> permission} {P2}
    forall {V:void}
    exists {IMP: {o} implies (P1 o) (P2 o)}
    true.

%worlds (objvar) (false-implies-implies-var _ _).
%total { } (false-implies-implies-var _ _).


%theorem set-fldpred-implies-fldmap2conj/L1
  : forall* {FM} {S1} {S} {F} {T} {N}
    forall {SZ: fldmap`size FM (s N)}
    {DM: fldmap`domain FM S}
    {L: fldmap`lookup FM F T}
    {U: set`union S1 (set/+ F set/0) S}
    {FS: set`not-member S1 F}
    exists {FM1} {SZ: fldmap`size FM1 N}
    {DM: fldmap`domain FM1 S1}
    {FS: fldmap`fresh FM1 F}
    {U: fldmap`update FM1 F T FM}
    true.

- : set-fldpred-implies-fldmap2conj/L1 SZ-FM DM-FM=S FM-L S1UF=S F/S1 %{=>}%
    FM1 SZ-FM1=N DM-FM1=S1 F/FM1 FM1+F=FM
    <- fldmap`can-remove SZ-FM FM-L %{=>}% FM1 N1 SZ-FM1=N1 SN1=SN FM1+F=FM F/FM1
    <- nat`succ-cancels SN1=SN N1=N
    <- fldmap`size-respects-eq SZ-FM1=N1 fldmap`eq/ N1=N SZ-FM1=N
    <- fldmap`domain-total DM-FM1=S2
    <- fldmap`domain-preserves-fresh F/FM1 DM-FM1=S2 F/S2
    <- fldmap`update-commute-domain FM1+F=FM DM-FM1=S2 DM-FM=S S2+F=S
    <- set`not-member-update-implies-unit-union F/S2 S2+F=S S2UF=S
    <- set`union-implies-leq S1UF=S S1<=S F<=S
    <- set`union-implies-leq S2UF=S S2<=S _
    <- set`not-member-implies-unit-disjoint F/S1 S1XF
    <- set`not-member-implies-unit-disjoint F/S2 S2XF
    <- set`disjoint-symmetric S1XF FXS1
    <- set`disjoint-symmetric S2XF FXS2
    <- set`union-commutative S1UF=S FUS1=S
    <- set`union-commutative S2UF=S FUS2=S
    <- set`leq-reflexive _ S<=S
    <- set`remove-characterization S1<=S FXS1 FUS1=S S<=S S/F=S1
    <- set`remove-characterization S2<=S FXS2 FUS2=S S<=S S/F=S2
    <- set`remove-deterministic S/F=S1 S/F=S2 set`eq/ set`eq/ S1=S2
    <- set`eq-symmetric S1=S2 S2=S1
    <- fldmap`domain-respects-eq DM-FM1=S2 fldmap`eq/ S2=S1 DM-FM1=S1.

%worlds () (set-fldpred-implies-fldmap2conj/L1 _ _ _ _ _ _ _ _ _ _).
%total { } (set-fldpred-implies-fldmap2conj/L1 _ _ _ _ _ _ _ _ _ _).


%theorem set-fldpred-implies-fldmap2conj/L2
  : forall* {CM} {PM} {FM} {FM1} {G1} {F} {T} {PF}
    forall {F2C: fldmap2conj CM PM FM1 ([o] G1 o) PM}
    {FS: fldmap`fresh FM1 F}
    {U: fldmap`update FM1 F T FM}
    {T2PF: ty2perm PM T PF}
    exists {G} {F2C: fldmap2conj CM PM FM ([t] G t) PM}
    {IMP: {o} implies (combine (unitperm (precise-exists o F PF)) (G1 o)) (G o)}
    true.

- : set-fldpred-implies-fldmap2conj/L2
    fldmap2conj/0 fldmap`fresh/0 fldmap`update/0 (ty2perm/ PM-L NN2P A2P) _
    (fldmap2conj/in fldmap2conj/0 NN2P A2P fldmap`shift/0 PM-L)
    ([_] implies/reflexive).

- : set-fldpred-implies-fldmap2conj/L2 F2C
    F/FM1 (fldmap`update/< SN3+F=N) (ty2perm/ PM-L NN2P A2P) _
    (fldmap2conj/in F2C NN2P A2P (fldmap`shift/+ SF+N3=N) PM-L)
    ([_] implies/reflexive)
    <- nat`plus-swap-succ SN3+F=N N3+SF=N
    <- nat`plus-commutative N3+SF=N SF+N3=N.

- : set-fldpred-implies-fldmap2conj/L2
    (fldmap2conj/in F2C-FM3 NN2P1 A2P1 N<<FM2=FM3 PM-L1) F/FM1
    (fldmap`update/> FM2+N0=FM4 SN0+N=F) (ty2perm/ PM-L2 NN2P2 A2P2) _
    (fldmap2conj/in F2C-FM5 NN2P1 A2P1 N<<FM4=FM5 PM-L1)
    ([o] implies/trans
      (implies/reorder)
      (implies/combine implies/reflexive (IMP o)))
    <- fldmap`shift-total N<<FM4=FM5
    <- fldmap-shift-preserves-fresh F/FM1 N<<FM2=FM3 F/FM3
    <- nat`plus-swap-succ SN0+N=F N0+SN=F
    <- nat`plus-commutative N0+SN=F SN+N0=F
    <- fldmap`shift-preserves-update* FM2+N0=FM4 N<<FM2=FM3 SN+N0=F N<<FM4=FM5 FM3+F=FM5
    <- set-fldpred-implies-fldmap2conj/L2
      F2C-FM3 F/FM3 FM3+F=FM5 (ty2perm/ PM-L2 NN2P2 A2P2) _ F2C-FM5 ([t] IMP t).

% - : set-fldpred-implies-fldmap2conj/L2 (fldmap2conj/null F2C-FM3 N<<FM2=FM3)
%      F/FM1 (fldmap`update/> FM2+N0=FM4 SN0+N=F) PM-L FNN2P _
%      (fldmap2conj/null F2C-FM5 N<<FM4=FM5) ([t] IMP t)
%      <- fldmap`shift-total N<<FM4=FM5
%      <- fldmap-shift-preserves-fresh F/FM1 N<<FM2=FM3 F/FM3
%      <- nat`plus-swap-succ SN0+N=F N0+SN=F
%      <- nat`plus-commutative N0+SN=F SN+N0=F
%      <- fldmap`shift-preserves-update* FM2+N0=FM4 N<<FM2=FM3 SN+N0=F N<<FM4=FM5 FM3+F=FM5
%      <- set-fldpred-implies-fldmap2conj/L2
% 	F2C-FM3 F/FM3 FM3+F=FM5 PM-L FNN2P _ F2C-FM5 ([t] IMP t).


%%% impossible cases

%theorem set-fldpred-implies-fldmap2conj/L2L
  : forall* {CM} {PMin} {FM} {PMout}
    forall {F:void}
    exists {G} {F2C: fldmap2conj CM PMin FM ([t] G t) PMout}
    true.

%worlds (objvar) (set-fldpred-implies-fldmap2conj/L2L _ _ _).
%total { } (set-fldpred-implies-fldmap2conj/L2L _ _ _).


- : set-fldpred-implies-fldmap2conj/L2 _ F/FM1 (fldmap`update/= N=F) _ _ F2C BIMP
    <- nat`eq-symmetric N=F F=N
    <- fldmap`fresh-respects-eq F/FM1 fldmap`eq/ F=N N/FM1
    <- fldmap`fresh-contradiction N/FM1 V
    <- set-fldpred-implies-fldmap2conj/L2L V G F2C
    <- false-implies-implies-var V ([o] BIMP o).

- : set-fldpred-implies-fldmap2conj/L2
    (fldmap2conj/out F2C1
      (F2CF:{p:clspred} fldmap2conj _ _ _ ([o:object] CJ p o) _)
      ([p] PM-U p) _ _ _ _ PM-FS) _ _ _ %{=>}% G F2C IMP
    <- ({p} predmap`update-implies-lookup (PM-U p) (PME-L p))
    <- ({p} fldmap2conj-implies-predmap-leq (F2CF p) (PME<=PMF p))
    <- ({p} predmap`lookup-respects-leq (PME-L p) (PME<=PMF p) _ (PMF-L p) _)
    <- fldmap2conj-implies-predmap-leq F2C1 PMF<=PM
    <- predmap`lookup-respects-leq (PMF-L (conj2pred CJ)) PMF<=PM _ PM-L _
    <- predmap`fresh-lookup-not-equal PM-FS PM-L NE
    <- nat`eq-ne-implies-false nat`eq/ NE V
    <- set-fldpred-implies-fldmap2conj/L2L V G F2C
    <- false-implies-implies-var V ([o] IMP o).

%worlds (objvar) (set-fldpred-implies-fldmap2conj/L2 _ _ _ _ _ _ _).
%total (F2C) (set-fldpred-implies-fldmap2conj/L2 F2C _ _ _ _ _ _).


%theorem set-fldpred-implies-fldmap2conj/L
  : forall* {CM} {PM} {FM:fldmap} {S} {FP}
    forall {N} {SZ: fldmap`size FM N} {DM: fldmap`domain FM S}
		{SF: set-fldpred PM FM S ([t] FP t)}
    exists {G} {F2C: fldmap2conj CM PM FM ([t] G t) PM}
    {TAS: {t} transform
          (output/expr t (FP t))
          (output/expr t (G t))}
    true.

- : set-fldpred-implies-fldmap2conj/L z _
     fldmap`domain/0 set-fldpred/0 %{=>}%
    _ fldmap2conj/0 ([t] transform/reflexive).

- : set-fldpred-implies-fldmap2conj/L (s N) SZ DM
    (set-fldpred/+ S1-R F/S1 S1UF=S T2PF FM-L) %{=>}% _ F2C
    ([t] transform/trans
      (TAS1 t)
      (transform/implies (IMP t)))
    <- set-fldpred-implies-fldmap2conj/L1 SZ DM FM-L S1UF=S F/S1 _ SZ1 DM1 F/FM1 FM1+F=FM
    <- set-fldpred-shrink-fldmap S1-R F/S1 FM1+F=FM S1-R1
    <- set-fldpred-implies-fldmap2conj/L N SZ1 DM1 S1-R1 _ F2C1 ([t] TAS t)
    <- set-fldpred-implies-fldmap2conj/L2 F2C1 F/FM1 FM1+F=FM T2PF _ F2C IMP
    <- ({t} transform-commutes-envadd* (TAS t) envadd/expr envadd/expr (TAS1 t)).

%worlds (objvar) (set-fldpred-implies-fldmap2conj/L _ _ _ _ _ _ _).
%total (N) (set-fldpred-implies-fldmap2conj/L N _ _ _ _ _ _).


%theorem set-fldpred-implies-fldmap2conj
  : forall* {CM} {PM} {FM} {S} {FP}
    forall {CM2PM: clsmap2predmap CM PM}
		{DM: fldmap`domain FM S}
		{SF: set-fldpred PM FM S ([t] FP t)}
    exists {G} {F2C: fldmap2conj CM PM FM ([t] G t) PM}
    {TAS: {t} transform
          (output/expr t (FP t))
          (output/expr t (G t))}
    true.

- : set-fldpred-implies-fldmap2conj _ DM SF G F2C TAS
    <- fldmap`size-total SZ
    <- set-fldpred-implies-fldmap2conj/L _ SZ DM SF G F2C TAS.

%worlds (objvar) (set-fldpred-implies-fldmap2conj _ _ _ _ _ _).
%total { } (set-fldpred-implies-fldmap2conj _ _ _ _ _ _).


%%% Constructor Typing

constyping : clsmap -> methmap -> fldmap
    -> cxt -> env -> set -> (object -> expr) -> env -> type.

constyping/0 : constyping _ _ _ _ V set/0 ([t] lit t) V.

constyping/nn :
    fldmap`lookup FM F (ty/ nn/yes A C) ->
    set`remove S (set/1 F) SP ->
    reftyping CM MM B V0 E (result/expr RT V1) ->
    subtype CM _ RT V1 (ty/ nn/yes A C) _ V2 ->
    constyping CM MM FM B V2 SP ([t] EF t) V3 ->
  constyping CM MM FM B V0 SP ([t] seq (write (lit t) F E) (EF t)) V3.

constyping/mn :
    fldmap`lookup FM F (ty/ nn/may A C) ->
    reftyping CM MM B V0 E (result/expr RT V1) ->
    subtype CM _ RT V1 (ty/ nn/may A C) _ V2 ->
    constyping CM MM FM B V2 S ([t] EF t) V3 ->
  constyping CM MM FM B V0 SP ([t] seq (write (lit t) F E) (EF t)) V3.


constymatch* : env -> env -> clsmap -> methmap -> fldmap -> cxt -> set ->
    (object -> func) -> methty -> type.

constymatch/base :
    ty2new-reftype (ty/ nn/yes annot/unique C) RT ->
    constyping CM MM FM B Vin FS ([t] E t) Vout ->
  constymatch* Vin Vout CM MM FM B FS ([t] func/0 (E t))
    (methty/base (ty/ nn/yes annot/unique C)).

constymatch/args/shared :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
    ({x} constymatch* Vin Vout CM MM FM (B1 x) FS ([t] F t x) CT) ->
  constymatch* Vin Vout CM MM FM B0 FS ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/shared C) set/0 CT).

constymatch/args/borrow :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/borrow C)) (B1 x)) ->
    nat+set2set (s N) FS Mf ->
    set`union Min Mf Min' ->
    set`union Mout Mf Mout' ->
    ({x} constymatch* (env/ Uin Min') (env/ Uout Mout') CM MM FM (B1 x) S ([t] F t x) CT) ->
  constymatch* (env/ Uin Min) (env/ Uout Mout) CM MM FM B0 S ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/borrow C) FS CT).

constymatch/args/unique :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) ->
    clsmap`lookup CM C FFM ->
    fldmap`domain FFM FFS ->
    nat+set2set (s N) FFS Mf ->
    set`add Uin (s N) Uin' ->
    set`union Min Mf Min' ->
    ({x} constymatch* (env/ Uin' Min') Vout CM MM FM (B1 x) S ([t] F t x) CT) ->
  constymatch* (env/ Uin Min) Vout CM MM FM B0 S ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/unique C) set/0 CT).

%abbrev constymatch
  = [CM][MM][FM][S][F][CT] constymatch* empty-env empty-env CM MM FM cxt/0 S F CT.


%%% Theorems about consty

%theorem constyping-implies-typing
  : forall* {CM} {PM} {MM} {W} {C} {FM} {FS} {S} {B}
    {Vin} {Vout} {E} {PiB}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM FS}
    {FM=>S: select-nn-fields FM S}
    {B=>PiB: cxt2perm PM B PiB}
    {CTYP: constyping CM MM FM B Vin S ([t] E t) Vout}
    exists {RFP} {AF: {t} allocFields t S (RFP t)}
    {PF} {T2PF: ty2perm PM (ty/ nn/yes annot/unique C) PF}
    {TYP: {t} typing W ((obj-ne-null t) , ((RFP t) , PiB)) (E t)
          (output/exists ([t] (output/expr t (PiB , (PF t)))))}
    true.


%%% Program Typing: checking method map against prog

methmapmatch* : clsmap -> methmap -> methmap -> prog -> type.

methmapmatch/0 : methmapmatch* _ _ methmap/0 prog`map/0.

methmapmatch/U/const :
    methmapmatch* CM MM0 MM' G' ->
    clsmap`lookup CM C FM ->
    select-nn-fields FM S ->
    constymatch CM MM0 FM S FF CT ->
    methmap`fresh MM' C ->
    methmap`update MM' C (methty/arg (ty/ nn/yes _ C) _ CT) MM ->
    prog`update G' C (func/+ ([t] FF t)) G ->
  methmapmatch* CM MM0 MM G.

methmapmatch/U/meth :
    methmapmatch* CM MM0 MM' G' ->
    clsmap`fresh CM N ->
    methtymatch CM MM0 F MT ->
    methmap`fresh MM' N ->
    methmap`update MM' N MT MM ->
    prog`update G' N F G ->
  methmapmatch* CM MM0 MM G.

%abbrev methmapmatch = [CM][MM][G] methmapmatch* CM MM MM G.


%%% Theorems about methmapmatch

%theorem false-implies-progtypematch
  : forall* {W0} {W} {G}
    forall {V: void}
    exists {W-G: progtypematch* W0 W G}
    true.

%worlds (gtermvar) (false-implies-progtypematch _ _).
%total { } (false-implies-progtypematch _ _).


%theorem fresh-update-preserves-progtypematch
  : forall* {W0} {W'} {G'} {FUN} {PT} {N} {W} {G}
    forall {W'-G': progtypematch* W0 W' G'}
    {FUN-PT: proctypematch W0 FUN PT}
    {WF: progtype`fresh W' N}
    {WU: progtype`update W' N PT W}
    {GU: prog`update G' N FUN G}
    exists {W-G: progtypematch* W0 W G}
    true.

%worlds (gtermvar) (fresh-update-preserves-progtypematch _ _ _ _ _ _).
%trustme %total { } (fresh-update-preserves-progtypematch _ _ _ _ _ _).


%theorem methmapmatch-implies-progtypematch
  : forall* {CM} {MM} {G} {PM} {MM0} {W0} {W}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM=>PM: clsmap2predmap CM PM}
		{CM-MM0: clsmap-methmap CM MM0}
    {MM0=>W0: methmap2progtype CM PM MM0 W0}
    {CM-MM: clsmap-methmap CM MM}
    {MM-G: methmapmatch* CM MM0 MM G}
    {MM=>W: methmap2progtype CM PM MM W}
    exists {W-G: progtypematch* W0 W G}
    true.

- : methmapmatch-implies-progtypematch CM-CM CM2PM CM-MM0 MM0=>W0
    _ methmapmatch/0 methmap2progtype/0 progtypematch/0.

- : methmapmatch-implies-progtypematch CM-CM
    (CM2PM:clsmap2predmap CM PM)
    (CM-MM0:clsmap-methmap CM MM0)
    (MM0=>W0: methmap2progtype CM PM MM0 W0)
    (CM-MM:clsmap-methmap CM _)
    (methmapmatch/U/meth
      (MM'-G':methmapmatch* CM MM0 MM' G')
      (CMF:clsmap`fresh CM N)
      (FUN-MT: methtymatch CM MM0 FUN MT)
      (N!<MM': methmap`fresh MM' N)
      (MM'+N=MM: methmap`update MM' N MT MM)
      (G'+N=G: prog`update G' N FUN G))
    (MM=>W:methmap2progtype CM PM _ W) W-G
    <- methmap2progtype/U/m-inversion MM=>W CMF N!<MM' MM'+N=MM W' PT MM'=>W' MT=>PT W'+PT=W
    <- clsmap-methmap/U/meth-inversion CM-MM CMF N!<MM' MM'+N=MM CM-MT CM-MM'
    <- methtymatch-implies-proctypematch CM-CM CM-MM0 CM2PM MM0=>W0 CM-MT FUN-MT MT=>PT FUN-PT
    <- methmapmatch-implies-progtypematch CM-CM CM2PM CM-MM0 MM0=>W0 CM-MM'
      MM'-G' MM'=>W' W'-G'
    <- methmap2progtype-preserves-fresh MM'=>W' N!<MM' N!<W'
    <- fresh-update-preserves-progtypematch W'-G' FUN-PT N!<W' W'+PT=W G'+N=G W-G.

%worlds (gtermvar) (methmapmatch-implies-progtypematch _ _ _ _ _ _ _ _).
%total (M) (methmapmatch-implies-progtypematch _ _ _ _ _ M _ _).