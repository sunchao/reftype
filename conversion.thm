%%% Theorems about conversion between ref-typing and typing

%%% Shortcuts
%abbrev fldperm-fun
  : object -> nat -> (object -> permission) -> permission
 = [o][F][PF] unitperm (precise-exists o F ([v] PF v)).


%%% Lemmas

%theorem implies-respects-permission-eq :
    forall* {P1} {P2} {P3} {P4}
    forall  {IMP: implies P1 P2}
            {E: permission`eq P1 P3}
            {E: permission`eq P2 P4}
    exists  {IMP: implies P3 P4}
    true.

- : implies-respects-permission-eq I permission`eq/ permission`eq/ I.

%worlds () (implies-respects-permission-eq _ _ _ _).
%total  {} (implies-respects-permission-eq _ _ _ _).


%theorem false-implies-transform :
    forall* {K} {O1:output K} {O2:output K}
    forall  {F:void}
    exists  {TS: transform O1 O2}
    true.

%worlds () (false-implies-transform _ _).
%total  {} (false-implies-transform _ _).


%theorem false-implies-predmap-lookup :
    forall* {PM} {N}
    forall  {F:void}
    exists  {CJ} {PM-L: predmap`lookup PM N (conj2pred CJ)}
    true.

%worlds () (false-implies-predmap-lookup _ _ _).
%total  {} (false-implies-predmap-lookup _ _ _).


%theorem fldperm-can-lookup/false-imply :
        forall* {PM} {NN} {C} {F:nat} {G} {A}
        forall  {V:void}
        exists  {AF} {PF:clspred -> object -> permission} {CP}
                {A=>AF: annot2perm A AF}
                {F2P: nn2perm NN AF PF}
                {L: predmap`lookup PM C CP}
                {I: {o} implies (unitperm (nonlinear (G o)))
                    (unitperm
                      (nonlinear
                        (nested ((fldperm F PF) CP o) o all)))}
        true.

%worlds (objvar) (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).
%total  {} (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).



%theorem fldperm-can-lookup/L :
        forall* {CM} {PM} {FM} {F} {NN} {A} {G} {C}
        forall  {FM2G: fldmap2conj CM PM FM ([r] G r) PM}
                {FM-L: fldmap`lookup FM F (ty/ NN A C)}
        exists  {AF} {PF} {CP}
                {A2AF: annot2perm A AF}
                {FNN2P: nn2perm NN AF PF}
                {PM-L: predmap`lookup PM C CP}
                {IMP: {o} implies (unitperm (nonlinear (G o)))
                      (unitperm
                        (nonlinear
                          (nested ((fldperm F PF) CP o) o all)))}
        true.

- : fldperm-can-lookup/L (fldmap2conj/null FMP2G F<=FM=FMP)
    (fldmap`lookup/> FM->F P) AF PF CP A2AF FNN2PF PM->C IMP
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- fldmap`shift-preserves-lookup* FM->F F<=FM=FMP P2 FMP->F
    <- fldperm-can-lookup/L FMP2G FMP->F AF PF CP A2AF FNN2PF PM->C IMP.

- : fldperm-can-lookup/L (fldmap2conj/in _ FNN2P A2AF _ PM-L) 
     (fldmap`lookup/= nat`eq/) _ _ _ A2AF FNN2P PM-L
    ([o] implies/trans3
      (implies/conj2combine)
      (implies/combine
        (implies/reflexive)
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
      (implies/equiv equiv/identity)).

- : fldperm-can-lookup/L (fldmap2conj/in FM2G _ _ FM-SH _)
    (fldmap`lookup/> FM-L P) AF PF CP A2AF FNN2P PM-L
    ([o] implies/trans4
      (implies/conj2combine)
      (implies/combine 
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
        (I o))
      (implies/equiv equiv/commute)
      (implies/equiv equiv/identity))
    <- nat`plus-swap-succ P P'
    <- nat`plus-commutative P' P''
    <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
    <- fldperm-can-lookup/L FM2G FM-L' AF PF CP A2AF FNN2P PM-L I. 

- : fldperm-can-lookup/L 
    (fldmap2conj/out F2C
      (F2CF:{f} fldmap2conj _ _ _ ([r] CJ f r) _) 
      ([f] PM-U f) _ _ _ _ PM-FS) _ AF PF PD A2AF FNN2P PM-L I
    <- predmap`size-total SZ-PM
    <- predmap`fresh-update-increases-size
      SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
    <- fldmap2conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
    <- predmap`size-total SZ-PMF
    <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
    <- fldmap2conj-implies-predmap-leq F2C PMF<=PM
    <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
    <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
    <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
    <- nat`gt-anti-reflexive SZ-PM>PM F
    <- fldperm-can-lookup/false-imply F AF PF PD A2AF FNN2P PM-L I.

%worlds (objvar) (fldperm-can-lookup/L _ _ _ _ _ _ _ _ _).
%total  (FM2G) (fldperm-can-lookup/L FM2G _ _ _ _ _ _ _ _).


%theorem permission-eq-implies-equiv :
    forall* {Pi1} {Pi2}
    forall  {EQ: permission`eq Pi1 Pi2}
    exists  {EQV: equiv Pi1 Pi2}
    true.

- : permission-eq-implies-equiv permission`eq/ equiv/reflexive.

%worlds (objvar) (permission-eq-implies-equiv _ _).
%total  {} (permission-eq-implies-equiv _ _).


%%% This theorem says if we have a class predicate and we 
%%% know that this class has a field F, then we can pull out
%%% the nesting fact about F from the predicate.

%theorem fldperm-can-lookup :
        forall* {CM} {PM} {C} {FM} {F} {NN} {A} {FC} {CP}
        forall  {CM2PM: clsmap2predmap CM PM}
                {PM-L: predmap`lookup PM C CP}
                {CM-L: clsmap`lookup CM C FM}
                {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
        exists  {AF} {PF} {FCP} 
                {A2AF: annot2perm A AF}
                {FNN2P: nn2perm NN AF PF}
                {PM-L: predmap`lookup PM FC FCP}
                {IMP: {o} implies
                      (unitperm
                        (nonlinear
                          (predcall CP (predargs/1 o))))
                      (unitperm
                        (nonlinear
                          (nested ((fldperm F PF) FCP o) o all)))}
        true.

- : fldperm-can-lookup
    CM2PM PM-L CM-L FM-L AF PF CP A2AF FNN2PF PM->FC 
    ([o] implies/trans3
      (implies/equiv (EQV o))
      (implies/nonlinear
	(bimplies/trans
	  (bimplies/predcall/Y/inline)
	  (bimplies/trans
            (bimplies/predcall/+/inline o)
            (bimplies/predcall/0/inline))))
      (IMP o))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- clsmap-predmap-implies-lookup-format CM-PM PM-L _ PM-LP
      ([o] (PEQ o))
    <- ({o} permission-eq-implies-equiv (PEQ o) (EQV o))
    <- clsmap2predmap-implies-fldmap2conj CM2PM PM-LP CM-L FM2G
    <- fldperm-can-lookup/L FM2G FM-L AF PF CP A2AF FNN2PF PM->FC IMP.

%worlds (objvar) (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).
%total  {} (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).


%theorem sharedperm-can-be-duplicated :
    forall* {NN} {C} {AF} {PF} {PM} {CP}
    forall  {A2P: annot2perm annot/shared AF}
            {NN2PF: nn2perm NN AF PF}
            {PM-L: predmap`lookup PM C CP}
    exists  {DUP: {r} implies (PF CP r) ((PF CP r) , (PF CP r))}
    true.

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/yes _
    ([r] 
      (implies/trans4
        (implies/combine 
          (implies/reflexive)
          (implies/combine2conj))
        (implies/combine2conj)
        (implies/duplicate)
        (implies/combine
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))))).

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/may _
    ([r] 
      (implies/trans3
	(implies/cond-inner
	  (bimplies/reflexive)
	  (bimplies/reflexive)
	  (implies/equiv (equiv/symmetric equiv/identity))
	  (implies/trans
	    (implies/combine2conj)
	    (implies/duplicate)))
	(implies/cond-distribute)
	(implies/combine
	  (implies/cond-inner
	    (bimplies/reflexive)
	    (bimplies/reflexive)
	    (implies/reflexive)
	    (implies/conj2combine))
	  (implies/cond-inner
	    (bimplies/reflexive)
	    (bimplies/reflexive)
	    (implies/reflexive)
	    (implies/conj2combine))))).
	      
%worlds () (sharedperm-can-be-duplicated _ _ _ _).
%total  {} (sharedperm-can-be-duplicated _ _ _ _).



%% wellformed type - not borrowed

wf-ty : ty -> type.

wf-ty/unique : wf-ty (ty/ _ annot/unique _).

wf-ty/shared : wf-ty (ty/ _ annot/shared _).



%%% Lemmas for proving tRead

%theorem ref-typing-ok/read/shared :
    forall* {CM} {FM} {B} {F} {Pi} {G} {Out1}
            {XM} {E: expr} {PM} {W} {A} {C}
    forall  {T} {WF-T: wf-ty T} 
            {CM2PM: clsmap2predmap CM PM}
            {CM-L: clsmap`lookup CM C FM} 
            {FM-L: fldmap`lookup FM F T}
            {ET+XM2Out1: reftype+efxmap2output 
                CM PM B (reftype/ (ty/ nn/yes A C) reftgts/shared) XM Out1}
            {TYP: typing W (G , ((allperm null) , Pi)) E Out1}
    exists  {Out} 
            {RT+XM: reftype+efxmap2output 
                    CM PM B (reftype/ T reftgts/shared) XM Out}
            {PTYP: typing W (G , ((allperm null) , Pi)) (read E F) Out}
    true.

% (shared.shared).unique
- : ref-typing-ok/read/shared (ty/ _ annot/unique _) _ CM2PM CM->C=FM FM->F=T
    (reftype+efxmap2output/s_ XM2Pi PM->C nn2perm/yes) TYP %{=>}%
    _ (reftype+efxmap2output/us XM2Pi PM->FC=CP NN2PF) 
    (tTrans2
      (tRead1 TYP
        (letTyping/exists 
          ([r]
            (letTyping/base r
              (tTrans
                (transform/trans3
                  (transform/implies
                    (implies/equiv (equiv/symmetric equiv/associate)))
                  (transform/drop)
                  (transform/trans3
                    (transform/implies
                      (implies/trans4
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans7
                            (implies/combine
                              (implies/equiv equiv/commute)
                              (implies/reflexive))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (IMP r) implies/carve)
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/carve)
                              (implies/reflexive))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (implies/reflexive)
                              (implies/chain-implication)))
                          (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine
                          (implies/equiv (equiv/symmetric equiv/one))
                          (implies/reflexive))))
                    (transform/skolem)
                    (transform/inside [v]
                      (transform/implies
                        (implies/equiv
                          (equiv/transitive
                            (equiv/combine equiv/distribute
                              equiv/reflexive)
                            (equiv/symmetric equiv/associate)))))))
                (letTyping/exists
                  ([v] (letTyping/base null tRead)))
                (transform/inside [v] (transform/reflexive)))))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans4
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans4
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/symmetric equiv/distribute)
                        (equiv/one)
                        (equiv/symmetric equiv/identity)))
                    (implies/combine
                      (implies/equiv equiv/commute)
                      (implies/trans
                        (implies/self-implication)
                        (implies/combine-assoc-encumbered)))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans4
                        (implies/linear-modus-ponens)
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/combine
                          (implies/reflexive)
                          (implies/gen-pack-encumber v))
                        (implies/chain-implication))))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/chain-implication)
                      (implies/reflexive))))))))
        (transform/rem-unused)))
    <- fldperm-can-lookup CM2PM PM->C CM->C=FM FM->F=T
      _ _ _ _ NN2PF PM->FC=CP IMP.

% (shared.unique).unique
- : ref-typing-ok/read/shared (ty/ FAA annot/unique FC) _ CM2PM CM->C=FM FM->F=T
    (reftype+efxmap2output/us XM2Pi' PM->C nn2perm/yes) TYP
    _ (reftype+efxmap2output/us XM2Pi' PM->FC=CP NN2PF-3) 
        (tTrans2 
      (tRead1 TYP
        (letTyping/exists [r]
          (letTyping/base r
            (tTrans
              (transform/trans3
                (transform/implies
                  (implies/trans4
                    (implies/combine
                      (implies/trans7
                        (implies/combine
                          (implies/reflexive)
                          (implies/combine
                            (implies/reflexive)
                            (implies/duplicate)))
                        (implies/equiv equiv/roll3)
                        (implies/combine
                          (IMP r)
                          (implies/trans4
                            (implies/equiv (equiv/symmetric equiv/identity))
                            (implies/combine
                              (implies/equiv equiv/roll2)
                              (implies/trans3
                                (implies/self-implication)
                                (implies/equiv-encumbered
                                  (equiv/transitive
                                    (equiv/roll2)
                                    (equiv/commute))
                                  (equiv/reflexive))
                                (implies/combine-assoc-encumbered)))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (implies/reflexive)
                              (implies/linear-modus-ponens))))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/carve)
                          (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine
                          (implies/reflexive)
                          (implies/chain-implication)))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/chain-implication)
                          (implies/reflexive))))
                    (implies/combine
                      (implies/equiv (equiv/symmetric equiv/one))
                      (implies/reflexive))))
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine equiv/distribute
                          equiv/reflexive)
                        (equiv/symmetric equiv/associate))))))
              (letTyping/exists [v] (letTyping/base null tRead))
              (transform/inside [_] (transform/reflexive))))))
          (transform/trans
	(transform/inside [r]
	  (transform/inside [v]
	    (transform/implies
	      (implies/trans4
		(implies/equiv equiv/associate)
		(implies/combine
		  (implies/trans4
		    (implies/equiv
		      (equiv/transitive3
			(equiv/symmetric equiv/distribute)
			(equiv/one)
			(equiv/symmetric equiv/identity)))
		    (implies/combine
		      (implies/equiv equiv/commute)
		      (implies/trans
			(implies/self-implication)
			(implies/combine-assoc-encumbered)))
		    (implies/equiv (equiv/symmetric equiv/associate))
		    (implies/combine
		      (implies/reflexive)
		      (implies/trans4
			(implies/linear-modus-ponens)
			(implies/equiv (equiv/symmetric equiv/identity))
			(implies/combine
			  (implies/reflexive)
			  (implies/gen-pack-encumber v))
			(implies/chain-implication))))
		  (implies/reflexive))
		(implies/equiv (equiv/symmetric equiv/associate))
		(implies/combine
		  (implies/reflexive)
		  (implies/trans
		    (implies/equiv equiv/associate)
		    (implies/combine
		      (implies/chain-implication)
		      (implies/reflexive))))))))
	(transform/rem-unused)))
    <- fldperm-can-lookup CM2PM PM->C CM->C=FM FM->F=T
      _ _ _ A2AF NN2PF-3 PM->FC=CP IMP.
    
% (shared.unique).shared
- : ref-typing-ok/read/shared (ty/ FAA annot/shared FC) _ CM2PM CM->C=FM FM->F=T
    (reftype+efxmap2output/us XM2Pi' PM->C nn2perm/yes) TYP
    _ (reftype+efxmap2output/s_ XM2Pi' PM->FC=CP NN2PF-3) 
    (tTrans2 
      (tRead1 TYP
        (letTyping/exists [r]
          (letTyping/base r
            (tTrans
              (transform/trans3
                (transform/implies
                  (implies/trans4
                    (implies/combine
                      (implies/trans7
                        (implies/combine
                          (implies/reflexive)
                          (implies/combine
                            (implies/reflexive)
                            (implies/duplicate)))
                        (implies/equiv equiv/roll3)
                        (implies/combine
                          (IMP r)
                          (implies/trans4
                            (implies/equiv (equiv/symmetric equiv/identity))
                            (implies/combine
                              (implies/equiv equiv/roll2)
                              (implies/trans3
                                (implies/self-implication)
                                (implies/equiv-encumbered
                                  (equiv/transitive
                                    (equiv/roll2)
                                    (equiv/commute))
                                  (equiv/reflexive))
                                (implies/combine-assoc-encumbered)))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (implies/reflexive)
                              (implies/linear-modus-ponens))))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/carve)
                          (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine
                          (implies/reflexive)
                          (implies/chain-implication)))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/chain-implication)
                          (implies/reflexive))))
                    (implies/combine
                      (implies/equiv (equiv/symmetric equiv/one))
                      (implies/reflexive))))
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine equiv/distribute
                          equiv/reflexive)
                        (equiv/symmetric equiv/associate))))))
              (letTyping/exists [v] (letTyping/base null tRead))
              (transform/inside [_] (transform/reflexive))))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans4
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans5
                    (implies/equiv (equiv/symmetric equiv/distribute))
                    (implies/equiv equiv/one)
                    (implies/combine implies/reflexive (IMP2 v))
                    (implies/equiv equiv/roll2)
                    (implies/combine
                      (implies/reflexive) (implies/pack v)))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens) implies/reflexive)))))))
        (transform/rem-unused)))
    <- fldperm-can-lookup CM2PM PM->C CM->C=FM FM->F=T
      _ _ _ A2AF NN2PF-3 PM->FC=CP IMP
    <- sharedperm-can-be-duplicated annot2perm/shared NN2PF-3 PM->FC=CP
      IMP2.

% (shared.shared).shared
- : ref-typing-ok/read/shared (ty/ FAA annot/shared FC) _ CM2PM CM->C=FM FM->F=T
    (reftype+efxmap2output/s_ XM2Pi' PM->C nn2perm/yes) TYP
    _ (reftype+efxmap2output/s_ XM2Pi' PM->FC=CP NN2PF-3) 
    (tTrans2
      (tRead1 TYP 
        (letTyping/exists 
          ([r]
            (letTyping/base r
              (tTrans
                (transform/trans3
                  (transform/implies
                    (implies/equiv (equiv/symmetric equiv/associate)))
                  (transform/drop)
                  (transform/trans3
                    (transform/implies
                      (implies/trans4
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans7
                            (implies/combine
                              (implies/equiv equiv/commute)
                              (implies/reflexive))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (IMP r) implies/carve)
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/carve)
                              (implies/reflexive))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (implies/reflexive)
                              (implies/chain-implication)))
                          (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine
                          (implies/equiv (equiv/symmetric equiv/one))
                          (implies/reflexive))))
                    (transform/skolem)
                    (transform/inside [v]
                      (transform/implies
                        (implies/equiv
                          (equiv/transitive
                            (equiv/combine equiv/distribute
                              equiv/reflexive)
                            (equiv/symmetric equiv/associate)))))))
                (letTyping/exists
                  ([v] (letTyping/base null tRead)))
                (transform/inside [v] (transform/reflexive)))))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans4
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans5
                    (implies/equiv (equiv/symmetric equiv/distribute))
                    (implies/equiv equiv/one)
                    (implies/combine implies/reflexive (IMP2 v))
                    (implies/equiv equiv/roll2)
                    (implies/combine
                      (implies/reflexive) (implies/pack v)))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens) implies/reflexive)))))))
        (transform/rem-unused)))
    <- fldperm-can-lookup CM2PM PM->C CM->C=FM FM->F=T
      _ _ _ A2AF NN2PF-3 PM->FC=CP IMP
    <- sharedperm-can-be-duplicated annot2perm/shared NN2PF-3 PM->FC=CP
      IMP2.

%worlds () (ref-typing-ok/read/shared _ _ _ _ _ _ _ _ _ _).
%total  {} (ref-typing-ok/read/shared _ _ _ _ _ _ _ _ _ _).


%theorem set2inner-efxmap-implies-filter-non-consume/inner/L :
    forall* {S} {M}
    forall  {N} {SZ: set`size S N} {S+X=>M: set2inner-efxmap S efx/write M}
    exists  {FNCI: filter-non-consume/inner M M}
    true.

- : set2inner-efxmap-implies-filter-non-consume/inner/L _ _
    set2inner-efxmap/0 filter-non-consume/inner/0.

- : set2inner-efxmap-implies-filter-non-consume/inner/L 
    (s N) (set`size/+ SZ) 
    (set2inner-efxmap/+ S2M) (filter-non-consume/inner/write U FI SH-M=MS)
    <- set`shift-total SH-S=SS
    <- set`shift-preserves-size SZ SH-S=SS SZ-SS
    <- inner-efxmap`shift-total SH-M=MS
    <- shift-preserves-set2inner-efxmap S2M SH-S=SS SH-M=MS SS2MS
    <- set2inner-efxmap-implies-filter-non-consume/inner/L N SZ-SS SS2MS FI
    <- inner-efxmap`shift-implies-update SH-M=MS U.
      
%worlds () (set2inner-efxmap-implies-filter-non-consume/inner/L _ _ _ _).
%total (N) (set2inner-efxmap-implies-filter-non-consume/inner/L N _ _ _).


%theorem set2inner-efxmap-implies-filter-non-consume/inner:
    forall* {S} {M}
    forall  {S+X=>M: set2inner-efxmap S efx/write M}
    exists  {FNCI: filter-non-consume/inner M M}
    true. 

- : set2inner-efxmap-implies-filter-non-consume/inner S+X=>M FNCI
    <- set`size-total SZ
    <- set2inner-efxmap-implies-filter-non-consume/inner/L _ SZ S+X=>M FNCI.

%worlds () (set2inner-efxmap-implies-filter-non-consume/inner _ _).
%total  {} (set2inner-efxmap-implies-filter-non-consume/inner _ _).


%theorem set+nat2tgtmap-implies-filter-non-consume :
    forall* {S} {F} {GM} {XM}
    forall  {N} {SZ: set`size S N} {S+F=>GM: set+nat2tgtmap S F GM}
            {GM+W=>XM: tgtmap2efxmap GM efx/write XM}
    exists  {FNC: filter-non-consume XM XM}
    true.

- : set+nat2tgtmap-implies-filter-non-consume _ _ 
    set+nat2tgtmap/0 tgtmap2efxmap/0 filter-non-consume/0.

- : set+nat2tgtmap-implies-filter-non-consume
    (s N) (set`size/+ SZ) (set+nat2tgtmap/+ S+F=>GM)
    (tgtmap2efxmap/+ GM=>XM (set2inner-efxmap/+ set2inner-efxmap/0)) %{=>}% 
    (filter-non-consume/+ XM-U FNC
      (filter-non-consume/inner/write
        inner-efxmap`update/0 filter-non-consume/inner/0 inner-efxmap`shift/0)
      SH-XM)
    <- set`shift-total SH-S
    <- tgtmap`shift-total SH-GM
    <- efxmap`shift-total SH-XM
    <- shift-preserves-set+nat2tgtmap S+F=>GM SH-S SH-GM SS+F=>GMS
    <- shift-preserves-tgtmap2efxmap GM=>XM SH-GM SH-XM GMS=>XMS
    <- set`shift-preserves-size SZ SH-S SZS
    <- set+nat2tgtmap-implies-filter-non-consume _ SZS SS+F=>GMS GMS=>XMS FNC
    <- efxmap`shift-implies-update SH-XM XM-U.

%worlds () (set+nat2tgtmap-implies-filter-non-consume _ _ _ _ _).
%trustme %total (N) (set+nat2tgtmap-implies-filter-non-consume N _ _ _ _).


%{%
  How to prove:
  1, by indiction hypothesis we can type check E, and
     have effects XM1, and unique target (reftgts/unique S GM);
  2, with read-type/uu we have S + F => GMS, and GM U GMS = GMP, 
     and GMP + efx/write => XM2, and XM1 U XM2 = XM;
  3, from efxmap`remove-tgtmap XM GM XM3 XM4, we can have XM3 U XM4 = XM;
  4, we have GMS <= XM, and since we know 
     domain(GMS) /\ domain(GM) = \emptyset, therefore GMS <= XM1;
%}%

%%% THis theorem cannot be proved since leq/0 and disjoint/L.

%theorem efxmap`leq-disjoint-implies-empty :
    forall* {M1} {M2}
    forall  {L: efxmap`leq M1 M2}
            {D: efxmap`disjoint M1 M2}
    exists  {E: efxmap`eq M1 efxmap/0}
    true.

- : efxmap`leq-disjoint-implies-empty efxmap`leq/0 _ efxmap`eq/.
   
- : efxmap`leq-disjoint-implies-empty
    (efxmap`leq/> L P1) (efxmap`disjoint/< D P2) E
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- efxmap`false-implies-eq F E.

- : efxmap`leq-disjoint-implies-empty
    (efxmap`leq/= _ _ nat`eq/) (efxmap`disjoint/< D P) E
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-eq F E.

- : efxmap`leq-disjoint-implies-empty
    (efxmap`leq/> L P1) (efxmap`disjoint/> D P2) E2
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- efxmap`map/+-preserves-eq EQ inner-efxmap`eq/ efxmap`eq/ MEQ
    <- efxmap`leq-respects-eq L MEQ efxmap`eq/ LP
    <- efxmap`leq-disjoint-implies-empty LP D E
    <- efxmap`eq-symmetric E EP
    <- efxmap`eq-contradiction EP F
    <- efxmap`false-implies-eq F E2.

- : efxmap`leq-disjoint-implies-empty
    (efxmap`leq/= _ _ nat`eq/) (efxmap`disjoint/> D P) E
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-eq F E.

%worlds () (efxmap`leq-disjoint-implies-empty _ _ _).
%total (L) (efxmap`leq-disjoint-implies-empty L _ _).


%theorem ref-typing-ok/read/unique/L2L :
    forall* {XM1} {XM2} {XM3} {XM}
    forall  {N1} {SZ: efxmap`size XM1 N1} 
            {N2} {SZ: efxmap`size XM2 N2}
            {XM1UXM2=XM: efxmap`join XM1 XM2 XM}
            {XM2^XM3: efxmap`disjoint XM2 XM3}
            {XM3<=XM: efxmap`leq XM3 XM}
    exists  {XM3<=XM1: efxmap`leq XM3 XM1}
    true.

- : ref-typing-ok/read/unique/L2L _ _ _ _ efxmap`join/L D LE LE2
    <- efxmap`disjoint-symmetric D DP
    <- efxmap`leq-disjoint-implies-empty LE DP E
    <- efxmap`leq-reflexive _ LE3
    <- efxmap`leq-respects-eq LE3 efxmap`eq/ E LE2.

- : ref-typing-ok/read/unique/L2L _ _ _ _ efxmap`join/R _ LE LE.

- : ref-typing-ok/read/unique/L2L _ _ _ _ _ efxmap`disjoint/R _ efxmap`leq/0.

- : ref-typing-ok/read/unique/L2L _ _ _ _
    (efxmap`join/< _ P1) (efxmap`disjoint/< _ P2)
    (efxmap`leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- efxmap`false-implies-leq F LE.

% SHP and SH2 unified.
- : ref-typing-ok/read/unique/L2L _ (efxmap`size/+ SZ)
    _ (efxmap`size/+ SZ2)
    (efxmap`join/< J P1) D (efxmap`leq/> LE P2) (efxmap`leq/> LE3P P2)
    <- nat`plus-swap-succ P1 P1P
    <- nat`plus-commutative P1P P1S
    <- efxmap`shift-total SH
    <- efxmap`shift-preserves-join J SH (efxmap`shift/+ P1S) _ SHP JP
    <- nat`plus-swap-succ P2 P2P
    <- nat`plus-commutative P2P P2S
    <- efxmap`shift-preserves-leq LE (efxmap`shift/+ P2S) SHP LE2
    <- efxmap`shift-preserves-size SZ SH SZK
    <- ref-typing-ok/read/unique/L2L _ SZK _ (efxmap`size/+ SZ2) JP D LE2 LE3
    <- efxmap`shift-preserves-leq-converse LE3 (efxmap`shift/+ P2S) SH LE3P.

- : ref-typing-ok/read/unique/L2L
    _ (efxmap`size/+ SZ) _ (efxmap`size/+ SZ2)
    (efxmap`join/< J P1) (efxmap`disjoint/> D P2)
    (efxmap`leq/= LE M-LE nat`eq/) (efxmap`leq/= LEE M-LE nat`eq/)
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- efxmap`map/+-preserves-eq EQ inner-efxmap`eq/ efxmap`eq/ MEQ
    <- efxmap`join-respects-eq J efxmap`eq/ MEQ efxmap`eq/ JP
    <- ref-typing-ok/read/unique/L2L _ SZ _ (efxmap`size/+ SZ2) JP D LE LEE.

- : ref-typing-ok/read/unique/L2L 
    _ (efxmap`size/+ SZ) _ (efxmap`size/+ SZ2)
    (efxmap`join/> J P1) (efxmap`disjoint/< D P2) (efxmap`leq/> LE P3) LEE2
    <- nat`plus-right-cancels P2 P3 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- efxmap`map/+-preserves-eq EQ inner-efxmap`eq/ efxmap`eq/ MEQ
    <- efxmap`disjoint-respects-eq D efxmap`eq/ MEQ DP
    <- ref-typing-ok/read/unique/L2L _ (efxmap`size/+ SZ) _ SZ2 J DP LE LEE
    <- nat`plus-swap-succ P3 P3S
    <- nat`plus-commutative P3S P3P
    <- nat`plus-swap-succ P1 P1S
    <- nat`plus-commutative P1S P1P
    <- efxmap`shift-preserves-leq
      LEE (efxmap`shift/+ P3P) (efxmap`shift/+ P1P) LEE2.

- : ref-typing-ok/read/unique/L2L _ _ _ _
    (efxmap`join/= _ _ nat`eq/) (efxmap`disjoint/< _ P)
    (efxmap`leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-leq F LE.

- : ref-typing-ok/read/unique/L2L _ _ _ _
    (efxmap`join/= _ _ nat`eq/) (efxmap`disjoint/> _ P)
    (efxmap`leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-leq F LE.

- : ref-typing-ok/read/unique/L2L _ _ _ _
    (efxmap`join/> _ _) (efxmap`disjoint/< _ P)
    (efxmap`leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-leq F LE.

- : ref-typing-ok/read/unique/L2L _ _ _ _
    (efxmap`join/> _ _) (efxmap`disjoint/> _ P) 
    (efxmap`leq/= _ _ nat`eq/) LE
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-anti-reflexive GT F
    <- efxmap`false-implies-leq F LE.

- : ref-typing-ok/read/unique/L2L _ _ _ _
    (efxmap`join/= _ _ nat`eq/) (efxmap`disjoint/> _ P1) 
    (efxmap`leq/> _ P2) LE
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- efxmap`false-implies-leq F LE.

- : ref-typing-ok/read/unique/L2L
    _ (efxmap`size/+ SZ) _ (efxmap`size/+ SZ2)
    (efxmap`join/= J M-J nat`eq/) (efxmap`disjoint/< D P1) 
    (efxmap`leq/> LE P2) (efxmap`leq/> LEP P2)
    <- nat`plus-right-cancels P1 P2 nat`eq/ nat`eq/ EQ1
    <- nat`succ-cancels EQ1 EQ
    <- efxmap`map/+-preserves-eq EQ inner-efxmap`eq/ efxmap`eq/ MEQ
    <- efxmap`disjoint-respects-eq D efxmap`eq/ MEQ DP
    <- ref-typing-ok/read/unique/L2L _ SZ _ SZ2 J DP LE LEP.

- : ref-typing-ok/read/unique/L2L _ _ _ _
    (efxmap`join/> _ _) (efxmap`disjoint/> _ P1) (efxmap`leq/> _ P2) LE
    <- nat`plus-implies-gt P1 nat`eq/ GT1
    <- nat`plus-implies-gt P2 nat`eq/ GT2
    <- nat`gt-anti-symmetric GT1 GT2 F
    <- efxmap`false-implies-leq F LE.

%worlds () (ref-typing-ok/read/unique/L2L _ _ _ _ _ _ _ _).
%total {N1 N2} (ref-typing-ok/read/unique/L2L N1 _ N2 _ _ _ _ _).


% this theorem should be in library.
    
%theorem ref-typing-ok/read/unique/L2 :
    forall* {XM1} {XM2} {XM3} {XM}
    forall  {XM1UXM2=XM: efxmap`join XM1 XM2 XM}
            {XM2^XM3: efxmap`disjoint XM2 XM3}
            {XM3<=XM: efxmap`leq XM3 XM}
    exists  {XM3<=XM1: efxmap`leq XM3 XM1}
    true.

- : ref-typing-ok/read/unique/L2 U D LE LE2
    <- efxmap`size-total SZ1
    <- efxmap`size-total SZ2
    <- ref-typing-ok/read/unique/L2L _ SZ1 _ SZ2 U D LE LE2.

%worlds () (ref-typing-ok/read/unique/L2 _ _ _ _).
%total  {} (ref-typing-ok/read/unique/L2 _ _ _ _).


% this lemma is ugly.

%theorem ref-typing-ok/read/unique/L1 :
    forall* {GM} {GMP} {GMS} {XMS} {XM1} {XM} {XM3} {XM4}
    forall  {GM^GMP: tgtmap`disjoint GM GMP}
            {GM+GMP=GMS: tgtmap`join GM GMP GMS}
            {GMS=>XMS: tgtmap2efxmap GMS efx/write XMS}
            {XM1UXMS=XM: efxmap`join XM1 XMS XM}
            {XM3UXM4=XM: efxmap`join XM3 XM4 XM}
            {XM4=>GM: efxmap2tgtmap XM4 GM}
    exists  {XMP} {GMP=>XMP: tgtmap2efxmap GMP efx/write XMP}
            {XMP<=XM3: efxmap`leq XMP XM3}
    true.

- : ref-typing-ok/read/unique/L1 GM^GMP GMUGMP=GMS
    GMS=>XMS XM1UXMS=XM XM3UXM4=XM XM4=>GM %{=>}% XMS2 GMP=>XMS2 XMS2<=XM3
    <- tgtmap2efxmap-preserves-disjoint-join
      GMS=>XMS GM^GMP GMUGMP=GMS XMS1 XMS2
      GM=>XMS1 GMP=>XMS2 XMS1^XMS2 XMS1UXMS2=XMS
    <- tgtmap`domain-total DM-GM=S4 
    <- tgtmap`domain-total DM-GMP=SS2
    <- tgtmap`domain-preserves-disjoint GM^GMP DM-GM=S4 DM-GMP=SS2 S4^SS2
    <- efxmap2tgtmap-preserves-domain-converse XM4=>GM DM-GM=S4 DM-XM4=S4
    <- tgtmap2efxmap-preserves-domain GMP=>XMS2 DM-GMP=SS2 DM-XMS2=SS2
    <- efxmap`domain-preserves-disjoint-converse
      S4^SS2 DM-XM4=S4 DM-XMS2=SS2 XM4^XMS2
    <- efxmap`join-implies-leq XMS1UXMS2=XMS _ XMS2<=XMS
    <- efxmap`join-implies-leq XM1UXMS=XM _ XMS<=XM
    <- efxmap`leq-transitive XMS2<=XMS XMS<=XM XMS2<=XM
    <- ref-typing-ok/read/unique/L2 XM3UXM4=XM XM4^XMS2 XMS2<=XM XMS2<=XM3.

%worlds () (ref-typing-ok/read/unique/L1 _ _ _ _ _ _ _ _ _).
%total  {} (ref-typing-ok/read/unique/L1 _ _ _ _ _ _ _ _ _).


%theorem ref-typing-ok/read/unique/L3L :
    forall* {S} {M}
    forall  {S=>M: set2inner-efxmap S efx/write M}
    exists  {FNCI: filter-non-consume/inner M M}
    true.

- : ref-typing-ok/read/unique/L3L set2inner-efxmap/0
  filter-non-consume/inner/0.

- : ref-typing-ok/read/unique/L3L (set2inner-efxmap/+ S=>M)
    (filter-non-consume/inner/write U FNCI SH)
    <- ref-typing-ok/read/unique/L3L S=>M FFF
    <- inner-efxmap`shift-total SH
    <- shift-preserves-filter-non-consume/inner FFF SH SH FNCI
    <- inner-efxmap`shift-implies-update SH U.

%worlds () (ref-typing-ok/read/unique/L3L _ _).
%total (T) (ref-typing-ok/read/unique/L3L T _).


%theorem ref-typing-ok/read/unique/L3 :
    forall* {GM} {XM}
    forall  {GM=>XM: tgtmap2efxmap GM efx/write XM}
    exists  {FNC: filter-non-consume XM XM}
    true.

- : ref-typing-ok/read/unique/L3 tgtmap2efxmap/0 filter-non-consume/0.

- : ref-typing-ok/read/unique/L3
    (tgtmap2efxmap/+ GM=>XM S=>M) (filter-non-consume/+ U FNC FNCI SH)
    <- ref-typing-ok/read/unique/L3 GM=>XM FNCP
    <- ref-typing-ok/read/unique/L3L S=>M FNCI
    <- efxmap`shift-total SH
    <- shift-preserves-filter-non-consume FNCP SH SH FNC
    <- efxmap`shift-implies-update SH U.

%worlds () (ref-typing-ok/read/unique/L3 _ _).
%total (T) (ref-typing-ok/read/unique/L3 T _).


%theorem ref-typing-ok/read/unique :
    forall* {CM} {FM} {B} {F} {Pi} {G} {Out1} {GS} {GMP}
            {XM1} {XM} {E: expr} {PM} {W} {A} {C} {S} {GM} {GMS} {XMS}
    forall  {T} {WF-T: wf-ty T} 
            {CM2PM: clsmap2predmap CM PM}
            {CM-L: clsmap`lookup CM C FM} 
            {FM-L: fldmap`lookup FM F T}
            {ET+XM2Out1: reftype+efxmap2output 
                CM PM B (reftype/ (ty/ nn/yes A C) 
			  (reftgts/unique S GM)) XM1 Out1}
            {TYP: typing W (G , ((allperm null) , Pi)) E Out1}
            {DM-GM: tgtmap`domain GM GS} {S^GS: set`disjoint S GS}
            {S+F=GMP: set+nat2tgtmap S F GMP} 
            {GM+GMP=GMS: tgtmap`join GM GMP GMS}
            {GMS=>XMS: tgtmap2efxmap GMS efx/write XMS}
            {XM1UXMS=XM: efxmap`join XM1 XMS XM}
    exists  {Out} 
            {RT+XM: reftype+efxmap2output 
                    CM PM B (reftype/ T (reftgts/unique set/0 GMS)) XM Out}
            {PTYP: typing W (G , ((allperm null) , Pi)) (read E F) Out}
    true.

- : ref-typing-ok/read/unique T WF-T CM2PM CM-L FM-L
    (reftype+efxmap2output/uu GM=>Pi is-tgtmap-empty/false
      ([o] S=>GF o) XM4=>Pi4 XM3=>Pi3 XM/GM=XM3+XM4 PM->C NN=>PF)
    TYP DM-GM=GS S^GS S+F=>GMP GMUGMP=GMS GMS=>XMS XM1UXMS=XM _
    _ PTYP
    <- set+nat2tgtmap-implies-domain S+F=>GMP DM-GMP=S
    <- tgtmap`domain-preserves-disjoint-converse
      S^GS DM-GMP=S DM-GM=GS GMP^GM
    <- tgtmap`disjoint-symmetric GMP^GM GM^GMP
    <- efxmap`remove-tgtmap-implies-join XM/GM=XM3+XM4 XM3UXM4=XM
    <- tgtmap`join-implies-leq GMUGMP=GMS GM<=GMS _
    <- tgtmap2efxmap-implies-tgtmap-leq-efxmap GMS=>XMS GMS<=XMS
    <- efxmap`join-implies-leq XM1UXMS=XM _ XMS<=XM
    <- tgtmap-leq-efxmap-left-transitive GMS<=XMS GM<=GMS GM<=XMS
    <- tgtmap-leq-efxmap-right-transitive GM<=XMS XMS<=XM GM<=XM
    <- efxmap`remove-tgtmap-implies-efxmap2tgtmap 
      XM/GM=XM3+XM4 GM<=XM XM4=>GM
    <- ref-typing-ok/read/unique/L1 GM^GMP GMUGMP=GMS GMS=>XMS 
      XM1UXMS=XM XM3UXM4=XM XM4=>GM XMP GMP=>XMP XMP<=XM3.


%theorem ref-typing-ok : 
    forall* {L1} {L2} {CM} {MM} {B}
            {T} {XM} {E: expr} {PM} {W} 
    forall  {CM-CM: clsmap-clsmap CM CM}
            {CM-MM: clsmap-methmap CM MM}
            {CM-B:  clsmap-cxt CM B}
            {CM2PM: clsmap2predmap CM PM}
            {R-TYP: ref-typing L1 CM MM B E (out/expr T XM) L2}
    exists  {Pin} {XM2Pin: efxmap2perm CM PM B XM Pin}
            {G} {B2G: cxt2facts PM B G}
            {Out} {XM2Out: reftype+efxmap2output CM PM B T XM Out}
            {P-TYP: typing W (G , ((allperm null) , Pin)) E Out}
    true.