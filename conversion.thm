%%% Theorems about conversion between reftyping and typing
%%% $Id$


%%% Shortcuts
%abbrev fldperm-fun
  : object -> nat -> (object -> permission) -> permission
 = [o][F][PF] unitperm (precise-exists o F ([v] PF v)).


%%% Lemmas

%theorem implies-respects-permission-eq :
    forall* {P1} {P2} {P3} {P4}
    forall  {IMP: implies P1 P2}
            {E: permission`eq P1 P3}
            {E: permission`eq P2 P4}
    exists  {IMP: implies P3 P4}
    true.

- : implies-respects-permission-eq I permission`eq/ permission`eq/ I.

%worlds () (implies-respects-permission-eq _ _ _ _).
%total  {} (implies-respects-permission-eq _ _ _ _).


%theorem false-implies-transform :
    forall* {K} {O1:output K} {O2:output K}
    forall  {F:void}
    exists  {TS: transform O1 O2}
    true.

%worlds () (false-implies-transform _ _).
%total  {} (false-implies-transform _ _).


%theorem false-implies-predmap-lookup :
    forall* {PM} {N}
    forall  {F:void}
    exists  {CJ} {PM-L: predmap`lookup PM N (conj2pred CJ)}
    true.

%worlds () (false-implies-predmap-lookup _ _ _).
%total  {} (false-implies-predmap-lookup _ _ _).


%theorem fldperm-can-lookup/false-imply :
    forall* {PM} {NN} {C} {F:nat} {G} {A}
    forall  {V:void}
    exists  {AF} {PF:clspred -> object -> permission} {CP}
            {A=>AF: annot2perm A AF}
            {F2P: nn2perm NN AF PF}
            {L: predmap`lookup PM C CP}
            {I: {o} implies (unitperm (nonlinear (G o)))
                (unitperm
                  (nonlinear
                    (nested ((fldperm F PF) CP o) o all)))}
    true.

%worlds (objvar) (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).
%total  {} (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).


%theorem fldperm-can-lookup/L :
    forall* {CM} {PM} {FM} {F} {NN} {A} {G} {C}
    forall  {FM2G: fldmap2conj CM PM FM ([r] G r) PM}
            {FM-L: fldmap`lookup FM F (ty/ NN A C)}
    exists  {AF} {PF} {CP}
            {A2AF: annot2perm A AF}
            {FNN2P: nn2perm NN AF PF}
            {PM-L: predmap`lookup PM C CP}
            {IMP: {o} implies (unitperm (nonlinear (G o)))
                  (unitperm
                    (nonlinear
                      (nested ((fldperm F PF) CP o) o all)))}
    true.

- : fldperm-can-lookup/L (fldmap2conj/null FMP2G F<=FM=FMP)
    (fldmap`lookup/> FM->F P) AF PF CP A2AF FNN2PF PM->C IMP
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- fldmap`shift-preserves-lookup* FM->F F<=FM=FMP P2 FMP->F
    <- fldperm-can-lookup/L FMP2G FMP->F AF PF CP A2AF FNN2PF PM->C IMP.

- : fldperm-can-lookup/L (fldmap2conj/in _ FNN2P A2AF _ PM-L) 
     (fldmap`lookup/= nat`eq/) _ _ _ A2AF FNN2P PM-L
    ([o] implies/trans3
      (implies/conj2combine)
      (implies/combine
        (implies/reflexive)
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
      (implies/equiv equiv/identity)).

- : fldperm-can-lookup/L (fldmap2conj/in FM2G _ _ FM-SH _)
    (fldmap`lookup/> FM-L P) AF PF CP A2AF FNN2P PM-L
    ([o] implies/trans4
      (implies/conj2combine)
      (implies/combine 
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
        (I o))
      (implies/equiv equiv/commute)
      (implies/equiv equiv/identity))
    <- nat`plus-swap-succ P P'
    <- nat`plus-commutative P' P''
    <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
    <- fldperm-can-lookup/L FM2G FM-L' AF PF CP A2AF FNN2P PM-L I. 

- : fldperm-can-lookup/L 
    (fldmap2conj/out F2C
      (F2CF:{f} fldmap2conj _ _ _ ([r] CJ f r) _) 
      ([f] PM-U f) _ _ _ _ PM-FS) _ AF PF PD A2AF FNN2P PM-L I
    <- predmap`size-total SZ-PM
    <- predmap`fresh-update-increases-size
      SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
    <- fldmap2conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
    <- predmap`size-total SZ-PMF
    <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
    <- fldmap2conj-implies-predmap-leq F2C PMF<=PM
    <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
    <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
    <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
    <- nat`gt-anti-reflexive SZ-PM>PM F
    <- fldperm-can-lookup/false-imply F AF PF PD A2AF FNN2P PM-L I.

%worlds (objvar) (fldperm-can-lookup/L _ _ _ _ _ _ _ _ _).
%total  (FM2G) (fldperm-can-lookup/L FM2G _ _ _ _ _ _ _ _).


%%% This theorem says if we have a class predicate and we 
%%% know that this class has a field F, then we can pull out
%%% the nesting fact about F from the predicate.

%theorem fldperm-can-lookup :
    forall* {CM} {PM} {C} {FM} {F} {NN} {A} {FC} {CP}
    forall  {CM2PM: clsmap2predmap CM PM}
            {PM-L: predmap`lookup PM C CP}
            {CM-L: clsmap`lookup CM C FM}
            {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    exists  {AF} {PF} {FCP} 
            {A2AF: annot2perm A AF}
            {FNN2P: nn2perm NN AF PF}
            {PM-L: predmap`lookup PM FC FCP}
            {IMP: {o} implies
                  (unitperm
                    (nonlinear
                      (predcall CP (predargs/1 o))))
                  (unitperm
                    (nonlinear
                      (nested ((fldperm F PF) FCP o) o all)))}
    true.

- : fldperm-can-lookup
    CM2PM PM-L CM-L FM-L AF PF CP A2AF FNN2PF PM->FC 
    ([o] implies/trans3
      (implies/equiv (EQV o))
      (implies/nonlinear
        (bimplies/trans
          (bimplies/predcall/Y/inline)
          (bimplies/trans
            (bimplies/predcall/+/inline o)
            (bimplies/predcall/0/inline))))
      (IMP o))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- clsmap-predmap-implies-lookup-format CM-PM PM-L _ PM-LP
      ([o] (PEQ o))
    <- ({o} permission-eq-implies-equiv (PEQ o) (EQV o))
    <- clsmap2predmap-implies-fldmap2conj CM2PM PM-LP CM-L FM2G
    <- fldperm-can-lookup/L FM2G FM-L AF PF CP A2AF FNN2PF PM->FC IMP.

%worlds (objvar) (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).
%total  {} (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).


%theorem sharedperm-can-be-duplicated :
    forall* {NN} {C} {AF} {PF} {PM} {CP}
    forall  {A2P: annot2perm annot/shared AF}
            {NN2PF: nn2perm NN AF PF}
            {PM-L: predmap`lookup PM C CP}
    exists  {IMP: {r} implies (PF CP r) ((PF CP r) , (PF CP r))}
    true.

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/yes _
    ([r] (implies/trans4
           (implies/combine 
          (implies/reflexive)
             (implies/combine2conj))
           (implies/combine2conj)
           (implies/duplicate)
           (implies/combine
             (implies/trans
               (implies/conj2combine)
               (implies/combine
                 (implies/reflexive)
                 (implies/conj2combine)))
             (implies/trans
               (implies/conj2combine)
               (implies/combine
                 (implies/reflexive)
                 (implies/conj2combine)))))).

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/may _
    ([r] (implies/trans3
           (implies/cond-inner
             (bimplies/reflexive)
             (bimplies/reflexive)
             (implies/equiv (equiv/symmetric equiv/identity))
             (implies/trans
               (implies/combine2conj)
               (implies/duplicate)))
           (implies/cond-distribute)
           (implies/combine
             (implies/cond-inner
               (bimplies/reflexive)
               (bimplies/reflexive)
               (implies/reflexive)
               (implies/conj2combine))
             (implies/cond-inner
               (bimplies/reflexive)
               (bimplies/reflexive)
               (implies/reflexive)
               (implies/conj2combine))))).
	      
%worlds () (sharedperm-can-be-duplicated _ _ _ _).
%total  {} (sharedperm-can-be-duplicated _ _ _ _).