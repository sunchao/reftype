%%% Theorems about conversion between ref-typing and typing

%%% Shortcuts
%abbrev fldperm-fun
  : object -> nat -> (object -> permission) -> permission
 = [o][F][PF] unitperm (precise-exists o F ([v] PF v)).


%%% Lemmas

%theorem implies-respects-permission-eq :
    forall* {P1} {P2} {P3} {P4}
    forall  {IMP: implies P1 P2}
            {E: permission`eq P1 P3}
            {E: permission`eq P2 P4}
    exists  {IMP: implies P3 P4}
    true.

- : implies-respects-permission-eq I permission`eq/ permission`eq/ I.

%worlds () (implies-respects-permission-eq _ _ _ _).
%total  {} (implies-respects-permission-eq _ _ _ _).


%theorem false-implies-transform :
    forall* {K} {O1:output K} {O2:output K}
    forall  {F:void}
    exists  {TS: transform O1 O2}
    true.

%worlds () (false-implies-transform _ _).
%total  {} (false-implies-transform _ _).


%theorem false-implies-predmap-lookup :
    forall* {PM} {N}
    forall  {F:void}
    exists  {CJ} {PM-L: predmap`lookup PM N (conj2pred CJ)}
    true.

%worlds () (false-implies-predmap-lookup _ _ _).
%total  {} (false-implies-predmap-lookup _ _ _).


%theorem fldperm-can-lookup/false-imply :
        forall* {PM} {NN} {C} {F:nat} {G} {A}
        forall  {V:void}
        exists  {AF} {PF:clspred -> object -> permission} {CP}
                {A=>AF: annot2perm A AF}
                {F2P: nn2perm NN AF PF}
                {L: predmap`lookup PM C CP}
                {I: {o} implies (unitperm (nonlinear (G o)))
                    (unitperm
                      (nonlinear
                        (nested ((fldperm F PF) CP o) o all)))}
        true.

%worlds (objvar) (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).
%total  {} (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).




%theorem fldperm-can-lookup/L :
        forall* {CM} {PM} {FM} {F} {NN} {A} {G} {C}
        forall  {FM2G: fldmap2conj CM PM FM ([r] G r) PM}
                {FM-L: fldmap`lookup FM F (ty/ NN A C)}
        exists  {AF} {PF} {CP}
                {A2AF: annot2perm A AF}
                {FNN2P: nn2perm NN AF PF}
                {PM-L: predmap`lookup PM C CP}
                {IMP: {o} implies (unitperm (nonlinear (G o)))
                      (unitperm
                        (nonlinear
                          (nested ((fldperm F PF) CP o) o all)))}
        true.

- : fldperm-can-lookup/L (fldmap2conj/null FMP2G F<=FM=FMP)
    (fldmap`lookup/> FM->F P) AF PF CP A2AF FNN2PF PM->C IMP
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- fldmap`shift-preserves-lookup* FM->F F<=FM=FMP P2 FMP->F
    <- fldperm-can-lookup/L FMP2G FMP->F AF PF CP A2AF FNN2PF PM->C IMP.

- : fldperm-can-lookup/L (fldmap2conj/in _ FNN2P A2AF _ PM-L) 
     (fldmap`lookup/= nat`eq/) _ _ _ A2AF FNN2P PM-L
    ([o] implies/trans3
      (implies/conj2combine)
      (implies/combine
        (implies/reflexive)
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
      (implies/equiv equiv/identity)).

- : fldperm-can-lookup/L (fldmap2conj/in FM2G _ _ FM-SH _)
    (fldmap`lookup/> FM-L P) AF PF CP A2AF FNN2P PM-L
    ([o] implies/trans4
      (implies/conj2combine)
      (implies/combine 
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
        (I o))
      (implies/equiv equiv/commute)
      (implies/equiv equiv/identity))
    <- nat`plus-swap-succ P P'
    <- nat`plus-commutative P' P''
    <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
    <- fldperm-can-lookup/L FM2G FM-L' AF PF CP A2AF FNN2P PM-L I. 

- : fldperm-can-lookup/L 
    (fldmap2conj/out F2C
      (F2CF:{f} fldmap2conj _ _ _ ([r] CJ f r) _) 
      ([f] PM-U f) _ _ _ _ PM-FS) _ AF PF PD A2AF FNN2P PM-L I
    <- predmap`size-total SZ-PM
    <- predmap`fresh-update-increases-size
      SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
    <- fldmap2conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
    <- predmap`size-total SZ-PMF
    <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
    <- fldmap2conj-implies-predmap-leq F2C PMF<=PM
    <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
    <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
    <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
    <- nat`gt-anti-reflexive SZ-PM>PM F
    <- fldperm-can-lookup/false-imply F AF PF PD A2AF FNN2P PM-L I.

%worlds (objvar) (fldperm-can-lookup/L _ _ _ _ _ _ _ _ _).
%total  (FM2G) (fldperm-can-lookup/L FM2G _ _ _ _ _ _ _ _).


%%% This theorem says if we have a class predicate and we 
%%% know that this class has a field F, then we can pull out
%%% the nesting fact about F from the predicate.

%theorem fldperm-can-lookup :
        forall* {CM} {PM} {C} {FM} {F} {NN} {A} {FC} {CP}
        forall  {CM2PM: clsmap2predmap CM PM}
                {PM-L: predmap`lookup PM C CP}
                {CM-L: clsmap`lookup CM C FM}
                {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
        exists  {AF} {PF} {FCP} 
                {A2AF: annot2perm A AF}
                {FNN2P: nn2perm NN AF PF}
                {PM-L: predmap`lookup PM FC FCP}
                {IMP: {o} implies
                      (unitperm
                        (nonlinear
                          (predcall CP (predargs/1 o))))
                      (unitperm
                        (nonlinear
                          (nested ((fldperm F PF) FCP o) o all)))}
        true.

- : fldperm-can-lookup
    CM2PM PM-L CM-L FM-L AF PF CP A2AF FNN2PF PM->FC 
    ([o] implies/trans3
      (implies/equiv (EQV o))
      (implies/nonlinear
        (bimplies/trans
          (bimplies/predcall/Y/inline)
          (bimplies/trans
            (bimplies/predcall/+/inline o)
            (bimplies/predcall/0/inline))))
      (IMP o))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- clsmap-predmap-implies-lookup-format CM-PM PM-L _ PM-LP ([o] EQV o)
    <- clsmap2predmap-implies-fldmap2conj CM2PM PM-LP CM-L FM2G
    <- fldperm-can-lookup/L FM2G FM-L AF PF CP A2AF FNN2PF PM->FC IMP.

%worlds (objvar) (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).
%total  {} (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).


%theorem sharedperm-can-be-duplicated :
    forall* {NN} {C} {AF} {PF} {PM} {CP}
    forall  {A2P: annot2perm annot/shared AF}
            {NN2PF: nn2perm NN AF PF}
            {PM-L: predmap`lookup PM C CP}
    exists  {DUP: {r} implies (PF CP r) ((PF CP r) , (PF CP r))}
    true.

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/yes _
    ([r] 
      (implies/trans4
        (implies/combine 
          (implies/reflexive)
          (implies/combine2conj))
        (implies/combine2conj)
        (implies/duplicate)
        (implies/combine
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))))).

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/may _
    ([r] 
      (implies/trans3
	(implies/cond-inner
	  (bimplies/reflexive)
	  (bimplies/reflexive)
	  (implies/equiv (equiv/symmetric equiv/identity))
	  (implies/trans
	    (implies/combine2conj)
	    (implies/duplicate)))
	(implies/cond-distribute)
	(implies/combine
	  (implies/cond-inner
	    (bimplies/reflexive)
	    (bimplies/reflexive)
	    (implies/reflexive)
	    (implies/conj2combine))
	  (implies/cond-inner
	    (bimplies/reflexive)
	    (bimplies/reflexive)
	    (implies/reflexive)
	    (implies/conj2combine))))).
	      
%worlds () (sharedperm-can-be-duplicated _ _ _ _).
%total  {} (sharedperm-can-be-duplicated _ _ _ _).



%% wellformed type - not borrowed

wf-ty : ty -> type.

wf-ty/unique : wf-ty (ty/ _ annot/unique _).

wf-ty/shared : wf-ty (ty/ _ annot/shared _).



%%% Lemmas for proving tRead

%theorem ref-typing-ok/read :
    forall* {CM} {FM} {B} {F} {Pi} {G} {Out1}
            {XM} {E: expr} {PM} {W} {A} {C}
    forall  {T} {WF-T: wf-ty T} 
            {CM2PM: clsmap2predmap CM PM}
            {CM-L: clsmap`lookup CM C FM} 
            {FM-L: fldmap`lookup FM F T}
            {ET+XM2Out1: reftype+efxmap2output 
                CM PM B (reftype/ (ty/ nn/yes A C) reftgts/shared) XM Out1}
            {TYP: typing W (G , ((allperm null) , Pi)) E Out1}
    exists  {Out} 
            {RT+XM: reftype+efxmap2output 
                    CM PM B (reftype/ T reftgts/shared) XM Out}
            {PTYP: typing W (G , ((allperm null) , Pi)) (read E F) Out}
    true.

% (shared.shared).unique
- : ref-typing-ok/read (ty/ _ annot/unique _) _ CM2PM CM->C=FM FM->F=T
    (reftype+efxmap2output/s_ XM2Pi PM->C nn2perm/yes) TYP %{=>}%
    _ (reftype+efxmap2output/us XM2Pi PM->FC=CP NN2PF) 
    (tTrans2
      (tRead1 TYP
        (letTyping/exists 
          ([r]
            (letTyping/base r
              (tTrans
                (transform/trans3
                  (transform/implies
                    (implies/equiv (equiv/symmetric equiv/associate)))
                  (transform/drop)
                  (transform/trans3
                    (transform/implies
                      (implies/trans4
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans7
                            (implies/combine
                              (implies/equiv equiv/commute)
                              (implies/reflexive))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (IMP r) implies/carve)
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/carve)
                              (implies/reflexive))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (implies/reflexive)
                              (implies/chain-implication)))
                          (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine
                          (implies/equiv (equiv/symmetric equiv/one))
                          (implies/reflexive))))
                    (transform/skolem)
                    (transform/inside [v]
                      (transform/implies
                        (implies/equiv
                          (equiv/transitive
                            (equiv/combine equiv/distribute
                              equiv/reflexive)
                            (equiv/symmetric equiv/associate)))))))
                (letTyping/exists
                  ([v] (letTyping/base null tRead)))
                (transform/inside [v] (transform/reflexive)))))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans4
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans4
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/symmetric equiv/distribute)
                        (equiv/one)
                        (equiv/symmetric equiv/identity)))
                    (implies/combine
                      (implies/equiv equiv/commute)
                      (implies/trans
                        (implies/self-implication)
                        (implies/combine-assoc-encumbered)))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans4
                        (implies/linear-modus-ponens)
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/combine
                          (implies/reflexive)
                          (implies/gen-pack-encumber v))
                        (implies/chain-implication))))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/chain-implication)
                      (implies/reflexive))))))))
        (transform/rem-unused)))
    <- fldperm-can-lookup CM2PM PM->C CM->C=FM FM->F=T
      _ _ _ _ NN2PF PM->FC=CP IMP.

% (shared.unique).unique
- : ref-typing-ok/read (ty/ FAA annot/unique FC) _ CM2PM CM->C=FM FM->F=T
    (reftype+efxmap2output/us XM2Pi' PM->C nn2perm/yes) TYP
    _ (reftype+efxmap2output/us XM2Pi' PM->FC=CP NN2PF-3) 
        (tTrans2 
      (tRead1 TYP
        (letTyping/exists [r]
          (letTyping/base r
            (tTrans
              (transform/trans3
                (transform/implies
                  (implies/trans4
                    (implies/combine
                      (implies/trans7
                        (implies/combine
                          (implies/reflexive)
                          (implies/combine
                            (implies/reflexive)
                            (implies/duplicate)))
                        (implies/equiv equiv/roll3)
                        (implies/combine
                          (IMP r)
                          (implies/trans4
                            (implies/equiv (equiv/symmetric equiv/identity))
                            (implies/combine
                              (implies/equiv equiv/roll2)
                              (implies/trans3
                                (implies/self-implication)
                                (implies/equiv-encumbered
                                  (equiv/transitive
                                    (equiv/roll2)
                                    (equiv/commute))
                                  (equiv/reflexive))
                                (implies/combine-assoc-encumbered)))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (implies/reflexive)
                              (implies/linear-modus-ponens))))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/carve)
                          (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine
                          (implies/reflexive)
                          (implies/chain-implication)))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/chain-implication)
                          (implies/reflexive))))
                    (implies/combine
                      (implies/equiv (equiv/symmetric equiv/one))
                      (implies/reflexive))))
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine equiv/distribute
                          equiv/reflexive)
                        (equiv/symmetric equiv/associate))))))
              (letTyping/exists [v] (letTyping/base null tRead))
              (transform/inside [_] (transform/reflexive))))))
          (transform/trans
	(transform/inside [r]
	  (transform/inside [v]
	    (transform/implies
	      (implies/trans4
		(implies/equiv equiv/associate)
		(implies/combine
		  (implies/trans4
		    (implies/equiv
		      (equiv/transitive3
			(equiv/symmetric equiv/distribute)
			(equiv/one)
			(equiv/symmetric equiv/identity)))
		    (implies/combine
		      (implies/equiv equiv/commute)
		      (implies/trans
			(implies/self-implication)
			(implies/combine-assoc-encumbered)))
		    (implies/equiv (equiv/symmetric equiv/associate))
		    (implies/combine
		      (implies/reflexive)
		      (implies/trans4
			(implies/linear-modus-ponens)
			(implies/equiv (equiv/symmetric equiv/identity))
			(implies/combine
			  (implies/reflexive)
			  (implies/gen-pack-encumber v))
			(implies/chain-implication))))
		  (implies/reflexive))
		(implies/equiv (equiv/symmetric equiv/associate))
		(implies/combine
		  (implies/reflexive)
		  (implies/trans
		    (implies/equiv equiv/associate)
		    (implies/combine
		      (implies/chain-implication)
		      (implies/reflexive))))))))
	(transform/rem-unused)))
    <- fldperm-can-lookup CM2PM PM->C CM->C=FM FM->F=T
      _ _ _ A2AF NN2PF-3 PM->FC=CP IMP.
    
% (shared.unique).shared
- : ref-typing-ok/read (ty/ FAA annot/shared FC) _ CM2PM CM->C=FM FM->F=T
    (reftype+efxmap2output/us XM2Pi' PM->C nn2perm/yes) TYP
    _ (reftype+efxmap2output/s_ XM2Pi' PM->FC=CP NN2PF-3) 
    (tTrans2 
      (tRead1 TYP
        (letTyping/exists [r]
          (letTyping/base r
            (tTrans
              (transform/trans3
                (transform/implies
                  (implies/trans4
                    (implies/combine
                      (implies/trans7
                        (implies/combine
                          (implies/reflexive)
                          (implies/combine
                            (implies/reflexive)
                            (implies/duplicate)))
                        (implies/equiv equiv/roll3)
                        (implies/combine
                          (IMP r)
                          (implies/trans4
                            (implies/equiv (equiv/symmetric equiv/identity))
                            (implies/combine
                              (implies/equiv equiv/roll2)
                              (implies/trans3
                                (implies/self-implication)
                                (implies/equiv-encumbered
                                  (equiv/transitive
                                    (equiv/roll2)
                                    (equiv/commute))
                                  (equiv/reflexive))
                                (implies/combine-assoc-encumbered)))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (implies/reflexive)
                              (implies/linear-modus-ponens))))
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/carve)
                          (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine
                          (implies/reflexive)
                          (implies/chain-implication)))
                      (implies/reflexive))
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/chain-implication)
                          (implies/reflexive))))
                    (implies/combine
                      (implies/equiv (equiv/symmetric equiv/one))
                      (implies/reflexive))))
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine equiv/distribute
                          equiv/reflexive)
                        (equiv/symmetric equiv/associate))))))
              (letTyping/exists [v] (letTyping/base null tRead))
              (transform/inside [_] (transform/reflexive))))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans4
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans5
                    (implies/equiv (equiv/symmetric equiv/distribute))
                    (implies/equiv equiv/one)
                    (implies/combine implies/reflexive (IMP2 v))
                    (implies/equiv equiv/roll2)
                    (implies/combine
                      (implies/reflexive) (implies/pack v)))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens) implies/reflexive)))))))
        (transform/rem-unused)))
    <- fldperm-can-lookup CM2PM PM->C CM->C=FM FM->F=T
      _ _ _ A2AF NN2PF-3 PM->FC=CP IMP
    <- sharedperm-can-be-duplicated annot2perm/shared NN2PF-3 PM->FC=CP
      IMP2.

% (shared.shared).shared
- : ref-typing-ok/read (ty/ FAA annot/shared FC) _ CM2PM CM->C=FM FM->F=T
    (reftype+efxmap2output/s_ XM2Pi' PM->C nn2perm/yes) TYP
    _ (reftype+efxmap2output/s_ XM2Pi' PM->FC=CP NN2PF-3) 
    (tTrans2
      (tRead1 TYP 
        (letTyping/exists 
          ([r]
            (letTyping/base r
              (tTrans
                (transform/trans3
                  (transform/implies
                    (implies/equiv (equiv/symmetric equiv/associate)))
                  (transform/drop)
                  (transform/trans3
                    (transform/implies
                      (implies/trans4
                        (implies/equiv equiv/associate)
                        (implies/combine
                          (implies/trans7
                            (implies/combine
                              (implies/equiv equiv/commute)
                              (implies/reflexive))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (IMP r) implies/carve)
                            (implies/equiv equiv/associate)
                            (implies/combine
                              (implies/carve)
                              (implies/reflexive))
                            (implies/equiv (equiv/symmetric equiv/associate))
                            (implies/combine
                              (implies/reflexive)
                              (implies/chain-implication)))
                          (implies/reflexive))
                        (implies/equiv (equiv/symmetric equiv/associate))
                        (implies/combine
                          (implies/equiv (equiv/symmetric equiv/one))
                          (implies/reflexive))))
                    (transform/skolem)
                    (transform/inside [v]
                      (transform/implies
                        (implies/equiv
                          (equiv/transitive
                            (equiv/combine equiv/distribute
                              equiv/reflexive)
                            (equiv/symmetric equiv/associate)))))))
                (letTyping/exists
                  ([v] (letTyping/base null tRead)))
                (transform/inside [v] (transform/reflexive)))))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans4
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans5
                    (implies/equiv (equiv/symmetric equiv/distribute))
                    (implies/equiv equiv/one)
                    (implies/combine implies/reflexive (IMP2 v))
                    (implies/equiv equiv/roll2)
                    (implies/combine
                      (implies/reflexive) (implies/pack v)))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens) implies/reflexive)))))))
        (transform/rem-unused)))
    <- fldperm-can-lookup CM2PM PM->C CM->C=FM FM->F=T
      _ _ _ A2AF NN2PF-3 PM->FC=CP IMP
    <- sharedperm-can-be-duplicated annot2perm/shared NN2PF-3 PM->FC=CP
      IMP2.

%worlds () (ref-typing-ok/read _ _ _ _ _ _ _ _ _ _).
%total  {} (ref-typing-ok/read _ _ _ _ _ _ _ _ _ _).


%theorem ref-typing-ok : 
    forall* {L1} {L2} {CM} {MM} {B}
            {T} {XM} {E: expr} {PM} {W} 
    forall  {CM-CM: clsmap-clsmap CM CM}
            {CM-MM: clsmap-methmap CM MM}
            {CM-B:  clsmap-cxt CM B}
            {CM2PM: clsmap2predmap CM PM}
            {R-TYP: ref-typing L1 CM MM B E (out/expr T XM) L2}
    exists  {Pin} {XM2Pin: efxmap2perm CM PM B XM Pin}
            {G} {B2G: cxt2facts PM B G}
            {Out} {XM2Out: reftype+efxmap2output CM PM B T XM Out}
            {P-TYP: typing W (G , ((allperm null) , Pin)) E Out}
    true.