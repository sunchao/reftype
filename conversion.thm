%%% Theorems about conversion

%theorem wf-clsmap-lookup-implies-wf-fldmap :
	forall*	{M} {N} {D}
	forall	{A: wf-clsmap M}
		{L: clsmap`lookup M N D}
	exists	{R: wf-fldmap D}
	true.

%worlds () (wf-clsmap-lookup-implies-wf-fldmap _ _ _).
%trustme %total { } (wf-clsmap-lookup-implies-wf-fldmap _ _ _).


%theorem wf-fldmap-lookup-implies-not-borrowed
  : forall* {FM} {F} {NN} {A} {C}
    forall {WF: wf-fldmap FM}
    {FML: fldmap`lookup FM F (ty/ NN A C)}
    exists {NB: not-borrowed A}
    true.

%worlds () (wf-fldmap-lookup-implies-not-borrowed _ _ _).
%trustme %total { } (wf-fldmap-lookup-implies-not-borrowed _ _ _).


%theorem reftyping-helper-implies-read-result-format
  : forall* {CM} {F} {Rslt} {Rslt2}
    forall {RTYP-HELPER: reftyping-helper/read CM Rslt F Rslt2}
    exists {RRF: read-result-format CM F cap/read Rslt}
    true.

- : reftyping-helper-implies-read-result-format
    (reftyping-helper/read/exists ([x] RH x))
    (read-result-format/exists ([x] RRF x))
    <- ({x} reftyping-helper-implies-read-result-format (RH x) (RRF x)).

- : reftyping-helper-implies-read-result-format
    (reftyping-helper/read/base CML FML MG _ _)
    (read-result-format/base CML FML MG).

%worlds (objvar) (reftyping-helper-implies-read-result-format _ _).
%total (K) (reftyping-helper-implies-read-result-format K _).


%theorem subtype-no-effect-on-capmap2perm
  : forall* {CM} {PM} {B0} {M} {Pi} {RT} {M0} {M1} {T} {B1}
    forall {B0+M=>Pi: capmap2perm CM PM B0 M Pi}
    {SUB: subtype CM RT (env/ B0 M0) T (env/ B1 M1)}
    exists {B1+M=>Pi: capmap2perm CM PM B1 M Pi}
    true.

%theorem sub-annot-cap-no-effect-on-capmap2perm
  : forall* {CM} {PM} {M} {Pi} {G} {FS} {A} {B0} {B1} {M0} {M1}
    forall {B0+M=>Pi: capmap2perm CM PM B0 M Pi}
    {SAC: sub-annot-cap G (env/ B0 M0) FS A (env/ B1 M1)}
    exists {B1+M=>Pi: capmap2perm CM PM B1 M Pi}
    true.

- : sub-annot-cap-no-effect-on-capmap2perm B0-M
    (sub-annot-cap/consume _ _ _ R) B1-M
    <- cxt-remove-unique-preserves-capmap2perm B0-M R B1-M.

- : sub-annot-cap-no-effect-on-capmap2perm B-M sub-annot-cap/shared2shared B-M.

%worlds (objvar) (sub-annot-cap-no-effect-on-capmap2perm _ _ _).
%total { } (sub-annot-cap-no-effect-on-capmap2perm _ _ _).

- : subtype-no-effect-on-capmap2perm B0-M (subtype/ nat`eq/ _ _ _ SAC) B1-M
    <- sub-annot-cap-no-effect-on-capmap2perm B0-M SAC B1-M.

- : subtype-no-effect-on-capmap2perm B-M subtype/null B-M.

- : subtype-no-effect-on-capmap2perm B-M subtype/maynull B-M.

%worlds (objvar) (subtype-no-effect-on-capmap2perm _ _ _).
%total { } (subtype-no-effect-on-capmap2perm _ _ _).


%theorem reftyping-ok/expr/write/L
  : forall* {CM} {MM} {PM} {B0} {B1} {B2} {M0} {M1} {M2} {RT} {T}
    {G} {E} {M} {Pi1} {Pi2} {Q}
    forall {RTYP: reftyping CM MM (env/ B0 M0) E (result/expr RT (env/ B1 M1))}
    {SUB: subtype CM RT (env/ B1 M1) T (env/ B2 M2)}
    {R-FMT: read-format CM PM B0 G M Pi1 Pi2 Q}
    exists {R-FMT: read-format CM PM B2 G M Pi1 Pi2 Q}
    true.

%worlds (objvar) (reftyping-ok/expr/write/L _ _ _ _).
%trustme %total { } (reftyping-ok/expr/write/L _ _ _ _).


%theorem reftyping-ok/expr
  : forall* {CM} {PM} {MM} {W} {E} {R} {V}
    forall {WF-CM: wf-clsmap CM}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-V: clsmap-env CM V}
    {RTYP: reftyping CM MM V E R}
    exists {Pi} {Out} {XX2I: env2input CM PM V Pi}
    {XX2O: result2output CM PM R Out}
    {TYP: typing W Pi E Out}
    true.

%theorem reftyping-ok/expr/let
  : forall* {W} {CM} {PM} {MM} {Rslt} {Out} {F} {Rslt2}
    forall {WF-CM: wf-clsmap CM}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-Rslt: clsmap-result CM Rslt}
    {LRTYP: letRefTyping CM MM Rslt F Rslt2}
    {Rslt=>Out1: result2output CM PM Rslt Out}
    exists {Out'} {Out2}
    {Out=>Out': transform Out Out'}
    {Rslt2=>Out2: result2output CM PM Rslt2 Out2}
    {LTYP: letTyping W Out' F Out2}
    true.

%theorem reftyping-ok/expr/write
  : forall* {CM} {MM} {PM} {W} {F} {E2} {G} {T} {Out1} {Rslt1} {Rslt2}
    forall {WF-CM: wf-clsmap CM}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-Rslt: clsmap-result CM Rslt1}
    {Rslt1=>Out1: result2output CM PM Rslt1 Out1}
    {RTYP-H: reftyping-helper/write CM MM Rslt1 F E2 G T Rslt2}
    exists {Out1'} {Out2} {Out2'}
    {Out1=>Out1': transform Out1 Out1'}
    {Rslt2=>Out2: result2output CM PM Rslt2 Out2}
    {TYP: letTyping W Out1' ([O] write (lit O) F E2) Out2'}
    {Out2'=>Out2: transform Out2' Out2}
    true.

- : reftyping-ok/expr/let WF-CM CM-CM CM2PM CM-Rslt
    (letRefTyping/base/unique
      CML2 DM-FM=FS S+FS=M2 B0-S=B1 N!<B1 B1+N=B2 GT
      M0-M2=M4 N+FS=M3 M5-M3=M4 MIN-X ([x] RTYP x))
    Rslt=>Out
  %{=>}% _ _
    (transform/trans
      (TRANS)
      (transform/inside [x]
         (transform/implies (implies/equiv (EQV x)))))
    (result2output/exists [x] (R2=>Out2 x))
    (letTyping/exists [x]
      (letTyping/base x
        (TYP x)))
    <- letRefTyping-helper/base/unique CM-CM CM2PM CML2 DM-FM=FS S+FS=M2
      B0-S=B1 N!<B1 B1+N=B2 GT M0-M2=M4 N+FS=M3 M5-M3=M4 MIN-X CM-Rslt Rslt=>Out
      Pi ([x] CM-V x) ([x] V=>Pi x) TRANS
    <- ({x} reftyping-ok/expr WF-CM CM-CM CM2PM (CM-V x) (RTYP x)
         _ _ (V=>Pi' x) (R2=>Out2 x) (TYP x))
    <- ({x} env2input-equiv (V=>Pi x) (V=>Pi' x) env`eq/ (EQV x)).

- : reftyping-ok/expr/let WF-CM CM-CM CM2PM CM-Rslt
    (letRefTyping/base/shared _ N!<B0 B0+N=B1 ([x] RTYP x))
    Rslt=>Out %{=>}% _ _
    (transform/trans
      (TRANS)
      (transform/inside [x]
        (transform/implies (implies/equiv (EQV x)))))
    (result2output/exists [x] (R2=>Out2 x))
    (letTyping/exists [x]
      (letTyping/base x
        (TYP x)))
    <- letRefTyping-helper/base/shared N!<B0 B0+N=B1 CM-Rslt Rslt=>Out Pi CM-V V=>Pi TRANS
    <- ({x} reftyping-ok/expr WF-CM CM-CM CM2PM (CM-V x) (RTYP x)
         _ _ (V=>Pi' x) (R2=>Out2 x) (TYP x))
    <- ({x} env2input-equiv (V=>Pi x) (V=>Pi' x) env`eq/ (EQV x)).

- : reftyping-ok/expr/let WF-CM CM-CM CM2PM (clsmap-result/exists [x] (CM-Rslt x))
    (letRefTyping/exists [x] (LRTYP x)) (result2output/exists ([x] R=>Out x)) _ _
    (transform/inside [x] (TRANS x))
    (result2output/exists [x] (R2=>Out2 x))
    (letTyping/exists [x] (LTYP x))
    <- ({x} reftyping-ok/expr/let WF-CM CM-CM CM2PM (CM-Rslt x)
         (LRTYP x) (R=>Out x) _ _ (TRANS x) (R2=>Out2 x) (LTYP x)).

- : reftyping-ok/expr/write WF-CM CM-CM CM2PM
    (clsmap-result/exists [x] (CM-R1 x))
    (result2output/exists [x] (R1=>Out1 x))
    (reftyping-helper/write/exists [x] (RTYP-H x)) _ _ _
    (transform/inside [x] (TRANS x))
    (result2output/exists [x] (R2=>Out2 x))
    (letTyping/exists [x] (LTYP x))
    (transform/inside [x] (TRANS2 x))
    <- ({x} reftyping-ok/expr/write WF-CM CM-CM CM2PM (CM-R1 x) (R1=>Out1 x)
         (RTYP-H x) _ _ _ (TRANS x) (R2=>Out2 x) (LTYP x) (TRANS2 x)).

- : reftyping-ok/expr/write WF-CM CM-CM CM2PM CM-R1 R1=>Out1
    (reftyping-helper/write/base (CML:clsmap`lookup CM C FM) FML
      (MG:make-tgts-and-caps M0 G0 F cap/write (targets/unique set/0 M) M1)
      (RTYP-E2:reftyping CM MM (env/ B0 M1) E2 (result/expr RT (env/ B1 M2)))
      (SUB:subtype CM RT (env/ B1 M2) (ty/ NN A FC) (env/ B2 M3))
      (CF:consider-ftype _ M3 A G2 M4)) _ _ _
    (transform/trans
      (TRANS-1)
      (transform/inside [x]
        (transform/implies
          (implies/combine
            (implies/equiv (PiB0'<=>PiB0))
            (implies/reflexive)))))
    R3=>Out3
    (letTyping/exists [x] (letTyping/base x (TYP x)))
    (transform/rem-unused)
    <- make-tgts-and-caps-consistent CM-CM CML FML CM-R1 MG (clsmap-result/expr _ _ CM-B0-M1)
    <- make-tgts-and-caps-implies-min-cap MG MC-M=W
    <- clsmap-result/expr-implies-clsmap-cxt CM-R1 CM-B0
    <- reftyping-ok/expr WF-CM CM-CM CM2PM (clsmap-env/ CM-B0 CM-B0-M1) RTYP-E2 _ Out2
      (env2input/ (B0=>PiB0:cxt2perm CM PM B0 PiB0)
        (B0+M1=>Pi2:capmap2perm CM PM B0 M1 Pi2)) R2=>Out2 TYP-E2
    <- reftyping-implies-clsmap-result CM-CM (clsmap-env/ CM-B0 CM-B0-M1) RTYP-E2 CM-R2
    <- before-read CM-CM CM2PM CML FML R1=>Out1 MG cap2frac/write CM-R1
      PiB0' _ Pi2' _ T2PF B0=>PiB0' B0+R-FMT TRANS-1
    <- reftyping-preserves-capmap2perm RTYP-E2 B0+M1=>Pi2 B1+M1=>Pi2
    <- subtype-no-effect-on-capmap2perm B1+M1=>Pi2 SUB B2+M1=>Pi2
    <- reftyping-ok/expr/write/L RTYP-E2 SUB B0+R-FMT R-FMT
    <- make-before-write-format WF-CM CM2PM CM-R2 SUB R2=>Out2 _ TRANS-2 BW-FMT
    <- do-write B2+M1=>Pi2 R-FMT SUB T2PF
      (tTrans2 TYP-E2 TRANS-2) BW-FMT CF _ TYP R3=>Out3
    <- cxt2perm-equiv B0=>PiB0' B0=>PiB0 clsmap`eq/ predmap`eq/ cxt`eq/ PiB0'<=>PiB0.


- : reftyping-ok/expr WF-CM CM-CM CM2PM (clsmap-env/ CM-B CM-M)
    (reftyping/lit
      (cxt`lookup-obj/ (BL:cxt`lookup B N (cxt-info/ O _))) ty2reftype/unique) _ _
    (env2input/ B=>PiB M=>PiM)
    (result2output/unique/1 (set`size/+ set`size/0) capmap`size/0
      T2PF ([_] (set2cond/U set2cond/0 set`update/0 set`not-member/0 BL)) B=>PiB M=>PiM)
    (tTrans2
      (tObjLoc)
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/trans6
                (implies/equiv PiB<=>PiF+PiBP)
                (implies/combine
                  (implies/trans
                    (implies/combine (DUP O) implies/reflexive) % (DUP O)
                    (implies/equiv (equiv/symmetric equiv/associate)))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric PiB<=>PiF+PiBP)))
                (implies/combine
                  (implies/trans
                    (implies/equiv (equiv/symmetric equiv/identity))
                    (implies/combine implies/reflexive (gen-objequal-self-cond _)))
                  (implies/reflexive))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/associate)
                (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))))
        (transform/gen-exists _)))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _
      (ty2perm2/unique CML PML _ T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-borrow T2PF DUP.

- : reftyping-ok/expr WF-CM CM-CM CM2PM (clsmap-env/ CM-B CM-M)
    (reftyping/lit
      (cxt`lookup-obj/ (BL:cxt`lookup B N (cxt-info/ O _))) ty2reftype/borrow) _ _
    (env2input/ B=>PiB M=>PiM)
    (result2output/unique/1 (set`size/+ set`size/0) capmap`size/0
      T2PF ([_] (set2cond/U set2cond/0 set`update/0 set`not-member/0 BL)) B=>PiB M=>PiM)
    (tTrans2
      (tObjLoc)
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/trans6
                (implies/equiv PiB<=>PiF+PiBP)
                (implies/combine (DUP O) (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric PiB<=>PiF+PiBP)))
                (implies/combine
                  (implies/trans
                    (implies/equiv (equiv/symmetric equiv/identity))
                    (implies/combine implies/reflexive (gen-objequal-self-cond _)))
                  (implies/reflexive))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/associate)
                (equiv/combine equiv/reflexive (equiv/symmetric equiv/associate))))))
        (transform/gen-exists _)))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _
      (ty2perm2/borrow T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-borrow T2PF DUP.

- : reftyping-ok/expr WF-CM CM-CM CM2PM (clsmap-env/ CM-B CM-M)
    (reftyping/lit
      (cxt`lookup-obj/ (BL:cxt`lookup B N (cxt-info/ O _))) ty2reftype/shared) _ _
    (env2input/ B=>PiB M=>PiM)
    (result2output/shared T2PF B=>PiB M=>PiM)
    (tTrans2
      (tObjLoc)
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/trans5
                (implies/equiv (PiB<=>PiF+PiBP))
                (implies/combine (DUP O) (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric (PiB<=>PiF+PiBP))))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))))
        (transform/gen-exists _)))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-capmap-implies-capmap2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _
      (ty2perm2/shared T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-shared T2PF DUP.

- : reftyping-ok/expr WF-CM (CM-CM:clsmap-clsmap CM CM)
    CM2PM CM-V (reftyping/read RTYP-E RTYP-HELPER) Pi Out V=>Pi R2=>Out2
    (tTrans2 (tRead1 (tTrans2 (TYP-E) (TRANS)) LTYP) TRANS2)
    <- reftyping-ok/expr WF-CM CM-CM CM2PM CM-V RTYP-E _ _ V=>Pi R=>Out TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-V RTYP-E CM-R
    <- reftyping-ok/read CM-CM CM2PM CM-R R=>Out RTYP-HELPER _ _ _
      TRANS R2=>Out2 LTYP TRANS2.

- : reftyping-ok/expr WF-CM CM-CM CM2PM CM-V
    (reftyping/let RTYP-E LRTYP) Pi Out3 V=>Pi R2=>Out2
    (tLet
      (tTrans2
        (TYP-E)
        (TRANS))
      (LTYP))
    <- reftyping-ok/expr WF-CM CM-CM CM2PM CM-V RTYP-E Pi Out1 V=>Pi R1=>Out1 TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-V RTYP-E CM-R1
    <- reftyping-ok/expr/let WF-CM CM-CM CM2PM CM-R1 LRTYP R1=>Out1 _ _ TRANS R2=>Out2 LTYP.

%%% IDEA:
%%% After checking E1, we get a permission output like the following:
%%%  (PiB , (PiF , PiF --|- Pi2 , Pi3))
%%% We then can combine PiB and Pi3 to check E2
%%% Then, subtype ensures that we have enough permission to be consumed,
%%% we can then check the "write".

- : reftyping-ok/expr WF-CM CM-CM CM2PM CM-ENV
    (reftyping/write RTYP-E1 RTYP-E2) Pi _ ENV=>Pi R3=>Out3
    (tTrans2 (tWrite1 (tTrans2 (TYP-E1) (TRANS1)) (LTYP)) (TRANS2))
    <- reftyping-ok/expr WF-CM CM-CM CM2PM CM-ENV RTYP-E1 Pi Out1 ENV=>Pi R1=>Out1 TYP-E1
    <- reftyping-implies-clsmap-result CM-CM CM-ENV RTYP-E1 CM-R1
    <- reftyping-ok/expr/write WF-CM CM-CM CM2PM CM-R1 R1=>Out1 RTYP-E2 _ _ _
      TRANS1 R3=>Out3 LTYP TRANS2.

%worlds (objvar) (reftyping-ok/expr _ _ _ _ _ _ _ _ _ _)
(reftyping-ok/expr/let _ _ _ _ _ _ _ _ _ _ _)
(reftyping-ok/expr/write _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (T LT WT) (reftyping-ok/expr _ _ _ _ T _ _ _ _ _)
(reftyping-ok/expr/let _ _ _ _ LT _ _ _ _ _ _)
(reftyping-ok/expr/write _ _ _ _ _ WT _ _ _ _ _ _ _).