%%% Theorems about converting from reftype to permission type.


%%% Shortcuts

%abbrev fldperm-fun
  : object -> nat -> (object -> permission) -> permission
 = [o][F][PF] unitperm (precise-exists o F ([v] PF v)).

%abbrev nonnull-unique-perm : object -> clspred -> permission
    = [x][p] (combine (unitperm (nonlinear (neg (objequal x null))))
               (combine (allperm x)
                 (one-predcall p x))).

%%% Lemmas

%theorem pullout-fldperm
  : forall* {CP} {PF} {Pi1} {Pi2}
    forall {IMP: {x:object} implies (one-predcall CP x)
                 (unitperm (nonlinear (nested (PF x) x all)))}
    exists {IMP: {f:fraction}{x:object}
                 implies
                 (combine (scale f (nonnull-unique-perm x CP))
                   (combine
                     (unitperm
                       (encumbered (scale f (nonnull-unique-perm x CP)) (Pi1 f)))
                     (Pi2 f)))
                 (combine (scale f (PF x))
                   (combine (unitperm (encumbered (scale f (PF x)) (Pi1 f)))
                     (Pi2 f)))}
    true.

- : pullout-fldperm IMP
    ([f][r] implies/trans9
      (implies/combine
        (implies/equiv
          (equiv/transitive
            (equiv/distribute)
            (equiv/commute)))
        (implies/combine
          (implies/trans
            (implies/equiv-encumbered
              (equiv/transitive
                (equiv/distribute)
                (equiv/combine
                  (equiv/reflexive)
                  (equiv/transitive
                    (equiv/distribute)
                    (equiv/commute))))
              (equiv/reflexive))
            (implies/combine-assoc-encumbered))
          (implies/reflexive)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/linear-modus-ponens)
            (implies/reflexive))))
      (implies/combine
        (implies/trans3
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/reflexive)
            (implies/trans
              (implies/scale-from-formula)
              (implies/duplicate)))
          (implies/equiv equiv/associate))
        (implies/combine
          (implies/combine-assoc-encumbered)
          (implies/reflexive)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (implies/scale-into-formula)
                (implies/reflexive))
              (implies/linear-modus-ponens))
            (implies/reflexive))))
      (implies/combine
        (implies/trans6
          (implies/equiv equiv/commute)
          (implies/combine
            (implies/trans
              (IMP r)
              (implies/scale-into-formula))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/distribute))
          (implies/scale implies/carve)
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/reflexive)
            (implies/scale-distribute-encumbered)))
        (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/chain-implication)
            (implies/reflexive))))).

%worlds () (pullout-fldperm _ _).
%total {} (pullout-fldperm _ _).


%abbrev add-encumber
  : implies (combine (unitperm (encumbered Pi1 Pi2)) Pi3)
              (unitperm (encumbered Pi1 (Pi2 , Pi3)))
    = (implies/trans
        (implies/combine
          (implies/reflexive)
          (implies/trans3
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/combine
              (implies/reflexive)
              (implies/trans3
                (implies/self-implication)
                (implies/equiv-encumbered
                  (equiv/commute)
                  (equiv/reflexive))
                (implies/combine-assoc-encumbered)))
            (implies/linear-modus-ponens)))
        (implies/chain-implication)).


%abbrev repack-fldperm
  : {f}{v} implies
    (scale f (unitperm (basic O F v)))
    (unitperm
      (encumbered
        (scale f (Pi v))
        (scale f (unitperm (precise-exists O F ([v] (Pi v)))))))
    = [f][v]
      (implies/trans3
        (implies/equiv (equiv/symmetric equiv/identity))
        (implies/combine
          (implies/reflexive)
          (implies/trans5
            (implies/equiv (equiv/symmetric equiv/zero))
            (implies/scale (implies/gen-pack-encumber v))
            (implies/scale-distribute-encumbered)
            (implies/equiv-encumbered
              (equiv/distribute)
              (equiv/reflexive))
            (implies/combine-assoc-encumbered)))
        (implies/linear-modus-ponens)).


%theorem implies-respects-permission-eq
  : forall* {P1} {P2} {P3} {P4}
    forall {Pi1=>Pi2: implies P1 P2}
    {P1=P3: permission`eq P1 P3}
    {P2=P4: permission`eq P2 P4}
    exists {P3=>P4: implies P3 P4}
    true.

- : implies-respects-permission-eq I permission`eq/ permission`eq/ I.

%worlds () (implies-respects-permission-eq _ _ _ _).
%total {} (implies-respects-permission-eq _ _ _ _).


%theorem false-implies-transform
  : forall* {K} {O1:output K} {O2:output K}
    forall {F:void}
    exists {T: transform O1 O2}
    true.

%worlds () (false-implies-transform _ _).
%total {} (false-implies-transform _ _).



%{ This theorem says if we have a class predicate and we
know that this class has a field F, then we can pull out
the nesting fact about F from the predicate. }%


%theorem fldperm-can-lookup
  : forall* {CM} {PM} {C} {FM} {F} {NN} {A} {FC} {CP}
    forall {CM2PM: clsmap2predmap CM PM}
    {PM-L: predmap`lookup PM C CP}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    exists {AF} {PF} {FCP}
    {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM FC FCP}
    {IMP: {o} implies
          (unitperm
            (nonlinear
              (predcall CP (predargs/1 o))))
          (unitperm
            (nonlinear
              (nested ((fldperm F PF) FCP o) o all)))}
    true.

%theorem fldperm-can-lookup/false-imply
  : forall* {PM} {NN} {C} {F:nat} {G} {A}
    forall {V:void}
    exists {AF} {PF:clspred -> object -> permission}
    {CP} {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    {IMP: {o} implies (unitperm (nonlinear (G o)))
        (unitperm
          (nonlinear
            (nested ((fldperm F PF) CP o) o all)))}
    true.

%theorem fldperm-can-lookup/L
  : forall* {CM} {PM} {FM} {F} {NN} {A} {G} {C}
    forall {FM=>G: fldmap2conj CM PM FM ([r] G r) PM}
    {FM-L: fldmap`lookup FM F (ty/ NN A C)}
    exists {AF} {PF} {CP}
    {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    {IMP: {o} implies (unitperm (nonlinear (G o)))
        (unitperm
            (nonlinear
              (nested ((fldperm F PF) CP o) o all)))}
    true.

- : fldperm-can-lookup/L (fldmap2conj/null FMP2G F<=FM=FMP)
    (fldmap`lookup/> FM->F P) AF PF CP A2AF FNN2PF PM->C IMP
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- fldmap`shift-preserves-lookup* FM->F F<=FM=FMP P2 FMP->F
    <- fldperm-can-lookup/L FMP2G FMP->F AF PF CP A2AF FNN2PF PM->C IMP.

- : fldperm-can-lookup/L (fldmap2conj/in _ FNN2P A2AF _ PM-L)
     (fldmap`lookup/= nat`eq/) _ _ _ A2AF FNN2P PM-L
    ([o] implies/trans3
      (implies/conj2combine)
      (implies/combine
        (implies/reflexive)
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
      (implies/equiv equiv/identity)).

- : fldperm-can-lookup/L (fldmap2conj/in FM2G _ _ FM-SH _)
    (fldmap`lookup/> FM-L P) AF PF CP A2AF FNN2P PM-L
    ([o] implies/trans4
      (implies/conj2combine)
      (implies/combine
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
        (I o))
      (implies/equiv equiv/commute)
      (implies/equiv equiv/identity))
    <- nat`plus-swap-succ P P'
    <- nat`plus-commutative P' P''
    <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
    <- fldperm-can-lookup/L FM2G FM-L' AF PF CP A2AF FNN2P PM-L I.

- : fldperm-can-lookup/L
    (fldmap2conj/out F2C
      (F2CF:{f} fldmap2conj _ _ _ ([r] CJ f r) _)
      ([f] PM-U f) _ _ _ _ PM-FS) _ AF PF PD A2AF FNN2P PM-L I
    <- predmap`size-total SZ-PM
    <- predmap`fresh-update-increases-size
      SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
    <- fldmap2conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
    <- predmap`size-total SZ-PMF
    <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
    <- fldmap2conj-implies-predmap-leq F2C PMF<=PM
    <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
    <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
    <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
    <- nat`gt-anti-reflexive SZ-PM>PM F
    <- fldperm-can-lookup/false-imply F AF PF PD A2AF FNN2P PM-L I.

- : fldperm-can-lookup
    CM2PM PM-L CM-L FM-L AF PF CP A2AF FNN2PF PM->FC
    ([o] implies/trans3
      (implies/equiv (EQV o))
      (implies/nonlinear
        (bimplies/trans
          (bimplies/predcall/Y/inline)
          (bimplies/trans
            (bimplies/predcall/+/inline o)
            (bimplies/predcall/0/inline))))
      (IMP o))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- clsmap-predmap-implies-lookup-format CM-PM PM-L _ PM-LP ([o] (PEQ o))
    <- ({o} permission`eq-implies-equiv (PEQ o) (EQV o))
    <- clsmap2predmap-implies-fldmap2conj CM2PM PM-LP CM-L FM2G
    <- fldperm-can-lookup/L FM2G FM-L AF PF CP A2AF FNN2PF PM->FC IMP.

%worlds (objvar) (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).
%total {} (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).

%worlds (objvar) (fldperm-can-lookup/L _ _ _ _ _ _ _ _ _).
%total (FM2G) (fldperm-can-lookup/L FM2G _ _ _ _ _ _ _ _).

%worlds (objvar) (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).
%total {} (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).



%theorem sharedperm-can-be-duplicated
  : forall* {NN} {C} {AF} {PF} {PM} {CP}
    forall {A2AF: annot2perm annot/shared AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    exists {IMP: {r} implies (PF CP r) ((PF CP r) , (PF CP r))}
    true.

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/yes _
    ([r]
      (implies/trans4
        (implies/combine
          (implies/reflexive)
          (implies/combine2conj))
        (implies/combine2conj)
        (implies/duplicate)
        (implies/combine
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))))).

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/may _
    ([r]
      (implies/trans3
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/trans
            (implies/combine2conj)
            (implies/duplicate)))
        (implies/cond-distribute)
        (implies/combine
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/conj2combine))
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/conj2combine))))).

%worlds () (sharedperm-can-be-duplicated _ _ _ _).
%total {} (sharedperm-can-be-duplicated _ _ _ _).


%theorem sharedperm-can-be-duplicated*
  : forall* {NN} {C} {PF} {PM}
    forall {T2PF: ty2perm PM (ty/ NN annot/shared C) PF}
    exists {IMP: {r} implies (PF r) ((PF r) , (PF r))}
    true.

- : sharedperm-can-be-duplicated*
    (ty2perm/ PM-L NN2PF A2AF) IMP
    <- sharedperm-can-be-duplicated A2AF NN2PF PM-L IMP.

%worlds () (sharedperm-can-be-duplicated* _ _).
%total {} (sharedperm-can-be-duplicated* _ _).


%abbrev ffperm
  : fraction -> object -> nat
   -> (object -> permission) -> permission
  = [f][r][n][fp] (scale f (unitperm (precise-exists r n ([o] fp o)))).

%abbrev gen-objequal-self
  : {o} implies empty (unitperm (nonlinear (disj (objequal o o) (neg t))))
    = [o] implies/trans
      (implies/empty2true)
      (implies/nonlinear
        (bimplies/trans
          (bimplies/objequal-reflexive)
          (bimplies/trans
            (bimplies/add-negneg)
            (bimplies/neg
              (bimplies/conj-weaken/false)
              (bool`ne/FT))))).

%theorem can-carve-out-of-shared
  : forall* {Pi1} {Pi2} {Pi3}
    forall {EQV: {f} equiv (Pi2 f) (scale f (allperm null) , Pi3 f)}
    exists {IMP: {f} {r} implies
                 ((unitperm
                      (nonlinear
                        (nested (allperm r) null all))) , (Pi1 f , Pi2 f))
                 ((scale f (allperm r)) ,
                   ((unitperm
                     (encumbered
                       (scale f (allperm r)) (Pi2 f))) , (Pi1 f)))}
    true.

- : can-carve-out-of-shared
    EQV ([f][r] implies/trans3
          (implies/equiv
            (equiv/transitive
              (equiv/combine
                (equiv/reflexive) equiv/commute)
              (equiv/associate)))
          (implies/combine
            (implies/trans6
              (implies/combine
                implies/reflexive (implies/equiv (EQV f)))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans5
                  (implies/combine
                    (implies/scale-into-formula)
                    (implies/reflexive))
                  (implies/equiv (equiv/symmetric equiv/distribute))
                  (implies/scale implies/carve)
                  (implies/equiv equiv/distribute)
                  (implies/combine
                    implies/reflexive
                    (implies/scale-distribute-encumbered)))
                (implies/reflexive))
              (implies/combine
                (implies/reflexive)
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/transitive
                          (EQV f)
                          (equiv/commute))
                        (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive implies/chain-implication))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))).

%worlds () (can-carve-out-of-shared _ _).
%total {} (can-carve-out-of-shared _ _).


%theorem reftyping-ok/before-read/shared
  : forall* {CM} {PM} {FM} {C} {NN} {A} {FC} {B} {XM} {MX} {Out} {F}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {LE: effects`leq (shared-effect efx/read) (effects/ XM MX)}
    {XX=>Out: effects2output CM PM B
              (reftype/ nn/yes C targets/shared) (effects/ XM MX) Out}
    exists {Pi1} {Pi2} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {MX=>Pi2: maybe-efx2perm MX Pi2}
    {XM=>Pi1: efxmap2perm false CM PM B XM Pi1}
    {TRANS: {f} transform (Out f)
            (output/exists [r]
              (output/expr r
                ((ffperm f r F TF) ,
                  ((unitperm
                     (encumbered
                       (ffperm f r F TF) (Pi2 f))) , Pi1 f))))}
    true.

- : reftyping-ok/before-read/shared
    CM-CM CM2PM CM-L FM-L (effects`leq/ XM1<=XM MX1<=MX)
    (effects2output/shared XM=>Pi1 MX=>Pi2
      (ty2perm/ PM-L nn2perm/yes annot2perm/shared))
    %{=>}% _ _ _ (ty2perm/ PM-LF NN2PF A2AF) MX=>Pi2 XM=>Pi1
    ([f] transform/inside [r]
      (transform/trans
        (transform/implies
          (implies/trans
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/associate)
                (equiv/combine
                  (equiv/reflexive)
                  (equiv/transitive3
                    (equiv/symmetric equiv/associate)
                    (equiv/combine equiv/reflexive equiv/commute)
                    (equiv/associate)))))
            (implies/combine
              (implies/reflexive)
              (implies/trans6
                (implies/combine
                  (IMP1 f r) (IMP2 r))
                (implies/equiv
                  (equiv/transitive3
                    (equiv/symmetric equiv/associate)
                    (equiv/combine equiv/reflexive equiv/commute)
                    (equiv/associate)))
                (implies/combine
                  (implies/trans
                    (implies/equiv equiv/commute)
                    (implies/trans5
                      (implies/combine
                        (implies/scale-into-formula)
                        (implies/reflexive))
                      (implies/equiv (equiv/symmetric equiv/distribute))
                      (implies/scale implies/carve)
                      (implies/equiv equiv/distribute)
                      (implies/combine
                        implies/reflexive
                        (implies/scale-distribute-encumbered))))
                  (implies/reflexive))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive implies/chain-implication))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))))))
        (transform/drop)))
    <- maybe-efx-leq-implies-permission-leq
      MX1<=MX (maybe-efx2perm/just apply-efx/read) MX=>Pi2 _ EQV
    <- can-carve-out-of-shared EQV IMP1
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L _ _ _ A2AF NN2PF PM-LF ([r] IMP2 r).

%worlds () (reftyping-ok/before-read/shared _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/before-read/shared _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem combine-fldperm
  : forall* {S} {B} {C} {CM} {PM} {FM}
    {NN} {A} {FC} {G} {F} {GM} {XM} {Pi} {PF}
    forall {K} {Z: set`size S (s K)}
    {SC: same-class B S C}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {S2GM: set+nat2tgtmap S F GM}
    {S2G: {x} set2facts x S (G x)}
    {XM2GM: efxmap2tgtmap XM GM}
    {M2P: efxmap2perm true CM PM B XM Pi}
    {T2PF: ty2perm PM (ty/ NN A FC) PF}
    exists {IMP: {f}{x} implies
          (combine (unitperm (nonlinear (G x)))
            (Pi f))
          (combine (scale f (unitperm (precise-exists x F ([v] PF v))))
            (unitperm (encumbered
                        (scale f (unitperm (precise-exists x F PF)))
                        (Pi f))))}
    true.

%theorem combine-fldperm/L
  : forall* {Pi} {X} {PF}
    forall {AP: apply-efx true X Pi ([f] PF f)}
    exists {IMP: {f} implies (PF f)
                 (combine (scale f Pi)
                   (unitperm (encumbered
                               (scale f Pi) (PF f))))}
    true.

%worlds (objvar) (combine-fldperm/L _ _).
%trustme %total {} (combine-fldperm/L _ _).                      

%theorem combine-fldperm/L1
  : forall* {M} {N}
    forall {DM: inner-efxmap`domain M (set/1 N)}
    exists {X} {EQ: inner-efxmap`eq M (inner-efxmap/+ N X inner-efxmap/0)}
    true.

- : combine-fldperm/L1
    (inner-efxmap`domain/+ inner-efxmap`domain/0) _ inner-efxmap`eq/.

%worlds (objvar) (combine-fldperm/L1 _ _ _).
%total {} (combine-fldperm/L1 _ _ _).

%theorem combine-fldperm/L2
  : forall* {P} {O} {FM} {PM} {F} {X} {Pi}
    forall {M2Pi: inner-efxmap2perm
                  P O FM PM (inner-efxmap/+ F X inner-efxmap/0) Pi}
    exists {T} {FML: fldmap`lookup FM F T}
    {PF} {T2PF: ty2perm PM T PF}
    {Pi1} {AP: apply-efx P X (unitperm (precise-exists O F PF)) Pi1}
    {EQV: {f} equiv (Pi f) (Pi1 f)}
    true.

- : combine-fldperm/L2 M2Pi _ FML _ T2PF _ AP
    ([f] equiv/transitive3
      (equiv/symmetric (EQV f))
      (equiv/combine
        (equiv/reflexive)
        (EQV1 f))
      (equiv/identity))
    <- inner-efxmap2perm/U-inversion M2Pi inner-efxmap`fresh/0
      inner-efxmap`update/0  _ FML _ T2PF _ AP _ M2P EQV
    <- inner-efxmap2perm-equiv M2P inner-efxmap2perm/0
      bool`eq/ object`eq/ fldmap`eq/ predmap`eq/ inner-efxmap`eq/ EQV1.

%worlds (objvar) (combine-fldperm/L2 _ _ _ _ _ _ _ _).
%total {} (combine-fldperm/L2 _ _ _ _ _ _ _ _). 

%theorem combine-fldperm/L3
  : forall* {SP} {N} {K}
    forall {NM: set`not-member SP K} {AD: set`add SP K (set/1 N)}
    exists {E: nat`eq K N} {E: set`eq SP set/0}
    true.

- : combine-fldperm/L3 set`not-member/0 set`update/0 nat`eq/ set`eq/.

- : combine-fldperm/L3 NM (set`update/= nat`eq/) nat`eq/ E
    <- set`not-member-contradiction NM F
    <- set`false-implies-eq F E.

%worlds () (combine-fldperm/L3 _ _ _ _).
%total {} (combine-fldperm/L3 _ _ _ _).


- : combine-fldperm _ (set`size/+ set`size/0)
    (same-class/U SC NM AD BL)
    CM-CM CM2PM
    (CML:clsmap`lookup CM C1 FM)
    (FML:fldmap`lookup FM F (ty/ FNN1 FA1 FC1))
    (S+F=>GM:set+nat2tgtmap (set/1 K) F GM)
    S=>G
    (XM=>GM:efxmap2tgtmap XM GM) XM=>Pi T2PF
    ([f][x]
      (implies/trans4
        (implies/combine
          (implies/nonlinear
            (bimplies/trans
              (bimplies/trans
                (BIMP1 x)
                (bimplies/trans
                  (bimplies/neg
                    (bimplies/trans
                      (bimplies/conj/XX
                        (bimplies/reflexive)
                        (bimplies/trans
                          (bimplies/neg (G-BIMP x) (bool`ne/TF))
                          (bimplies/rem-negneg)))
                      (bimplies/conj-true))
                    (bool`ne/FT))
                  (bimplies/rem-negneg)))
              (bimplies/objequal-symmetric)))
          (implies/trans
            (implies/equiv (equiv/symmetric (Pi1+Pi2<=>Pi f)))
            (implies/combine
              (implies/trans
                (implies/equiv (EQV f))
                (IMP2 f))
              (implies/equiv (EQV3 f)))))
        (implies/objequal
          ([o] (combine
                 (combine
                   (scale f (fldperm-fun o F PF))
                   (unitperm
                     (encumbered
                       (scale f (fldperm-fun o F PF)) (Pi3 f))))
                 empty)))
        (implies/equiv equiv/identity)
        (implies/combine
          (implies/reflexive)
          (implies/equiv-encumbered
            (equiv/reflexive)
            (equiv/transitive4
              (equiv/symmetric (EQV f))
              (equiv/symmetric equiv/identity)
              (equiv/combine equiv/reflexive (equiv/symmetric (EQV3 f)))
              (Pi1+Pi2<=>Pi f))))))
    <- set+nat2tgtmap/U-inversion S+F=>GM NM AD GMP SP+F=>GMP GMP+N+F=GM
    <- ({x} set2facts/U-inversion
         (S=>G x) NM AD _ (SP=>GP x) (BIMP1 x) (BIMP2 x))
    <- set+nat2tgtmap-preserves-fresh SP+F=>GMP NM N!<GMP
    <- efxmap2tgtmap/UP-inversion
      XM=>GM N!<GMP GMP+N+F=GM XMP M XMP=>GMP DM-M=S
      XMP+N+M=XM
    <- efxmap2tgtmap-preserves-fresh-converse N!<GMP XMP=>GMP N!<XMP
    <- efxmap2perm/U-inversion XM=>Pi N!<XMP XMP+N+M=XM
      NN A C BL1 FM1 CML1 Pi1 M=>Pi1 Pi2 XMP=>Pi2 Pi1+Pi2<=>Pi
    <- combine-fldperm/L1 DM-M=S _ M-EQ
    <- inner-efxmap2perm-respects-eq M=>Pi1 bool`eq/ object`eq/ fldmap`eq/
      predmap`eq/ M-EQ ([_] permission`eq/) M1=>Pi1
    <- combine-fldperm/L2 M1=>Pi1 _ FML1 _ T2PF1 _ AP EQV
    <- cxt`lookup-unique BL BL1 cxt`eq/ object`eq/ TE
    <- ty-eq-inversion TE NNE AE K1=C
    <- clsmap`lookup-unique CML CML1 clsmap`eq/ K1=C FM=FM1
    <- fldmap`lookup-unique FML FML1 FM=FM1 nat`eq/ FTE
    <- ty`eq-symmetric FTE FTEx
    <- ty2perm-deterministic T2PF1 T2PF predmap`eq/ FTEx PE
    <- combine-fldperm/L3 NM AD N-EQ S-EQ
    <- permission`precise-exists-respects-eq PE P-EQ
    <- apply-efx-respects-eq AP bool`eq/ efx`eq/ P-EQ ([_] permission`eq/) AP2
    <- combine-fldperm/L AP2 IMP2
    <- ({x} set2facts-bimplies (SP=>GP x)
         set2facts/0 object`eq/ S-EQ (G-BIMP x) _)
    <- set+nat2tgtmap-unique (SP+F=>GMP:set+nat2tgtmap SP F GMP)
      set+nat2tgtmap/0 S-EQ nat`eq/ GM-EQ
    <- efxmap2tgtmap-empty (XMP=>GMP:efxmap2tgtmap XMP GMP) GM-EQ XM-EQ
    <- efxmap2perm-equiv XMP=>Pi2 efxmap2perm/0 bool`eq/ clsmap`eq/
      predmap`eq/ cxt`eq/ (XM-EQ:efxmap`eq XMP efxmap/0) EQV3.

- : combine-fldperm (s _) SZ
    (same-class/U SC NM AD
      (BL:cxt`lookup B (object/ K) (ty/ NN1 A1 K1)))
    CM-CM CM2PM (CML:clsmap`lookup CM K1 FM) FML
    S+F=>GM S=>G XM=>GM XM=>Pi T2PF
    ([f][x]
      (implies/trans5
        (implies/combine
          (implies/trans3
            (implies/nonlinear (BIMP1 x))
            (implies/disj2cond)
            (implies/cond-gen-inner))
          (implies/trans
            (implies/equiv (equiv/symmetric (Pi1+Pi2<=>Pi f)))
            (implies/combine
              (implies/trans
                (implies/equiv (EQV f))
                (IMP2 f))
              (implies/reflexive))))
        (implies/equiv equiv/commute)
        (implies/cond-push)
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/trans6
            (implies/equiv equiv/commute)
            (implies/combine 
              (implies/trans
                (implies/equiv equiv/identity)
                (implies/nonlinear bimplies/objequal-symmetric))
              (implies/reflexive))
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/objequal
                ([o] (scale f (fldperm-fun o F ([v] PF v))) ,
                  (unitperm
                    (encumbered
                      (scale f (fldperm-fun o F ([v] PF v)))
                      (Pi f)))))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (add-encumber)
                (implies/equiv-encumbered
                  (equiv/reflexive)
                  (equiv/transitive
                    (equiv/combine (equiv/symmetric (EQV f)) equiv/reflexive)
                    (Pi1+Pi2<=>Pi f))))))
          (implies/trans5
            (implies/equiv
              (equiv/transitive4
                (equiv/symmetric equiv/associate)
                (equiv/combine
                  (equiv/reflexive)
                  (equiv/roll2))
                (equiv/associate)
                (equiv/combine equiv/reflexive equiv/commute)))
            (implies/combine
              (implies/trans
                (implies/combine
                  (implies/linear-modus-ponens)
                  (implies/trans
                    (implies/nonlinear
                      (bimplies/tt))
                    (implies/true2empty)))
                (implies/equiv equiv/identity))
              (IMP3 f x))
            (implies/equiv equiv/commute)
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (add-encumber)
                (implies/equiv-encumbered
                  (equiv/reflexive)
                  (equiv/transitive3
                    (equiv/commute)
                    (equiv/combine
                      (equiv/symmetric (EQV f))
                      (equiv/reflexive))
                    (Pi1+Pi2<=>Pi f)))))))
        (implies/cond-equal)))
    <- set+nat2tgtmap/U-inversion S+F=>GM NM AD GMP SP+F=>GMP GMP+N+F=GM
    <- ({x} set2facts/U-inversion (S=>G x) NM AD _ (SP=>GP x) (BIMP1 x)
         (BIMP2 x))
    <- set+nat2tgtmap-preserves-fresh SP+F=>GMP NM N!<GMP
    <- efxmap2tgtmap/UP-inversion
      XM=>GM N!<GMP GMP+N+F=GM XMP M XMP=>GMP DM-M=S XMP+N+M=XM
    <- efxmap2tgtmap-preserves-fresh-converse N!<GMP XMP=>GMP N!<XMP
    <- efxmap2perm/U-inversion XM=>Pi N!<XMP XMP+N+M=XM
      NN A C BL1 FM1 CML1 Pi1 M=>Pi1 Pi2 XMP=>Pi2 Pi1+Pi2<=>Pi
    <- combine-fldperm/L1 DM-M=S _ M-EQ
    <- inner-efxmap2perm-respects-eq M=>Pi1 bool`eq/ object`eq/ fldmap`eq/
      predmap`eq/ M-EQ ([_] permission`eq/) M1=>Pi1
    <- combine-fldperm/L2 M1=>Pi1 _ FML1 _ T2PF1 _ AP EQV
    <- cxt`lookup-unique BL BL1 cxt`eq/ object`eq/ TE
    <- ty-eq-inversion TE NNE AE K1=C
    <- clsmap`lookup-unique CML CML1 clsmap`eq/ K1=C FM=FM1
    <- fldmap`lookup-unique FML FML1 FM=FM1 nat`eq/ FTE
    <- ty`eq-symmetric FTE FTEx
    <- ty2perm-deterministic T2PF1 T2PF predmap`eq/ FTEx PE
    <- permission`precise-exists-respects-eq PE P-EQ
    <- apply-efx-respects-eq AP bool`eq/ efx`eq/ P-EQ ([_] permission`eq/) AP2
    <- combine-fldperm/L AP2 IMP2
    <- set`not-member-update-increases-size-converse SZ NM AD SZP
    <- combine-fldperm _ SZP SC CM-CM CM2PM CML FML SP+F=>GMP SP=>GP
      XMP=>GMP XMP=>Pi2 T2PF IMP3.

%worlds (objvar) (combine-fldperm _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N) (combine-fldperm N _ _ _ _ _ _ _ _ _ _ _ _).


%theorem get-field-permission*
  : forall* {PM} {CM} {FM} {XM} {S} {B} {C} {F}
    {NN} {A} {FC} {G} {Pi} {GM}
    forall {K} {SZ: set`size S (s K)}
    {SC: same-class B S C} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>XM: set+nat2tgtmap S F GM}
    {GM=>XM: tgtmap2efxmap GM efx/read XM}
    {S=>G: {r} set2facts r S (G r)}
    {XM=>Pi: efxmap2perm true CM PM B XM Pi}
    exists {PF} {T2PF: ty2perm PM (ty/ NN A FC) PF}
    {IMP: {f}{r} implies
          ((unitperm (nonlinear (G r))) , (Pi f))
          ((scale f (unitperm (precise-exists r F ([v] PF v)))) ,
            (unitperm
              (encumbered
                (scale f (unitperm (precise-exists r F ([v] PF v))))
                (Pi f))))}
    true.

- : get-field-permission* K SZ SC CM-CM CM2PM CML FML S+F=>GM GM=>XM
    S=>G XM=>Pi _ T2PF IMP
    <- tgtmap2efxmap-implies-efxmap2tgtmap GM=>XM XM=>GM
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-clsmap-ty CM-FM FML CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF
    <- combine-fldperm K SZ SC CM-CM CM2PM CML FML S+F=>GM S=>G
      XM=>GM XM=>Pi T2PF IMP.

%worlds () (get-field-permission* _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (get-field-permission* _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%{
How to prove this? First we need to show that XM2 is
less than or equal to XM2P, therefore we can get back the
permission for reading field F. For this we need the following
theorem:

  if we have:
    S + F => GM
    GM    => XM2
    XM2   <= XM
    XM/GM == XM1 , XM2P
    --------------------
  then we can get:
    XM2   <= XM2P
    DM(XM2) = DM(XM2P)

The immediate result of this is we can convert XM2P to two
sets of permissions, say Pi1 and Pi2, and Pi1 is the permissions
generated from XM2.

Since we have permission Pi1, as well as the object equal relations,
we can get the field permission, and thus this theorem can be done.

One problem is XM1 \join XM2 = XM, here it's possible that XM1 overlaps
with XM2, and thus if XM2 => GM2, and XM / GM2 = XM1P + XM2P,
XM1P will be less than XM1.

}%

%theorem reftyping-ok/before-read/unique/L1
  : forall* {CM} {PM} {B} {S} {F} {GM2} {XM1} {XM2} {XM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {S+F=>GM2: set+nat2tgtmap S F GM2}
    {GM2=>XM2: tgtmap2efxmap GM2 efx/read XM2}
    {J: efxmap`join XM1 XM2 XM}
    {CM-B-XM: clsmap-cxt-efxmap CM B XM}
    exists {XM1P} {XM2P}
    {SG: select-tgtmap XM GM2 XM1P XM2P}
    {CM-B-XM2P: clsmap-cxt-efxmap CM B XM2P}
    {XM2<=XM2P: efxmap`leq XM2 XM2P}
    {NC-XM2P: efxmap`no-consume XM2P}
    {Pi2} {XM2=>Pi2: efxmap2perm true CM PM B XM2 Pi2}
    {Pi1P} {XM1P=>Pi1P: efxmap2perm false CM PM B XM1P Pi1P}
    true.

- : reftyping-ok/before-read/unique/L1
    CM-CM CM2PM S+F=>GM2 GM2=>XM2 XM1+XM2=XM CM-B-XM _ _
    XM/GM2=XM1P+XM2P CM-B-XM2P XM2<=XM2P NC-XM2P _ T+XM2=>Pi2 _ F+XM1P=>Pi1P
    <- tgtmap2efxmap-implies-efxmap2tgtmap GM2=>XM2 XM2=>GM2
    <- efxmap`join-implies-leq XM1+XM2=XM XM1<=XM XM2<=XM
    <- set+nat2tgtmap-no-consume S+F=>GM2 GM2=>XM2 efx`not-consume/read NC-XM2
    <- select-tgtmap-total XM/GM2=XM1P+XM2P
    <- select-tgtmap-implies-leq XM/GM2=XM1P+XM2P XM1P<=XM XM2P<=XM
    <- leq-preserves-clsmap-cxt-efxmap CM-B-XM XM2<=XM CM-B-XM2
    <- leq-preserves-clsmap-cxt-efxmap CM-B-XM XM2P<=XM CM-B-XM2P
    <- leq-preserves-clsmap-cxt-efxmap CM-B-XM XM1P<=XM CM-B-XM1P
    <- efxmap`join-no-consume-right XM2=>GM2 NC-XM2 XM1+XM2=XM
      (XM/GM2=XM1P+XM2P:select-tgtmap XM GM2 XM1P XM2P) NC-XM2P
    <- select-tgtmap-leq-implies-leq XM/GM2=XM1P+XM2P GM2=>XM2 XM2<=XM XM2<=XM2P
    <- clsmap-cxt-efxmap-implies-efxmap2perm CM-CM CM2PM CM-B-XM2 Pi2 T+XM2=>Pi2
    <- clsmap-cxt-efxmap-implies-efxmap2perm CM-CM CM2PM CM-B-XM1P Pi1P F+XM1P=>Pi1P.

%worlds () (reftyping-ok/before-read/unique/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/before-read/unique/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/before-read/unique/0
  : forall* {B} {CM} {PM} {FM} {C} {XM} {MX}
    {F} {NN} {A} {FC} {Out}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {XM=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique set/0 tgtmap/0 false))
              (effects/ XM MX) Out}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {CP} {PML: predmap`lookup PM C CP}
    {Pi2} {MX=>Pi3: maybe-efx2perm MX Pi2}
    {Pi1} {XM=>Pi: efxmap2perm false CM PM B XM ([f] Pi1 f)}
    {TRANS: {f} transform (Out f)
            (output/exists [r]
              (output/expr r
                (combine (unitperm (precise-exists r F TF))
                  (combine
                    (unitperm
                      (encumbered (unitperm (precise-exists r F TF))
                        (nonnull-unique-perm r CP)))
                    (combine (Pi1 f) (Pi2 f))))))}
    true.


- : reftyping-ok/before-read/unique/0
    CM-CM CM2PM CML FML
    (effects2output/unique/0 _ _ XM=>Pi1 MX=>Pi2 (ty2perm/ PML nn2perm/yes annot2perm/unique))
    %{=>}% _ (ty2perm/ PMFL NN2PF A2AF) _ PML _ MX=>Pi2 _ XM=>Pi1
    ([f] transform/inside [r]
      (transform/implies
        (implies/trans
          (implies/combine
            (implies/trans10
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine
                (implies/equiv equiv/commute)
                (implies/trans
                  (implies/self-implication)
                  (implies/combine-assoc-encumbered)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/reflexive)
                (implies/linear-modus-ponens))
              (implies/combine
                (implies/trans % (r.all->0, P(r))
                  (implies/combine
                    (implies/reflexive)
                    (implies/duplicate))
                  (implies/equiv equiv/associate))
                (implies/trans
                  (implies/equiv-encumbered
                    (equiv/commute)
                    (equiv/reflexive))
                  (implies/combine-assoc-encumbered)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/reflexive)
                (implies/linear-modus-ponens))
              (implies/combine
                (implies/trans3
                  (implies/equiv equiv/commute)
                  (implies/combine
                    (IMP r)
                    (implies/reflexive))
                  (implies/carve))
                (implies/reflexive))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine
                (implies/reflexive)
                (implies/chain-implication)))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate)))))
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF NN2PF PMFL IMP.

%worlds () (reftyping-ok/before-read/unique/0 _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/before-read/unique/0 _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/before-read/unique/0f
  : forall* {B} {CM} {PM} {FM} {C} {XM1} {XM2} {XM} {MX}
    {F} {NN} {A} {FC} {S} {GM2} {Out} {K}
    forall {B-XM: clsmap-cxt-efxmap CM B XM}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>GM2: set+nat2tgtmap S F GM2}
    {GM2=>XM2: tgtmap2efxmap GM2 efx/read XM2} % change efx/read to X later
    {XM1+XM2=XM: efxmap`join XM1 XM2 XM}
    {XM=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique S tgtmap/0 false))
              (effects/ XM MX) Out}
    {SC: same-class B S C} % this should be guaranteed
    {SZ: set`size S (s K)}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi3} {MX=>Pi3: maybe-efx2perm MX Pi3}
    {XM1P} {XM2P} {XM/GM2=XM1+XM2P: select-tgtmap XM GM2 XM1P XM2P}
    {Pi1} {XM1P=>Pi1: efxmap2perm false CM PM B XM1P Pi1}
    {Pi2} {XM2P=>Pi2: efxmap2perm false CM PM B XM2P Pi2}
    {TRANS: {f} transform (Out f)
            (output/exists [r]
              (output/expr r
                (combine (ffperm f r F TF)
                  (combine
                    (unitperm
                      (encumbered
                        (ffperm f r F TF) (Pi2 f)))
                    (combine (Pi1 f) (Pi3 f))))))}
    true.

- : reftyping-ok/before-read/unique/0f
    CM-B-XM CM-CM CM2PM CM-L FM-L
    S+F=>GM2 GM2=>XM2 XM1+XM2=XM
    (effects2output/unique/0f
      SZ-SP tgtmap`size/0 F+XM=>Pi S=>GF MX=>Pi3 _)
    B-S-C SZ-S %{=>}% _ T2PF _ MX=>Pi3
    _ _ XM/GM2=XM1P+XM2P _ F+XM1P=>Pi1P _ F+XM2P=>Pi2P
    ([f] transform/inside [r]
      (transform/trans
        (transform/drop)
        (transform/implies
          (implies/trans3
            (implies/equiv
              (equiv/transitive
                (equiv/combine
                  (equiv/reflexive) % GF
                  (equiv/transitive
                    (equiv/combine
                      (equiv/transitive
                        (Pi<=>Pi1P+Pi2P f)
                        (equiv/commute))
                      (equiv/reflexive))
                    (equiv/symmetric equiv/associate)))
                (equiv/associate)))
            (implies/combine
              (implies/trans4
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine (equiv/reflexive) (EQV f))
                    (equiv/associate)))
                (implies/combine
                  (IMP f r)
                  (implies/trans3
                    (implies/equiv (equiv/symmetric equiv/identity))
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans3
                        (implies/self-implication)
                        (implies/equiv-encumbered
                          (equiv/reflexive)
                          (equiv/transitive
                            (equiv/commute)
                            (equiv/symmetric (EQV f))))
                        (implies/combine-assoc-encumbered)))
                    (implies/linear-modus-ponens)))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/chain-implication)))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))))))
    <- reftyping-ok/before-read/unique/L1 CM-CM CM2PM
      S+F=>GM2 GM2=>XM2 XM1+XM2=XM CM-B-XM _ _
      XM/GM2=XM1P+XM2P CM-B-XM2P XM2<=XM2P NC-XM2P _ T+XM2=>Pi2 _ F+XM1P=>Pi1P
    <- efxmap`leq-implies-permission-leq CM-CM CM2PM CM-B-XM2P T+XM2=>Pi2
      XM2<=XM2P Pi2P Pi3P T+XM2P=>Pi2P ([f] EQV f)
    <- get-field-permission* _ SZ-S B-S-C CM-CM CM2PM CM-L FM-L
      S+F=>GM2 GM2=>XM2 S=>GF T+XM2=>Pi2 _ T2PF ([f][r] IMP f r)
    <- efxmap`no-consume-same-permission NC-XM2P T+XM2P=>Pi2P F+XM2P=>Pi2P
    <- select-tgtmap-implies-permission-combine*
      XM/GM2=XM1P+XM2P F+XM=>Pi F+XM1P=>Pi1P F+XM2P=>Pi2P Pi<=>Pi1P+Pi2P.

%worlds ()
(reftyping-ok/before-read/unique/0f
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(reftyping-ok/before-read/unique/0f
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/before-read/unique/0t
  : forall* {B} {CM} {PM} {FM} {C} {XM1} {XM2} {XM} {MX1} {MX2} {MX}
    {F} {NN} {A} {FC} {S} {GM2} {Out}
    forall {B-XM: clsmap-cxt-efxmap CM B XM}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>GM2: set+nat2tgtmap S F GM2}
    {GM2=>XM2: tgtmap2efxmap GM2 efx/read XM2} % change efx/read to X later
    {XM1+XM2=XM: efxmap`join XM1 XM2 XM}
    {MX1+MX2=MX: maybe-efx`join MX1 MX2 MX}
    {XM=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique S tgtmap/0 true))
              (effects/ XM MX) Out}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi3} {MX=>Pi3: maybe-efx2perm MX Pi3}
    {XM1P} {XM2P} {XM/GM2=XM1+XM2P: select-tgtmap XM GM2 XM1P XM2P}
    {Pi1} {XM1P=>Pi1: efxmap2perm false CM PM B XM1P Pi1}
    {Pi2} {XM2P=>Pi2: efxmap2perm false CM PM B XM2P Pi2}
    {TRANS: {f} transform (Out f)
            (output/exists [r]
              (output/expr r
                (combine (ffperm f r F TF)
                  (combine
                    (unitperm
                      (encumbered
                        (ffperm f r F TF) ((Pi2 f) , (Pi3 f))))
                    (Pi1 f)))))}
    true.

- : reftyping-ok/before-read/unique/0t
    CM-B-XM CM-CM CM2PM CM-L FM-L
    S+F=>GM2 GM2=>XM2 XM1+XM2=XM MX1+MX2=MX
    (effects2output/unique/0t
      tgtmap`size/0 F+XM=>Pi _ MX=>Pi3
      (ty2perm/ PM-L nn2perm/yes annot2perm/unique))
  %{=>}% _ (ty2perm/ PM-FL NN2PF A2AF) _ MX=>Pi3
    _ _ XM/GM2=XM1P+XM2P _ F+XM1P=>Pi1P _ F+XM2P=>Pi2P
    ([f] transform/trans3
      (transform/inside [o]
        (transform/inside [r]
          (transform/drop)))
      (transform/rem-unused)
      (transform/inside [r]
        (transform/implies
          (implies/trans4
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (implies/combine
                  (implies/reflexive)
                  (implies/equiv
                    (equiv/transitive
                      (Pi<=>Pi1P+Pi2P f)
                      (equiv/commute))))
                (implies/equiv equiv/associate)))
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/trans
                (IMP4 f r)
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans3
                        (implies/equiv (equiv/symmetric equiv/identity))
                        (implies/combine
                          (implies/reflexive)
                          (implies/trans
                            (implies/self-implication)
                            (implies/combine-assoc-encumbered)))
                        (implies/linear-modus-ponens)))
                    (implies/chain-implication))))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))))))
    <- reftyping-ok/before-read/unique/L1 CM-CM CM2PM
      S+F=>GM2 GM2=>XM2 XM1+XM2=XM CM-B-XM _ _
      XM/GM2=XM1P+XM2P CM-B-XM2P XM2<=XM2P NC-XM2P Pi2 T+XM2=>Pi2 Pi1P F+XM1P=>Pi1P
    <- efxmap`leq-implies-permission-leq CM-CM CM2PM CM-B-XM2P T+XM2=>Pi2
      XM2<=XM2P Pi2P Pi3P T+XM2P=>Pi2P ([f] EQV f)
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L _ _ _ A2AF NN2PF PM-FL IMP2
    <- efxmap`no-consume-same-permission NC-XM2P T+XM2P=>Pi2P F+XM2P=>Pi2P
    <- select-tgtmap-implies-permission-combine*
      XM/GM2=XM1P+XM2P F+XM=>Pi F+XM1P=>Pi1P F+XM2P=>Pi2P Pi<=>Pi1P+Pi2P
    <- pullout-fldperm IMP2 IMP4.

%worlds ()
(reftyping-ok/before-read/unique/0t
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(reftyping-ok/before-read/unique/0t
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem can-scale-from-shared
  : forall* {PM} {PF} {C} {NN}
    forall {T2PF: ty2perm PM (ty/ NN annot/shared C) PF}
    exists {IMP: {f}{v} implies (scale f (PF v)) (PF v)}
    true.

- : can-scale-from-shared
    (ty2perm/ _ nn2perm/yes annot2perm/shared)
    ([_][_] implies/trans
      (implies/equiv
        (equiv/transitive
          (equiv/distribute)
          (equiv/combine
            (equiv/reflexive)
            (equiv/distribute))))
      (implies/combine
        (implies/scale-from-formula)
        (implies/combine
          (implies/scale-from-formula)
          (implies/scale-from-formula)))).

- : can-scale-from-shared
    (ty2perm/ _ nn2perm/may annot2perm/shared)
    ([_][_] implies/trans
      (implies/scale-distribute-cond)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/zero)
        (implies/trans
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/scale-from-formula)
            (implies/scale-from-formula))))).

%worlds () (can-scale-from-shared _ _).
%total {} (can-scale-from-shared _ _).


%theorem can-scale-from-borrow
  : forall* {PM} {PF} {C} {NN}
    forall {T2PF: ty2perm PM (ty/ NN annot/borrow C) PF}
    exists {IMP: {f}{v} implies (scale f (PF v)) (PF v)}
    true.

- : can-scale-from-borrow
    (ty2perm/ _ nn2perm/yes annot2perm/borrow)
    ([f][v] implies/trans
      (implies/equiv
        (equiv/transitive
          (equiv/distribute)
          (equiv/combine
            (equiv/reflexive)
            (equiv/distribute))))
      (implies/combine
        (implies/scale-from-formula)
        (implies/combine
          (implies/equiv
            (equiv/zero))
          (implies/scale-from-formula)))).

- : can-scale-from-borrow
    (ty2perm/ _ nn2perm/may annot2perm/borrow)
    ([_][_] implies/trans
      (implies/scale-distribute-cond)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/equiv equiv/zero)
        (implies/trans
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/equiv equiv/zero)
            (implies/scale-from-formula))))).

%worlds () (can-scale-from-borrow _ _).
%total {} (can-scale-from-borrow _ _).


%theorem reftyping-ok/read/shared
  : forall* {CM} {PM} {W} {B} {FM} {Pi0} {Pi1} {XX1} {XX2} {XX}
    {GSP} {NN} {A} {FC} {C} {E} {F} {Out}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {TI1: cxt2perm CM PM B Pi0}
    {TI2: effects2input CM PM B XX Pi1}
    {TI3: effects2output CM PM B (reftype/ nn/yes C targets/shared) XX Out}
    {TYE: {f} typing W (Pi0 , (Pi1 f)) E (Out f)}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {MTAE: make-targets-and-effects targets/shared A F efx/read GSP XX2}
    {J: effects`join XX1 XX2 XX}
    exists {Out2} {TO: effects2output CM PM B (reftype/ NN FC GSP) XX Out2}
    {TYP: {f} typing W (Pi0 , (Pi1 f)) (read E F) (Out2 f)}
    true.

- : reftyping-ok/read/shared CM-CM CM2PM B-Pi0 XX=>Pi1 XX=>Out
    TYP-E CML FML (make-targets-and-effects/shared consider-ftype/shared) J
    _ (effects2output/shared XM=>Pi4 MX=>Pi3 T2PF)
        ([f]
      (tTrans2
        (tRead1
          (tTrans2
            (TYP-E f)
            (transform/trans
              (TRANS f)
              (transform/inside [r]
                (transform/trans
                  (transform/skolem)
                  (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
          (letTyping/exists [v]
            (letTyping/exists [r]
              (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans5
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans4
                    (implies/combine
                      (implies/reflexive)
                      (implies/trans
                        (implies/scale (IMP v))
                        (implies/equiv equiv/distribute)))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans
                        (implies/equiv (equiv/symmetric equiv/distribute))
                        (implies/scale (implies/pack v)))
                      (implies/reflexive))
                    (implies/equiv equiv/commute))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans3
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens) implies/reflexive)
                    (implies/equiv equiv/commute)))
                (implies/combine
                  (DIS f v) implies/reflexive)))))
        (transform/rem-unused)))
    <- effects`join-implies-leq J LE1 LE2
    <- reftyping-ok/before-read/shared
      CM-CM CM2PM CML FML LE2 XX=>Out _ _ _ T2PF MX=>Pi3 XM=>Pi4 TRANS
    <- sharedperm-can-be-duplicated* T2PF IMP
    <- can-scale-from-shared T2PF DIS.

- : reftyping-ok/read/shared CM-CM CM2PM B-Pi0 XX=>Pi1 XX=>Out
    TYP-E CML FML (make-targets-and-effects/shared consider-ftype/unique) J
    _ (effects2output/unique/0t tgtmap`size/0 XM=>Pi4
        ([_] set2facts/0) MX=>Pi3 T2PF)
    ([f]
      (tTrans2
        (tRead1
          (tTrans2
            (TYP-E f)
            (transform/trans
              (TRANS f)
              (transform/inside [r]
                (transform/trans
                  (transform/skolem)
                  (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
          (letTyping/exists [v]
            (letTyping/exists [r]
              (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans5
                  (implies/combine
                    (repack-fldperm f v)
                    (implies/reflexive))
                  (implies/equiv equiv/roll2)
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/chain-implication)
                        (implies/reflexive))))
                  (implies/combine
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine
                        (implies/reflexive)
                        (gen-objequal-self v))
                      (implies/equiv equiv/commute))
                    (implies/reflexive))
                  (implies/equiv (equiv/symmetric equiv/associate))))
              (transform/gen-exists v))))
        (transform/rem-unused)))
    <- effects`join-implies-leq J LE1 LE2
    <- reftyping-ok/before-read/shared
      CM-CM CM2PM CML FML LE2 XX=>Out _ _ _ T2PF MX=>Pi3 XM=>Pi4 TRANS.

%worlds () (reftyping-ok/read/shared _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/read/shared _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/before-read/unique/L2
  : forall* {G} {F} {PF} {CP} {Pi2} {Pi12} forall
    {IMP1: {f}{x} implies
          (combine (unitperm (nonlinear (G x))) (Pi12 f))
          (combine (scale f (unitperm (precise-exists x F ([v] PF v))))
            (unitperm
              (encumbered
                (scale f (unitperm (precise-exists x F PF)))
                (Pi12 f))))}
    {IMP2: {x} implies (one-predcall CP x)
           (unitperm
             (nonlinear
               (nested (unitperm (precise-exists x F PF)) x all)))}
    exists {Pi}
    {IMP: {f}{o}{x} implies
          (combine
            (unitperm (nonlinear (disj (objequal o x) (G o))))
            (combine
              (scale f (nonnull-unique-perm x CP))
              (combine
                (unitperm
                  (encumbered (scale f (nonnull-unique-perm x CP))
                    (Pi2 f)))
                (Pi12 f))))
          (combine
            (combine
              (scale f (unitperm (precise-exists o F PF)))
              (unitperm
                (encumbered
                  (scale f (unitperm (precise-exists o F PF)))
                  (combine (Pi12 f) (Pi2 f)))))
            (Pi o x))}
    true.

- : reftyping-ok/before-read/unique/L2 IMP1 IMP2 _
    ([f][o][x]
      (implies/trans5
        (implies/combine
          (implies/trans
            (implies/disj2cond)
            (implies/cond-gen-inner))
          (implies/reflexive))
        (implies/equiv equiv/commute)
        (implies/cond-push)
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/trans9
            (implies/combine
              (implies/equiv equiv/associate)
              (implies/equiv equiv/identity))
            (implies/equiv equiv/commute)
            (implies/equiv equiv/associate)
            (implies/combine
              (implies/trans
                (implies/combine
                  (implies/nonlinear bimplies/objequal-symmetric)
                  (implies/reflexive))
                (implies/objequal
                  ([o] (scale f (nonnull-unique-perm o CP)) ,
                    (unitperm
                      (encumbered (scale f (nonnull-unique-perm o CP))
                        (Pi2 f))))))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (add-encumber)
                (implies/equiv-encumbered
                  (equiv/reflexive)
                  (equiv/commute))))
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/identity)
                (equiv/symmetric equiv/associate)))
            (IMP2' f o)
            (implies/equiv equiv/associate))
          (implies/trans3
            (implies/equiv
              (equiv/transitive
                (equiv/commute)
                (equiv/symmetric equiv/associate)))
            (implies/combine
              (implies/reflexive)
              (implies/trans5
                (implies/combine % (G , (Pf, (Pf --|- P2 , P12)))
                  (implies/reflexive)
                  (implies/trans3
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv equiv/commute)))
                (implies/equiv equiv/associate)
                (implies/combine
                  (IMP1 f o)
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (add-encumber))))
            (implies/equiv equiv/commute)))
        (implies/cond-pull)))
    <- pullout-fldperm IMP2 IMP2'.

%worlds () (reftyping-ok/before-read/unique/L2 _ _ _ _).
%total {} (reftyping-ok/before-read/unique/L2 _ _ _ _).


%theorem combine-fldperm
  : forall* {S} {B} {C} {CM} {PM} {FM}
    {NN} {A} {FC} {G} {F} {GM} {XM} {Pi} {PF}
    forall {K} {Z: set`size S (s K)}
    {SC: same-class B S C}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {S2GM: set+nat2tgtmap S F GM}
    {S2G: {x} set2facts x S (G x)}
    {M2P: efxmap2perm true CM PM B XM Pi}
    {XM2GM: efxmap2tgtmap XM GM}
    {T2PF: ty2perm PM (ty/ NN A FC) PF}
    exists {IMP: {f}{x} implies
          (combine (unitperm (nonlinear (G x)))
            (Pi f))
          (combine (scale f (unitperm (precise-exists x F ([v] PF v))))
            (unitperm (encumbered
                        (scale f (unitperm (precise-exists x F PF)))
                        (Pi f))))}
    true.

%worlds () (combine-fldperm _ _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {} (combine-fldperm _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/before-read/unique/+f
  : forall* {B} {CM} {PM} {FM} {C} {XM1} {XM2} {XM} {N1} {N2}
    {MX} {F} {NN} {A} {FC} {GM1} {GM2} {Out} {GM}
    forall {S} {SZ: tgtmap`size GM1 (s N1)}
    {CM-B-XM: clsmap-cxt-efxmap CM B XM}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CL: clsmap`lookup CM C FM}
    {FL: fldmap`lookup FM F (ty/ NN A FC)}
    {GM1<=XM1: tgtmap`leq-efxmap GM1 XM1}
    {S=>GM2: set+nat2tgtmap S F GM2}
    {GM1^GM2: tgtmap`deep-disjoint GM1 GM2}
    {GM1+GM2=GM: tgtmap`join GM1 GM2 GM}
    {GM=>XM2: tgtmap2efxmap GM efx/read XM2}
    {XM1+XM2=XM: efxmap`join XM1 XM2 XM}
    {XM=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique S GM1 false))
              (effects/ XM MX) Out}
    {SOC: same-class B S C}
    {SZ: set`size S N2}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi3} {MX=>Pi3: maybe-efx2perm MX Pi3}
    {XM1P} {XM2P} {XM+GM=>XM1P+XM2P: select-tgtmap XM GM XM1P XM2P}
    {Pi1} {XM1P=>Pi1: efxmap2perm false CM PM B XM1P Pi1}
    {Pi2} {XM2P=>Pi2: efxmap2perm false CM PM B XM2P Pi2}
    {TRANS: {f} transform (Out f)
            (output/exists [o]
              (output/expr o
                (combine (ffperm f o F TF)
                  (combine
                    (unitperm
                      (encumbered
                        (ffperm f o F TF) ((Pi2 f))))
                    (combine (Pi1 f) (Pi3 f))))))}
    true.

%theorem reftyping-ok/before-read/unique/+f/F
  : forall* {CM} {PM} {B} {NN} {A} {FC} {XM} {GM} {MX} {Out} {F}
    forall {V:void}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi3} {MX=>Pi3: maybe-efx2perm MX Pi3}
    {XM1P} {XM2P} {XM+GM=>XM1P+XM2P: select-tgtmap XM GM XM1P XM2P}
    {Pi1} {XM1P=>Pi1: efxmap2perm false CM PM B XM1P Pi1}
    {Pi2} {XM2P=>Pi2: efxmap2perm false CM PM B XM2P Pi2}
    {TRANS: {f} transform (Out f)
            (output/exists [o]
              (output/expr o
                (combine (ffperm f o F TF)
                  (combine
                    (unitperm
                      (encumbered
                        (ffperm f o F TF) ((Pi2 f))))
                    (combine (Pi1 f) (Pi3 f))))))}
    true.

%worlds () (reftyping-ok/before-read/unique/+f/F _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/before-read/unique/+f/F _ _ _ _ _ _ _ _ _ _ _ _ _).

- : reftyping-ok/before-read/unique/+f _ _ _ _ _ _ _ _
    (S=>GM2:set+nat2tgtmap set/0 _ (tgtmap/+ _ _ _))
    _ _ _ _ _ _ _ _ K1 K2 K3 K4 K5 K6 K7 K8 K9 K10 K11
    <- tgtmap`size-total MZ
    <- set+nat2tgtmap-preserves-size-converse S=>GM2 MZ SZ
    <- set`size-unique set`size/0 SZ set`eq/ E
    <- nat`eq-contradiction E V
    <- reftyping-ok/before-read/unique/+f/F V _ K1 K2 K3 K4 K5 K6 K7 K8 K9 K10 K11.

- : reftyping-ok/before-read/unique/+f set/0 _
    CM-B-XM CM-CM CM2PM CML FML GM1<=XM1 _ _ tgtmap`join/R
    (GM1=>XM2:tgtmap2efxmap GM1 efx/read XM2)
    (XM1+XM2=XM:efxmap`join XM1 XM2 XM)
    (effects2output/unique/+f
      _ (XM+GM1=>XM3+XM4:select-tgtmap XM GM1 XM3 XM4)
      (XM3=>Pi1:efxmap2perm _ _ _ _ XM3 Pi1)
      (XM4=>Pi2:efxmap2perm _ _ _ _ XM4 Pi2) ([_] set2facts/0)
      (MX=>Pi3:maybe-efx2perm MX Pi3)
      (ty2perm/ PML nn2perm/yes annot2perm/unique))
    _ _ _ (ty2perm/ PML2 NN2PF2 A2AF2) _ MX=>Pi3
    _ _ XM+GM1=>XM3+XM4 _ XM3=>Pi1 _ XM4=>Pi2
    ([f]
      (transform/inside [o]
        (transform/trans
          (transform/inside [r]
            (transform/implies
              (implies/trans3
                (implies/combine
                  (implies/nonlinear
                    (bimplies/trans
                      (bimplies/neg
                        (bimplies/trans
                          (bimplies/conj/XX
                            (bimplies/reflexive)
                            (bimplies/rem-negneg))
                          (bimplies/conj-true))
                        (bool`ne/FT))
                      (bimplies/trans
                        (bimplies/rem-negneg)
                        (bimplies/objequal-symmetric))))
                  (implies/reflexive))
                (implies/objequal
                  ([x] (combine (scale f (nonnull-unique-perm x CP))
                         (combine
                           (unitperm
                             (encumbered
                               (scale f (nonnull-unique-perm x CP))
                               (Pi2 f)))
                           (combine (Pi1 f) (Pi3 f))))))
                (IMP2 f o))))
          (transform/rem-unused))))
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- pullout-fldperm IMP IMP2.

- : reftyping-ok/before-read/unique/+f (set/+ _ _) _
    CM-B-XM CM-CM CM2PM CML FML GM1<=XM1 S=>GM2 GM1^GM2
    (GM1+GM2=GM:tgtmap`join GM1 GM2 GM)
    (GM=>XM2:tgtmap2efxmap GM efx/read XM2)
    (XM1+XM2=XM:efxmap`join XM1 XM2 XM)
    (effects2output/unique/+f
      _ (XM+GM1=>XM3+XM4:select-tgtmap XM GM1 XM3 XM4)
      (XM3=>Pi1:efxmap2perm _ _ _ _ XM3 Pi1)
      (XM4=>Pi2:efxmap2perm _ _ _ _ XM4 Pi2) S=>GF
      (MX=>Pi3:maybe-efx2perm MX Pi3)
      (ty2perm/ PML nn2perm/yes annot2perm/unique))
    SOC S-SZ _ (ty2perm/ PML2 NN2PF2 A2AF2) _ MX=>Pi3
    XM5 XM7 XM+GM=>XM5+XM7 Pi11 XM5=>Pi11 Pi12+Pi2 XM7=>Pi12+Pi2
    ([f]
      (transform/inside [o]
        (transform/trans
          (transform/inside [r]
            (transform/trans
              (transform/implies
                (implies/trans4
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/combine
                            (implies/reflexive)
                            (implies/trans
                              (implies/combine
                                (implies/equiv
                                  (equiv/transitive
                                    (Pi1<=>Pi11+Pi12 f)
                                    (equiv/commute)))
                                (implies/reflexive))
                              (implies/equiv
                                (equiv/symmetric
                                  equiv/associate))))
                          (implies/equiv equiv/associate)))
                      (implies/equiv equiv/associate)))
                  (implies/equiv equiv/associate)
                  (implies/combine
                    (implies/trans
                      (IMP4 f o r)
                      (implies/combine
                        (implies/combine
                          (implies/reflexive)
                          (implies/equiv-encumbered
                            (equiv/reflexive)
                            (EQV f)))
                        (implies/reflexive)))
                    (implies/reflexive))
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine
                        (equiv/commute)
                        (equiv/reflexive))
                      (equiv/symmetric equiv/associate)
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/symmetric equiv/associate))))))
              (transform/drop)))
          (transform/rem-unused))))
    <- select-tgtmap-total (XM3+GM2=>XM5+XM6:select-tgtmap XM3 GM2 XM5 XM6)
    <- efxmap`join-implies-leq XM1+XM2=XM XM1<=XM XM2<=XM
    <- tgtmap`join-implies-leq GM1+GM2=GM GM1<=GM GM2<=GM
    <- tgtmap2efxmap-implies-leq-efxmap GM=>XM2 GM<=XM2
    <- tgtmap`leq-efxmap-right-transitive GM1<=XM1 XM1<=XM GM1<=XM
    <- tgtmap`leq-efxmap-transitive GM<=XM2 GM2<=GM XM2<=XM GM2<=XM
    <- set+nat2tgtmap-implies-no-empty S=>GM2 NE-GM2
    <- select-tgtmap-deep-disjoint-leq-implies-leq
      NE-GM2 XM+GM1=>XM3+XM4 GM1^GM2 GM1<=XM GM2<=XM GM2<=XM3
    <- select-tgtmap-associates XM+GM1=>XM3+XM4
      XM3+GM2=>XM5+XM6 GM1<=XM GM2<=XM3 GM1^GM2
      GM1+GM2=GM XM7 (XM6^XM4:efxmap`deep-disjoint XM6 XM4)
      (XM6+XM4=XM7:efxmap`join XM6 XM4 XM7)
      (XM+GM=>XM5+XM7:select-tgtmap XM GM XM5 XM7)
    <- tgtmap2efxmap-implies-efxmap2tgtmap GM=>XM2 XM2=>GM
    <- tgtmap2efxmap-no-consume efx`not-consume/read GM=>XM2 NC-XM2
    <- efxmap`join-no-consume-right
      XM2=>GM NC-XM2 XM1+XM2=XM XM+GM=>XM5+XM7 NC-XM7
    <- efxmap`join-implies-leq XM6+XM4=XM7 XM6<=XM7 XM4<=XM7
    <- efxmap`no-consume-respects-geq NC-XM7 XM6<=XM7 NC-XM6
    <- select-tgtmap-implies-permission-combine
      XM3+GM2=>XM5+XM6 XM3=>Pi1 Pi11 Pi12
      (XM5=>Pi11:efxmap2perm _ _ _ _ XM5 Pi11)
      (XM6=>Pi12:efxmap2perm _ _ _ _ XM6 Pi12) Pi1<=>Pi11+Pi12
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- efxmap`deep-disjoint-join-implies-equiv-converse
      XM6^XM4 XM6+XM4=XM7 XM6=>Pi12 XM4=>Pi2 Pi12+Pi2 XM7=>Pi12+Pi2 EQV
    <- efxmap`no-consume-same-permission-converse NC-XM6 XM6=>Pi12 T+XM6=>Pi12
    <- select-tgtmap-implies-efxmap2tgtmap XM3+GM2=>XM5+XM6 GM2<=XM3 XM6=>GM2
    <- combine-fldperm _ S-SZ SOC CM-CM CM2PM CML FML S=>GM2 S=>GF
      T+XM6=>Pi12 XM6=>GM2 (ty2perm/ PML2 NN2PF2 A2AF2) IMP3
    <- reftyping-ok/before-read/unique/L2 IMP3 IMP _ IMP4.

%worlds ()
(reftyping-ok/before-read/unique/+f
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(reftyping-ok/before-read/unique/+f
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/before-read/unique/+t
  : forall* {B} {CM} {PM} {FM} {C} {XM1} {XM2} {XM} {N1} {N2}
    {MX} {F} {NN} {A} {FC} {GM1} {GM2} {Out} {GM}
    forall {S} {SZ: tgtmap`size GM1 (s N1)}
    {CM-B-XM: clsmap-cxt-efxmap CM B XM}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CL: clsmap`lookup CM C FM}
    {FL: fldmap`lookup FM F (ty/ NN A FC)}
    {GM1<=XM1: tgtmap`leq-efxmap GM1 XM1}
    {S=>GM2: set+nat2tgtmap S F GM2}
    {GM1^GM2: tgtmap`deep-disjoint GM1 GM2}
    {GM1+GM2=GM: tgtmap`join GM1 GM2 GM}
    {GM=>XM2: tgtmap2efxmap GM efx/read XM2}
    {XM1+XM2=XM: efxmap`join XM1 XM2 XM}
    {XM=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique S GM1 true))
              (effects/ XM MX) Out}
    {SOC: same-class B S C}
    {SZ: set`size S N2}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi3} {MX=>Pi3: maybe-efx2perm MX Pi3}
    {XM1P} {XM2P} {XM+GM=>XM1P+XM2P: select-tgtmap XM GM XM1P XM2P}
    {Pi1} {XM1P=>Pi1: efxmap2perm false CM PM B XM1P Pi1}
    {Pi2} {XM2P=>Pi2: efxmap2perm false CM PM B XM2P Pi2}
    {TRANS: {f} transform (Out f)
            (output/exists [o]
              (output/expr o
                (combine (ffperm f o F TF)
                  (combine
                    (unitperm
                      (encumbered
                        (ffperm f o F TF) (combine (Pi2 f) (Pi3 f))))
                    (Pi1 f)))))}
    true.

%theorem reftyping-ok/before-read/unique/+t/F
  : forall* {CM} {PM} {B} {NN} {A} {FC} {XM} {GM} {MX} {Out} {F}
    forall {V:void}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi3} {MX=>Pi3: maybe-efx2perm MX Pi3}
    {XM1P} {XM2P} {XM+GM=>XM1P+XM2P: select-tgtmap XM GM XM1P XM2P}
    {Pi1} {XM1P=>Pi1: efxmap2perm false CM PM B XM1P Pi1}
    {Pi2} {XM2P=>Pi2: efxmap2perm false CM PM B XM2P Pi2}
    {TRANS: {f} transform (Out f)
            (output/exists [o]
              (output/expr o
                (combine (ffperm f o F TF)
                  (combine
                    (unitperm
                      (encumbered
                        (ffperm f o F TF) (combine (Pi2 f) (Pi3 f))))
                    (Pi1 f)))))}
    true.

%worlds () (reftyping-ok/before-read/unique/+t/F _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/before-read/unique/+t/F _ _ _ _ _ _ _ _ _ _ _ _ _).

- : reftyping-ok/before-read/unique/+t _ _ _ _ _ _ _ _
    (S=>GM2:set+nat2tgtmap set/0 _ (tgtmap/+ _ _ _))
    _ _ _ _ _ _ _ _ K1 K2 K3 K4 K5 K6 K7 K8 K9 K10 K11
    <- tgtmap`size-total MZ
    <- set+nat2tgtmap-preserves-size-converse S=>GM2 MZ SZ
    <- set`size-unique set`size/0 SZ set`eq/ E
    <- nat`eq-contradiction E V
    <- reftyping-ok/before-read/unique/+t/F V _ K1 K2 K3 K4 K5 K6 K7 K8 K9 K10 K11.

- : reftyping-ok/before-read/unique/+t set/0 _
    CM-B-XM CM-CM CM2PM CML FML GM1<=XM1 _ _ tgtmap`join/R
    (GM1=>XM2:tgtmap2efxmap GM1 efx/read XM2)
    (XM1+XM2=XM:efxmap`join XM1 XM2 XM)
    (effects2output/unique/+t
      _ (XM+GM1=>XM3+XM4:select-tgtmap XM GM1 XM3 XM4)
      (XM3=>Pi1:efxmap2perm _ _ _ _ XM3 Pi1)
      (XM4=>Pi2:efxmap2perm _ _ _ _ XM4 Pi2) ([_] set2facts/0)
      (MX=>Pi3:maybe-efx2perm MX Pi3)
      (ty2perm/ PML nn2perm/yes annot2perm/unique))
    _ _ _ (ty2perm/ PML2 NN2PF2 A2AF2) _ MX=>Pi3
    _ _ XM+GM1=>XM3+XM4 _ XM3=>Pi1 _ XM4=>Pi2
    ([f]
      (transform/inside [o]
        (transform/trans
          (transform/inside [r]
            (transform/implies
              (implies/trans3
                (implies/combine
                  (implies/nonlinear
                    (bimplies/trans
                      (bimplies/neg
                        (bimplies/trans
                          (bimplies/conj/XX
                            (bimplies/reflexive)
                            (bimplies/rem-negneg))
                          (bimplies/conj-true))
                        (bool`ne/FT))
                      (bimplies/trans
                        (bimplies/rem-negneg)
                        (bimplies/objequal-symmetric))))
                  (implies/reflexive))
                (implies/objequal
                  ([x] (combine (scale f (nonnull-unique-perm x CP))
                         (combine
                           (unitperm
                             (encumbered
                               (scale f (nonnull-unique-perm x CP))
                               (combine (Pi2 f) (Pi3 f))))
                           (Pi1 f)))))
                (IMP2 f o))))
          (transform/rem-unused))))
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- pullout-fldperm IMP IMP2.

- : reftyping-ok/before-read/unique/+t (set/+ _ _) _
    CM-B-XM CM-CM CM2PM CML FML GM1<=XM1 S=>GM2 GM1^GM2
    (GM1+GM2=GM:tgtmap`join GM1 GM2 GM)
    (GM=>XM2:tgtmap2efxmap GM efx/read XM2)
    (XM1+XM2=XM:efxmap`join XM1 XM2 XM)
    (effects2output/unique/+t
      _ (XM+GM1=>XM3+XM4:select-tgtmap XM GM1 XM3 XM4)
      (XM3=>Pi1:efxmap2perm _ _ _ _ XM3 Pi1)
      (XM4=>Pi2:efxmap2perm _ _ _ _ XM4 Pi2) S=>GF
      (MX=>Pi3:maybe-efx2perm MX Pi3)
      (ty2perm/ PML nn2perm/yes annot2perm/unique))
    SOC S-SZ _ (ty2perm/ PML2 NN2PF2 A2AF2) _ MX=>Pi3
    XM5 XM7 XM+GM=>XM5+XM7 Pi11 XM5=>Pi11 Pi12+Pi2 XM7=>Pi12+Pi2
    ([f]
      (transform/inside [o]
        (transform/trans
          (transform/inside [r]
            (transform/trans
              (transform/implies
                (implies/trans4
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/combine
                        (implies/reflexive)
                        (implies/trans
                          (implies/combine
                            (implies/reflexive)
                            (implies/equiv
                              (equiv/transitive
                                (Pi1<=>Pi11+Pi12 f)
                                (equiv/commute))))
                          (implies/equiv equiv/associate)))
                      (implies/equiv equiv/associate)))
                  (implies/equiv equiv/associate)
                  (implies/combine
                    (implies/trans
                      (IMP4 f o r)
                      (implies/combine
                        (implies/combine
                          (implies/reflexive)
                          (implies/equiv-encumbered
                            (equiv/reflexive)
                            (equiv/transitive
                              (equiv/associate)
                              (equiv/combine
                                (EQV f)
                                (equiv/reflexive)))))
                        (implies/reflexive)))
                    (implies/reflexive))
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine
                        (equiv/commute)
                        (equiv/reflexive))
                      (equiv/symmetric equiv/associate)
                      (equiv/combine
                        (equiv/reflexive)
                        (equiv/symmetric equiv/associate))))))
              (transform/drop)))
          (transform/rem-unused))))
    <- select-tgtmap-total (XM3+GM2=>XM5+XM6:select-tgtmap XM3 GM2 XM5 XM6)
    <- efxmap`join-implies-leq XM1+XM2=XM XM1<=XM XM2<=XM
    <- tgtmap`join-implies-leq GM1+GM2=GM GM1<=GM GM2<=GM
    <- tgtmap2efxmap-implies-leq-efxmap GM=>XM2 GM<=XM2
    <- tgtmap`leq-efxmap-right-transitive GM1<=XM1 XM1<=XM GM1<=XM
    <- tgtmap`leq-efxmap-transitive GM<=XM2 GM2<=GM XM2<=XM GM2<=XM
    <- set+nat2tgtmap-implies-no-empty S=>GM2 NE-GM2
    <- select-tgtmap-deep-disjoint-leq-implies-leq
      NE-GM2 XM+GM1=>XM3+XM4 GM1^GM2 GM1<=XM GM2<=XM GM2<=XM3
    <- select-tgtmap-associates XM+GM1=>XM3+XM4
      XM3+GM2=>XM5+XM6 GM1<=XM GM2<=XM3 GM1^GM2
      GM1+GM2=GM XM7 (XM6^XM4:efxmap`deep-disjoint XM6 XM4)
      (XM6+XM4=XM7:efxmap`join XM6 XM4 XM7)
      (XM+GM=>XM5+XM7:select-tgtmap XM GM XM5 XM7)
    <- tgtmap2efxmap-implies-efxmap2tgtmap GM=>XM2 XM2=>GM
    <- tgtmap2efxmap-no-consume efx`not-consume/read GM=>XM2 NC-XM2
    <- efxmap`join-no-consume-right
      XM2=>GM NC-XM2 XM1+XM2=XM XM+GM=>XM5+XM7 NC-XM7
    <- efxmap`join-implies-leq XM6+XM4=XM7 XM6<=XM7 XM4<=XM7
    <- efxmap`no-consume-respects-geq NC-XM7 XM6<=XM7 NC-XM6
    <- select-tgtmap-implies-permission-combine
      XM3+GM2=>XM5+XM6 XM3=>Pi1 Pi11 Pi12
      (XM5=>Pi11:efxmap2perm _ _ _ _ XM5 Pi11)
      (XM6=>Pi12:efxmap2perm _ _ _ _ XM6 Pi12) Pi1<=>Pi11+Pi12
    <- fldperm-can-lookup CM2PM PML CML FML _ _ _ A2AF2 NN2PF2 PML2 IMP
    <- efxmap`deep-disjoint-join-implies-equiv-converse
      XM6^XM4 XM6+XM4=XM7 XM6=>Pi12 XM4=>Pi2 Pi12+Pi2 XM7=>Pi12+Pi2 EQV
    <- efxmap`no-consume-same-permission-converse NC-XM6 XM6=>Pi12 T+XM6=>Pi12
    <- select-tgtmap-implies-efxmap2tgtmap XM3+GM2=>XM5+XM6 GM2<=XM3 XM6=>GM2
    <- combine-fldperm _ S-SZ SOC CM-CM CM2PM CML FML S=>GM2 S=>GF
      T+XM6=>Pi12 XM6=>GM2 (ty2perm/ PML2 NN2PF2 A2AF2) IMP3
    <- reftyping-ok/before-read/unique/L2 IMP3 IMP _ IMP4.

%worlds ()
(reftyping-ok/before-read/unique/+t
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(reftyping-ok/before-read/unique/+t
 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%%% tedius transformations


%theorem ge-succ-implies-succ
  : forall* {N1} {N2}
    forall {GE: nat`ge N1 (s N2)}
    exists {N3} {E: nat`eq N1 (s N3)}
    true.

- : ge-succ-implies-succ (nat`ge/= nat`eq/) _ nat`eq/.

- : ge-succ-implies-succ (nat`ge/> GT) _ EQ
    <- nat`gt-implies-positive GT _ EQ.

%worlds () (ge-succ-implies-succ _ _ _).
%total (G) (ge-succ-implies-succ G _ _).


%theorem reftyping-ok/read/unique
  : forall* {CM} {PM} {W} {B} {FM} {Pi} {XM1} {MX1} {XX2}
    {GSP} {NN} {A} {FC} {C} {E} {F} {Out} {XM} {MX}
    forall {S} {GM} {SB}
    {B-XM: clsmap-cxt-efxmap CM B XM}
    {SOC: same-class B S C}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {TI: effects2output CM PM B
          (reftype/ nn/yes C (targets/unique S GM SB)) (effects/ XM MX) Out}
    {GM<=XM: tgtmap`leq-efxmap GM XM1}
    {TYE: {f} typing W (Pi f) E (Out f)}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {MTAE: make-targets-and-effects (targets/unique S GM SB) A F efx/read GSP XX2}
    {J: effects`join (effects/ XM1 MX1) XX2 (effects/ XM MX)}
    exists {Out2} {TO: effects2output CM PM
                       B (reftype/ NN FC GSP) (effects/ XM MX) Out2}
    {TYP: {f} typing W (Pi f) (read E F) (Out2 f)}
    true.

- : reftyping-ok/read/unique _ (tgtmap/+ _ _ _) true
    B-XM SOC CM-CM CM2PM XX=>Out GM<=XM TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>GM2 GM1^GM2 GM1+GM2=GM GM=>XM _ (consider-ftype/shared))
    (effects`join/ J-XM _) _ (effects2output/shared XM=>Pi MX=>Pi3 T2PF)
    ([f] tTrans2
      (tRead1
        (tTrans2
          (TYP-E f)
          (transform/trans
            (TRANS f)
            (transform/inside [r]
              (transform/trans
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          equiv/distribute equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans6
                (implies/combine
                  (repack-fldperm f v)
                  (implies/reflexive))
                (implies/equiv equiv/roll2)
                (implies/combine
                  (implies/trans
                    (implies/scale (DUP v))
                    (implies/equiv equiv/distribute))
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/chain-implication)
                      (implies/reflexive))))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans3
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/commute)
                        (equiv/associate)
                        (equiv/combine
                          (EQV f)
                          (equiv/reflexive))))))
                (implies/combine
                  (DIS f v) (implies/reflexive))))))
        (transform/rem-unused)))
    <- set`size-total S-SZ
    <- tgtmap`size-total M-SZ
      <- reftyping-ok/before-read/unique/+t _ M-SZ B-XM CM-CM CM2PM CML FML
      GM<=XM S+F=>GM2 GM1^GM2 GM1+GM2=GM GM=>XM J-XM
      XX=>Out SOC S-SZ _ T2PF _ MX=>Pi3 _ _ SG _ XM1=>Pi3 _ XM2=>Pi4 TRANS
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- can-scale-from-shared T2PF DIS
    <- select-tgtmap-implies-permission-combine-converse
      SG XM1=>Pi3 XM2=>Pi4 _ XM=>Pi EQV.

- : reftyping-ok/read/unique _ (tgtmap/+ _ _ _) true
    B-XM SOC CM-CM CM2PM XX=>Out GM<=XM TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>GM2 GM1^GM2 GM1+GM2=GM GM=>XM _ consider-ftype/unique)
    (effects`join/ (J-XM) _) _
    (effects2output/unique/+t
      SZ-MP SG XM1=>Pi3 XM2=>Pi4 ([_] set2facts/0) MX=>Pi3 T2PF)
    ([f] tTrans2
      (tRead1
        (tTrans2
          (TYP-E f)
          (transform/trans
            (TRANS f)
            (transform/inside [r]
              (transform/trans
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          equiv/distribute equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans5
                  (implies/combine
                    (repack-fldperm f v)
                    (implies/reflexive))
                  (implies/equiv equiv/roll2)
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/chain-implication)
                        (implies/reflexive))))
                  (implies/combine
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine
                        (implies/reflexive)
                        (gen-objequal-self v))
                      (implies/equiv equiv/commute))
                    (implies/reflexive))
                  (implies/equiv (equiv/symmetric equiv/associate))))
              (transform/gen-exists v))))
        (transform/rem-unused)))
    <- set`size-total SZ-S
    <- tgtmap`size-total SZ-M1
    <- tgtmap`join-implies-leq GM1+GM2=GM GM1<=GM _
    <- tgtmap`size-total SZ-M
    <- tgtmap`leq-implies-size-le GM1<=GM SZ-M1 SZ-M LE
    <- ge-succ-implies-succ LE _ EQ
    <- tgtmap`size-respects-eq SZ-M tgtmap`eq/ EQ SZ-MP
    <- reftyping-ok/before-read/unique/+t _ SZ-M1 B-XM CM-CM CM2PM CML FML
      GM<=XM S+F=>GM2 GM1^GM2 GM1+GM2=GM GM=>XM J-XM
      XX=>Out SOC SZ-S _ T2PF _ MX=>Pi3 _ _ SG _ XM1=>Pi3 _ XM2=>Pi4 TRANS.

- : reftyping-ok/read/unique _ (tgtmap/+ _ _ _) false
    B-XM SOC CM-CM CM2PM XX=>Out GM<=XM TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>GM2 GM1^GM2 GM1+GM2=GM GM=>XM _ consider-ftype/unique)
    (effects`join/ (J-XM) _) _
    (effects2output/unique/+f
      SZ-MP SG XM1=>Pi3 XM2=>Pi4 ([_] set2facts/0) MX=>Pi3 T2PF)
    ([f] tTrans2
      (tRead1
        (tTrans2
          (TYP-E f)
          (transform/trans
            (TRANS f)
            (transform/inside [r]
              (transform/trans
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          equiv/distribute equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans5
                  (implies/combine
                    (repack-fldperm f v)
                    (implies/reflexive))
                  (implies/equiv equiv/roll2)
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/chain-implication)
                        (implies/reflexive))))
                  (implies/combine
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine
                        (implies/reflexive)
                        (gen-objequal-self v))
                      (implies/equiv equiv/commute))
                    (implies/reflexive))
                  (implies/equiv (equiv/symmetric equiv/associate))))
              (transform/gen-exists v))))
        (transform/rem-unused)))
    <- set`size-total SZ-S
    <- tgtmap`size-total SZ-M1
    <- tgtmap`join-implies-leq GM1+GM2=GM GM1<=GM GM2<=GM
    <- tgtmap`size-total SZ-M
    <- tgtmap`leq-implies-size-le GM1<=GM SZ-M1 SZ-M LE
    <- ge-succ-implies-succ LE _ EQ
    <- tgtmap`size-respects-eq SZ-M tgtmap`eq/ EQ SZ-MP
    <- reftyping-ok/before-read/unique/+f _ SZ-M1 B-XM CM-CM CM2PM CML FML
      GM<=XM S+F=>GM2 GM1^GM2 GM1+GM2=GM GM=>XM J-XM
      XX=>Out SOC SZ-S _ T2PF _ MX=>Pi3 _ _ SG _ XM1=>Pi3 _ XM2=>Pi4 TRANS.

- : reftyping-ok/read/unique _ (tgtmap/+ _ _ _) false
    B-XM SOC CM-CM CM2PM
    XX=>Out GM<=XM TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>GM2 GM1^GM2 GM1+GM2=GM GM=>XM (efx-on-shared/false) (consider-ftype/shared))
    (effects`join/ J-XM _) _ (effects2output/shared XM=>Pi MX=>Pi3 T2PF)
    ([f]
      (tTrans2
        (tRead1
          (tTrans2
            (TYP-E f)
            (transform/trans
              (TRANS f)
              (transform/inside [r]
                (transform/trans
                  (transform/skolem)
                  (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
          (letTyping/exists [v]
            (letTyping/exists [r]
              (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans6
                (implies/combine
                  (repack-fldperm f v)
                  (implies/reflexive))
                (implies/equiv equiv/roll2)
                (implies/combine
                  (implies/trans
                    (implies/scale (DUP v))
                    (implies/equiv equiv/distribute))
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/chain-implication)
                      (implies/reflexive))))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans4
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/equiv
                        (equiv/transitive
                          (equiv/commute)
                          (EQV f)))
                      (implies/reflexive))))
                (implies/combine (DIS f v) implies/reflexive)))))
        (transform/rem-unused)))
    <- set`size-total S-SZ
    <- tgtmap`size-total M-SZ
    <- reftyping-ok/before-read/unique/+f _ M-SZ B-XM CM-CM CM2PM CML FML
      GM<=XM S+F=>GM2 GM1^GM2 GM1+GM2=GM GM=>XM J-XM
      XX=>Out SOC S-SZ _ T2PF _ MX=>Pi3 _ _ SG _ XM1=>Pi3 _ XM2=>Pi4 TRANS
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- can-scale-from-shared T2PF DIS
    <- select-tgtmap-implies-permission-combine-converse
      SG XM1=>Pi3 XM2=>Pi4 _ XM=>Pi EQV.

%theorem reftyping-ok/read/unique/F
  : forall* {CM} {PM} {B} {NN} {FC} {GSP} {XM} {MX} {W} {Pi} {E} {F}
    forall {V:void}
    exists {Out2}
    {TO: effects2output CM PM
         B (reftype/ NN FC GSP) (effects/ XM MX) Out2}
    {TYP: {f} typing W (Pi f) (read E F) (Out2 f)}
    true.

%worlds () (reftyping-ok/read/unique/F _ _ _ _).
%total {} (reftyping-ok/read/unique/F _ _ _ _).

- : reftyping-ok/read/unique (set/+ _ _) _ _ _ _ _ _ _ _ _ _ _
    (make-targets-and-effects/unique
      (S+F=>GM: set+nat2tgtmap _ F tgtmap/0)
      _ _ _ _ _) _ K1 K2 K3
    <- set`size-total SZ
    <- set+nat2tgtmap-preserves-size S+F=>GM SZ MZ
    <- tgtmap`size-unique tgtmap`size/0 MZ tgtmap`eq/ E
    <- nat`eq-contradiction E V
    <- reftyping-ok/read/unique/F V K1 K2 K3.

- : reftyping-ok/read/unique set/0 _ _ _ _ _ _ _ _ _ _ _
    (make-targets-and-effects/unique
      (S+F=>GM: set+nat2tgtmap set/0 _ (tgtmap/+ _ _ _))
      _ _ _ _ _) _ K1 K2 K3
    <- tgtmap`size-total SZ
    <- set+nat2tgtmap-preserves-size-converse S+F=>GM SZ SZx
    <- set`size-unique set`size/0 SZx set`eq/ E
    <- nat`eq-contradiction E V
    <- reftyping-ok/read/unique/F V K1 K2 K3.

- : reftyping-ok/read/unique _ _ _ _ _ _ _ _ _ _ _ _
    (make-targets-and-effects/unique
      _ _ _ (T:tgtmap2efxmap tgtmap/0 _ (efxmap/+ _ _ _)) _ _)
    _ K1 K2 K3
    <- tgtmap2efxmap-preserves-size tgtmap`size/0 T MZ
    <- efxmap`size-total Z
    <- efxmap`size-unique (efxmap`size/+ Z) MZ efxmap`eq/ Ex
    <- nat`eq-symmetric Ex E
    <- nat`eq-contradiction E V
    <- reftyping-ok/read/unique/F V K1 K2 K3.

- : reftyping-ok/read/unique set/0 tgtmap/0 true
    B-XM _ CM-CM CM2PM XX=>Out _ TYP-E CML FML
    (make-targets-and-effects/unique _ _ _ _ _ consider-ftype/shared)
    (effects`join/ J-XM J-MX) _
    (effects2output/shared XM=>Pi MX=>Pi3 T2PF)
    ([f] tTrans2
      (tRead1
        (tTrans2
          (TYP-E f)
          (transform/trans
            (TRANS f)
            (transform/inside [r]
              (transform/trans
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          equiv/distribute equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans6
                (implies/combine
                  (repack-fldperm f v)
                  (implies/reflexive))
                (implies/equiv equiv/roll2)
                (implies/combine
                  (implies/trans
                    (implies/scale (DUP v))
                    (implies/equiv equiv/distribute))
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/chain-implication)
                      (implies/reflexive))))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens)
                      (implies/reflexive))))
                (implies/combine
                  (DIS f v)
                  (implies/trans
                    (implies/combine
                      (implies/equiv
                        (equiv/transitive3
                          (equiv/combine (EQV2 f) equiv/reflexive)
                          (equiv/commute)
                          (equiv/identity)))
                      (implies/reflexive))
                    (implies/equiv equiv/commute)))))))
        (transform/rem-unused)))
    <- reftyping-ok/before-read/unique/0t B-XM CM-CM CM2PM CML FML
      set+nat2tgtmap/0 tgtmap2efxmap/0 J-XM J-MX XX=>Out _ T2PF _ MX=>Pi3
      _ _ SG _ XM1=>Pi3 _ XM2=>Pi4 TRANS
    <- select-tgtmap-right-equiv-empty SG _ EQx M2=>G2 EQE
    <- efxmap`eq-symmetric EQx EQ
    <- equiv-empty-implies-permission-equiv M2=>G2 EQE XM2=>Pi4 EQV2
    <- efxmap2perm-respects-eq XM1=>Pi3 bool`eq/ clsmap`eq/ predmap`eq/
      cxt`eq/ EQ ([_] permission`eq/) XM=>Pi
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- can-scale-from-shared T2PF DIS.

- : reftyping-ok/read/unique set/0 tgtmap/0 true
    B-XM _ CM-CM CM2PM XX=>Out _ TYP-E CML FML
    (make-targets-and-effects/unique
      set+nat2tgtmap/0 _ _ tgtmap2efxmap/0 _ consider-ftype/unique)
    (effects`join/ J-XM J-MX) _
    (effects2output/unique/0t tgtmap`size/0 XM=>Pi
      ([_] set2facts/0) MX=>Pi3 T2PF)
    ([f] tTrans2
      (tRead1
        (tTrans2
          (TYP-E f)
          (transform/trans
            (TRANS f)
            (transform/inside [r]
              (transform/trans
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          equiv/distribute equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans5
                  (implies/combine
                    (repack-fldperm f v)
                    (implies/reflexive))
                  (implies/equiv equiv/roll2)
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/chain-implication)
                        (implies/reflexive))))
                  (implies/combine
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine
                        (implies/reflexive)
                        (gen-objequal-self v))
                      (implies/equiv equiv/commute))
                    (implies/combine
                      (implies/equiv-encumbered
                        (equiv/reflexive)
                        (equiv/transitive3
                          (equiv/combine (EQV2 f) (equiv/reflexive))
                          (equiv/commute)
                          (equiv/identity)))
                      (implies/reflexive)))
                  (implies/equiv
                    (equiv/symmetric equiv/associate))))
              (transform/gen-exists v))))
        (transform/rem-unused)))
    <- reftyping-ok/before-read/unique/0t B-XM CM-CM CM2PM CML FML
      set+nat2tgtmap/0 tgtmap2efxmap/0 J-XM J-MX XX=>Out _ T2PF _ MX=>Pi3
      _ _ SG _ XM1=>Pi3 _ XM2=>Pi4 TRANS
    <- select-tgtmap-right-equiv-empty SG _ EQx M2=>G2 EQE
    <- efxmap`eq-symmetric EQx EQ
    <- equiv-empty-implies-permission-equiv M2=>G2 EQE XM2=>Pi4 EQV2
    <- efxmap2perm-respects-eq XM1=>Pi3 bool`eq/ clsmap`eq/ predmap`eq/
      cxt`eq/ EQ ([_] permission`eq/) XM=>Pi.

- : reftyping-ok/read/unique set/0 tgtmap/0 true
    B-XM _ CM-CM CM2PM XX=>Out _ TYP-E CML FML
    (make-targets-and-effects/unique
      set+nat2tgtmap/0 _ _ tgtmap2efxmap/0 _ consider-ftype/unique)
    (effects`join/ J-XM J-MX) _
    (effects2output/unique/0t tgtmap`size/0 XM=>Pi
      ([_] set2facts/0) MX=>Pi3 T2PF)
    ([f] tTrans2
      (tRead1
        (tTrans2
          (TYP-E f)
          (transform/trans
            (TRANS f)
            (transform/inside [r]
              (transform/trans
                (transform/skolem)
                (transform/inside [v]
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/combine
                          equiv/distribute equiv/reflexive)
                        (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans5
                  (implies/combine
                    (repack-fldperm f v)
                    (implies/reflexive))
                  (implies/equiv equiv/roll2)
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/chain-implication)
                        (implies/reflexive))))
                  (implies/combine
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine
                        (implies/reflexive)
                        (gen-objequal-self v))
                      (implies/equiv equiv/commute))
                    (implies/combine
                      (implies/equiv-encumbered
                        (equiv/reflexive)
                        (equiv/transitive3
                          (equiv/combine (EQV2 f) (equiv/reflexive))
                          (equiv/commute)
                          (equiv/identity)))
                      (implies/reflexive)))
                  (implies/equiv
                    (equiv/symmetric equiv/associate))))
              (transform/gen-exists v))))
        (transform/rem-unused)))
    <- reftyping-ok/before-read/unique/0t B-XM CM-CM CM2PM CML FML
      set+nat2tgtmap/0 tgtmap2efxmap/0 J-XM J-MX XX=>Out _ T2PF _ MX=>Pi3
      _ _ SG _ XM1=>Pi3 _ XM2=>Pi4 TRANS
    <- select-tgtmap-right-equiv-empty SG _ EQx M2=>G2 EQE
    <- efxmap`eq-symmetric EQx EQ
    <- equiv-empty-implies-permission-equiv M2=>G2 EQE XM2=>Pi4 EQV2
    <- efxmap2perm-respects-eq XM1=>Pi3 bool`eq/ clsmap`eq/ predmap`eq/
      cxt`eq/ EQ ([_] permission`eq/) XM=>Pi.

- : reftyping-ok/read/unique set/0 tgtmap/0 false
    _ _ CM-CM CM2PM XX=>Out _ TYP-E CML FML _ _ _
    (effects2output/unique/0 set`size/0 tgtmap`size/0 XM=>Pi MX=>Pi3 T2PF)
    ([f] tTrans2
      (tRead1
        (tTrans2
          (TYP-E f)
          (transform/trans
            (TRANS f)
            (transform/inside [r]
              (transform/trans3
                (transform/implies
                  (implies/equiv
                    (equiv/combine
                      (equiv/symmetric equiv/one)
                      (equiv/reflexive))))
                (transform/skolem)
                (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans3
              (transform/drop)
              (transform/implies
                (implies/equiv
                  (equiv/transitive
                    (equiv/combine
                      (equiv/one)
                      (equiv/reflexive))
                    (equiv/roll2))))
              (transform/drop))))
        (transform/rem-unused)))
    <- reftyping-ok/before-read/unique/0 CM-CM CM2PM CML FML
      XX=>Out _ T2PF _ PML _ MX=>Pi3 _ XM=>Pi TRANS.

- : reftyping-ok/read/unique set/0 tgtmap/0 false
    B-XM SOC CM-CM CM2PM XX=>Out _ TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>GM2 _ _
      GM2=>XM SB=>MX consider-ftype/shared)
    (effects`join/ J-XM J-MX)
    _ (effects2output/shared XM=>Pi MX=>Pi3 T2PF)
    ([f] tTrans2
      (tRead1
        (tTrans2
          (TYP-E f)
          (transform/trans
            (TRANS f)
            (transform/inside [r]
              (transform/trans3
                (transform/implies
                  (implies/equiv
                    (equiv/combine
                      (equiv/symmetric equiv/one)
                      (equiv/reflexive))))
                (transform/skolem)
                (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
        (letTyping/exists [v]
          (letTyping/exists [r]
            (letTyping/base v tRead))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans5
                  (implies/equiv equiv/associate)
                  (implies/combine
                    (implies/trans5
                      (implies/equiv
                        (equiv/transitive
                          (equiv/symmetric equiv/distribute)
                          (equiv/one)))
                      (implies/combine
                        (implies/reflexive) (DUP v))
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/pack v)
                        (implies/reflexive))
                      (implies/equiv equiv/commute))
                    (implies/reflexive))
                  (implies/equiv (equiv/symmetric equiv/associate))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/linear-modus-ponens)
                        (implies/reflexive))))
                  (implies/equiv equiv/roll2)))
              (transform/drop))))
        (transform/rem-unused)))
    <- reftyping-ok/before-read/unique/0 CM-CM CM2PM CML FML
      XX=>Out _ T2PF _ PML _ MX=>Pi3 _ XM=>Pi TRANS
    <- sharedperm-can-be-duplicated* T2PF DUP.

- : reftyping-ok/read/unique (set/+ _ _) tgtmap/0 false
    B-XM SOC CM-CM CM2PM XX=>Out _ TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>GM2 _ _
      GM2=>XM SB=>MX consider-ftype/shared)
    (effects`join/ J-XM J-MX)
    _ (effects2output/shared XM=>Pi MX=>Pi3 T2PF)
    ([f]
      (tTrans2
        (tRead1
          (tTrans2
            (TYP-E f)
            (transform/trans
              (TRANS f)
              (transform/inside [r]
                (transform/trans
                  (transform/skolem)
                  (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
          (letTyping/exists [v]
            (letTyping/exists [r]
              (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans6
                (implies/combine
                  (repack-fldperm f v)
                  (implies/reflexive))
                (implies/equiv equiv/roll2)
                (implies/combine
                  (implies/trans
                    (implies/scale (DUP v))
                    (implies/equiv equiv/distribute))
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/chain-implication)
                      (implies/reflexive))))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans4
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens)
                      (implies/reflexive))
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/trans
                        (implies/equiv equiv/commute)
                        (implies/equiv (EQV f)))
                      (implies/reflexive))))
                (implies/combine (DIS f v) implies/reflexive)))))
        (transform/rem-unused)))
    <- set`size-total S-SZ
    <- reftyping-ok/before-read/unique/0f B-XM CM-CM CM2PM CML FML
      S+F=>GM2 GM2=>XM J-XM XX=>Out SOC S-SZ _ T2PF _ MX=>Pi3
      _ _ SG _ XM1=>Pi3 _ XM2=>Pi4 TRANS
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- can-scale-from-shared T2PF DIS
    <- select-tgtmap-implies-permission-combine-converse
      SG XM1=>Pi3 XM2=>Pi4 _ XM=>Pi EQV.

- : reftyping-ok/read/unique (set/+ _ _) tgtmap/0 false
    B-XM SOC CM-CM CM2PM XX=>Out _ TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>GM2 _ _ GM2=>XM SB=>MX consider-ftype/unique)
    (effects`join/ J-XM J-MX)
    _ (effects2output/unique/+f
        SZ-GM SG XM1=>Pi3 XM2=>Pi4 ([_] set2facts/0) MX=>Pi3 T2PF)
    ([f]
      (tTrans2
        (tRead1
          (tTrans2
            (TYP-E f)
            (transform/trans
              (TRANS f)
              (transform/inside [r]
                (transform/trans
                  (transform/skolem)
                  (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
          (letTyping/exists [v]
            (letTyping/exists [r]
              (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans5
                  (implies/combine
                    (repack-fldperm f v)
                    (implies/reflexive))
                  (implies/equiv equiv/roll2)
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/chain-implication)
                        (implies/reflexive))))
                  (implies/combine
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine
                        (implies/reflexive)
                        (gen-objequal-self v))
                      (implies/equiv equiv/commute))
                    (implies/reflexive))
                  (implies/equiv (equiv/symmetric equiv/associate))))
              (transform/gen-exists v))))
        (transform/rem-unused)))
    <- set`size-total S-SZ
    <- set+nat2tgtmap-preserves-size S+F=>GM2 S-SZ SZ-GM
    <- reftyping-ok/before-read/unique/0f B-XM CM-CM CM2PM CML FML
      S+F=>GM2 GM2=>XM J-XM XX=>Out SOC S-SZ _ T2PF _ MX=>Pi3
      _ _ SG _ XM1=>Pi3 _ XM2=>Pi4 TRANS.

- : reftyping-ok/read/unique (set/+ _ _) tgtmap/0 true
    B-XM SOC CM-CM CM2PM XX=>Out _ TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>GM2 _ tgtmap`join/L GM2=>XM SB=>MX (consider-ftype/unique))
    (effects`join/ J-XM J-MX)
    _ (effects2output/unique/+t
        SZ-GM SG XM1=>Pi3 XM2=>Pi4 ([_] set2facts/0) MX=>Pi3 T2PF)
    ([f]
      (tTrans2
        (tRead1
          (tTrans2
            (TYP-E f)
            (transform/trans
              (TRANS f)
              (transform/inside [r]
                (transform/trans
                  (transform/skolem)
                  (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
          (letTyping/exists [v]
            (letTyping/exists [r]
              (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans5
                  (implies/combine
                    (repack-fldperm f v)
                    (implies/reflexive))
                  (implies/equiv equiv/roll2)
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/chain-implication)
                        (implies/reflexive))))
                  (implies/combine
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine
                        (implies/reflexive)
                        (gen-objequal-self v))
                      (implies/equiv equiv/commute))
                    (implies/reflexive))
                  (implies/equiv (equiv/symmetric equiv/associate))))
              (transform/gen-exists v))))
        (transform/rem-unused)))
    <- set`size-total SZ
    <- set+nat2tgtmap-preserves-size S+F=>GM2 SZ SZ-GM
    <- reftyping-ok/before-read/unique/0t B-XM CM-CM CM2PM CML FML
      S+F=>GM2 GM2=>XM J-XM J-MX XX=>Out _ T2PF _ MX=>Pi3
      _ _ SG _ XM1=>Pi3 _ XM2=>Pi4 TRANS.

- : reftyping-ok/read/unique (set/+ _ _) tgtmap/0 true
    B-XM SOC CM-CM CM2PM XX=>Out _ TYP-E CML FML
    (make-targets-and-effects/unique
      S+F=>GM2 _ tgtmap`join/L GM2=>XM SB=>MX (consider-ftype/shared))
    (effects`join/ J-XM J-MX)
    _ (effects2output/shared XM=>Pi MX=>Pi3 T2PF)
    ([f]
      (tTrans2
        (tRead1
          (tTrans2
            (TYP-E f)
            (transform/trans
              (TRANS f)
              (transform/inside [r]
                (transform/trans
                  (transform/skolem)
                  (transform/inside [v]
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive
                          (equiv/combine
                            equiv/distribute equiv/reflexive)
                          (equiv/symmetric equiv/associate)))))))))
          (letTyping/exists [v]
            (letTyping/exists [r]
              (letTyping/base v tRead)))))
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/implies
              (implies/trans6
                (implies/combine
                  (repack-fldperm f v)
                  (implies/reflexive))
                (implies/equiv equiv/roll2)
                (implies/combine
                  (implies/trans
                    (implies/scale (DUP v))
                    (implies/equiv equiv/distribute))
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/chain-implication)
                      (implies/reflexive))))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/equiv equiv/associate)
                    (implies/combine
                      (implies/linear-modus-ponens)
                      (implies/reflexive))))
                (implies/combine
                  (DIS f v)
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/commute)
                      (equiv/associate)
                      (equiv/combine (EQV f) equiv/reflexive))))))))
        (transform/rem-unused)))
    <- set`size-total SZ
    <- set+nat2tgtmap-preserves-size S+F=>GM2 SZ SZ-GM
    <- reftyping-ok/before-read/unique/0t B-XM CM-CM CM2PM CML FML
      S+F=>GM2 GM2=>XM J-XM J-MX XX=>Out _ T2PF _ MX=>Pi3
      _ _ SG _ XM1=>Pi3 _ XM2=>Pi4 TRANS
    <- select-tgtmap-implies-permission-combine-converse
      SG XM1=>Pi3 XM2=>Pi4 _ XM=>Pi EQV
    <- sharedperm-can-be-duplicated* T2PF DUP
    <- can-scale-from-shared T2PF DIS.

%worlds () (reftyping-ok/read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/read/unique _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/read
  : forall* {CM} {PM} {W} {B} {FM} {XX} {XX1} {XX2}
    {GSP} {NN} {A} {FC} {C} {E} {F} {Out} {Pi0} {Pi1}
    forall {GS} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B-GS: clsmap-cxt-targets CM B C GS}
    {CM-B-XX: clsmap-cxt-effects CM B XX}
    {GS-XX: targets-effects GS XX1}
    {B2P: cxt2perm CM PM B Pi0}
    {XX2I: effects2input CM PM B XX Pi1}
    {XX2O: effects2output CM PM B (reftype/ nn/yes C GS) XX Out}
    {TYPE: {f} typing W (Pi0 , (Pi1 f)) E (Out f)}
    {CML: clsmap`lookup CM C FM}
    {FML: fldmap`lookup FM F (ty/ NN A FC)}
    {MG: make-targets-and-effects GS A F efx/read GSP XX2}
    {XJ: effects`join XX1 XX2 XX}
    exists {Out2} {XX2O: effects2output CM PM B (reftype/ NN FC GSP) XX Out2}
    {TYP: {f} typing W (Pi0 , (Pi1 f)) (read E F) (Out2 f)}
    true.

- : reftyping-ok/read targets/shared CM-CM CM2PM CM-B-GS _ _
    B2P XX2I XX2O TYPE CML FML MG XJ _ XX2Ox TYP
    <- reftyping-ok/read/shared
      CM-CM CM2PM B2P XX2I XX2O TYPE CML FML MG XJ _ XX2Ox TYP.

- : reftyping-ok/read (targets/unique S G SB) CM-CM CM2PM
    (clsmap-cxt-targets/unique CM-B-G SOC) (clsmap-cxt-effects/ CM-B-M)
    (targets-effects/unique G<=M1) B2P XX2I XX2O TYPE CML FML MG XJ _ XX2Ox TYP
    <- reftyping-ok/read/unique S G SB CM-B-M SOC CM-CM CM2PM XX2O
      G<=M1 TYPE CML FML MG XJ _ XX2Ox TYP.

%worlds () (reftyping-ok/read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/read _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


% cxt and efxmap need to be consistent too.
%theorem reftyping-frame
  : forall* {CM} {PM} {Out1} {W} {E} {XX1} {XX2}
    {Pi0} {Pi1} {B} {RT}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {B=>Pi0: cxt2perm CM PM B Pi0}
    {XM1=>Pi1: effects2input CM PM B XX1 Pi1}
    {XM1=>Out1: effects2output CM PM B RT XX1 Out1}
    {TYP-E: {f} typing W (Pi0 , Pi1 f) E (Out1 f)}
    {XX1<=XX2: effects`leq XX1 XX2}
    exists {Pi2} {Out2}
    {XM2=>Pi2: effects2input CM PM B XX2 Pi2}
    {XM2=>Out2: effects2output CM PM B RT XX2 Out2}
    {TYP-E: ({f} typing W (Pi0 , Pi2 f) E (Out2 f))}
    true.

%worlds () (reftyping-frame _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total {} (reftyping-frame _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/expr
  : forall* {CM} {PM} {MM} {W} {B} {E} {RT} {XX}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-B: clsmap-cxt CM B}
    {MM2W: methmap2progtype CM PM MM W}
    {RTYP: reftyping CM MM B E (out/expr RT XX)}
    exists {Pi1} {B=>Pi: cxt2perm CM PM B Pi1}
    {Pi2} {XX2I: effects2input CM PM B XX Pi2}
    {Out} {XX2O: effects2output CM PM B RT XX Out}
    {TYP: {f} typing W (Pi1 , (Pi2 f)) E (Out f)}
    true.

- : reftyping-ok/expr CM-CM CM2PM CM-B _
    (reftyping/write RTYP-E1 RTYP-E2 CML FML SUB MG X1+X2=X5 X5+X3=X6
    X6+X4=X7) %{=>}% _ XX2I _ XX2O TYP.

- : reftyping-ok/expr CM-CM CM2PM CM-B _
    (reftyping/lit ty2reftype/borrow _ BL) _ B2P _
    (effects2input/ efxmap2perm/0 maybe-efx2perm/nothing) _
    (effects2output/unique/0f (set`size/+ set`size/0) tgtmap`size/0
      efxmap2perm/0
      ([_] (set2facts/U set`not-member/0 set`update/0 set2facts/0))
      maybe-efx2perm/nothing T2PF)
    ([f] tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/trans
                (IMP)
                (implies/equiv equiv/commute))
              (implies/trans
                (implies/equiv
                  (equiv/transitive
                    (equiv/symmetric equiv/identity)
                    (equiv/commute)))
                (implies/combine
                  (gen-objequal-self _)
                  (implies/reflexive))))
            (implies/equiv (equiv/symmetric equiv/associate))))
        (transform/drop)
        (transform/gen-exists _)))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B2P
    <- clsmap-cxt-lookup-implies-ty2perm CM-B BL B2P _ T2PF IMP.

- : reftyping-ok/expr CM-CM CM2PM CM-B _
    (reftyping/lit ty2reftype/shared _ BL) _ B2P _
    (effects2input/ efxmap2perm/0 maybe-efx2perm/nothing) _
    (effects2output/shared efxmap2perm/0 maybe-efx2perm/nothing T2PF)
    ([f] tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans
            (implies/combine
              (implies/trans
                (IMP)
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))))
        (transform/drop)
        (transform/gen-exists _)))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B2P
    <- clsmap-cxt-lookup-implies-ty2perm CM-B BL B2P _ T2PF IMP.

- : reftyping-ok/expr CM-CM CM2PM CM-B MM2W
    (reftyping/read RTYP-E CML FML MG XJ) _ B2P _ XX2I _ XX2O TYP
    <- reftyping-ok/expr CM-CM CM2PM CM-B MM2W RTYP-E _ B2P _ XX2Iex _ XX2Oex TYPex
    <- effects`join-implies-leq XJ LE _
    <- reftyping-frame
      CM-CM CM2PM B2P XX2Iex XX2Oex TYPex LE _ _ XX2I XX2Oe TYPe
    <- reftyping-consistent CM-CM CM-B RTYP-E _ _ CM-B-GS CM-B-XX1 GS-XX1
    <- make-targets-and-effects-consistent
      CML FML CM-B-GS MG CM-B-GSP CM-B-XX2 GS-XX2
    <- leq-preserves-targets-effects GS-XX1 LE GS-XX
    <- join-preserves-clsmap-cxt-effects CM-B-XX1 CM-B-XX2 XJ CM-B-XX
    <- reftyping-ok/read _ CM-CM CM2PM CM-B-GS CM-B-XX GS-XX1 B2P XX2I
      XX2Oe TYPe CML FML MG XJ _ XX2O TYP.

%worlds () (reftyping-ok/expr _ _ _ _ _ _ _ _ _ _ _ _).
%trustme %total (T) (reftyping-ok/expr _ _ _ _ T _ _ _ _ _ _ _).
