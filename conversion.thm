%%% Theorems about conversion

%theorem reftyping-ok
  : forall* {CM} {PM} {MM} {W} {K} {E: term K} {R: result K} {V} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-V: clsmap-cxt-env CM B V}
    {RTYP: reftyping CM MM B V E R}
    exists {PiB} {Pi} {Out}
    {B=>PiB: cxt2perm PM B PiB}
    {XX2I: env2input CM PM B V Pi}
    {XX2O: result2output CM PM B R Out}
    {TYP: typing W (PiB , Pi) E Out}
    true.

%theorem reftyping-ok/args
  : forall* {CM} {PM} {MM} {B} {V} {A} {MT} {AR} {W}
    forall {Pi0} {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-V: clsmap-cxt-env CM B V}
    {RTYP: argsRefTyping CM MM B V A MT AR}
    exists {PiB} {Pi} {Out}
    {B=>PiB: cxt2perm PM B PiB}
    {V=>Pi: env2input CM PM B V Pi}
    {TYP: typing W (Pi0 , (PiB , Pi)) A Out}
    {R=>Out: result2output* CM PM B Pi0 AR Out}
    true.

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ _))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1) (sub-annot/fresh _))
      (ATYP:argsRefTyping CM MM B _ A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/combine
                            (equiv/transitive
                              (equiv/combine (PiB0<=>PiB1 o r p)
                                (equiv/combine equiv/reflexive (PiV1<=>PiV11 o r p)))
                              (equiv/reorder))
                            (equiv/symmetric equiv/identity))
                          (equiv/swap)))
                      (equiv/commute)
                      (equiv/swap))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 capset2perm/0) RT=>PiT  AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0) V1=>PiV1
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-B-U1 CM-B-M1))
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , empty)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U1 CM-B-M1) ATYP _
         _ _ (B=>PiB1 x o p) (V1=>PiV11 x o p) (TYP-A x o p) (AR=>AOut x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- ({x}{o}{p} env2input-unique V1=>PiV1 (V1=>PiV11 x o p) env`eq/ (PiV1<=>PiV11 x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ (env/ U1 M1)))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/borrow (S+FS=>MF:set+set2set S FS MF)
          (M1-MF=M2:set`split M1 MF M2)))
      (ATYP:argsRefTyping CM MM B (env/ U1 M2) A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine
                        (implies/combine (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/equiv (PiU1<=>PiU1P o r p))
                              (implies/equiv
                                (equiv/transitive
                                  (PiM1<=>PiMF+PiM2)
                                  (equiv/combine equiv/reflexive (PiM2<=>PiM2P o r p)))))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive5
                        (equiv/combine equiv/reflexive
                          (equiv/transitive
                            (equiv/identity)
                            (equiv/reorder)))
                        (equiv/associate)
                        (equiv/combine equiv/reflexive
                          (equiv/roll3))
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive3
                            (equiv/combine equiv/reflexive
                              (equiv/transitive (equiv/symmetric equiv/identity) equiv/commute))
                            (equiv/symmetric equiv/associate)
                            (equiv/commute))
                          (equiv/reflexive))))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 MF=>PiMF) RT=>PiT AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0)
        (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-U1 CM-M1))
    <- set`split-implies-leq M1-MF=M2 MF<=M1 M2<=M1
    <- clsmap-cxt-capset-respects-geq CM-M1 M2<=M1 CM-M2
    <- set`split-implies-permission-combine M1-MF=M2 M1=>PiM1
      PiMF PiM2 MF=>PiMF M2=>PiM2 PiM1<=>PiMF+PiM2
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , PiMF)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U1 CM-M2) ATYP _
         _ _ (B=>PiB1 x o p) (env2input/ (U1=>PiU1P x o p) (M2=>PiM2P x o p))
         (TYP-A x o p) (AR=>AOut x o p))
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} capset2perm-equiv M2=>PiM2 (M2=>PiM2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiM2<=>PiM2P x o p))
    <- ({x}{o}{p} make-encumbered-equiv U1=>PiU1 (U1=>PiU1P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiU1<=>PiU1P x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ (env/ U1 M1)))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/unique CML DM-FM=FS (S+FS=>MF:set+set2set S FS MF)
          (M1-MF=M2:set`split M1 MF M2) (S<=U1:set`leq S U1)
          (U1-S=U2: set`remove U1 S U2) _))
      (ATYP:argsRefTyping CM MM B (env/ U2 M2) A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine
                        (implies/combine (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/equiv
                                (equiv/transitive
                                  PiU1<=>PiS+PiU2
                                  (equiv/combine equiv/reflexive (PiU2<=>PiU2P o r p))))
                              (implies/equiv
                                (equiv/transitive
                                  (PiM1<=>PiMF+PiM2)
                                  (equiv/combine equiv/reflexive (PiM2<=>PiM2P o r p)))))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive4
                        (equiv/combine equiv/reflexive
                          (equiv/transitive
                            (equiv/combine
                              (equiv/transitive
                                (equiv/combine (equiv/reflexive) % PiB1
                                  (equiv/transitive
                                    (equiv/combine (equiv/reflexive) % Pif
                                      (equiv/swap-middle))
                                    (equiv/associate)))
                                (equiv/reorder))
                              (equiv/reflexive))
                            (equiv/commute)))
                        (equiv/associate)
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive
                            (equiv/combine (equiv/identity) equiv/reflexive)
                            (equiv/commute))
                          (equiv/reflexive))))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ S=>PiS MF=>PiMF) RT=>PiT AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0)
        (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-U1 CM-M1))
    <- set`remove-implies-leq U1-S=U2 U2<=U1
    <- clsmap-cxt-objset-respects-geq CM-U1 U2<=U1 CM-U2
    <- set`split-implies-leq M1-MF=M2 MF<=M1 M2<=M1
    <- clsmap-cxt-capset-respects-geq CM-M1 M2<=M1 CM-M2
    <- make-encumbered-intro S<=U1 U1-S=U2 U1=>PiU1 PiS PiU2 S=>PiS U2=>PiU2 PiU1<=>PiS+PiU2
    <- set`split-implies-permission-combine M1-MF=M2 M1=>PiM1
      PiMF PiM2 MF=>PiMF M2=>PiM2 PiM1<=>PiMF+PiM2
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (PiS , PiMF)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U2 CM-M2) ATYP _
         _ _ (B=>PiB1 x o p) (env2input/ (U2=>PiU2P x o p) (M2=>PiM2P x o p))
         (TYP-A x o p) (AR=>AOut x o p))
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} capset2perm-equiv M2=>PiM2 (M2=>PiM2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
      set`eq/ (PiM2<=>PiM2P x o p))
    <- ({x}{o}{p} make-encumbered-equiv U2=>PiU2 (U2=>PiU2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiU2<=>PiU2P x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ _))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/shared))
      (ATYP:argsRefTyping CM MM B _ A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans3
                    (implies/combine implies/reflexive
                      (implies/combine
                        (implies/combine
                          (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/equiv (PiV1<=>PiV11 o r p))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/combine equiv/reflexive
                          (equiv/transitive3
                            (equiv/combine (equiv/roll2) equiv/reflexive)
                            (equiv/commute)
                            (equiv/associate)))
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive
                            (equiv/commute)
                            (equiv/combine equiv/commute equiv/reflexive))
                          (equiv/reflexive))))
                    (implies/combine
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/equiv (equiv/symmetric equiv/identity)))
                        (implies/reflexive))
                      (implies/reflexive))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 capset2perm/0) RT=>PiT  AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0) V1=>PiV1
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-B-U1 CM-B-M1))
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , empty)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U1 CM-B-M1) ATYP _
         _ _ (B=>PiB1 x o p) (V1=>PiV11 x o p) (TYP-A x o p) (AR=>AOut x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- ({x}{o}{p} env2input-unique V1=>PiV1 (V1=>PiV11 x o p) env`eq/ (PiV1<=>PiV11 x o p)).

- : reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-B-V
    (argsRefTyping/0) _ _ _ B=>PiB V=>Pi
    (tTrans2 tArgs0
      (transform/args/0
        (implies/reflexive)))
    (result2output/args/0 B=>PiB V=>Pi)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>PiB
    <- clsmap-cxt-env-implies-env2input CM-CM CM2PM CM-B-V _ V=>Pi.


%theorem reftyping-ok/expr/write
  : forall* {CM} {MM} {PM} {W} {F} {E2} {G} {T} {Out1} {Rslt1} {Rslt2} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-Rslt: clsmap-result CM B Rslt1}
    {Rslt1=>Out1: result2output CM PM B Rslt1 Out1}
    {RTYP-H: writeRefTyping CM MM B Rslt1 F E2 G T Rslt2}
    exists {Out1'} {Out2} {Out2'}
    {Out1=>Out1': transform Out1 Out1'}
    {Rslt2=>Out2: result2output CM PM B Rslt2 Out2}
    {TYP: letTyping W Out1' ([O] write (lit O) F E2) Out2'}
    {Out2'=>Out2: transform Out2' Out2}
    true.

%theorem reftyping-ok/expr/write/L2
  : forall* {CM} {NN1} {G1} {U1} {M2} {NN} {N1} {A} {FS} {X8} {U2} {M3} {FM} {FC}
    forall {CML: clsmap`lookup CM FC FM}
    {DM: fldmap`domain FM FS}
    {SUB:subtype CM FS (reftype/ NN1 N1 G1) (env/ U1 M2) (ty/ NN A FC) X8 (env/ U2 M3)}
    exists {CML: clsmap`lookup CM N1 FM}
    true.

%worlds (gtermvar) (reftyping-ok/expr/write/L2 _ _ _ _).
%trustme %total { } (reftyping-ok/expr/write/L2 _ _ _ _).


- : reftyping-ok/expr/write CM-CM CM-MM CM2PM MM2W CM-B CM-R1 R1=>Out1
    (writeRefTyping/base (CML:clsmap`lookup CM C FM) FML
      (MG:make-tgts-and-caps M0 G0 F (targets/unique set/0 M _) M1)
      (RTYP-E2:reftyping CM MM B (env/ U0 M1) E2 (result/expr _ (env/ U1 M2)))
      (SUB:subtype _ _ _ (env/ U1 M2) (ty/ NN A FC) _ (env/ U2 M3))
      (CF:consider-ftype _ M3 A G2 M4)) _ _ _
    (transform/trans
      (TRANS-1)
      (transform/inside [x]
        (transform/inside [p:permission]
          (transform/implies
            (implies/trans
              (implies/equiv
                (equiv/transitive
                  (equiv/combine (PiU0'<=>PiU0) equiv/reflexive)
                  (equiv/roll2)))
              (implies/combine (implies/equiv (PiB'<=>PiB)) implies/reflexive))))))
    R3=>Out3
    (letTyping/exists [x] (letTyping/exists [p] (letTyping/base x (TYP x p))))
    (transform/trans transform/rem-unused (transform/rem-unused))
    <- make-tgts-and-caps-consistent/1 CM-CM CML FML CM-R1 MG (clsmap-cxt-env/ _ CM-B-M1)
    <- clsmap-result/expr-inversion CM-R1 _ (clsmap-cxt-env/ CM-B-U0 _)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U0 CM-B-M1) RTYP-E2
      PiB _ Out2 B=>PiB (env2input/ (U0=>PiU0: make-encumbered CM PM B U0 PiU0)
                          (M1=>Pi2:capset2perm CM PM B M1 Pi2)) R2=>Out2 TYP-E2
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B
      (clsmap-cxt-env/ CM-B-U0 CM-B-M1) RTYP-E2 CM-R2
    <- before-read CM-CM CM2PM CML FML R1=>Out1 MG CM-R1
      PiB' _ Pi2' PiU0' _ T2PF B=>PiB' U0=>PiU0' R-FMT TRANS-1
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-not-borrow CM-FM FML NB
    <- make-before-write-format CM2PM CM-R2 SUB NB R2=>Out2 _ TRANS-2 BW-FMT
    <- do-write M1=>Pi2 R-FMT SUB T2PF
      (tTrans2 TYP-E2 TRANS-2) BW-FMT CF _ TYP R3=>Out3
    <- make-encumbered-equiv U0=>PiU0' U0=>PiU0
      clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/ PiU0'<=>PiU0
    <- cxt2perm-equiv B=>PiB' B=>PiB predmap`eq/ cxt`eq/ PiB'<=>PiB.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _)))
      ty2reftype/unique) _ _ _
    (B=>PiB)
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM)
      (reftype2perm/borrow (set`size/+ set`size/0) set`size/0
        T2PF ([_] (set2cond/U set2cond/0 set`update/0 set`not-member/0 BL))))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans5
            (implies/combine
              (implies/trans5
                (implies/equiv PiB<=>PiF+PiBP)
                (implies/combine (DUP O) implies/reflexive)
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric PiB<=>PiF+PiBP)))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/equiv equiv/commute)
                  (implies/combine (gen-objequal-self-cond _) implies/reflexive))))
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive
                (implies/equiv equiv/associate))
              (implies/reflexive))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _ (ty2perm2/unique T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-borrow T2PF DUP.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit
      (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _))) ty2reftype/borrow) _ _ _
    B=>PiB
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM)
      (reftype2perm/borrow (set`size/+ set`size/0) set`size/0
        T2PF ([_] (set2cond/U set2cond/0 set`update/0 set`not-member/0 BL))))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans5
            (implies/combine
              (implies/trans5
                (implies/equiv PiB<=>PiF+PiBP)
                (implies/combine (DUP O) implies/reflexive)
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric PiB<=>PiF+PiBP)))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/equiv equiv/commute)
                  (implies/combine (gen-objequal-self-cond _) implies/reflexive))))
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive
                (implies/equiv equiv/associate))
              (implies/reflexive))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _
      (ty2perm2/borrow T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-borrow T2PF DUP.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit
      (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _)))
      ty2reftype/shared) _ _ _
    B=>PiB
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM) (reftype2perm/shared T2PF))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans3
            (implies/combine
              (implies/trans5
                (implies/equiv (PiB<=>PiF+PiBP))
                (implies/combine (DUP O) (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric (PiB<=>PiF+PiBP))))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/equiv (equiv/symmetric equiv/identity))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _
      (ty2perm2/shared T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-shared T2PF DUP.

- : reftyping-ok (CM-CM:clsmap-clsmap CM CM) CM-MM
    CM2PM MM2W CM-B CM-V (reftyping/read RTYP-E RTYP-HELPER) PiB Pi Out B=>PiB V=>Pi R2=>Out2
    (tTrans2 (tRead1 (tTrans2 (TYP-E) (TRANS)) LTYP) TRANS2)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V RTYP-E _ _ _ B=>PiB V=>Pi R=>Out TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-E CM-R
    <- reftyping-ok/read CM-CM CM2PM CM-R R=>Out RTYP-HELPER _ _ _
      TRANS R2=>Out2 LTYP TRANS2.

- : reftyping-ok
    (CM-CM:clsmap-clsmap CM CM) (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W
    (CM-B0:clsmap-cxt CM B0) (CM-V0: clsmap-cxt-env CM B0 V0)
    (reftyping/let
      (RTYP-E0:reftyping CM MM B0 V0 E0 (result/expr (reftype/ NN C targets/shared) V1))
      (letRefTyping/base/shared (CML:clsmap`lookup CM C FM)
        (N!<B0:cxt`fresh B0 (s N))
        ([x] (B0+N=B1:{x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) x)
        ([x] (RTYP-E1: {x} reftyping CM MM (B1 x) V1 (F x)
                       (result/expr (reftype/ NN1 C1 G1) V2)) x)
        N!<G1))
    PiB0 Pi0 Out1 B0=>PiB0 V0=>Pi R1=>Out1
    (tTrans2
      (tLet
        (tTrans2
          (TYP-E0)
          (TRANS))
        (letTyping/exists [x]
          (letTyping/exists [o]
            (letTyping/exists [p]
              (letTyping/base x
                (tTrans
                  (transform/implies
                    (implies/combine
                      (implies/equiv (PiB1<=>PiB1' x))
                      (implies/equiv (Pi<=>Pi' x))))
                  (letTyping/base null (TYP-E1 x))
                  (transform/reflexive)))))))
      (TRANS2))
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B0 CM-V0 RTYP-E0 CM-R0
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0 RTYP-E0
      _ _ _ B0=>PiB0 V0=>Pi R0=>Out0 TYP-E0
    <- letRefTyping-helper/base/shared/before N!<B0 B0+N=B1
      CM-B0 CM-R0 R0=>Out0 PiB1 Pi1 CM-B1 CM-V1 V1=>Pi1 B1=>PiB1 TRANS
    <-({x} reftyping-ok CM-CM CM-MM CM2PM MM2W (CM-B1 x) (CM-V1 x)
        (RTYP-E1 x) _ _ _ (B1=>PiB1' x) (V1=>Pi1' x) (R1=>Out1' x) (TYP-E1 x))
    <- ({x} reftyping-implies-clsmap-result CM-CM CM-MM (CM-B1 x) (CM-V1 x) (RTYP-E1 x) (CM-R1 x))
    <- letRefTyping-helper/base/shared/after _ N!<G1 N!<B0 B0+N=B1
      ([x] CM-R1 x) ([x] R1=>Out1' x) _ R1=>Out1 TRANS2
    <- ({x} cxt2perm-equiv (B1=>PiB1 x) (B1=>PiB1' x) predmap`eq/
         cxt`eq/ (PiB1<=>PiB1' x))
    <- ({x} env2input-unique (V1=>Pi1 x) (V1=>Pi1' x) env`eq/ (Pi<=>Pi' x)).

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0
    (reftyping/let RTYP-E0
      (letRefTyping/base/unique
        CML DM-FM=FS S+FS=M2 N!<B0 B0+N=B1
        SP N!<U1 U1+N=U2 M0-M2=M4 N+FS=M3
        (set`split/ M3^M4 M3+M4=M5) ([x] RTYP-E1 x) N!<G1 M6-M3=M7 M8-M2=M7 M9-M1=M8
        N!<U4 U4+N=U3 U4+S=U5)) PiB0 Pi0 Out3 B0=>PiB0 V0=>Pi R1=>Out1
    (tTrans2
      (tLet
        (tTrans2
          (TYP-E0)
          (TRANS))
        (letTyping/exists [x]
          (letTyping/exists [o]
            (letTyping/exists [p]
              (letTyping/base x
                (tTrans
                  (transform/implies
                    (implies/combine implies/reflexive
                      (implies/combine
                        (implies/equiv (PiB1<=>PiB1' x))
                        (implies/equiv (Pi<=>Pi' x)))))
                  (letTyping/base null (TYP-E1' x o p))
                  (transform/reflexive)))))))
      (TRANS2))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0 RTYP-E0
      PiB0 Pi0 Out0 B0=>PiB0 V0=>Pi R0=>Out0 TYP-E0
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B0 CM-V0 RTYP-E0
      (clsmap-result/expr CM-B0-RT0
        (clsmap-cxt-env/ CM-B0-U0 CM-B0-M0))
    <- set`split-implies-leq-remove SP S<=U0 U0-S=U1
    <- letRefTyping-helper/base/unique CM-CM CM2PM CM-B0 CML DM-FM=FS
      S+FS=M2 N!<B0 B0+N=B1 S<=U0 U0-S=U1 U1+N=U2 M0-M2=M4 N+FS=M3
      (set`split/ M3^M4 M3+M4=M5)
      (clsmap-result/expr CM-B0-RT0 (clsmap-cxt-env/ CM-B0-U0 CM-B0-M0)) R0=>Out0
      ([x] Pi1 x) ([x] Pi2 x) ([x] PiB1 x)
      CM-B1 CM-V1 V1=>Pi B1=>PiB1 EC-FMT TRANS
    <-({x} reftyping-ok CM-CM CM-MM CM2PM MM2W (CM-B1 x) (CM-V1 x)
        (RTYP-E1 x) (PiB1' x) (Pi1' x) (Out1' x)
        (B1=>PiB1' x) (V1=>Pi' x) (R1=>Out1' x) (TYP-E1 x))
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- set`split-implies-leq SP _ U1<=U0
    <- clsmap-cxt-objset-respects-geq CM-B0-U0 U1<=U0 CM-B0-U1
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-objset CM-B0-U1
         N!<B0 (B0+N=B1 x) (CM-B1-U1 x))
    <- ({x} nat+set2set-implies-clsmap-cxt-capset CML DM-FM=FS
         (B1-L x) not-shared/unique N+FS=M3 (CM-B1-M3 x))
    <- set`split-implies-leq M0-M2=M4 M2<=M0 M4<=M0
    <- clsmap-cxt-capset-respects-geq CM-B0-M0 M4<=M0 CM-B0-M4
    <- ({x} cxt-fresh-update-preserves-clsmap-cxt-capset CM-B0-M4
         N!<B0 (B0+N=B1 x) (CM-B1-M4 x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-M3 x) (CM-B1-M4 x)
         M3+M4=M5 (CM-B1-M5 x))
    <- ({x} reftyping-implies-clsmap-result CM-CM CM-MM (CM-B1 x)
         (clsmap-cxt-env/
           (clsmap-cxt-objset/U (CM-B1-U1 x) (B1-L x) CML N!<U1 U1+N=U2)
           (CM-B1-M5 x)) (RTYP-E1 x)
         (clsmap-result/expr (CM-B1-RT x)
           (clsmap-cxt-env/ (CM-B1-U3 x) (CM-B1-M6 x))))
    <- ({x} cxt2perm-equiv (B1=>PiB1 x) (B1=>PiB1' x) predmap`eq/
         cxt`eq/ (PiB1<=>PiB1' x))
    <- ({x} reftyping-implies-clsmap-result/L3/L2 (CM-B1-M6 x)
         (B1-L x) CML DM-FM=FS N+FS=M3 M6-M3=M7 CM-B0-M7)
    <- letRefTyping-helper/base/unique/L6 G1 CM-B0-M7 N!<G1 N!<B0 B0+N=B1
      CML DM-FM=FS N+FS=M3 EC-FMT R1=>Out1' M6-M3=M7 M8-M2=M7 M9-M1=M8
      N!<U4 U4+N=U3 U4+S=U5 ([x] Out1 x) Out3 EA R1=>Out1 TRANS2
    <- ({x}{o}{p} typing-frame* (TYP-E1 x) (EA x o p) (TYP-E1' x o p))
    <- ({x} env2input-unique (V1=>Pi x) (V1=>Pi' x) env`eq/ (Pi<=>Pi' x)).


%%% IDEA:
%%% After checking E1, we get a permission output like the following:
%%%  (PiB , (PiF , PiF --|- Pi2 , Pi3))
%%% We then can combine PiB and Pi3 to check E2
%%% Then, subtype ensures that we have enough permission to be consumed,
%%% we can then check the "write".

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/write RTYP-E1 RTYP-E2) PiB Pi _ B=>PiB V=>Pi R3=>Out3
    (tTrans2 (tWrite1 (tTrans2 (TYP-E1) (TRANS1)) (LTYP)) (TRANS2))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W
      CM-B CM-V RTYP-E1 PiB Pi Out1 B=>PiB V=>Pi R1=>Out1 TYP-E1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-E1 CM-R1
    <- reftyping-ok/expr/write CM-CM CM-MM CM2PM MM2W
      CM-B CM-R1 R1=>Out1 RTYP-E2 _ _ _ TRANS1 R3=>Out3 LTYP TRANS2.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/call FS MML ARTYP CRTYP) _ _ _ B=>PiB V=>PiV R=>O
    (tTrans2
      (tCall WL
        (tTrans
          (transform/implies
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/identity)
                (equiv/commute))))
          (letTyping/base null ATYP)
          (TRANS1))
        CTYP)
      (TRANS2))
    <- methmap`lookup-implies-fresh-update MML _ MM-FS MM-UD
    <- methmap2progtype/U/m-inversion MM2W FS MM-FS MM-UD _ _ _ MT=>PT W-UD
    <- progtype`update-implies-lookup W-UD WL
    <- reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-V ARTYP
      _ _ _ B=>PiB V=>PiV ATYP AR=>AO
    <- reftyping-ok/call CM-CM CM-MM CM-B CM2PM MM2W CM-V ARTYP AR=>AO MT=>PT
      CRTYP _ _ _ TRANS1 CTYP TRANS2 R=>O.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/const CML DM NM AD MML ARTYP CRTYP) _ _ _ B=>PiB V=>PiV R=>O
    (tTrans2
      (tCall WL
        (tTrans2
          (tArgs1
            (tTrans2
              (tAlloc ([t] AF t))
              (transform/inside [t]
                (transform/implies
                  (implies/equiv
                    (equiv/transitive
                      (equiv/commute)
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/symmetric equiv/identity)
                          (equiv/commute))))))))
            (letTyping/exists [t] (letTyping/base t (tArgs (ATYP2 t)))))
          (transform/inside [t] (transform/args/+ (TRANS1 t))))
        (callTyping/exists [t] (callTyping/arg t (CTYP t))))
      (transform/trans
        (transform/inside [t] (TRANS2 t))
        (transform/rem-unused)))
    <- methmap`lookup-implies-fresh-update MML _ MM-FS MM-UD
    <- methmap2progtype/U/c-inversion MM2W CML MM-FS MM-UD _ _ _ CT=>PT W-UD
    <- progtype`update-implies-lookup W-UD WL
    <- reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-V ARTYP
      _ _ _ B=>PiB V=>PiV ATYP AR=>AO
    <- allocFields-total _ AF
    <- reftyping-ok/const CM-CM CM-MM CM-B CM2PM MM2W CM-V
      ARTYP AR=>AO CT=>PT CRTYP NM AD DM AF _ _ _ _ EA TRANS1 CTYP TRANS2 R=>O
    <- ({t} typing-frame* ATYP (EA t) (ATYP2 t)).

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/eq RTYP1 RTYP2 RCT1 RCT2) _ _ _ B=>PiB V0=>PiV0 R=>O TYP
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP1
      PiB _ _ B=>PiB V0=>PiV0 R1=>O1 TYP1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP1
      (clsmap-result/expr CM-B-RT1 CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP2
      PiB' _ _ B=>PiB' V1=>PiV1 R2=>O2 TYP2
    <- cxt2perm-equiv B=>PiB B=>PiB' predmap`eq/ cxt`eq/ PiB<=>PiB'
    <- reftyping-ok/eq CM-CM CM2PM B=>PiB V0=>PiV0 TYP1 R1=>O1
      (tTrans
        (transform/implies
          (implies/combine (implies/equiv (PiB<=>PiB')) implies/reflexive))
        (letTyping/base null (TYP2))
        (transform/reflexive))
      V1=>PiV1
      R2=>O2 RCT1 RCT2 _ TYP R=>O.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/not RTYP) _ _ _ B=>PiB V0=>PiV0 R=>O' (tNot TYP NV)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP
      _ _ _ B=>PiB V0=>PiV0 R=>O TYP
    <- reftyping-ok/not/L R=>O _ NV R=>O'.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/and RTYP-C1 RTYP-C2) _ _ _ B=>PiB V0=>PiV0 R=>O
    (tTrans2
      (tAnd TYP-C1 AND-HELP-C2)
      (TRANS))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP-C1
      PiB _ _ B=>PiB V0=>PiV0 R1=>O1 TYP-C1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP-C1 (clsmap-result/cond CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-C2
      PiB' _ _ B=>PiB' V1=>PiV1 R2=>O2 TYP-C2
    <- reftyping-ok/and B=>PiB' V1=>PiV1 R1=>O1 R2=>O2 TYP-C2 _ _ AND-HELP-C2 TRANS R=>O.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/sub RTYP SUB (clsmap-result/expr CM-RT1 CM-V2)) PiB _ _ B=>PiB V0=>PiV0
    (result2output/expr (B=>PiB':cxt2perm PM B PiB') V2=>PiV2 RT1=>PF1)
    (tTrans2 TYP0
      (transform/trans3
        (transform/inside [_]
          (transform/inside [_]
            (transform/inside [_]
              (transform/implies (implies/equiv equiv/identity)))))
      (TRANS)
        (transform/inside [_]
          (transform/inside [_]
            (transform/inside [_]
              (transform/implies (implies/equiv (equiv/symmetric equiv/identity))))))))
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0
      RTYP (clsmap-result/expr CM-RT0 CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP _ _ _ B=>PiB V0=>PiV0
      (result2output/expr B=>PiB' V1=>PiV1 RT0=>PF0) TYP0
    <- reftype-sub-transform _ CM-CM CM2PM B=>PiB' CM-RT0 CM-RT1 SUB RT0=>PF0 V1=>PiV1
      _ _ RT1=>PF1 V2=>PiV2 TRANS.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/if RTYP-C RTYP-E1 RTYP-E2) _ _ _ B=>PiB V0=>PiV0 R1=>O1
    (tTrans2
      (tIf
        (TYP-C)
        (IF-TYP))
      (TRANS))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP-C
      PiB _ _ B=>PiB V0=>PiV0 R0=>O0 TYP-C
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP-C (clsmap-result/cond CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-E1
      PiB1 PiV1 _ B=>PiB1 V1=>PiV1 R1=>O1 TYP-E1
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-E2
      PiB2 PiV1' _ B=>PiB2 V1=>PiV1' R2=>O2 TYP-E2
    <- result2output/expr-trans R1=>O1 R2=>O2 result`eq/ TRANS0 TRANS1
    <- cxt2perm-equiv B=>PiB1 B=>PiB2 predmap`eq/ cxt`eq/ PiB1<=>PiB2
    <- env2input-unique V1=>PiV1 V1=>PiV1' env`eq/ PiV1<=>PiV1'
    <- reftyping-ok/if B=>PiB1 V1=>PiV1 R0=>O0 TYP-E1
      (tTrans
        (transform/implies
          (implies/equiv
            (equiv/combine PiB1<=>PiB2 PiV1<=>PiV1')))
        (letTyping/base null TYP-E2)
        (TRANS1))
      _ IF-TYP TRANS.

%worlds (gtermvar) (reftyping-ok _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(reftyping-ok/expr/write _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(reftyping-ok/args _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

%total (T WT AT) (reftyping-ok _ _ _ _ _ _ T _ _ _ _ _ _ _)
(reftyping-ok/expr/write _ _ _ _ _ _ _ WT _ _ _ _ _ _ _)
(reftyping-ok/args _ _ _ _ _ _ _ AT _ _ _ _ _ _ _).



%%% Method Typing


% Checking method type against func

methtymatch* : env -> env -> clsmap -> methmap -> cxt -> func -> methty -> type.

%%% if we have sub rule, then RT should match T,
%%% hence subtype will not be needed.

methtymatch/base :
    ty2new-reftype T RT ->
    reftyping CM MM B Vin E (result/expr RT Vout) ->
  methtymatch* Vin Vout CM MM B (func/0 E) (methty/base T).

methtymatch/args/shared :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
    ({x} methtymatch* Vin Vout CM MM (B1 x) (F x) MT) ->
  methtymatch* Vin Vout CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/shared C) _ MT).

methtymatch/args/unique :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) ->
    clsmap`lookup CM C FM ->
    fldmap`domain FM FS ->
    nat+set2set (s N) FS Mf ->
    set`add Uin (s N) Uin' ->
    set`union Min Mf Min' ->
    ({x} methtymatch* (env/ Uin' Min') Vout CM MM (B1 x) (F x) MT) ->
  methtymatch* (env/ Uin Min) Vout CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/unique C) _ MT).

methtymatch/args/borrow :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/borrow C)) (B1 x)) ->
    nat+set2set (s N) FS Mf ->
    set`union Min Mf Min' ->
    set`union Mout Mf Mout' ->
    ({x} methtymatch* (env/ Uin Min') (env/ Uout Mout') CM MM (B1 x) (F x) MT) ->
  methtymatch* (env/ Uin Min) (env/ Uout Mout) CM MM B0 (func/+ F)
    (methty/arg (ty/ NN annot/borrow C) FS MT).

%abbrev methtymatch = [CM][MM][F][MT] methtymatch* empty-env empty-env CM MM cxt/0 F MT.


%%% Theorems about matching methmap with proctype

%theorem methtymatch-respects-eq
  : forall* {CM} {MM} {F1} {F2} {MT1} {MT2}
    forall {F1-MT1: methtymatch CM MM F1 MT1}
    {F1=F2: func`eq F1 F2}
    {MT1=MT2: methty`eq MT1 MT2}
    exists {F2-MT2: methtymatch CM MM F2 MT2}
    true.

- : methtymatch-respects-eq M func`eq/ methty`eq/ M.

%worlds (gtermvar) (methtymatch-respects-eq _ _ _ _).
%total { } (methtymatch-respects-eq _ _ _ _).


%theorem shift-preserves-progtypematch
  : forall* {W} {W1} {W2} {G1} {G2} {N}
    forall {PM: progtypematch* W W1 G1}
    {SH: progtype`shift N W1 W2}
    {SH: prog`shift N G1 G2}
    exists {PM: progtypematch* W W2 G2}
    true.

- : shift-preserves-progtypematch PM progtype`shift/0 prog`shift/0 PM.

- : shift-preserves-progtypematch (progtypematch/+ PM PTM) _ _ (progtypematch/+ PM PTM).

%worlds (gtermvar) (shift-preserves-progtypematch _ _ _ _).
%total { } (shift-preserves-progtypematch _ _ _ _).


%theorem shift-preserves-progtypematch-converse/L
  : forall* {W} {W1} {G1} {FUN} {PT} {N1} {N2}
    forall {W1-G1: progtypematch* W W1 G1}
		{F-P: proctypematch W FUN PT}
		{N1=N2: nat`eq N1 N2}
    exists {W2-G2: progtypematch* W (progtype`map/+ N1 PT W1) (prog`map/+ N2 FUN G1)}
    true.

- : shift-preserves-progtypematch-converse/L W1-G1 F-P nat`eq/ (progtypematch/+ W1-G1 F-P).

%worlds (gtermvar) (shift-preserves-progtypematch-converse/L _ _ _ _).
%total { } (shift-preserves-progtypematch-converse/L _ _ _ _).


%theorem shift-preserves-progtypematch-converse
  : forall* {W} {W1} {W2} {G1} {G2} {N}
    forall {PM: progtypematch* W W2 G2}
    {SH: progtype`shift N W1 W2}
    {SH: prog`shift N G1 G2}
    exists {PM: progtypematch* W W1 G1}
    true.

- : shift-preserves-progtypematch-converse PM progtype`shift/0 prog`shift/0 PM.

- : shift-preserves-progtypematch-converse
    (progtypematch/+ W1-G1 F-P) (progtype`shift/+ P1) (prog`shift/+ P2) W2-G2
    <- nat`plus-left-cancels P1 P2 nat`eq/ nat`eq/ N1=N2
    <- shift-preserves-progtypematch-converse/L W1-G1 F-P N1=N2 W2-G2.

%worlds (gtermvar) (shift-preserves-progtypematch-converse _ _ _ _).
%total (PM) (shift-preserves-progtypematch-converse PM _ _ _).


%theorem methmap2progtype-preserves-fresh
  : forall* {PM} {CM} {MM} {W} {N}
    forall {MM2W: methmap2progtype PM CM MM W}
    {FS: methmap`fresh MM N}
    exists {FS: progtype`fresh W N}
    true.

%worlds (gtermvar) (methmap2progtype-preserves-fresh _ _ _).
%trustme %total { } (methmap2progtype-preserves-fresh MW _ _).


%theorem methtymatch-implies-proctypematch*/L1
  : forall* {CM} {PM} {B} {T} {RT} {PF}
    forall {T=>RT: ty2new-reftype T RT}
    {RT=>PF: reftype2perm CM PM B RT ([o][r][p] PF o r p)}
    exists {PF'} {T=>PF': ty2perm PM T ([x] PF' x)}
    {EQ: {o}{r}{p} permission`eq (PF o r p) (PF' o)}
    true.

- : methtymatch-implies-proctypematch*/L1
    ty2new-reftype/unique (reftype2perm/fresh T2PF) _ T2PF ([_][_][_] permission`eq/).

- : methtymatch-implies-proctypematch*/L1
    ty2new-reftype/shared (reftype2perm/shared T2PF) _ T2PF ([_][_][_] permission`eq/).

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L1 _ _ _ _ _).
%total { } (methtymatch-implies-proctypematch*/L1 _ _ _ _ _).


%theorem methtymatch-implies-proctypematch*/L2
  : forall* {CM} {B} {M0} {N} {FS} {M1}
    forall {CM-B-OS: clsmap-cxt-capset CM B M0}
    {N!<B: cxt`fresh B (s N)}
    {N+FS=>M1: nat+set2set (s N) FS M1}
    exists {DJ: set`disjoint M0 M1}
    true.

%theorem methtymatch-implies-proctypematch*/L2L
  : forall* {N} {FS} {M}
    forall {N+FS=>M: nat+set2set (s N) FS M}
    exists {NM: set`not-member M z}
    true.

%theorem methtymatch-implies-proctypematch*/L2L/L
  : forall* {N} {FS} {M}
    forall {N+FS=>M: nat+set2set (s N) FS M}
    {B} {MB?: set`member? M z B}
    exists {NM: set`not-member M z}
    true.

- : methtymatch-implies-proctypematch*/L2L/L N+FS=>M true (set`member?/in Z<-M) NM
    <- set`lookup-implies-not-member-update Z<-M M' Z!<M' M'+Z=M
    <- nat+set2set/UP-inversion N+FS=>M Z!<M' M'+Z=M FSP _ _ N+F=Z _
    <- nat2pair-deterministic/0 N+F=Z PE
    <- pair-eq-implies-eq PE EQ' _
    <- nat`eq-symmetric EQ' EQ
    <- nat`eq-contradiction EQ V
    <- set`false-implies-not-member V NM.

- : methtymatch-implies-proctypematch*/L2L/L _ false (set`member?/out NM) NM.

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L2L/L _ _ _ _).
%total { } (methtymatch-implies-proctypematch*/L2L/L _ _ _ _).

- : methtymatch-implies-proctypematch*/L2L N+FS=>M NM
    <- set`member?-total MB?
    <- methtymatch-implies-proctypematch*/L2L/L N+FS=>M _ MB? NM.

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L2L _ _).
%total { } (methtymatch-implies-proctypematch*/L2L _ _).


- : methtymatch-implies-proctypematch*/L2 clsmap-cxt-capset/0 _ _ set`disjoint/L.

- : methtymatch-implies-proctypematch*/L2 _ _ nat+set2set/0 set`disjoint/R.

- : methtymatch-implies-proctypematch*/L2 (clsmap-cxt-capset/z CM-B-M0P Z!<M0P M0P+Z=M0)
    N!<B N+FS=>M1 M0^M1
    <- methtymatch-implies-proctypematch*/L2 CM-B-M0P N!<B N+FS=>M1 M0P^M1
    <- methtymatch-implies-proctypematch*/L2L N+FS=>M1 Z!<M1
    <- set`disjoint-symmetric M0P^M1 M1^M0P
    <- set`not-member-add-preserves-disjoint M1^M0P Z!<M1 M0P+Z=M0 M1^M0
    <- set`disjoint-symmetric M1^M0 M0^M1.

- : methtymatch-implies-proctypematch*/L2
    (clsmap-cxt-capset/U CM-B-M0P N+F=K BL _ CML FML K!<M0P M0P+K=M0)
    N!<B N+FS=>M1 M0^M1
    <- cxt`fresh-lookup-not-equal N!<B BL (NE:nat`ne (s N) N0)
    <- nat+set2set-nat-ne-implies-disjoint/L N+FS=>M1 NE N+F=K K!<M1
    <- methtymatch-implies-proctypematch*/L2 CM-B-M0P N!<B N+FS=>M1 M0P^M1
    <- set`disjoint-symmetric M0P^M1 M1^M0P
    <- set`not-member-add-preserves-disjoint M1^M0P K!<M1 M0P+K=M0 M1^M0
    <- set`disjoint-symmetric M1^M0 M0^M1.

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L2 _ _ _ _).
%total (A) (methtymatch-implies-proctypematch*/L2 A _ _ _).


%%% Here Piin should be PiB + PiVin, and Piout should be PiB + PiVout
%theorem methtymatch-implies-proctypematch*
  : forall* {CM} {MM} {PM} {B} {W} {MT} {F} {Vin} {Vout}
    {PT} {PiB} {Piin} {Piout} {PiVin} {PiVout}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-Vin: clsmap-cxt-env CM B Vin}
    {CM-B-Vout: clsmap-cxt-env CM B Vout}
    {B=>PiB: cxt2perm PM B PiB}
    {Vin=>Piin: env2input CM PM B Vin PiVin}
    {Vout=>Piout: env2input CM PM B Vout PiVout}
    {IMP: implies Piin (PiB , PiVin)}
    {IMP: implies (PiB , PiVout) Piout}
    {CM-MT: clsmap-methty CM MT}
    {MC: methtymatch* Vin Vout CM MM B F MT}
    {MT=>PT: methty2proctype* CM PM Piin Piout MT PT}
    exists {PC: proctypematch W F PT}
    true.

- : methtymatch-implies-proctypematch*
    CM-CM CM-MM CM2PM MM2W CM-B CM-B-Vin CM-B-Vout
    (B=>PiB:cxt2perm PM B PiB)
    (Vin=>PiVin:env2input CM PM B Vin PiVin)
    (Vout=>PiVout:env2input CM PM B Vout PiVout)
    IMP0 IMP1
    (clsmap-methty/base CM-T)
    (methtymatch/base T=>RT RTYP)
    (methty2proctype/base (T2PF:ty2perm PM T PF))
    (proctypematch/base
      (tTrans
        (transform/implies
          (implies/trans IMP0
            (implies/equiv (equiv/combine PiB<=>PiB' PiVin<=>PiVin'))))
        (letTyping/base null TYP)
        (transform/inside [o]
          (transform/trans3
            (transform/inside [r]
              (transform/inside [p]
                (transform/implies
                  (implies/trans4
                    (implies/equiv equiv/identity)
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/combine
                          (equiv/transitive (EQV o r p) (PF'<=>PF o))
                          (PiVout'<=>PiVout))))
                    (implies/equiv equiv/reorder)
                    (implies/combine implies/reflexive
                      (implies/trans
                        (implies/combine (implies/equiv PiB''<=>PiB) implies/reflexive)
                        (IMP1)))))))
            (transform/rem-unused)
            (transform/rem-unused)))))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-Vin RTYP PiB' PiVin' _ B=>PiB'
      Vin=>PiVin'
      (result2output/expr
        (B=>PiB'':cxt2perm PM B PiB'')
        (Vout=>PiVout':env2input CM PM B Vout PiVout')
        RT=>PF) TYP
    <- env2input-unique Vin=>PiVin Vin=>PiVin' env`eq/ PiVin<=>PiVin'
    <- methtymatch-implies-proctypematch*/L1 T=>RT RT=>PF PF' T2PF' EQ
    <- ({o}{r}{p} permission`eq-implies-equiv (EQ o r p) (EQV o r p))
    <- cxt2perm-equiv B=>PiB B=>PiB' predmap`eq/ cxt`eq/ PiB<=>PiB'
    <- cxt2perm-equiv B=>PiB'' B=>PiB predmap`eq/ cxt`eq/ PiB''<=>PiB
    <- env2input-unique Vout=>PiVout' Vout=>PiVout env`eq/ PiVout'<=>PiVout
    <- ty2perm-deterministic T2PF' T2PF predmap`eq/ ty`eq/ PF'=PF
    <- ({x} permission`eq-implies-equiv (PF'=PF x) (PF'<=>PF x)).

- : methtymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (CM-B0-Vin:clsmap-cxt-env CM B0 Vin)
    (CM-B0-Vout:clsmap-cxt-env CM B0 Vout)
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (B0+Vin=>PiVin:env2input CM PM B0 Vin PiVin)
    (B0+Vout=>PiVout:env2input CM PM B0 Vout PiVout)
    (IMP0:implies Piin (PiB0 , PiVin))
    (IMP1:implies (PiB0 , PiVout) Piout)
    (clsmap-methty/args CM-MT CML DM LE)
    (methtymatch/args/shared N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) x)
      ([x] MC x))
    (methty2proctype/arg
      (argtype2perm/shared T2PF) MT=>PT)
    (proctypematch/arg PC)
    <- cxt`fresh-update-preserves-env2input B0+Vin=>PiVin N!<B0 B0+N=B1 B1+Vin=>PiVin
    <- cxt`fresh-update-preserves-env2input B0+Vout=>PiVout N!<B0 B0+N=B1 B1+Vout=>PiVout
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vin N!<B0 B0+N=B1 CM-B1-Vin
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vout N!<B0 B0+N=B1 CM-B1-Vout
    <- ({x} methtymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (CM-B1-Vin x) (CM-B1-Vout x)
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/shared T2PF))
         (B1+Vin=>PiVin x) (B1+Vout=>PiVout x)
         (implies/trans
           (implies/combine implies/reflexive (IMP0))
           (implies/associate))
         (implies/trans
           (implies/symmetric-associate)
           (implies/combine implies/reflexive IMP1))
         (CM-MT) (MC x) (MT=>PT x)
         (PC x)).

- : methtymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (clsmap-cxt-env/ CM-B0-Uin CM-B0-Min)
    (clsmap-cxt-env/ CM-B0-Uout CM-B0-Mout)
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (env2input/ (B0+Uin=>PiUin:make-encumbered CM PM B0 Uin PiUin)
      (B0+Min=>PiMin:capset2perm CM PM B0 Min PiMin))
    (env2input/ (B0+Uout=>PiUout:make-encumbered CM PM B0 Uout PiUout)
      (B0+Mout=>PiMout:capset2perm CM PM B0 Mout PiMout))
    (IMP0) (IMP1)
    (clsmap-methty/args CM-MT (CML2:clsmap`lookup CM C FM2)
      (DM2:fldmap`domain FM2 FS2) LE2)
    (methtymatch/args/borrow N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/borrow C)) (B1 x)) x)
      (N+FS=>Mf:nat+set2set (s N) FS3 Mf) (Min+Mf=Min':set`union Min Mf Min')
      (Mout+Mf=Mout':set`union Mout Mf Mout')
      ([x] MC x))
    (methty2proctype/arg
      (argtype2perm/borrow (CML:clsmap`lookup CM C FM)
        (DM:fldmap`domain FM FS) LE FS=>PF T2PFB) MT=>PT)
    (proctypematch/arg PC)
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- cxt`fresh-update-preserves-make-encumbered B0+Uin=>PiUin N!<B0 B0+N=B1 B1+Uin=>PiUin
    <- cxt`fresh-update-preserves-capset2perm B0+Min=>PiMin N!<B0 B0+N=B1 B1+Min=>PiMin
    <- cxt`fresh-update-preserves-make-encumbered B0+Uout=>PiUout N!<B0 B0+N=B1 B1+Uout=>PiUout
    <- cxt`fresh-update-preserves-capset2perm B0+Mout=>PiMout N!<B0 B0+N=B1 B1+Mout=>PiMout
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uin N!<B0 B0+N=B1 CM-B1-Uin
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Min N!<B0 B0+N=B1 CM-B1-Min
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uout N!<B0 B0+N=B1 CM-B1-Uout
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Mout N!<B0 B0+N=B1 CM-B1-Mout
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} nat+set2set-implies-clsmap-cxt-capset/L CML DM LE (B1-L x) not-shared/borrow
         N+FS=>Mf (CM-B1-Mf x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Min x) (CM-B1-Mf x) Min+Mf=Min'
         (CM-B1-Min' x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Mout x) (CM-B1-Mf x) Mout+Mf=Mout'
         (CM-B1-Mout' x))
    <- letRefTyping-helper/base/unique/L4L2* CML FS=>PF B1-L N+FS=>Mf _ B1+Mf=>PiMf IMP5 IMP6
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Min N!<B0 N+FS=>Mf Min^Mf
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Mout N!<B0 N+FS=>Mf Mout^Mf
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Min^Mf Min+Mf=Min')
         (B1+Min=>PiMin x) (B1+Mf=>PiMf x) _ (B1+Min'=>PiMin' x) (EQV1 x))
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Mout^Mf Mout+Mf=Mout')
         (B1+Mout=>PiMout x) (B1+Mf=>PiMf x) _ (B1+Mout'=>PiMout' x) (EQV2 x))
    <- not-unique-perm-implies-empty T2PFB not-unique/borrow IMP7
    <- ({x} methtymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (clsmap-cxt-env/ (CM-B1-Uin x) (CM-B1-Min' x))
         (clsmap-cxt-env/ (CM-B1-Uout x) (CM-B1-Mout' x))
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/borrow T2PFB))
         (env2input/ (B1+Uin=>PiUin x) (B1+Min'=>PiMin' x))
         (env2input/ (B1+Uout=>PiUout x) (B1+Mout'=>PiMout' x))
         (implies/trans3
           (implies/combine implies/reflexive (IMP0))
           (implies/equiv equiv/swap-middle)
           (implies/combine implies/reflexive
             (implies/trans3
               (implies/combine (IMP5 x) implies/reflexive)
               (implies/equiv equiv/reorder)
               (implies/combine implies/reflexive
                 (implies/trans implies/commute (implies/equiv (EQV1 x)))))))
         (implies/trans4
           (implies/combine
             (implies/trans
               (implies/combine (IMP7 x) implies/reflexive)
               (implies/commute-identity))
             (implies/trans
               (implies/combine
                 (implies/reflexive)
                 (implies/trans
                   (implies/equiv (equiv/symmetric (EQV2 x)))
                   (implies/combine implies/reflexive (IMP6 x))))
               (implies/associate)))
           (implies/associate)
           (implies/combine (IMP1) implies/reflexive)
           (implies/commute))
         (CM-MT) (MC x) (MT=>PT x)
         (PC x)).

- : methtymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (clsmap-cxt-env/ CM-B0-Uin CM-B0-Min)
    CM-B0-Vout
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (env2input/ (B0+Uin=>PiUin:make-encumbered CM PM B0 Uin PiUin)
      (B0+Min=>PiMin:capset2perm CM PM B0 Min PiMin))
    (B0+Vout=>PiVout:env2input CM PM B0 Vout PiVout)
    (IMP0)
    (IMP1:implies (PiB0 , PiVout) Piout)
    (clsmap-methty/args CM-MT (CML2:clsmap`lookup CM C FM2)
      (DM2:fldmap`domain FM2 FS2) LE)
    (methtymatch/args/unique N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) x)
      (CML:clsmap`lookup CM C FM) (DM:fldmap`domain FM FS)
      (N+FS=>Mf:nat+set2set (s N) FS Mf) (Uin+N=Uin':set`add Uin (s N) Uin')
      (Min+Mf=Min':set`union Min Mf Min')
      ([x] MC x))
    (methty2proctype/arg
      (argtype2perm/unique T2PF) MT=>PT)
    (proctypematch/arg PC)
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- cxt`fresh-update-preserves-make-encumbered B0+Uin=>PiUin N!<B0 B0+N=B1 B1+Uin=>PiUin
    <- cxt`fresh-update-preserves-capset2perm B0+Min=>PiMin N!<B0 B0+N=B1 B1+Min=>PiMin
    <- cxt`fresh-update-preserves-env2input B0+Vout=>PiVout N!<B0 B0+N=B1 B1+Vout=>PiVout
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uin N!<B0 B0+N=B1 CM-B1-Uin
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Min N!<B0 B0+N=B1 CM-B1-Min
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vout N!<B0 B0+N=B1 CM-B1-Vout
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- cxt`domain-total (DM-B0=BS0:cxt`domain B0 BS0)
    <- clsmap-cxt-objset-implies-domain-leq CM-B0-Uin DM-B0=BS0 Uin<=BS0
    <- cxt`domain-preserves-fresh N!<B0 DM-B0=BS0 N!<BS0
    <- set`not-member-respects-geq N!<BS0 Uin<=BS0 N!<Uin
    <- ({x} nat+set2set-implies-clsmap-cxt-capset CML DM (B1-L x) not-shared/unique
         N+FS=>Mf (CM-B1-Mf x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Min x) (CM-B1-Mf x) Min+Mf=Min'
         (CM-B1-Min' x))
    <- letRefTyping-helper/base/unique/L4L1** CM-CM CM2PM CML PML DM T2PF _ _ FS=>PF T2PFB IMP4
    <- letRefTyping-helper/base/unique/L4L2* CML FS=>PF B1-L N+FS=>Mf _ B1+Mf=>PiMf IMP5 _
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Min N!<B0 N+FS=>Mf Min^Mf
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Min^Mf Min+Mf=Min')
         (B1+Min=>PiMin x) (B1+Mf=>PiMf x) _ (B1+Min'=>PiMin' x) (EQV x))
    <- not-unique-perm-implies-empty T2PFB not-unique/borrow IMP7
    <- ({x} methtymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (clsmap-cxt-env/
           (clsmap-cxt-objset/U (CM-B1-Uin x) (B1-L x) CML N!<Uin Uin+N=Uin')
           (CM-B1-Min' x))
         (CM-B1-Vout x)
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/unique T2PFB))
         (env2input/
           (make-encumbered/U (B1+Uin=>PiUin x) (B1-L x) CML PML DM
             FS=>PF N!<Uin Uin+N=Uin')
           (B1+Min'=>PiMin' x))
         (B1+Vout=>PiVout x)
         (implies/trans5
           (implies/combine (IMP4 x) (IMP0))
           (implies/equiv equiv/swap-middle)
           (implies/combine
             (implies/equiv equiv/swap) (implies/reflexive))
           (implies/symmetric-associate)
           (implies/combine implies/reflexive
             (implies/trans3
               (implies/combine implies/reflexive implies/reorder)
               (implies/associate)
               (implies/combine implies/reflexive
                 (implies/trans3
                   (implies/commute)
                   (implies/combine implies/reflexive (IMP5 x))
                   (implies/equiv (EQV x)))))))
         (implies/trans
           (implies/symmetric-associate)
           (implies/combine (IMP7 x) (IMP1)))
         (CM-MT) (MC x) (MT=>PT x)
         (PC x)).

%worlds (gtermvar) (methtymatch-implies-proctypematch* _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (M) (methtymatch-implies-proctypematch* _ _ _ _ _ _ _ _ _ _ _ _ _ M _ _).


%theorem methtymatch-implies-proctypematch
  : forall* {CM} {MM} {PM} {W} {MT} {F} {PT}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-MT: clsmap-methty CM MT}
    {F-MT: methtymatch CM MM F MT}
    {MT=>PT: methty2proctype CM PM MT PT}
    exists {PC: proctypematch W F PT}
    true.

- : methtymatch-implies-proctypematch CM-CM CM-MM CM2PM MM2W
    CM-MT F-MT MT=>PT F-PT
    <- methtymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
      clsmap-cxt/0
      (clsmap-cxt-env/ clsmap-cxt-objset/0 clsmap-cxt-capset/0)
      (clsmap-cxt-env/ clsmap-cxt-objset/0 clsmap-cxt-capset/0)
      (cxt2perm/0)
      (env2input/ make-encumbered/0 capset2perm/0)
      (env2input/ make-encumbered/0 capset2perm/0)
      (implies/trans
        (implies/symmetric-identity)
        (implies/combine implies/reflexive (implies/symmetric-identity)))
      (implies/trans
        (implies/combine implies/reflexive implies/identity)
        (implies/identity))
      CM-MT F-MT MT=>PT F-PT.

%worlds (gtermvar) (methtymatch-implies-proctypematch _ _ _ _ _ _ _ _).
%total { } (methtymatch-implies-proctypematch _ _ _ _ _ _ _ _).



%%% A set of helper relations to prove the case of constymatch

%%% Bijection between raw field permissions and set members

set-rawfldperm : set -> (object -> permission) -> type.

set-rawfldperm/0 : set-rawfldperm set/0 ([_] empty).

set-rawfldperm/+
  : set-rawfldperm S ([t] (unitperm (basic t F null)) , (B t))
    <- set`union S1 (set/1 F) S
    <- set`not-member S1 F
    <- set-rawfldperm S1 B.


%%% Bijection between assembled field permissions and set members

set-fldpred : predmap -> fldmap -> set -> (object -> permission) -> type.

set-fldpred/0 : set-fldpred _ _ set/0 ([_] empty).

set-fldpred/+
  : set-fldpred PM FM S ([t] ((unitperm (precise-exists t F PF)) , (R t)))
    <- fldmap`lookup FM F T
    <- ty2perm PM T PF
    <- set`union S1 (set/1 F) S
    <- set`not-member S1 F
    <- set-fldpred PM FM S1 ([t] R t).


%%% Relation between set of fields and expr in constructor
%%% it simply says all fields appeared in the expr must be
%%% in the set.

set-expr : set -> (object -> expr) -> type.

set-expr/0 : set-expr _ ([t] lit t).

set-expr/+
  : set-expr S ([t] (seq (write (lit t) F _)) (B t))
    <- set`member S F
    <- set-expr S B.


%%% Property of nonnull set

nonnull-set : fldmap -> set -> type.

nonnull-set/0 : nonnull-set _ set/0.

nonnull-set/+
  : nonnull-set FM S
    <- fldmap`lookup FM F (ty/ nn/yes _ _)
    <- set`not-member SP F % this is not necessary, but will make proof easier
    <- set`add SP F S
    <- nonnull-set FM SP.


maynull-set : fldmap -> set -> type.

maynull-set/0 : maynull-set _ set/0.

maynull-set/+
  : maynull-set FM S
    <- fldmap`lookup FM F (ty/ nn/may _ _)
    <- set`not-member SP F
    <- set`add SP F S
    <- maynull-set FM SP.


%%% Select nonnull fields

select-nn-fields : fldmap -> set -> type.

select-nn-fields/0 : select-nn-fields fldmap/0 set`set/0.

select-nn-fields/in
 : select-nn-fields (fldmap/+ F (ty/ nn/yes _ _) M) S
    <- fldmap`shift F M M'
    <- select-nn-fields M' S'
    <- set`union S' (set/1 F) S.

select-nn-fields/out
  : select-nn-fields (fldmap/+ F (ty/ nn/may _ _) M) S
    <- fldmap`shift F M M'
    <- select-nn-fields M' S.


%%% Some Lemmas

%theorem fldmap-shift-preserves-fresh
  : forall* {M1} {M2} {N} {F} {T}
    forall {NM: fldmap`fresh (fldmap`map/+ F T M1) N}
    {SH: fldmap`shift F M1 M2}
    exists {NM: fldmap`fresh M2 N}
    true.

- : fldmap-shift-preserves-fresh _ fldmap`shift/0 fldmap`fresh/0.

- : fldmap-shift-preserves-fresh FS (fldmap`shift/+ SF+N2=N3) FS1
    <- nat`plus-swap-succ SF+N2=N3 F+SN2=N3
    <- nat`plus-commutative F+SN2=N3 SN2+F=N3
    <- fldmap`update-preserves-fresh-converse FS (fldmap`update/< SN2+F=N3) FS1.

%worlds () (fldmap-shift-preserves-fresh _ _ _).
%total (SH) (fldmap-shift-preserves-fresh _ SH _).


%%% Theorems about set-rawfldperm

%theorem set-rawfldperm-respects-eq
  : forall* {S1} {P1} {S2} {P2}
    forall {SR: set-rawfldperm S1 ([t] P1 t)}
		{EQ: set`eq S1 S2} {EQ: {t} permission`eq (P1 t) (P2 t)}
    exists {SR: set-rawfldperm S2 ([t] P2 t)}
    true.

- : set-rawfldperm-respects-eq SR set`eq/ ([_] permission`eq/) SR.

%worlds (gtermvar) (set-rawfldperm-respects-eq _ _ _ _).
%total { } (set-rawfldperm-respects-eq _ _ _ _).


%theorem allocfields-implies-set-rawfldperm
  :	forall* {FM} {S} {P1}
    forall {DM: fldmap`domain FM S}
		{SR: {t} allocFields t S (P1 t)}
    exists {P2} {I: {t} implies (P1 t) (P2 t)}
    {SR: set-rawfldperm S ([t] P2 t)}
    true.

- : allocfields-implies-set-rawfldperm
    fldmap`domain/0 ([_] allocFields/0) _ ([_] implies/reflexive) set-rawfldperm/0.


- : allocfields-implies-set-rawfldperm
    (fldmap`domain/+ DM-FM) ([t] allocFields/+ F<<S=SP (SP->PP t))
    _ ([t] implies/trans
        (implies/equiv equiv/commute)
        (implies/combine
          (implies/reflexive)
          (I t)))
    (set-rawfldperm/+ SP-B F/SP SPUF=S)
    <- fldmap`shift-total F<<FM=FMP
    <- fldmap`shift-preserves-domain* DM-FM F<<FM=FMP F<<S=SP DM-FMP
    <- allocfields-implies-set-rawfldperm DM-FMP SP->PP _ ([t] I t) SP-B
    <- set`shift-implies-not-member F<<S=SP F/SP
    <- set`shift-implies-update F<<S=SP SP+N=S
    <- set`add-implies-unit-union SP+N=S SPUF=S.

%worlds (gtermvar) (allocfields-implies-set-rawfldperm _ _ _ _ _).
%total (SR) (allocfields-implies-set-rawfldperm _ SR _ _ _).


%%% This theorem says given a bijection between a set and a sequence of bare
%%% field permissions, for any given element in the set, we can reorder the
%%% permissions and move the corresponding field permission to the front.
%%% the rest of set and rest permission still preserve the bijection property.

%theorem set-rawfldperm-reorder
  : forall* {S} {FP} {F}
    forall {S-RP: set-rawfldperm S ([t] FP t)} {IN: set`member S F}
    exists {R} {IMP: {t} implies (FP t) ((unitperm (basic t F null)) , (R t))}
    {S1} {S1-R: set-rawfldperm S1 ([t] R t)}
    {NM: set`not-member S1 F} {U: set`union S1 (set/1 F) S}
    true.

%theorem set-rawfldperm-reorder/L
  : forall* {S} {S1} {F} {N} {R}
    forall {C} {CMP: nat`compare N F C}
    {S1-R: set-rawfldperm S1 ([t] R t)}
    {N/S1: set`not-member S1 N}
    {U: set`union S1 (set/1 N) S}
    {IN: set`member S F}
    exists {RP}
    {IMP: {t} implies ((unitperm (basic t N null)) , (R t))
          ((unitperm (basic t F null)) , (RP t))}
    {S2} {S2-RP: set-rawfldperm S2 ([t] RP t)}
		{F/S2: set`not-member S2 F} {U: set`union S2 (set/1 F) S}
    true.

- : set-rawfldperm-reorder/L equal
    _ S1-R N/S1 S1UN=S _ _ ([_] implies/reflexive) _ S1-R N/S1 S1UN=S.

- : set-rawfldperm-reorder/L less
    C S1-R N/S1 S1UN=S F&S _
    ([t] implies/trans
      (implies/combine
        (implies/reflexive)
        (IMP t))
      (implies/equiv equiv/roll2))
    S3 (set-rawfldperm/+ S2-RP N/S2 S2UN=S3) F/S3 S3UF=S
    <- nat`less-implies-lt C F>N
    <- set`ne-implies-unit-map-not-member (nat`ne/< F>N) F/N
    <- set`not-member-union-right-preserves-lookup-converse F&S F/N S1UN=S F&S1
    <- set-rawfldperm-reorder S1-R F&S1 RP ([t] IMP t) S2 S2-RP F/S2 S2UF=S1
    <- set`union-preserves-not-member-converse* N/S1 S2UF=S1 N/S2 _
    <- set`union-commutative S2UF=S1 FUS2=S1
    <- set`union-associative FUS2=S1 S1UN=S S3 S2UN=S3 FUS3=S
    <- set`union-commutative FUS3=S S3UF=S
    <- set`union-preserves-not-member* F/S2 F/N S2UN=S3 F/S3.

- : set-rawfldperm-reorder/L greater
    C S1-R N/S1 S1UN=S F&S _
    ([t] implies/trans
      (implies/combine
        (implies/reflexive)
        (IMP t))
      (implies/equiv equiv/roll2))
    S3 (set-rawfldperm/+ S2-RP N/S2 S2UN=S3) F/S3 S3UF=S
    <- nat`greater-implies-gt C N>F
    <- set`ne-implies-unit-map-not-member (nat`ne/> N>F) F/N
    <- set`not-member-union-right-preserves-lookup-converse F&S F/N S1UN=S F&S1
    <- set-rawfldperm-reorder S1-R F&S1 RP ([t] IMP t) S2 S2-RP F/S2 S2UF=S1
    <- set`union-preserves-not-member-converse* N/S1 S2UF=S1 N/S2 _
    <- set`union-commutative S2UF=S1 FUS2=S1
    <- set`union-associative FUS2=S1 S1UN=S S3 S2UN=S3 FUS3=S
    <- set`union-commutative FUS3=S S3UF=S
    <- set`union-preserves-not-member* F/S2 F/N S2UN=S3 F/S3.

- : set-rawfldperm-reorder
    (set-rawfldperm/+ S1-R N/S1 S1UN=S) F&S RP ([t] IMP t) S2 S2-RP F/S2 S2UF=S
    <- nat`compare-total CMP
    <- set-rawfldperm-reorder/L _ CMP S1-R N/S1 S1UN=S F&S RP IMP S2 S2-RP F/S2 S2UF=S.

%worlds (gtermvar) (set-rawfldperm-reorder _ _ _ _ _ _ _ _)
  (set-rawfldperm-reorder/L _ _ _ _ _ _ _ _ _ _ _ _).

%total (SP1 SP2) (set-rawfldperm-reorder SP1 _ _ _ _ _ _ _)
  (set-rawfldperm-reorder/L _ _ SP2 _ _ _ _ _ _ _ _ _).


%%% Theorems about set-fldpred

%theorem set-fldpred-respects-eq
  :	forall* {PM1} {PM2} {FM1} {FM2} {S1} {S2} {P1} {P2}
    forall {SF: set-fldpred PM1 FM1 S1 ([t] P1 t)}
		{EQ: predmap`eq PM1 PM2} {EQ: fldmap`eq FM1 FM2}
		{EQ: set`eq S1 S2} {EQ: {o} permission`eq (P1 o) (P2 o)}
    exists {SF: set-fldpred PM2 FM2 S2 ([t] P2 t)}
    true.

- : set-fldpred-respects-eq SF predmap`eq/ fldmap`eq/ set`eq/ ([_] permission`eq/) SF.

%worlds () (set-fldpred-respects-eq _ _ _ _ _ _).
%total { } (set-fldpred-respects-eq _ _ _ _ _ _).


%theorem set-fldpred-shrink-fldmap
  : forall* {PM} {FM1} {FM} {S} {R} {F} {T}
    forall {SF: set-fldpred PM FM1 S ([t] (R t))}
    {FS: set`not-member S F}
    {U: fldmap`update FM F T FM1}
    exists {SF: set-fldpred PM FM S ([t] (R t))}
    true.

- : set-fldpred-shrink-fldmap set-fldpred/0 _ _ set-fldpred/0.

- : set-fldpred-shrink-fldmap
    (set-fldpred/+ S1-R N/S1 S1UN=S T2PF FM1-L) F/S FM+F=FM1
    (set-fldpred/+ S1-R1 N/S1 S1UN=S T2PF FM-L)
    <- set`union-preserves-not-member-converse* F/S S1UN=S F/S1 _
    <- set-fldpred-shrink-fldmap S1-R F/S1 FM+F=FM1 S1-R1
    <- set`union-left-preserves-member* (set`lookup/= nat`eq/) S1UN=S N#S
    <- set`not-member-lookup-not-equal F/S N#S F!=N
    <- nat`ne-symmetric F!=N N!=F
    <- fldmap`update-preserves-lookup-converse FM1-L FM+F=FM1 N!=F FM-L.

%worlds (gtermvar) (set-fldpred-shrink-fldmap _ _ _ _).
%total (SF) (set-fldpred-shrink-fldmap SF _ _ _).


%%% Similar theorem as set-rawfldperm-reorder, except the relation
%%% is between set and sequence of packed field permissions

%theorem set-fldpred-reorder
  : forall* {PM} {FM} {FP} {S} {F}
    forall {S-FP: set-fldpred PM FM S ([t] FP t)}
    {IN: set`member S F}
    exists {RP}
    {TAS: {r}{t} transform
          (output/expr r (FP t))
          (output/exists [o]
            (output/expr r
              ((unitperm (basic t F o)) , (RP t))))}
    {S1} {S1-RP: set-fldpred PM FM S1 ([t] RP t)}
    {NM: set`not-member S1 F} {U: set`union S1 (set/1 F) S}
    true.

%theorem set-fldpred-reorder/L
  : forall* {PM} {FM} {S} {F} {A}
    {S1} {N} {R} {NN} {PF} {D}
    forall {C} {CMP: nat`compare N F C}
    {S1-R: set-fldpred PM FM S1 ([t] R t)}
    {N/S1: set`not-member S1 N}
    {U: set`union S1 (set/1 N) S}
    {IN: set`member S F}
    {T2PF: ty2perm PM (ty/ NN A D) PF}
    {FM-L: fldmap`lookup FM N (ty/ NN A D)}
    exists {RP}
    {TAS: {r}{t} transform
          (output/expr r ((unitperm (precise-exists t N PF)) , (R t)))
          (output/exists [o]
            (output/expr r ((unitperm (basic t F o)) , (RP t))))}
    {S2} {S2-RP: set-fldpred PM FM S2 ([t] RP t)}
    {F/S2: set`not-member S2 F} {U: set`union S2 (set/1 F) S}
    true.

- : set-fldpred-reorder/L equal
    _ S1-R N/S1 S1UN=S _ (ty2perm/ PM-L nn2perm/yes _) _ _
    ([r][t] transform/trans3
      (transform/implies
        (implies/combine
          (implies/equiv (equiv/symmetric equiv/one))
          (implies/reflexive)))
      (transform/skolem)
      (transform/inside [v]
        (transform/trans
          (transform/implies
            (implies/trans
              (implies/combine
                (implies/trans
                  (implies/equiv equiv/one)
                  (implies/equiv equiv/commute))
                (implies/reflexive))
              (implies/symmetric-associate)))
          (transform/drop))))
    _ S1-R N/S1 S1UN=S.

- : set-fldpred-reorder/L equal
     _ S1-R N/S1 S1UN=S _ (ty2perm/ _ nn2perm/may _) _ _
    ([r][t] transform/trans3
      (transform/implies
        (implies/combine
          (implies/equiv (equiv/symmetric equiv/one))
          (implies/reflexive)))
      (transform/skolem)
      (transform/inside [v]
        (transform/trans
          (transform/implies
            (implies/trans
              (implies/combine
                (implies/trans
                  (implies/equiv equiv/one)
                  (implies/equiv equiv/commute))
                (implies/reflexive))
              (implies/symmetric-associate)))
          (transform/drop))))
     _ S1-R N/S1 S1UN=S.

- : set-fldpred-reorder/L less
    C S1-R N/S1 S1UN=S F&S T2PF FM-L _
    ([r][t] transform/trans
      (TAS' r t)
      (transform/inside [_]
        (transform/implies
          (implies/equiv equiv/roll2))))
    S3 (set-fldpred/+ S2-RP N/S2 S2UN=S3 T2PF FM-L) F/S3 S3UF=S
    <- nat`less-implies-lt C F>N
    <- set`ne-implies-unit-map-not-member (nat`ne/< F>N) F/N
    <- set`not-member-union-right-preserves-lookup-converse F&S F/N S1UN=S F&S1
    <- set-fldpred-reorder S1-R F&S1 RP ([r][t] TAS r t) E2 S2-RP F/S2 S2UF=S1
    <- ({r}{t} transform-commutes-envadd*
         (TAS r t) envadd/expr (envadd/exists [o] envadd/expr) (TAS' r t))
    <- set`union-preserves-not-member-converse* N/S1 S2UF=S1 N/S2 _
    <- set`union-commutative S2UF=S1 FUS2=S1
    <- set`union-associative FUS2=S1 S1UN=S S3 S2UN=S3 FUS3=S
    <- set`union-commutative FUS3=S S3UF=S
    <- set`union-preserves-not-member* F/S2 F/N S2UN=S3 F/S3.

- : set-fldpred-reorder/L greater
    C S1-R N/S1 S1UN=S F&S T2PF FM-L _
    ([r][t] transform/trans
      (TAS' r t)
      (transform/inside [_]
        (transform/implies
          (implies/equiv equiv/roll2))))
    S3 (set-fldpred/+ S2-RP N/S2 S2UN=S3 T2PF FM-L) F/S3 S3UF=S
    <- nat`greater-implies-gt C N>F
    <- set`ne-implies-unit-map-not-member (nat`ne/> N>F) F/N
    <- set`not-member-union-right-preserves-lookup-converse F&S F/N S1UN=S F&S1
    <- set-fldpred-reorder S1-R F&S1 RP ([r][t] TAS r t) _ S2-RP F/S2 S2UF=S1
    <- ({r}{t} transform-commutes-envadd*
         (TAS r t) envadd/expr (envadd/exists [_] envadd/expr) (TAS' r t))
    <- set`union-preserves-not-member-converse* N/S1 S2UF=S1 N/S2 _
    <- set`union-commutative S2UF=S1 FUS2=S1
    <- set`union-associative FUS2=S1 S1UN=S S3 S2UN=S3 FUS3=S
    <- set`union-commutative FUS3=S S3UF=S
    <- set`union-preserves-not-member* F/S2 F/N S2UN=S3 F/S3.

- : set-fldpred-reorder (set-fldpred/+ S1-R N/S1 S1UN=S T2PF FM-L) IN
    RP ([r][t] TAS r t) S2 S2-RP F/S2 S2UF=S
    <- nat`compare-total CMP
    <- set-fldpred-reorder/L _ CMP S1-R N/S1 S1UN=S IN T2PF FM-L
      RP ([r][t] TAS r t) S2 S2-RP F/S2 S2UF=S.

%worlds (gtermvar) (set-fldpred-reorder _ _ _ _ _ _ _ _)
  (set-fldpred-reorder/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).

%total (SF1 SF2) (set-fldpred-reorder SF1 _ _ _ _ _ _ _)
  (set-fldpred-reorder/L _ _ SF2 _ _ _ _ _ _ _ _ _ _ _).


%theorem false-implies-implies-var
  : forall* {P1: object -> permission} {P2}
    forall {V:void}
    exists {IMP: {o} implies (P1 o) (P2 o)}
    true.

%worlds (gtermvar) (false-implies-implies-var _ _).
%total { } (false-implies-implies-var _ _).


%theorem set-fldpred-implies-fldmap2conj/L1
  : forall* {FM} {S1} {S} {F} {T} {N}
    forall {SZ: fldmap`size FM (s N)}
    {DM: fldmap`domain FM S}
    {L: fldmap`lookup FM F T}
    {U: set`union S1 (set/+ F set/0) S}
    {FS: set`not-member S1 F}
    exists {FM1} {SZ: fldmap`size FM1 N}
    {DM: fldmap`domain FM1 S1}
    {FS: fldmap`fresh FM1 F}
    {U: fldmap`update FM1 F T FM}
    true.

- : set-fldpred-implies-fldmap2conj/L1 SZ-FM DM-FM=S FM-L S1UF=S F/S1 %{=>}%
    FM1 SZ-FM1=N DM-FM1=S1 F/FM1 FM1+F=FM
    <- fldmap`can-remove SZ-FM FM-L %{=>}% FM1 N1 SZ-FM1=N1 SN1=SN FM1+F=FM F/FM1
    <- nat`succ-cancels SN1=SN N1=N
    <- fldmap`size-respects-eq SZ-FM1=N1 fldmap`eq/ N1=N SZ-FM1=N
    <- fldmap`domain-total DM-FM1=S2
    <- fldmap`domain-preserves-fresh F/FM1 DM-FM1=S2 F/S2
    <- fldmap`update-commute-domain FM1+F=FM DM-FM1=S2 DM-FM=S S2+F=S
    <- set`not-member-update-implies-unit-union F/S2 S2+F=S S2UF=S
    <- set`union-implies-leq S1UF=S S1<=S F<=S
    <- set`union-implies-leq S2UF=S S2<=S _
    <- set`not-member-implies-unit-disjoint F/S1 S1XF
    <- set`not-member-implies-unit-disjoint F/S2 S2XF
    <- set`disjoint-symmetric S1XF FXS1
    <- set`disjoint-symmetric S2XF FXS2
    <- set`union-commutative S1UF=S FUS1=S
    <- set`union-commutative S2UF=S FUS2=S
    <- set`leq-reflexive _ S<=S
    <- set`remove-characterization S1<=S FXS1 FUS1=S S<=S S/F=S1
    <- set`remove-characterization S2<=S FXS2 FUS2=S S<=S S/F=S2
    <- set`remove-deterministic S/F=S1 S/F=S2 set`eq/ set`eq/ S1=S2
    <- set`eq-symmetric S1=S2 S2=S1
    <- fldmap`domain-respects-eq DM-FM1=S2 fldmap`eq/ S2=S1 DM-FM1=S1.

%worlds () (set-fldpred-implies-fldmap2conj/L1 _ _ _ _ _ _ _ _ _ _).
%total { } (set-fldpred-implies-fldmap2conj/L1 _ _ _ _ _ _ _ _ _ _).


%theorem set-fldpred-implies-fldmap2conj/L2
  : forall* {CM} {PM} {FM} {FM1} {G1} {F} {T} {PF}
    forall {F2C: fldmap2conj CM PM FM1 ([o] G1 o) PM}
    {FS: fldmap`fresh FM1 F}
    {U: fldmap`update FM1 F T FM}
    {T2PF: ty2perm PM T PF}
    exists {G} {F2C: fldmap2conj CM PM FM ([t] G t) PM}
    {IMP: {o} implies (combine (unitperm (precise-exists o F PF)) (G1 o)) (G o)}
    true.

- : set-fldpred-implies-fldmap2conj/L2
    fldmap2conj/0 fldmap`fresh/0 fldmap`update/0 (ty2perm/ PM-L NN2P A2P) _
    (fldmap2conj/in fldmap2conj/0 NN2P A2P fldmap`shift/0 PM-L)
    ([_] implies/reflexive).

- : set-fldpred-implies-fldmap2conj/L2 F2C
    F/FM1 (fldmap`update/< SN3+F=N) (ty2perm/ PM-L NN2P A2P) _
    (fldmap2conj/in F2C NN2P A2P (fldmap`shift/+ SF+N3=N) PM-L)
    ([_] implies/reflexive)
    <- nat`plus-swap-succ SN3+F=N N3+SF=N
    <- nat`plus-commutative N3+SF=N SF+N3=N.

- : set-fldpred-implies-fldmap2conj/L2
    (fldmap2conj/in F2C-FM3 NN2P1 A2P1 N<<FM2=FM3 PM-L1) F/FM1
    (fldmap`update/> FM2+N0=FM4 SN0+N=F) (ty2perm/ PM-L2 NN2P2 A2P2) _
    (fldmap2conj/in F2C-FM5 NN2P1 A2P1 N<<FM4=FM5 PM-L1)
    ([o] implies/trans
      (implies/reorder)
      (implies/combine implies/reflexive (IMP o)))
    <- fldmap`shift-total N<<FM4=FM5
    <- fldmap-shift-preserves-fresh F/FM1 N<<FM2=FM3 F/FM3
    <- nat`plus-swap-succ SN0+N=F N0+SN=F
    <- nat`plus-commutative N0+SN=F SN+N0=F
    <- fldmap`shift-preserves-update* FM2+N0=FM4 N<<FM2=FM3 SN+N0=F N<<FM4=FM5 FM3+F=FM5
    <- set-fldpred-implies-fldmap2conj/L2
      F2C-FM3 F/FM3 FM3+F=FM5 (ty2perm/ PM-L2 NN2P2 A2P2) _ F2C-FM5 ([t] IMP t).

% - : set-fldpred-implies-fldmap2conj/L2 (fldmap2conj/null F2C-FM3 N<<FM2=FM3)
%      F/FM1 (fldmap`update/> FM2+N0=FM4 SN0+N=F) PM-L FNN2P _
%      (fldmap2conj/null F2C-FM5 N<<FM4=FM5) ([t] IMP t)
%      <- fldmap`shift-total N<<FM4=FM5
%      <- fldmap-shift-preserves-fresh F/FM1 N<<FM2=FM3 F/FM3
%      <- nat`plus-swap-succ SN0+N=F N0+SN=F
%      <- nat`plus-commutative N0+SN=F SN+N0=F
%      <- fldmap`shift-preserves-update* FM2+N0=FM4 N<<FM2=FM3 SN+N0=F N<<FM4=FM5 FM3+F=FM5
%      <- set-fldpred-implies-fldmap2conj/L2
% 	F2C-FM3 F/FM3 FM3+F=FM5 PM-L FNN2P _ F2C-FM5 ([t] IMP t).


%%% impossible cases

%theorem set-fldpred-implies-fldmap2conj/L2L
  : forall* {CM} {PMin} {FM} {PMout}
    forall {F:void}
    exists {G} {F2C: fldmap2conj CM PMin FM ([t] G t) PMout}
    true.

%worlds (gtermvar) (set-fldpred-implies-fldmap2conj/L2L _ _ _).
%total { } (set-fldpred-implies-fldmap2conj/L2L _ _ _).


- : set-fldpred-implies-fldmap2conj/L2 _ F/FM1 (fldmap`update/= N=F) _ _ F2C BIMP
    <- nat`eq-symmetric N=F F=N
    <- fldmap`fresh-respects-eq F/FM1 fldmap`eq/ F=N N/FM1
    <- fldmap`fresh-contradiction N/FM1 V
    <- set-fldpred-implies-fldmap2conj/L2L V G F2C
    <- false-implies-implies-var V ([o] BIMP o).

- : set-fldpred-implies-fldmap2conj/L2
    (fldmap2conj/out F2C1
      (F2CF:{p:clspred} fldmap2conj _ _ _ ([o:object] CJ p o) _)
      ([p] PM-U p) _ _ _ _ PM-FS) _ _ _ %{=>}% G F2C IMP
    <- ({p} predmap`update-implies-lookup (PM-U p) (PME-L p))
    <- ({p} fldmap2conj-implies-predmap-leq (F2CF p) (PME<=PMF p))
    <- ({p} predmap`lookup-respects-leq (PME-L p) (PME<=PMF p) _ (PMF-L p) _)
    <- fldmap2conj-implies-predmap-leq F2C1 PMF<=PM
    <- predmap`lookup-respects-leq (PMF-L (conj2pred CJ)) PMF<=PM _ PM-L _
    <- predmap`fresh-lookup-not-equal PM-FS PM-L NE
    <- nat`eq-ne-implies-false nat`eq/ NE V
    <- set-fldpred-implies-fldmap2conj/L2L V G F2C
    <- false-implies-implies-var V ([o] IMP o).

%worlds (gtermvar) (set-fldpred-implies-fldmap2conj/L2 _ _ _ _ _ _ _).
%total (F2C) (set-fldpred-implies-fldmap2conj/L2 F2C _ _ _ _ _ _).


%theorem set-fldpred-implies-fldmap2conj/L
  : forall* {CM} {PM} {FM:fldmap} {S} {FP}
    forall {N} {SZ: fldmap`size FM N} {DM: fldmap`domain FM S}
		{SF: set-fldpred PM FM S ([t] FP t)}
    exists {G} {F2C: fldmap2conj CM PM FM ([t] G t) PM}
    {TAS: {t} transform
          (output/expr t (FP t))
          (output/expr t (G t))}
    true.

- : set-fldpred-implies-fldmap2conj/L z _
     fldmap`domain/0 set-fldpred/0 %{=>}%
    _ fldmap2conj/0 ([t] transform/reflexive).

- : set-fldpred-implies-fldmap2conj/L (s N) SZ DM
    (set-fldpred/+ S1-R F/S1 S1UF=S T2PF FM-L) %{=>}% _ F2C
    ([t] transform/trans
      (TAS1 t)
      (transform/implies (IMP t)))
    <- set-fldpred-implies-fldmap2conj/L1 SZ DM FM-L S1UF=S F/S1 _ SZ1 DM1 F/FM1 FM1+F=FM
    <- set-fldpred-shrink-fldmap S1-R F/S1 FM1+F=FM S1-R1
    <- set-fldpred-implies-fldmap2conj/L N SZ1 DM1 S1-R1 _ F2C1 ([t] TAS t)
    <- set-fldpred-implies-fldmap2conj/L2 F2C1 F/FM1 FM1+F=FM T2PF _ F2C IMP
    <- ({t} transform-commutes-envadd* (TAS t) envadd/expr envadd/expr (TAS1 t)).

%worlds (gtermvar) (set-fldpred-implies-fldmap2conj/L _ _ _ _ _ _ _).
%total (N) (set-fldpred-implies-fldmap2conj/L N _ _ _ _ _ _).


%theorem set-fldpred-implies-fldmap2conj
  : forall* {CM} {PM} {FM} {S} {FP}
    forall {CM2PM: clsmap2predmap CM PM}
		{DM: fldmap`domain FM S}
		{SF: set-fldpred PM FM S ([t] FP t)}
    exists {G} {F2C: fldmap2conj CM PM FM ([t] G t) PM}
    {TAS: {t} transform
          (output/expr t (FP t))
          (output/expr t (G t))}
    true.

- : set-fldpred-implies-fldmap2conj _ DM SF G F2C TAS
    <- fldmap`size-total SZ
    <- set-fldpred-implies-fldmap2conj/L _ SZ DM SF G F2C TAS.

%worlds (gtermvar) (set-fldpred-implies-fldmap2conj _ _ _ _ _ _).
%total { } (set-fldpred-implies-fldmap2conj _ _ _ _ _ _).


%theorem nonnull-set-respects-eq
  :	forall* {FM1} {FM2} {S1} {S2}
    forall {NNS1: nonnull-set FM1 S1}
		{EQ: fldmap`eq FM1 FM2}
		{EQ: set`eq S1 S2}
    exists {NNS2: nonnull-set FM2 S2}
    true.

- : nonnull-set-respects-eq NNS fldmap`eq/ set`eq/ NNS.

%worlds () (nonnull-set-respects-eq _ _ _ _).
%total { } (nonnull-set-respects-eq _ _ _ _).


%%% After removing an element from a nonnull set, the result
%%% should still preserve the property.

%theorem remove-preserves-nonnull-set
  : forall* {FM} {S1} {S2} {F}
    forall {NNS: nonnull-set FM S1}
    {RM: set`remove S1 (set/1 F) S2}
    exists {NNS: nonnull-set FM S2}
    true.

- : remove-preserves-nonnull-set nonnull-set/0 _ nonnull-set/0.

%theorem remove-preserves-nonnull-set/L
  :	forall* {FM} {SP} {S1} {S2} {F} {N} {C} {B} {A}
    forall {NNSP: nonnull-set FM SP}
		{NM: set`not-member SP N}
		{AD: set`add SP N S1}
		{L: fldmap`lookup FM N (ty/ nn/yes A C)}
		{R: set`remove S1 (set/1 F) S2}
		{EQ?: nat`eq? N F B}
    exists {NNS: nonnull-set FM S2}
    true.

- : remove-preserves-nonnull-set/L NNSP N/SP SP+N=S1 _ S1/N=S2 nat`eq?/yes NNS2
    <- set`not-member-update-implies-unit-union N/SP SP+N=S1 SPUN=S1
    <- set`union-implies-leq SPUN=S1 SP<=S1 _
    <- set`union-commutative SPUN=S1 NUSP=S1
    <- set`not-member-implies-unit-disjoint N/SP SP^N
    <- set`disjoint-symmetric SP^N N^SP
    <- set`leq-reflexive _ S1<=S1
    <- set`remove-characterization SP<=S1 N^SP NUSP=S1 S1<=S1 S1/N=SP
    <- set`remove-deterministic S1/N=SP S1/N=S2 set`eq/ set`eq/ SP=S2
    <- nonnull-set-respects-eq NNSP fldmap`eq/ SP=S2 NNS2.

- : remove-preserves-nonnull-set/L
    NNSP N/SP SP+N=S1 FM#N S1/F=S2 (nat`eq?/no N!=F) (nonnull-set/+ NNS3 S3+N=S2 N/S3 FM#N)
    <- add-implies-unit-union SP+N=S1 SPUN=S1
    <- set`remove-right-distributes-over-union SPUN=S1 S1/F=S2
      _ _ SP/F=S3 N/F=S4 S3US4=S2
    <- set`ne-implies-disjoint N!=F N^F
    <- set`disjoint-implies-remove-nothing N^F N/F=N
    <- set`remove-implies-leq SP/F=S3 S3<=SP
    <- set`not-member-respects-geq N/SP S3<=SP N/S3
    <- set`remove-unique N/F=S4 N/F=N set`eq/ set`eq/ S4=N
    <- set`union-respects-eq S3US4=S2 set`eq/ S4=N set`eq/ S3UN=S2
    <- set`unit-union-implies-add S3UN=S2 S3+N=S2
    <- remove-preserves-nonnull-set NNSP SP/F=S3 NNS3.

- : remove-preserves-nonnull-set (nonnull-set/+ NNSP A NM L) R NNS2
    <- nat`eq?-total EQ?
    <- remove-preserves-nonnull-set/L NNSP NM A L R EQ? NNS2.

%worlds () (remove-preserves-nonnull-set _ _ _)
  (remove-preserves-nonnull-set/L _ _ _ _ _ _ _).

%total (NNS1 NNSP) (remove-preserves-nonnull-set NNS1 _ _)
  (remove-preserves-nonnull-set/L NNSP _ _ _ _ _ _).


%%% This theorem says we can use a bigger fldmap
%%% and still preserve the relation

%theorem fldmap-shift-preserves-nonnull-set
  : forall* {FM1} {FM2} {S} {F} {T}
    forall {NNS: nonnull-set FM2 S}
    {SH: fldmap`shift F FM1 FM2}
    exists {NNS: nonnull-set (fldmap`map/+ F T FM1) S}
    true.

- : fldmap-shift-preserves-nonnull-set nonnull-set/0 _ nonnull-set/0.

- : fldmap-shift-preserves-nonnull-set
    (nonnull-set/+ FM2-NQ Q+N=S N/Q FM2#N) F<<FM1=FM2
    (nonnull-set/+ FM-NQ Q+N=S N/Q (fldmap`lookup/> FM1#N1 SN1+F=N))
    <- fldmap-shift-preserves-nonnull-set FM2-NQ F<<FM1=FM2 FM-NQ
    <- fldmap`shift-preserves-lookup-converse FM2#N F<<FM1=FM2 _ SF+N1=N FM1#N1
    <- nat`plus-swap-succ SF+N1=N F+SN1=N
    <- nat`plus-commutative F+SN1=N SN1+F=N.

%worlds () (fldmap-shift-preserves-nonnull-set _ _ _).
%total (NNS) (fldmap-shift-preserves-nonnull-set NNS _ _).


%theorem union-preserves-nonnull-set
  : forall* {FM} {S1} {S2} {F} {C} {A}
    forall {NNS: nonnull-set FM S1}
		{NM: set`not-member S1 F}
    {U: set`union S1 (set/1 F) S2}
    {L: fldmap`lookup FM F (ty/ nn/yes A C)}
    exists {NNS: nonnull-set FM S2}
    true.

- : union-preserves-nonnull-set NS1 NM U L (nonnull-set/+ NS1 A NM L)
     <- set`unit-union-implies-add U A.

%worlds () (union-preserves-nonnull-set _ _ _ _ _).
%total (NS) (union-preserves-nonnull-set NS _ _ _ _).


%theorem select-nn-fields-preserves-fresh/L
  :	forall* {M} {MP} {N1} {N2} {T}
    forall {FS: fldmap`fresh (fldmap`map/+ N2 T M) N1}
		{SH: fldmap`shift N2 M MP}
		{NE: nat`ne N1 N2}
    exists {FS: fldmap`fresh MP N1}
    true.

- : select-nn-fields-preserves-fresh/L
    (fldmap`fresh/< N2>N1) N2<<M=MP _ N1/MP
    <- fldmap`shift-implies-fresh* N2<<M=MP (nat`ge/> N2>N1) N1/MP.

- : select-nn-fields-preserves-fresh/L
    (fldmap`fresh/> N0/M SN0+N2=N1) N2<<M=MP N1!=N2 N1/MP
    <- nat`plus-swap-succ SN0+N2=N1 N0+SN2=N1
    <- nat`plus-commutative N0+SN2=N1 SN2+N0=N1
    <- fldmap`shift-preserves-fresh N0/M SN2+N0=N1 M2 N2<<M=M2 N1/M2
    <- fldmap`shift-deterministic N2<<M=M2 N2<<M=MP nat`eq/ fldmap`eq/ M2=MP
    <- fldmap`fresh-respects-eq N1/M2 M2=MP nat`eq/ N1/MP.

%worlds () (select-nn-fields-preserves-fresh/L _ _ _ _).
%total (FS) (select-nn-fields-preserves-fresh/L FS _ _ _).


%theorem select-nn-fields-preserves-fresh
  : forall* {FM} {S} {F}
    forall {NS: select-nn-fields FM S}
    {FS: fldmap`fresh FM F}
    exists {NM: set`not-member S F}
    true.

- : select-nn-fields-preserves-fresh select-nn-fields/0 _ set`not-member/0.

- : select-nn-fields-preserves-fresh
    (select-nn-fields/in SPUN=S MP->SP N<<M=MP) F/FM F/S
    <- fldmap`fresh-lookup-not-equal F/FM (fldmap`lookup/= nat`eq/) F!=N
    <- select-nn-fields-preserves-fresh/L F/FM N<<M=MP F!=N F/MP
    <- select-nn-fields-preserves-fresh MP->SP F/MP F/SP
    <- set`unit-union-implies-add SPUN=S SP+N=S
    <- set`update-preserves-not-member F/SP SP+N=S F!=N F/S.

- : select-nn-fields-preserves-fresh
    (select-nn-fields/out MP->S N<<M=MP) F/FM F/S
    <- fldmap`fresh-lookup-not-equal F/FM (fldmap`lookup/= nat`eq/) F!=N
    <- select-nn-fields-preserves-fresh/L F/FM N<<M=MP F!=N F/MP
    <- select-nn-fields-preserves-fresh MP->S F/MP F/S.

%worlds () (select-nn-fields-preserves-fresh _ _ _).
%total (NS) (select-nn-fields-preserves-fresh NS _ _).


%theorem select-nn-fields-lookup-implies-member
  : forall* {FM} {S} {F} {C} {A}
    forall {NNS: select-nn-fields FM S}
    {L: fldmap`lookup FM F (ty/ nn/yes A C)}
    exists {MB: set`member S F}
    true.

- : select-nn-fields-lookup-implies-member
    (select-nn-fields/in S2UN=S _ _) (fldmap`lookup/= N=F) NinS
    <- set`union-implies-leq S2UN=S _ N<=S
    <- set`member-respects-leq (set`lookup/= nat`eq/) N<=S NinS.

- : select-nn-fields-lookup-implies-member
    (select-nn-fields/in S2UN=S FM2->S2 N<<FM1=FM2) (fldmap`lookup/> FM1#N0 SN0+N=F) FinS
    <- nat`plus-swap-succ SN0+N=F N0+SN=F
    <- nat`plus-commutative N0+SN=F SN+N0=F
    <- fldmap`shift-preserves-lookup* FM1#N0 N<<FM1=FM2 SN+N0=F FM2#F
    <- select-nn-fields-lookup-implies-member FM2->S2 FM2#F FinS2
    <- set`union-implies-leq S2UN=S S2<=S _
    <- set`member-respects-leq FinS2 S2<=S FinS.

- : select-nn-fields-lookup-implies-member
    (select-nn-fields/out FM2->S N<<FM1=FM2) (fldmap`lookup/> FM1#N0 SN0+N=F) FinS
    <- nat`plus-swap-succ SN0+N=F N0+SN=F
    <- nat`plus-commutative N0+SN=F SN+N0=F
    <- fldmap`shift-preserves-lookup* FM1#N0 N<<FM1=FM2 SN+N0=F FM2#F
    <- select-nn-fields-lookup-implies-member FM2->S FM2#F FinS.

%worlds () (select-nn-fields-lookup-implies-member _ _ _).
%total (NS) (select-nn-fields-lookup-implies-member NS _ _).


%theorem select-nn-fields-implies-leq
  : forall* {FM} {S1} {S2}
    forall {DM: fldmap`domain FM S1}
		{FNN: select-nn-fields FM S2}
    exists {LE: set`leq S2 S1}
    true.

- : select-nn-fields-implies-leq fldmap`domain/0 select-nn-fields/0 set`leq/0.

- : select-nn-fields-implies-leq
    (fldmap`domain/+ DM-FM=Q) (select-nn-fields/in SPUN=S2 FMP=>SP N<<FM=FMP) S2<=S1
    <- fldmap`shift-preserves-domain DM-FM=Q N<<FM=FMP _ N<<Q=QP DM-FMP=QP
    <- select-nn-fields-implies-leq DM-FMP=QP FMP=>SP SP<=QP
    <- set`can-construct-unit-union N<<Q=QP QPUN=S1
    <- set`union-right-preserves-leq* SP<=QP SPUN=S2 QPUN=S1 S2<=S1.

- : select-nn-fields-implies-leq
    (fldmap`domain/+ DM-FM=Q) (select-nn-fields/out FMP=>S2 N<<FM=FMP) S2<=S1
    <- fldmap`shift-preserves-domain DM-FM=Q N<<FM=FMP _ N<<Q=QP DM-FMP=QP
    <- select-nn-fields-implies-leq DM-FMP=QP FMP=>S2 S2<=QP
    <- set`can-construct-unit-union N<<Q=QP QPUN=S1
    <- set`union-implies-leq QPUN=S1 QP<=S1 _
    <- set`leq-transitive S2<=QP QP<=S1 S2<=S1.

%worlds () (select-nn-fields-implies-leq _ _ _).
%total (FNN) (select-nn-fields-implies-leq _ FNN _).


%theorem select-nn-fields-implies-nonnull-set
: forall* {FM} {S}
  forall {FF: select-nn-fields FM S}
  exists {NS: nonnull-set FM S}
  true.

- : select-nn-fields-implies-nonnull-set select-nn-fields/0 nonnull-set/0.

- : select-nn-fields-implies-nonnull-set
    (select-nn-fields/in SPUF=S FMP->SP F<<FM=FMP) FM-NN-S
    <- select-nn-fields-implies-nonnull-set FMP->SP FMP-NN-SP
    <- fldmap`shift-implies-fresh F<<FM=FMP F/FMP
    <- fldmap-shift-preserves-nonnull-set FMP-NN-SP F<<FM=FMP FM-NN-SP
    <- select-nn-fields-preserves-fresh FMP->SP F/FMP F/SP
    <- union-preserves-nonnull-set FM-NN-SP F/SP SPUF=S (fldmap`lookup/= nat`eq/) FM-NN-S.

- : select-nn-fields-implies-nonnull-set
    (select-nn-fields/out FMP-S F<<FM=FMP) FM-NN-S
    <- select-nn-fields-implies-nonnull-set FMP-S FMP-NN-S
    <- fldmap-shift-preserves-nonnull-set FMP-NN-S F<<FM=FMP FM-NN-S.

%worlds () (select-nn-fields-implies-nonnull-set _ _).
%total  (FF) (select-nn-fields-implies-nonnull-set FF _).


%theorem maynull-set-respects-eq
  : forall* {FM1} {FM2} {S1} {S2}
    forall {MNS1: maynull-set FM1 S1}
		{EQ: fldmap`eq FM1 FM2}
		{EQ: set`eq S1 S2}
    exists {MNS2: maynull-set FM2 S2}
    true.

- : maynull-set-respects-eq MNS fldmap`eq/ set`eq/ MNS.

%worlds () (maynull-set-respects-eq _ _ _ _).
%total { } (maynull-set-respects-eq _ _ _ _).


%theorem fldmap-shift-preserves-maynull-set
	: forall* {FM} {FMP} {S} {T} {F}
    forall {MNS: maynull-set FMP S}
		{SH: fldmap`shift F FM FMP}
    exists {SF: maynull-set (fldmap`map/+ F T FM) S}
    true.

- : fldmap-shift-preserves-maynull-set maynull-set/0 _ maynull-set/0.

- : fldmap-shift-preserves-maynull-set
    (maynull-set/+ FM2-NQ Q+N=S N/Q FM2#N) F<<FM1=FM2
    (maynull-set/+ FM-NQ Q+N=S N/Q (fldmap`lookup/> FM1#N1 SN1+F=N))
    <- fldmap-shift-preserves-maynull-set FM2-NQ F<<FM1=FM2 FM-NQ
    <- fldmap`shift-preserves-lookup-converse FM2#N F<<FM1=FM2 _ SF+N1=N FM1#N1
    <- nat`plus-swap-succ SF+N1=N F+SN1=N
    <- nat`plus-commutative F+SN1=N SN1+F=N.

%worlds (gtermvar) (fldmap-shift-preserves-maynull-set _ _ _).
%total (MNS) (fldmap-shift-preserves-maynull-set MNS _ _).


%theorem set-not-member-preserves-leq
  :	forall* {A} {B} {C} {N}
    forall {LE: set`leq A B}
		{NM: set`not-member A N}
		{AD: set`add C N B}
    exists {LE: set`leq A C}
    true.

%theorem set-not-member-preserves-leq/L1
  :	forall* {A} {B} {C} {N} {K}
    forall  {LE: set`leq A B}
		{NM: set`not-member A N}
		{AD: set`add C N B}
		{LE?: set`leq? A C K}
    exists  {LE: set`leq A C}
    true.

- : set-not-member-preserves-leq/L1 A<=B N/A C+N=B A<=C A<=C.

%theorem set-not-member-preserves-leq/L2
  :	forall* {A} {B} {C} {N} {M} {K}
    forall  {LE: set`leq A B}
		{NM: set`not-member A N}
		{AD: set`add C N B}
		{EQ?: nat`eq? N M K}
		{MB: set`member A M}
		{NM: set`not-member C M}
    exists  {LE: set`leq A C}
    true.

- : set-not-member-preserves-leq/L2 _ N/A _ nat`eq?/yes N<-A _ A<=C
    <- set`member-not-member-contradiction N<-A N/A F
    <- set`false-implies-leq F A<=C.

- : set-not-member-preserves-leq/L2
    A<=B N/A C+N=B (nat`eq?/no N!=M) M<-A M/C A<=C
    <- set`member-respects-leq M<-A A<=B M<-B
    <- nat`ne-symmetric N!=M M!=N
    <- set`update-preserves-not-member M/C C+N=B M!=N M/B
    <- set`member-not-member-contradiction M<-B M/B F
    <- set`false-implies-leq F A<=C.

%worlds () (set-not-member-preserves-leq/L2 _ _ _ _ _ _ _).
%total  (EQ?) (set-not-member-preserves-leq/L2 _ _ _ EQ? _ _ _).

- : set-not-member-preserves-leq/L1 A<=B N/A C+N=B (set`nle/< M<-A M/C) A<=C
    <- nat`eq?-total N?=M
    <- set-not-member-preserves-leq/L2 A<=B N/A C+N=B N?=M M<-A M/C A<=C.

%worlds () (set-not-member-preserves-leq/L1 _ _ _ _ _).
%total  (LE?) (set-not-member-preserves-leq/L1 _ _ _ LE? _).

- : set-not-member-preserves-leq A<=B N/A C+N=B A<=C
    <- set`leq?-total A<=?C
    <- set-not-member-preserves-leq/L1 A<=B N/A C+N=B A<=?C A<=C.

%worlds () (set-not-member-preserves-leq _ _ _ _).
%total  {} (set-not-member-preserves-leq _ _ _ _).


%theorem remove-not-member-implies-same-result
	: forall* {S} {S1} {S2} {N}
    forall  {RM: set`remove S S1 S2}
		{NM: set`not-member S N}
		{MB: set`member S1 N}
    exists  {S3} {NM: set`not-member S3 N}
		{RM: set`remove S S3 S2}
		{AD: set`add S3 N S1}
    true.

- : remove-not-member-implies-same-result
    S-S1=S2 N/S N<-S1 %{=>}% S3 N/S3 S-S3=S2 S3+N=S1
    <- set`lookup-implies-union N<-S1 S3 N/S3 NUS3=S1
    <- set`union-commutative NUS3=S1 S3UN=S1
    <- set`unit-union-implies-add S3UN=S1 S3+N=S1
    <- set`remove-associates-union-converse NUS3=S1 S-S1=S2 S4 S-N=S4 S4-S3=S2
    <- set`not-member-implies-unit-disjoint N/S S^N
    <- set`disjoint-implies-remove-nothing S^N S-N=S
    <- set`remove-unique S-N=S4 S-N=S set`eq/ set`eq/ S4=S
    <- set`remove-respects-eq S4-S3=S2 S4=S set`eq/ set`eq/ S-S3=S2.

%worlds () (remove-not-member-implies-same-result _ _ _ _ _ _ _).
%total  {} (remove-not-member-implies-same-result _ _ _ _ _ _ _).


%theorem rm-psv-sfp
  :	forall* {S} {S1} {S2} {P}
    forall {SP: set-rawfldperm S ([t] P t)}
		{LE: set`leq S1 S}
		{RM: set`remove S S1 S2}
    exists {P1} {P2} {I: {t} implies (P t) ((P1 t) , (P2 t))}
		{S1: set-rawfldperm S1 ([t] P1 t)}
		{SP: set-rawfldperm S2 ([t] P2 t)}
    true.

- : rm-psv-sfp set-rawfldperm/0 _ _ _ _
    ([_] implies/equiv (equiv/symmetric equiv/identity))
    set-rawfldperm/0 set-rawfldperm/0.


%theorem rm-psv-sfp/L
  :	forall* {B} {SP} {S} {S1} {S2} {S3} {S4} {N} {PP}
    forall {MB?: set`member? S1 N B}
		{SR: set-rawfldperm SP ([t] PP t)}
		{NM: set`not-member SP N}
		{U: set`union SP (set/1 N) S}
		{LE: set`leq S1 S}
		{RM: set`remove S S1 S2}
		{R: set`remove SP S1 S3}
		{R: set`remove (set/1 N) S1 S4}
		{U: set`union S3 S4 S2}
    exists {P1} {S1-P1: set-rawfldperm S1 ([t] P1 t)}
		{P2} {S2-P2: set-rawfldperm S2 ([t] P2 t)}
		{I: {t} implies ((unitperm (basic t N null)) , (PP t)) ((P1 t) , (P2 t))}
    true.

- : rm-psv-sfp/L (set`member?/out N/S1)
    SP-PP N/SP SPUN=S S1<=S S-S1=S2 SP-S1=S3 N-S1=S4 S3US4=S2 _ S1-P1 _
    (set-rawfldperm/+ S3-P3 N/S3 S3UN=S2)
    ([t] implies/trans
      (implies/combine (implies/reflexive) (PP=>P1P3 t))
      (implies/equiv equiv/roll2))
    <- set`unit-union-implies-add SPUN=S SP+N=S
    <- set-not-member-preserves-leq S1<=S N/S1 SP+N=S S1<=SP
    <- rm-psv-sfp SP-PP S1<=SP SP-S1=S3 P1 P3 PP=>P1P3 S1-P1 S3-P3
    <- set`remove-implies-leq SP-S1=S3 S3<=SP
    <- set`not-member-respects-geq N/SP S3<=SP N/S3
    <- set`not-member-implies-unit-disjoint N/S1 S1^N
    <- set`disjoint-symmetric S1^N N^S1
    <- set`disjoint-implies-remove-nothing N^S1 N-S1=N
    <- set`remove-unique N-S1=S4 N-S1=N set`eq/ set`eq/ S4=N
    <- set`union-respects-eq S3US4=S2 set`eq/ S4=N set`eq/ S3UN=S2.

- : rm-psv-sfp/L (set`member?/in N<-S1)
    SP-PP N/SP SPUN=S S1<=S S-S1=S2 SP-S1=S3 N-S1=S4 S3US4=S2 _
    (set-rawfldperm/+ S5-P5 N/S5 S5UN=S1) _ S2-P3
    ([t] implies/trans
      (implies/combine
        (implies/reflexive)
        (PP=>P5P3 t))
      (implies/equiv equiv/associate))
    <- remove-not-member-implies-same-result
      SP-S1=S3 N/SP N<-S1 S5 N/S5 SP-S5=S3 S5+N=S1
    <- set`unit-union-implies-add SPUN=S SP+N=S
    <- set`add-implies-unit-union S5+N=S1 S5UN=S1
    <- not-member-add-implies-remove N/S5 S5+N=S1 S1-N=S5
    <- not-member-add-implies-remove N/SP SP+N=S S-N=SP
    <- set`remove-right-preserves-leq S1<=S S1-N=S5 S-N=SP S5<=SP
    <- rm-psv-sfp SP-PP S5<=SP SP-S5=S3 P5 P3 ([t] PP=>P5P3 t) S5-P5 S3-P3
    <- set`member-implies-unit-leq N<-S1 N<=S1
    <- set`leq-implies-remove-all N<=S1 N-S1=0
    <- set`remove-unique N-S1=S4 N-S1=0 set`eq/ set`eq/ S4=0
    <- set`union-respects-eq S3US4=S2 set`eq/ S4=0 set`eq/ S3U0=S2
    <- set`union-unique S3U0=S2 set`union/R set`eq/ set`eq/ S2=S3
    <- set`eq-symmetric S2=S3 S3=S2
    <- set-rawfldperm-respects-eq S3-P3 S3=S2 ([_] permission`eq/) S2-P3.

- : rm-psv-sfp (set-rawfldperm/+ SP-PP N/SP SPUN=S) S1<=S S-S1=S2
    _ _ IMP S1-P1 S2-P2
    <- set`remove-right-distributes-over-union
      SPUN=S S-S1=S2 S3 S4 SP-S1=S3 N-S1=S4 S3US4=S2
    <- set`member?-total N<-S1?
    <- rm-psv-sfp/L N<-S1? SP-PP N/SP SPUN=S S1<=S S-S1=S2 SP-S1=S3 N-S1=S4
      S3US4=S2 _ S1-P1 _ S2-P2 IMP.

%worlds (gtermvar) (rm-psv-sfp _ _ _ _ _ _ _ _)
  (rm-psv-sfp/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (P1 P2) (rm-psv-sfp P1 _ _ _ _ _ _ _)
  (rm-psv-sfp/L _ P2 _ _ _ _ _ _ _ _ _ _ _ _).


%theorem fnn-rm-imp-mns/LL2
	: forall* {A} {B} {C} {D} {E} {F} {N}
    forall {AD: set`add A N B}
		{AD: set`add C N D}
		{NM: set`not-member A N}
		{NM: set`not-member C N}
		{R: set`remove B D E}
		{U: set`union C E F}
    exists {LE: set`leq A F}
    true.

%theorem fnn-rm-imp-mns/LL2B1
	: forall* {A} {B} {C} {D} {E} {F} {N} {K}
    forall {AD: set`add A N B}
		{AD: set`add C N D}
		{NM: set`not-member A N}
		{NM: set`not-member C N}
		{R: set`remove B D E}
		{U: set`union C E F}
		{LE?: set`leq? A F K}
    exists {LE: set`leq A F}
    true.

- : fnn-rm-imp-mns/LL2B1 _ _ _ _ _ _ A<=F A<=F.

%theorem fnn-rm-imp-mns/LL2B2
	: forall* {A} {B} {C} {D} {E} {F} {N} {M} {K1} {K2}
    forall {AD: set`add A N B}
		{AD: set`add C N D}
		{NM: set`not-member A N}
		{NM: set`not-member C N}
		{R: set`remove B D E}
		{U: set`union C E F}
		{MB: set`member A M}
		{NM: set`not-member F M}
		{MB?: set`member? D M K1}
		{EQ?: nat`eq? N M K2}
    exists {LE: set`leq A F}
    true.

- : fnn-rm-imp-mns/LL2B2 _ _ N/A _ _ _ N<-A _ _ nat`eq?/yes A<=F
    <- set`member-not-member-contradiction N<-A N/A V
    <- set`false-implies-leq V A<=F.

- : fnn-rm-imp-mns/LL2B2
    A+N=B C+N=D N/A N/C B/D=E CUE=F M<-A M/F (set`member?/in M<-D) (nat`eq?/no N!=M) A<=F
    <- set`not-member-update-implies-leq N/A A+N=B A<=B
    <- set`member-respects-leq M<-A A<=B M<-B
    <- set`add-implies-unit-union C+N=D CUN=D
    <- set`ne-implies-unit-map-not-member N!=M M/N
    <- set`not-member-union-right-preserves-lookup-converse M<-D M/N CUN=D M<-C
    <- set`union-preserves-not-member-converse* M/F CUE=F M/C M/E
    <- set`member-not-member-contradiction M<-C M/C V
    <- set`false-implies-leq V A<=F.

- : fnn-rm-imp-mns/LL2B2
    A+N=B C+N=D N/A N/C (set`remove/ _ _ DUE=G B<=G)
    CUE=F M<-A M/F (set`member?/out M/D) (nat`eq?/no N!=M) A<=F
    <- set`not-member-update-implies-leq N/A A+N=B A<=B
    <- set`member-respects-leq M<-A A<=B M<-B
    <- set`member-respects-leq M<-B B<=G M<-G
    <- set`not-member-union-left-preserves-member-converse M/D M<-G DUE=G M<-E
    <- set`union-preserves-not-member-converse* M/F CUE=F M/C M/E
    <- set`member-not-member-contradiction M<-E M/E V
    <- set`false-implies-leq V A<=F.

%worlds (gtermvar) (fnn-rm-imp-mns/LL2B2 _ _ _ _ _ _ _ _ _ _ _).
%total { } (fnn-rm-imp-mns/LL2B2 _ _ _ _ _ _ _ _ _ _ _).

- : fnn-rm-imp-mns/LL2B1
    A+N=B C+N=D N/A N/C B/D=E CUE=F (set`nle/< M<-A M/F) A<=F
    <- set`member?-total M<-D?
    <- nat`eq?-total N=M?
    <- fnn-rm-imp-mns/LL2B2 A+N=B C+N=D N/A N/C B/D=E CUE=F M<-A M/F M<-D? N=M? A<=F.

%worlds () (fnn-rm-imp-mns/LL2B1 _ _ _ _ _ _ _ _).
%total { } (fnn-rm-imp-mns/LL2B1 _ _ _ _ _ _ _ _).

- : fnn-rm-imp-mns/LL2 A+N=B C+N=D N/A N/C B/D=E CUE=F A<=F
    <- set`leq?-total A<=F?
    <- fnn-rm-imp-mns/LL2B1 A+N=B C+N=D N/A N/C B/D=E CUE=F A<=F? A<=F.

%worlds (gtermvar) (fnn-rm-imp-mns/LL2 _ _ _ _ _ _ _).
%total { } (fnn-rm-imp-mns/LL2 _ _ _ _ _ _ _).


%theorem fnn-rm-imp-mns/L1
  : forall* {A} {B} {C} {D} {E} {N}
    forall {AD: set`add A N B}
    {AD: set`add C N D}
    {NM: set`not-member A N}
    {NM: set`not-member C N}
    {R: set`remove B D E}
    exists {R: set`remove A C E}
    true.

- : fnn-rm-imp-mns/L1 A+N=B C+N=D N/A N/C B/D=E %{=>}% A/C=E
    <- set`remove-implies-leq B/D=E E<=B
    <- set`add-implies-member C+N=D N<-D
    <- set`remove-implies-disjoint B/D=E D^E
    <- set`disjoint-lookup-implies-not-member N<-D D^E N/E
    <- set-not-member-preserves-leq E<=B N/E A+N=B E<=A
    <- set`not-member-update-implies-leq N/C C+N=D C<=D
    <- set`disjoint-respects-geq* D^E C<=D C^E
    <- set`union-total CUE=F
    <- fnn-rm-imp-mns/LL2 A+N=B C+N=D N/A N/C B/D=E CUE=F A<=F
    <- remove-characterization E<=A C^E CUE=F A<=F A/C=E.

%worlds (gtermvar) (fnn-rm-imp-mns/L1 _ _ _ _ _ _).
%total { } (fnn-rm-imp-mns/L1 _ _ _ _ _ _).


%theorem fnn-rm-imp-mns/L2
  : forall* {A} {B} {C} {D} {E}
    forall {U: set`union A B C}
    {X: set`disjoint B D}
    {R: set`remove C D E}
    exists {F} {R: set`remove A D F}
    {U: set`union F B E}
    true.

- : fnn-rm-imp-mns/L2 AUB=C B^D C-D=E F A-D=F FUB=E
    <- set`remove-right-distributes-over-union AUB=C C-D=E F H A-D=F B-D=H FUH=E
    <- set`disjoint-implies-remove-nothing B^D B-D=B
    <- set`remove-deterministic B-D=H B-D=B set`eq/ set`eq/ H=B
    <- set`union-respects-eq FUH=E set`eq/ H=B set`eq/ FUB=E.

%worlds (gtermvar) (fnn-rm-imp-mns/L2 _ _ _ _ _ _ ).
%total { } (fnn-rm-imp-mns/L2 _ _ _ _ _ _ ).


%theorem fnn-rm-imp-mns
  : forall* {CM} {PM} {FM} {S} {S1} {S2}
    forall {CM2PM: clsmap2predmap CM PM}
    {CM-FM: clsmap-fldmap CM FM}
    {DM: fldmap`domain FM S}
    {FNN: select-nn-fields FM S1}
    {RM: set`remove S S1 S2}
    exists {MNS: maynull-set FM S2}
    true.

- : fnn-rm-imp-mns _ _ fldmap`domain/0 _ _ maynull-set/0.

- : fnn-rm-imp-mns
    CM2PM (clsmap-fldmap/+ CM-FM _ _) (fldmap`domain/+ DM-FM=SS)
    (select-nn-fields/in S1PUN=S1 FMP->S1P N<<FM=FMP) S/S1=S2 %{=>}% MN-S2
    <- fldmap`shift-preserves-domain DM-FM=SS N<<FM=FMP _ N<<SS=SP DM-FMP=SP
    <- shift-preserves-clsmap-fldmap CM-FM N<<FM=FMP CM-FMP
    <- set`shift-implies-not-member N<<SS=SP N/SP
    <- set`can-construct-unit-union N<<SS=SP SPUN=S
    <- set`unit-union-implies-add SPUN=S SP+N=S
    <- set`unit-union-implies-add S1PUN=S1 S1P+N=S1
    <- fldmap`shift-implies-fresh N<<FM=FMP N/FMP
    <- select-nn-fields-preserves-fresh FMP->S1P N/FMP N/S1P
    <- fnn-rm-imp-mns/L1 SP+N=S S1P+N=S1 N/SP N/S1P S/S1=S2 SP/S1P=S2
    <- fnn-rm-imp-mns CM2PM CM-FMP DM-FMP=SP FMP->S1P SP/S1P=S2 FMP-MN-S2
    <- fldmap-shift-preserves-maynull-set FMP-MN-S2 N<<FM=FMP MN-S2.

- : fnn-rm-imp-mns
    CM2PM (clsmap-fldmap/+ CM-FM _ _) (fldmap`domain/+ DM-FM=SS)
    (select-nn-fields/out FMP->S1 N<<FM=FMP) S/S1=S2
    (maynull-set/+ MN-S3 S3+N=S2 N/S3 (fldmap`lookup/= nat`eq/))
    <- fldmap`shift-preserves-domain DM-FM=SS N<<FM=FMP _ N<<SS=SP DM-FMP=SP
    <- shift-preserves-clsmap-fldmap CM-FM N<<FM=FMP CM-FMP
    <- fldmap`shift-implies-fresh N<<FM=FMP N/FMP
    <- select-nn-fields-preserves-fresh FMP->S1 N/FMP N/S1
    <- set`can-construct-unit-union N<<SS=SP SPUN=S
    <- set`unit-union-implies-add SPUN=S SP+N=S
    <- set`not-member-implies-unit-disjoint N/S1 S1^N
    <- set`disjoint-symmetric S1^N N^S1
    <- fnn-rm-imp-mns/L2 SPUN=S N^S1 S/S1=S2 S3 SP/S1=S3 S3UN=S2
    <- set`unit-union-implies-add S3UN=S2 S3+N=S2
    <- fnn-rm-imp-mns CM2PM CM-FMP DM-FMP=SP FMP->S1 SP/S1=S3 FMP-MN-S3
    <- fldmap-shift-preserves-maynull-set FMP-MN-S3 N<<FM=FMP MN-S3
    <- set`shift-implies-not-member N<<SS=SP N/SP
    <- set`remove-implies-leq SP/S1=S3 S3<=SP
    <- set`not-member-respects-geq N/SP S3<=SP N/S3.

%worlds (gtermvar) (fnn-rm-imp-mns _ _ _ _ _ _).
%total (FN) (fnn-rm-imp-mns _ _ _ FN _ _).


%%% We need to show the size is actually decreasing...
%%% this is like the opposite of not-member-update-increase-size

%theorem mns-imp-sfp/LL1
	: forall* {A} {B} {N} {M}
    forall {SZ: set`size A (s N)}
		{NM: set`not-member B M}
		{AD: set`add B M A}
    exists {SZ: set`size B N}
    true.

- : mns-imp-sfp/LL1 SZA M/B B+M=A SZ-B=N
    <- set`add-implies-member B+M=A M<-A
    <- set`can-remove SZA M<-A AP L SZ-AP=L SL=SN AP+M=A M/AP
    <- not-member-add-implies-remove M/AP AP+M=A A-M=AP
    <- not-member-add-implies-remove M/B B+M=A A-M=B
    <- set`remove-unique A-M=AP A-M=B set`eq/ set`eq/ AP=B
    <- nat`succ-cancels SL=SN L=N
    <- set`size-respects-eq SZ-AP=L AP=B L=N SZ-B=N.

%worlds () (mns-imp-sfp/LL1 _ _ _ _).
%total { } (mns-imp-sfp/LL1 _ _ _ _).


%theorem mns-imp-sfp/LL2
	: forall* {PM} {F} {C} {A} {PF}
    forall {FNN2P: ty2perm PM (ty/ nn/may A C) ([o] PF o)}
    exists {I: {o} implies (unitperm (basic o F null))
               (unitperm (precise-exists o F PF))}
    true.

- : mns-imp-sfp/LL2 (ty2perm/ PML nn2perm/may _)
    ([_] implies/trans3
      (implies/equiv
        (equiv/symmetric equiv/identity))
      (implies/combine
        (implies/reflexive)
        (implies/trans3
          (implies/equiv
            (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/trans
              (implies/empty2true)
              (implies/nonlinear
                (bimplies/objequal-reflexive)))
            (implies/reflexive))
          (implies/cond-intro)))
      (implies/pack null)).

%worlds (gtermvar) (mns-imp-sfp/LL2 _ _).
%total { } (mns-imp-sfp/LL2 _ _).


%theorem mns-imp-sfp/L
	: forall* {PM} {CM} {FM} {S} {Pi1}
    forall {N} {SZ: set`size S N}
		{CM-FM: clsmap-fldmap CM FM}
		{CM2PM: clsmap2predmap CM PM}
		{MNS: maynull-set FM S}
		{SRP: set-rawfldperm S ([t] Pi1 t)}
    exists {Pi2} {I: {t} implies (Pi1 t) (Pi2 t)}
		{SFP: set-fldpred PM FM S ([t] Pi2 t)}
    true.

- : mns-imp-sfp/L z _ _ _ maynull-set/0 set-rawfldperm/0 _ ([t] implies/reflexive) set-fldpred/0.

- : mns-imp-sfp/L (s N) SZ
    CM-FM CM2PM (maynull-set/+ MN-SP SP+N=S N/SP FM#N)
    SRP _ ([t] implies/trans (I t) (implies/combine (I2 t) (I3 t)))
    (set-fldpred/+ S1-SF-R N/S1 S1UN=S (ty2perm/ PML nn2perm/may A2P) FM#N)
    <- set`add-implies-member SP+N=S N<-S
    <- set-rawfldperm-reorder SRP N<-S _ ([t] I t) S1 S1-R N/S1 S1UN=S
    <- set`unit-union-implies-add S1UN=S S1+N=S
    <- not-member-add-implies-remove N/SP SP+N=S S-N=SP
    <- not-member-add-implies-remove N/S1 S1+N=S S-N=S1
    <- set`remove-unique S-N=SP S-N=S1 set`eq/ set`eq/ SP=S1
    <- lookup-implies-clsmap-ty CM-FM FM#N (clsmap-ty/ CML)
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- annot2perm-total A2P
    <- mns-imp-sfp/LL2 (ty2perm/ PML nn2perm/may A2P) ([t] I2 t)
    <- maynull-set-respects-eq MN-SP fldmap`eq/ SP=S1 MN-S1
    <- mns-imp-sfp/LL1 SZ N/SP SP+N=S SZP
    <- set`size-respects-eq SZP SP=S1 nat`eq/ SZS1
    <- mns-imp-sfp/L _ SZS1 CM-FM CM2PM MN-S1 S1-R _ ([t] I3 t) S1-SF-R.

%worlds (gtermvar) (mns-imp-sfp/L _ _ _ _ _ _ _ _ _).
%total (N) (mns-imp-sfp/L N _ _ _ _ _ _ _ _).


%theorem mns-imp-sfp
	: forall* {PM} {CM} {FM} {S} {Pi1}
    forall  {CM-FM: clsmap-fldmap CM FM}
		{CM2PM: clsmap2predmap CM PM}
		{MNS: maynull-set FM S}
		{SRP: set-rawfldperm S ([t] Pi1 t)}
    exists  {Pi2} {I: {t} implies (Pi1 t) (Pi2 t)}
		{SFP: set-fldpred PM FM S ([t] Pi2 t)}
    true.

- : mns-imp-sfp CM-FM CM2PM MNS SRP _ I SFP
    <- set`size-total SZ
    <- mns-imp-sfp/L _ SZ CM-FM CM2PM MNS SRP _ I SFP.

%worlds (gtermvar) (mns-imp-sfp _ _ _ _ _ _ _).
%total  {} (mns-imp-sfp _ _ _ _ _ _ _).


%%% Constructor Typing

constyping : clsmap -> methmap -> fldmap
    -> cxt -> env -> set -> (object -> expr) -> env -> type.

constyping/0 : constyping _ _ _ _ V set/0 ([t] lit t) V.

constyping/nn :
    fldmap`lookup FM F (ty/ nn/yes A C) ->
    set`remove S (set/1 F) SP ->
    reftyping CM MM B V0 E (result/expr RT V1) ->
    subtype CM _ RT V1 (ty/ nn/yes A C) _ V2 ->
    constyping CM MM FM B V2 SP ([t] EF t) V3 ->
  constyping CM MM FM B V0 S ([t] seq (write (lit t) F E) (EF t)) V3.

constyping/mn :
    fldmap`lookup FM F (ty/ nn/may A C) ->
    reftyping CM MM B V0 E (result/expr RT V1) ->
    subtype CM _ RT V1 (ty/ nn/may A C) _ V2 ->
    constyping CM MM FM B V2 S ([t] EF t) V3 ->
  constyping CM MM FM B V0 S ([t] seq (write (lit t) F E) (EF t)) V3.


constymatch* : env -> env -> clsmap -> methmap -> fldmap -> cxt ->
    (object -> func) -> methty -> type.

constymatch/base :
    ty2new-reftype (ty/ nn/yes annot/unique C) RT ->
    clsmap`lookup CM C FM ->
    select-nn-fields FM S ->
    constyping CM MM FM B Vin S ([t] E t) Vout ->
  constymatch* Vin Vout CM MM FM B ([t] func/0 (E t))
    (methty/base (ty/ nn/yes annot/unique C)).

constymatch/args/shared :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) ->
    ({x} constymatch* Vin Vout CM MM FM (B1 x) ([t] F t x) CT) ->
  constymatch* Vin Vout CM MM FM B0 ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/shared C) set/0 CT).

constymatch/args/borrow :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/borrow C)) (B1 x)) ->
    nat+set2set (s N) FS Mf ->
    set`union Min Mf Min' ->
    set`union Mout Mf Mout' ->
    ({x} constymatch* (env/ Uin Min') (env/ Uout Mout') CM MM FM (B1 x) ([t] F t x) CT) ->
  constymatch* (env/ Uin Min) (env/ Uout Mout) CM MM FM B0 ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/borrow C) FS CT).

constymatch/args/unique :
    cxt`fresh B0 (s N) ->
    ({x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) ->
    clsmap`lookup CM C FFM ->
    fldmap`domain FFM FFS ->
    nat+set2set (s N) FFS Mf ->
    set`add Uin (s N) Uin' ->
    set`union Min Mf Min' ->
    ({x} constymatch* (env/ Uin' Min') Vout CM MM FM (B1 x) ([t] F t x) CT) ->
  constymatch* (env/ Uin Min) Vout CM MM FM B0 ([t] (func/+ ([o] F t o)))
    (methty/arg (ty/ NN annot/unique C) set/0 CT).

%abbrev constymatch
  = [CM][MM][FM][F][CT] constymatch* empty-env empty-env CM MM FM cxt/0 F CT.


%%% Theorems about constyping

%theorem constyping-respects-eq
  : forall* {CM} {MM} {FM} {S1} {S2} {B} {E} {Vin} {Vout}
    forall {CTYP: constyping CM MM FM B Vin S1 ([t] E t) Vout}
    {EQ: set`eq S1 S2}
    exists {CTYP: constyping CM MM FM B Vin S2 ([t] E t) Vout}
    true.

- : constyping-respects-eq CTYP set`eq/ CTYP.

%worlds (gtermvar) (constyping-respects-eq _ _ _).
%total { } (constyping-respects-eq _ _ _).


before-write-format* : clsmap -> predmap -> cxt -> expr-result -> expr-output -> type.

before-write-format*/ :
    cxt2perm PM B PiB ->
    reftype2ty RT T ->
    ty2perm PM T ([x] PF x) ->
    env2input CM PM B V PiV ->
  before-write-format* CM PM B (result/expr RT V)
      (output/exists [x]
        (output/exists [p:permission]
          (output/expr x (combine PiB (combine (PF x) (PiV)))))).

before-write-format2 : clsmap -> predmap -> cxt -> ty -> env -> expr-output -> type.

before-write-format2/ :
    cxt2perm PM B PiB ->
    ty2perm PM T ([x] PF x) ->
    env2input CM PM B V PiV ->
  before-write-format2 CM PM B T V
      (output/exists [x]
        (output/exists [p:permission]
          (output/expr x (combine PiB (combine (PF x) (PiV)))))).


%theorem make-before-write-format*
  : forall* {CM} {PM} {V1} {V2} {Out0} {B} {V3} {FS} {C} {NN} {A} {RT}
    forall {CM2PM: clsmap2predmap CM PM}
    {CM-B-R: clsmap-result CM B (result/expr RT V1)}
    {SUB: subtype CM FS RT V1 (ty/ NN A C) V3 V2}
    {NB: not-borrow A}
    {R=>Out: result2output CM PM B (result/expr RT V1) Out0}
    exists {Out1}
    {TRANS: transform Out0 Out1}
    {BR-FMT: before-write-format* CM PM B (result/expr RT V2) Out1}
    true.

- : make-before-write-format* CM2PM CM-B-R SUB NB R2O _
    (transform/trans
      (TRANS)
      (transform/inside [o]
        (transform/inside [p]
          (transform/implies
            (implies/equiv
              (equiv/transitive
                (equiv/reorder)
                (equiv/combine equiv/reflexive equiv/reorder)))))))
    (before-write-format*/ B2P RT2T T2PF (env2input/ U2P M2P))
    <- make-before-write-format CM2PM CM-B-R SUB NB R2O _ TRANS
      (before-write-format/expr U2P B2P M2P RT2T T2PF).

%worlds (gtermvar) (make-before-write-format* _ _ _ _ _ _ _ _).
%total { } (make-before-write-format* _ _ _ _ _ _ _ _).


%theorem make-before-write-format2
  : forall* {CM} {PM} {B} {FS} {RT} {V1} {V2} {V3} {Out} {NN} {A} {C}
    forall {SUB: subtype CM FS RT V1 (ty/ NN A C) V3 V2}
    {NB: not-borrow A}
    {BWF*: before-write-format* CM PM B (result/expr RT V2) Out}
    exists {Out'} {TRANS: transform Out Out'}
    {BWF2: before-write-format2 CM PM B (ty/ NN A C) V2 Out'}
    true.

- : make-before-write-format2
    (subtype/ NN-LEQ (sub-annot/unique _ _ _ _ _ _ _)) not-borrow/shared
    (before-write-format*/ B2P reftype2ty/unique T2PF V2P)
    _
    (transform/inside [o]
      (transform/inside [p]
        (transform/trans3
          (transform/implies
            (implies/trans5
              (implies/combine implies/reflexive
                (implies/combine (IMP o) implies/reflexive))
              (implies/reorder)
              (implies/combine implies/commute implies/reflexive)
              (implies/symmetric-associate)
              (implies/combine implies/cond-neg implies/reflexive)))
          (transform/cond/nest)
          (transform/implies
            (implies/trans4
              (implies/combine implies/cond-unneg implies/reflexive)
              (implies/associate)
              (implies/combine implies/commute implies/reflexive)
              (implies/reorder))))))
    (before-write-format2/ B2P (ty2perm/ PML nn2perm/yes annot2perm/shared) V2P)
    <- nn-leq-implies-permission-leq T2PF NN-LEQ _
      (ty2perm/ PML nn2perm/yes annot2perm/unique) IMP.

- : make-before-write-format2
    (subtype/ NN-LEQ (sub-annot/unique _ _ _ _ _ _ _)) not-borrow/shared
    (before-write-format*/ B2P reftype2ty/unique T2PF V2P)
    _
    (transform/inside [o]
      (transform/inside [p]
        (transform/trans3
          (transform/implies
            (implies/trans3
              (implies/combine implies/reflexive
                (implies/combine (IMP o) implies/reflexive))
              (implies/reorder)
              (implies/combine implies/cond-neg implies/reflexive)))
          (transform/cond/nest)
          (transform/implies
            (implies/trans
              (implies/combine implies/cond-unneg implies/reflexive)
              (implies/reorder))))))
    (before-write-format2/ B2P (ty2perm/ PML nn2perm/may annot2perm/shared) V2P)
    <- nn-leq-implies-permission-leq T2PF NN-LEQ _
      (ty2perm/ PML nn2perm/may annot2perm/unique) IMP.

- : make-before-write-format2
    (subtype/ NN-LEQ (sub-annot/fresh _)) not-borrow/shared
    (before-write-format*/ B2P reftype2ty/fresh T2PF V2P)
    _
    (transform/inside [o]
      (transform/inside [p]
        (transform/trans3
          (transform/implies
            (implies/trans5
              (implies/combine implies/reflexive
                (implies/combine (IMP o) implies/reflexive))
              (implies/reorder)
              (implies/combine implies/commute implies/reflexive)
              (implies/symmetric-associate)
              (implies/combine implies/cond-neg implies/reflexive)))
          (transform/cond/nest)
          (transform/implies
            (implies/trans4
              (implies/combine implies/cond-unneg implies/reflexive)
              (implies/associate)
              (implies/combine implies/commute implies/reflexive)
              (implies/reorder))))))
    (before-write-format2/ B2P (ty2perm/ PML nn2perm/yes annot2perm/shared) V2P)
    <- nn-leq-implies-permission-leq T2PF NN-LEQ _
      (ty2perm/ PML nn2perm/yes annot2perm/unique) IMP.

- : make-before-write-format2
    (subtype/ NN-LEQ (sub-annot/fresh _)) not-borrow/shared
    (before-write-format*/ B2P reftype2ty/fresh T2PF V2P)
    _
    (transform/inside [o]
      (transform/inside [p]
        (transform/trans3
          (transform/implies
            (implies/trans3
              (implies/combine implies/reflexive
                (implies/combine (IMP o) implies/reflexive))
              (implies/reorder)
              (implies/combine implies/cond-neg implies/reflexive)))
          (transform/cond/nest)
          (transform/implies
            (implies/trans
              (implies/combine implies/cond-unneg implies/reflexive)
              (implies/reorder))))))
    (before-write-format2/ B2P (ty2perm/ PML nn2perm/may annot2perm/shared) V2P)
    <- nn-leq-implies-permission-leq T2PF NN-LEQ _
      (ty2perm/ PML nn2perm/may annot2perm/unique) IMP.

- : make-before-write-format2
    (subtype/ NN-LEQ (sub-annot/unique _ _ _ _ _ _ _)) _
    (before-write-format*/ B2P reftype2ty/unique T2PF V2P)
    _
    (transform/inside [o]
      (transform/inside [_]
        (transform/implies
          (implies/combine implies/reflexive
            (implies/combine (IMP o) implies/reflexive)))))
    (before-write-format2/ B2P T2PF2 V2P)
    <- nn-leq-implies-permission-leq T2PF NN-LEQ _ T2PF2 IMP.

- : make-before-write-format2
    (subtype/ NN-LEQ (sub-annot/fresh _)) _
    (before-write-format*/ B2P reftype2ty/fresh T2PF V2P)
    _
    (transform/inside [o]
      (transform/inside [_]
        (transform/implies
          (implies/combine implies/reflexive
            (implies/combine (IMP o) implies/reflexive)))))
    (before-write-format2/ B2P T2PF2 V2P)
    <- nn-leq-implies-permission-leq T2PF NN-LEQ _ T2PF2 IMP.

- : make-before-write-format2
    (subtype/ NN-LEQ (sub-annot/shared)) _
    (before-write-format*/ B2P reftype2ty/shared T2PF V2P)
    _
    (transform/inside [o]
      (transform/inside [_]
        (transform/implies
          (implies/combine implies/reflexive
            (implies/combine (IMP o) implies/reflexive)))))
    (before-write-format2/ B2P T2PF2 V2P)
    <- nn-leq-implies-permission-leq T2PF NN-LEQ _ T2PF2 IMP.

%worlds (gtermvar) (make-before-write-format2 _ _ _ _ _ _).
%total { } (make-before-write-format2 _ _ _ _ _ _).


%theorem diff-lookup-implies-ne
  : forall* {FM} {N1} {N2} {C1} {C2} {A1} {A2}
    forall {L1:fldmap`lookup FM N1 (ty/ nn/may A1 C1)}
    {L2:fldmap`lookup FM N2 (ty/ nn/yes A2 C2)}
    exists {NE: nat`ne N1 N2}
    true.

- : diff-lookup-implies-ne (fldmap`lookup/= EQ) (fldmap`lookup/> _ P) (nat`ne/< GT')
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-respects-eq GT nat`eq/ EQ GT'.

- : diff-lookup-implies-ne (fldmap`lookup/> _ P) (fldmap`lookup/= EQ) (nat`ne/> GT')
    <- nat`plus-implies-gt P nat`eq/ GT
    <- nat`gt-respects-eq GT nat`eq/ EQ GT'.

- : diff-lookup-implies-ne (fldmap`lookup/> L1 P1) (fldmap`lookup/> L2 P2) PNE
    <- diff-lookup-implies-ne L1 L2 NE
    <- nat`succ-preserves-ne NE SNE
    <- nat`plus-right-preserves-ne* SNE P1 P2 PNE.

%worlds () (diff-lookup-implies-ne _ _ _).
%total (L) (diff-lookup-implies-ne L _ _).


%theorem only-nonnull-in-nonnull-set
  : forall* {FM} {S} {F} {C} {A}
    forall {NNS: nonnull-set FM S}
    {L: fldmap`lookup FM F (ty/ nn/may A C)}
    exists {NM: set`not-member S F}
    true.

- : only-nonnull-in-nonnull-set nonnull-set/0 _ set`not-member/0.

- : only-nonnull-in-nonnull-set (nonnull-set/+ NNSP SP+N=S _ FM#N) FM#F F/S
     <- only-nonnull-in-nonnull-set NNSP FM#F F/SP
     <- diff-lookup-implies-ne FM#F FM#N F!=N
     <- set`update-preserves-not-member F/SP SP+N=S F!=N F/S.

%worlds () (only-nonnull-in-nonnull-set _ _ _).
%total (NNS) (only-nonnull-in-nonnull-set NNS _ _).


%%% Theorems about constyping-implies-typing

%theorem constyping-implies-set-expr
  : forall* {CM} {MM} {FM} {S} {R} {L} {E} {V0} {V1}
    forall  {CTYP: constyping CM MM FM L V0 R ([t] E t) V1}
    {DM: fldmap`domain FM S}
    exists {S-E: set-expr S E}
    true.

- : constyping-implies-set-expr constyping/0 _ set-expr/0.

- : constyping-implies-set-expr
     (constyping/nn FM#F R/F=R1 _ _ CTYP) FM->S (set-expr/+ S-B S#F)
     <- constyping-implies-set-expr CTYP FM->S S-B
     <- fldmap`domain-preserves-lookup FM#F FM->S S#F.

- : constyping-implies-set-expr
     (constyping/mn FM#F RTYP _ CTYP) FM->S (set-expr/+ S-B S#F)
     <- constyping-implies-set-expr CTYP FM->S S-B
     <- fldmap`domain-preserves-lookup FM#F FM->S S#F.

%worlds (gtermvar) (constyping-implies-set-expr _ _ _).
%total (T) (constyping-implies-set-expr T _ _).


%theorem constyping-implies-typing/L
  : forall* {PM} {CM} {MM} {FM} {E} {W}
    {S} {S1} {S2} {R0} {Q0} {L} {PiL} {Vin} {Vout} {PiVin}
    forall  {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM-B: clsmap-cxt CM L}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-FM: clsmap-fldmap CM FM}
    {L=>PiL: cxt2perm PM L PiL}
    {CM-B-Vin: clsmap-cxt-env CM L Vin}
    {Vin=>PiVin: env2input CM PM L Vin PiVin}
    {CTYP: constyping CM MM FM L Vin S1 ([t] E t) Vout}
    {NNS: nonnull-set FM S1}
    {S/S1=S2: set`remove S S1 S2}
    {S1US2=S: set`union S1 S2 S}
    {S-E: set-expr S E}
		{S1-R0: set-rawfldperm S1 R0}
    {S2-Q0: set-fldpred PM FM S2 Q0}
    exists {Q1} {PiVout}
    {Vout=>PiVout: env2input CM PM L Vout PiVout}
    {TYP: {t} typing W ((R0 t) , ((Q0 t) , (PiVin , PiL))) (E t)
          (output/expr t ((Q1 t) , (PiVout , PiL)))}
    {S-Q1: set-fldpred PM FM S Q1}
    true.

%theorem constyping-implies-typing/LMB
  : forall* {PM} {CM} {MM} {FM} {E} {W} {B} {C} {NN}
    {S} {S1} {S2} {L} {PiL} {R0} {Q0} {F} {S3} {V0} {V1} {RT}
    {V2} {V3} {A} {PiV0} {FS} {AV}
    forall {G} {MB?: set`member? S1 F G}
    {RM: set`remove S1 (set/1 F) S3}
    {F&S: set`member S F}
    {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM-L: clsmap-cxt CM L}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-FM: clsmap-fldmap CM FM}
    {L=>PiL: cxt2perm PM L PiL}
    {CM-B-V0: clsmap-cxt-env CM L V0}
    {V0=>PiV0: env2input CM PM L V0 PiV0}
    {NTYP: reftyping CM MM L V0 E (result/expr RT V1)}
    {SUB: subtype CM FS RT V1 (ty/ NN A C) AV V2}
    {CTYP: constyping CM MM FM L V2 S3 ([t] B t) V3}
    {FM-L: fldmap`lookup FM F (ty/ NN A C)}
    {NNS1: nonnull-set FM S1}
    {S/S1=S2: set`remove S S1 S2}
    {S1US2=S: set`union S1 S2 S}
    {S-B: set-expr S B}
		{S1-R0: set-rawfldperm S1 R0}
    {S2-Q0: set-fldpred PM FM S2 Q0}
    exists {Q1} {PiV3}
    {V3=>PiV3: env2input CM PM L V3 PiV3}
    {TYP: {t:object} typing W ((R0 t) , ((Q0 t) , (PiV0 , PiL)))
          ((seq (write (lit t) F E) (B t)))
          (output/expr t ((Q1 t) , (PiV3 , PiL)))}
    {S-Q1: set-fldpred PM FM S Q1}
    true.

%theorem constyping-implies-typing/LL
  : forall* {PM} {CM} {MM} {FM} {E} {W} {B} {F} {S3}
    {S} {S1} {S2} {L} {Pi} {R0} {Q0} {C} {NN} {A}
    {V0} {V3} {PiV0} {RT} {V1} {FS} {AV} {V2}
    forall  {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM-L: clsmap-cxt CM L}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-FM: clsmap-fldmap CM FM}
    {L2P: cxt2perm PM L Pi}
    {CM-B-V0: clsmap-cxt-env CM L V0}
    {V0=>PiV0: env2input CM PM L V0 PiV0}
		{NTYP: reftyping CM MM L V0 E (result/expr RT V1)}
    {SUB: subtype CM FS RT V1 (ty/ NN A C) AV V2}
    {CTYP: constyping CM MM FM L V2 S3 ([t] B t) V3}
    {FM-L: fldmap`lookup FM F (ty/ NN A C)}
    {NNS1: nonnull-set FM S1}
    {F&S1: set`member S1 F}
    {RM: set`remove S1 (set/1 F) S3}
    {S/S1=S2: set`remove S S1 S2}
    {S1US2=S: set`union S1 S2 S}
    {S-B: set-expr S B}
		{S1-R0: set-rawfldperm S1 R0}
    {S2-Q0: set-fldpred PM FM S2 Q0}
    exists {Q1} {PiV3}
    {V3=>PiV3: env2input CM PM L V3 PiV3}
    {TYP: {t} typing W ((R0 t) , ((Q0 t) , (PiV0 , Pi)))
          (seq (write (lit t) F E) (B t))
          (output/expr t ((Q1 t) , (PiV3 , Pi)))}
    {S-Q1: set-fldpred PM FM S Q1}
    true.

%theorem constyping-implies-typing/LR
  : forall* {PM} {CM} {MM} {FM} {E} {W} {B} {F}
    {S} {S1} {S2} {L} {Pi} {R0} {Q0} {C} {NN}
    {V0} {V1} {V2} {V3} {RT} {FS} {A} {PiV0} {AV}
    forall  {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM-L: clsmap-cxt CM L}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-FM: clsmap-fldmap CM FM}
    {L2P: cxt2perm PM L Pi}
    {CM-B-V0: clsmap-cxt-env CM L V0}
    {V0=>PiV0: env2input CM PM L V0 PiV0}
		{NTYP: reftyping CM MM L V0 E (result/expr RT V1)}
    {SUB: subtype CM FS RT V1 (ty/ NN A C) AV V2}
    {CTYP: constyping CM MM FM L V2 S1 ([t] B t) V3}
    {FM-L: fldmap`lookup FM F (ty/ NN A C)}
    {NNS: nonnull-set FM S1}
    {F&S2: set`member S2 F}
    {S/S1=S2: set`remove S S1 S2}
    {S1US2=S: set`union S1 S2 S}
    {S-B: set-expr S B}
		{S1-R0: set-rawfldperm S1 R0}
    {S2-Q0: set-fldpred PM FM S2 Q0}
    exists {Q1} {PiV3}
    {V3=>PiV3: env2input CM PM L V3 PiV3}
    {TYP: {t} typing W ((R0 t) , ((Q0 t) , (PiV0 , Pi)))
          (seq (write (lit t) F E) (B t))
          (output/expr t ((Q1 t) , (PiV3 , Pi)))}
    {S-Q1: set-fldpred PM FM S Q1}
    true.

- : constyping-implies-typing/L _ _ _ _ _ _ _ _ Vin=>PiVin
    constyping/0 _ _ _
    set-expr/0 set-rawfldperm/0 S-Q _ _ Vin=>PiVin
    ([t] tTrans2
      (tObjLoc)
      (transform/implies
        (implies/equiv
          (equiv/commute-identity))))
    S-Q.

- : constyping-implies-typing/L
    CM-CM CM-MM (CM-OFL:clsmap-cxt CM B)
    (CM2PM:clsmap2predmap CM PM) (MM2W:methmap2progtype CM PM MM W)
    (CM-FM:clsmap-fldmap CM FM)
    (OFL2P:cxt2perm PM B PiB)
    CM-B-Vin (Vin=>PiVin:env2input CM PM B V0 PiV0)
    (constyping/mn (FM-L:fldmap`lookup FM F (ty/ nn/may A C))
      (RTYP:reftyping CM MM B V0 E (result/expr RT V1))
      (SUB:subtype CM FS0 RT V1 (ty/ nn/may A C) AV V2)
      (CTYP:constyping CM MM FM B V2 S1 ([t] EF t) V3))
    (NNS1:nonnull-set FM S1)
    (S/S1=S2:set`remove S S1 S2)
    (S1US2=S:set`union S1 S2 S)
    (set-expr/+ (S-B:set-expr S _) (F&S:set`member S F))
    (S1-R0:set-rawfldperm S1 R0)
    (S2-Q0:set-fldpred PM FM S2 Q0)
    Q1 PiV3 (Vout=>PiVout:env2input CM PM B V3 PiV3) TYP S-Q1
    <- only-nonnull-in-nonnull-set NNS1 FM-L F/S1
    <- set`not-member-union-left-preserves-lookup-converse F/S1 F&S S1US2=S F&S2
    <- constyping-implies-typing/LR
      CM-CM CM-MM CM-OFL CM2PM MM2W CM-FM OFL2P CM-B-Vin Vin=>PiVin RTYP SUB CTYP FM-L
      NNS1 F&S2 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 _ Vout=>PiVout TYP S-Q1.

- : constyping-implies-typing/L
    CM-CM CM-MM CM-OFL CM2PM MM2W CM-FM OFL2P CM-B-Vin Vin=>PiVin
    (constyping/nn FM-L S1/F=S3 RTYP SUB CTYP)
    NNS1 S/S1=S2 S1US2=S (set-expr/+ S-B F&S) S1-R0 S2-Q0 Q1 _ Vout=>PiVout TYP S-Q1
    <- set`member?-total MB?
    <- constyping-implies-typing/LMB _ MB? S1/F=S3
      F&S CM-CM CM-MM CM-OFL CM2PM MM2W CM-FM OFL2P CM-B-Vin Vin=>PiVin
      RTYP SUB CTYP FM-L NNS1 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 _ Vout=>PiVout TYP S-Q1.

- : constyping-implies-typing/LR
    CM-CM CM-MM CM-B (CM2PM:clsmap2predmap CM PM)
    (MM2W:methmap2progtype CM PM MM W)
    (CM-FM:clsmap-fldmap CM FM)
    (B=>PiBP:cxt2perm PM B PiBP)
    CM-B-V0 (V0=>PiV0:env2input CM PM B V0 PiV0)
    (RTYP:reftyping CM MM B V0 E (result/expr RT V1))
    (SUB:subtype CM FS0 RT V1 _ _ V2)
    (CTYP:constyping CM MM FM B V2 S1 BB V3)
    (FM-L:fldmap`lookup FM F (ty/ NN A C))
    (NNS:nonnull-set FM S1)
    (F&S2:set`member S2 F)
    (S/S1=S2:set`remove S S1 S2)
    (S1US2=S:set`union S1 S2 S)
    (S-B:set-expr S BB)
    (S1-R0:set-rawfldperm S1 ([x] R0 x))
    (S2-Q0:set-fldpred PM FM S2 ([x] Q0 x)) _ _ V3=>PiV3
    ([t] tTrans2
      (tLet
        (tWrite2
          (tTrans
            (transform/implies
              (implies/trans
                (implies/equiv equiv/associate)
                (implies/combine implies/reflexive
                  (implies/trans
                    (implies/commute)
                    (implies/combine
                      (implies/equiv (equiv/symmetric PiB0<=>PiBP))
                      (implies/equiv PiV0<=>PiV0'))))))
            (letTyping/base null (TYPE' t))
            (transform/trans3
              (TRANS1' t)
              (TRANS2' t)
              (transform/inside [o]
                (transform/trans
                  (transform/rem-unused)
                  (transform/trans
                    (transform/implies
                      (implies/equiv
                        (equiv/transitive3
                          (equiv/combine equiv/commute equiv/reflexive)
                          (equiv/symmetric-associate)
                          (equiv/commute))))
                    (TRANS0' o t))))))
          (letTyping/exists [r]
            (letTyping/exists [o]
              (letTyping/base r
                (tTrans
                  (transform/implies
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/symmetric-associate))))
                  (letTyping/base null
                    (tWrite:typing _ _ (write (lit t) F (lit r)) _))
                  (transform/implies
                    (implies/trans5
                      (implies/combine implies/reflexive
                        (implies/equiv equiv/roll4))
                      (implies/associate)
                      (implies/combine (implies/pack r) implies/reflexive)
                      (implies/equiv equiv/roll3)
                      (implies/combine implies/reflexive
                        (implies/trans
                          (implies/associate)
                          (implies/combine implies/reflexive implies/commute))))))))))
        (letTyping/exists [r]
          (letTyping/exists [o]
            (letTyping/base r (TYPB t)))))
      (transform/trans3
        (transform/inside [r]
          (transform/inside [o]
            (transform/implies
              (implies/combine implies/reflexive
                (implies/combine implies/reflexive (implies/equiv PiB1<=>PiBP))))))
        (transform/rem-unused)
        (transform/rem-unused)))
    S-Q1
    <- set-fldpred-reorder S2-Q0 F&S2 RP ([r][t] TRANS0 r t) S3 S3-RP F/S3 S3UF=S2
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP
      PiB0 PiV0' Out1 B=>PiB0 V0=>PiV0' R1=>Out1 TYPE
    <- env2input-unique V0=>PiV0 V0=>PiV0' env`eq/ PiV0<=>PiV0'
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP CM-B-R1
    <- lookup-implies-not-borrow CM-FM FM-L NB
    <- make-before-write-format* CM2PM CM-B-R1 SUB NB R1=>Out1 Out2 TRANS1 BWF*
    <- make-before-write-format2 SUB NB BWF* _ TRANS2
      (before-write-format2/ (B=>PiB1:cxt2perm PM B PiB1) (T2PF:ty2perm _ _ PF)
        (V2=>PiV2:env2input CM PM B V2 PiV2))
    <- clsmap-result/expr-inversion CM-B-R1 CM-B-RT CM-B-V1
    <- subtype-consistent CM-B-RT CM-B-V1 SUB CM-B-V2 _
    <- constyping-implies-typing/L CM-CM CM-MM CM-B CM2PM MM2W CM-FM B=>PiB1
      CM-B-V2 V2=>PiV2 CTYP NNS S/S1=S2 S1US2=S S-B S1-R0
      (set-fldpred/+ S3-RP F/S3 S3UF=S2 T2PF FM-L) _ _ V3=>PiV3 TYPB S-Q1
    <- ({t:object} typing-frame TYPE _ (EA t) (TYPE' t))
    <- cxt2perm-equiv B=>PiB0 B=>PiBP predmap`eq/ cxt`eq/ PiB0<=>PiBP
    <- cxt2perm-equiv B=>PiB1 B=>PiBP predmap`eq/ cxt`eq/ PiB1<=>PiBP
    <- ({t} transform-commutes-envadd TRANS1 (EA t) (Out2' t) (EA2 t) (TRANS1' t))
    <- ({t} transform-commutes-envadd* TRANS2 (EA2 t)
         (envadd/exists [o] (envadd/exists [p] (envadd/expr))) (TRANS2' t))
    <- ({o}{t} transform-commutes-envadd* (TRANS0 o t) envadd/expr
         (envadd/exists [r] envadd/expr) (TRANS0' o t)).

- : constyping-implies-typing/LL
    CM-CM CM-MM CM-B (CM2PM:clsmap2predmap CM PM)
    (MM2W:methmap2progtype CM PM MM W)
    (CM-FM:clsmap-fldmap CM FM)
    (B=>PiB:cxt2perm PM B PiB)
    CM-B-V0 (V0=>PiV0:env2input CM PM B V0 PiV0)
    (RTYP:reftyping CM MM B V0 E (result/expr RT V1))
    (SUB:subtype CM FS0 RT V1 _ _ V2)
    (CTYP:constyping CM MM FM B V2 S3' BB V3)
    (FM-L:fldmap`lookup FM F (ty/ NN A C))
    (NNS1:nonnull-set FM S1)
    (F&S1:set`member S1 F)
    (S1/F=S3':set`remove S1 (set/1 F) S3')
    (S/S1=S2:set`remove S S1 S2)
    (S1US2=S:set`union S1 S2 S)
    (S-B:set-expr S BB)
    (S1-R0:set-rawfldperm S1 R0)
    (S2-Q0:set-fldpred PM FM S2 Q0) _ _ V3=>PiV3
    ([t] tTrans2
      (tLet
        (tWrite2
          (tTrans
            (transform/implies
              (implies/equiv
                (equiv/transitive
                  (equiv/associate)
                  (equiv/combine equiv/reflexive
                    (equiv/transitive
                      (equiv/commute)
                      (equiv/combine PiB<=>PiB0 PiV0<=>PiV0'))))))
            (letTyping/base null (TYPE' t))
            (transform/trans3
              (TRANS1' t)
              (TRANS2' t)
              (transform/inside [o]
                (transform/trans
                  (transform/rem-unused)
                  (transform/implies
                    (implies/trans3
                      (implies/symmetric-associate)
                      (implies/combine (IMP t) implies/reflexive)
                      (implies/symmetric-associate)))))))
          (letTyping/exists [o]
            (letTyping/base o
              (tTrans2
                (tWrite:typing _ _ (write (lit t) F _) _)
                (transform/implies
                  (implies/trans5
                    (implies/combine implies/reflexive
                      (implies/equiv equiv/roll4))
                    (implies/associate)
                    (implies/combine (implies/pack o) implies/reflexive)
                    (implies/reorder)
                    (implies/combine implies/reflexive
                      (implies/trans
                        (implies/associate)
                        (implies/combine implies/reflexive implies/commute)))))))))
        (letTyping/exists [o] (letTyping/base o (TYPB t))))
      (transform/trans
        (transform/rem-unused)
        (transform/implies
          (implies/combine implies/reflexive
            (implies/combine implies/reflexive (implies/equiv PiB1<=>PiB))))))
    S-Q1
    <- set-rawfldperm-reorder S1-R0 F&S1 RP ([t] IMP t) S3 S3-RP F/S3 S3UF=S1
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP
      PiB0 PiV0' Out1 B=>PiB0 V0=>PiV0' R1=>Out1 TYPE
    <- env2input-unique V0=>PiV0 V0=>PiV0' env`eq/ PiV0<=>PiV0'
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP CM-B-R1
    <- lookup-implies-not-borrow CM-FM FM-L NB
    <- make-before-write-format* CM2PM CM-B-R1 SUB NB R1=>Out1 Out2 TRANS1 BWF*
    <- make-before-write-format2 SUB NB BWF* _ TRANS2
      (before-write-format2/ (B=>PiB1:cxt2perm PM B PiB1) (T2PF:ty2perm _ _ PF)
        (V2=>PiV2:env2input CM PM B V2 PiV2))
    <- clsmap-result/expr-inversion CM-B-R1 CM-B-RT CM-B-V1
    <- subtype-consistent CM-B-RT CM-B-V1 SUB CM-B-V2 _
    <- set`remove-implies-disjoint S/S1=S2 S1^S2
     <- set`disjoint-lookup-implies-not-member F&S1 S1^S2 F/S2
     <- set`union-associative S3UF=S1 S1US2=S S4 FUS2=S4 S3US4=S
     <- set`union-commutative FUS2=S4 S2UF=S4
     <- set`union-commutative S3UF=S1 FUS3=S1
     <- set`union-implies-leq S1US2=S S1<=S S2<=S
     <- set`union-implies-leq S3UF=S1 S3<=S1 F<=S1
     <- set`union-implies-leq S2UF=S4 S2<=S4 F<=S4
     <- set`leq-transitive F<=S1 S1<=S F<=S
     <- set`union-is-lub S2UF=S4 S2<=S F<=S S4<=S
     <- set`not-member-implies-unit-disjoint F/S3 S3^F
     <- set`leq-reflexive _ S2<=S2
     <- set`disjoint-respects-geq S1^S2 S3<=S1 S2<=S2 S3^S2
     <- set`disjoint-symmetric S3^F F^S3
     <- set`disjoint-symmetric S3^S2 S2^S3
     <- set`union-preserves-disjoint* F^S3 S2^S3 FUS2=S4 S4^S3
     <- set`disjoint-symmetric S4^S3 S3^S4
     <- set`leq-reflexive _ S<=S
     <- set`leq-reflexive _ S1<=S1
     <- set`remove-characterization S4<=S S3^S4 S3US4=S S<=S S/S3=S4
     <- set`remove-characterization S3<=S1 F^S3 FUS3=S1 S1<=S1 S1/F=S3
     <- set`remove-deterministic S1/F=S3' S1/F=S3 set`eq/ set`eq/ S3'=S3
     <- constyping-respects-eq CTYP S3'=S3 CTYP'
     <- remove-preserves-nonnull-set NNS1 S1/F=S3 NNS3
     <- constyping-implies-typing/L CM-CM CM-MM CM-B CM2PM MM2W CM-FM B=>PiB1
       CM-B-V2 V2=>PiV2 CTYP' NNS3 S/S3=S4 S3US4=S S-B S3-RP
       (set-fldpred/+ S2-Q0 F/S2 S2UF=S4 T2PF FM-L) _ _ V3=>PiV3 TYPB S-Q1
     <- ({t:object} typing-frame TYPE _ (EA t) (TYPE' t))
     <- cxt2perm-equiv B=>PiB B=>PiB0 predmap`eq/ cxt`eq/ PiB<=>PiB0
     <- ({t} transform-commutes-envadd TRANS1 (EA t) (Out2' t) (EA2 t) (TRANS1' t))
     <- ({t} transform-commutes-envadd* TRANS2 (EA2 t)
          (envadd/exists [o] (envadd/exists [p] (envadd/expr))) (TRANS2' t))
    <- cxt2perm-equiv B=>PiB1 B=>PiB predmap`eq/ cxt`eq/ PiB1<=>PiB.

- : constyping-implies-typing/LMB false OUT S1/F=S3 F&S
     CM-CM CM-MM CM-B CM2PM MM2W CM-FM B=>PiB CM-B-V0 V0=>PiV0 RTYP SUB CTYP FM-L
     NNS1 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 PiV3 V3=>PiV3 TYP S-Q1
     <- set`out-implies-not-member OUT F/S1
     <- set`not-member-implies-unit-disjoint F/S1 S1^F
     <- set`disjoint-implies-remove-nothing S1^F S1/F=S1
     <- set`remove-deterministic S1/F=S3 S1/F=S1 set`eq/ set`eq/ S3=S1
     <- constyping-respects-eq CTYP S3=S1 CTYP'
     <- set`not-member-union-left-preserves-lookup-converse F/S1 F&S S1US2=S F&S2
     <- constyping-implies-typing/LR
       CM-CM CM-MM CM-B CM2PM MM2W CM-FM B=>PiB CM-B-V0 V0=>PiV0 RTYP SUB CTYP' FM-L
       NNS1 F&S2 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 PiV3 V3=>PiV3 TYP S-Q1.

- : constyping-implies-typing/LMB true IN S1/F=S3 _
    CM-CM CM-MM CM-B CM2PM MM2W CM-FM B=>PiB CM-B-V0 V0=>PiV0 RTYP SUB CTYP FM-L
    NNS1 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 PiV3 V3=>PiV3 TYP S-Q1
     <- set`in-implies-member IN _ F&S1
     <- constyping-implies-typing/LL
       CM-CM CM-MM CM-B CM2PM MM2W CM-FM B=>PiB CM-B-V0 V0=>PiV0 RTYP SUB CTYP FM-L
       NNS1 F&S1 S1/F=S3 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 PiV3 V3=>PiV3 TYP S-Q1.

%worlds (gtermvar)
(constyping-implies-typing/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(constyping-implies-typing/LMB _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(constyping-implies-typing/LL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(constyping-implies-typing/LR _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

%total (T2 T3 T4 T1)
(constyping-implies-typing/L _ _ _ _ _ _ _ _ _ _ _ _ _ T1 _ _ _ _ _ _ _)
(constyping-implies-typing/LR _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ T3 _ _ _ _ _ _ _)
(constyping-implies-typing/LL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ T4 _ _ _ _ _ _ _)
(constyping-implies-typing/LMB _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ T2 _ _ _ _ _ _ _).


%theorem constyping-implies-typing
  : forall* {CM} {PM} {MM} {W} {C} {FM} {S} {B}
    {Vin} {Vout} {E} {PiB} {S1} {PiVin}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM-B: clsmap-cxt CM B}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CML: clsmap`lookup CM C FM}
    {FM-DM: fldmap`domain FM S}
    {FM=>S: select-nn-fields FM S1}
    {B=>PiB: cxt2perm PM B PiB}
    {CM-B-Vin: clsmap-cxt-env CM B Vin}
    {Vin=>PiVin: env2input CM PM B Vin PiVin}
    {CTYP: constyping CM MM FM B Vin S1 ([t] E t) Vout}
    exists {RFP} {AF: {t} allocFields t S (RFP t)}
    {PF} {T2PF: ty2perm PM (ty/ nn/yes annot/unique C) PF}
    {PiVout} {Vout=>PiVout: env2input CM PM B Vout PiVout}
    {TYP: {t} typing W (((obj-ne-null t) , (unitperm (basic t all null))) ,
                         ((RFP t) , (PiVin , PiB))) (E t)
          (output/exists ([t] (output/expr t (PiB , (PiVout , (PF t))))))}
    true.

- : constyping-implies-typing CM-CM CM-MM CM-B CM2PM MM2W
    (CML:clsmap`lookup CM C FM)
    (DM-FM=S:fldmap`domain FM FS)
    (FM=>S1:select-nn-fields FM S1)
    (B2P:cxt2perm PM B PiB)
    (CM-B-Vin: clsmap-cxt-env CM B Vin)
    (Vin=>PiVin: env2input CM PM B Vin PiVin)
    (CTYP:constyping CM MM FM B Vin S1 ([t] EF t) Vout) %{==>}%
    _ AF _ (ty2perm/ PML nn2perm/yes annot2perm/unique) _ Vout=>PiVout
    ([t] tTrans
      (transform/implies
        (implies/combine implies/reflexive
          (implies/trans
            (implies/combine
              (implies/trans3
                (PP=>P t)
                (P=>P1P2 t)
                (implies/combine implies/reflexive (R2=>P2 t)))
              (implies/reflexive))
            (implies/symmetric-associate))))
      (letTyping/base null (TYP2 t))
      (transform/trans3
        (transform/implies
          (implies/equiv
            (equiv/transitive
              (equiv/reorder)
              (equiv/commute))))
        (TRANS2 t)
        (transform/trans3
          (transform/implies
            (implies/trans8
              (implies/combine implies/symmetric-associate
                (implies/equiv (G<=>CJ t)))
              (implies/symmetric-associate)
              (implies/combine implies/duplicate implies/reflexive)
              (implies/symmetric-associate)
              (implies/combine implies/reflexive
                (implies/trans4
                  (implies/combine implies/reflexive
                    (implies/trans
                      (implies/combine implies/commute implies/reflexive)
                      (implies/symmetric-associate)))
                  (implies/reorder)
                  (implies/combine implies/reflexive
                    (implies/combine implies/reflexive implies/commute))
                  (implies/combine implies/reflexive
                    (implies/cond-intro-neg))))
              (implies/associate)
              (implies/commute)
              (implies/combine implies/cond-neg implies/reflexive)))
          (transform/cond/nest)
          (transform/trans
            (transform/implies
              (implies/trans7
                (implies/combine
                  (implies/trans
                    (implies/cond-unneg)
                    (implies/cond-inner
                      (bimplies/reflexive)
                      (bimplies/reflexive)
                      (implies/reflexive)
                      (implies/trans
                        (implies/combine
                          (implies/nonlinear
                            (bimplies/trans
                              (bimplies/predcall/0/extract)
                              (bimplies/trans
                                (bimplies/predcall/+/extract
                                  ([x]
                                    (predicate/0
                                      (nested
                                        (CJ (conj2pred CJ) x) x all))) t)
                                (bimplies/predcall/Y/extract))))
                          (implies/reflexive))
                        (implies/commute))))
                  (implies/reflexive))
                (implies/commute)
                (implies/combine implies/commute implies/reflexive)
                (implies/symmetric-associate)
                (implies/combine implies/commute implies/reflexive)
                (implies/symmetric-associate)
                (implies/reflexive)))
            (transform/gen-exists t)))))
    <- allocFields-total _ ([t] AF t)
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- select-nn-fields-implies-leq DM-FM=S FM=>S1 S1<=S
    <- set`remove-total S/S1=S2
    <- set`remove-subset-implies-union S/S1=S2 S1<=S S1US2=S
    <- select-nn-fields-implies-nonnull-set FM=>S1 NN-S1
    <- constyping-implies-set-expr CTYP DM-FM=S S-E
    <- allocfields-implies-set-rawfldperm DM-FM=S ([t] AF t) _ ([t] PP=>P t) S-P
    <- rm-psv-sfp S-P S1<=S S/S1=S2 _ _ ([t] P=>P1P2 t) S1-P1 S2-R2
    <- fnn-rm-imp-mns CM2PM CM-FM DM-FM=S FM=>S1 S/S1=S2 MN-S2
    <- mns-imp-sfp CM-FM CM2PM MN-S2 S2-R2 _ ([t] R2=>P2 t) S2-P2
    <- constyping-implies-typing/L CM-CM CM-MM CM-B CM2PM MM2W CM-FM B2P
      CM-B-Vin Vin=>PiVin CTYP NN-S1 S/S1=S2 S1US2=S S-E S1-P1 S2-P2 _ _ Vout=>PiVout TYP S-Q
    <- set-fldpred-implies-fldmap2conj CM2PM DM-FM=S S-Q _ F2C ([t] TRANS t)
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML CJ PML
    <- clsmap2predmap-implies-fldmap2conj CM2PM PML CML F2C2
    <- fldmap2conj-deterministic* F2C F2C2 clsmap`eq/ fldmap`eq/ predmap`eq/ G=CJ
    <- ({t} typing-frame* (TYP t) envadd/expr (TYP2 t))
    <- ({t} transform-commutes-envadd* (TRANS t) envadd/expr envadd/expr (TRANS2 t))
    <- ({t} permission`eq-implies-equiv (G=CJ t) (G<=>CJ t)).

%worlds (gtermvar) (constyping-implies-typing _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total { } (constyping-implies-typing _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem constymatch-implies-proctypematch/L1
  : forall* {S} {S0} {OS0} {F}
    forall {AF0: {t} allocFields t S0 (OS0 t)}
    {NM: set`not-member S F}
    {ADD: set`add S F S0}
    exists {OS} {AF: {t} allocFields t S (OS t)}
    {EQV: {t} equiv (OS0 t) (combine (unitperm (basic t F null)) (OS t))}
    true.

%worlds (gtermvar) (constymatch-implies-proctypematch/L1 _ _ _ _ _ _).
%trustme %total { } (constymatch-implies-proctypematch/L1 _ _ _ _ _ _).


%%% Here Piin should be PiB + PiVin, and Piout should be PiB + PiVout
%theorem constymatch-implies-proctypematch*
  : forall* {CM} {MM} {PM} {B} {W} {MT} {F} {Vin} {Vout}
    {PTF} {PiB} {Piin} {Piout} {PiVin} {PiVout} {FM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-Vin: clsmap-cxt-env CM B Vin}
    {CM-B-Vout: clsmap-cxt-env CM B Vout}
    {B=>PiB: cxt2perm PM B PiB}
    {Vin=>Piin: env2input CM PM B Vin PiVin}
    {Vout=>Piout: env2input CM PM B Vout PiVout}
    {IMP: implies Piin (PiB , PiVin)}
    {IMP: implies (PiB , PiVout) Piout}
    {CM-MT: clsmap-methty CM MT}
    {MC: constymatch* Vin Vout CM MM FM B F MT}
    {MT=>PT: consty2proctype* CM FM PM Piin Piout MT PTF}
    exists {PC: {t} proctypematch W (F t) (PTF t)}
    true.

- : constymatch-implies-proctypematch*
    CM-CM CM-MM CM2PM MM2W CM-B CM-B-Vin CM-B-Vout
    (B=>PiB:cxt2perm PM B PiB)
    (Vin=>PiVin:env2input CM PM B Vin PiVin)
    (Vout=>PiVout:env2input CM PM B Vout PiVout)
    IMP0 IMP1
    (clsmap-methty/base CM-T)
    (constymatch/base T=>RT CML SNF CTYP)
    (consty2proctype/base
      (DM-FM=S:fldmap`domain FM S)
      (NM:set`not-member S all)
      (ADD: set`add S all S0)
      (S0=>OS0:{t} allocFields t S0 (OS0 t))
      (T2PF:ty2perm PM (ty/ nn/yes annot/unique C) PF))
    ([t] proctypematch/base
      (tTrans
        (transform/implies
          (implies/trans3
            (implies/combine IMP0
              (implies/trans
                (implies/combine implies/reflexive
                  (implies/equiv
                    (equiv/transitive (EQV t) (equiv/combine equiv/reflexive (OS<=>OSP t)))))
                (implies/associate)))
            (implies/reorder)
            (implies/combine implies/reflexive
              (implies/trans
                (implies/commute)
                (implies/combine implies/reflexive implies/commute)))))
        (letTyping/base null (TYP t))
        (transform/inside [r]
          (transform/implies
            (implies/trans4
              (implies/combine implies/reflexive
                (implies/combine (implies/equiv PiVout'<=>PiVout)
                  (implies/equiv (PFP<=>PF r))))
              (implies/associate)
              (implies/combine IMP1 implies/reflexive)
              (implies/commute))))))
    <- constyping-implies-typing CM-CM CM-MM CM-B CM2PM MM2W CML DM-FM=S
      SNF B=>PiB CM-B-Vin Vin=>PiVin CTYP %{=>}% OSP S=>OSP PFP T2PFP PiVout' Vout=>PiVout' TYP
    <- constymatch-implies-proctypematch/L1 S0=>OS0 NM ADD OS S=>OS EQV
    <- allocFields-unique S=>OS S=>OSP set`eq/ OS=OSP
    <- ({t} permission`eq-implies-equiv (OS=OSP t) (OS<=>OSP t))
    <- ty2perm-deterministic T2PFP T2PF predmap`eq/ ty`eq/ PFP=PF
    <- ({t} permission`eq-implies-equiv (PFP=PF t) (PFP<=>PF t))
    <- env2input-unique Vout=>PiVout' Vout=>PiVout env`eq/ PiVout'<=>PiVout.

- : constymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (CM-B0-Vin:clsmap-cxt-env CM B0 Vin)
    (CM-B0-Vout:clsmap-cxt-env CM B0 Vout)
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (B0+Vin=>PiVin:env2input CM PM B0 Vin PiVin)
    (B0+Vout=>PiVout:env2input CM PM B0 Vout PiVout)
    (IMP0:implies Piin (PiB0 , PiVin))
    (IMP1:implies (PiB0 , PiVout) Piout)
    (clsmap-methty/args CM-MT CML DM LE)
    (constymatch/args/shared N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) x)
      ([x] MC x))
    (consty2proctype/arg
      (argtype2perm/shared T2PF) MT=>PT)
    ([t] proctypematch/arg ([x] PC x t))
    <- cxt`fresh-update-preserves-env2input B0+Vin=>PiVin N!<B0 B0+N=B1 B1+Vin=>PiVin
    <- cxt`fresh-update-preserves-env2input B0+Vout=>PiVout N!<B0 B0+N=B1 B1+Vout=>PiVout
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vin N!<B0 B0+N=B1 CM-B1-Vin
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vout N!<B0 B0+N=B1 CM-B1-Vout
    <- ({x} constymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (CM-B1-Vin x) (CM-B1-Vout x)
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/shared T2PF))
         (B1+Vin=>PiVin x) (B1+Vout=>PiVout x)
         (implies/trans
           (implies/combine implies/reflexive (IMP0))
           (implies/associate))
         (implies/trans
           (implies/symmetric-associate)
           (implies/combine implies/reflexive IMP1))
         (CM-MT) (MC x) (MT=>PT x)
         ([t] PC x t)).

- : constymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (clsmap-cxt-env/ CM-B0-Uin CM-B0-Min)
    (clsmap-cxt-env/ CM-B0-Uout CM-B0-Mout)
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (env2input/ (B0+Uin=>PiUin:make-encumbered CM PM B0 Uin PiUin)
      (B0+Min=>PiMin:capset2perm CM PM B0 Min PiMin))
    (env2input/ (B0+Uout=>PiUout:make-encumbered CM PM B0 Uout PiUout)
      (B0+Mout=>PiMout:capset2perm CM PM B0 Mout PiMout))
    (IMP0) (IMP1)
    (clsmap-methty/args CM-MT (CML2:clsmap`lookup CM C FM2)
      (DM2:fldmap`domain FM2 FS2) LE2)
    (constymatch/args/borrow N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/borrow C)) (B1 x)) x)
      (N+FS=>Mf:nat+set2set (s N) FS3 Mf) (Min+Mf=Min':set`union Min Mf Min')
      (Mout+Mf=Mout':set`union Mout Mf Mout')
      ([x] MC x))
    (consty2proctype/arg
      (argtype2perm/borrow (CML:clsmap`lookup CM C FM)
        (DM:fldmap`domain FM FS) LE FS=>PF T2PFB) MT=>PT)
    ([t] proctypematch/arg ([x] PC x t))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- cxt`fresh-update-preserves-make-encumbered B0+Uin=>PiUin N!<B0 B0+N=B1 B1+Uin=>PiUin
    <- cxt`fresh-update-preserves-capset2perm B0+Min=>PiMin N!<B0 B0+N=B1 B1+Min=>PiMin
    <- cxt`fresh-update-preserves-make-encumbered B0+Uout=>PiUout N!<B0 B0+N=B1 B1+Uout=>PiUout
    <- cxt`fresh-update-preserves-capset2perm B0+Mout=>PiMout N!<B0 B0+N=B1 B1+Mout=>PiMout
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uin N!<B0 B0+N=B1 CM-B1-Uin
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Min N!<B0 B0+N=B1 CM-B1-Min
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uout N!<B0 B0+N=B1 CM-B1-Uout
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Mout N!<B0 B0+N=B1 CM-B1-Mout
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- ({x} nat+set2set-implies-clsmap-cxt-capset/L CML DM LE (B1-L x) not-shared/borrow
         N+FS=>Mf (CM-B1-Mf x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Min x) (CM-B1-Mf x) Min+Mf=Min'
         (CM-B1-Min' x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Mout x) (CM-B1-Mf x) Mout+Mf=Mout'
         (CM-B1-Mout' x))
    <- letRefTyping-helper/base/unique/L4L2* CML FS=>PF B1-L N+FS=>Mf _ B1+Mf=>PiMf IMP5 IMP6
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Min N!<B0 N+FS=>Mf Min^Mf
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Mout N!<B0 N+FS=>Mf Mout^Mf
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Min^Mf Min+Mf=Min')
         (B1+Min=>PiMin x) (B1+Mf=>PiMf x) _ (B1+Min'=>PiMin' x) (EQV1 x))
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Mout^Mf Mout+Mf=Mout')
         (B1+Mout=>PiMout x) (B1+Mf=>PiMf x) _ (B1+Mout'=>PiMout' x) (EQV2 x))
    <- not-unique-perm-implies-empty T2PFB not-unique/borrow IMP7
    <- ({x} constymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (clsmap-cxt-env/ (CM-B1-Uin x) (CM-B1-Min' x))
         (clsmap-cxt-env/ (CM-B1-Uout x) (CM-B1-Mout' x))
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/borrow T2PFB))
         (env2input/ (B1+Uin=>PiUin x) (B1+Min'=>PiMin' x))
         (env2input/ (B1+Uout=>PiUout x) (B1+Mout'=>PiMout' x))
         (implies/trans3
           (implies/combine implies/reflexive (IMP0))
           (implies/equiv equiv/swap-middle)
           (implies/combine implies/reflexive
             (implies/trans3
               (implies/combine (IMP5 x) implies/reflexive)
               (implies/equiv equiv/reorder)
               (implies/combine implies/reflexive
                 (implies/trans implies/commute (implies/equiv (EQV1 x)))))))
         (implies/trans4
           (implies/combine
             (implies/trans
               (implies/combine (IMP7 x) implies/reflexive)
               (implies/commute-identity))
             (implies/trans
               (implies/combine
                 (implies/reflexive)
                 (implies/trans
                   (implies/equiv (equiv/symmetric (EQV2 x)))
                   (implies/combine implies/reflexive (IMP6 x))))
               (implies/associate)))
           (implies/associate)
           (implies/combine (IMP1) implies/reflexive)
           (implies/commute))
         (CM-MT) (MC x) (MT=>PT x)
         ([t] PC x t)).

- : constymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (clsmap-cxt-env/ CM-B0-Uin CM-B0-Min)
    CM-B0-Vout
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (env2input/ (B0+Uin=>PiUin:make-encumbered CM PM B0 Uin PiUin)
      (B0+Min=>PiMin:capset2perm CM PM B0 Min PiMin))
    (B0+Vout=>PiVout:env2input CM PM B0 Vout PiVout)
    (IMP0)
    (IMP1:implies (PiB0 , PiVout) Piout)
    (clsmap-methty/args CM-MT (CML2:clsmap`lookup CM C FM2)
      (DM2:fldmap`domain FM2 FS2) LE)
    (constymatch/args/unique N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) x)
      (CML:clsmap`lookup CM C FM) (DM:fldmap`domain FM FS)
      (N+FS=>Mf:nat+set2set (s N) FS Mf) (Uin+N=Uin':set`add Uin (s N) Uin')
      (Min+Mf=Min':set`union Min Mf Min')
      ([x] MC x))
    (consty2proctype/arg
      (argtype2perm/unique T2PF) MT=>PT)
    ([t] proctypematch/arg ([x] PC x t))
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- cxt`fresh-update-preserves-make-encumbered B0+Uin=>PiUin N!<B0 B0+N=B1 B1+Uin=>PiUin
    <- cxt`fresh-update-preserves-capset2perm B0+Min=>PiMin N!<B0 B0+N=B1 B1+Min=>PiMin
    <- cxt`fresh-update-preserves-env2input B0+Vout=>PiVout N!<B0 B0+N=B1 B1+Vout=>PiVout
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uin N!<B0 B0+N=B1 CM-B1-Uin
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Min N!<B0 B0+N=B1 CM-B1-Min
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vout N!<B0 B0+N=B1 CM-B1-Vout
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- cxt`domain-total (DM-B0=BS0:cxt`domain B0 BS0)
    <- clsmap-cxt-objset-implies-domain-leq CM-B0-Uin DM-B0=BS0 Uin<=BS0
    <- cxt`domain-preserves-fresh N!<B0 DM-B0=BS0 N!<BS0
    <- set`not-member-respects-geq N!<BS0 Uin<=BS0 N!<Uin
    <- ({x} nat+set2set-implies-clsmap-cxt-capset CML DM (B1-L x) not-shared/unique
         N+FS=>Mf (CM-B1-Mf x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Min x) (CM-B1-Mf x) Min+Mf=Min'
         (CM-B1-Min' x))
    <- letRefTyping-helper/base/unique/L4L1** CM-CM CM2PM CML PML DM T2PF _ _ FS=>PF T2PFB IMP4
    <- letRefTyping-helper/base/unique/L4L2* CML FS=>PF B1-L N+FS=>Mf _ B1+Mf=>PiMf IMP5 _
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Min N!<B0 N+FS=>Mf Min^Mf
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Min^Mf Min+Mf=Min')
         (B1+Min=>PiMin x) (B1+Mf=>PiMf x) _ (B1+Min'=>PiMin' x) (EQV x))
    <- not-unique-perm-implies-empty T2PFB not-unique/borrow IMP7
    <- ({x} constymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (clsmap-cxt-env/
           (clsmap-cxt-objset/U (CM-B1-Uin x) (B1-L x) CML N!<Uin Uin+N=Uin')
           (CM-B1-Min' x))
         (CM-B1-Vout x)
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/unique T2PFB))
         (env2input/
           (make-encumbered/U (B1+Uin=>PiUin x) (B1-L x) CML PML DM
             FS=>PF N!<Uin Uin+N=Uin')
           (B1+Min'=>PiMin' x))
         (B1+Vout=>PiVout x)
         (implies/trans5
           (implies/combine (IMP4 x) (IMP0))
           (implies/equiv equiv/swap-middle)
           (implies/combine
             (implies/equiv equiv/swap) (implies/reflexive))
           (implies/symmetric-associate)
           (implies/combine implies/reflexive
             (implies/trans3
               (implies/combine implies/reflexive implies/reorder)
               (implies/associate)
               (implies/combine implies/reflexive
                 (implies/trans3
                   (implies/commute)
                   (implies/combine implies/reflexive (IMP5 x))
                   (implies/equiv (EQV x)))))))
         (implies/trans
           (implies/symmetric-associate)
           (implies/combine (IMP7 x) (IMP1)))
         (CM-MT) (MC x) (MT=>PT x)
         ([t] PC x t)).

%worlds (gtermvar) (constymatch-implies-proctypematch* _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (M) (constymatch-implies-proctypematch* _ _ _ _ _ _ _ _ _ _ _ _ _ M _ _).


%theorem constymatch-implies-proctypematch
  : forall* {CM} {MM} {PM} {W} {MT} {F} {PTF} {FM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-MT: clsmap-methty CM MT}
    {MC: constymatch CM MM FM F MT}
    {MT=>PT: consty2proctype CM FM PM MT PTF}
    exists {PC: {t} proctypematch W (F t) (PTF t)}
    true.

- : constymatch-implies-proctypematch CM-CM CM-MM CM2PM MM2W CM-MT F-MT MT=>PT F-PT
    <- constymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
      clsmap-cxt/0
      (clsmap-cxt-env/ clsmap-cxt-objset/0 clsmap-cxt-capset/0)
      (clsmap-cxt-env/ clsmap-cxt-objset/0 clsmap-cxt-capset/0)
      (cxt2perm/0)
      (env2input/ make-encumbered/0 capset2perm/0)
      (env2input/ make-encumbered/0 capset2perm/0)
      (implies/trans
        (implies/symmetric-identity)
        (implies/combine implies/reflexive (implies/symmetric-identity)))
      (implies/trans
        (implies/combine implies/reflexive implies/identity)
        (implies/identity))
      CM-MT F-MT MT=>PT F-PT.

%worlds (gtermvar) (constymatch-implies-proctypematch _ _ _ _ _ _ _ _).
%total { } (constymatch-implies-proctypematch _ _ _ _ _ _ _ _).


%%% Program Typing: checking method map against prog

methmapmatch* : clsmap -> methmap -> methmap -> prog -> type.

methmapmatch/0 : methmapmatch* _ _ methmap/0 prog`map/0.

%%% nat`z is a special field.
methmapmatch/U/const :
    methmapmatch* CM MM0 MM' G' ->
    clsmap`lookup CM C FM ->
    constymatch CM MM0 FM FF CT ->
    methmap`fresh MM' C ->
    methmap`update MM' C (methty/arg (ty/ nn/yes _ C) _ CT) MM ->
    prog`update G' C (func/+ ([t] FF t)) G ->
  methmapmatch* CM MM0 MM G.

methmapmatch/U/meth :
    methmapmatch* CM MM0 MM' G' ->
    clsmap`fresh CM N ->
    methtymatch CM MM0 F MT ->
    methmap`fresh MM' N ->
    methmap`update MM' N MT MM ->
    prog`update G' N F G ->
  methmapmatch* CM MM0 MM G.

%abbrev methmapmatch = [CM][MM][G] methmapmatch* CM MM MM G.


%%% Theorems about methmapmatch

%theorem false-implies-progtypematch
  : forall* {W0} {W} {G}
    forall {V: void}
    exists {W-G: progtypematch* W0 W G}
    true.

%worlds (gtermvar) (false-implies-progtypematch _ _).
%total { } (false-implies-progtypematch _ _).


%theorem fresh-update-preserves-progtypematch
  : forall* {W0} {W'} {G'} {FUN} {PT} {N} {W} {G}
    forall {W'-G': progtypematch* W0 W' G'}
    {FUN-PT: proctypematch W0 FUN PT}
    {WF: progtype`fresh W' N}
    {WU: progtype`update W' N PT W}
    {GU: prog`update G' N FUN G}
    exists {W-G: progtypematch* W0 W G}
    true.

%worlds (gtermvar) (fresh-update-preserves-progtypematch _ _ _ _ _ _).
%trustme %total { } (fresh-update-preserves-progtypematch _ _ _ _ _ _).


%theorem methmapmatch-implies-progtypematch/L
  : forall* {CM} {MM} {G} {PM} {MM0} {W0} {W}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM=>PM: clsmap2predmap CM PM}
		{CM-MM0: clsmap-methmap CM MM0}
    {MM0=>W0: methmap2progtype CM PM MM0 W0}
    {CM-MM: clsmap-methmap CM MM}
    {MM-G: methmapmatch* CM MM0 MM G}
    {MM=>W: methmap2progtype CM PM MM W}
    exists {W-G: progtypematch* W0 W G}
    true.

- : methmapmatch-implies-progtypematch/L CM-CM CM2PM CM-MM0 MM0=>W0
    _ methmapmatch/0 methmap2progtype/0 progtypematch/0.

- : methmapmatch-implies-progtypematch/L CM-CM
    (CM2PM:clsmap2predmap CM PM)
    (CM-MM0:clsmap-methmap CM MM0)
    (MM0=>W0: methmap2progtype CM PM MM0 W0)
    (CM-MM:clsmap-methmap CM _)
    (methmapmatch/U/meth
      (MM'-G':methmapmatch* CM MM0 MM' G')
      (CMF:clsmap`fresh CM N)
      (FUN-MT: methtymatch CM MM0 FUN MT)
      (N!<MM': methmap`fresh MM' N)
      (MM'+N=MM: methmap`update MM' N MT MM)
      (G'+N=G: prog`update G' N FUN G))
    (MM=>W:methmap2progtype CM PM _ W) W-G
    <- methmap2progtype/U/m-inversion MM=>W CMF N!<MM' MM'+N=MM W' PT MM'=>W' MT=>PT W'+PT=W
    <- clsmap-methmap/U/meth-inversion CM-MM CMF N!<MM' MM'+N=MM CM-MT CM-MM'
    <- methtymatch-implies-proctypematch CM-CM CM-MM0 CM2PM MM0=>W0 CM-MT FUN-MT MT=>PT FUN-PT
    <- methmapmatch-implies-progtypematch/L CM-CM CM2PM CM-MM0 MM0=>W0 CM-MM'
      MM'-G' MM'=>W' W'-G'
    <- methmap2progtype-preserves-fresh MM'=>W' N!<MM' N!<W'
    <- fresh-update-preserves-progtypematch W'-G' FUN-PT N!<W' W'+PT=W G'+N=G W-G.

- : methmapmatch-implies-progtypematch/L CM-CM
    (CM2PM:clsmap2predmap CM PM)
    (CM-MM0:clsmap-methmap CM MM0)
    (MM0=>W0: methmap2progtype CM PM MM0 W0)
    (CM-MM:clsmap-methmap CM _)
    (methmapmatch/U/const
      (MM'-G':methmapmatch* CM MM0 MM' G')
      (CML:clsmap`lookup CM N FM)
      (FUN-MT: constymatch CM MM0 FM FUN MT)
      (N!<MM': methmap`fresh MM' N)
      (MM'+N=MM: methmap`update MM' N (methty/arg (ty/ nn/yes _ N) _ MT) MM)
      (G'+N=G: prog`update G' N (func/+ ([t] FUN t)) G))
    (MM=>W:methmap2progtype CM PM _ W) W-G
    <- methmap2progtype/U/c-inversion MM=>W CML N!<MM' MM'+N=MM W' PT MM'=>W' MT=>PT W'+PT=W
    <- clsmap-methmap/U/const-inversion CM-MM CML N!<MM' MM'+N=MM FS A MT0 S
      EQ CM-MT0 DM LE CM-MM'
    <- methty/arg-eq-inversion EQ T-EQ _ MT0=MT
    <- clsmap-methty-respects-eq CM-MT0 clsmap`eq/ MT0=MT CM-MT
    <- constymatch-implies-proctypematch CM-CM CM-MM0 CM2PM MM0=>W0 CM-MT FUN-MT MT=>PT FUN-PT
    <- methmapmatch-implies-progtypematch/L CM-CM CM2PM CM-MM0 MM0=>W0 CM-MM'
      MM'-G' MM'=>W' W'-G'
    <- methmap2progtype-preserves-fresh MM'=>W' N!<MM' N!<W'
    <- fresh-update-preserves-progtypematch W'-G'
      (proctypematch/arg ([t] FUN-PT t)) N!<W' W'+PT=W G'+N=G W-G.

%worlds (gtermvar) (methmapmatch-implies-progtypematch/L _ _ _ _ _ _ _ _).
%total (M) (methmapmatch-implies-progtypematch/L _ _ _ _ _ M _ _).


%theorem methmapmatch-implies-progtypematch
  : forall* {CM} {MM} {G} {PM} {W}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
		{CM-MM: clsmap-methmap CM MM}
    {MM-G: methmapmatch CM MM G}
    {MM2W: methmap2progtype CM PM MM W}
    exists {W-G: progtypematch W G}
    true.

- : methmapmatch-implies-progtypematch CM-CM CM2PM CM-MM MM-G MM2W W-G
    <- methmapmatch-implies-progtypematch/L CM-CM CM2PM CM-MM MM2W CM-MM MM-G MM2W W-G.

%worlds (gtermvar) (methmapmatch-implies-progtypematch _ _ _ _ _ _).
%total { } (methmapmatch-implies-progtypematch _ _ _ _ _ _).


%theorem env2progtype-total
  : forall* {CM} {MM} {G}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {MM-G: methmapmatch CM MM G}
    exists {W} {PM} {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {W-G: progtypematch W G}
    true.

- : env2progtype-total CM-CM CM-MM MM-G _ _ CM2PM MM2W W-G
    <- clsmap2predmap-total CM-CM _ CM2PM
    <- methmap2progtype-total CM-CM CM2PM CM-MM _ MM2W
    <- methmapmatch-implies-progtypematch CM-CM CM2PM CM-MM MM-G MM2W W-G.

%worlds () (env2progtype-total _ _ _ _ _ _ _ _).
%total { } (env2progtype-total _ _ _ _ _ _ _ _).