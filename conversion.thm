%%% Theorems about conversion between reftyping and typing


same-class : cxt -> set -> nat -> type.

same-class/0 : same-class _ set/0 _.

same-class/+
  : same-class B (set/+ L S) C
    <- set`shift L S SP
    <- cxt`lookup B L (cxtv/ _ (ty/ _ _ C))
    <- same-class B SP C.

%%% lemmas for reftyping/read

%{ this lemma says if we have a set of object IDs,
call it S, and we can convert this set S to objequal facts G.
Suppose all objects in S are of the same
class. Then, if we extend S with a field F with read 
effect, and get efxmap XM. This XM can then be converted
to a input permission Pi, and Pi "implies" read permission
for field F, along with the encumbered facts. }% 

reftyping-ok/read/L1
  : {K} set`size S (s K)
    -> same-class B S C
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN A FC)
    -> ty2perm PM (ty/ NN A FC) PF
    -> set+nat2efxmap S F efx/read XM
    -> ({r} set2facts B r S (G r))
    -> efxmap2perm true CM PM B XM Pi
    -> ({z}{r} implies
         ((unitperm (nonlinear (G r))) , (Pi z))
         ((scale z (unitperm (precise-exists r F ([v] PF v)))) ,
           (unitperm
             (encumbered 
               (scale z (unitperm (precise-exists r F ([v] PF v))))
               (Pi z)))))
    -> type.

%mode reftyping-ok/read/L1 
+K +SZ +SC +CML +FML +T2PF +S2XM -S2G -XM2Pi -IMP.

- : reftyping-ok/read/L1 _ (set`size/+ set`size/0)
    (same-class/+ same-class/0 B-L set`shift/0 WF-B)
    CM-L FM-L T2PF (set+nat2efxmap/+ set+nat2efxmap/0)
  %{=>}% 
    ([_] set2facts/+ set2facts/0 B-L WF-B set`shift/0)
    (efxmap2perm/+
      efxmap2perm/0 efxmap`shift/0
      (inner-efxmap2perm/+ 
        (apply-efx/read)
        inner-efxmap2perm/0 inner-efxmap`shift/0
        T2PF FM-L) CM-L B-L WF-B)
    ([z][r] implies/trans4
      (implies/combine
        (implies/nonlinear
          (bimplies/trans
            (bimplies/neg
              (bimplies/trans
                (bimplies/conj/XX
                  (bimplies/reflexive)
                  (bimplies/rem-negneg))
                (bimplies/conj-true))
              (bool`ne/FT))
            (bimplies/trans
              (bimplies/rem-negneg)
              (bimplies/objequal-symmetric))))
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/equiv
              (equiv/transitive
                (equiv/identity)
                (equiv/identity)))
            (implies/trans
              (implies/self-implication)
              (implies/equiv-encumbered
                (equiv/transitive
                  (equiv/identity)
                  (equiv/identity))
                (equiv/reflexive))))))
      (implies/objequal
        ([o] (scale z (fldperm-fun o F ([v] PF v))) , 
          (unitperm
            (encumbered (scale z (fldperm-fun o F ([v] PF v)))
              (combine
                (combine (scale z (fldperm-fun R F ([v] PF v))) 
                  empty) empty)))))
      (implies/equiv (equiv/symmetric equiv/identity))
      (implies/equiv equiv/identity)).

- : reftyping-ok/read/L1 (s N) (set`size/+ SZ-S)
    (same-class/+ SOC-SS B-L SL<<S=SS WF-B)
    CM-L FM-L T2PF (set+nat2efxmap/+ S1+FX=XM1)
    %{=>}%
    ([r] set2facts/+ (SS=>GS r) B-L WF-B SL<<S=SS)
    (efxmap2perm/+ XMS=>PiS SL<<XM=XMS
      (inner-efxmap2perm/+ apply-efx/read
        inner-efxmap2perm/0 inner-efxmap`shift/0
        T2PF FM-L) CM-L B-L WF-B)
    ([z][r] implies/trans7
      (implies/equiv equiv/commute)
      (implies/combine
        (implies/combine
          (implies/equiv equiv/identity)
          (implies/reflexive))
        (implies/disj2cond))
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans6
          (implies/combine
            (implies/reflexive)
            (implies/equiv equiv/identity))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (implies/nonlinear bimplies/objequal-symmetric)
                (implies/trans
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/self-implication))))
              (implies/objequal
                ([o] (scale z (fldperm-fun o F ([v] PF v))) , 
                  (unitperm
                    (encumbered (scale z (fldperm-fun o F ([v] PF v)))
                      (scale z (fldperm-fun R F ([v] PF v))))))))
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine
                (implies/reflexive)
                (implies/trans3
                  (implies/self-implication)
                  (implies/equiv-encumbered
                    (equiv/commute)
                    (equiv/combine
                      (equiv/symmetric equiv/identity)
                      (equiv/reflexive)))
                  (implies/combine-assoc-encumbered)))
              (implies/linear-modus-ponens)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/chain-implication))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans2
          (implies/combine
            (implies/reflexive)
            (implies/trans3
              (implies/equiv 
                (equiv/transitive
                  (equiv/symmetric equiv/associate)
                  (equiv/combine
                    (equiv/reflexive)
                    (equiv/commute))))
              (implies/combine
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/reflexive)
                        (equiv/combine
                          (equiv/symmetric equiv/identity)
                          (equiv/reflexive)))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens))
                (implies/trans
                  (IMP z r) 
                  (implies/equiv (equiv/symmetric equiv/identity))))
              (implies/trans
                (implies/equiv
                  (equiv/associate))
                (implies/combine
                  (implies/trans
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/symmetric equiv/associate)))
                    (implies/combine
                      (implies/reflexive)
                      (implies/chain-implication)))
                  (implies/reflexive)))))
          (implies/equiv 
            (equiv/transitive
              (equiv/commute)
              (equiv/symmetric equiv/associate)))))
      (implies/cond-pull)
      (implies/trans
        (implies/combine
          (implies/reflexive)
          (implies/trans
            (implies/cond-inner
              (bimplies/reflexive)
              (bimplies/reflexive)
              (implies/reflexive)
              (implies/trans
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/nonlinear 
                      (bimplies/tt))
                    (implies/true2empty)))
                (implies/equiv equiv/identity)))
            (implies/cond-equal)))
        (implies/equiv equiv/identity)))
    <- set`shift-preserves-size SZ-S SL<<S=SS SZ-SS
    <- efxmap`shift-total SL<<XM=XMS
    <- shift-preserves-set+nat2efxmap 
      S1+FX=XM1 SL<<S=SS SL<<XM=XMS SS+FX=XMS
    <- reftyping-ok/read/L1 N SZ-SS SOC-SS CM-L
      FM-L T2PF SS+FX=XMS %{=>}% SS=>GS XMS=>PiS ([z][r] IMP z r).

%worlds (objvar | fracvar) (reftyping-ok/read/L1 _ _ _ _ _ _ _ _ _ _).
%total (N) (reftyping-ok/read/L1 N _ _ _ _ _ _ _ _ _).

%{ A version of the above theorem where set2facts and
  efxmap2perm appear in premises }%
reftyping-ok/read/L2
  : set`size S (s K)
    -> same-class B S C
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN A FC)
    -> ty2perm PM (ty/ NN A FC) PF
    -> set+nat2efxmap S F efx/read XM
    -> ({r} set2facts B r S (G r))
    -> efxmap2perm true CM PM B XM Pi
    -> ({z}{r} implies
         ((unitperm (nonlinear (G r))) , (Pi z))
         ((scale z (unitperm (precise-exists r F ([v] PF v)))) ,
           (unitperm
             (encumbered 
               (scale z (unitperm (precise-exists r F ([v] PF v))))
               (Pi z)))))
    -> type.

%mode reftyping-ok/read/L2 +SZ +SC +CML +FML +T2PF +S2XM +S2G +XM2Pi -IMP.


reftyping-ok/read/L2L
  : ({r:object} implies (combine (Pi1 r) Pi2)
      (combine (Pi3 r) (unitperm (encumbered (Pi3 r) Pi2))))
    -> ({r} permission`eq (Pi1 r) (Pi4 r))
    -> permission`eq Pi2 Pi5
    -> ({r} implies (combine (Pi4 r) Pi5)
	 (combine (Pi3 r) (unitperm (encumbered (Pi3 r) Pi5))))
    -> type.

%mode reftyping-ok/read/L2L +IMP1 +EQ1 +EQ2 -IMP2.

- : reftyping-ok/read/L2L IMP ([_] permission`eq/) permission`eq/ IMP.

%worlds (objvar | fracvar) (reftyping-ok/read/L2L _ _ _ _).
%total  {} (reftyping-ok/read/L2L _ _ _ _).

- : reftyping-ok/read/L2 S-SZ S-C
    CM-L FM-L T2PF S+F2GM S2G XM2Pi IMP
    <- reftyping-ok/read/L1 _ S-SZ S-C CM-L FM-L
      T2PF S+F2GM S2G' XM2Pi' IMP'
    <- ({o} set2facts-deterministic (S2G' o) (S2G o)
         cxt`eq/ object`eq/ set`eq/ (P1-EQ o))
    <- efxmap2perm-deterministic XM2Pi' XM2Pi
      bool`eq/ clsmap`eq/ predmap`eq/ cxt`eq/ efxmap`eq/ ([z] P2-EQ z)
    <- ({z} reftyping-ok/read/L2L (IMP' z) P1-EQ (P2-EQ z) (IMP z)).

%worlds (objvar | fracvar) (reftyping-ok/read/L2 _ _ _ _ _ _ _ _ _).
%total  {} (reftyping-ok/read/L2 _ _ _ _ _ _ _ _ _).


%{ this theorem says if we know object o is equal to r,
we have "all" permission for object r, and we know F is a field
inside object r, then we can carve the permission for F out
of the permission for object r, and get a permission about
object o. }%

reftyping-ok/read/L3
  : {Pi} clsmap2predmap CM PM
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F (ty/ NN A FC)
    -> predmap`lookup PM C CP
    -> nn2perm nn/yes ([r] allperm r) PF
    -> annot2perm A AF
    -> nn2perm NN AF TF
    -> predmap`lookup PM FC FCP
    -> ({o}{r} implies
         (unitperm (nonlinear (objequal o r)) ,
           ((PF CP r) ,
             (unitperm 
               (encumbered
                 (PF CP r) Pi))))
         (unitperm (precise-exists o F ([v] TF FCP v)) ,
           (unitperm
             (encumbered
               (unitperm (precise-exists o F ([v] TF FCP v))) Pi))))
    -> type.

%mode reftyping-ok/read/L3 +Pi +CM2PM +CM-L +FM-L +PM-L +NN2PF 
-A2AF -NN2TF -PM-L2 -IMP.

%abbrev fperm : clspred -> object -> permission 
  = [P][O] (unitperm (nonlinear (neg (objequal O null))) ,
             ((allperm O) , (one-predcall P O))).

- : reftyping-ok/read/L3 _ CM2PM CM-L FM-L PM-L nn2perm/yes
    %{=>}% A2AF FNN2P PM-FL
    ([o][r] implies/trans9
      (implies/combine 
        (implies/nonlinear (bimplies/objequal-symmetric))
        (implies/reflexive))
      (implies/objequal 
        ([x] ((fperm CP x) , (unitperm (encumbered (fperm CP x) Pi)))))
      (implies/combine
        (implies/trans
          (implies/combine
            (implies/reflexive) % r != null
            (implies/trans3
              (implies/combine
                (implies/reflexive) % r.all --> 0
                (implies/trans
                  (implies/duplicate)
                  (implies/combine (IMPF o) implies/reflexive)))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans
                  (implies/equiv equiv/commute)
                  (implies/carve))
                (implies/reflexive))))
          (implies/equiv equiv/commute))
        (implies/combine-assoc-encumbered))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive) 
        (implies/trans3
          (implies/linear-modus-ponens)
          (implies/equiv-encumbered
            (equiv/commute) (equiv/reflexive))
          (implies/combine-assoc-encumbered)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive) (implies/linear-modus-ponens))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive) (implies/chain-implication)))
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L _ _ _
      A2AF FNN2P PM-FL ([o] IMPF o).

%worlds () (reftyping-ok/read/L3 _ _ _ _ _ _ _ _ _ _).
%total  {} (reftyping-ok/read/L3 _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/L4 :
    forall* {XM} {GM} {XM1} {XMS} {XM3} {XM4}
            {S} {GS} {F} {GMP} {GMS} {X}
    forall  {DM-GM: tgtmap`domain GM GS} 
            {S^GS: set`disjoint S GS} {S+F=GMP: set+nat2tgtmap S F GMP}
            {GMUGMP=GMS: tgtmap`join GM GMP GMS}
            {GMS=>XMS: tgtmap2efxmap GMS X XMS}
            {XM1UXMS=XM: efxmap`join XM1 XMS XM}
            {XM/GM=XM3+XM4: efxmap`remove-tgtmap XM GM XM3 XM4}
    exists  {XMP} {GMP=>XMP: tgtmap2efxmap GMP X XMP}
            {XMP<=XM3: efxmap`leq XMP XM3}
    true.

% - : reftyping-ok/L4 DM-GM=GS S^GS S+F=GMP
%     GMUGMP=GMS GMS=>XMS XM1UXMS=XM XM/GM=XM3+XM4 XMS2 GMP=>XMS2 XMS2<=XM3
%     <- set+nat2tgtmap-implies-domain S+F=GMP DM-GMP=S
%     <- tgtmap`domain-preserves-disjoint-converse
%       S^GS DM-GMP=S DM-GM=GS GMP^GM
%     <- tgtmap`disjoint-symmetric GMP^GM GM^GMP
%     <- efxmap`remove-tgtmap-implies-join XM/GM=XM3+XM4 XM3UXM4=XM
%     <- tgtmap`join-implies-leq GMUGMP=GMS GM<=GMS GMP<=GMS
%     <- tgtmap2efxmap-implies-tgtmap-leq-efxmap GMS=>XMS GMS<=XMS
%     <- efxmap`join-implies-leq XM1UXMS=XM XM1<=XM XMS<=XM
%     <- tgtmap-leq-efxmap-left-transitive GMS<=XMS GM<=GMS GM<=XMS
%     <- tgtmap-leq-efxmap-right-transitive GM<=XMS XMS<=XM GM<=XM
%     <- efxmap`remove-tgtmap-implies-efxmap2tgtmap XM/GM=XM3+XM4 GM<=XM XM4=>GM
%     <- tgtmap2efxmap-preserves-disjoint-join
%       GMS=>XMS GM^GMP GMUGMP=GMS XMS1 XMS2 GM=>XMS1 GMP=>XMS2
%       XMS1^XMS2 XMS1UXMS2=XMS
%     <- efxmap2tgtmap-preserves-domain-converse XM4=>GM DM-GM=GS DM-XM4=GS
%     <- tgtmap2efxmap-preserves-domain GMP=>XMS2 DM-GMP=S DM-XMS2=S
%     <- efxmap`domain-preserves-disjoint-converse 
%       S^GS DM-XMS2=S DM-XM4=GS XMS2^XM4
%     <- efxmap`disjoint-symmetric XMS2^XM4 XM4^XMS2
%     <- efxmap`join-implies-leq XMS1UXMS2=XMS _ XMS2<=XMS
%     <- efxmap`leq-transitive XMS2<=XMS XMS<=XM XMS2<=XM
%     <- efxmap`join-disjoint-right-leq-implies-leq
%       XM3UXM4=XM XM4^XMS2 XMS2<=XM XMS2<=XM3.

%worlds () (reftyping-ok/L4 _ _ _ _ _ _ _ _ _ _).
%trustme %total { } (reftyping-ok/L4 _ _ _ _ _ _ _ _ _ _).


%{%
A well-formed clsmap should contain key 0, which 
maps to a special fldmap with only one value, which is (0 -> ty/null)
%}%

wf-clsmap : clsmap -> type.

wf-clsmap/
  : clsmap`lookup CM nat`z (fldmap/1 nat`z ty/null)
    -> wf-clsmap CM.

%{%
  After using reftyping-frame, we can use the *augmented* permission
  to check E, and get a output containing two set of permissions:
  object equal relations and the actual permissions for result value 
%}% 

%abbrev ffperm : fraction -> object -> nat 
   -> (object -> permission) -> permission 
  = [z][r][n][fp] (scale z (unitperm (precise-exists r n ([o] fp o)))). 

reftyping-ok/read/L1
  : clsmap-clsmap CM CM
    -> clsmap2predmap CM PM
    -> cxt-efxmap B CM XM
    -> reftype+efxmap2output CM PM B (reftype/ (ty/ nn/yes A C) S GM1) XM Out
    -> set+nat2tgtmap S F GM2
    -> tgtmap`join GM1 GM2 GM
    -> tgtmap2efxmap GM efx/read XM2
    -> efxmap`leq XM2 XM
    -> clsmap`lookup CM C FM
    -> fldmap`lookup FM F T
    -> ({z} transform (Out z)
         (output/exists [r]
           (output/expr r
             ((ffperm z r F PF) ,
               (unitperm
                 (encumbered (ffperm z r F PF) Pi1) , Pi2)))))
    -> type.

%mode reftyping-ok/read/L1 +D1 +D2 +D3 +D4 +D5 +D6 +D7 +D7 +D8 +D9 -D10.