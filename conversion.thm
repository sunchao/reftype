%%% Theorems about converting from reftype to permission type.


%%% Shortcuts

%abbrev fldperm-fun
  : object -> nat -> (object -> permission) -> permission
 = [o][F][PF] unitperm (precise-exists o F ([v] PF v)).


%%% Lemmas

%theorem implies-respects-permission-eq
  : forall* {P1} {P2} {P3} {P4}
    forall {Pi1=>Pi2: implies P1 P2}
    {P1=P3: permission`eq P1 P3}
    {P2=P4: permission`eq P2 P4}
    exists {P3=>P4: implies P3 P4}
    true.

- : implies-respects-permission-eq I permission`eq/ permission`eq/ I.

%worlds () (implies-respects-permission-eq _ _ _ _).
%total {} (implies-respects-permission-eq _ _ _ _).


%theorem false-implies-transform
  : forall* {K} {O1:output K} {O2:output K}
    forall {F:void}
    exists {T: transform O1 O2}
    true.

%worlds () (false-implies-transform _ _).
%total {} (false-implies-transform _ _).



%{ This theorem says if we have a class predicate and we
know that this class has a field F, then we can pull out
the nesting fact about F from the predicate. }%


%theorem fldperm-can-lookup
  : forall* {CM} {PM} {C} {FM} {F} {NN} {A} {FC} {CP}
    forall {CM2PM: clsmap2predmap CM PM}
    {PM-L: predmap`lookup PM C CP}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    exists {AF} {PF} {FCP}
    {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM FC FCP}
    {IMP: {o} implies
          (unitperm
            (nonlinear
              (predcall CP (predargs/1 o))))
          (unitperm
            (nonlinear
              (nested ((fldperm F PF) FCP o) o all)))}
    true.

%theorem fldperm-can-lookup/false-imply
  : forall* {PM} {NN} {C} {F:nat} {G} {A}
    forall {V:void}
    exists {AF} {PF:clspred -> object -> permission}
    {CP} {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    {IMP: {o} implies (unitperm (nonlinear (G o)))
        (unitperm
          (nonlinear
            (nested ((fldperm F PF) CP o) o all)))}
    true.

%theorem fldperm-can-lookup/L
  : forall* {CM} {PM} {FM} {F} {NN} {A} {G} {C}
    forall {FM=>G: fldmap2conj CM PM FM ([r] G r) PM}
    {FM-L: fldmap`lookup FM F (ty/ NN A C)}
    exists {AF} {PF} {CP}
    {A2AF: annot2perm A AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    {IMP: {o} implies (unitperm (nonlinear (G o)))
        (unitperm
            (nonlinear
              (nested ((fldperm F PF) CP o) o all)))}
    true.

- : fldperm-can-lookup/L (fldmap2conj/null FMP2G F<=FM=FMP)
    (fldmap`lookup/> FM->F P) AF PF CP A2AF FNN2PF PM->C IMP
    <- nat`plus-swap-succ P P1
    <- nat`plus-commutative P1 P2
    <- fldmap`shift-preserves-lookup* FM->F F<=FM=FMP P2 FMP->F
    <- fldperm-can-lookup/L FMP2G FMP->F AF PF CP A2AF FNN2PF PM->C IMP.

- : fldperm-can-lookup/L (fldmap2conj/in _ FNN2P A2AF _ PM-L)
     (fldmap`lookup/= nat`eq/) _ _ _ A2AF FNN2P PM-L
    ([o] implies/trans3
      (implies/conj2combine)
      (implies/combine
        (implies/reflexive)
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
      (implies/equiv equiv/identity)).

- : fldperm-can-lookup/L (fldmap2conj/in FM2G _ _ FM-SH _)
    (fldmap`lookup/> FM-L P) AF PF CP A2AF FNN2P PM-L
    ([o] implies/trans4
      (implies/conj2combine)
      (implies/combine
        (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
        (I o))
      (implies/equiv equiv/commute)
      (implies/equiv equiv/identity))
    <- nat`plus-swap-succ P P'
    <- nat`plus-commutative P' P''
    <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
    <- fldperm-can-lookup/L FM2G FM-L' AF PF CP A2AF FNN2P PM-L I.

- : fldperm-can-lookup/L
    (fldmap2conj/out F2C
      (F2CF:{f} fldmap2conj _ _ _ ([r] CJ f r) _)
      ([f] PM-U f) _ _ _ _ PM-FS) _ AF PF PD A2AF FNN2P PM-L I
    <- predmap`size-total SZ-PM
    <- predmap`fresh-update-increases-size
      SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
    <- fldmap2conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
    <- predmap`size-total SZ-PMF
    <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
    <- fldmap2conj-implies-predmap-leq F2C PMF<=PM
    <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
    <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
    <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
    <- nat`gt-anti-reflexive SZ-PM>PM F
    <- fldperm-can-lookup/false-imply F AF PF PD A2AF FNN2P PM-L I.

- : fldperm-can-lookup
    CM2PM PM-L CM-L FM-L AF PF CP A2AF FNN2PF PM->FC
    ([o] implies/trans3
      (implies/equiv (EQV o))
      (implies/nonlinear
        (bimplies/trans
          (bimplies/predcall/Y/inline)
          (bimplies/trans
            (bimplies/predcall/+/inline o)
            (bimplies/predcall/0/inline))))
      (IMP o))
    <- clsmap2predmap-implies-clsmap-predmap CM2PM CM-PM
    <- clsmap-predmap-implies-lookup-format CM-PM PM-L _ PM-LP ([o] (PEQ o))
    <- ({o} permission`eq-implies-equiv (PEQ o) (EQV o))
    <- clsmap2predmap-implies-fldmap2conj CM2PM PM-LP CM-L FM2G
    <- fldperm-can-lookup/L FM2G FM-L AF PF CP A2AF FNN2PF PM->FC IMP.

%worlds (objvar) (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).
%total {} (fldperm-can-lookup/false-imply _ _ _ _ _ _ _ _).

%worlds (objvar) (fldperm-can-lookup/L _ _ _ _ _ _ _ _ _).
%total (FM2G) (fldperm-can-lookup/L FM2G _ _ _ _ _ _ _ _).

%worlds (objvar) (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).
%total {} (fldperm-can-lookup _ _ _ _ _ _ _ _ _ _ _).



%theorem sharedperm-can-be-duplicated
  : forall* {NN} {C} {AF} {PF} {PM} {CP}
    forall {A2AF: annot2perm annot/shared AF}
    {NN2PF: nn2perm NN AF PF}
    {PM-L: predmap`lookup PM C CP}
    exists {IMP: {r} implies (PF CP r) ((PF CP r) , (PF CP r))}
    true.

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/yes _
    ([r]
      (implies/trans4
        (implies/combine
          (implies/reflexive)
          (implies/combine2conj))
        (implies/combine2conj)
        (implies/duplicate)
        (implies/combine
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))
          (implies/trans
            (implies/conj2combine)
            (implies/combine
              (implies/reflexive)
              (implies/conj2combine)))))).

- : sharedperm-can-be-duplicated annot2perm/shared
    nn2perm/may _
    ([r]
      (implies/trans3
        (implies/cond-inner
          (bimplies/reflexive)
          (bimplies/reflexive)
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/trans
            (implies/combine2conj)
            (implies/duplicate)))
        (implies/cond-distribute)
        (implies/combine
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/conj2combine))
          (implies/cond-inner
            (bimplies/reflexive)
            (bimplies/reflexive)
            (implies/reflexive)
            (implies/conj2combine))))).

%worlds () (sharedperm-can-be-duplicated _ _ _ _).
%total {} (sharedperm-can-be-duplicated _ _ _ _).


%theorem sharedperm-can-be-duplicated*
  : forall* {NN} {C} {PF} {PM}
    forall {T2PF: ty2perm PM (ty/ NN annot/shared C) PF}
    exists {IMP: {r} implies (PF r) ((PF r) , (PF r))}
    true.

- : sharedperm-can-be-duplicated*
    (ty2perm/ PM-L NN2PF A2AF) IMP
    <- sharedperm-can-be-duplicated A2AF NN2PF PM-L IMP.

%worlds () (sharedperm-can-be-duplicated* _ _).
%total {} (sharedperm-can-be-duplicated* _ _).




%abbrev ffperm
  : fraction -> object -> nat
   -> (object -> permission) -> permission
  = [f][r][n][fp] (scale f (unitperm (precise-exists r n ([o] fp o)))).


%{
%theorem reftyping-ok/read/unique
 : forall* {W} {CM} {PM} {E} {F}
   {B} {Pi0} {S} {C} {GM1} {GM2} {GM}
   {FM} {T} {XM1} {XM2} {XM} {GMP} {Pi1} {Out1}
   forall {CM-CM: clsmap-clsmap CM CM}
   {CM2PM: clsmap2predmap CM PM}
   {B-XM: cxt-efxmap B CM XM}
   {B2G: cxt2perm CM PM B Pi0}
   {TYP-E: {f} typing W (Pi0 , Pi1 f) E (Out1 f)}
   {TI1: efxmap2perm true CM PM B XM1 Pi1}
   {TO1: reftype+efxmap2output CM PM B
         (reftype/ (ty/ nn/yes annot/unique C) S GM1) XM1 Out1}
   {CM-L: clsmap`lookup CM C FM}
   {FM-L: fldmap`lookup FM F T}
   {S+F2GM: set+nat2tgtmap B S F GM2}
   {J: tgtmap`join GM1 GM2 GM}
   {GM2XM: tgtmap2efxmap GM efx/read XM2}
   {XMJ: efxmap`join XM1 XM2 XM}
   {F-GM: consider-fldtype T GM GMP}
   exists {Pi} {Out}
   {TI: efxmap2perm true CM PM B XM Pi}
   {TO: reftype+efxmap2output CM PM B (reftype/ T set/0 GMP) XM Out}
   {TYP: {f} typing W (Pi0 , Pi f) (read E F) (Out f)}
   true.
}%

%abbrev implies1
  : {v} implies empty
    (unitperm
      (encumbered
        (scale Q (unitperm (basic O F v)))
        (unitperm
          (encumbered
            (scale Q (PF v))
            (scale Q (unitperm (precise-exists O F ([v] PF v))))))))
    = ([v] implies/trans5
        (implies/equiv (equiv/symmetric equiv/zero))
        (implies/scale (implies/gen-pack-encumber v))
        (implies/scale-distribute-encumbered)
        (implies/equiv-encumbered equiv/distribute equiv/reflexive)
        (implies/combine-assoc-encumbered)).


%abbrev gen-objequal-self
  : {o} implies empty (unitperm (nonlinear (disj (objequal o o) (neg t))))
    = [o] implies/trans
      (implies/empty2true)
      (implies/nonlinear
        (bimplies/trans
          (bimplies/objequal-reflexive)
          (bimplies/trans
            (bimplies/add-negneg)
            (bimplies/neg
              (bimplies/conj-weaken/false)
              (bool`ne/FT))))).

% doesn't work - why?
%abbrev trans1
  : {f} transform
    (output/exists [r]
      (output/exists [v]
        (output/expr v
          (scale f (unitperm (basic r F v)) ,
            (scale f (PF v) ,
              (unitperm (encumbered (ffperm f r F PF) (Pi2 f)) , Pi1 f))))))
    (output/exists [o]
      (output/exists [v]
        (output/expr o
          (unitperm (nonlinear (disj (objequal o v) (neg t))) ,
            ((scale f (PF v) ,
               (unitperm (encumbered (scale f (PF v)) (Pi2 f)) , Pi1 f)))))))
    = [f]
      (transform/trans
        (transform/inside [r]
          (transform/inside [v]
            (transform/trans
              (transform/implies
                (implies/trans6
                  (implies/combine
                    (implies/trans3
                      (implies/equiv (equiv/symmetric equiv/identity))
                      (implies/combine implies/reflexive (implies1 v))
                      (implies/linear-modus-ponens))
                    (implies/reflexive))
                  (implies/equiv equiv/roll2)
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/equiv equiv/associate)
                      (implies/combine
                        (implies/chain-implication)
                        (implies/reflexive))))
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (gen-objequal-self v))
                  (implies/equiv equiv/commute)))
              (transform/gen-exists v))))
        (transform/rem-unused)).


%theorem can-carve-out-of-shared
  : forall* {Pi1} {Pi2} {Pi3}
    forall {EQV: {f} equiv (Pi2 f) (scale f (allperm null) , Pi3 f)}
    exists {IMP: {f} {r} implies
                 ((unitperm
                      (nonlinear
                        (nested (allperm r) null all))) , (Pi1 f , Pi2 f))
                 ((scale f (allperm r)) ,
                   ((unitperm
                     (encumbered
                       (scale f (allperm r)) (Pi2 f))) , (Pi1 f)))}
    true.

- : can-carve-out-of-shared
    EQV ([f][r] implies/trans3
          (implies/equiv
            (equiv/transitive
              (equiv/combine
                (equiv/reflexive) equiv/commute)
              (equiv/associate)))
          (implies/combine
            (implies/trans6
              (implies/combine
                implies/reflexive (implies/equiv (EQV f)))
              (implies/equiv equiv/associate)
              (implies/combine
                (implies/trans5
                  (implies/combine
                    (implies/scale-into-formula)
                    (implies/reflexive))
                  (implies/equiv (equiv/symmetric equiv/distribute))
                  (implies/scale implies/carve)
                  (implies/equiv equiv/distribute)
                  (implies/combine
                    implies/reflexive
                    (implies/scale-distribute-encumbered)))
                (implies/reflexive))
              (implies/combine
                (implies/reflexive)
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/transitive
                          (EQV f)
                          (equiv/commute))
                        (equiv/reflexive))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens)))
              (implies/equiv (equiv/symmetric equiv/associate))
              (implies/combine implies/reflexive implies/chain-implication))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/associate))).

%worlds () (can-carve-out-of-shared _ _).
%total {} (can-carve-out-of-shared _ _).


%abbrev carve-right-scale
  : {f} implies
    (unitperm (nonlinear (nested Pi1 O F)) ,
      (scale f (unitperm (basic O F null))))
    ((scale f Pi1) ,
      (unitperm
        (encumbered
          (scale f Pi1) (scale f (unitperm (basic O F null))))))
    = ([_]
        (implies/trans5
          (implies/combine
            (implies/scale-into-formula)
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/distribute))
          (implies/scale implies/carve)
          (implies/equiv equiv/distribute)
          (implies/combine
            implies/reflexive
            (implies/scale-distribute-encumbered)))).


%theorem reftyping-ok/before-read/shared
  : forall* {CM} {PM} {FM} {C} {NN} {A} {FC} {B} {XM} {MX} {Out} {F}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {LE: effects`leq (shared-effect efx/read) (effects/ XM MX)}
    {XX=>Out: effects2output CM PM B
              (reftype/ nn/yes C targets/shared) (effects/ XM MX) Out}
    exists {Pi1} {Pi2} {TF}
    {FT=>TF: ty2perm PM (ty/ NN A FC) TF}
    {MX=>Pi2: maybe-efx2perm MX Pi2}
    {XM=>Pi1: efxmap2perm false CM PM B XM Pi1}
    {TRANS: {f} transform (Out f)
            (output/exists [r]
              (output/expr r
                ((ffperm f r F TF) ,
                  ((unitperm
                     (encumbered
                       (ffperm f r F TF) (Pi2 f))) , Pi1 f))))}
    true.

- : reftyping-ok/before-read/shared
    CM-CM CM2PM CM-L FM-L (effects`leq/ XM1<=XM MX1<=MX)
    (effects2output/shared XM=>Pi1 MX=>Pi2
      (ty2perm/ PM-L nn2perm/yes annot2perm/shared))
    %{=>}% _ _ _ (ty2perm/ PM-LF NN2PF A2AF) MX=>Pi2 XM=>Pi1
    ([f] transform/inside [r]
      (transform/trans
        (transform/implies
          (implies/trans3
            (implies/combine
              (implies/trans
                (implies/equiv equiv/distribute)
                (implies/combine
                  implies/reflexive
                  (implies/trans
                    (implies/equiv equiv/distribute)
                    (implies/combine
                      (implies/scale-from-formula)
                      (implies/scale-from-formula)))))
              (implies/reflexive))
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/associate)
                (equiv/combine
                  (equiv/reflexive)
                  (equiv/transitive3
                    (equiv/symmetric equiv/associate)
                    (equiv/combine equiv/reflexive equiv/commute)
                    (equiv/associate)))))
            (implies/combine
              (implies/reflexive)
              (implies/trans6
                (implies/combine
                  (IMP1 f r) (IMP2 r))
                (implies/equiv
                  (equiv/transitive3
                    (equiv/symmetric equiv/associate)
                    (equiv/combine equiv/reflexive equiv/commute)
                    (equiv/associate)))
                (implies/combine
                  (implies/trans
                    (implies/equiv equiv/commute)
                    (implies/trans5
                      (implies/combine
                        (implies/scale-into-formula)
                        (implies/reflexive))
                      (implies/equiv (equiv/symmetric equiv/distribute))
                      (implies/scale implies/carve)
                      (implies/equiv equiv/distribute)
                      (implies/combine
                        implies/reflexive
                        (implies/scale-distribute-encumbered))))
                  (implies/reflexive))
                (implies/equiv equiv/associate)
                (implies/combine
                  (implies/trans
                    (implies/equiv (equiv/symmetric equiv/associate))
                    (implies/combine implies/reflexive implies/chain-implication))
                  (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))))))
        (transform/drop)))
    <- maybe-efx-leq-implies-permission-leq
      MX1<=MX (maybe-efx2perm/just apply-efx/read) MX=>Pi2 _ EQV
    <- can-carve-out-of-shared EQV IMP1
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L _ _ _ A2AF NN2PF PM-LF ([r] IMP2 r).

%worlds () (reftyping-ok/before-read/shared _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/before-read/shared _ _ _ _ _ _ _ _ _ _ _ _ _).


same-class : cxt -> set -> nat -> type.

same-class/0 : same-class _ set/0 _.

same-class/+
  : same-class B (set/+ N S) C
    <- set`shift N S SP
    <- cxt`lookup B N (cxtv/ _ (ty/ _ _ C))
    <- same-class B SP C.


%%% this lemma says we can combine a set of
%%% objequal facts and a corresponding set of field permissions,
%%% to get a single field permission carved out of latter.

%theorem get-field-permission/L
  : forall* {PM} {CM} {FM} {XM} {S} {B} {C} {F} {NN} {A} {FC}
    forall {K} {SZ: set`size S (s K)}
    {SC: same-class B S C} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>XM: set+nat2efxmap S F efx/read XM}
    exists {G} {S=>G: {r} set2facts B r S (G r)}
    {PF} {T2PF: ty2perm PM (ty/ NN A FC) PF}
    {Pi} {XM=>Pi: efxmap2perm true CM PM B XM Pi}
    {IMP: {f}{r} implies
          ((unitperm (nonlinear (G r))) , (Pi f))
          ((scale f (unitperm (precise-exists r F ([v] PF v)))) ,
            (unitperm
              (encumbered
                (scale f (unitperm (precise-exists r F ([v] PF v))))
                (Pi f))))}
    true.

- : get-field-permission/L _ (set`size/+ set`size/0)
    (same-class/+ same-class/0 B-L set`shift/0 ) CM-CM CM2PM
    CM-L FM-L (set+nat2efxmap/+ set+nat2efxmap/0) %{=>}%
    _ ([r] set2facts/U set`not-member/0 set`update/0 B-L set2facts/0)
    _ T2PF
    _ (efxmap2perm/U efxmap`fresh/0 efxmap`update/0 B-L CM-L
      (inner-efxmap2perm/U
        inner-efxmap`fresh/0 inner-efxmap`update/0
        FM-L T2PF apply-efx/read inner-efxmap2perm/0) efxmap2perm/0)
    ([f][r] implies/trans
      (implies/combine
        (implies/nonlinear
          (bimplies/trans
            (bimplies/neg
              (bimplies/trans
                (bimplies/conj/XX
                  (bimplies/reflexive)
                  (bimplies/rem-negneg))
                (bimplies/conj-true))
              (bool`ne/FT))
            (bimplies/trans
              (bimplies/rem-negneg)
              (bimplies/objequal-symmetric))))
        (implies/trans
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/equiv
              (equiv/transitive
                (equiv/identity)
                (equiv/identity)))
            (implies/trans
              (implies/self-implication)
              (implies/equiv-encumbered
                (equiv/transitive
                  (equiv/identity)
                  (equiv/identity))
                (equiv/reflexive))))))
      (implies/objequal
        ([o] (scale f (fldperm-fun o F ([v] PF v))) ,
          (unitperm
            (encumbered (scale f (fldperm-fun o F ([v] PF v)))
              (combine
                (combine (scale f (fldperm-fun R F ([v] PF v)))
                  empty) empty))))))
    <- lookup-implies-clsmap-fldmap CM-CM CM-L CM-FM
    <- lookup-implies-clsmap-ty CM-FM FM-L CM-T
    <- clsmap-ty-implies-ty2perm CM2PM CM-T _ T2PF.

- : get-field-permission/L (s N) (set`size/+ SZ-S)
    (same-class/+ SOC-SS B-L SL<<S=SS) CM-CM CM2PM
    CM-L FM-L (set+nat2efxmap/+ S1+FX=XM1) %{=>}%
    _ ([r] set2facts/U N!<SS SS+N=S B-L (SS=>GS r)) _ T2PF
    _ (efxmap2perm/U N!<XMS XMS+N=XM B-L CM-L
      (inner-efxmap2perm/U
        inner-efxmap`fresh/0 inner-efxmap`update/0
        FM-L T2PF apply-efx/read inner-efxmap2perm/0)
      XMS=>PiS)
    ([z][r] implies/trans7
      (implies/equiv equiv/commute)
      (implies/combine
        (implies/combine
          (implies/equiv equiv/identity)
          (implies/reflexive))
        (implies/disj2cond))
      (implies/cond-push)
      (implies/cond-gen-inner)
      (implies/cond-inner
        (bimplies/reflexive)
        (bimplies/reflexive)
        (implies/trans6
          (implies/combine
            (implies/reflexive)
            (implies/equiv equiv/identity))
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/trans
              (implies/combine
                (implies/nonlinear bimplies/objequal-symmetric)
                (implies/trans
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/self-implication))))
              (implies/objequal
                ([o] (scale z (fldperm-fun o F ([v] PF v))) ,
                  (unitperm
                    (encumbered (scale z (fldperm-fun o F ([v] PF v)))
                      (scale z (fldperm-fun R F ([v] PF v))))))))
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine
                (implies/reflexive)
                (implies/trans3
                  (implies/self-implication)
                  (implies/equiv-encumbered
                    (equiv/commute)
                    (equiv/combine
                      (equiv/symmetric equiv/identity)
                      (equiv/reflexive)))
                  (implies/combine-assoc-encumbered)))
              (implies/linear-modus-ponens)))
          (implies/equiv (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/chain-implication))
          (implies/equiv (equiv/symmetric equiv/identity)))
        (implies/trans2
          (implies/combine
            (implies/reflexive)
            (implies/trans3
              (implies/equiv
                (equiv/transitive
                  (equiv/symmetric equiv/associate)
                  (equiv/combine
                    (equiv/reflexive)
                    (equiv/commute))))
              (implies/combine
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans3
                      (implies/self-implication)
                      (implies/equiv-encumbered
                        (equiv/reflexive)
                        (equiv/combine
                          (equiv/symmetric equiv/identity)
                          (equiv/reflexive)))
                      (implies/combine-assoc-encumbered)))
                  (implies/linear-modus-ponens))
                (implies/trans
                  (IMP z r)
                  (implies/equiv (equiv/symmetric equiv/identity))))
              (implies/trans
                (implies/equiv
                  (equiv/associate))
                (implies/combine
                  (implies/trans
                    (implies/equiv
                      (equiv/transitive
                        (equiv/commute)
                        (equiv/symmetric equiv/associate)))
                    (implies/combine
                      (implies/reflexive)
                      (implies/chain-implication)))
                  (implies/reflexive)))))
          (implies/equiv
            (equiv/transitive
              (equiv/commute)
              (equiv/symmetric equiv/associate)))))
      (implies/cond-pull)
      (implies/trans
        (implies/combine
          (implies/reflexive)
          (implies/trans
            (implies/cond-inner
              (bimplies/reflexive)
              (bimplies/reflexive)
              (implies/reflexive)
              (implies/trans
                (implies/combine
                  (implies/reflexive)
                  (implies/trans
                    (implies/nonlinear
                      (bimplies/tt))
                    (implies/true2empty)))
                (implies/equiv equiv/identity)))
            (implies/cond-equal)))
        (implies/equiv equiv/identity)))
    <- set`shift-preserves-size SZ-S SL<<S=SS SZ-SS
    <- efxmap`shift-total SL<<XM=XMS
    <- shift-preserves-set+nat2efxmap
      S1+FX=XM1 SL<<S=SS SL<<XM=XMS SS+FX=XMS
    <- get-field-permission/L N SZ-SS SOC-SS CM-CM CM2PM CM-L
      FM-L SS+FX=XMS %{=>}% _ SS=>GS _ T2PF _ XMS=>PiS ([z][r] IMP z r)
    <- set`shift-implies-not-member SL<<S=SS N!<SS
    <- set`shift-implies-update SL<<S=SS SS+N=S
    <- efxmap`shift-implies-fresh SL<<XM=XMS N!<XMS
    <- efxmap`shift-implies-update SL<<XM=XMS XMS+N=XM.

%worlds (objvar) (get-field-permission/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (N) (get-field-permission/L N _ _ _ _ _ _ _ _ _ _ _ _ _ _).


% a version in which we use set+nat2tgtmap instead.

%theorem get-field-permission
  : forall* {PM} {CM} {FM} {GM} {XM} {S} {B} {C} {F} {NN} {A} {FC}
    forall {K} {SZ: set`size S (s K)}
    {SC: same-class B S C} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>GM: set+nat2tgtmap S F GM}
    {GM=>XM: tgtmap2efxmap GM efx/read XM}
    exists {G} {S=>G: {r} set2facts B r S (G r)}
    {PF} {T2PF: ty2perm PM (ty/ NN A FC) PF}
    {Pi} {XM=>Pi: efxmap2perm true CM PM B XM Pi}
    {IMP: {f}{r} implies
          ((unitperm (nonlinear (G r))) , (Pi f))
          ((scale f (unitperm (precise-exists r F ([v] PF v)))) ,
            (unitperm
              (encumbered
                (scale f (unitperm (precise-exists r F ([v] PF v))))
                (Pi f))))}
    true.

- : get-field-permission K SZ SC CM-CM CM2PM CM-L FM-L S+F=>GM GM=>XM
    _ S=>G _ T2PF _ XM=>Pi IMP
    <- set+nat2tgtmap-implies-set+nat2efxmap S+F=>GM GM=>XM S+F=>XM
    <- get-field-permission/L K SZ SC CM-CM CM2PM CM-L FM-L S+F=>XM
    _ S=>G _ T2PF _ XM=>Pi IMP.

%worlds () (get-field-permission _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (get-field-permission _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem get-field-permission*
  : forall* {PM} {CM} {FM} {XM} {S} {B} {C} {F}
    {NN} {A} {FC} {G} {Pi} {GM}
    forall {K} {SZ: set`size S (s K)}
    {SC: same-class B S C} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>XM: set+nat2tgtmap S F GM}
    {GM=>XM: tgtmap2efxmap GM efx/read XM}
    {S=>G: {r} set2facts B r S (G r)}
    {XM=>Pi: efxmap2perm true CM PM B XM Pi}
    exists {PF} {T2PF: ty2perm PM (ty/ NN A FC) PF}
    {IMP: {f}{r} implies
          ((unitperm (nonlinear (G r))) , (Pi f))
          ((scale f (unitperm (precise-exists r F ([v] PF v)))) ,
            (unitperm
              (encumbered
                (scale f (unitperm (precise-exists r F ([v] PF v))))
                (Pi f))))}
    true.

- : get-field-permission* _ SZ SC CM-CM CM2PM CM-L FM-L
    S+F=>GM GM=>XM S=>GF XM=>Pi _ T2PF
    ([f][r] implies/trans3
      (implies/equiv
        (equiv/combine (EQV2 r) (EQV3 f)))
      (IMP' f r)
      (implies/combine
        (implies/reflexive)
        (implies/equiv-encumbered
          (equiv/reflexive)
          (equiv/symmetric (EQV3 f)))))
    <- get-field-permission _ SZ SC CM-CM CM2PM CM-L FM-L
      S+F=>GM GM=>XM _ S=>GF' _ T2PF _ XM=>Pi' IMP'
    <- ({r} set2facts-equiv (S=>GF r) (S=>GF' r)
         cxt`eq/ object`eq/ set`eq/ (EQV2 r))
    <- efxmap2perm-equiv XM=>Pi XM=>Pi' bool`eq/ clsmap`eq/
      predmap`eq/ cxt`eq/ efxmap`eq/ ([f] EQV3 f).

%worlds () (get-field-permission* _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (get-field-permission* _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem get-field-permission2
  : forall* {PM} {CM} {FM} {XM} {S} {B} {C} {F}
    {NN} {A} {FC} {G} {Pi} {GM} {PF}
    forall {K} {SZ: set`size S (s K)}
    {SC: same-class B S C} {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>XM: set+nat2tgtmap S F GM}
    {GM=>XM: tgtmap2efxmap GM efx/read XM}
    {S=>G: {r} set2facts B r S (G r)}
    {XM=>Pi: efxmap2perm true CM PM B XM Pi}
    {T2PF: ty2perm PM (ty/ NN A FC) PF}
    exists {IMP: {f}{r} implies
          ((unitperm (nonlinear (G r))) , (Pi f))
          ((scale f (unitperm (precise-exists r F ([v] PF v)))) ,
            (unitperm
              (encumbered
                (scale f (unitperm (precise-exists r F ([v] PF v))))
                (Pi f))))}
    true.

%theorem get-field-permission2/eq
  : forall* {Pi1} {Pi2} {F}
    forall {E: {x} permission`eq (Pi1 x) (Pi2 x)}
    exists {EQV: {f}{r} equiv
                 (scale f (unitperm (precise-exists r F Pi2)))
                 (scale f (unitperm (precise-exists r F Pi1)))}
    true.

- : get-field-permission2/eq ([_] permission`eq/) ([f][r] equiv/reflexive).

%worlds () (get-field-permission2/eq _ _).
%total {} (get-field-permission2/eq _ _).


- : get-field-permission2 _ SZ SC CM-CM CM2PM CM-L FM-L
    S+F=>GM GM=>XM S=>GF XM=>Pi T2PF
    ([f][r] implies/trans4
      (implies/equiv
        (equiv/combine (EQV1 r) (EQV2 f)))
      (IMP' f r)
      (implies/combine
        (implies/reflexive)
        (implies/equiv-encumbered
          (equiv/reflexive)
          (equiv/symmetric (EQV2 f))))
      (implies/combine
        (implies/equiv (EQV3 f r))
        (implies/equiv-encumbered
          (EQV3 f r)
          (equiv/reflexive))))
    <- get-field-permission _ SZ SC CM-CM CM2PM CM-L FM-L
      S+F=>GM GM=>XM _ S=>GF' _ T2PF' _ XM=>Pi' IMP'
    <- ({r} set2facts-equiv (S=>GF r) (S=>GF' r)
         cxt`eq/ object`eq/ set`eq/ (EQV1 r))
    <- efxmap2perm-equiv XM=>Pi XM=>Pi' bool`eq/ clsmap`eq/
      predmap`eq/ cxt`eq/ efxmap`eq/ ([f] EQV2 f)
    <- ty2perm-deterministic T2PF T2PF' predmap`eq/ ty`eq/ ([x] EQ x)
    <- get-field-permission2/eq EQ EQV3.

%worlds () (get-field-permission2 _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (get-field-permission2 _ _ _ _ _ _ _ _ _ _ _ _ _).


%{
How to prove this? First we need to show that XM2 is
less than or equal to XM2P, therefore we can get back the
permission for reading field F. For this we need the following
theorem:

  if we have:
    S + F => GM
    GM    => XM2
    XM2   <= XM
    XM/GM == XM1 , XM2P
    --------------------
  then we can get:
    XM2   <= XM2P
    DM(XM2) = DM(XM2P)

The immediate result of this is we can convert XM2P to two
sets of permissions, say Pi1 and Pi2, and Pi1 is the permissions
generated from XM2.

Since we have permission Pi1, as well as the object equal relations,
we can get the field permission, and thus this theorem can be done.

One problem is XM1 \join XM2 = XM, here it's possible that XM1 overlaps
with XM2, and thus if XM2 => GM2, and XM / GM2 = XM1P + XM2P,
XM1P will be less than XM1.

}%

%theorem reftyping-ok/before-read/unique/L1
  : forall* {CM} {PM} {B} {S} {F} {GM2} {XM1} {XM2} {XM}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {S+F=>GM2: set+nat2tgtmap S F GM2}
    {GM2=>XM2: tgtmap2efxmap GM2 efx/read XM2}
    {WF-XM1: efxmap`wf XM1} {J: efxmap`join XM1 XM2 XM}
    {CM-B-XM: clsmap-cxt-efxmap CM B XM}
    exists {XM1P} {XM2P}
    {R: efxmap`remove-tgtmap XM GM2 XM1P XM2P}
    {CM-B-XM2P: clsmap-cxt-efxmap CM B XM2P}
    {XM2<=XM2P: efxmap`leq XM2 XM2P}
    {NC-XM2P: efxmap`no-consume XM2P}
    {Pi2} {XM2=>Pi2: efxmap2perm true CM PM B XM2 Pi2}
    {Pi1P} {XM1P=>Pi1P: efxmap2perm false CM PM B XM1P Pi1P}
    true.

- : reftyping-ok/before-read/unique/L1 CM-CM CM2PM
    S+F=>GM2 GM2=>XM2 WF-XM1 XM1+XM2=XM CM-B-XM _ _
    XM/GM2=XM1P+XM2P CM-B-XM2P XM2<=XM2P NC-XM2P _ T+XM2=>Pi2 _ F+XM1P=>Pi1P
    <- set+nat2tgtmap-implies-wf S+F=>GM2 WF-GM2
    <- tgtmap2efxmap-preserves-wf WF-GM2 GM2=>XM2 WF-XM2
    <- efxmap`join-preserves-wf WF-XM1 WF-XM2 XM1+XM2=XM WF-XM
    <- tgtmap2efxmap-implies-efxmap2tgtmap GM2=>XM2 XM2=>GM2
    <- efxmap`join-implies-leq XM1+XM2=XM XM1<=XM XM2<=XM
    <- set+nat2tgtmap-no-consume S+F=>GM2 GM2=>XM2 efx`not-consume/read NC-XM2
    <- efxmap`remove-tgtmap-total WF-XM WF-GM2 XM1P XM2P XM/GM2=XM1P+XM2P
    <- efxmap`remove-tgtmap-implies-leq XM/GM2=XM1P+XM2P XM1P<=XM XM2P<=XM
    <- leq-preserves-clsmap-cxt-efxmap CM-B-XM XM2<=XM CM-B-XM2
    <- leq-preserves-clsmap-cxt-efxmap CM-B-XM XM2P<=XM CM-B-XM2P
    <- leq-preserves-clsmap-cxt-efxmap CM-B-XM XM1P<=XM CM-B-XM1P
    <- efxmap`join-no-consume-right WF-XM1 WF-XM2 XM2=>GM2 NC-XM2 XM1+XM2=XM
      (XM/GM2=XM1P+XM2P:efxmap`remove-tgtmap XM GM2 XM1P XM2P) NC-XM2P
    <- efxmap`remove-tgtmap-leq-implies-leq
      WF-XM WF-GM2 XM/GM2=XM1P+XM2P GM2=>XM2 XM2<=XM XM2<=XM2P
    <- clsmap-cxt-efxmap-implies-efxmap2perm CM-CM CM2PM CM-B-XM2 Pi2 T+XM2=>Pi2
    <- clsmap-cxt-efxmap-implies-efxmap2perm CM-CM CM2PM CM-B-XM1P Pi1P F+XM1P=>Pi1P.

%worlds () (reftyping-ok/before-read/unique/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {} (reftyping-ok/before-read/unique/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem reftyping-ok/before-read/unique/L2
  : forall* {Pi2} {Pi2P} {Pi3P} {G} {PF}
    forall {EQV: {f} equiv (Pi2P f) (Pi2 f , (Pi3P f))}
    {IMP: {f:fraction}{x:object} implies (combine (G x) (Pi2 f))
          (combine (PF f x) (unitperm (encumbered (PF f x) (Pi2 f))))}
    exists {IMP': {f}{x} implies (combine (G x) (Pi2P f))
                  (combine (PF f x) (unitperm (encumbered (PF f x) (Pi2P f))))}
    true.

- : reftyping-ok/before-read/unique/L2
    ([f] EQV f) ([f][x] IMP f x)
    ([f][x] implies/trans4
      (implies/equiv
        (equiv/transitive
          (equiv/combine (equiv/reflexive) (EQV f))
          (equiv/associate)))
      (implies/combine
        (IMP f x)
        (implies/trans3
          (implies/equiv (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/reflexive)
            (implies/trans3
              (implies/self-implication)
              (implies/equiv-encumbered
                (equiv/reflexive)
                (equiv/transitive
                  (equiv/commute)
                  (equiv/symmetric (EQV f))))
              (implies/combine-assoc-encumbered)))
          (implies/linear-modus-ponens)))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/chain-implication))).

%worlds () (reftyping-ok/before-read/unique/L2 _ _ _).
%total {} (reftyping-ok/before-read/unique/L2 _ _ _).


%theorem reftyping-ok/before-read/unique/0f
  : forall* {B} {CM} {PM} {FM} {C} {XM1} {XM2} {XM} {MX1} {MX2} {MX}
    {F} {NN} {A} {FC} {S} {GM2} {Out} {K}
    forall {W: efxmap`wf XM1}
    {B-XM: clsmap-cxt-efxmap CM B XM}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>GM2: set+nat2tgtmap S F GM2}
    {GM2=>XM2: tgtmap2efxmap GM2 efx/read XM2} % change efx/read to X later
    {XM1+XM2=XM: efxmap`join XM1 XM2 XM}
    {MX1+MX2=MX: maybe-efx`join MX1 MX2 MX}
    {XM=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique S tgtmap/0 false))
              (effects/ XM MX) Out}
    {SC: same-class B S C} % this should be guaranteed
    {SZ: set`size S (s K)}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi3} {MX=>Pi3: maybe-efx2perm MX Pi3}
    {XM1P} {XM2P} {XM/GM2=XM1+XM2P: efxmap`remove-tgtmap XM GM2 XM1P XM2P}
    {Pi1} {XM1P=>Pi1: efxmap2perm false CM PM B XM1P Pi1}
    {Pi2} {XM2P=>Pi2: efxmap2perm false CM PM B XM2P Pi2}
    {TRANS: {f} transform (Out f)
            (output/exists [r]
              (output/expr r
                (combine (ffperm f r F TF)
                  (combine
                    (unitperm
                      (encumbered
                        (ffperm f r F TF) (Pi2 f)))
                    (combine (Pi1 f) (Pi3 f))))))}
    true.

- : reftyping-ok/before-read/unique/0f
    WF-XM1 CM-B-XM CM-CM CM2PM CM-L FM-L
    S+F=>GM2 GM2=>XM2 XM1+XM2=XM MX1+MX2=MX
    (effects2output/unique/0f
      tgtmap`size/0 F+XM=>Pi S=>GF MX=>Pi3 _)
    B-S-C SZ-S %{=>}% _ T2PF _ MX=>Pi3
    _ _ XM/GM2=XM1P+XM2P _ F+XM1P=>Pi1P _ F+XM2P=>Pi2P
    ([f] transform/inside [r]
      (transform/trans
        (transform/drop)
        (transform/implies
          (implies/trans3
            (implies/equiv
              (equiv/transitive
                (equiv/combine
                  (equiv/reflexive) % GF
                  (equiv/transitive
                    (equiv/combine
                      (equiv/transitive
                        (Pi<=>Pi1P+Pi2P f)
                        (equiv/commute))
                      (equiv/reflexive))
                    (equiv/symmetric equiv/associate)))
                (equiv/associate)))
            (implies/combine
              (IMP2 f r) (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))))))
    <- reftyping-ok/before-read/unique/L1 CM-CM CM2PM
      S+F=>GM2 GM2=>XM2 WF-XM1 XM1+XM2=XM CM-B-XM _ _
      XM/GM2=XM1P+XM2P CM-B-XM2P XM2<=XM2P NC-XM2P _ T+XM2=>Pi2 _ F+XM1P=>Pi1P
    <- efxmap`leq-implies-permission-leq CM-CM CM2PM CM-B-XM2P T+XM2=>Pi2
      XM2<=XM2P Pi2P Pi3P T+XM2P=>Pi2P ([f] EQV f)
    <- get-field-permission* _ SZ-S B-S-C CM-CM CM2PM CM-L FM-L
      S+F=>GM2 GM2=>XM2 S=>GF T+XM2=>Pi2 _ T2PF ([f][r] IMP f r)
    <- efxmap`no-consume-same-permission NC-XM2P T+XM2P=>Pi2P F+XM2P=>Pi2P
    <- efxmap`remove-tgtmap-implies-permission-combine
      XM/GM2=XM1P+XM2P F+XM=>Pi F+XM1P=>Pi1P F+XM2P=>Pi2P Pi<=>Pi1P+Pi2P
    <- reftyping-ok/before-read/unique/L2 EQV IMP IMP2.

%worlds ()
(reftyping-ok/before-read/unique/0f
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(reftyping-ok/before-read/unique/0f
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%abbrev nonnull-unique-perm : object -> clspred -> permission
    = [x][p] (combine (unitperm (nonlinear (neg (objequal x null))))
               (combine (allperm x)
                 (one-predcall p x))).

%theorem reftyping-ok/before-read/unique/0t/L
  : forall* {Pi1} {Pi2} {PF} {CP}
    forall {IMP2: {x:object} implies (one-predcall CP x)
                  (unitperm (nonlinear (nested (PF x) x all)))}
    exists {IMP3: {f}{x} implies
                  (combine (scale f (nonnull-unique-perm x CP))
                    (combine (unitperm
                               (encumbered
                                 (scale f (nonnull-unique-perm x CP)) (Pi1 f)))
                      (Pi2 f)))
                  (combine (scale f (PF x))
                    (unitperm (encumbered (scale f (PF x)) ((Pi2 f) , Pi1 f))))}
    true.

- : reftyping-ok/before-read/unique/0t/L
    ([x] IMP2 x)
    ([f][x] implies/trans7
      (implies/combine
        (implies/trans6
          (implies/equiv
            (equiv/symmetric equiv/identity))
          (implies/combine
            (implies/trans4
              (implies/equiv
                (equiv/distribute))
              (implies/equiv
                (equiv/combine
                  (equiv/reflexive)
                  (equiv/distribute)))
              (implies/combine
                (implies/reflexive)
                (implies/trans
                  (implies/combine
                    (implies/reflexive)
                    (implies/trans
                      (implies/scale implies/duplicate)
                      (implies/equiv equiv/distribute)))
                  (implies/equiv equiv/associate)))
              (implies/equiv equiv/commute))
            (implies/trans3
              (implies/self-implication)
              (implies/equiv-encumbered
                (equiv/transitive3
                  (equiv/distribute)
                  (equiv/combine
                    (equiv/reflexive)
                    (equiv/distribute))
                  (equiv/combine
                    (equiv/reflexive)
                    (equiv/commute)))
                (equiv/reflexive))
              (implies/combine-assoc-encumbered)))
          (implies/equiv
            (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/trans
              (implies/linear-modus-ponens)
              (implies/combine-assoc-encumbered)))
          (implies/equiv
            (equiv/symmetric equiv/associate))
          (implies/combine
            (implies/reflexive)
            (implies/linear-modus-ponens)))
        (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/chain-implication)
            (implies/reflexive))))
      (implies/combine
        (implies/trans6
          (implies/equiv equiv/commute)
          (implies/combine
            (implies/scale (IMP2 x))
            (implies/reflexive))
          (implies/equiv (equiv/symmetric equiv/distribute))
          (implies/scale implies/carve)
          (implies/equiv equiv/distribute)
          (implies/combine
            (implies/reflexive)
            (implies/scale-distribute-encumbered)))
        (implies/reflexive))
      (implies/equiv (equiv/symmetric equiv/associate))
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/equiv equiv/associate)
          (implies/combine
            (implies/chain-implication)
            (implies/reflexive))))
      (implies/combine
        (implies/reflexive)
        (implies/trans
          (implies/combine
            (implies/reflexive)
            (implies/trans3
              (implies/equiv (equiv/symmetric equiv/identity))
              (implies/combine
                (implies/reflexive)
                (implies/trans
                  (implies/self-implication)
                  (implies/combine-assoc-encumbered)))
              (implies/linear-modus-ponens)))
          (implies/chain-implication)))).

%worlds () (reftyping-ok/before-read/unique/0t/L _ _).
%total {} (reftyping-ok/before-read/unique/0t/L _ _).


%theorem reftyping-ok/before-read/unique/0t
  : forall* {B} {CM} {PM} {FM} {C} {XM1} {XM2} {XM} {MX1} {MX2} {MX}
    {F} {NN} {A} {FC} {S} {GM2} {Out}
    forall {W: efxmap`wf XM1}
    {B-XM: clsmap-cxt-efxmap CM B XM}
    {CM-CM: clsmap-clsmap CM CM}
    {CM2PM: clsmap2predmap CM PM}
    {CM-L: clsmap`lookup CM C FM}
    {FM-L: fldmap`lookup FM F (ty/ NN A FC)}
    {S=>GM2: set+nat2tgtmap S F GM2}
    {GM2=>XM2: tgtmap2efxmap GM2 efx/read XM2} % change efx/read to X later
    {XM1+XM2=XM: efxmap`join XM1 XM2 XM}
    {MX1+MX2=MX: maybe-efx`join MX1 MX2 MX}
    {XM=>Out: effects2output CM PM B
              (reftype/ nn/yes C (targets/unique S tgtmap/0 true))
              (effects/ XM MX) Out}
    exists {TF} {T2TF: ty2perm PM (ty/ NN A FC) TF}
    {Pi3} {MX=>Pi3: maybe-efx2perm MX Pi3}
    {XM1P} {XM2P} {XM/GM2=XM1+XM2P: efxmap`remove-tgtmap XM GM2 XM1P XM2P}
    {Pi1} {XM1P=>Pi1: efxmap2perm false CM PM B XM1P Pi1}
    {Pi2} {XM2P=>Pi2: efxmap2perm false CM PM B XM2P Pi2}
    {TRANS: {f} transform (Out f)
            (output/exists [r]
              (output/expr r
                (combine (ffperm f r F TF)
                  (combine
                    (unitperm
                      (encumbered
                        (ffperm f r F TF) ((Pi2 f) , (Pi3 f))))
                    (Pi1 f)))))}
    true.

- : reftyping-ok/before-read/unique/0t
    WF-XM1 CM-B-XM CM-CM CM2PM CM-L FM-L
     S+F=>GM2 GM2=>XM2 XM1+XM2=XM MX1+MX2=MX
    (effects2output/unique/0t
      tgtmap`size/0 F+XM=>Pi _ MX=>Pi3
      (ty2perm/ PM-L nn2perm/yes annot2perm/unique))
  %{=>}% _ (ty2perm/ PM-FL NN2PF A2AF) _ MX=>Pi3
    _ _ XM/GM2=XM1P+XM2P _ F+XM1P=>Pi1P _ F+XM2P=>Pi2P
    ([f] transform/trans3
      (transform/inside [o]
        (transform/inside [r]
          (transform/drop)))
      (transform/rem-unused)
      (transform/inside [r]
        (transform/implies
          (implies/trans4
            (implies/combine
              (implies/reflexive)
              (implies/trans
                (implies/combine
                  (implies/reflexive)
                  (implies/equiv
                    (equiv/transitive
                      (Pi<=>Pi1P+Pi2P f)
                      (equiv/commute))))
                (implies/equiv equiv/associate)))
            (implies/equiv equiv/associate)
            (implies/combine
              (IMP4 f r)
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))))))
    <- reftyping-ok/before-read/unique/L1 CM-CM CM2PM
      S+F=>GM2 GM2=>XM2 WF-XM1 XM1+XM2=XM CM-B-XM _ _
      XM/GM2=XM1P+XM2P CM-B-XM2P XM2<=XM2P NC-XM2P Pi2 T+XM2=>Pi2 Pi1P F+XM1P=>Pi1P
    <- efxmap`leq-implies-permission-leq CM-CM CM2PM CM-B-XM2P T+XM2=>Pi2
      XM2<=XM2P Pi2P Pi3P T+XM2P=>Pi2P ([f] EQV f)
    <- fldperm-can-lookup CM2PM PM-L CM-L FM-L _ _ _ A2AF NN2PF PM-FL IMP2
    <- efxmap`no-consume-same-permission NC-XM2P T+XM2P=>Pi2P F+XM2P=>Pi2P
    <- efxmap`remove-tgtmap-implies-permission-combine
      XM/GM2=XM1P+XM2P F+XM=>Pi F+XM1P=>Pi1P F+XM2P=>Pi2P Pi<=>Pi1P+Pi2P
    <- reftyping-ok/before-read/unique/0t/L IMP2 IMP4.

%worlds ()
(reftyping-ok/before-read/unique/0t
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total {}
(reftyping-ok/before-read/unique/0t
  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).