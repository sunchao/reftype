%%% Theorems about conversion

%theorem reftyping-ok
  : forall* {CM} {PM} {MM} {W} {K} {E: term K} {R: result K} {V} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-V: clsmap-cxt-env CM B V}
    {RTYP: reftyping CM MM B V E R}
    exists {PiB} {Pi} {Out}
    {B=>PiB: cxt2perm PM B PiB}
    {XX2I: env2input CM PM B V Pi}
    {XX2O: result2output CM PM B R Out}
    {TYP: typing W (PiB , Pi) E Out}
    true.

%theorem reftyping-ok/args
  : forall* {CM} {PM} {MM} {B} {V} {A} {MT} {AR} {W}
    forall {Pi0} {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-V: clsmap-cxt-env CM B V}
    {RTYP: argsRefTyping CM MM B V A MT AR}
    exists {PiB} {Pi} {Out}
    {B=>PiB: cxt2perm PM B PiB}
    {V=>Pi: env2input CM PM B V Pi}
    {TYP: typing W (Pi0 , (PiB , Pi)) A Out}
    {R=>Out: result2output* CM PM B Pi0 AR Out}
    true.

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ _))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1) (sub-annot/fresh _))
      (ATYP:argsRefTyping CM MM B _ A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/equiv
                    (equiv/transitive3
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/combine
                            (equiv/transitive
                              (equiv/combine (PiB0<=>PiB1 o r p)
                                (equiv/combine equiv/reflexive (PiV1<=>PiV11 o r p)))
                              (equiv/reorder))
                            (equiv/symmetric equiv/identity))
                          (equiv/swap)))
                      (equiv/commute)
                      (equiv/swap))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 capset2perm/0) RT=>PiT  AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0) V1=>PiV1
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-B-U1 CM-B-M1))
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , empty)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U1 CM-B-M1) ATYP _
         _ _ (B=>PiB1 x o p) (V1=>PiV11 x o p) (TYP-A x o p) (AR=>AOut x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- ({x}{o}{p} env2input-unique V1=>PiV1 (V1=>PiV11 x o p) env`eq/ (PiV1<=>PiV11 x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ (env/ U1 M1)))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/borrow (S+FS=>MF:set+set2set S FS MF)
          (M1-MF=M2:set`split M1 MF M2)))
      (ATYP:argsRefTyping CM MM B (env/ U1 M2) A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine
                        (implies/combine (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/equiv (PiU1<=>PiU1P o r p))
                              (implies/equiv
                                (equiv/transitive
                                  (PiM1<=>PiMF+PiM2)
                                  (equiv/combine equiv/reflexive (PiM2<=>PiM2P o r p)))))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive5
                        (equiv/combine equiv/reflexive
                          (equiv/transitive
                            (equiv/identity)
                            (equiv/reorder)))
                        (equiv/associate)
                        (equiv/combine equiv/reflexive
                          (equiv/roll3))
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive3
                            (equiv/combine equiv/reflexive
                              (equiv/transitive (equiv/symmetric equiv/identity) equiv/commute))
                            (equiv/symmetric equiv/associate)
                            (equiv/commute))
                          (equiv/reflexive))))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 MF=>PiMF) RT=>PiT AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0)
        (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-U1 CM-M1))
    <- set`split-implies-leq M1-MF=M2 MF<=M1 M2<=M1
    <- clsmap-cxt-capset-respects-geq CM-M1 M2<=M1 CM-M2
    <- set`split-implies-permission-combine M1-MF=M2 M1=>PiM1
      PiMF PiM2 MF=>PiMF M2=>PiM2 PiM1<=>PiMF+PiM2
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , PiMF)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U1 CM-M2) ATYP _
         _ _ (B=>PiB1 x o p) (env2input/ (U1=>PiU1P x o p) (M2=>PiM2P x o p))
         (TYP-A x o p) (AR=>AOut x o p))
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} capset2perm-equiv M2=>PiM2 (M2=>PiM2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiM2<=>PiM2P x o p))
    <- ({x}{o}{p} make-encumbered-equiv U1=>PiU1 (U1=>PiU1P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiU1<=>PiU1P x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ (env/ U1 M1)))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/unique CML DM-FM=FS (S+FS=>MF:set+set2set S FS MF)
          (M1-MF=M2:set`split M1 MF M2) (S<=U1:set`leq S U1)
          (U1-S=U2: set`remove U1 S U2) _))
      (ATYP:argsRefTyping CM MM B (env/ U2 M2) A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans
                    (implies/combine
                      (implies/reflexive)
                      (implies/combine
                        (implies/combine (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/combine
                              (implies/equiv
                                (equiv/transitive
                                  PiU1<=>PiS+PiU2
                                  (equiv/combine equiv/reflexive (PiU2<=>PiU2P o r p))))
                              (implies/equiv
                                (equiv/transitive
                                  (PiM1<=>PiMF+PiM2)
                                  (equiv/combine equiv/reflexive (PiM2<=>PiM2P o r p)))))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive4
                        (equiv/combine equiv/reflexive
                          (equiv/transitive
                            (equiv/combine
                              (equiv/transitive
                                (equiv/combine (equiv/reflexive) % PiB1
                                  (equiv/transitive
                                    (equiv/combine (equiv/reflexive) % Pif
                                      (equiv/swap-middle))
                                    (equiv/associate)))
                                (equiv/reorder))
                              (equiv/reflexive))
                            (equiv/commute)))
                        (equiv/associate)
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive
                            (equiv/combine (equiv/identity) equiv/reflexive)
                            (equiv/commute))
                          (equiv/reflexive))))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ S=>PiS MF=>PiMF) RT=>PiT AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0)
        (env2input/ (U1=>PiU1:make-encumbered CM PM B U1 PiU1)
          (M1=>PiM1:capset2perm CM PM B M1 PiM1))
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-U1 CM-M1))
    <- set`remove-implies-leq U1-S=U2 U2<=U1
    <- clsmap-cxt-objset-respects-geq CM-U1 U2<=U1 CM-U2
    <- set`split-implies-leq M1-MF=M2 MF<=M1 M2<=M1
    <- clsmap-cxt-capset-respects-geq CM-M1 M2<=M1 CM-M2
    <- make-encumbered-intro S<=U1 U1-S=U2 U1=>PiU1 PiS PiU2 S=>PiS U2=>PiU2 PiU1<=>PiS+PiU2
    <- set`split-implies-permission-combine M1-MF=M2 M1=>PiM1
      PiMF PiM2 MF=>PiMF M2=>PiM2 PiM1<=>PiMF+PiM2
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (PiS , PiMF)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U2 CM-M2) ATYP _
         _ _ (B=>PiB1 x o p) (env2input/ (U2=>PiU2P x o p) (M2=>PiM2P x o p))
         (TYP-A x o p) (AR=>AOut x o p))
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} capset2perm-equiv M2=>PiM2 (M2=>PiM2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
      set`eq/ (PiM2<=>PiM2P x o p))
    <- ({x}{o}{p} make-encumbered-equiv U2=>PiU2 (U2=>PiU2P x o p) clsmap`eq/ predmap`eq/ cxt`eq/
         set`eq/ (PiU2<=>PiU2P x o p)).

- : reftyping-ok/args Pi0 CM-CM (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W (CM-B:clsmap-cxt CM B)
    (CM-B-V0:clsmap-cxt-env CM B V0)
    (argsRefTyping/+ (RTYP:reftyping CM MM B V0 E (result/expr _ _))
      (subtype/ (NN-LEQ:nonnull`leq NN2 NN1)
        (sub-annot/shared))
      (ATYP:argsRefTyping CM MM B _ A MT AR))
    PiB PiV0 _ B=>PiB V0=>PiV0
    (tArgs1
      (TYP-E')
      (letTyping/exists [o]
        (letTyping/exists [r]
          (letTyping/exists [p]
            (letTyping/base o
              (tTrans
                (transform/implies
                  (implies/trans3
                    (implies/combine implies/reflexive
                      (implies/combine
                        (implies/combine
                          (implies/equiv (PiB0<=>PiB1 o r p))
                          (implies/combine implies/reflexive
                            (implies/equiv (PiV1<=>PiV11 o r p))))
                        (implies/reflexive)))
                    (implies/equiv
                      (equiv/transitive3
                        (equiv/combine equiv/reflexive
                          (equiv/transitive3
                            (equiv/combine (equiv/roll2) equiv/reflexive)
                            (equiv/commute)
                            (equiv/associate)))
                        (equiv/associate)
                        (equiv/combine
                          (equiv/transitive
                            (equiv/commute)
                            (equiv/combine equiv/commute equiv/reflexive))
                          (equiv/reflexive))))
                    (implies/combine
                      (implies/combine
                        (implies/combine implies/reflexive
                          (implies/equiv (equiv/symmetric equiv/identity)))
                        (implies/reflexive))
                      (implies/reflexive))))
                (letTyping/base null (tArgs (TYP-A o r p)))
                (transform/reflexive)))))))
    (result2output/args/+ (env2input/ make-encumbered/0 capset2perm/0) RT=>PiT  AR=>AOut)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-V0 RTYP _ PiV0 _
      B=>PiB V0=>PiV0
      (result2output/expr (B=>PiB0:cxt2perm PM B PiB0) V1=>PiV1
        (RT=>PiT:reftype2perm CM PM B _ ([x][o][p] PF x o p))) TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-B-V0 RTYP
      (clsmap-result/expr _ (clsmap-cxt-env/ CM-B-U1 CM-B-M1))
    <- ({x}{o}{p} reftyping-ok/args (((PF x o p) , (empty , empty)) , Pi0)
         CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U1 CM-B-M1) ATYP _
         _ _ (B=>PiB1 x o p) (V1=>PiV11 x o p) (TYP-A x o p) (AR=>AOut x o p))
    <- typing-frame* TYP-E
      (envadd/exists [_] (envadd/exists [_] (envadd/exists [_] envadd/expr))) TYP-E'
    <- ({x}{o}{p} cxt2perm-equiv B=>PiB0 (B=>PiB1 x o p)
         predmap`eq/ cxt`eq/ (PiB0<=>PiB1 x o p))
    <- ({x}{o}{p} env2input-unique V1=>PiV1 (V1=>PiV11 x o p) env`eq/ (PiV1<=>PiV11 x o p)).

- : reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-B-V
    (argsRefTyping/0) _ _ _ B=>PiB V=>Pi
    (tTrans2 tArgs0
      (transform/args/0
        (implies/reflexive)))
    (result2output/args/0 B=>PiB V=>Pi)
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B _ B=>PiB
    <- clsmap-cxt-env-implies-env2input CM-CM CM2PM CM-B-V _ V=>Pi.


%theorem reftyping-ok/expr/write
  : forall* {CM} {MM} {PM} {W} {F} {E2} {G} {T} {Out1} {Rslt1} {Rslt2} {B}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-Rslt: clsmap-result CM B Rslt1}
    {Rslt1=>Out1: result2output CM PM B Rslt1 Out1}
    {RTYP-H: writeRefTyping CM MM B Rslt1 F E2 G T Rslt2}
    exists {Out1'} {Out2} {Out2'}
    {Out1=>Out1': transform Out1 Out1'}
    {Rslt2=>Out2: result2output CM PM B Rslt2 Out2}
    {TYP: letTyping W Out1' ([O] write (lit O) F E2) Out2'}
    {Out2'=>Out2: transform Out2' Out2}
    true.

%theorem reftyping-ok/expr/write/L2
  : forall* {CM} {NN1} {G1} {U1} {M2} {NN} {N1} {A} {FS} {X8} {U2} {M3} {FM} {FC}
    forall {CML: clsmap`lookup CM FC FM}
    {DM: fldmap`domain FM FS}
    {SUB:subtype CM FS (reftype/ NN1 N1 G1) (env/ U1 M2) (ty/ NN A FC) X8 (env/ U2 M3)}
    exists {CML: clsmap`lookup CM N1 FM}
    true.

%worlds (gtermvar) (reftyping-ok/expr/write/L2 _ _ _ _).
%trustme %total { } (reftyping-ok/expr/write/L2 _ _ _ _).


- : reftyping-ok/expr/write CM-CM CM-MM CM2PM MM2W CM-B CM-R1 R1=>Out1
    (writeRefTyping/base (CML:clsmap`lookup CM C FM) FML
      (MG:make-tgts-and-caps M0 G0 F (targets/unique set/0 M _) M1)
      (RTYP-E2:reftyping CM MM B (env/ U0 M1) E2 (result/expr _ (env/ U1 M2)))
      (SUB:subtype _ _ _ (env/ U1 M2) (ty/ NN A FC) _ (env/ U2 M3))
      (CF:consider-ftype _ M3 A G2 M4)) _ _ _
    (transform/trans
      (TRANS-1)
      (transform/inside [x]
        (transform/inside [p:permission]
          (transform/implies
            (implies/trans
              (implies/equiv
                (equiv/transitive
                  (equiv/combine (PiU0'<=>PiU0) equiv/reflexive)
                  (equiv/roll2)))
              (implies/combine (implies/equiv (PiB'<=>PiB)) implies/reflexive))))))
    R3=>Out3
    (letTyping/exists [x] (letTyping/exists [p] (letTyping/base x (TYP x p))))
    (transform/trans transform/rem-unused (transform/rem-unused))
    <- make-tgts-and-caps-consistent/1 CM-CM CML FML CM-R1 MG (clsmap-cxt-env/ _ CM-B-M1)
    <- clsmap-result/expr-inversion CM-R1 _ (clsmap-cxt-env/ CM-B-U0 _)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-B-U0 CM-B-M1) RTYP-E2
      PiB _ Out2 B=>PiB (env2input/ (U0=>PiU0: make-encumbered CM PM B U0 PiU0)
                          (M1=>Pi2:capset2perm CM PM B M1 Pi2)) R2=>Out2 TYP-E2
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B
      (clsmap-cxt-env/ CM-B-U0 CM-B-M1) RTYP-E2 CM-R2
    <- before-read CM-CM CM2PM CML FML R1=>Out1 MG CM-R1
      PiB' _ Pi2' PiU0' _ T2PF B=>PiB' U0=>PiU0' R-FMT TRANS-1
    <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
    <- lookup-implies-not-borrow CM-FM FML NB
    <- make-before-write-format CM2PM CM-R2 SUB NB R2=>Out2 _ TRANS-2 BW-FMT
    <- do-write M1=>Pi2 R-FMT SUB T2PF
      (tTrans2 TYP-E2 TRANS-2) BW-FMT CF _ TYP R3=>Out3
    <- make-encumbered-equiv U0=>PiU0' U0=>PiU0
      clsmap`eq/ predmap`eq/ cxt`eq/ set`eq/ PiU0'<=>PiU0
    <- cxt2perm-equiv B=>PiB' B=>PiB predmap`eq/ cxt`eq/ PiB'<=>PiB.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _)))
      ty2reftype/unique) _ _ _
    (B=>PiB)
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM)
      (reftype2perm/borrow (set`size/+ set`size/0) set`size/0
        T2PF ([_] (set2cond/U set2cond/0 set`update/0 set`not-member/0 BL))))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans5
            (implies/combine
              (implies/trans5
                (implies/equiv PiB<=>PiF+PiBP)
                (implies/combine (DUP O) implies/reflexive)
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric PiB<=>PiF+PiBP)))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/equiv equiv/commute)
                  (implies/combine (gen-objequal-self-cond _) implies/reflexive))))
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive
                (implies/equiv equiv/associate))
              (implies/reflexive))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _ (ty2perm2/unique T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-borrow T2PF DUP.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit
      (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _))) ty2reftype/borrow) _ _ _
    B=>PiB
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM)
      (reftype2perm/borrow (set`size/+ set`size/0) set`size/0
        T2PF ([_] (set2cond/U set2cond/0 set`update/0 set`not-member/0 BL))))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans5
            (implies/combine
              (implies/trans5
                (implies/equiv PiB<=>PiF+PiBP)
                (implies/combine (DUP O) implies/reflexive)
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric PiB<=>PiF+PiBP)))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/combine implies/reflexive
              (implies/combine implies/reflexive
                (implies/trans3
                  (implies/equiv (equiv/symmetric equiv/identity))
                  (implies/equiv equiv/commute)
                  (implies/combine (gen-objequal-self-cond _) implies/reflexive))))
            (implies/equiv (equiv/symmetric equiv/identity))
            (implies/combine
              (implies/combine implies/reflexive
                (implies/equiv equiv/associate))
              (implies/reflexive))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _
      (ty2perm2/borrow T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-borrow T2PF DUP.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B (clsmap-cxt-env/ CM-U CM-M)
    (reftyping/lit
      (cxt`lookup-obj/ (BL:cxt`lookup B (s N) (cxt-info/ O _)))
      ty2reftype/shared) _ _ _
    B=>PiB
    (env2input/ U=>PiU M=>PiM)
    (result2output/expr B=>PiB (env2input/ U=>PiU M=>PiM) (reftype2perm/shared T2PF))
    (tTrans2
      (tObjLoc)
      (transform/trans3
        (transform/implies
          (implies/trans3
            (implies/combine
              (implies/trans5
                (implies/equiv (PiB<=>PiF+PiBP))
                (implies/combine (DUP O) (implies/reflexive))
                (implies/equiv (equiv/symmetric equiv/associate))
                (implies/combine implies/reflexive
                  (implies/equiv (equiv/symmetric (PiB<=>PiF+PiBP))))
                (implies/equiv equiv/commute))
              (implies/reflexive))
            (implies/equiv (equiv/symmetric equiv/associate))
            (implies/equiv (equiv/symmetric equiv/identity))))
        (transform/add-unused)
        (transform/trans
          (transform/gen-exists _)
          (transform/inside [_] (transform/inside [_] transform/add-unused)))))
    <- clsmap-cxt-implies-cxt2perm CM-CM CM2PM CM-B PiB B=>PiB
    <- clsmap-cxt-objset-implies-make-encumbered CM-CM CM2PM CM-U PiU U=>PiU
    <- clsmap-cxt-capset-implies-capset2perm CM-CM CM2PM CM-M PiM M=>PiM
    <- cxt`lookup-implies-fresh-update BL BP BF BU
    <- cxt2perm/U-inversion B=>PiB BF BU PiBP BP=>PiBP _
      (ty2perm2/shared T2PF) PiB<=>PiF+PiBP
    <- can-duplicate-shared T2PF DUP.

- : reftyping-ok (CM-CM:clsmap-clsmap CM CM) CM-MM
    CM2PM MM2W CM-B CM-V (reftyping/read RTYP-E RTYP-HELPER) PiB Pi Out B=>PiB V=>Pi R2=>Out2
    (tTrans2 (tRead1 (tTrans2 (TYP-E) (TRANS)) LTYP) TRANS2)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V RTYP-E _ _ _ B=>PiB V=>Pi R=>Out TYP-E
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-E CM-R
    <- reftyping-ok/read CM-CM CM2PM CM-R R=>Out RTYP-HELPER _ _ _
      TRANS R2=>Out2 LTYP TRANS2.

- : reftyping-ok
    (CM-CM:clsmap-clsmap CM CM) (CM-MM:clsmap-methmap CM MM)
    (CM2PM:clsmap2predmap CM PM) MM2W
    (CM-B0:clsmap-cxt CM B0) (CM-V0: clsmap-cxt-env CM B0 V0)
    (reftyping/let
      (RTYP-E0:reftyping CM MM B0 V0 E0 (result/expr (reftype/ NN C targets/shared) V1))
      (letRefTyping/base/shared (CML:clsmap`lookup CM C FM)
        (N!<B0:cxt`fresh B0 (s N))
        ([x] (B0+N=B1:{x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) x)
        ([x] (RTYP-E1: {x} reftyping CM MM (B1 x) V1 (F x)
                       (result/expr (reftype/ NN1 C1 G1) V2)) x)
        N!<G1))
    PiB0 Pi0 Out1 B0=>PiB0 V0=>Pi R1=>Out1
    (tTrans2
      (tLet
        (tTrans2
          (TYP-E0)
          (TRANS))
        (letTyping/exists [x]
          (letTyping/exists [o]
            (letTyping/exists [p]
              (letTyping/base x
                (tTrans
                  (transform/implies
                    (implies/combine
                      (implies/equiv (PiB1<=>PiB1' x))
                      (implies/equiv (Pi<=>Pi' x))))
                  (letTyping/base null (TYP-E1 x))
                  (transform/reflexive)))))))
      (TRANS2))
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B0 CM-V0 RTYP-E0 CM-R0
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0 RTYP-E0
      _ _ _ B0=>PiB0 V0=>Pi R0=>Out0 TYP-E0
    <- letRefTyping-helper/base/shared/before N!<B0 B0+N=B1
      CM-B0 CM-R0 R0=>Out0 PiB1 Pi1 CM-B1 CM-V1 V1=>Pi1 B1=>PiB1 TRANS
    <-({x} reftyping-ok CM-CM CM-MM CM2PM MM2W (CM-B1 x) (CM-V1 x)
        (RTYP-E1 x) _ _ _ (B1=>PiB1' x) (V1=>Pi1' x) (R1=>Out1' x) (TYP-E1 x))
    <- ({x} reftyping-implies-clsmap-result CM-CM CM-MM (CM-B1 x) (CM-V1 x) (RTYP-E1 x) (CM-R1 x))
    <- letRefTyping-helper/base/shared/after _ N!<G1 N!<B0 B0+N=B1
      ([x] CM-R1 x) ([x] R1=>Out1' x) _ R1=>Out1 TRANS2
    <- ({x} cxt2perm-equiv (B1=>PiB1 x) (B1=>PiB1' x) predmap`eq/
         cxt`eq/ (PiB1<=>PiB1' x))
    <- ({x} env2input-unique (V1=>Pi1 x) (V1=>Pi1' x) env`eq/ (Pi<=>Pi' x)).

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0
    (reftyping/let RTYP-E0
      (letRefTyping/base/unique
        CML DM-FM=FS S+FS=M2 N!<B0 B0+N=B1
        SP N!<U1 U1+N=U2 M0-M2=M4 N+FS=M3
        M5-M3=M4 ([x] RTYP-E1 x) N!<G1 M6-M3=M7 M8-M2=M7 M9-M1=M8
        N!<U4 U4+N=U3 U4+S=U5)) PiB0 Pi0 Out3 B0=>PiB0 V0=>Pi R1=>Out1
    (tTrans2
      (tLet
        (tTrans2
          (TYP-E0)
          (TRANS))
        (letTyping/exists [x]
          (letTyping/exists [o]
            (letTyping/exists [p]
              (letTyping/base x
                (tTrans
                  (transform/implies
                    (implies/combine implies/reflexive
                      (implies/combine
                        (implies/equiv (PiB1<=>PiB1' x))
                        (implies/equiv (Pi<=>Pi' x)))))
                  (letTyping/base null (TYP-E1' x o p))
                  (transform/reflexive)))))))
      (TRANS2))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B0 CM-V0 RTYP-E0
      PiB0 Pi0 Out0 B0=>PiB0 V0=>Pi R0=>Out0 TYP-E0
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B0 CM-V0 RTYP-E0 CM-R0
    <- set`split-implies-leq-remove SP S<=U0 U0-S=U1
    <- letRefTyping-helper/base/unique CM-CM CM2PM CM-B0 CML DM-FM=FS
      S+FS=M2 N!<B0 B0+N=B1 S<=U0 U0-S=U1 U1+N=U2 M0-M2=M4 N+FS=M3
      M5-M3=M4 CM-R0 R0=>Out0 ([x] Pi1 x) ([x] Pi2 x) ([x] PiB1 x)
      CM-B1 CM-V1 V1=>Pi B1=>PiB1 EC-FMT TRANS
    <-({x} reftyping-ok CM-CM CM-MM CM2PM MM2W (CM-B1 x) (CM-V1 x)
        (RTYP-E1 x) (PiB1' x) (Pi1' x) (Out1' x)
        (B1=>PiB1' x) (V1=>Pi' x) (R1=>Out1' x) (TYP-E1 x))
    <- ({x} cxt2perm-equiv (B1=>PiB1 x) (B1=>PiB1' x) predmap`eq/
         cxt`eq/ (PiB1<=>PiB1' x))
    <- letRefTyping-helper/base/unique/L6 G1 N!<G1 N!<B0 B0+N=B1
      CML DM-FM=FS N+FS=M3 EC-FMT R1=>Out1' M6-M3=M7 M8-M2=M7 M9-M1=M8
      N!<U4 U4+N=U3 U4+S=U5 ([x] Out1 x) Out3 EA R1=>Out1 TRANS2
    <- ({x}{o}{p} typing-frame* (TYP-E1 x) (EA x o p) (TYP-E1' x o p))
    <- ({x} env2input-unique (V1=>Pi x) (V1=>Pi' x) env`eq/ (Pi<=>Pi' x)).


%%% IDEA:
%%% After checking E1, we get a permission output like the following:
%%%  (PiB , (PiF , PiF --|- Pi2 , Pi3))
%%% We then can combine PiB and Pi3 to check E2
%%% Then, subtype ensures that we have enough permission to be consumed,
%%% we can then check the "write".

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/write RTYP-E1 RTYP-E2) PiB Pi _ B=>PiB V=>Pi R3=>Out3
    (tTrans2 (tWrite1 (tTrans2 (TYP-E1) (TRANS1)) (LTYP)) (TRANS2))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W
      CM-B CM-V RTYP-E1 PiB Pi Out1 B=>PiB V=>Pi R1=>Out1 TYP-E1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V RTYP-E1 CM-R1
    <- reftyping-ok/expr/write CM-CM CM-MM CM2PM MM2W
      CM-B CM-R1 R1=>Out1 RTYP-E2 _ _ _ TRANS1 R3=>Out3 LTYP TRANS2.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/call FS MML ARTYP CRTYP) _ _ _ B=>PiB V=>PiV R=>O
    (tTrans2
      (tCall WL
        (tTrans
          (transform/implies
            (implies/equiv
              (equiv/transitive
                (equiv/symmetric equiv/identity)
                (equiv/commute))))
          (letTyping/base null ATYP)
          (TRANS1))
        CTYP)
      (TRANS2))
    <- methmap`lookup-implies-fresh-update MML _ MM-FS MM-UD
    <- methmap2progtype/U/m-inversion MM2W FS MM-FS MM-UD _ _ _ MT=>PT W-UD
    <- progtype`update-implies-lookup W-UD WL
    <- reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-V ARTYP
      _ _ _ B=>PiB V=>PiV ATYP AR=>AO
    <- reftyping-ok/call CM-CM CM-MM CM-B CM2PM MM2W CM-V ARTYP AR=>AO MT=>PT
      CRTYP _ _ _ TRANS1 CTYP TRANS2 R=>O.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V
    (reftyping/const CML DM MML ARTYP CRTYP) _ _ _ B=>PiB V=>PiV R=>O
    (tTrans2
      (tCall WL
        (tTrans2
          (tArgs1
            (tTrans2
              (tAlloc ([t] AF t))
              (transform/inside [t]
                (transform/implies
                  (implies/equiv
                    (equiv/transitive
                      (equiv/commute)
                      (equiv/combine equiv/reflexive
                        (equiv/transitive
                          (equiv/symmetric equiv/identity)
                          (equiv/commute))))))))
            (letTyping/exists [t] (letTyping/base t (tArgs (ATYP2 t)))))
          (transform/inside [t] (transform/args/+ (TRANS1 t))))
        (callTyping/exists [t] (callTyping/arg t (CTYP t))))
      (transform/trans
        (transform/inside [t] (TRANS2 t))
        (transform/rem-unused)))
    <- methmap`lookup-implies-fresh-update MML _ MM-FS MM-UD
    <- methmap2progtype/U/c-inversion MM2W CML MM-FS MM-UD _ _ _ CT=>PT W-UD
    <- progtype`update-implies-lookup W-UD WL
    <- reftyping-ok/args _ CM-CM CM-MM CM2PM MM2W CM-B CM-V ARTYP
      _ _ _ B=>PiB V=>PiV ATYP AR=>AO
    <- allocFields-total _ AF
    <- reftyping-ok/const CM-CM CM-MM CM-B CM2PM MM2W CM-V
      ARTYP AR=>AO CT=>PT CRTYP DM AF _ _ _ _ EA TRANS1 CTYP TRANS2 R=>O
    <- ({t} typing-frame* ATYP (EA t) (ATYP2 t)).

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/eq RTYP1 RTYP2 RCT1 RCT2) _ _ _ B=>PiB V0=>PiV0 R=>O TYP
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP1
      PiB _ _ B=>PiB V0=>PiV0 R1=>O1 TYP1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP1
      (clsmap-result/expr CM-B-RT1 CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP2
      PiB' _ _ B=>PiB' V1=>PiV1 R2=>O2 TYP2
    <- cxt2perm-equiv B=>PiB B=>PiB' predmap`eq/ cxt`eq/ PiB<=>PiB'
    <- reftyping-ok/eq CM-CM CM2PM B=>PiB V0=>PiV0 TYP1 R1=>O1
      (tTrans
        (transform/implies
          (implies/combine (implies/equiv (PiB<=>PiB')) implies/reflexive))
        (letTyping/base null (TYP2))
        (transform/reflexive))
      V1=>PiV1
      R2=>O2 RCT1 RCT2 _ TYP R=>O.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/not RTYP) _ _ _ B=>PiB V0=>PiV0 R=>O' (tNot TYP NV)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP
      _ _ _ B=>PiB V0=>PiV0 R=>O TYP
    <- reftyping-ok/not/L R=>O _ NV R=>O'.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/and RTYP-C1 RTYP-C2) _ _ _ B=>PiB V0=>PiV0 R=>O
    (tTrans2
      (tAnd TYP-C1 AND-HELP-C2)
      (TRANS))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP-C1
      PiB _ _ B=>PiB V0=>PiV0 R1=>O1 TYP-C1
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP-C1 (clsmap-result/cond CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-C2
      PiB' _ _ B=>PiB' V1=>PiV1 R2=>O2 TYP-C2
    <- reftyping-ok/and B=>PiB' V1=>PiV1 R1=>O1 R2=>O2 TYP-C2 _ _ AND-HELP-C2 TRANS R=>O.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/sub RTYP SUB (clsmap-result/expr CM-RT1 CM-V2)) PiB _ _ B=>PiB V0=>PiV0
    (result2output/expr (B=>PiB':cxt2perm PM B PiB') V2=>PiV2 RT1=>PF1)
    (tTrans2 TYP0
      (transform/trans3
        (transform/inside [_]
          (transform/inside [_]
            (transform/inside [_]
              (transform/implies (implies/equiv equiv/identity)))))
      (TRANS)
        (transform/inside [_]
          (transform/inside [_]
            (transform/inside [_]
              (transform/implies (implies/equiv (equiv/symmetric equiv/identity))))))))
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0
      RTYP (clsmap-result/expr CM-RT0 CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP _ _ _ B=>PiB V0=>PiV0
      (result2output/expr B=>PiB' V1=>PiV1 RT0=>PF0) TYP0
    <- reftype-sub-transform _ CM-CM CM2PM B=>PiB' CM-RT0 CM-RT1 SUB RT0=>PF0 V1=>PiV1
      _ _ RT1=>PF1 V2=>PiV2 TRANS.

- : reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0
    (reftyping/if RTYP-C RTYP-E1 RTYP-E2) _ _ _ B=>PiB V0=>PiV0 R1=>O1
    (tTrans2
      (tIf
        (TYP-C)
        (IF-TYP))
      (TRANS))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V0 RTYP-C
      PiB _ _ B=>PiB V0=>PiV0 R0=>O0 TYP-C
    <- reftyping-implies-clsmap-result CM-CM CM-MM CM-B CM-V0 RTYP-C (clsmap-result/cond CM-V1)
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-E1
      PiB1 PiV1 _ B=>PiB1 V1=>PiV1 R1=>O1 TYP-E1
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-V1 RTYP-E2
      PiB2 PiV1' _ B=>PiB2 V1=>PiV1' R2=>O2 TYP-E2
    <- result2output/expr-trans R1=>O1 R2=>O2 result`eq/ TRANS0 TRANS1
    <- cxt2perm-equiv B=>PiB1 B=>PiB2 predmap`eq/ cxt`eq/ PiB1<=>PiB2
    <- env2input-unique V1=>PiV1 V1=>PiV1' env`eq/ PiV1<=>PiV1'
    <- reftyping-ok/if B=>PiB1 V1=>PiV1 R0=>O0 TYP-E1
      (tTrans
        (transform/implies
          (implies/equiv
            (equiv/combine PiB1<=>PiB2 PiV1<=>PiV1')))
        (letTyping/base null TYP-E2)
        (TRANS1))
      _ IF-TYP TRANS.

%worlds (gtermvar) (reftyping-ok _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(reftyping-ok/expr/write _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(reftyping-ok/args _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

%total (T WT AT) (reftyping-ok _ _ _ _ _ _ T _ _ _ _ _ _ _)
(reftyping-ok/expr/write _ _ _ _ _ _ _ WT _ _ _ _ _ _ _)
(reftyping-ok/args _ _ _ _ _ _ _ AT _ _ _ _ _ _ _).


%%% Theorems about matching methmap with proctype

%theorem methtymatch-implies-proctypematch*/L1
  : forall* {CM} {PM} {B} {T} {RT} {PF}
    forall {T=>RT: ty2new-reftype T RT}
    {RT=>PF: reftype2perm CM PM B RT ([o][r][p] PF o r p)}
    exists {PF'} {T=>PF': ty2perm PM T ([x] PF' x)}
    {EQ: {o}{r}{p} permission`eq (PF o r p) (PF' o)}
    true.

- : methtymatch-implies-proctypematch*/L1
    ty2new-reftype/unique (reftype2perm/fresh T2PF) _ T2PF ([_][_][_] permission`eq/).

- : methtymatch-implies-proctypematch*/L1
    ty2new-reftype/shared (reftype2perm/shared T2PF) _ T2PF ([_][_][_] permission`eq/).

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L1 _ _ _ _ _).
%total { } (methtymatch-implies-proctypematch*/L1 _ _ _ _ _).


%theorem methtymatch-implies-proctypematch*/L2
  : forall* {CM} {B} {M0} {N} {FS} {M1}
    forall {CM-B-OS: clsmap-cxt-capset CM B M0}
    {N!<B: cxt`fresh B (s N)}
    {N+FS=>M1: nat+set2set (s N) FS M1}
    exists {DJ: set`disjoint M0 M1}
    true.

%theorem methtymatch-implies-proctypematch*/L2L
  : forall* {N} {FS} {M}
    forall {N+FS=>M: nat+set2set (s N) FS M}
    exists {NM: set`not-member M z}
    true.

%theorem methtymatch-implies-proctypematch*/L2L/L
  : forall* {N} {FS} {M}
    forall {N+FS=>M: nat+set2set (s N) FS M}
    {B} {MB?: set`member? M z B}
    exists {NM: set`not-member M z}
    true.

- : methtymatch-implies-proctypematch*/L2L/L N+FS=>M true (set`member?/in Z<-M) NM
    <- set`lookup-implies-not-member-update Z<-M M' Z!<M' M'+Z=M
    <- nat+set2set/UP-inversion N+FS=>M Z!<M' M'+Z=M FSP _ _ N+F=Z _
    <- nat2pair-deterministic/0 N+F=Z PE
    <- pair-eq-implies-eq PE EQ' _
    <- nat`eq-symmetric EQ' EQ
    <- nat`eq-contradiction EQ V
    <- set`false-implies-not-member V NM.

- : methtymatch-implies-proctypematch*/L2L/L _ false (set`member?/out NM) NM.

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L2L/L _ _ _ _).
%total { } (methtymatch-implies-proctypematch*/L2L/L _ _ _ _).

- : methtymatch-implies-proctypematch*/L2L N+FS=>M NM
    <- set`member?-total MB?
    <- methtymatch-implies-proctypematch*/L2L/L N+FS=>M _ MB? NM.

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L2L _ _).
%total { } (methtymatch-implies-proctypematch*/L2L _ _).


- : methtymatch-implies-proctypematch*/L2 clsmap-cxt-capset/0 _ _ set`disjoint/L.

- : methtymatch-implies-proctypematch*/L2 _ _ nat+set2set/0 set`disjoint/R.

- : methtymatch-implies-proctypematch*/L2 (clsmap-cxt-capset/z CM-B-M0P Z!<M0P M0P+Z=M0)
    N!<B N+FS=>M1 M0^M1
    <- methtymatch-implies-proctypematch*/L2 CM-B-M0P N!<B N+FS=>M1 M0P^M1
    <- methtymatch-implies-proctypematch*/L2L N+FS=>M1 Z!<M1
    <- set`disjoint-symmetric M0P^M1 M1^M0P
    <- set`not-member-add-preserves-disjoint M1^M0P Z!<M1 M0P+Z=M0 M1^M0
    <- set`disjoint-symmetric M1^M0 M0^M1.

- : methtymatch-implies-proctypematch*/L2
    (clsmap-cxt-capset/U CM-B-M0P N+F=K BL _ CML FML K!<M0P M0P+K=M0)
    N!<B N+FS=>M1 M0^M1
    <- cxt`fresh-lookup-not-equal N!<B BL (NE:nat`ne (s N) N0)
    <- nat+set2set-nat-ne-implies-disjoint/L N+FS=>M1 NE N+F=K K!<M1
    <- methtymatch-implies-proctypematch*/L2 CM-B-M0P N!<B N+FS=>M1 M0P^M1
    <- set`disjoint-symmetric M0P^M1 M1^M0P
    <- set`not-member-add-preserves-disjoint M1^M0P K!<M1 M0P+K=M0 M1^M0
    <- set`disjoint-symmetric M1^M0 M0^M1.

%worlds (gtermvar) (methtymatch-implies-proctypematch*/L2 _ _ _ _).
%total (A) (methtymatch-implies-proctypematch*/L2 A _ _ _).


%%% Here Piin should be PiB + PiVin, and Piout should be PiB + PiVout
%theorem methtymatch-implies-proctypematch*
  : forall* {CM} {MM} {PM} {B} {W} {MT} {F} {Vin} {Vout}
    {PT} {PiB} {Piin} {Piout} {PiVin} {PiVout}
    forall {CM-CM: clsmap-clsmap CM CM}
    {CM-MM: clsmap-methmap CM MM}
    {CM2PM: clsmap2predmap CM PM}
    {MM2W: methmap2progtype CM PM MM W}
    {CM-B: clsmap-cxt CM B}
    {CM-B-Vin: clsmap-cxt-env CM B Vin}
    {CM-B-Vout: clsmap-cxt-env CM B Vout}
    {B=>PiB: cxt2perm PM B PiB}
    {Vin=>Piin: env2input CM PM B Vin PiVin}
    {Vout=>Piout: env2input CM PM B Vout PiVout}
    {IMP: implies Piin (PiB , PiVin)}
    {IMP: implies (PiB , PiVout) Piout}
    {CM-MT: clsmap-methty CM MT}
    {MC: methtymatch* Vin Vout CM MM B F MT}
    {MT=>PT: methty2proctype* CM PM Piin Piout MT PT}
    exists {PC: proctypematch W F PT}
    true.

- : methtymatch-implies-proctypematch*
    CM-CM CM-MM CM2PM MM2W CM-B CM-B-Vin CM-B-Vout
    (B=>PiB:cxt2perm PM B PiB)
    (Vin=>PiVin:env2input CM PM B Vin PiVin)
    (Vout=>PiVout:env2input CM PM B Vout PiVout)
    IMP0 IMP1
    (clsmap-methty/base CM-T)
    (methtymatch/base T=>RT RTYP)
    (methty2proctype/base (T2PF:ty2perm PM T PF))
    (proctypematch/base
      (tTrans
        (transform/implies
          (implies/trans IMP0
            (implies/equiv (equiv/combine PiB<=>PiB' PiVin<=>PiVin'))))
        (letTyping/base null TYP)
        (transform/inside [o]
          (transform/trans3
            (transform/inside [r]
              (transform/inside [p]
                (transform/implies
                  (implies/trans4
                    (implies/equiv equiv/identity)
                    (implies/combine implies/reflexive
                      (implies/equiv
                        (equiv/combine
                          (equiv/transitive (EQV o r p) (PF'<=>PF o))
                          (PiVout'<=>PiVout))))
                    (implies/equiv equiv/reorder)
                    (implies/combine implies/reflexive
                      (implies/trans
                        (implies/combine (implies/equiv PiB''<=>PiB) implies/reflexive)
                        (IMP1)))))))
            (transform/rem-unused)
            (transform/rem-unused)))))
    <- reftyping-ok CM-CM CM-MM CM2PM MM2W CM-B CM-B-Vin RTYP PiB' PiVin' _ B=>PiB'
      Vin=>PiVin'
      (result2output/expr
        (B=>PiB'':cxt2perm PM B PiB'')
        (Vout=>PiVout':env2input CM PM B Vout PiVout')
        RT=>PF) TYP
    <- env2input-unique Vin=>PiVin Vin=>PiVin' env`eq/ PiVin<=>PiVin'
    <- methtymatch-implies-proctypematch*/L1 T=>RT RT=>PF PF' T2PF' EQ
    <- ({o}{r}{p} permission`eq-implies-equiv (EQ o r p) (EQV o r p))
    <- cxt2perm-equiv B=>PiB B=>PiB' predmap`eq/ cxt`eq/ PiB<=>PiB'
    <- cxt2perm-equiv B=>PiB'' B=>PiB predmap`eq/ cxt`eq/ PiB''<=>PiB
    <- env2input-unique Vout=>PiVout' Vout=>PiVout env`eq/ PiVout'<=>PiVout
    <- ty2perm-deterministic T2PF' T2PF predmap`eq/ ty`eq/ PF'=PF
    <- ({x} permission`eq-implies-equiv (PF'=PF x) (PF'<=>PF x)).

- : methtymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (CM-B0-Vin:clsmap-cxt-env CM B0 Vin)
    (CM-B0-Vout:clsmap-cxt-env CM B0 Vout)
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (B0+Vin=>PiVin:env2input CM PM B0 Vin PiVin)
    (B0+Vout=>PiVout:env2input CM PM B0 Vout PiVout)
    (IMP0:implies Piin (PiB0 , PiVin))
    (IMP1:implies (PiB0 , PiVout) Piout)
    (clsmap-methty/args CM-MT CML DM LE)
    (methtymatch/args/shared N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/shared C)) (B1 x)) x)
      ([x] MC x))
    (methty2proctype/arg
      (argtype2perm/shared T2PF) MT=>PT)
    (proctypematch/arg PC)
    <- cxt`fresh-update-preserves-env2input B0+Vin=>PiVin N!<B0 B0+N=B1 B1+Vin=>PiVin
    <- cxt`fresh-update-preserves-env2input B0+Vout=>PiVout N!<B0 B0+N=B1 B1+Vout=>PiVout
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vin N!<B0 B0+N=B1 CM-B1-Vin
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vout N!<B0 B0+N=B1 CM-B1-Vout
    <- ({x} methtymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (CM-B1-Vin x) (CM-B1-Vout x)
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/shared T2PF))
         (B1+Vin=>PiVin x) (B1+Vout=>PiVout x)
         (implies/trans
           (implies/combine implies/reflexive (IMP0))
           (implies/associate))
         (implies/trans
           (implies/symmetric-associate)
           (implies/combine implies/reflexive IMP1))
         (CM-MT) (MC x) (MT=>PT x)
         (PC x)).

- : methtymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (clsmap-cxt-env/ CM-B0-Uin CM-B0-Min)
    (clsmap-cxt-env/ CM-B0-Uout CM-B0-Mout)
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (env2input/ (B0+Uin=>PiUin:make-encumbered CM PM B0 Uin PiUin)
      (B0+Min=>PiMin:capset2perm CM PM B0 Min PiMin))
    (env2input/ (B0+Uout=>PiUout:make-encumbered CM PM B0 Uout PiUout)
      (B0+Mout=>PiMout:capset2perm CM PM B0 Mout PiMout))
    (IMP0) (IMP1)
    (clsmap-methty/args CM-MT (CML2:clsmap`lookup CM C FM2)
      (DM2:fldmap`domain FM2 FS2) LE2)
    (methtymatch/args/borrow N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/borrow C)) (B1 x)) x)
      (N+FS=>Mf:nat+set2set (s N) FS3 Mf) (Min+Mf=Min':set`union Min Mf Min')
      (Mout+Mf=Mout':set`union Mout Mf Mout')
      ([x] MC x))
    (methty2proctype/arg
      (argtype2perm/borrow (CML:clsmap`lookup CM C FM)
        (DM:fldmap`domain FM FS) LE FS=>PF T2PFB) MT=>PT)
    (proctypematch/arg PC)
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- cxt`fresh-update-preserves-make-encumbered B0+Uin=>PiUin N!<B0 B0+N=B1 B1+Uin=>PiUin
    <- cxt`fresh-update-preserves-capset2perm B0+Min=>PiMin N!<B0 B0+N=B1 B1+Min=>PiMin
    <- cxt`fresh-update-preserves-make-encumbered B0+Uout=>PiUout N!<B0 B0+N=B1 B1+Uout=>PiUout
    <- cxt`fresh-update-preserves-capset2perm B0+Mout=>PiMout N!<B0 B0+N=B1 B1+Mout=>PiMout
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uin N!<B0 B0+N=B1 CM-B1-Uin
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Min N!<B0 B0+N=B1 CM-B1-Min
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uout N!<B0 B0+N=B1 CM-B1-Uout
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Mout N!<B0 B0+N=B1 CM-B1-Mout
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
      %%% FIX HERE
    <- ({x} nat+set2set-implies-clsmap-cxt-capset/L CML DM LE (B1-L x) not-shared/borrow
         N+FS=>Mf (CM-B1-Mf x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Min x) (CM-B1-Mf x) Min+Mf=Min'
         (CM-B1-Min' x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Mout x) (CM-B1-Mf x) Mout+Mf=Mout'
         (CM-B1-Mout' x))
    <- letRefTyping-helper/base/unique/L4L2* CML FS=>PF B1-L N+FS=>Mf _ B1+Mf=>PiMf IMP5 IMP6
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Min N!<B0 N+FS=>Mf Min^Mf
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Mout N!<B0 N+FS=>Mf Mout^Mf
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Min^Mf Min+Mf=Min')
         (B1+Min=>PiMin x) (B1+Mf=>PiMf x) _ (B1+Min'=>PiMin' x) (EQV1 x))
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Mout^Mf Mout+Mf=Mout')
         (B1+Mout=>PiMout x) (B1+Mf=>PiMf x) _ (B1+Mout'=>PiMout' x) (EQV2 x))
    <- not-unique-perm-implies-empty T2PFB not-unique/borrow IMP7
    <- ({x} methtymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (clsmap-cxt-env/ (CM-B1-Uin x) (CM-B1-Min' x))
         (clsmap-cxt-env/ (CM-B1-Uout x) (CM-B1-Mout' x))
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/borrow T2PFB))
         (env2input/ (B1+Uin=>PiUin x) (B1+Min'=>PiMin' x))
         (env2input/ (B1+Uout=>PiUout x) (B1+Mout'=>PiMout' x))
         (implies/trans3
           (implies/combine implies/reflexive (IMP0))
           (implies/equiv equiv/swap-middle)
           (implies/combine implies/reflexive
             (implies/trans3
               (implies/combine (IMP5 x) implies/reflexive)
               (implies/equiv equiv/reorder)
               (implies/combine implies/reflexive
                 (implies/trans implies/commute (implies/equiv (EQV1 x)))))))
         (implies/trans4
           (implies/combine
             (implies/trans
               (implies/combine (IMP7 x) implies/reflexive)
               (implies/commute-identity))
             (implies/trans
               (implies/combine
                 (implies/reflexive)
                 (implies/trans
                   (implies/equiv (equiv/symmetric (EQV2 x)))
                   (implies/combine implies/reflexive (IMP6 x))))
               (implies/associate)))
           (implies/associate)
           (implies/combine (IMP1) implies/reflexive)
           (implies/commute))
         (CM-MT) (MC x) (MT=>PT x)
         (PC x)).

- : methtymatch-implies-proctypematch* CM-CM CM-MM CM2PM MM2W
    (CM-B0:clsmap-cxt CM B0)
    (clsmap-cxt-env/ CM-B0-Uin CM-B0-Min)
    CM-B0-Vout
    (B0=>PiB0:cxt2perm PM B0 PiB0)
    (env2input/ (B0+Uin=>PiUin:make-encumbered CM PM B0 Uin PiUin)
      (B0+Min=>PiMin:capset2perm CM PM B0 Min PiMin))
    (B0+Vout=>PiVout:env2input CM PM B0 Vout PiVout)
    (IMP0)
    (IMP1:implies (PiB0 , PiVout) Piout)
    (clsmap-methty/args CM-MT (CML2:clsmap`lookup CM C FM2)
      (DM2:fldmap`domain FM2 FS2) LE)
    (methtymatch/args/unique N!<B0
      ([x] (B0+N=B1: {x} cxt`update B0 (s N) (cxt-info/ x (ty/ NN annot/unique C)) (B1 x)) x)
      (CML:clsmap`lookup CM C FM) (DM:fldmap`domain FM FS)
      (N+FS=>Mf:nat+set2set (s N) FS Mf) (Uin+N=Uin':set`add Uin (s N) Uin')
      (Min+Mf=Min':set`union Min Mf Min')
      ([x] MC x))
    (methty2proctype/arg
      (argtype2perm/unique T2PF) MT=>PT)
    (proctypematch/arg PC)
    <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
    <- cxt`fresh-update-preserves-make-encumbered B0+Uin=>PiUin N!<B0 B0+N=B1 B1+Uin=>PiUin
    <- cxt`fresh-update-preserves-capset2perm B0+Min=>PiMin N!<B0 B0+N=B1 B1+Min=>PiMin
    <- cxt`fresh-update-preserves-env2input B0+Vout=>PiVout N!<B0 B0+N=B1 B1+Vout=>PiVout
    <- cxt`fresh-update-preserves-clsmap-cxt-objset CM-B0-Uin N!<B0 B0+N=B1 CM-B1-Uin
    <- cxt`fresh-update-preserves-clsmap-cxt-capset CM-B0-Min N!<B0 B0+N=B1 CM-B1-Min
    <- cxt`fresh-update-preserves-clsmap-cxt-env CM-B0-Vout N!<B0 B0+N=B1 CM-B1-Vout
    <- ({x} cxt`update-implies-lookup (B0+N=B1 x) (B1-L x))
    <- cxt`domain-total (DM-B0=BS0:cxt`domain B0 BS0)
    <- clsmap-cxt-objset-implies-domain-leq CM-B0-Uin DM-B0=BS0 Uin<=BS0
    <- cxt`domain-preserves-fresh N!<B0 DM-B0=BS0 N!<BS0
    <- set`not-member-respects-geq N!<BS0 Uin<=BS0 N!<Uin
    <- ({x} nat+set2set-implies-clsmap-cxt-capset CML DM (B1-L x) not-shared/unique
         N+FS=>Mf (CM-B1-Mf x))
    <- ({x} join-preserves-clsmap-cxt-capset (CM-B1-Min x) (CM-B1-Mf x) Min+Mf=Min'
         (CM-B1-Min' x))
    <- letRefTyping-helper/base/unique/L4L1** CM-CM CM2PM CML PML DM T2PF _ _ FS=>PF T2PFB IMP4
    <- letRefTyping-helper/base/unique/L4L2* CML FS=>PF B1-L N+FS=>Mf _ B1+Mf=>PiMf IMP5 _
    <- methtymatch-implies-proctypematch*/L2 CM-B0-Min N!<B0 N+FS=>Mf Min^Mf
    <- ({x} set`split-implies-permission-combine-converse (set`split/ Min^Mf Min+Mf=Min')
         (B1+Min=>PiMin x) (B1+Mf=>PiMf x) _ (B1+Min'=>PiMin' x) (EQV x))
    <- not-unique-perm-implies-empty T2PFB not-unique/borrow IMP7
    <- ({x} methtymatch-implies-proctypematch*
         CM-CM CM-MM CM2PM MM2W
         (clsmap-cxt/U CM-B0 (clsmap-ty/ CML) N!<B0 (B0+N=B1 x))
         (clsmap-cxt-env/
           (clsmap-cxt-objset/U (CM-B1-Uin x) (B1-L x) CML N!<Uin Uin+N=Uin')
           (CM-B1-Min' x))
         (CM-B1-Vout x)
         (cxt2perm/U B0=>PiB0 N!<B0 (B0+N=B1 x) (ty2perm2/unique T2PFB))
         (env2input/
           (make-encumbered/U (B1+Uin=>PiUin x) (B1-L x) CML PML DM
             FS=>PF N!<Uin Uin+N=Uin')
           (B1+Min'=>PiMin' x))
         (B1+Vout=>PiVout x)
         (implies/trans5
           (implies/combine (IMP4 x) (IMP0))
           (implies/equiv equiv/swap-middle)
           (implies/combine
             (implies/equiv equiv/swap) (implies/reflexive))
           (implies/symmetric-associate)
           (implies/combine implies/reflexive
             (implies/trans3
               (implies/combine implies/reflexive implies/reorder)
               (implies/associate)
               (implies/combine implies/reflexive
                 (implies/trans3
                   (implies/commute)
                   (implies/combine implies/reflexive (IMP5 x))
                   (implies/equiv (EQV x)))))))
         (implies/trans
           (implies/symmetric-associate)
           (implies/combine (IMP7 x) (IMP1)))
         (CM-MT) (MC x) (MT=>PT x)
         (PC x)).

%worlds (gtermvar) (methtymatch-implies-proctypematch* _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (M) (methtymatch-implies-proctypematch* _ _ _ _ _ _ _ _ _ _ _ _ _ M _ _).
