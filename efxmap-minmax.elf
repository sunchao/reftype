% Compute minimum effects for this efxmap, start with efx/write.
% Here, efxmap-max-efx is really a copy-and-paste from efxmap-min-efx.

efxmap-min-efx* : efx -> efxmap -> efx -> type.

efxmap-min-efx/0 : efxmap-min-efx* X efxmap/0 X.

efxmap-min-efx/U : efxmap-min-efx* X1 M X4
                <- efxmap`fresh M' N
                <- efxmap`update M' N X2 M
                <- efx`min X1 X2 X3
                <- efxmap-min-efx* X3 M' X4.

%abbrev efxmap-min-efx = [M][X] efxmap-min-efx* efx/write M X.


efxmap-max-efx* : efx -> efxmap -> efx -> type.

efxmap-max-efx/0 : efxmap-max-efx* X efxmap/0 X.

efxmap-max-efx/U : efxmap-max-efx* X1 M X4
                <- efxmap`fresh M' N
                <- efxmap`update M' N X2 M
                <- efx`max X1 X2 X3
                <- efxmap-max-efx* X3 M' X4.

%abbrev efxmap-max-efx = [M][X] efxmap-max-efx* efx/read M X.



%%% 1, theorems about efxmap-min-efx

%theorem efxmap-min-efx-respects-eq
  : forall* {M} {M'} {X1} {X1'} {X2} {X2'}
    forall {MX: efxmap-min-efx* X1 M X2}
    {E: efx`eq X1 X1'} {E: efxmap`eq M M'} {E: efx`eq X2 X2'}
    exists {MX: efxmap-min-efx* X1' M' X2'}
    true.

- : efxmap-min-efx-respects-eq MX efx`eq/ efxmap`eq/ efx`eq/ MX.

%worlds (objvar) (efxmap-min-efx-respects-eq _ _ _ _ _).
%total {} (efxmap-min-efx-respects-eq _ _ _ _ _).


%theorem efxmap-min-efx-total*
  : forall* {M} {X1}
    exists {X2} {MX: efxmap-min-efx* X1 M X2} true.

%theorem efxmap-min-efx-total*/L
  : forall* {M} {X1}
    forall {N} {Z: efxmap`size M N}
    exists {X2} {MX: efxmap-min-efx* X1 M X2} true.

- : efxmap-min-efx-total*/L z _  _ efxmap-min-efx/0.

- : efxmap-min-efx-total*/L (s N) Z _ (efxmap-min-efx/U MX MIN U F)
    <- efxmap`lookup-implies-fresh-update (efxmap`lookup/= nat`eq/) MP F U
    <- efx`min-total MIN
    <- efxmap`fresh-update-increases-size-converse Z F U ZP
    <- efxmap-min-efx-total*/L N ZP _ MX.

%worlds (objvar) (efxmap-min-efx-total*/L _ _ _ _).
%total (N) (efxmap-min-efx-total*/L N _ _ _).

- : efxmap-min-efx-total* _ MX
    <- efxmap`size-total Z
    <- efxmap-min-efx-total*/L _ Z _ MX.

%worlds (objvar) (efxmap-min-efx-total* _ _).
%total {} (efxmap-min-efx-total* _ _).

%abbrev efxmap-min-efx-total = efxmap-min-efx-total* _.


%theorem efxmap-min-efx-unique
  : forall* {M} {M'} {X1} {X1'} {X2} {X2'}
    forall {MX: efxmap-min-efx* X1 M X2}
    {MX': efxmap-min-efx* X1' M' X2'}
    {E: efx`eq X1 X1'} {E: efxmap`eq M M'}
    exists {E: efx`eq X2 X2'}
    true.

- : efxmap-min-efx-unique MX MX efx`eq/ efxmap`eq/ efx`eq/.

%worlds (objvar) (efxmap-min-efx-unique _ _ _ _ _).
%trustme %total {} (efxmap-min-efx-unique _ _ _ _ _).


%theorem set2efxmap-implies-efxmap-min-efx
  : forall* {X} {S} {M}
    forall {N} {SZ: set`size S (s N)} {S+X=>M: set2efxmap S X M}
    exists {MX: efxmap-min-efx M X}
    true.

%worlds () (set2efxmap-implies-efxmap-min-efx _ _ _ _).
%trustme %total { } (set2efxmap-implies-efxmap-min-efx _ _ _ _).

%theorem efxmap-min-efx/U-inversion
  : forall* {M'} {N} {M} {X1} {X2} {X3} {X4}
    forall {MX: efxmap-min-efx* X1 M X4}
    {F: efxmap`fresh M' N}
    {U: efxmap`update M' N X2 M}
    exists {X2} {MX: efx`min X1 X2 X3}
    {MX': efxmap-min-efx* X3 M' X4}
    true.

%worlds (objvar) (efxmap-min-efx/U-inversion _ _ _ _ _ _).
%trustme %total {} (efxmap-min-efx/U-inversion _ _ _ _ _ _).


%theorem efxmap-min-efx-respects-leq
  : forall* {M1} {M2} {X1} {X2}
    forall {M1<=M2: efxmap`leq M1 M2}
    {MX-M1: efxmap-min-efx M1 X1}
    {MX-M2: efxmap-min-efx M2 X2}
    exists {X2<=X1: efx`leq X2 X1}
    true.

%worlds (objvar) (efxmap-min-efx-respects-leq _ _ _ _).
%trustme %total {} (efxmap-min-efx-respects-leq _ _ _ _).


%theorem efxmap-min-efx-respects-leq-domain
  : forall* {M} {M'} {X} {S}
    forall {MX: efxmap-min-efx M X}
    {M<=M': efxmap`leq M M'}
    {DM-M: efxmap`domain M S} {DM-M': efxmap`domain M' S}
    exists {X'} {MX': efxmap-min-efx M' X'}
    {X<=X': efx`leq X X'}
    true.

%worlds () (efxmap-min-efx-respects-leq-domain _ _ _ _ _ _ _).
%trustme %total { } (efxmap-min-efx-respects-leq-domain _ _ _ _ _ _ _).


%theorem efxmap`join-joins-min-efx
  : forall* {M1} {M2} {M} {X1} {X2}
    forall {J: efxmap`join M1 M2 M}
    {MX-M1: efxmap-min-efx M1 X1}
    {MX-M2: efxmap-min-efx M2 X2}
    exists {X} {MX: efx`min X1 X2 X}
    {MX-M: efxmap-min-efx M X}
    true.

%worlds (objvar) (efxmap`join-joins-min-efx _ _ _ _ _ _).
%trustme %total {} (efxmap`join-joins-min-efx _ _ _ _ _ _).


%%% 2, theorems about efxmap-max-efx

%theorem efxmap-max-efx-respects-eq
  : forall* {M} {M'} {X1} {X1'} {X2} {X2'}
    forall {MX: efxmap-max-efx* X1 M X2}
    {E: efx`eq X1 X1'} {E: efxmap`eq M M'} {E: efx`eq X2 X2'}
    exists {MX: efxmap-max-efx* X1' M' X2'}
    true.

- : efxmap-max-efx-respects-eq MX efx`eq/ efxmap`eq/ efx`eq/ MX.

%worlds (objvar) (efxmap-max-efx-respects-eq _ _ _ _ _).
%total {} (efxmap-max-efx-respects-eq _ _ _ _ _).


%theorem efxmap-max-efx-total*
  : forall* {M} {X1}
    exists {X2} {MX: efxmap-max-efx* X1 M X2} true.

%theorem efxmap-max-efx-total*/L
  : forall* {M} {X1}
    forall {N} {Z: efxmap`size M N}
    exists {X2} {MX: efxmap-max-efx* X1 M X2} true.

- : efxmap-max-efx-total*/L z _  _ efxmap-max-efx/0.

- : efxmap-max-efx-total*/L (s N) Z _ (efxmap-max-efx/U MX MAX U F)
    <- efxmap`lookup-implies-fresh-update (efxmap`lookup/= nat`eq/) MP F U
    <- efx`max-total MAX
    <- efxmap`fresh-update-increases-size-converse Z F U ZP
    <- efxmap-max-efx-total*/L N ZP _ MX.

%worlds (objvar) (efxmap-max-efx-total*/L _ _ _ _).
%total (N) (efxmap-max-efx-total*/L N _ _ _).

- : efxmap-max-efx-total* _ MX
    <- efxmap`size-total Z
    <- efxmap-max-efx-total*/L _ Z _ MX.

%worlds (objvar) (efxmap-max-efx-total* _ _).
%total {} (efxmap-max-efx-total* _ _).

%abbrev efxmap-max-efx-total = efxmap-max-efx-total* _.


%theorem efxmap-max-efx-unique
  : forall* {M} {M'} {X1} {X1'} {X2} {X2'}
    forall {MX: efxmap-max-efx* X1 M X2}
    {MX': efxmap-max-efx* X1' M' X2'}
    {E: efx`eq X1 X1'} {E: efxmap`eq M M'}
    exists {E: efx`eq X2 X2'}
    true.

- : efxmap-max-efx-unique MX MX efx`eq/ efxmap`eq/ efx`eq/.

%worlds (objvar) (efxmap-max-efx-unique _ _ _ _ _).
%trustme %total {} (efxmap-max-efx-unique _ _ _ _ _).


%theorem set2efxmap-implies-efxmap-max-efx
  : forall* {X} {S} {M}
    forall {N} {SZ: set`size S (s N)} {S+X=>M: set2efxmap S X M}
    exists {MX: efxmap-max-efx M X}
    true.

%worlds () (set2efxmap-implies-efxmap-max-efx _ _ _ _).
%trustme %total { } (set2efxmap-implies-efxmap-max-efx _ _ _ _).

%theorem efxmap-max-efx/U-inversion
  : forall* {M'} {N} {M} {X1} {X2} {X3} {X4}
    forall {MX: efxmap-max-efx* X1 M X4}
    {F: efxmap`fresh M' N}
    {U: efxmap`update M' N X2 M}
    exists {X2} {MX: efx`max X1 X2 X3}
    {MX': efxmap-max-efx* X3 M' X4}
    true.

%worlds (objvar) (efxmap-max-efx/U-inversion _ _ _ _ _ _).
%trustme %total {} (efxmap-max-efx/U-inversion _ _ _ _ _ _).


%theorem efxmap-max-efx-respects-leq
  : forall* {M1} {M2} {X1} {X2}
    forall {M1<=M2: efxmap`leq M1 M2}
    {MX-M1: efxmap-max-efx M1 X1}
    {MX-M2: efxmap-max-efx M2 X2}
    exists {X2<=X1: efx`leq X1 X2}
    true.

%worlds (objvar) (efxmap-max-efx-respects-leq _ _ _ _).
%trustme %total {} (efxmap-max-efx-respects-leq _ _ _ _).


%theorem efxmap-max-efx-respects-leq-domain
  : forall* {M} {M'} {X} {S}
    forall {MX: efxmap-max-efx M X}
    {M<=M': efxmap`leq M M'}
    {DM-M: efxmap`domain M S} {DM-M': efxmap`domain M' S}
    exists {X'} {MX': efxmap-max-efx M' X'}
    {X<=X': efx`leq X X'}
    true.

%worlds () (efxmap-max-efx-respects-leq-domain _ _ _ _ _ _ _).
%trustme %total { } (efxmap-max-efx-respects-leq-domain _ _ _ _ _ _ _).


%theorem efxmap`join-joins-max-efx
  : forall* {M1} {M2} {M} {X1} {X2}
    forall {J: efxmap`join M1 M2 M}
    {MX-M1: efxmap-max-efx M1 X1}
    {MX-M2: efxmap-max-efx M2 X2}
    exists {X} {MX: efx`max X1 X2 X}
    {MX-M: efxmap-max-efx M X}
    true.

%worlds (objvar) (efxmap`join-joins-max-efx _ _ _ _ _ _).
%trustme %total {} (efxmap`join-joins-max-efx _ _ _ _ _ _).