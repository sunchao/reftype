%%%%%% Sets of natural numbers
%%%%%% John Boyland
%%%%%% You may freely use, modify and distribute this file without restrictions.

%%%%% This file requires the "nat.elf" signature

%{%
 This signature implements sets of natural numbers.
 The representation is "adequate" in that every set
 has a unique representation.  In other words, equality of the terms
 is the same as semantic equality.
%}%

%{%
  This signature was created using "map" and is not "optimally" concise.
  The proofs of the theorems are more general than necessary and
  use many trivial lemmas.
%}%

%{%
  This file follows the same theorem naming convention as nat.elf (q.v.)
%}%


%%%%% set-help.elf
%%%%% Theorems needed to help 'set' use 'map.'
%%%%% This file is part of the set.elf signature



%%%% Theorems


%{%
   What follows is a series of utterly trivial theorems
   about the unit type and trivial operations on it.
   These theorems are needed to satisfy the map "functor".
   All of these definitions are indented one space,
   which signifies to the pre-module module-system
   that they are internal and should not be exported.
%}%


 unit`eq : unit -> unit -> type.

 unit`eq/ : unit`eq unit/ unit/.


 %theorem unit`false-implies-eq :
	forall* {U1} {U2}
	forall {F:void}
	exists {E:unit`eq U1 U2}
	true.

 %worlds () (unit`false-implies-eq _ _).
 %total { } (unit`false-implies-eq _ _).


 %theorem unit`eq-reflexive :
	forall {U}
	exists {E:unit`eq U U}
	true.

 - : unit`eq-reflexive unit/ unit`eq/.

 %worlds () (unit`eq-reflexive _ _).
 %total { } (unit`eq-reflexive _ _).


 %theorem unit`eq-symmetric :
	forall* {U1} {U2}
	forall {E1:unit`eq U1 U2}
	exists {E2:unit`eq U2 U1}
	true.
 
 - : unit`eq-symmetric unit`eq/ unit`eq/.

 %worlds () (unit`eq-symmetric _ _).
 %total { } (unit`eq-symmetric _ _).


 %theorem unit`eq-transitive :
	forall* {U1} {U2} {U3}
	forall {E12:unit`eq U1 U2} {E23:unit`eq U2 U3}
	exists {E13:unit`eq U1 U3}
        true.

 - : unit`eq-transitive unit`eq/ unit`eq/ unit`eq/.

 %worlds () (unit`eq-transitive _ _ _).
 %total { } (unit`eq-transitive _ _ _).


 %abbrev unit`leq = unit`eq.
 %abbrev unit`false-implies-leq = unit`false-implies-eq.
 %abbrev unit`leq-reflexive = unit`eq-reflexive.
 %abbrev unit`leq-transitive = unit`eq-transitive.


 %theorem unit`leq-respects-eq :
	forall* {U1} {U2} {V1} {V2}
	forall	{L1: unit`leq U1 U2}
		{E1: unit`eq U1 V1}
		{E2: unit`eq U2 V2}
	exists  {L2: unit`leq V1 V2}
	true.

 - : unit`leq-respects-eq L _ _ L.

 %worlds () (unit`leq-respects-eq _ _ _ _).
 %total { } (unit`leq-respects-eq _ _ _ _).

 %theorem unit`leq-anti-symmetric :
	forall* {U1} {U2}
	forall {L12:unit`leq U1 U2} {L21:unit`leq U2 U1}
	exists {E:unit`eq U1 U2}
	true.

 - : unit`leq-anti-symmetric E _ E.

 %worlds () (unit`leq-anti-symmetric _ _ _).
 %total { } (unit`leq-anti-symmetric _ _ _).


 unit`union : unit -> unit -> unit -> type.

 unit`union/ : unit`union unit/ unit/ unit/.


 %theorem unit`false-implies-union :
	forall* {U1} {U2} {U3}
	forall {F:void}
	exists {J:unit`union U1 U2 U3}
	true.

 %worlds () (unit`false-implies-union _ _).
 %total { } (unit`false-implies-union _ _).


 %theorem unit`union-respects-eq :
	forall* {U1} {U2} {U3} {V1} {V2} {V3}
	forall	{J:unit`union U1 U2 U3}
		{E1:unit`eq U1 V1} 
		{E2:unit`eq U2 V2}
        	{E3:unit`eq U3 V3}
	exists	{K:unit`union V1 V2 V3}
	true.

 - : unit`union-respects-eq J _ _ _ J.

 %worlds () (unit`union-respects-eq _ _ _ _ _).
 %total { } (unit`union-respects-eq _ _ _ _ _).


 %theorem unit`union-deterministic :
	forall* {U1} {U2} {U3} {V1} {V2} {V3}
	forall {J:unit`union U1 U2 U3} {K:unit`union V1 V2 V3}
	       {E1:unit`eq U1 V1} {E2:unit`eq U2 V2}
        exists {E3:unit`eq U3 V3}
	true.

 - : unit`union-deterministic unit`union/ unit`union/ unit`eq/ unit`eq/ unit`eq/.

 %worlds () (unit`union-deterministic _ _ _ _ _).
 %total { } (unit`union-deterministic _ _ _ _ _).


 %theorem unit`union-total* :
	forall {U1} {U2}
	exists {U3} {J:unit`union U1 U2 U3}
	true.

 - : unit`union-total* _ _ _ unit`union/.

 %worlds () (unit`union-total* _ _ _ _).
 %total { } (unit`union-total* _ _ _ _).


 %theorem unit`union-commutative :
	forall* {U1} {U2} {U3}
	forall {J:unit`union U1 U2 U3}
	exists {K:unit`union U2 U1 U3}
	true.

 - : unit`union-commutative _ unit`union/.

 %worlds () (unit`union-commutative _ _).
 %total { } (unit`union-commutative _ _).


 %theorem unit`union-associative :
	forall* {U1} {U2} {U3} {U4} {U7}
	forall {J12:unit`union U1 U2 U3}
               {J34:unit`union U3 U4 U7}
	exists {U6} {J24:unit`union U2 U4 U6}
               {J16:unit`union U1 U6 U7}
	true.

 - : unit`union-associative _ _ unit/ unit`union/ unit`union/.

 %worlds () (unit`union-associative _ _ _ _ _).
 %total { } (unit`union-associative _ _ _ _ _).


 %theorem unit`union-associative* :
	forall* {U1} {U2} {U3} {U4} {U6} {U7}
	forall {J12:unit`union U1 U2 U3}
               {J34:unit`union U3 U4 U7}
	       {J24:unit`union U2 U4 U6}
        exists {J16:unit`union U1 U6 U7}
	true.

 - : unit`union-associative* _ _ _ unit`union/.

 %worlds () (unit`union-associative* _ _ _ _).
 %total { } (unit`union-associative* _ _ _ _).

 %theorem unit`union-left-preserves-leq* :
	forall* {U1} {U2} {U3} {U4} {U5}
        forall {L24:unit`leq U2 U4} 
	       {J12:unit`union U1 U2 U3} {J14:unit`union U1 U4 U5}
        exists {L35:unit`leq U3 U5}
	true.

 - : unit`union-left-preserves-leq* _ _ _ unit`eq/.

 %worlds () (unit`union-left-preserves-leq* _ _ _ _).
 %total { } (unit`union-left-preserves-leq* _ _ _ _).

 %theorem unit`union-preserves-leq :
	forall* {U1} {U2} {U3} {V1} {V2} {V3}
	forall {L1:unit`leq U1 V1} {L2:unit`leq U2 V2}
	       {JU:unit`union U1 U2 U3} {JV:unit`union V1 V2 V3}
	exists {L3:unit`leq U3 V3}
	true.

 - : unit`union-preserves-leq _ _ _ _ unit`eq/.

 %worlds () (unit`union-preserves-leq _ _ _ _ _).
 %total { } (unit`union-preserves-leq _ _ _ _ _).


 %theorem unit`union-implies-leq* :
	forall* {U1} {U2} {U3}
	forall {J:unit`union U1 U2 U3}
	exists {L:unit`leq U1 U3}
	true.

 - : unit`union-implies-leq* _ unit`eq/.

 %worlds () (unit`union-implies-leq* _ _).
 %total { } (unit`union-implies-leq* _ _).


 %theorem unit`union-implies-leq :
	forall* {U1} {U2} {U3}
	forall {J:unit`union U1 U2 U3}
	exists {L:unit`leq U1 U3} {L2:unit`leq U2 U3}
	true.

 - : unit`union-implies-leq _ unit`eq/ unit`eq/.

 %worlds () (unit`union-implies-leq _ _ _).
 %total { } (unit`union-implies-leq _ _ _).


 %theorem unit`union-is-lub :
	forall* {U1} {U2} {U3} {U4}
	forall {J:unit`union U1 U2 U3}
	       {L1:unit`leq U1 U4} {L2:unit`leq U2 U4}
	exists {L3:unit`leq U3 U4}
	true.

 - : unit`union-is-lub _ _ _ unit`eq/.

 %worlds () (unit`union-is-lub _ _ _ _).
 %total { } (unit`union-is-lub _ _ _ _).

 
 %abbrev unit`intersection = unit`union.
 %abbrev unit`false-implies-intersection = unit`false-implies-union.
 %abbrev unit`intersection-respects-eq = unit`union-respects-eq.
 %abbrev unit`intersection-deterministic = unit`union-deterministic.
 %abbrev unit`intersection-total* = unit`union-total*.
 %abbrev unit`intersection-commutative = unit`union-commutative.
 %abbrev unit`intersection-associative = unit`union-associative.
 %abbrev unit`intersection-associative* = unit`union-associative*.
 %abbrev unit`intersection-implies-leq* = unit`union-implies-leq*.
 %abbrev unit`intersection-left-preserves-leq* = unit`union-left-preserves-leq*.

 %theorem unit`intersection-is-glb :
	forall* {U0} {U1} {U2} {U3}
	forall {A:unit`intersection U1 U2 U3}
	       {L1:unit`leq U0 U1} {L2:unit`leq U0 U2}
	exists {L3:unit`leq U0 U3}
	true.

 - : unit`intersection-is-glb _ _ _ unit`eq/.

 %worlds () (unit`intersection-is-glb _ _ _ _).
 %total { } (unit`intersection-is-glb _ _ _ _).

 %theorem unit`intersection-right-distributes-over-union :
	forall* {U1} {U2} {U3} {U4} {U7}
	forall {J:unit`union U1 U2 U3} {A:unit`intersection U3 U4 U7}
        exists {U5} {U6} {M14:unit`intersection U1 U4 U5} {M24:unit`intersection U2 U4 U6}
               {J56:unit`union U5 U6 U7}
	true.

 - : unit`intersection-right-distributes-over-union _ _ unit/ unit/ unit`union/
                                           unit`union/ unit`union/.

 %worlds () (unit`intersection-right-distributes-over-union _ _ _ _ _ _ _).
 %total { } (unit`intersection-right-distributes-over-union _ _ _ _ _ _ _).

 %abbrev unit`union-right-distributes-over-intersection = 
         unit`intersection-right-distributes-over-union.

%%%% Functor Use



%%%% Definitions of Maps

map : type.


map/0 : map.

map/+ : nat -> unit -> map -> map.

%abbrev map/1 : nat -> unit -> map = [N] [D] (map/+ N D map/0).


%%%% Relations on maps


% equality is defined assuming "ne" is available,
% but 'ne' may be isufficiently inhabited to
% prove things about.


eq? : map -> map -> bool -> type.

%abbrev eq : map -> map -> type = [M1] [M2] eq? M1 M2 true.

%abbrev ne : map -> map -> type = [M1] [M2] eq? M1 M2 false.


eq?/yes : eq M M.

%abbrev eq/ = eq?/yes.

%abbrev eq?/no : ne M1 M2 -> eq? M1 M2 false = [x] x.



lookup : map -> nat -> unit -> type.


lookup/= : lookup (map/+ N1 D _) N2 D
    <- nat`eq N1 N2.

lookup/> : lookup (map/+ N1 _ F) N2 D
    <- plus (s N0) N1 N2
    <- lookup F N0 D.


not-member : map -> nat -> type.


not-member/0 : not-member map/0 M.

not-member/< : not-member (map/+ N _ F) M
    <- gt N M.

not-member/> : not-member (map/+ N _ F) M
    <- plus (s M1) N M
    <- not-member F M1.



ne/< : lookup M1 N D -> not-member M2 N -> ne M1 M2.

ne/> : not-member M1 N -> lookup M2 N D -> ne M1 M2.



member? : map -> nat -> bool -> type.


member?/in : member? M N true
    <- lookup M N _.

member?/out : member? M N false
    <- not-member M N.



disjoint : map -> map -> type.


disjoint/L : disjoint map/0 M.

disjoint/R : disjoint M map/0.

disjoint/< : disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N0) N1 N2
    <- disjoint M1 (map/+ N0 D2 M2).

disjoint/> : disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N3) N2 N1
    <- disjoint (map/+ N3 D1 M1) M2.



disjoint? : map -> map -> bool -> type.


disjoint?/yes : disjoint M1 M2 -> disjoint? M1 M2 true.

disjoint?/no :
	lookup M1 N D1 ->
	lookup M2 N D2 ->
    disjoint? M1 M2 false.



size : map -> nat -> type.


size/0 : size map/0 z.

size/+ : size (map/+ _ _ M) (s N)
    <- size M N.



%% useful for proving termination on map operations:

bound : map -> nat -> type.


bound/0 : bound map/0 z.

bound/+ : bound (map/+ N1 D M) N3
    <- bound M N2
    <- plus (s N1) N2 N3.


%worlds () (bound _ _).
%unique bound +B -1N.



shift : nat -> map -> map -> type.


shift/0 : shift _ map/0 map/0.

shift/+ : shift N1 (map/+ N2 D M) (map/+ N3 D M)
    <- plus (s N1) N2 N3.


%worlds () (shift _ _ _).
%unique shift +N +M -1M3.



update : map -> nat -> unit -> map -> type.


update/0 : update map/0 N D (map/+ N D map/0).

update/= : update (map/+ N1 _ F) N2 D (map/+ N2 D F)
    <- nat`eq N1 N2.

update/< : update (map/+ N1 D1 F) N2 D2 (map/+ N2 D2 (map/+ N3 D1 F))
    <- plus (s N3) N2 N1.

update/> : update (map/+ N1 D1 F1) N2 D2 (map/+ N1 D1 F2)
    <- plus (s N0) N1 N2
    <- update F1 N0 D2 F2.




%%%% Theorems



%%% Theorems about eq


%theorem meta-eq :
	forall {M} {N} {E:eq M N}
	true.
- : meta-eq M M eq/.
%worlds () (meta-eq _ _ _).
%total {} (meta-eq _ _ _).
%reduces M = N (meta-eq M N _).


%theorem false-implies-eq? :
	forall*	{M1} {M2} {B}
	forall	{F:void}
	exists	{E: eq? M1 M2 B}
	true.

%worlds () (false-implies-eq? _ _).
%total { } (false-implies-eq? _ _).

%abbrev false-implies-eq = false-implies-eq?.

%abbrev false-implies-ne = false-implies-eq?.


%theorem eq-reflexive : forall {M} exists {E:eq M M} true.

- : eq-reflexive _ eq/.

%worlds () (eq-reflexive M %{=>}% M=M).
%total {} (eq-reflexive _ _).


%theorem eq?-symmetric :
	forall*	{M1} {M2} {B}
	forall	{E1: eq? M1 M2 B}
	exists	{E2: eq? M2 M1 B}
	true.

- : eq?-symmetric eq/ eq/.

- : eq?-symmetric (ne/< L F) (ne/> F L).

- : eq?-symmetric (ne/> F L) (ne/< L F).


%worlds () (eq?-symmetric _ _).
%total { } (eq?-symmetric _ _).

%abbrev eq-symmetric = eq?-symmetric.

%abbrev ne-symmetric = eq?-symmetric.


%theorem eq-transitive:
	forall* {M1} {M2} {M3}
	forall {E12:eq M1 M2} {E23:eq M2 M3}
	exists {E13:eq M1 M3}
	true.

- : eq-transitive eq/ eq/ eq/.

%worlds () (eq-transitive M1=M2 M2=M3 %{=>}% M1=M3).
%total {} (eq-transitive _ _ _).


%theorem map/+-preserves-eq? :
	forall* {N} {NP} {D} {DP} {F} {FP} {B}
	forall {EN:nat`eq N NP} {ED:unit`eq D DP} {EF:eq? F FP B}
	exists {E:eq? (map/+ N D F) (map/+ NP DP FP) B}
	true.

- : map/+-preserves-eq? nat`eq/ unit`eq/ eq/ eq/.

- : map/+-preserves-eq? nat`eq/ unit`eq/ (ne/< L F) 
	(ne/< (lookup/> L P) (not-member/> F P))
    <- plus-total P.

- : map/+-preserves-eq? nat`eq/ unit`eq/ (ne/> F L) 
	(ne/> (not-member/> F P) (lookup/> L P))
    <- plus-total P.


%worlds () (map/+-preserves-eq? _ _ _ _).
%total { } (map/+-preserves-eq? _ _ _ _).

%abbrev map/+-preserves-eq = map/+-preserves-eq?.

%abbrev map/+-preserves-ne = map/+-preserves-eq?.


%theorem map/+-preserves-eq-converse :
	forall* {N} {NP} {D} {DP} {F} {FP}
	forall {E:eq (map/+ N D F) (map/+ NP DP FP)}
	exists {EN:nat`eq N NP} {ED:unit`eq D DP} {EF:eq F FP}
	true.

- : map/+-preserves-eq-converse eq/ nat`eq/ unit`eq/ eq/.

%worlds () (map/+-preserves-eq-converse _ _ _ _).
%total {} (map/+-preserves-eq-converse _ _ _ _).


%theorem eq-no-occur :
	forall*  {M} {N} {D}
	forall {E:eq M (map/+ N D M)}
	exists {F:void}
	true.

%worlds () (eq-no-occur _ _).
%total {} (eq-no-occur _ _).


%theorem eq-contradiction :
	forall* {N} {D} {M}
	forall {E:eq map/0 (map/+ N D M)}
	exists {F:void}
	true.

%worlds () (eq-contradiction _ _).
%total {} (eq-contradiction _ _).



%%% Theorems about lookup


%theorem false-implies-lookup : 
	forall* {M} {N} {D}
	forall {F:void}
	exists {L:lookup M N D}
	true.

%worlds () (false-implies-lookup _ %{=>}% F^N=D).
%total {} (false-implies-lookup _ _).


%theorem lookup-respects-eq :
	forall* {M} {N} {D} {MP} {NP} {DP}
	forall {L:lookup M N D} {EM:eq M MP} {EN:nat`eq N NP} {ED:unit`eq D DP}
	exists {LP:lookup MP NP DP}
	true.

- : lookup-respects-eq L eq/ nat`eq/ unit`eq/ L.

%worlds () (lookup-respects-eq M^N=D M=MP N=NP D=DP %{=>}% MP^NP=DP).
%total {} (lookup-respects-eq _ _ _ _ _).
%reduces X = Y (lookup-respects-eq X _ _ _ Y).


%theorem meta-reduces-lookup :
	forall*	{M1} {M2} {N1} {N2} {D1} {D2}
	forall	{F: void}
		{L1: lookup M1 N1 D1}
		{L2: lookup M2 N2 D2}
	true.

%worlds () (meta-reduces-lookup _ _ _).
%total { } (meta-reduces-lookup _ _ _).
%reduces X < Y (meta-reduces-lookup _ X Y).


%theorem lookup/>-inversion :
	forall*	{N1} {D1} {M1} {N2} {D2} {N0}
	forall	{L: lookup (map/+ N1 D1 M1) N2 D2}
		{P: plus (s N0) N1 N2}
	exists	{LP: lookup M1 N0 D2}
	true. 

- : lookup/>-inversion (LEQ:lookup (map/+ N _ _) N _) P L
    <- plus-implies-gt P nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-lookup F L
    <- meta-reduces-lookup F L LEQ.

- : lookup/>-inversion (lookup/> LP P) PX LPX
    <- plus-right-cancels P PX nat`eq/ nat`eq/ SN0=SNX
    <- succ-cancels SN0=SNX N0=NX
    <- lookup-respects-eq LP eq/ N0=NX unit`eq/ LPX.

%worlds () (lookup/>-inversion _ _ _).
%total { } (lookup/>-inversion _ _ _).
%reduces Y < X (lookup/>-inversion X _ Y).


%theorem lookup-deterministic :
	forall* {M} {N} {D} {MP} {NP} {DP}
	forall {L:lookup M N D} {LP:lookup MP NP DP}
               {EM:eq M MP} {EN:nat`eq N NP}
	exists {ED:unit`eq D DP}
	true.

%abbrev lookup-unique = lookup-deterministic.

- : lookup-deterministic (lookup/= nat`eq/) (lookup/= nat`eq/) eq/ nat`eq/ unit`eq/.

- : lookup-deterministic (lookup/> F^N0=D   N0+1+N1=N2) 
                         (lookup/> F^N0P=DP N0P+1+N1=N2) eq/ nat`eq/ D=DP
    <- plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- lookup-deterministic F^N0=D F^N0P=DP eq/ N0=N0P D=DP.

%% contradiction cases
- : lookup-deterministic (lookup/= nat`eq/) (lookup/> _ N0+1+N=N) 
                         eq/ nat`eq/ D=DP
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N FALSE
    <- unit`false-implies-eq FALSE D=DP.

- : lookup-deterministic (lookup/> _ N0+1+N=N) (lookup/= nat`eq/)
                         eq/ nat`eq/ D=DP
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N FALSE
    <- unit`false-implies-eq FALSE D=DP.

%worlds () (lookup-deterministic M^N=D MP^NP=DP M=MP N=NP %{=>}% D=DP).
%total (L) (lookup-deterministic L _ _ _ _).


%% lookup is NOT total


%theorem lookup-contradiction :
	forall* {N} {D}
	forall {L:lookup map/0 N D}
	exists {F:void}
	true.

%worlds () (lookup-contradiction _ _).
%total { } (lookup-contradiction _ _).


%theorem lookup-one-choice :
	forall* {N1} {D1} {N2} {D2}
	forall  {L:lookup (map/+ N1 D1 map/0) N2 D2}
	exists  {NE:nat`eq N1 N2} {DE:unit`eq D1 D2}
	true.

- : lookup-one-choice (lookup/= nat`eq/) nat`eq/ unit`eq/.

%worlds () (lookup-one-choice _ _ _).
%total { } (lookup-one-choice _ _ _).


%theorem lookup-implies-ge :
        forall* {N1} {D1} {M1} {N} {D}
        forall  {L: lookup (map/+ N1 D1 M1) N D}
        exists  {G: nat`ge N N1}
        true.

- : lookup-implies-ge (lookup/= nat`eq/) (nat`ge/= nat`eq/).

- : lookup-implies-ge (lookup/> _ P) (nat`ge/> GT)
    <- plus-implies-gt P nat`eq/ GT.
    
%worlds () (lookup-implies-ge _ _).
%total { } (lookup-implies-ge _ _).



%%% Theorems about not-member


%theorem false-implies-not-member : 
	forall* {M} {N} forall {F:void} exists {D:not-member M N} true.

%worlds () (false-implies-not-member _ %{=>}% N-not-in-member-M).
%total {} (false-implies-not-member _ _).


%theorem not-member-respects-eq :
	forall* {M} {N} {MP} {NP}
	forall {D:not-member M N} {EM:eq M MP} {EN:nat`eq N NP}
	exists {DP:not-member MP NP}
	true.

- : not-member-respects-eq D eq/ nat`eq/ D.

%worlds () (not-member-respects-eq _ _ _ _).
%total {} (not-member-respects-eq _ _ _ _).


%theorem not-member/>-inversion :
	forall*	{M} {N} {D} {N1} {N2}
	forall	{F: not-member (map/+ N D M) N1}
		{P: plus (s N2) N N1}
	exists	{F1: not-member M N2}
	true.

- : not-member/>-inversion (not-member/< G1) P FR
    <- plus-implies-gt P nat`eq/ G
    <- gt-anti-symmetric G1 G F
    <- false-implies-not-member F FR.

- : not-member/>-inversion (not-member/> F1 P1) P F
    <- plus-right-cancels P1 P nat`eq/ nat`eq/ SEQ
    <- succ-cancels SEQ EQ
    <- not-member-respects-eq F1 eq/ EQ F.

%worlds () (not-member/>-inversion _ _ _).
%total { } (not-member/>-inversion _ _ _).


%% not-member is NOT deterministic

%theorem not-member-total* :
	forall {M}
	exists {N} {F:not-member M N}
	true.

- : not-member-total* map/0 z not-member/0.

- : not-member-total* (map/+ N1 _ M) N3 (not-member/> F N+1+N1=N3)
    <- not-member-total* M N F
    <- plus-total* (s N) N1 N3 N+1+N1=N3.

%worlds () (not-member-total* M %{=>}% N N-not-in-member-of-M).
%total (M) (not-member-total* M _ _).

%abbrev not-member-total = not-member-total* _ _.


%theorem not-member-lookup-not-equal :
	forall* {M} {N1} {N2} {D2}
	forall {F:not-member M N1} {L:lookup M N2 D2}
	exists {NE:nat`ne N1 N2}
	true.

- : not-member-lookup-not-equal (not-member/< N2>N1) (lookup/= nat`eq/) (nat`ne/< N2>N1).

- : not-member-lookup-not-equal (not-member/< N1>N3) (lookup/> _ N0+1+N1=N2) 
                           (nat`ne/< N2>N3)
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- gt-transitive N2>N1 N1>N3 N2>N3.

- : not-member-lookup-not-equal (not-member/> _ X+1+N2=N1) (lookup/= nat`eq/) (nat`ne/> N1>N2)
    <- plus-implies-gt X+1+N2=N1 nat`eq/ N1>N2.

- : not-member-lookup-not-equal (not-member/> F N4+1+N1=N3) (lookup/> L N0+1+N1=N2)
                           N3<>N2
    <- not-member-lookup-not-equal F L N4<>N0
    <- succ-preserves-ne N4<>N0 N4+1<>N0+1
    <- plus-right-preserves-ne* N4+1<>N0+1 N4+1+N1=N3 N0+1+N1=N2 N3<>N2.

%worlds () (not-member-lookup-not-equal N1-not-in-member-of-M M^N2=D %{=>}% N1<>N2).
%total (F) (not-member-lookup-not-equal F _ _).


%theorem not-member-contradiction :
	forall* {M} {N} {D}
	forall {F:not-member (map/+ N D M) N}
        exists {V:void}
	true.

- : not-member-contradiction (not-member/< N>N) V
    <- nat`gt-anti-reflexive N>N V.

- : not-member-contradiction (not-member/> _ N0+1+N=N) V
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N V.

%worlds () (not-member-contradiction _ _).
%total {} (not-member-contradiction _ _).


%theorem ne-implies-unit-map-not-member :
	forall* {N1} {D} {N2}
	forall {NE:nat`ne N1 N2}
	exists {F:not-member (map/+ N1 D map/0) N2}
	true.

- : ne-implies-unit-map-not-member 
     (nat`ne/< N1<N2) (not-member/> not-member/0 N0+1+N1=N2)
    <- nat`gt-implies-plus N1<N2 N0 N0+1+N1=N2.

- : ne-implies-unit-map-not-member
     (nat`ne/> N1>N2) (not-member/< N1>N2).

%worlds () (ne-implies-unit-map-not-member _ _).
%total { } (ne-implies-unit-map-not-member _ _).


%theorem plus-right-preserves-not-member* :
	forall* {M} {N1} {D} {N2} {N} {N3} {N4}
        forall {F:not-member (map/+ N1 D M) N2}
               {P1:plus N1 N N3} {P2:plus N2 N N4}
        exists {FP:not-member (map/+ N3 D M) N4}
	true.

- : plus-right-preserves-not-member* (not-member/< N2>N1) N1+N=N3 N2+N=N4 (not-member/< N4>N3)
    <- nat`plus-right-preserves-gt* N2>N1 N1+N=N3 N2+N=N4 N4>N3.

- : plus-right-preserves-not-member* (not-member/> F10 N0+1+N1=N2) N1+N=N3 N2+N=N4
                                (not-member/> F10 N0+1+N3=N4)
    <- nat`plus-associative* N0+1+N1=N2 N2+N=N4 N1+N=N3 N0+1+N3=N4.

%worlds () (plus-right-preserves-not-member* _ _ _ _).
%total {} (plus-right-preserves-not-member* _ _ _ _).


%theorem not-member-lookup-implies-ne :
	forall* {M1} {N1} {M2} {N2} {D2}
	forall {L1:not-member M1 N1}
	       {L2:lookup M2 N2 D2}
	       {EN:nat`eq N1 N2}
	exists {NM:ne M1 M2}
	true.

- : not-member-lookup-implies-ne F L nat`eq/ (ne/> F L).

%worlds () (not-member-lookup-implies-ne _ _ _ _).
%total { } (not-member-lookup-implies-ne _ _ _ _).



%%% Theorems about eq?/ne


%% false-implies-eq? already done

%theorem eq?-respects-eq :
	forall* {M11} {M12} {M21} {M22} {B}
	forall {N1:eq? M11 M12 B} {E1:eq M11 M21} {E2:eq M12 M22}
	exists {N2:eq? M21 M22 B}
	true.

%abbrev ne-respects-eq = eq?-respects-eq.


%theorem ne-anti-reflexive :
	forall* {M}
	forall {N:ne M M}
	exists {F:void}
	true.

- : ne-anti-reflexive (ne/< L F) V
    <- not-member-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N V.

- : ne-anti-reflexive (ne/> F L) V
    <- not-member-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N V.


%worlds () (ne-anti-reflexive _ _).
%total (N) (ne-anti-reflexive N _).


%theorem eq-ne-implies-false :
        forall* {X} {Y}
        forall {D1:eq X Y} {D2:ne X Y}
        exists {F:void}
        true.

- : eq-ne-implies-false eq/ X<>X F
    <- ne-anti-reflexive X<>X F.

%worlds () (eq-ne-implies-false _ _ _).
%total { } (eq-ne-implies-false _ _ _).




%%% Theorems about map/member


%theorem false-implies-member? :
	forall* {M} {N} {D}
	forall {F:void}
	exists {MD:member? M N D}
	true.

%worlds () (false-implies-member? _ _).
%total {} (false-implies-member? _ _).


%theorem member?-respects-eq :
	forall* {M1} {N1} {B1} {M2} {N2} {B2}
	forall  {MD1:member? M1 N1 B1}
		{EM:eq M1 M2}
		{EN:nat`eq N1 N2}
		{BE:bool`eq B1 B2}
	exists  {MD2:member? M2 N2 B2}
	true.

- : member?-respects-eq MD eq/ nat`eq/ bool`eq/ MD.

%worlds () (member?-respects-eq _ _ _ _ _).
%total { } (member?-respects-eq _ _ _ _ _).


%theorem member?-deterministic :
	forall* {M1} {N1} {B1} {M2} {N2} {B2}
	forall  {MD1:member? M1 N1 B1}
		{MD2:member? M2 N2 B2}
		{EM:eq M1 M2}
		{EN:nat`eq N1 N2}
	exists	{BE:bool`eq B1 B2}
	true.

%abbrev member?-unique = member?-deterministic.

- : member?-deterministic _ _ _ _ bool`eq/.

- : member?-deterministic (member?/in L) (member?/out F) eq/ nat`eq/ BE
    <- not-member-lookup-not-equal F L NE
    <- nat`ne-anti-reflexive NE V
    <- bool`false-implies-eq V BE.

- : member?-deterministic (member?/out F) (member?/in L) eq/ nat`eq/ BE
    <- not-member-lookup-not-equal F L NE
    <- nat`ne-anti-reflexive NE V
    <- bool`false-implies-eq V BE.

%worlds () (member?-deterministic _ _ _ _ _).
%total { } (member?-deterministic _ _ _ _ _).


%theorem member?-total* :
	forall {M} {N}
	exists {B} {MD:member? M N B}
	true.

%% we need a lemma
%theorem member?-map/+-total :
	forall {N1} {D1} {M1} {N2} {C} {CMP:nat`compare N1 N2 C}
	exists {B} {MD:member? (map/+ N1 D1 M1) N2 B}
	true.

%% and this lemma needs a lemma
%theorem member?-map/+-complete :
	forall {N1} {D1} {M1} {N2} {N0} {P:plus (s N0) N1 N2}
               {B} {MD1:member? M1 N0 B}
	exists {MD:member? (map/+ N1 D1 M1) N2 B}
	true.

- : member?-total* map/0 N false (member?/out not-member/0).

- : member?-total* (map/+ N1 D1 M1) N2 B MD
    <- nat`compare-total* N1 N2 C CMP
    <- member?-map/+-total N1 D1 M1 N2 C CMP B MD.

- : member?-map/+-total N1 D1 M1 N2 equal CMP true 
                           (member?/in (lookup/= N1=N2))
    <- equal-implies-eq CMP N1=N2.

- : member?-map/+-total N1 D1 M1 N2 greater CMP false 
                           (member?/out (not-member/< N1>N2))
    <- greater-implies-gt CMP N1>N2.

- : member?-map/+-total N1 D1 M1 N2 less CMP B MD
    <- less-implies-lt CMP N2>N1
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- member?-total* M1 N0 B MD1
    <- member?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 B MD1 MD.

- : member?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 true (member?/in L1)
                              (member?/in (lookup/> L1 N0+1+N1=N2)).

- : member?-map/+-complete N1 D1 M1 N2 N0 N0+1+N1=N2 false (member?/out F1)
                              (member?/out (not-member/> F1 N0+1+N1=N2)).

%worlds () (member?-map/+-complete _ _ _ _ _ _ _ _ _).
%total {} (member?-map/+-complete _ _ _ _ _ _ _ _ _).

%worlds () (member?-total* _ _ _ _)
           (member?-map/+-total _ _ _ _ _ _ _ _).
%total (M M1) (member?-total* M _ _ _) 
              (member?-map/+-total _ _ M1 _ _ _ _ _).

%abbrev member?-total = member?-total* _ _ _.


%theorem in-implies-lookup :
	forall* {M} {N}
	forall {MD:member? M N true}
	exists {D} {L:lookup M N D}
	true.

- : in-implies-lookup (member?/in L) _ L.

%worlds () (in-implies-lookup _ _ _).
%total {} (in-implies-lookup _ _ _).


%theorem out-implies-not-member :
	forall* {M} {N}
	forall {MD:member? M N false}
	exists {F:not-member M N}
	true.

- : out-implies-not-member (member?/out F) F.

%worlds () (out-implies-not-member _ _).
%total {} (out-implies-not-member _ _).



%%% Theorems about disjoint


%theorem false-implies-disjoint :
	forall* {M1} {M2}
	forall {F:void}
	exists {D:disjoint M1 M2}
	true.

%worlds () (false-implies-disjoint _ _).
%total { } (false-implies-disjoint _ _).


%theorem disjoint-respects-eq :
	forall* {M1} {M2} {M1P} {M2P}
	forall {A:disjoint M1 M2} {E1:eq M1 M1P} {E2:eq M2 M2P} 
	exists {AP:disjoint M1P M2P}
	true.

- : disjoint-respects-eq A eq/ eq/ A.

%worlds () (disjoint-respects-eq _ _ _ _).
%total {} (disjoint-respects-eq _ _ _ _).
%reduces A = AP (disjoint-respects-eq A _ _ AP).


%theorem disjoint/=-contradiction :
	forall* {N1} {D1} {M1} {N2} {D2} {M2}
	forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
	       {G:nat`eq N1 N2}
	exists {F:void}
	true.

- : disjoint/=-contradiction (disjoint/< _ N0+1+N=N) nat`eq/ F
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F.

- : disjoint/=-contradiction (disjoint/> _ N3+1+N=N) nat`eq/ F
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F.

%worlds () (disjoint/=-contradiction _ _ _).
%total { } (disjoint/=-contradiction _ _ _).


%theorem disjoint/<-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}
	forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
               {P:plus (s N0) N1 N2} 	       
	exists {AP:disjoint M1 (map/+ N0 D2 M2)}
	true.

- : disjoint/<-inversion (disjoint/< A P) PP AP
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P unit`eq/ eq/ M022=M022P
    <- disjoint-respects-eq A eq/ M022=M022P AP.

- : disjoint/<-inversion (disjoint/> AP N3+1+N2=N1) N0+1+N1=N2 A
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M311=M1
    <- false-implies-eq F M2=M022
    <- disjoint-respects-eq AP M311=M1 M2=M022 A.

%worlds () (disjoint/<-inversion _ _ _).
%total {}  (disjoint/<-inversion _ _ _).
%reduces AP < A (disjoint/<-inversion A _ AP).


%theorem disjoint/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
	forall {A:disjoint (map/+ N1 D1 M1) (map/+ N2 D2 M2)}
	       {P:plus (s N3) N2 N1}
	exists {AP:disjoint (map/+ N3 D1 M1) M2}
	true.

- : disjoint/>-inversion (disjoint/> A P) PP AP
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P unit`eq/ eq/ M311=M311P
    <- disjoint-respects-eq A M311=M311P eq/ AP.

- : disjoint/>-inversion (disjoint/< AP N0+1+N1=N2) N3+1+N2=N1 A
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M1=M311
    <- false-implies-eq F M022=M2
    <- disjoint-respects-eq AP M1=M311 M022=M2 A.

%worlds () (disjoint/>-inversion _ _ _).
%total { } (disjoint/>-inversion _ _ _).
%reduces AP < A (disjoint/>-inversion A _ AP).


%theorem disjoint-anti-reflexive :
	forall* {M}
	forall {D:disjoint M M}
	exists {E:eq map/0 M}
	true.

- : disjoint-anti-reflexive disjoint/L eq/.

- : disjoint-anti-reflexive disjoint/R eq/.

- : disjoint-anti-reflexive (A:disjoint (map/+ N D M) (map/+ N D M)) E
    <- disjoint/=-contradiction A nat`eq/ F
    <- false-implies-eq F E.

%worlds () (disjoint-anti-reflexive _ _).
%total { } (disjoint-anti-reflexive _ _).


%theorem disjoint-symmetric :
	forall* {M1} {M2}
	forall {D:disjoint M1 M2} 
	exists {D:disjoint M2 M1}
	true.

- : disjoint-symmetric disjoint/L disjoint/R.

- : disjoint-symmetric disjoint/R disjoint/L.

- : disjoint-symmetric (disjoint/< D P) (disjoint/> DP P)
    <- disjoint-symmetric D DP.

- : disjoint-symmetric (disjoint/> D P) (disjoint/< DP P)
    <- disjoint-symmetric D DP.

%worlds () (disjoint-symmetric _ _).
%total (D) (disjoint-symmetric D _).


%theorem disjoint-lookup-contradiction :
	forall* {M1} {M2} {N} {D1} {D2}
	forall {A:disjoint M1 M2}
               {L1:lookup M1 N D1} {L2:lookup M2 N D2}
	exists {F:void}
	true.

- : disjoint-lookup-contradiction disjoint/L L _ F
    <- lookup-contradiction L F.

- : disjoint-lookup-contradiction disjoint/R _ L F
    <- lookup-contradiction L F.

- : disjoint-lookup-contradiction (disjoint/< _ N0+1+N=N)
                                  (lookup/= nat`eq/) (lookup/= nat`eq/) F
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : disjoint-lookup-contradiction (disjoint/< _ N0+1+N1=N2)
                                  (lookup/= nat`eq/) 
                                  (lookup/> _ N3+1+N2=N1) F
    <- plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- gt-anti-symmetric N2>N1 N1>N2 F.
    
- : disjoint-lookup-contradiction (disjoint/< D N0+1+N1=N2)
                                  (lookup/> L1P N0P+1+N1=N2)
                                  (lookup/= nat`eq/) F
    <- plus-right-cancels N0P+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N0P+1=N0+1
    <- succ-cancels N0P+1=N0+1 N0P=N0
    <- lookup-respects-eq L1P eq/ N0P=N0 unit`eq/ L1
    <- disjoint-lookup-contradiction D L1 (lookup/= nat`eq/) F.

- : disjoint-lookup-contradiction (disjoint/< D N0+1+N1=N2)
                                  (lookup/> L1 N1P+1+N1=N) 
                                  (lookup/> L2 N2P+1+N2=N) F
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N2P+1+N2=N NX
                                 N2P+1+N0=NX NX+N1+1=N
    <- plus-swap-succ N1P+1+N1=N N1P+N1+1=N
    <- plus-right-cancels NX+N1+1=N N1P+N1+1=N nat`eq/ nat`eq/ NX=N1P
    <- plus-respects-eq N2P+1+N0=NX nat`eq/ nat`eq/ NX=N1P N2P+1+N0=N1P
    <- disjoint-lookup-contradiction D L1 (lookup/> L2 N2P+1+N0=N1P) F.

- : disjoint-lookup-contradiction (disjoint/> _ N3+1+N=N)
                                  (lookup/= nat`eq/) (lookup/= nat`eq/) F
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : disjoint-lookup-contradiction (disjoint/> _ N3+1+N2=N1)
                                  (lookup/> _ N3+1+N1=N2)
                                  (lookup/= nat`eq/) F
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- plus-implies-gt N3+1+N1=N2 nat`eq/ N2>N1
    <- gt-anti-symmetric N1>N2 N2>N1 F.
    
- : disjoint-lookup-contradiction (disjoint/> D N3+1+N2=N1)
                                  (lookup/= nat`eq/)
                                  (lookup/> L2P N3P+1+N2=N1) F
    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- succ-cancels N3P+1=N3+1 N3P=N3
    <- lookup-respects-eq L2P eq/ N3P=N3 unit`eq/ L2
    <- disjoint-lookup-contradiction D (lookup/= nat`eq/) L2 F.

- : disjoint-lookup-contradiction (disjoint/> D N3+1+N2=N1)
                                  (lookup/> L1 N1P+1+N1=N)
                                  (lookup/> L2 N2P+1+N2=N) F 
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N1P+1+N1=N NX
                                 N1P+1+N3=NX NX+N2+1=N
    <- plus-swap-succ N2P+1+N2=N N2P+N2+1=N
    <- plus-right-cancels NX+N2+1=N N2P+N2+1=N nat`eq/ nat`eq/ NX=N2P
    <- plus-respects-eq N1P+1+N3=NX nat`eq/ nat`eq/ NX=N2P N1P+1+N3=N2P
    <- disjoint-lookup-contradiction D (lookup/> L1 N1P+1+N3=N2P) L2 F.

%worlds () (disjoint-lookup-contradiction _ _ _ _).
%total (D) (disjoint-lookup-contradiction D _ _ _).


%theorem disjoint-lookup-implies-not-member :
	forall*	{M1} {N} {D} {M2}
	forall	{L: lookup M1 N D}
		{A: disjoint M1 M2}
	exists	{F: not-member M2 N}
	true.

%theorem disjoint-lookup-implies-not-member/L :
	forall*	{M1} {N} {D} {M2} {B}
	forall	{L: lookup M1 N D}
		{A: disjoint M1 M2}
		{D?: member? M2 N B}
	exists	{F: not-member M2 N}
	true.

- : disjoint-lookup-implies-not-member/L
	L1 A (member?/in L2) FR
    <- disjoint-lookup-contradiction A L1 L2 F
    <- false-implies-not-member F FR.

- : disjoint-lookup-implies-not-member/L
	_ _ (member?/out FR) FR.

%worlds () (disjoint-lookup-implies-not-member/L _ _ _ _).
%total { } (disjoint-lookup-implies-not-member/L _ _ _ _).

- : disjoint-lookup-implies-not-member L D F
    <- member?-total D?
    <- disjoint-lookup-implies-not-member/L L D D? F.

%worlds () (disjoint-lookup-implies-not-member _ _ _).
%total { } (disjoint-lookup-implies-not-member _ _ _).


%theorem shift-left-preserves-disjoint :
	forall* {N} {D} {M1} {M2} {SM1}
	forall {A:disjoint M1 M2} {S1:shift N M1 SM1}
        exists {SA:disjoint SM1 (map/+ N D M2)}
        true.

- : shift-left-preserves-disjoint _ shift/0 disjoint/L.

- : shift-left-preserves-disjoint M111*M2 (shift/+ N+1+N1=N1P)
                              (disjoint/> M111*M2 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-disjoint _ _ _).
%total { } (shift-left-preserves-disjoint _ _ _).


%theorem shift-left-preserves-disjoint-converse :
	forall* {N} {D} {M1} {M2} {SM1}
	forall {SA:disjoint SM1 (map/+ N D M2)} {S1:shift N M1 SM1}
        exists {A:disjoint M1 M2}
	true.

- : shift-left-preserves-disjoint-converse _ shift/0 disjoint/L.

- : shift-left-preserves-disjoint-converse M111*M222 (shift/+ N2+1+N3=N1)
                                           M311*M2
    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1
    <- disjoint/>-inversion M111*M222 N3+1+N2=N1 M311*M2.

%worlds () (shift-left-preserves-disjoint-converse _ _ _).
%total { } (shift-left-preserves-disjoint-converse _ _ _).


%theorem shift-right-preserves-disjoint :
	forall* {N} {D} {M1} {M2} {SM2}
	forall {A:disjoint M1 M2} {S2:shift N M2 SM2}
        exists {SA:disjoint (map/+ N D M1) SM2}
	true.

- : shift-right-preserves-disjoint _ shift/0 disjoint/R.

- : shift-right-preserves-disjoint M1*M222 (shift/+ N+1+N2=N2P)
                               (disjoint/< M1*M222 N2+1+N=N2P)
    <- plus-swap-succ N+1+N2=N2P N+N2+1=N2P
    <- plus-commutative N+N2+1=N2P N2+1+N=N2P.

%worlds () (shift-right-preserves-disjoint _ _ _).
%total { } (shift-right-preserves-disjoint _ _ _).


%theorem shift-right-preserves-disjoint-converse :
	forall* {N} {D} {M1} {M2} {SM2}
	forall {SA:disjoint (map/+ N D M1) SM2} {S2:shift N M2 SM2}
        exists {A:disjoint M1 M2}
	true.

- : shift-right-preserves-disjoint-converse _ shift/0 disjoint/R.

- : shift-right-preserves-disjoint-converse M111*M322 (shift/+ N1+1+N2=N3)
                                            M1*M222
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- disjoint/<-inversion M111*M322 N2+1+N1=N3 M1*M222.

%worlds () (shift-right-preserves-disjoint-converse _ _ _).
%total { } (shift-right-preserves-disjoint-converse _ _ _).


%theorem shift-preserves-disjoint :
	forall* {N} {M1} {M2} {SM1} {SM2}
	forall {A:disjoint M1 M2} 
               {S1:shift N M1 SM1} {S2:shift N M2 SM2}
	exists {SA:disjoint SM1 SM2}
	true.

- : shift-preserves-disjoint _ shift/0 _ disjoint/L.

- : shift-preserves-disjoint _ _ shift/0 disjoint/R.

- : shift-preserves-disjoint (disjoint/< M1*M022 N0+1+N1=N2)
                             (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                             (disjoint/< M1*M022 N0+1+N4=N5)
    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4
    <- plus-commutative N+N1+1=N4 N1+1+N=N4
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.

- : shift-preserves-disjoint (disjoint/> M311*M2 N3+1+N2=N1)
                             (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                             (disjoint/> M311*M2 N3+1+N5=N4)
    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5
    <- plus-commutative N+N2+1=N5 N2+1+N=N5
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4.

%worlds () (shift-preserves-disjoint _ _ _ _).
%total { } (shift-preserves-disjoint _ _ _ _).


%theorem shift-preserves-disjoint-converse :
	forall* {N} {M1} {M2} {SM1} {SM2}
	forall {SA:disjoint SM1 SM2}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	exists {A:disjoint M1 M2}
	true.

- : shift-preserves-disjoint-converse _ shift/0 _ disjoint/L.

- : shift-preserves-disjoint-converse _ _ shift/0 disjoint/R.

- : shift-preserves-disjoint-converse (disjoint/< M1*M055 N0+1+N4=N5)
                                      (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
				      (disjoint/< M1*M055 N0+1+N1=N2)
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4
    <- plus-associative-converse N1+N+1=N4 N0+1+N4=N5 N2P N0+1+N1=N2P N2P+N+1=N5
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-right-cancels N2P+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2P=N2
    <- plus-respects-eq N0+1+N1=N2P nat`eq/ nat`eq/ N2P=N2 N0+1+N1=N2.
                                  
- : shift-preserves-disjoint-converse (disjoint/> M611*M2 N6+1+N5=N4)
                                      (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5)
                                      (disjoint/> M611*M2 N6+1+N2=N1)
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5
    <- plus-associative-converse N2+N+1=N5 N6+1+N5=N4 N1P N6+1+N2=N1P N1P+N+1=N4
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-right-cancels N1P+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1P=N1
    <- plus-respects-eq N6+1+N2=N1P nat`eq/ nat`eq/ N1P=N1 N6+1+N2=N1.

%worlds () (shift-preserves-disjoint-converse _ _ _ _).
%total { } (shift-preserves-disjoint-converse _ _ _ _).


%theorem can-construct-unit-disjoint:
	forall*	{N} {D} {M1} {M}
	forall	{S: shift N M1 M}
	exists	{A: disjoint M (map/+ N D map/0)}
	true.

- : can-construct-unit-disjoint shift/0 disjoint/L.

- : can-construct-unit-disjoint (shift/+ P) (disjoint/> disjoint/R PPP)
    <- plus-swap-succ P PP
    <- plus-commutative PP PPP.

%worlds () (can-construct-unit-disjoint _ _).
%total { } (can-construct-unit-disjoint _ _).


%theorem ne-implies-disjoint :
	forall* {N1} {D1} {N2} {D2}
	forall	{NE:nat`ne N1 N2}
	exists	{D:disjoint (map/+ N1 D1 map/0) (map/+ N2 D2 map/0)}
	true.

- : ne-implies-disjoint (nat`ne/< N1<N2) 
	(disjoint/< disjoint/L N0+1+N1=N2)
    <- gt-implies-plus N1<N2 _ N0+1+N1=N2.

- : ne-implies-disjoint (nat`ne/> N1>N2) 
	(disjoint/> disjoint/R N3+1+N2=N1)
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1.

%worlds () (ne-implies-disjoint _ _).
%total { } (ne-implies-disjoint _ _).


%theorem not-member-implies-unit-disjoint :
	forall*	{N} {M} {D}
	forall	{F:not-member M N}
	exists	{D: disjoint M (map/+ N D map/0)}
	true.

- : not-member-implies-unit-disjoint not-member/0 disjoint/L.

- : not-member-implies-unit-disjoint (not-member/< G) (disjoint/> disjoint/R P)
    <- gt-implies-plus G _ P.

- : not-member-implies-unit-disjoint (not-member/> F P) (disjoint/< D P)
    <- not-member-implies-unit-disjoint F D.

%worlds () (not-member-implies-unit-disjoint _ _).
%total (F) (not-member-implies-unit-disjoint F _).



%%% Theorems about size


%theorem false-implies-size :
	forall* {M} {N}
	forall {F:void}
	exists {SZ:size M N}
	true.

%worlds () (false-implies-size _ _).
%total { } (false-implies-size _ _).


%theorem size-total* :
	forall {M} 
	exists {N} {MX:size M N}
	true.

- : size-total* map/0 _ size/0.

- : size-total* _ _ (size/+ SZ)
    <- size-total* _ _ SZ.

%worlds () (size-total* _ _ _).
%total (M) (size-total* M _ _).


%abbrev size-total = size-total* _ _.


%theorem size-respects-eq :
	forall* {M1} {M2} {N1} {N2}
	forall  {SZ1:size M1 N1} 
		{EM:eq M1 M2}
        	{EN:nat`eq N1 N2}
	exists	{SZ2:size M2 N2} 
	true.

- : size-respects-eq S eq/ nat`eq/ S.

%worlds () (size-respects-eq _ _ _ _).
%total { } (size-respects-eq _ _ _ _).


%theorem size-deterministic :
	forall* {M1} {M2} {N1} {N2}
	forall {SZ1:size M1 N1} {SZ2:size M2 N2} {EM:eq M1 M2}
        exists {EN:nat`eq N1 N2}
	true.

%abbrev size-unique = size-deterministic.

- : size-deterministic size/0 size/0 eq/ nat`eq/.

- : size-deterministic (size/+ N1=|M1|) (size/+ N2=|M2|) eq/ N1+1=N2+1
    <- size-deterministic N1=|M1| N2=|M2| eq/ N1=N2
    <- succ-deterministic N1=N2 N1+1=N2+1.

%worlds () (size-deterministic _ _ _ _).
%total (S) (size-deterministic S _ _ _).


%theorem shift-preserves-size :
	forall* {M1} {N1} {M2} {N}
	forall	{SZ1: size M1 N1}
		{SH: shift N M1 M2}
	exists	{SZ2: size M2 N1}
	true.

- : shift-preserves-size (size/0) (shift/0) (size/0).

- : shift-preserves-size (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size _ _ _).
%total { } (shift-preserves-size _ _ _).


%theorem shift-preserves-size-converse:
	forall* {M1} {N1} {M2} {N}
	forall	{SZ2: size M2 N1}
		{SH: shift N M1 M2}
	exists	{SZ1: size M1 N1}
	true.

- : shift-preserves-size-converse (size/0) (shift/0) (size/0).

- : shift-preserves-size-converse (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size-converse _ _ _).
%total { } (shift-preserves-size-converse _ _ _).



%%% Theorems about bound

%theorem false-implies-bound :
	forall* {M} {N}
	forall {F:void}
	exists {MX:bound M N}
	true.

%worlds () (false-implies-bound _ _).
%total { } (false-implies-bound _ _).


%theorem bound-respects-eq :
	forall*	{M1} {N1} {M2} {N2}
	forall	{B1: bound M1 N1}
		{EM: eq M1 M2}
		{EN: nat`eq N1 N2}
	exists	{B2: bound M2 N2}
	true.

- : bound-respects-eq B _ _ B.

%worlds () (bound-respects-eq _ _ _ _).
%total { } (bound-respects-eq _ _ _ _).


%theorem bound-unique :
	forall*	{M1} {N1} {M2} {N2}
	forall	{B1: bound M1 N1}
		{B2: bound M2 N2}
		{EM: eq M1 M2}
	exists	{EN: nat`eq N1 N2}
	true.

%abbrev bound-deterministic = bound-unique.

- : bound-unique bound/0 bound/0 _ nat`eq/.

- : bound-unique (bound/+ P1 B1) (bound/+ P2 B2) eq/ EQ2
    <- bound-unique B1 B2 eq/ EQ1
    <- plus-unique P1 P2 nat`eq/ EQ1 EQ2.

%worlds () (bound-unique _ _ _ _).
%total (B) (bound-unique B _ _ _).


%theorem bound-total* :
	forall {M} 
	exists {N} {MX:bound M N}
	true.

- : bound-total* map/0 _ bound/0.

- : bound-total* _ _ (bound/+ P MX)
    <- bound-total* _ _ MX
    <- plus-total P.

%worlds () (bound-total* _ _ _).
%total (M) (bound-total* M _ _).


%abbrev bound-total = bound-total* _ _.


%theorem bound-lookup-implies-gt :
        forall* {M} {N} {D} {X}
        forall  {B: bound M X}
                {L: lookup M N D}
        exists  {G: gt X N}
        true.

- : bound-lookup-implies-gt (bound/+ P _) (lookup/= nat`eq/) G
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- plus-implies-gt Psc (nat`eq/) G.

- : bound-lookup-implies-gt (bound/+ P1 B) (lookup/> L P2) G
    <- bound-lookup-implies-gt B L G1
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- plus-left-preserves-gt* G1 P1 P2sc G.

%worlds () (bound-lookup-implies-gt _ _ _).
%total (B) (bound-lookup-implies-gt B _ _).


%theorem ge-bound-implies-not-member :
	forall* {M} {X} {N}
	forall {B:bound M X} {G:nat`ge N X}
	exists {F:not-member M N}
	true.

- : ge-bound-implies-not-member bound/0 _ not-member/0.

- : ge-bound-implies-not-member (bound/+ M1+1+X1=X B) N>=X (not-member/> F1 N1+1+M1=N)
    <- nat`ge-implies-plus N>=X Y1 Y1+X=N
    <- nat`plus-commutative M1+1+X1=X X1+M1+1=X
    <- nat`plus-associative-converse X1+M1+1=X Y1+X=N N1 Y1+X1=N1 N1+M1+1=N
    <- plus-swap-succ-converse N1+M1+1=N N1+1+M1=N
    <- plus-implies-ge Y1+X1=N1 N1>=X1
    <- ge-bound-implies-not-member B N1>=X1 F1.

%worlds () (ge-bound-implies-not-member _ _ _).
%total (B) (ge-bound-implies-not-member B _ _).



%%% Theorems about shift

%theorem false-implies-shift :
	forall* {M} {N} {MP}
	forall {F:void}
	exists {S:shift N M MP}
	true.
%worlds () (false-implies-shift _ _).
%total { } (false-implies-shift _ _).


%theorem shift-respects-eq :
	forall* {N} {M1} {M2} {NP} {M1P} {M2P}
	forall {S:shift N M1 M2} 
               {EN:nat`eq N NP} {E1:eq M1 M1P} {E2:eq M2 M2P}
        exists {SP:shift NP M1P M2P}
	true.

- : shift-respects-eq S nat`eq/ eq/ eq/ S.

%worlds () (shift-respects-eq _ _ _ _ _).
%total { } (shift-respects-eq _ _ _ _ _).


%theorem shift-total* :
	forall {N} {M1}
	exists {M2} {S:shift N M1 M2}
	true.

- : shift-total* N map/0 map/0 shift/0.

- : shift-total* N1 (map/+ N2 D M) (map/+ N3 D M) (shift/+ N1+1+N2=N3)
    <- plus-total N1+1+N2=N3.

%worlds () (shift-total* _ _ _ _).
%total { } (shift-total* _ _ _ _).

%abbrev shift-total = shift-total* _ _ _.


%theorem shift-deterministic :
	forall* {N} {M1} {M2} {NP} {M1P} {M2P}
	forall {S:shift N M1 M2} {SP:shift NP M1P M2P}
	       {EN:nat`eq N NP} {EM1:eq M1 M1P}
	exists {EM2:eq M2 M2P}
	true.

%abbrev shift-unique = shift-deterministic.

- : shift-deterministic shift/0 shift/0 nat`eq/ eq/ eq/.

- : shift-deterministic (shift/+ N1+1+N2=N3) (shift/+ N1+1+N2=N3P) nat`eq/ eq/ E
    <- plus-deterministic N1+1+N2=N3 N1+1+N2=N3P nat`eq/ nat`eq/ N3=N3P
    <- map/+-preserves-eq N3=N3P unit`eq/ eq/ E.

%worlds () (shift-deterministic _ _ _ _ _).
%total { } (shift-deterministic _ _ _ _ _).


%theorem shift-cancels :
	forall* {N} {M1} {M2} {NP} {M1P} {M2P}
	forall {S:shift N M1 M2} {SP:shift NP M1P M2P}
	       {EN:nat`eq N NP} {EM1:eq M2 M2P}
	exists {EM2:eq M1 M1P}
	true.

- : shift-cancels shift/0 shift/0 nat`eq/ eq/ eq/.

- : shift-cancels (shift/+ N1+1+N2=N3) (shift/+ N1+1+N2P=N3) nat`eq/ eq/ E
    <- plus-left-cancels N1+1+N2=N3 N1+1+N2P=N3 nat`eq/ nat`eq/ N2=N2P
    <- map/+-preserves-eq N2=N2P unit`eq/ eq/ E.

%worlds () (shift-cancels _ _ _ _ _).
%total { } (shift-cancels _ _ _ _ _).


%theorem shifts-add :
	forall* {N1} {N2} {N3} {M0} {M1} {M3}
	forall {S1:shift N1 M0 M1} {S2:shift N2 M1 M3} {P:plus (s N1) N2 N3}
        exists {S3:shift N3 M0 M3}
	true.

- : shifts-add shift/0 shift/0 _ shift/0.

- : shifts-add (shift/+ N1+1+N4=N5) (shift/+ N2+1+N5=N7) N1+1+N2=N3
               (shift/+ N3+1+N4=N7)          
    <- plus-total N3+1+N4=N7P
    <- plus-swap-succ N3+1+N4=N7P N3+N4+1=N7P
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-swap-succ N1+1+N4=N5 N1+N4+1=N5
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- plus-associative* N2+1+N1=N3 N3+N4+1=N7P N1+N4+1=N5 N2+1+N5=N7P
    <- plus-deterministic N2+1+N5=N7P N2+1+N5=N7 nat`eq/ nat`eq/ N7P=N7
    <- plus-respects-eq N3+1+N4=N7P nat`eq/ nat`eq/ N7P=N7 N3+1+N4=N7.

%worlds () (shifts-add _ _ _ _).
%total { } (shifts-add _ _ _ _).


%theorem shifts-add-converse :
	forall* {N1} {N2} {N3} {M0} {M3}
	forall {S3:shift N3 M0 M3} {P:plus (s N1) N2 N3}
	exists {M1} {S1:shift N1 M0 M1} {S2:shift N2 M1 M3}
        true.

- : shifts-add-converse S3 P M1 S1 S2
    <- shift-total S1
    <- shift-total S2P
    <- shifts-add S1 S2P P S3P
    <- shift-deterministic S3P S3 nat`eq/ eq/ M3P=M3
    <- shift-respects-eq S2P nat`eq/ eq/ M3P=M3 S2.

%worlds () (shifts-add-converse _ _ _ _ _).
%total { } (shifts-add-converse _ _ _ _ _).


%theorem shift-preserves-not-member :
        forall* {M1} {N1} {N2} {N0}
        forall	{L1:not-member M1 N1}
        	{P:plus (s N0) N1 N2} 
	exists	{M2} {S:shift N0 M1 M2}
		{L2:not-member M2 N2} 
	true.
	
- : shift-preserves-not-member not-member/0 P _ shift/0 not-member/0.

- : shift-preserves-not-member 
	(not-member/< G) P _ (shift/+ PP)
	(not-member/< GP)
    <- plus-total PP
    <- plus-left-preserves-gt* G PP P GP.

- : shift-preserves-not-member
	(not-member/> F D+1+N3=N1) N0+1+N1=N2 _ (shift/+ N0+1+N3=N4)
	(not-member/> F D+1+N4=N2)
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative D+1+N3=N1 N1+N0+1=N2 N4 N3+N0+1=N4 D+1+N4=N2
    <- plus-commutative N3+N0+1=N4 N0+1+N3=N4.

%worlds () (shift-preserves-not-member _ _ _ _ _).
%total (F) (shift-preserves-not-member F _ _ _ _).


%theorem shift-preserves-not-member* :
        forall* {M1} {N1} {N2} {N0} {M2}
        forall	{L1:not-member M1 N1}
        	{P:plus (s N0) N1 N2} 
		{S:shift N0 M1 M2}
	exists	{L2:not-member M2 N2} 
	true.
	
- : shift-preserves-not-member* F P S1 FP1
    <- shift-preserves-not-member F P _ S2 FP2
    <- shift-deterministic S2 S1 nat`eq/ eq/ EQ
    <- not-member-respects-eq FP2 EQ nat`eq/ FP1.

%worlds () (shift-preserves-not-member* _ _ _ _).
%total { } (shift-preserves-not-member* _ _ _ _).


%theorem shift-preserves-not-member-converse* :
        forall* {M1} {N1} {N2} {M2} {N0}
	forall {L2:not-member M2 N2} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2} 
        exists {L1:not-member M1 N1}
	true.

- : shift-preserves-not-member-converse* not-member/0 shift/0 _ not-member/0.

- : shift-preserves-not-member-converse* 
	(not-member/< N1>N) (shift/+ S+1+N2=N1) S+1+NP=N
	(not-member/< N2>NP)
    <- plus-left-cancels-gt S+1+N2=N1 S+1+NP=N nat`eq/ N1>N N2>NP.

- : shift-preserves-not-member-converse* 
	(not-member/> F NX+1+N2=N) (shift/+ S+1+N1=N2) S+1+NP=N
        (not-member/> F NX+1+N1=NP)
    <- plus-commutative S+1+N1=N2 N1+S+1=N2
    <- plus-associative-converse N1+S+1=N2 NX+1+N2=N NPP NX+1+N1=NPP NPP+S+1=N
    <- plus-commutative NPP+S+1=N S+1+NPP=N
    <- plus-left-cancels S+1+NPP=N S+1+NP=N nat`eq/ nat`eq/ NPP=NP
    <- plus-respects-eq NX+1+N1=NPP nat`eq/ nat`eq/ NPP=NP NX+1+N1=NP.

%worlds () (shift-preserves-not-member-converse* _ _ _ _).
%total { } (shift-preserves-not-member-converse* _ _ _ _).


%theorem shift-preserves-lookup :
        forall* {M1} {N1} {D} {N0} {M2}
	forall {L1:lookup M1 N1 D} {S:shift N0 M1 M2}
        exists {N2} {P:plus (s N0) N1 N2} {L2:lookup M2 N2 D}
	true.

- : shift-preserves-lookup (lookup/= nat`eq/) (shift/+ N0+1+N1=N2) _
                           N0+1+N1=N2 (lookup/= nat`eq/).

- : shift-preserves-lookup (lookup/> L N3+1+N1=N4) (shift/+ N0+1+N1=N2) _
                           N0+1+N4=N5 (lookup/> L N3+1+N2=N5)
    <- plus-total N0+1+N4=N5
    <- plus-commutative N3+1+N1=N4 N1+N3+1=N4
    <- plus-associative-converse* N1+N3+1=N4 N0+1+N4=N5 N0+1+N1=N2 N2+N3+1=N5
    <- plus-commutative N2+N3+1=N5 N3+1+N2=N5.

%worlds () (shift-preserves-lookup _ _ _ _ _).
%total { } (shift-preserves-lookup _ _ _ _ _).


%theorem shift-preserves-lookup* :
        forall* {M1} {N1} {D} {N0} {M2} {N2}
	forall {L1:lookup M1 N1 D} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2} 
        exists {L2:lookup M2 N2 D}
	true.

- : shift-preserves-lookup* L1 S P L2
    <- shift-preserves-lookup L1 S _ PP L2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- lookup-respects-eq L2P eq/ N2P=N2 unit`eq/ L2.

%worlds () (shift-preserves-lookup* _ _ _ _).
%total { } (shift-preserves-lookup* _ _ _ _).


%theorem shift-preserves-lookup-converse :
        forall* {M1} {N0} {D} {N2} {M2}
	forall {L2:lookup M2 N2 D} {S:shift N0 M1 M2}
        exists {N1} {P:plus (s N0) N1 N2} {L1:lookup M1 N1 D}
	true.

- : shift-preserves-lookup-converse (lookup/= nat`eq/) (shift/+ N0+1+N1=N2) _
                                    N0+1+N1=N2 (lookup/= nat`eq/).

- : shift-preserves-lookup-converse (lookup/> L N3+1+N2=N5) (shift/+ N0+1+N1=N2)
                                    _ N0+1+N4=N5 (lookup/> L N3+1+N1=N4)
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse N1+N0+1=N2 N3+1+N2=N5 N4 N3+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.

%worlds () (shift-preserves-lookup-converse _ _ _ _ _).
%total { } (shift-preserves-lookup-converse _ _ _ _ _).


%theorem shift-preserves-lookup-converse* :
        forall* {M1} {N1} {D} {N2} {M2} {N0}
	forall {L2:lookup M2 N2 D} {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2} 
        exists {L1:lookup M1 N1 D}
	true.

- : shift-preserves-lookup-converse* L2 S P L1
    <- shift-preserves-lookup-converse L2 S _ PP L1P
    <- plus-left-cancels PP P nat`eq/ nat`eq/ N1P=N1
    <- lookup-respects-eq L1P eq/ N1P=N1 unit`eq/ L1.

%worlds () (shift-preserves-lookup-converse* _ _ _ _).
%total { } (shift-preserves-lookup-converse* _ _ _ _).


%theorem shift-implies-not-member* :
	forall* {M} {N1} {N} {NM}
	forall	{SH:shift N M NM}
		{GE:nat`ge N N1}
	exists	{F:not-member NM N1}
	true.

- : shift-implies-not-member* shift/0 _ not-member/0.

- : shift-implies-not-member* 
     (shift/+ SN+N1=N1P) N>=NP
     (not-member/< N1P>NP)
    <- plus-commutative SN+N1=N1P N1+SN=N1P
    <- plus-implies-ge N1+SN=N1P N1P>=SN
    <- ge-succ-implies-gt N1P>=SN N1P>N
    <- gt-transitive-ge N1P>N N>=NP N1P>NP.

%worlds () (shift-implies-not-member* _ _ _).
%total { } (shift-implies-not-member* _ _ _).


%theorem shift-implies-not-member :
	forall* {M} {N} {NM}
	forall	{SH:shift N M NM}
	exists	{F:not-member NM N}
	true.

- : shift-implies-not-member SH F
    <- shift-implies-not-member* SH (nat`ge/= nat`eq/) F.

%worlds () (shift-implies-not-member _ _).
%total { } (shift-implies-not-member _ _).


%theorem removal-preserves-not-member :
	forall*	{N1} {D} {M1} {N2} {M2}
	forall	{F1: not-member (map/+ N1 D M1) N2}
		{S: shift N1 M1 M2}
	exists	{F2: not-member M2 N2}
	true.

- : removal-preserves-not-member _ _ not-member/0.

- : removal-preserves-not-member (not-member/< GT1) (shift/+ P) (not-member/< GT2)
    <- plus-swap-succ P PS
    <- plus-commutative PS PSC
    <- plus-implies-gt PSC nat`eq/ GT3
    <- gt-transitive GT3 GT1 GT2.

- : removal-preserves-not-member (not-member/> F1 P1) (shift/+ P2) F2
    <- plus-swap-succ P1 PS1
    <- plus-commutative PS1 PSC1
    <- shift-preserves-not-member* F1 PSC1 
	(shift/+ P2) F2.

%worlds () (removal-preserves-not-member _ _ _).
%total { } (removal-preserves-not-member _ _ _).


%theorem shift-preserves-size :
	forall* {M} {N1} {N2} {S2M}
	forall {SZ:size M N1} {SH:shift N2 M S2M}
	exists {SHSZ:size S2M N1}
	true.

- : shift-preserves-size size/0 shift/0 size/0.

- : shift-preserves-size (size/+ SZ) (shift/+ _) (size/+ SZ).

%worlds () (shift-preserves-size _ _ _).
%total { } (shift-preserves-size _ _ _).



%%% Theorems about disjoint?


%theorem disjoint?-total* :
	forall {M1} {M2}
	exists {B} {D:disjoint? M1 M2 B}
	true.

- : disjoint?-total* _ _ _ (disjoint?/yes disjoint/L).

- : disjoint?-total* _ _ _ (disjoint?/yes disjoint/R).

%theorem disjoint?-total*/+ :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {C}
	forall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2} {CMP:nat`compare N1 N2 C}
	exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

%theorem disjoint?-total*/< :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0} {B1}
	forall {P:plus (s N0) N1 N2}
               {D?1:disjoint? M1 (map/+ N0 D2 M2) B1}
	exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

%theorem disjoint?-total*/> :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {B1}
	forall {P:plus (s N3) N2 N1}
               {D?1:disjoint? (map/+ N3 D1 M1) M2 B1}
	exists {B} {D:disjoint? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

- : disjoint?-total* _ _ _ D?
    <- size-total SZ1
    <- size-total SZ2
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?.

- : disjoint?-total*/+ _ _ _ _ (nat`compare/=) _ 
                       (disjoint?/no (lookup/= nat`eq/) (lookup/= nat`eq/)).

- : disjoint?-total*/+ _ _ _ _ (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- disjoint?-total*/< N0+1+N1=N2 (disjoint?/yes disjoint/L) _ D?.

- : disjoint?-total*/+ _ _ (size/+ SZ1) SZ2 (nat`compare/< N2>N1) _ D?
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- disjoint?-total*/< N0+1+N1=N2 D?1 _ D?.

- : disjoint?-total*/< N0+1+N1=N2 (disjoint?/yes M1*M022) _
                       (disjoint?/yes (disjoint/< M1*M022 N0+1+N1=N2)).

- : disjoint?-total*/< N0+1+N1=N2 (disjoint?/no M1^N3=D1 M022^N3=D2) _
                       (disjoint?/no (lookup/> M1^N3=D1 N3+1+N1=N4) M222^N4=D2)
    <- plus-total N3+1+N1=N4
    <- plus-swap-succ N3+1+N1=N4 N3+N1+1=N4
    <- plus-commutative N3+N1+1=N4 N1+1+N3=N4
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-preserves-lookup* M022^N3=D2 (shift/+ N1+1+N0=N2) N1+1+N3=N4
                               M222^N4=D2.

%worlds () (disjoint?-total*/< _ _ _ _).
%total { } (disjoint?-total*/< _ _ _ _).

- : disjoint?-total*/+ _ _ _ _ (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- disjoint?-total*/> N3+1+N2=N1 (disjoint?/yes disjoint/R) _ D?.

- : disjoint?-total*/+ _ _ SZ1 (size/+ SZ2) (nat`compare/> N1>N2) _ D?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- nat`compare-total CMP
    <- disjoint?-total*/+ _ _ SZ1 SZ2 CMP _ D?1
    <- disjoint?-total*/> N3+1+N2=N1 D?1 _ D?.

- : disjoint?-total*/> P (disjoint?/yes D) _ (disjoint?/yes (disjoint/> D P)).

- : disjoint?-total*/> N3+1+N2=N1 (disjoint?/no M311^N4=D1 M2^N4=D2) _
                       (disjoint?/no M111^N5=D1 (lookup/> M2^N4=D2 N4+1+N2=N5))
    <- plus-total N4+1+N2=N5
    <- plus-swap-succ N4+1+N2=N5 N4+N2+1=N5
    <- plus-commutative N4+N2+1=N5 N2+1+N4=N5
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- shift-preserves-lookup* M311^N4=D1 (shift/+ N2+1+N3=N1) N2+1+N4=N5
                               M111^N5=D1.

%worlds () (disjoint?-total*/> _ _ _ _).
%total { } (disjoint?-total*/> _ _ _ _).

%worlds () (disjoint?-total*/+ _ _ _ _ _ _ _).
%total [S1 S2] (disjoint?-total*/+ S1 S2 _ _ _ _ _).

%worlds () (disjoint?-total* _ _ _ _).
%total { } (disjoint?-total* _ _ _ _).

%abbrev disjoint?-total = disjoint?-total* _ _ _.



%%% Theorems about update


%theorem false-implies-update :
	forall* {M} {N} {D} {MP} 
	forall {F:void} 
	exists {U:update M N D MP} 
	true.
%worlds () (false-implies-update _ %{=>}% M^N=D->MP).
%total {} (false-implies-update _ _).


%theorem update-respects-eq :
	forall* {M1} {N} {D} {M2} {M1P} {NP} {DP} {M2P}
	forall {U:update M1 N D M2} {EM1:eq M1 M1P} 
               {EN:nat`eq N NP} {ED:unit`eq D DP} {EM2:eq M2 M2P}
	exists {UP:update M1P NP DP M2P} 
	true.
- : update-respects-eq U eq/ nat`eq/ unit`eq/ eq/ U.
%worlds () (update-respects-eq M1^N=D->M2 M1=M1P N=NP D=DP M2=M2P 
                        %{=>}% M1P^NP=DP->M2P).
%total {} (update-respects-eq _ _ _ _ _ _).
%reduces U = UP (update-respects-eq U _ _ _ _ UP).


%% a technical lemma to help prove reduction arguments

%theorem meta-reduces-update :
	forall*	{M1} {M2} {N1} {N2} {D1} {D2} {M1P} {M2P}
	forall	{F: void}
		{L1: update M1 N1 D1 M1P}
		{L2: update M2 N2 D2 M2P}
	true.

%worlds () (meta-reduces-update _ _ _).
%total { } (meta-reduces-update _ _ _).
%reduces X < Y (meta-reduces-update _ X Y).


%theorem update/=-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2}
	forall {U:update (map/+ N1 D1 M1) N2 D2 M2} {E:nat`eq N1 N2}
        exists {EM:eq (map/+ N2 D2 M1) M2}
	true.

- : update/=-inversion (update/= nat`eq/) nat`eq/ eq/.

- : update/=-inversion (update/< N3+1+N=N) nat`eq/ E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update/=-inversion (update/> U1022 N3+1+N=N) nat`eq/ E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

%worlds () (update/=-inversion _ _ _).
%total { } (update/=-inversion _ _ _).


%theorem update/<-inversion:
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
	forall {U:update (map/+ N1 D1 M1) N2 D2 M2} {P:plus (s N3) N2 N1}
	exists {E:eq (map/+ N2 D2 (map/+ N3 D1 M1)) M2}
	true.

- : update/<-inversion (update/= nat`eq/) N3+1+N=N E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update/<-inversion (update/< N3+1+N2=N1) N3P+1+N2=N1 E
    <- nat`plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- nat`succ-cancels N3P+1=N3+1 N3P=N3
    <- map/+-preserves-eq N3P=N3 unit`eq/ eq/ M311P=M311
    <- map/+-preserves-eq nat`eq/ unit`eq/ M311P=M311 E.

- : update/<-inversion (update/> _ N0+1+N1=N2) N3+1+N2=N1 E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (update/<-inversion _ _ _).
%total { } (update/<-inversion _ _ _).


%theorem update/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M} {N0}
	forall {U:update (map/+ N1 D1 M1) N2 D2 M} {P:plus (s N0) N1 N2}
	exists {M2} {UP:update M1 N0 D2 M2} {E:eq (map/+ N1 D1 M2) M}
	true.

% a little more complex than might be expected
% because we want to prove reduction
- : update/>-inversion (U: update (map/+ N D1 M1) N D2 (map/+ N D2 M1))
                       N0+1+N=N M1 UP E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E
    <- false-implies-update F UP
    <- meta-reduces-update F UP U.

- : update/>-inversion 
	(update/< N3+1+N2=N1: update (map/+ N1 D1 M1) N2 D2 _) 
        N0+1+N1=N2 M1 UP E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-update F UP
    <- false-implies-eq F E
    <- meta-reduces-update 
	F UP (update/< N3+1+N2=N1: update (map/+ N1 D1 M1) N2 D2 _).

- : update/>-inversion (update/> U N0+1+N1=N2) N0P+1+N1=N2 _ UP eq/ 
    <- nat`plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- nat`succ-cancels N0+1=N0P+1 N0=N0P
    <- update-respects-eq U eq/ N0=N0P unit`eq/ eq/ UP.

%worlds () (update/>-inversion _ _ _ _ _).
%total { } (update/>-inversion _ _ _ _ _).
%reduces UP < U (update/>-inversion U _ _ UP _).


% the resulting map rather than the initial map is addressed
%theorem update/>-inversion* :
	forall* {N1} {D1} {M1} {N2} {D2} {M} {N0}
	forall {U:update M N2 D2 (map/+ N1 D1 M1)} {P:plus (s N0) N1 N2}
	exists {M0} {UP:update M0 N0 D2 M1} {E:eq (map/+ N1 D1 M0) M}
	true.

- : update/>-inversion* (update/0:update _ N D _) P map/0 UP EQ
    <- plus-implies-gt P nat`eq/ GT
    <- gt-anti-reflexive GT F
    <- false-implies-update F UP
    <- false-implies-eq F EQ
    <- meta-reduces-update F UP (update/0:update _ N D _).

- : update/>-inversion* (update/= nat`eq/:update (map/+ N1 D1 M1) _ D _) P 
	map/0 UP EQ
    <- plus-implies-gt P nat`eq/ GT
    <- gt-anti-reflexive GT F
    <- false-implies-update F UP
    <- false-implies-eq F EQ
    <- meta-reduces-update F UP
	(update/= nat`eq/:update (map/+ N1 D1 M1) _ D _).

- : update/>-inversion* (update/< P1: update (map/+ N1 D1 M1) N D _) P map/0 
	UP EQ
    <- plus-implies-gt P nat`eq/ GT
    <- gt-anti-reflexive GT F
    <- false-implies-update F UP
    <- false-implies-eq F EQ
    <- meta-reduces-update F UP (update/< P1: update (map/+ N1 D1 M1) N D _).

- : update/>-inversion* (update/> UP1 P1) P _ UP eq/
    <- plus-right-cancels P1 P nat`eq/ nat`eq/ SN1=SN
    <- succ-cancels SN1=SN N1=N
    <- update-respects-eq UP1 eq/ N1=N unit`eq/ eq/ UP.

%worlds () (update/>-inversion* _ _ _ _ _).
%total { } (update/>-inversion* _ _ _ _ _).
%reduces UP < U (update/>-inversion* U _ _ UP _).


%theorem update-contradiction :
	forall* {M} {N} {D}
	forall	{U: update M N D map/0}
	exists	{F: void}
	true.

%worlds () (update-contradiction _ _).
%total { } (update-contradiction _ _).


%theorem update-deterministic :
	forall* {M1} {N1} {D1} {M1P} {M2} {N2} {D2} {M2P}
	forall {U1:update M1 N1 D1 M1P} {U2:update M2 N2 D2 M2P}
	       {EM:eq M1 M2} {EN:nat`eq N1 N2} {ED:unit`eq D1 D2}
	exists {EMP:eq M1P M2P}
	true.

%abbrev update-unique = update-deterministic.

- : update-deterministic update/0 update/0 eq/ nat`eq/ unit`eq/ eq/.

- : update-deterministic (update/= nat`eq/) (update/= nat`eq/) eq/ nat`eq/ unit`eq/ eq/.

- : update-deterministic (update/< N3+1+N2=N1) (update/< N3P+1+N2=N1)
                         eq/ nat`eq/ unit`eq/ M1P=M2P
    <- plus-right-cancels N3+1+N2=N1 N3P+1+N2=N1 nat`eq/ nat`eq/ SN3=SN3P
    <- succ-cancels SN3=SN3P N3E
    <- map/+-preserves-eq N3E unit`eq/ eq/ MM1=MM2
    <- map/+-preserves-eq nat`eq/ unit`eq/ MM1=MM2 M1P=M2P.

- : update-deterministic (update/> F1^N0=D2->F2 N0+1+N1=N2)
                         (update/> F1^N0P=D2->F2P N0P+1+N1=N2)
                         eq/ nat`eq/ unit`eq/ M1P=M2P
    <- plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- update-deterministic F1^N0=D2->F2 F1^N0P=D2->F2P eq/ N0=N0P 
                            unit`eq/ F2=F2P
    <- map/+-preserves-eq nat`eq/ unit`eq/ F2=F2P M1P=M2P.

%% contradiction cases:
- : update-deterministic (update/= nat`eq/) (update/< N3+1+N=N) eq/ nat`eq/ unit`eq/ E
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/= nat`eq/) (update/> _ N0+1+N=N) eq/ nat`eq/ unit`eq/ E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/< N3+1+N=N) (update/= nat`eq/) eq/ nat`eq/ unit`eq/ E
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/< N3+1+N2=N1) (update/> _ N0+1+N1=N2)
                         eq/ nat`eq/ unit`eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

- : update-deterministic (update/> _ N0+1+N=N) (update/= nat`eq/) eq/ nat`eq/ unit`eq/ E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : update-deterministic (update/> _ N0+1+N1=N2) (update/< N3+1+N2=N1)
                         eq/ nat`eq/ unit`eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (update-deterministic M1^N1=D1->M1P M2^N2=D2->M2P M1=M2 N1=N2 D1=D2
                          %{=>}% M1P=M2P).
%total (U) (update-deterministic U _ _ _ _ _).


%theorem update-total* :
	forall {M} {N} {D}
	exists {MP} {U:update M N D MP}
	true.

%% we need a mutually recursive lemma
%theorem update-map/+-total :
	forall {N1} {D1} {M1} {N2} {D2} {C} {CMP:nat`compare N1 N2 C}
	exists {M2} {U:update (map/+ N1 D1 M1) N2 D2 M2}
	true.

- : update-total* map/0 N D (map/+ N D map/0) update/0.

- : update-total* (map/+ N1 D1 M1) N2 D2 M2 U
    <- nat`compare-total* N1 N2 C CMP
    <- update-map/+-total N1 D1 M1 N2 D2 C CMP M2 U.

- : update-map/+-total N1 D1 M1 N2 D2 equal CMP (map/+ N2 D2 M1) (update/= N1=N2)
    <- equal-implies-eq CMP N1=N2.

- : update-map/+-total N1 D1 M1 N2 D2 less CMP (map/+ N1 D1 M1P)
                       (update/> U1 N0+1+N1=N2)
    <- less-implies-lt CMP N2>N1
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- update-total* M1 N0 D2 M1P U1.

- : update-map/+-total N1 D1 M1 N2 D2 greater CMP (map/+ N2 D2 (map/+ N3 D1 M1))
                       (update/< N3+1+N2=N1)
    <- greater-implies-gt CMP N1>N2
    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1.

%worlds () (update-total* M N D %{=>}% MP M^N=D->MP)
           (update-map/+-total _ _ _ _ _ _ _ _ _).
%total (M1 M2) (update-total* M1 _ _ _ _) (update-map/+-total _ _ M2 _ _ _ _ _ _).

%abbrev update-total = update-total* _ _ _ _.


%theorem lookup-implies-update :
        forall* {F} {N} {D}
        forall {L:lookup F N D}
        exists {U:update F N D F} 
        true.
        
- : lookup-implies-update (lookup/= nat`eq/) (update/= nat`eq/).

- : lookup-implies-update (lookup/> L P) (update/> U P)
    <- lookup-implies-update L U.

%worlds () (lookup-implies-update _ _).
%total (L) (lookup-implies-update L _).


%theorem lookup-implies-not-member-update :
        forall* {M2} {N} {D}
        forall	{L:lookup M2 N D}
	exists	{M1}
		{F: not-member M1 N} 
        	{U:update M1 N D M2} 
        true.

- : lookup-implies-not-member-update (lookup/= nat`eq/) _ not-member/0 update/0.

- : lookup-implies-not-member-update (lookup/= nat`eq/) _ (not-member/< GT) (update/< P)
    <- plus-total P
    <- plus-implies-gt P nat`eq/ GT.

- : lookup-implies-not-member-update (lookup/> L P) _ (not-member/> F P) (update/> U P)
    <- lookup-implies-not-member-update L _ F U.

%worlds () (lookup-implies-not-member-update _ _ _ _).
%total (L) (lookup-implies-not-member-update L _ _ _).


%theorem update-implies-lookup :
	forall* {F} {N} {D} {FP}
	forall {U:update F N D FP} 
	exists {L:lookup FP N D}
	true.

- : update-implies-lookup update/0 (lookup/= nat`eq/).

- : update-implies-lookup (update/= nat`eq/) (lookup/= nat`eq/).

- : update-implies-lookup (update/< _) (lookup/= nat`eq/).

- : update-implies-lookup (update/> F^N0=D2->FP N0+1+N1=N2)
                          (lookup/> FP^N0=D2    N0+1+N1=N2)
    <- update-implies-lookup F^N0=D2->FP FP^N0=D2.

%worlds () (update-implies-lookup F^N=D->FP %{=>}% FP^N=D).
%total (U) (update-implies-lookup U _).


%theorem update-preserves-lookup :
	forall* {F} {N1} {D1} {FP} {N2} {D2}
	forall {L:lookup F N2 D2} {U:update F N1 D1 FP} {X:nat`ne N2 N1}
        exists {LP:lookup FP N2 D2}
	true.

%% update/0 is impossible

- : update-preserves-lookup (lookup/= nat`eq/) (update/= nat`eq/) N<>N LP
    <- nat`ne-anti-reflexive N<>N FALSE
    <- false-implies-lookup FALSE LP.

- : update-preserves-lookup (lookup/> L1 P1) (update/= nat`eq/) _ (lookup/> L1 P1).

- : update-preserves-lookup (lookup/= nat`eq/) (update/< N3+1+N2=N1) _ 
                            (lookup/> (lookup/= nat`eq/) N3+1+N2=N1).

- : update-preserves-lookup (lookup/> L N0+1+N1=N2P) (update/< N3+1+N2=N1) _
			    (lookup/> (lookup/> L N0+1+N3=N4)
			              N4+1+N2=N2P)
    <- plus-left-decrease N3+1+N2=N1 N1-1 N1=N1-1+1 N3+N2=N1-1
    <- plus-right-increase N3+N2=N1-1 N3+N2+1=N1-1+1
    <- nat`eq-symmetric N1=N1-1+1 N1-1+1=N1
    <- plus-respects-eq N3+N2+1=N1-1+1 nat`eq/ nat`eq/ N1-1+1=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N0+1+N1=N2P N4 N0+1+N3=N4
                                N4+N2+1=N2P
    <- plus-swap-succ-converse N4+N2+1=N2P N4+1+N2=N2P.

- : update-preserves-lookup (lookup/= nat`eq/) (update/> _ _) _ (lookup/= nat`eq/).

- : update-preserves-lookup (lookup/> L N0+1+N1=N2) 
                            ((update/> U N0P+1+N1=N2P) 
                             : update (map/+ N1 D1 M1) N2P DP 
                                      (map/+ N1 D1 M1P))
                            N2<>N2P 
                            ((lookup/> LP N0+1+N1=N2) 
                             : lookup (map/+ N1 D1 M1P) N2 D)
    <- plus-right-cancels-ne N0+1+N1=N2 N0P+1+N1=N2P nat`eq/ N2<>N2P N0+1<>N0P+1
    <- succ-preserves-ne-converse N0+1<>N0P+1 N0<>N0P
    <- update-preserves-lookup L U N0<>N0P LP.

%worlds () (update-preserves-lookup F^N2=D2 F^N1=D1->FP N1<>N2 FP^N2=D2).
%total (L) (update-preserves-lookup L _ _ _).


%theorem update-preserves-lookup-converse :
	forall* {F1} {N1} {D1} {F2} {N2} {D2}
	forall {L2:lookup F2 N2 D2} {U:update F1 N1 D1 F2} {X:nat`ne N2 N1}
        exists {L1:lookup F1 N2 D2}
	true.

- : update-preserves-lookup-converse (lookup/= nat`eq/) update/0 N<>N L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/= nat`eq/) N<>N
                                     L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/< N3+1+N2=N1)
                                     N<>N L1
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

- : update-preserves-lookup-converse (lookup/= nat`eq/) (update/> _ _) _
                                     (lookup/= nat`eq/).

- : update-preserves-lookup-converse (lookup/> L1 P) (update/= nat`eq/) _
                                     (lookup/> L1 P).

- : update-preserves-lookup-converse (lookup/> (lookup/= nat`eq/) N3+1+N2=N4)
                                     (update/< N3+1+N2=N1) _
                                     (lookup/= N1=N4)
    <- plus-deterministic N3+1+N2=N1 N3+1+N2=N4 nat`eq/ nat`eq/ N1=N4.

- : update-preserves-lookup-converse (lookup/> (lookup/> L1 N6+1+N3=N5) 
                                               N5+1+N2=N4)
                                     (update/< N3+1+N2=N1) _
                                     (lookup/> L1 N6+1+N1=N4)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-swap-succ N5+1+N2=N4 N5+N2+1=N4
    <- plus-associative* N6+1+N3=N5 N5+N2+1=N4 N3+N2+1=N1 N6+1+N1=N4.

- : update-preserves-lookup-converse (lookup/> L2 N5+1+N1=N4)
                                     (update/> U1 N0+1+N1=N2) N4<>N2
                                     (lookup/> L1 N5+1+N1=N4)
    <- plus-right-cancels-ne N5+1+N1=N4 N0+1+N1=N2 nat`eq/ N4<>N2 N5+1<>N0+1
    <- succ-preserves-ne-converse N5+1<>N0+1 N5<>N0
    <- update-preserves-lookup-converse L2 U1 N5<>N0 L1.

%worlds () (update-preserves-lookup-converse _ _ _ _).
%total (L) (update-preserves-lookup-converse L _ _ _).


%theorem update-preserves-not-member :
	forall* {M1} {N1} {N2} {D} {M2}
	forall {F1:not-member M1 N1} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
	exists {F2:not-member M2 N1}
	true.

- : update-preserves-not-member not-member/0 update/0 (nat`ne/< N>M) (not-member/< N>M).

- : update-preserves-not-member not-member/0 update/0 (nat`ne/> M>N) 
                           (not-member/> not-member/0 M1+1+N=M)
    <- gt-implies-plus M>N M1 M1+1+N=M.

- : update-preserves-not-member (not-member/< N>M) (update/= nat`eq/) _ (not-member/< N>M).

- : update-preserves-not-member (not-member/< N1>M) (update/< N3+1+N2=N1) (nat`ne/< N2>M)
                           (not-member/< N2>M).

- : update-preserves-not-member (not-member/< N1>M) (update/< N3+1+N2=N1) (nat`ne/> M>N2)
                           (not-member/> (not-member/< N3>M1) M1+1+N2=M)
    <- gt-implies-plus M>N2 M1 M1+1+N2=M
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-swap-succ M1+1+N2=M  M1+N2+1=M
    <- plus-right-cancels-gt N3+N2+1=N1 M1+N2+1=M nat`eq/ N1>M N3>M1.

- : update-preserves-not-member (not-member/< N1>M) (update/> _ _) _ (not-member/< N1>M).

- : update-preserves-not-member (not-member/> F P) (update/= nat`eq/) _ (not-member/> F P).

- : update-preserves-not-member (not-member/> F M1+1+N1=M) (update/< N3+1+N2=N1) _
                           (not-member/> (not-member/> F M1+1+N3=MM) MM+1+N2=M)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 M1+1+N1=M MM M1+1+N3=MM
                                 MM+N2+1=M
    <- plus-swap-succ-converse MM+N2+1=M MM+1+N2=M.

- : update-preserves-not-member (not-member/> F M1+1+N1=M) (update/> U N0+1+N1=N2) M<>N2
                           (not-member/> FP M1+1+N1=M)
    <- plus-right-cancels-ne M1+1+N1=M N0+1+N1=N2 nat`eq/ M<>N2 M1+1<>N0+1
    <- succ-preserves-ne-converse M1+1<>N0+1 M1<>N0
    <- update-preserves-not-member F U M1<>N0 FP.

%worlds () (update-preserves-not-member N1-not-member-M1 M1^N2=D->M2 N1<>N2 N1-not-member-M2).
%total (F) (update-preserves-not-member F _ _ _).


%theorem update-preserves-not-member-converse :
	forall* {M1} {N1} {N2} {D} {M2}
	forall {F1:not-member M2 N1} {U:update M1 N2 D M2}
	exists {F2:not-member M1 N1}
	true.

%theorem update-preserves-not-member-converse-helper :
	forall* {M1} {N1} {N2} {D} {M2} {B} {B2}
	forall {F1:not-member M2 N1} {U:update M1 N2 D M2}
               {D:member? M1 N1 B} {E:nat`eq? N1 N2 B2}
	exists {F2:not-member M1 N1}
	true.

- : update-preserves-not-member-converse-helper _ _ (member?/out F) _ F.

- : update-preserves-not-member-converse-helper F2 U (member?/in L1) (nat`eq?/no N) F1
    <- update-preserves-lookup L1 U N L2
    <- not-member-lookup-not-equal F2 L2 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-not-member F F1.

- : update-preserves-not-member-converse-helper F2 U _ nat`eq?/yes F1
    <- update-implies-lookup U L2
    <- not-member-lookup-not-equal F2 L2 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-not-member F F1.

%worlds () (update-preserves-not-member-converse-helper _ _ _ _ _).
%total { } (update-preserves-not-member-converse-helper _ _ _ _ _).

- : update-preserves-not-member-converse F2 U F1
    <- member?-total D
    <- nat`eq?-total E
    <- update-preserves-not-member-converse-helper F2 U D E F1.

%worlds () (update-preserves-not-member-converse _ _ _).
%total { } (update-preserves-not-member-converse _ _ _).


%theorem update-is-cause-of-change :
	forall* {M1} {N1} {N2} {M2} {D1} {D2}
	forall {F:not-member M1 N1}
	       {U:update M1 N2 D2 M2}
	       {L:lookup M2 N1 D1}
	exists {EN:nat`eq N1 N2} {ED:unit`eq D1 D2}
	true.

%theorem update-is-cause-of-change/L :
	forall* {M1} {N1} {N2} {M2} {D1} {D2} {B}
	forall {F:not-member M1 N1}
	       {U:update M1 N2 D2 M2}
	       {L:lookup M2 N1 D1}
	       {E:nat`eq? N1 N2 B}
	exists {EN:nat`eq N1 N2} {ED:unit`eq D1 D2}
	true.

- : update-is-cause-of-change F U L EN ED
     <- nat`eq?-total E?
     <- update-is-cause-of-change/L F U L E? EN ED.

- : update-is-cause-of-change/L F U L (nat`eq?/yes) nat`eq/ ED
    <- update-implies-lookup U LP
    <- lookup-deterministic L LP eq/ nat`eq/ ED.

- : update-is-cause-of-change/L F U L (nat`eq?/no N1<>N2) EN ED
    <- update-preserves-not-member F U N1<>N2 FP
    <- not-member-lookup-not-equal FP L N1<>N1
    <- nat`ne-anti-reflexive N1<>N1 V
    <- nat`false-implies-eq V EN
    <- unit`false-implies-eq V ED.
    
%worlds () (update-is-cause-of-change/L _ _ _ _ _ _).
%total { } (update-is-cause-of-change/L _ _ _ _ _ _).

%worlds () (update-is-cause-of-change _ _ _ _ _).
%total { } (update-is-cause-of-change _ _ _ _ _).


%theorem update-preserves-membership :
	forall* {M1} {N1} {B} {N2} {D} {M2}
	forall {MD1:member? M1 N1 B} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
	exists {MD2:member? M2 N1 B}
	true.

- : update-preserves-membership (member?/in L) U NE (member?/in LP)
    <- update-preserves-lookup L U NE LP.

- : update-preserves-membership (member?/out F) U NE (member?/out FP)
    <- update-preserves-not-member F U NE FP.

%worlds () (update-preserves-membership _ _ _ _).
%total {} (update-preserves-membership _ _ _ _).


%theorem update-preserves-membership-converse :
	forall* {M1} {N1} {B} {N2} {D} {M2}
	forall {MD2:member? M2 N1 B} {U:update M1 N2 D M2} {N:nat`ne N1 N2}
	exists {MD1:member? M1 N1 B}
	true.

- : update-preserves-membership-converse (member?/in L2) U NE (member?/in L1)
    <- update-preserves-lookup-converse L2 U NE L1.

- : update-preserves-membership-converse (member?/out F2) U NE (member?/out F1)
    <- update-preserves-not-member-converse F2 U F1.

%worlds () (update-preserves-membership-converse _ _ _ _).
%total { } (update-preserves-membership-converse _ _ _ _).


%theorem lookup-update-preserves-membership :
	forall* {M1} {N1} {B} {N2} {D1} {D2} {M2}
	forall {MD1:member? M1 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
	exists {MD2:member? M2 N1 B}
	true.

%theorem lookup-update-preserves-membership/L :
	forall* {M1} {N1} {B} {N2} {D1} {D2} {M2} {B2}
	forall {MD1:member? M1 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
	       {EQ?:nat`eq? N1 N2 B2}
	exists {MD2:member? M2 N1 B}
	true.

- : lookup-update-preserves-membership/L MD1 _ Ux1 (nat`eq?/no N1<>N2) MD2 
    <- update-preserves-membership MD1 Ux1 N1<>N2 MD2.

- : lookup-update-preserves-membership/L
	(member?/in _) _ U (nat`eq?/yes) (member?/in L2)
    <- update-implies-lookup U L2.

- : lookup-update-preserves-membership/L
	(member?/out F1) L1 _ nat`eq?/yes (member?/out F2)
    <- not-member-lookup-not-equal F1 L1 NE
    <- nat`ne-anti-reflexive NE F
    <- false-implies-not-member F F2.

%worlds () (lookup-update-preserves-membership/L _ _ _ _ _).
%total { } (lookup-update-preserves-membership/L _ _ _ _ _).

- : lookup-update-preserves-membership MD1 L1 U MD2
    <- nat`eq?-total EQUAL?
    <- lookup-update-preserves-membership/L MD1 L1 U EQUAL? MD2.

%worlds () (lookup-update-preserves-membership _ _ _ _).
%total { } (lookup-update-preserves-membership _ _ _ _).


%theorem lookup-update-preserves-membership-converse :
	forall* {M1} {N1} {B} {N2} {D1} {D2} {M2}
	forall {MD1:member? M2 N1 B} {L:lookup M1 N2 D1} {U:update M1 N2 D2 M2}
	exists {MD2:member? M1 N1 B}
	true.

- : lookup-update-preserves-membership-converse MD2 ML MU MD1
    <- member?-total MD1P
    <- lookup-update-preserves-membership MD1P ML MU MD2P
    <- member?-deterministic MD2P MD2 eq/ nat`eq/ BP=B
    <- member?-respects-eq MD1P eq/ nat`eq/ BP=B MD1.

%worlds () (lookup-update-preserves-membership-converse _ _ _ _).
%total { } (lookup-update-preserves-membership-converse _ _ _ _).


%theorem update-preserves-in-member :
	forall* {M1} {N1} {N2} {D} {M2}
	forall {MD1:member? M1 N1 true} {U:update M1 N2 D M2}
	exists {MD2:member? M2 N1 true}
	true.

%theorem update-preserves-in-member/L :
	forall* {M1} {N1} {N2} {D} {M2} {B}
	forall {MD1:member? M1 N1 true} {U:update M1 N2 D M2}
	       {E: nat`eq? N1 N2 B}
	exists {MD2:member? M2 N1 true}
	true.

- : update-preserves-in-member/L
	(member?/in ML1) U (nat`eq?/no N1<>N2) (member?/in ML2)
    <- update-preserves-lookup ML1 U N1<>N2 ML2.

- : update-preserves-in-member/L _ U (nat`eq?/yes) (member?/in ML)
    <- update-implies-lookup U ML.

%worlds () (update-preserves-in-member/L _ _ _ _).
%total { } (update-preserves-in-member/L _ _ _ _).

- : update-preserves-in-member MD1 U MD2
    <- nat`eq?-total E
    <- update-preserves-in-member/L MD1 U E MD2.

%worlds () (update-preserves-in-member _ _ _).
%total { } (update-preserves-in-member _ _ _).


%theorem shift-preserves-update :
	forall* {M1} {N1} {D} {M1P} {N0} {M2}
	forall {U1:update M1 N1 D M1P}
               {S:shift N0 M1 M2}
        exists {N2} {M2P} 
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
               {U2:update M2 N2 D M2P}
	true.

- : shift-preserves-update update/0 shift/0 _ _ P (shift/+ P) update/0
    <- plus-total P.

- : shift-preserves-update (update/= nat`eq/) (shift/+ P) _ _ P (shift/+ P)
                           (update/= nat`eq/).

- : shift-preserves-update (update/< N4+1+N1=N3) (shift/+ N0+1+N3=N5) _ _
                           N0+1+N1=N2 (shift/+ N0+1+N1=N2) 
                           (update/< N4+1+N2=N5)
    <- plus-commutative N4+1+N1=N3 N1+N4+1=N3
    <- plus-associative-converse N1+N4+1=N3 N0+1+N3=N5 _ N0+1+N1=N2 N2+N4+1=N5
    <- plus-commutative N2+N4+1=N5 N4+1+N2=N5.

- : shift-preserves-update (update/> U N4+1+N3=N1) (shift/+ N0+1+N3=N5) _ _
                           N0+1+N1=N2 (shift/+ N0+1+N3=N5)
                           (update/> U N4+1+N5=N2)
   <- plus-total N0+1+N1=N2
   <- plus-commutative N4+1+N3=N1 N3+N4+1=N1
   <- plus-associative-converse* N3+N4+1=N1 N0+1+N1=N2 N0+1+N3=N5 N5+N4+1=N2
   <- plus-commutative N5+N4+1=N2 N4+1+N5=N2.

%worlds () (shift-preserves-update _ _ _ _ _ _ _).
%total { } (shift-preserves-update _ _ _ _ _ _ _).


%theorem shift-preserves-update* :
	forall* {M1} {N1} {D} {M1P} {N0} {M2} {N2} {M2P}
	forall {U1:update M1 N1 D M1P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
        exists {U2:update M2 N2 D M2P}
	true.

- : shift-preserves-update* U1 S P SS U2
    <- shift-preserves-update U1 S _ _ PP SSP U2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- shift-deterministic SSP SS nat`eq/ eq/ M2P=M2
    <- update-respects-eq U2P eq/ N2P=N2 unit`eq/ M2P=M2 U2.

%worlds () (shift-preserves-update* _ _ _ _ _).
%total { } (shift-preserves-update* _ _ _ _ _).


%theorem shift-preserves-update-converse :
	forall* {M1} {N1} {D} {N0} {M2} {N2} {M2P}
        forall {U2:update M2 N2 D M2P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
        exists {M1P} {SS:shift N0 M1P M2P}
	       {U1:update M1 N1 D M1P}
	true.

- : shift-preserves-update-converse U2 S P _ SS U1
    <- update-total U1
    <- shift-preserves-update U1 S _ _ PP SSP U2P
    <- plus-deterministic PP P nat`eq/ nat`eq/ N2P=N2
    <- update-deterministic U2P U2 eq/ N2P=N2 unit`eq/ M2P=M2
    <- shift-respects-eq SSP nat`eq/ eq/ M2P=M2 SS.

%worlds () (shift-preserves-update-converse _ _ _ _ _ _).
%total { } (shift-preserves-update-converse _ _ _ _ _ _).


%theorem shift-preserves-update-converse* :
	forall* {M1} {N1} {D} {N0} {M2} {N2} {M2P} {M1P}
        forall {U2:update M2 N2 D M2P}
               {S:shift N0 M1 M2}
               {P:plus (s N0) N1 N2}
               {SS:shift N0 M1P M2P}
	exists {U1:update M1 N1 D M1P}
	true.

- : shift-preserves-update-converse* U2 S P SS U1
    <- shift-preserves-update-converse U2 S P _ SSP U1P
    <- shift-cancels SSP SS nat`eq/ eq/ E
    <- update-respects-eq U1P eq/ nat`eq/ unit`eq/ E U1.

%worlds () (shift-preserves-update-converse* _ _ _ _ _).
%total { } (shift-preserves-update-converse* _ _ _ _ _).


%theorem update-commutes-shift-converse :
	forall* {M2} {N2} {D} {M2P} {N0} {M1P}
        forall {U2:update M2 N2 D M2P}
               {SS:shift N0 M1P M2P}
        exists {N1} {M1}
               {P:plus (s N0) N1 N2}
               {S:shift N0 M1 M2}
	       {U1:update M1 N1 D M1P}
	true.

- : update-commutes-shift-converse
	update/0 (shift/+ P) _ _ P shift/0 update/0.

- : update-commutes-shift-converse
	(update/= nat`eq/) (shift/+ P) _ _ P (shift/+ P)
	(update/= nat`eq/).

- : update-commutes-shift-converse
	(update/< D1+1+N=N1) (shift/+ D2+1+N2=N) _ _ D2+1+N2=N 
	(shift/+ D2+1+N0=N1) (update/< D1+1+N2=N0)
    <- plus-commutative D2+1+N2=N N2+D2+1=N
    <- plus-associative-converse N2+D2+1=N D1+1+N=N1 N0 D1+1+N2=N0 N0+D2+1=N1
    <- plus-commutative N0+D2+1=N1 D2+1+N0=N1.

- : update-commutes-shift-converse
	(update/> U D1+1+N=N1) (shift/+ D2+1+N2=N) _ _ D2+1+N0=N1
	(shift/+ D2+1+N2=N) (update/> U D1+1+N2=N0)
    <- plus-commutative D2+1+N2=N N2+D2+1=N
    <- plus-associative-converse N2+D2+1=N D1+1+N=N1 N0 D1+1+N2=N0 N0+D2+1=N1
    <- plus-commutative N0+D2+1=N1 D2+1+N0=N1.

%worlds () (update-commutes-shift-converse _ _ _ _ _ _ _).
%total { } (update-commutes-shift-converse _ _ _ _ _ _ _).


%theorem update-commutes-shift-converse* :
	forall* {M2} {N2} {D} {M2P} {N0} {M1P} {N1}
        forall {U2:update M2 N2 D M2P}
               {SS:shift N0 M1P M2P}
               {P:plus (s N0) N1 N2}
        exists {M1}
               {S:shift N0 M1 M2}
	       {U1:update M1 N1 D M1P}
	true.

- : update-commutes-shift-converse* U SHP P _ SH UP
    <- update-commutes-shift-converse U SHP _ _ PP SH UPP
    <- plus-left-cancels PP P nat`eq/ nat`eq/ EQ
    <- update-respects-eq UPP eq/ EQ unit`eq/ eq/ UP.

%worlds () (update-commutes-shift-converse* _ _ _ _ _ _).
%total { } (update-commutes-shift-converse* _ _ _ _ _ _).


%theorem not-member-update-preserves-lookup :
	forall* {M} {N1} {D1} {MP} {N2} {D2}
	forall {L:lookup M N2 D2} {F: not-member M N1} {U:update M N1 D1 MP}
        exists {LP:lookup MP N2 D2}
	true.

- : not-member-update-preserves-lookup L F U LP
    <- not-member-lookup-not-equal F L NE
    <- nat`ne-symmetric NE NEs
    <- update-preserves-lookup L U NEs LP.

%worlds () (not-member-update-preserves-lookup _ _ _ _).
%total { } (not-member-update-preserves-lookup _ _ _ _).


%theorem not-member-update-increases-size :
	forall* {M1} {S} {N} {D} {M2}
	forall	{S1: size M1 S}
		{F: not-member M1 N}
		{U: update M1 N D M2}
	exists	{S2: size M2 (s S)}
	true.

- : not-member-update-increases-size size/0 not-member/0 update/0 (size/+ size/0).

- : not-member-update-increases-size (size/+ S) (not-member/< G) U SP
    <- gt-implies-plus G _ P
    <- update/<-inversion U P E
    <- size-respects-eq (size/+ (size/+ S)) E nat`eq/ SP.

- : not-member-update-increases-size (size/+ S) (not-member/> F P) U SPP
    <- update/>-inversion U P _ UP E
    <- not-member-update-increases-size S F UP SP
    <- size-respects-eq (size/+ SP) E nat`eq/ SPP.

%worlds () (not-member-update-increases-size _ _ _ _).
%total (F) (not-member-update-increases-size F _ _ _).

				       
%theorem not-member-update-increases-size-converse :
	forall* {M1} {S} {N} {D} {M2}
	forall	{S2: size M2 (s S)}
		{F: not-member M1 N}
		{U: update M1 N D M2}
	exists	{S1: size M1 S}
	true.

- : not-member-update-increases-size-converse S2 F U S1
    <- size-total S1P
    <- not-member-update-increases-size S1P F U S2P
    <- size-deterministic S2P S2 eq/ SNP=SN
    <- succ-cancels SNP=SN NP=N 
    <- size-respects-eq S1P eq/ NP=N S1.

%worlds () (not-member-update-increases-size-converse _ _ _ _).
%total { } (not-member-update-increases-size-converse _ _ _ _).


%theorem not-member-update-preserves-disjoint :
	forall* {M1} {M2} {N} {D} {M2P}
	forall	{I: disjoint M1 M2}
		{F: not-member M1 N}
		{U: update M2 N D M2P}
	exists	{DP: disjoint M1 M2P}
	true.

%theorem not-member-update-preserves-disjoint/L :
	forall* {M1} {M2} {N} {D} {M2P} {B}
	forall	{I: disjoint M1 M2}
		{F: not-member M1 N}
		{U: update M2 N D M2P}
		{D?: disjoint? M1 M2P B}
	exists	{DP: disjoint M1 M2P}
	true.

- : not-member-update-preserves-disjoint/L _ _ _ (disjoint?/yes DJ) DJ.

- : not-member-update-preserves-disjoint/L D FR U (disjoint?/no L1 L2P) DP
    <- not-member-lookup-not-equal FR L1 NE
    <- nat`ne-symmetric NE NEs
    <- update-preserves-lookup-converse L2P U NEs L2
    <- disjoint-lookup-contradiction D L1 L2 F
    <- false-implies-disjoint F DP.

%worlds () (not-member-update-preserves-disjoint/L _ _ _ _ _).
%total { } (not-member-update-preserves-disjoint/L _ _ _ _ _).

- : not-member-update-preserves-disjoint D F U DP
    <- disjoint?-total D?
    <- not-member-update-preserves-disjoint/L D F U D? DP.

%worlds () (not-member-update-preserves-disjoint _ _ _ _).
%total { } (not-member-update-preserves-disjoint _ _ _ _).


%theorem update-preserves-disjoint-converse :
	forall* {M1} {M2} {N} {D} {M2P}
	forall	{I: disjoint M1 M2P}
		{U: update M2 N D M2P}
	exists	{DP: disjoint M1 M2}
	true.

%theorem update-preserves-disjoint-converse/L :
	forall* {M1} {M2} {N} {D} {M2P} {B}
	forall	{I: disjoint M1 M2P}
		{U: update M2 N D M2P}
		{D: disjoint? M1 M2 B}
	exists	{DP: disjoint M1 M2}
	true.

- : update-preserves-disjoint-converse/L _ _ (disjoint?/yes DJ) DJ.

- : update-preserves-disjoint-converse/L DJP U (disjoint?/no L1 L2) DJ
    <- update-preserves-in-member (member?/in L2) U (member?/in L2P)
    <- disjoint-lookup-contradiction DJP L1 L2P F
    <- false-implies-disjoint F DJ.

%worlds () (update-preserves-disjoint-converse/L _ _ _ _).
%total { } (update-preserves-disjoint-converse/L _ _ _ _).

- : update-preserves-disjoint-converse DP U D
    <- disjoint?-total D?
    <- update-preserves-disjoint-converse/L DP U D? D.

%worlds () (update-preserves-disjoint-converse _ _ _).
%total { } (update-preserves-disjoint-converse _ _ _).


%theorem update-preserves-bound:
	forall* {M1} {N1} {N2} {D} {M2}
	forall {F1:bound M1 N1} {U:update M1 N2 D M2} {N:nat`gt N1 N2}
	exists {F2:bound M2 N1}
	true.

- : update-preserves-bound (bound/+ P B) (update/= nat`eq/) _ (bound/+ P B).

- : update-preserves-bound (bound/+ I+1+J=K B) (update/< L+1+M=I) _ 
	(bound/+ M+1+N=K (bound/+ L+1+J=N B))
    <- plus-swap-succ I+1+J=K I+J+1=K
    <- plus-swap-succ L+1+M=I L+M+1=I
    <- plus-commutative L+M+1=I M+1+L=I
    <- plus-associative M+1+L=I I+J+1=K N L+J+1=N M+1+N=K
    <- plus-swap-succ-converse L+J+1=N L+1+J=N.

- : update-preserves-bound (bound/+ I+1+J=K B) (update/> U L+1+I=M) K>M
	(bound/+ I+1+J=K BP)
    <- plus-swap-succ L+1+I=M L+I+1=M
    <- plus-commutative L+I+1=M I+1+L=M
    <- plus-left-cancels-gt I+1+J=K I+1+L=M nat`eq/ K>M J>L
    <- update-preserves-bound B U J>L BP.

%worlds () (update-preserves-bound _ _ _ _).
%total (U) (update-preserves-bound _ U _ _).


%theorem update-preserves-bound-converse:
	forall* {M1} {N1} {N2} {D} {M2}
	forall {F1:bound M2 N1} {U:update M1 N2 D M2} {N:nat`ne N1 (s N2)}
	exists {F2:bound M1 N1}
	true.

- : update-preserves-bound-converse (bound/+ I+1+0=J bound/0) update/0 J<>I+1 B
    <- plus-right-identity (s I) I+1+0=I+1
    <- plus-unique I+1+0=J I+1+0=I+1 nat`eq/ nat`eq/ J=I+1
    <- nat`eq-ne-implies-false J=I+1 J<>I+1 F
    <- false-implies-bound F B.

- : update-preserves-bound-converse (bound/+ P B) (update/= nat`eq/) _ 
	(bound/+ P B).

- : update-preserves-bound-converse
	(bound/+ M+1+N=K (bound/+ L+1+J=N B))
	(update/< L+1+M=I) _ 
	(bound/+ I+1+J=K B) 
    <- plus-swap-succ L+1+J=N L+J+1=N 
    <- plus-swap-succ L+1+M=I L+M+1=I
    <- plus-commutative L+M+1=I M+1+L=I
    <- plus-associative-converse* L+J+1=N M+1+N=K M+1+L=I I+J+1=K
    <- plus-swap-succ-converse I+J+1=K I+1+J=K.

- : update-preserves-bound-converse 
	(bound/+ I+1+J=K BP) (update/> U L+1+I=M) K<>M+1
	(bound/+ I+1+J=K B)
    <- plus-swap-succ L+1+I=M L+I+1=M
    <- plus-commutative L+I+1=M I+1+L=M
    <- plus-right-increase I+1+L=M I+1+L+1=M+1
    <- plus-left-cancels-ne I+1+J=K I+1+L+1=M+1 nat`eq/ K<>M+1 J<>L+1
    <- update-preserves-bound-converse BP U J<>L+1 B.

%worlds () (update-preserves-bound-converse _ _ _ _).
%total (U) (update-preserves-bound-converse _ U _ _).



%theorem update-overwrites :
	forall* {M1} {N1} {D1} {M2} {N2} {D2} {M3}
	forall {U1:update M1 N1 D1 M2} {U2:update M2 N2 D2 M3}
	       {E:nat`eq N1 N2}
	exists {U12:update M1 N1 D2 M3}
	true.

- : update-overwrites (update/0) (update/= nat`eq/) nat`eq/ (update/0).

- : update-overwrites (update/= nat`eq/) (update/= nat`eq/) nat`eq/ (update/= nat`eq/).

- : update-overwrites (update/< P) (update/= nat`eq/) nat`eq/ (update/< P).

- : update-overwrites (update/> U1 P) (update/> U2 PP) nat`eq/ (update/> U3 P)
    <- plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- update-overwrites U1 U2 N0=N0P U3.

%% contradiction cases
- : update-overwrites (update/0) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/0) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/= nat`eq/) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/= nat`eq/) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/< _) (update/< N3+1+N=N) nat`eq/ U
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/< _) (update/> _ N0+1+N=N) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/> _ N0+1+N=N) (update/= nat`eq/) nat`eq/ U
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-update F U.

- : update-overwrites (update/> _ N0+1+N1=N2) (update/< N3+1+N2=N1) nat`eq/ U
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-update F U.

%worlds () (update-overwrites M1^N1=D1->M2 M2^N2=D2->M3 N1=N2 
                       %{=>}% M1^N1=D2->M3).
%total (U) (update-overwrites U _ _ _).


%theorem update-overwrites-converse :
	forall* {M1} {N1} {D1} {M2} {D2} {M3}
	forall {U12:update M1 N1 D1 M3} {U1:update M1 N1 D2 M2}
	exists {U2:update M2 N1 D1 M3}
	true.

- : update-overwrites-converse U12 U1 U2
    <- update-total U2P 
    <- update-overwrites U1 U2P nat`eq/ U12P
    <- update-deterministic U12P U12 eq/ nat`eq/ unit`eq/ M2P=M2
    <- update-respects-eq U2P eq/ nat`eq/ unit`eq/ M2P=M2 U2.

%worlds () (update-overwrites-converse _ _ _).
%total { } (update-overwrites-converse _ _ _).


%theorem update-may-have-no-effect :
	forall* {M1} {N} {D} {M2}
	forall {L:lookup M1 N D} {U:update M1 N D M2}
	exists {E:eq M1 M2}
	true.

- : update-may-have-no-effect (lookup/= nat`eq/) U E
    <- update/=-inversion U nat`eq/ E.

- : update-may-have-no-effect (lookup/> L1 N0+1+N1=N2) U E
    <- update/>-inversion U N0+1+N1=N2 _ U1 M112=M2
    <- update-may-have-no-effect L1 U1 M1=M2
    <- map/+-preserves-eq nat`eq/ unit`eq/ M1=M2 M111=M112
    <- eq-transitive M111=M112 M112=M2 E.

%worlds () (update-may-have-no-effect _ _ _).
%total (L) (update-may-have-no-effect L _ _).


%theorem update-idempotent :
	forall* {M1} {N1} {D1} {M2} {N2} {D2} {M3}
	forall {U1:update M1 N1 D1 M2} {U2:update M2 N2 D2 M3}
	       {EN:nat`eq N1 N2} {ED:unit`eq D1 D2}
	exists {EM:eq M2 M3}
	true.

- : update-idempotent U1 U2 nat`eq/ unit`eq/ M2=M3
    <- update-overwrites U1 U2 nat`eq/ M1^N=D->M3
    <- update-deterministic U1 M1^N=D->M3 eq/ nat`eq/ unit`eq/ M2=M3.

%worlds () (update-idempotent M1^N1=D1->M2 M2^N2=D2->M3 N1=N2 D1=D2
                       %{=>}% M2=M3).
%total {} (update-idempotent _ _ _ _ _).


%theorem update-commutes :
	forall* {M} {N1} {D1} {M1} {N2} {D2} {M12}
	forall {U1:update M N1 D1 M1} {U12:update M1 N2 D2 M12}
               {NE:nat`ne N1 N2}
        exists {M2} {U2:update M N2 D2 M2} {U21:update M2 N1 D1 M12}
	true.

- : update-commutes update/0 (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes update/0 (update/< NP+1+N2=N1) _ _ update/0
                    (update/> update/0 NP+1+N2=N1).

- : update-commutes update/0 (update/> update/0 NP+1+N1=N2) _ _ update/0
                    (update/< NP+1+N1=N2).

- : update-commutes (update/= nat`eq/) (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes (update/= nat`eq/) (update/< NP+1+N2=N1) _ _ 
                    (update/< NP+1+N2=N1) (update/> (update/= nat`eq/) NP+1+N2=N1).

- : update-commutes (update/= nat`eq/) (update/> U NP+1+N1=N2) _ _ 
                    (update/> U NP+1+N1=N2) (update/= nat`eq/).

- : update-commutes (update/< _) (update/= nat`eq/) N<>N map/0 U2 U21
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-update F U2
    <- false-implies-update F U21.

- : update-commutes (update/< N1P+1+N1=N) (update/< N2P+1+N2=N1) _ _ 
                    (update/< N2PP+1+N2=N) 
                    (update/> (update/< N1P+1+N2P=N2PP) N2P+1+N2=N1)
    <- plus-swap-succ N2P+1+N2=N1 N2P+N2+1=N1
    <- plus-associative-converse N2P+N2+1=N1 N1P+1+N1=N 
                                 N2PP N1P+1+N2P=N2PP N2PP+N2+1=N
    <- plus-swap-succ-converse N2PP+N2+1=N N2PP+1+N2=N.

- : update-commutes ((update/< N11+1+N1=N):update (map/+ N D M) _ _ _)
                  (update/> (update/= nat`eq/) N11+1+N1=N2) _
                    (map/+ N2 D2 M)
                    (update/= N=N2)
                    ((update/< N11+1+N1=N2):update _ N1 D1 _)
    <- plus-deterministic N11+1+N1=N N11+1+N1=N2 nat`eq/ nat`eq/ N=N2.

- : update-commutes (update/< N11+1+N1=N) 
                    (update/> (update/< N2PP+1+N2P=N11) N2P+1+N1=N2) _ _
                    (update/< N2PP+1+N2=N) (update/< N2P+1+N1=N2)
    <- plus-swap-succ N11+1+N1=N N11+N1+1=N
    <- plus-swap-succ N2P+1+N1=N2 N2P+N1+1=N2
    <- plus-associative* N2PP+1+N2P=N11 N11+N1+1=N N2P+N1+1=N2
                         N2PP+1+N2=N.

- : update-commutes (update/< N11+1+N1=N) 
                    (update/> (update/> U N2PP+1+N11=N2P) N2P+1+N1=N2) _ _
                    (update/> U N2PP+1+N=N2) (update/< N11+1+N1=N)
    <- plus-swap-succ N11+1+N1=N N11+N1+1=N
    <- plus-swap-succ N2P+1+N1=N2 N2P+N1+1=N2
    <- plus-associative* N2PP+1+N11=N2P N2P+N1+1=N2 N11+N1+1=N N2PP+1+N=N2.

- : update-commutes (update/> U N11+1+N=N1) (update/= nat`eq/) _ _
                    (update/= nat`eq/) (update/> U N11+1+N=N1).

- : update-commutes (update/> U N11+1+N=N1) (update/< N2P+1+N2=N) _ _
                    (update/< N2P+1+N2=N)
		    (update/> (update/> U N11+1+N2P=N11P) N11P+1+N2=N1)
    <- plus-swap-succ N2P+1+N2=N N2P+N2+1=N
    <- plus-associative-converse N2P+N2+1=N N11+1+N=N1 
                                 N11P N11+1+N2P=N11P N11P+N2+1=N1
    <- plus-swap-succ-converse N11P+N2+1=N1 N11P+1+N2=N1.

- : update-commutes (update/> U1 N11+1+N=N1) (update/> U12 N2P+1+N=N2) N1<>N2
                    (map/+ N D M2) 
     		    (update/> U2 N2P+1+N=N2) (update/> U21 N11+1+N=N1)
    <- plus-right-cancels-ne N11+1+N=N1 N2P+1+N=N2 nat`eq/ N1<>N2 N11+1<>N2P+1
    <- succ-preserves-ne-converse N11+1<>N2P+1 N11<>N2P
    <- update-commutes U1 U12 N11<>N2P M2 U2 U21.

%worlds () (update-commutes M^N1=D1->M1 M1^D2=N2->M12 N1<>N2
                     %{=>}% M2 M^N2=D2->M2 M2^N1=D1->M12).
%total (U1) (update-commutes U1 _ _ _ _ _).


%theorem update-commutes* :
	forall* {M} {N1} {D1} {M1} {N2} {D2} {M12} {M2}
	forall {U1:update M N1 D1 M1} {U12:update M1 N2 D2 M12}
               {NE:nat`ne N1 N2} {U2:update M N2 D2 M2} 
        exists {U21:update M2 N1 D1 M12}
	true.

- : update-commutes* M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 M^N2=D2->M2 M2^N1=D1->M12
    <- update-commutes M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 
                       M2P M^N2=D2->M2P M2P^N1=D1->M12
    <- update-deterministic M^N2=D2->M2P M^N2=D2->M2 eq/ nat`eq/ 
                            unit`eq/ M2P=M2
    <- update-respects-eq M2P^N1=D1->M12 M2P=M2 nat`eq/ 
                            unit`eq/ eq/ M2^N1=D1->M12.

%worlds () (update-commutes* M^N1=D1->M1 M1^D2=N2->M12 N1<>N2 M^N2=D2->M2
                      %{=>}% M2^N1=D1->M12).
%total {} (update-commutes* _ _ _ _ _). 


%theorem not-member-update-cancels :
	forall* {M1} {N1} {D1} {M1P}
		{M2} {N2} {D2} {M2P}
	forall	{F1: not-member M1 N1}
		{U1: update M1 N1 D1 M1P}
		{F2: not-member M2 N2}
		{U2: update M2 N2 D2 M2P}
		{NE: nat`eq N1 N2}
		{EQP: eq M1P M2P}
	exists	{DE: unit`eq D1 D2}
		{EQ: eq M1 M2}
	true.

% can never be update/=
- : not-member-update-cancels _ _ FR (update/= nat`eq/) _ eq/ DE E
    <- not-member-contradiction FR F
    <- unit`false-implies-eq F DE
    <- false-implies-eq F E.

- : not-member-update-cancels FR (update/= nat`eq/) _ _ _ eq/ DE E
    <- not-member-contradiction FR F
    <- unit`false-implies-eq F DE
    <- false-implies-eq F E.

- : not-member-update-cancels not-member/0 update/0 _ update/0 nat`eq/ eq/ unit`eq/ eq/.

- : not-member-update-cancels not-member/0 update/0 
	FR (update/> _ P) nat`eq/ eq/ DE E
    <- plus-implies-gt P nat`eq/ GT
    <- gt-anti-reflexive GT F
    <- unit`false-implies-eq F DE
    <- false-implies-eq F E.

- : not-member-update-cancels 
     (not-member/< GT1) U1 (not-member/< GT2) U2 nat`eq/ eq/ DEX E
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 _ DEX EQ12R
    <- map/+-preserves-eq-converse EQ12R NP1=NP2 DE RE
    <- succ-deterministic NP1=NP2 SNP1=SNP2
    <- plus-deterministic P1 P2 SNP1=SNP2 nat`eq/ N1=N2
    <- map/+-preserves-eq N1=N2 DE RE E.
    
- : not-member-update-cancels 
     (not-member/< GT1) U1 (not-member/> _ P2) U2 nat`eq/ eq/ DE E
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- update/>-inversion U2 P2 _ _ EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 _ _
    <- plus-implies-gt P2 nat`eq/ NP1>NP2
    <- gt-respects-eq NP1>NP2 NP1=NP2 nat`eq/ NP2>NP2
    <- gt-anti-reflexive NP2>NP2 F
    <- unit`false-implies-eq F DE
    <- false-implies-eq F E.

- : not-member-update-cancels 
	(not-member/> F1 P1) UP1 (not-member/> F2 P2) UP2 nat`eq/ eq/ DE E
    <- update/>-inversion UP1 P1 _ U1 EQ1
    <- update/>-inversion UP2 P2 _ U2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 D1=D2 MP1=MP2
    <- plus-right-cancels P1 P2 NP1=NP2 nat`eq/ SN1=SN2
    <- succ-cancels SN1=SN2 N1=N2
    <- not-member-update-cancels F1 U1 F2 U2 N1=N2 MP1=MP2 DE M1=M2
    <- map/+-preserves-eq NP1=NP2 D1=D2 M1=M2 E.

- :  not-member-update-cancels 
	(not-member/> F1 P1) UP1 (not-member/< GT2) UP2 nat`eq/ eq/ DE E
    <- update/>-inversion UP1 P1 _ _ EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion UP2 P2 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- eq-transitive EQ1 EQ2s EQ12
    <- map/+-preserves-eq-converse EQ12 NP1=NP2 _ _
    <- plus-implies-gt P1 nat`eq/ NP2>NP1
    <- gt-respects-eq NP2>NP1 nat`eq/ NP1=NP2 NP2>NP2
    <- gt-anti-reflexive NP2>NP2 F
    <- unit`false-implies-eq F DE
    <- false-implies-eq F E.

%worlds () (not-member-update-cancels _ _ _ _ _ _ _ _).
%total (F) (not-member-update-cancels F _ _ _ _ _ _ _).


% not exactly a converse, but very useful nonetheless
%theorem update-commutes-converse :
	forall* {M2} {N1} {D1} {M1} {N2} {D2} {M3}
	forall	{U1:update M2 N1 D1 M3} {U2:update M1 N2 D2 M3}
        	{NE:nat`ne N1 N2}
        exists	{M0} 
		{UX1:update M0 N2 D2 M2} {UX2:update M0 N1 D1 M1}
	true.

%theorem update-commutes-converse/L :
	forall* {M2} {N1} {D1} {M1} {N2} {D2} {M3} {B}
	forall	{U1:update M2 N1 D1 M3} {U2:update M1 N2 D2 M3}
        	{NE:nat`ne N1 N2}
		{MD?: member? M2 N1 B}
        exists	{M0} 
		{UX1:update M0 N2 D2 M2} {UX2:update M0 N1 D1 M1}
	true.

- : update-commutes-converse/L U23 U13 N1<>N2 (member?/out F2) _ U02 U01
    <- update-implies-lookup U23 L31
    <- update-preserves-lookup-converse L31 U13 N1<>N2 L11
    <- lookup-implies-not-member-update L11 M0 F01 U01
    <- update-commutes U01 U13 N1<>N2 M2X U02X U2X3
    <- update-preserves-not-member F01 U02X N1<>N2 F2X
    <- not-member-update-cancels F2X U2X3 F2 U23 nat`eq/ eq/ _ M2X=M2
    <- update-respects-eq U02X eq/ nat`eq/ unit`eq/ M2X=M2 U02.

- : update-commutes-converse/L U23 U13 N1<>N2 (member?/in L2) _ U02 U01
    <- update-implies-lookup U23 L31
    <- update-preserves-lookup-converse L31 U13 N1<>N2 L11
    <- lookup-implies-not-member-update L11 M0X F0X1 U0X1
    <- update-commutes U0X1 U13 N1<>N2 M2X U0X2X U2X3
    <- lookup-implies-update L2 U22
    <- update-overwrites-converse U22 U23 U32
    <- update-overwrites U2X3 U32 nat`eq/ U2X2
    <- nat`ne-symmetric N1<>N2 N2<>N1
    <- update-commutes U0X2X U2X2 N2<>N1 M0 U0X0 U02
    <- update-overwrites-converse U0X1 U0X0 U01.

%worlds () (update-commutes-converse/L _ _ _ _ _ _ _).
%total { } (update-commutes-converse/L _ _ _ _ _ _ _).

- : update-commutes-converse U23 U13 N1<>N2 M0 U02 U01
    <- member?-total D?
    <- update-commutes-converse/L U23 U13 N1<>N2 D? M0 U02 U01.

%worlds () (update-commutes-converse _ _ _ _ _ _).
%total { } (update-commutes-converse _ _ _ _ _ _).


%% NB: update-commutes-converse* (the obvious * variant) is NOT true.


%theorem not-member-update-commutes-converse* :
	forall* {M0} {M2} {N1} {D1} {M1} {N2} {D2} {M3}
	forall	{F0: not-member M0 N1}
		{U01:update M0 N1 D1 M1}
		{U13:update M1 N2 D2 M3}
        	{NE:nat`ne N1 N2}
		{F2: not-member M2 N1}
		{U23:update M2 N1 D1 M3} 
	exists	{U02:update M0 N2 D2 M2} 
	true.

- : not-member-update-commutes-converse* F0 U01 U13 NE F2 U23 U02
    <- update-commutes-converse U23 U13 NE M0X U02X U01X
    <- update-preserves-not-member-converse F2 U02X F0X
    <- not-member-update-cancels F0X U01X F0 U01 nat`eq/ eq/ DE M0X=M0
    <- update-respects-eq U02X M0X=M0 nat`eq/ unit`eq/ eq/ U02.

%worlds () (not-member-update-commutes-converse* _ _ _ _ _ _ _).
%total { } (not-member-update-commutes-converse* _ _ _ _ _ _ _).


%% The following theorem is needed if you want to iteratively
%% do something with a set.  It says that you can take out an element 
%% and (using the update-preserves-X-converse theorems) get a smaller set
%% that differs only for this element:

%theorem can-remove :
        forall* {M} {S} {N} {D}
	forall {SZ:size M S} {L:lookup M N D}
	exists {M-} {S-} {SZ-:size M- S-} {E:nat`eq (s S-) S}
               {U:update M- N D M} {F:not-member M- N}
	true.

- : can-remove (size/+ _) (lookup/= _) _ _ size/0 nat`eq/ update/0 not-member/0.

- : can-remove (size/+ (size/+ SZ)) (lookup/= nat`eq/) _ _ (size/+ SZ) nat`eq/
               (update/< N3+1+N2=N1) (not-member/< N1>N2)
    <- plus-total N3+1+N2=N1
    <- plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2.

- : can-remove (size/+ SZ) (lookup/> LK N0+1+N1=N2) _ _
               (size/+ SZ2) E
               (update/> U2 N0+1+N1=N2) (not-member/> F2 N0+1+N1=N2)
    <- can-remove SZ LK M- S- SZ2 E2 U2 F2
    <- succ-deterministic E2 E.

%worlds () (can-remove _ _ _ _ _ _ _ _).
%total (L) (can-remove _ L _ _ _ _ _ _).


% another version, which requires that you "know" the set is non-empty

%theorem can-remove* :
        forall* {M} {S}
	forall	{SZ:size M (s S)}
	exists	{MP} {N} {D}
		{SZP:size MP S} 
                {U:update MP N D M} 
		{F:not-member MP N}
	true.

- : can-remove* (size/+ SZ) MP N D SZP U F
    <- can-remove (size/+ SZ) (lookup/= nat`eq/) MP NP SZPP EQ U F
    <- succ-cancels EQ EQP
    <- size-respects-eq SZPP eq/ EQP SZP.

%worlds () (can-remove* _ _ _ _ _ _ _).
%total { } (can-remove* _ _ _ _ _ _ _).


%theorem shift-implies-update :
	forall*	{M1} {N} {M2} {D}
	forall	{SH: shift N M1 M2}
	exists	{U: update M2 N D (map/+ N D M1)}
	true.

- : shift-implies-update shift/0 update/0.

- : shift-implies-update (shift/+ P) (update/< PSC)
    <- plus-swap-succ P PS
    <- plus-commutative PS PSC.

%worlds () (shift-implies-update _ _).
%total { } (shift-implies-update _ _).


%theorem not-member-update-implies-shift:
	forall* {M} {N} {D1} {M1} {D2}
	forall	{F: not-member M N}
		{U: update M N D1 (map/+ N D2 M1)}
	exists	{S: shift N M1 M}
		{E: unit`eq D2 D1}
	true.

- : not-member-update-implies-shift F U S DEQ
    <- shift-total SP
    <- shift-implies-update SP UP
    <- shift-implies-not-member SP FP
    <- not-member-update-cancels FP UP F U nat`eq/ eq/ DEQ MEQ
    <- shift-respects-eq SP nat`eq/ eq/ MEQ S.

%worlds () (not-member-update-implies-shift _ _ _ _).
%total { } (not-member-update-implies-shift _ _ _ _).





%%%% Map comparison



%%% Definition of leq

%{%
We always define leq? and nle even if we do not have these things in unit.
This is simply for uniformity.  The relations are crippled if
unit does not have the required relation.
%}%


leq? : map -> map -> bool -> type.

%abbrev leq : map -> map -> type = [M1] [M2] leq? M1 M2 true.

%abbrev nle : map -> map -> type = [M1] [M2] leq? M1 M2 false.


leq/0 : leq map/0 M.

leq/= : leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`eq N1 N2
    <- unit`leq D1 D2
    <- leq M1 M2.

leq/> : leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)
    <- nat`plus (s N3) N2 N1
    <- leq (map/+ N3 D1 M1) M2.


nle/< : lookup M1 N D1 -> not-member M2 N -> nle M1 M2.


%abbrev leq?/yes : leq M1 M2 -> leq? M1 M2 true = [x] x.

%abbrev leq?/no : nle M1 M2 -> leq? M1 M2 false = [x] x.



%%% Theorems about leq


%theorem false-implies-leq? :
	forall* {M1} {M2} {B}
	forall {F:void}
	exists {L:leq? M1 M2 B}
	true.

%worlds () (false-implies-leq? _ _).
%total {} (false-implies-leq? _ _).

%abbrev false-implies-leq : void -> leq M1 M2 -> type = false-implies-leq?.

%abbrev false-implies-nle : void -> nle M1 M2 -> type = false-implies-leq?.


%theorem leq?-respects-eq :
	forall* {M1} {M2} {M1P} {M2P} {B}
	forall {L:leq? M1 M2 B} {E1:eq M1 M1P} {E2:eq M2 M2P}
	exists {LP:leq? M1P M2P B}
	true.

- : leq?-respects-eq L eq/ eq/ L.

%worlds () (leq?-respects-eq _ _ _ _).
%total { } (leq?-respects-eq _ _ _ _).
%reduces L1 = L2 (leq?-respects-eq L1 _ _ L2).

%abbrev leq-respects-eq = leq?-respects-eq.

%abbrev nle-respects-eq = leq?-respects-eq.


%theorem leq/0-inversion :
	forall* {M1} {M2}
	forall {L:leq M1 M2} {E2:eq M2 map/0}
	exists {E1:eq M1 map/0}
	true.

- : leq/0-inversion leq/0 eq/ eq/.

%worlds () (leq/0-inversion _ _ _).
%total { } (leq/0-inversion _ _ _).


%theorem leq/=-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2}
	forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} {EN:nat`eq N1 N2}
	exists {ED:unit`leq D1 D2} {EM:leq M1 M2}
	true.

- : leq/=-inversion (leq/= M1<=M2 D1<=D2 nat`eq/) nat`eq/ D1<=D2 M1<=M2.

- : leq/=-inversion (leq/> M311<=M2 N3+1+N=N) nat`eq/ ED M1<=M2
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- unit`false-implies-leq F ED
    <- false-implies-eq F M311=M1
    <- leq-respects-eq M311<=M2 M311=M1 eq/ M1<=M2.

%worlds () (leq/=-inversion _ _ _ _).
%total { } (leq/=-inversion _ _ _ _).
%reduces L1 < L (leq/=-inversion L _ _ L1).


%theorem leq/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3}
	forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} 
               {P:plus (s N3) N2 N1}
	exists {EM:leq (map/+ N3 D1 M1) M2}
	true.

- : leq/>-inversion (leq/= M1<=M2 D1<=D2 nat`eq/) N3+1+N=N M311<=M2
    <- plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M1=M311
    <- leq-respects-eq M1<=M2 M1=M311 eq/ M311<=M2.

- : leq/>-inversion (leq/> M311P<=M2 N3P+1+N2=N1) N3+1+N2=N1 M311<=M2
    <- plus-right-cancels N3P+1+N2=N1 N3+1+N2=N1 nat`eq/ nat`eq/ N3P+1=N3+1
    <- succ-cancels N3P+1=N3+1 N3P=N3
    <- map/+-preserves-eq N3P=N3 unit`eq/ eq/ M311P=M311
    <- leq-respects-eq M311P<=M2 M311P=M311 eq/ M311<=M2.

%worlds () (leq/>-inversion _ _ _).
%total { } (leq/>-inversion _ _ _).
%reduces LP < L (leq/>-inversion L _ LP).


%theorem leq-contradiction :
	forall*	{N} {D} {M}
	forall	{L: leq (map/+ N D M) map/0}
	exists	{F: void}
	true.

%worlds () (leq-contradiction _ _).
%total { } (leq-contradiction _ _).


%theorem leq/<-contradiction :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0}
	forall {L:leq (map/+ N1 D1 M1) (map/+ N2 D2 M2)} 
               {P:plus (s N0) N1 N2}
	exists {F:void}
	true.

- : leq/<-contradiction (leq/= _ _ nat`eq/) N0+1+N=N F
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F.

- : leq/<-contradiction (leq/> _ N3+1+N2=N1) N0+1+N1=N2 F
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F.

%worlds () (leq/<-contradiction _ _ _).
%total { } (leq/<-contradiction _ _ _).


%theorem leq-reflexive :
	forall {M}
	exists {L:leq M M}
	true.

- : leq-reflexive map/0 leq/0.

- : leq-reflexive (map/+ N D M) (leq/= M<=M D<=D nat`eq/)
    <- unit`leq-reflexive D D<=D
    <- leq-reflexive M M<=M.

%worlds () (leq-reflexive _ _).
%total (M) (leq-reflexive M _).


%theorem leq-anti-symmetric :
	forall* {M1} {M2}
	forall {L1: leq M1 M2} {L2:leq M2 M1}
	exists {E: eq M1 M2}
	true.

- : leq-anti-symmetric leq/0 leq/0 eq/.

- : leq-anti-symmetric (leq/= M1<=M2 D1<=D2 nat`eq/) 
                       (leq/= M2<=M1 D2<=D1 nat`eq/) E
    <- unit`leq-anti-symmetric D1<=D2 D2<=D1 D1=D2
    <- leq-anti-symmetric M1<=M2 M2<=M1 M1=M2
    <- map/+-preserves-eq nat`eq/ D1=D2 M1=M2 E.

- : leq-anti-symmetric (leq/= _ _ nat`eq/) (leq/> _ N3+1+N=N) E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : leq-anti-symmetric (leq/> _ N3+1+N=N) (leq/= _ _ nat`eq/) E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : leq-anti-symmetric (leq/> _ N3+1+N2=N1) (leq/> _ N0+1+N1=N2) E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (leq-anti-symmetric _ _ _).
%total (L) (leq-anti-symmetric L _ _).


%theorem leq-transitive :
	forall* {M1} {M2} {M3}
	forall {L1:leq M1 M2} {L2:leq M2 M3}
	exists {L3:leq M1 M3}
	true.

- : leq-transitive leq/0 _ leq/0.

- : leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) (leq/= M2<=M3 D2<=D3 nat`eq/)
                   (leq/= M1<=M3 D1<=D3 nat`eq/)
    <- unit`leq-transitive D1<=D2 D2<=D3 D1<=D3
    <- leq-transitive M1<=M2 M2<=M3 M1<=M3.

- : leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) (leq/> M522<=M3 N5+1+N3=N2)
                   (leq/> M511<=M3 N5+1+N3=N2)
    <- leq-transitive (leq/= M1<=M2 D1<=D2 nat`eq/) M522<=M3 M511<=M3.

- : leq-transitive (leq/> M011<=M2 N0+1+N=N1) (leq/= M2<=M3 D2<=D3 nat`eq/)
                   (leq/> M011<=M3 N0+1+N=N1)
    <- leq-transitive M011<=M2 M2<=M3 M011<=M3.

- : leq-transitive (leq/> M011<=M2 N0+1+N2=N1) (leq/> M522<=M3 N5+1+N3=N2)
                   (leq/> M411<=M3 N4+1+N3=N1)
    <- nat`plus-swap-succ N5+1+N3=N2 N5+N3+1=N2 
    <- nat`plus-associative-converse N5+N3+1=N2 N0+1+N2=N1 N4 N0+1+N5=N4
                                     N4+N3+1=N1
    <- nat`plus-swap-succ-converse N4+N3+1=N1 N4+1+N3=N1
    <- leq-transitive (leq/> M011<=M2 N0+1+N5=N4) M522<=M3 M411<=M3.

%worlds () (leq-transitive _ _ _).
%total (L) (leq-transitive _ L _).


%theorem map/+-preserves-leq? :
	forall* {N1} {N2} {D1} {D2} {M1} {M2} {B}
	forall {E:nat`eq N1 N2} {LD:unit`leq D1 D2} {LM:leq? M1 M2 B}
        exists {L:leq? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
	true.

- : map/+-preserves-leq? N1=N2 D1<=D2 M1<=M2 (leq/= M1<=M2 D1<=D2 N1=N2).

- : map/+-preserves-leq? nat`eq/ _ (nle/< L1 F2)
	(nle/< (lookup/> L1 P) (not-member/> F2 P))
    <- plus-total P.


%worlds () (map/+-preserves-leq? _ _ _ _).
%total { } (map/+-preserves-leq? _ _ _ _).

%abbrev map/+-preserves-leq = map/+-preserves-leq?.

%abbrev map/+-preserves-nle = map/+-preserves-leq?.


%theorem lookup-respects-leq :
	forall* {M} {N} {D} {MP}
	forall {L:lookup M N D} {ME:leq M MP}
        exists {DP} {L:lookup MP N DP} {DE:unit`leq D DP}
	true.

- : lookup-respects-leq (lookup/= nat`eq/) (leq/= _ D1<=D2 nat`eq/) 
                         _ (lookup/= nat`eq/) D1<=D2.

- : lookup-respects-leq (lookup/= nat`eq/) (leq/> M311<=M2 N3+1+N2=N1)
                         D2 (lookup/> L13 N3+1+N2=N1) D1<=D2
    <- lookup-respects-leq (lookup/= nat`eq/) M311<=M2 D2 L13 D1<=D2.

- : lookup-respects-leq (lookup/> L13 N3+1+N2=N1) (leq/= M1<=M2 _ nat`eq/)
                        D2 (lookup/> L13P N3+1+N2=N1) D1<=D2
    <- lookup-respects-leq L13 M1<=M2 D2 L13P D1<=D2.

- : lookup-respects-leq (lookup/> L10 N0+1+N1=N) (leq/> M311<=M2 N3+1+N2=N1)
                        D2 (lookup/> L14P N4+1+N2=N) D1<=D2
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- nat`plus-associative-converse N3+N2+1=N1 N0+1+N1=N 
                                     N4 N0+1+N3=N4 N4+N2+1=N
    <- nat`plus-swap-succ-converse N4+N2+1=N N4+1+N2=N
    <- lookup-respects-leq (lookup/> L10 N0+1+N3=N4) M311<=M2 D2 L14P D1<=D2.

%worlds () (lookup-respects-leq _ _ _ _ _).
%total (L) (lookup-respects-leq _ L _ _ _).


%theorem lookup-respects-leq* :
	forall* {M} {N} {D} {MP} {DP}
	forall {L:lookup M N D} {ME:leq M MP}
               {LP:lookup MP N DP} 
	exists {DE:unit`leq D DP}
	true.

- : lookup-respects-leq* L ME LP DL
    <- lookup-respects-leq L ME _ LPP DLP
    <- lookup-unique LPP LP eq/ nat`eq/ DE
    <- unit`leq-respects-eq DLP unit`eq/ DE DL.

%worlds () (lookup-respects-leq* _ _ _ _).
%total { } (lookup-respects-leq* _ _ _ _).


%theorem lookup-implies-unit-leq :
	forall*	{M} {N} {D}
	forall	{L: lookup M N D}
	exists	{L: leq (map/+ N D map/0) M}
	true.

- : lookup-implies-unit-leq (lookup/= nat`eq/) (leq/= leq/0 D<=D nat`eq/)
    <- unit`leq-reflexive _ D<=D.

- : lookup-implies-unit-leq (lookup/> LO P) (leq/> LE P)
    <- lookup-implies-unit-leq LO LE.

%worlds () (lookup-implies-unit-leq _ _).
%total (L) (lookup-implies-unit-leq L _).


%theorem not-member-respects-geq :
	forall* {M} {MP} {N}
	forall {FP:not-member MP N} {L:leq M MP}
	exists {F:not-member M N}
	true.

- : not-member-respects-geq F leq/0 not-member/0.

- : not-member-respects-geq (not-member/< R) (leq/= _ _ nat`eq/) (not-member/< R).

- : not-member-respects-geq (not-member/< N2>N) (leq/> _ N3+1+N2=N1) (not-member/< N1>N)
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- gt-transitive N1>N2 N2>N N1>N.

- : not-member-respects-geq (not-member/> F20 N0+1+N2=N) (leq/= M1<=M2 _ nat`eq/)
                       (not-member/> F10 N0+1+N2=N) 
    <- not-member-respects-geq F20 M1<=M2 F10.

- : {F3110:not-member (map/+ N3 D1 M1) N0}
    {N0+1+N2=N:plus (s N0) N2 N}
    {N3+1+N2=N1:plus (s N3) N2 N1}
    not-member-respects-geq 
       (not-member/> F20 N0+1+N2=N: not-member (map/+ N2 D2 M2) N) 
       (leq/> M311<=M2 N3+1+N2=N1) FP
    <- not-member-respects-geq F20 M311<=M2 F3110
    <- nat`plus-swap-succ N0+1+N2=N N0+N2+1=N
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-right-preserves-not-member* F3110 N3+N2+1=N1 N0+N2+1=N FP.

%worlds () (not-member-respects-geq _ _ _).
%total (F) (not-member-respects-geq F _ _).


%theorem leq-implies-size-le:
	forall* {M1} {M2} {N1} {N2}
	forall {L:leq M1 M2} {SZ1:size M1 N1} {SZ2:size M2 N2}
	exists {G:ge N2 N1}
	true.

- : leq-implies-size-le leq/0 size/0 N2=|M2| N2>=0
    <- plus-commutative (plus/z:plus z N2 N2) N2+0=N2    
    <- plus-implies-ge N2+0=N2 N2>=0.

- : leq-implies-size-le (leq/= M1<=M2 _ _) (size/+ N1=|M1|) (size/+ N2=|M2|)
                        N2+1>=N1+1
    <- leq-implies-size-le M1<=M2 N1=|M1| N2=|M2| N2>=N1
    <- succ-preserves-ge N2>=N1 N2+1>=N1+1.

- : leq-implies-size-le (leq/> M311<=M2 _) (size/+ N1=|M1|) (size/+ N2=|M2|)
                        (ge/> N2+1>N1+1)
    <- leq-implies-size-le M311<=M2 (size/+ N1=|M1|) N2=|M2| N2>=N1+1
    <- succ-implies-gt nat`eq/ N2+1>N2
    <- gt-transitive-ge N2+1>N2 N2>=N1+1 N2+1>N1+1.

%worlds () (leq-implies-size-le _ _ _ _).
%total (L) (leq-implies-size-le L _ _ _).


%theorem leq-implies-bound-le:
	forall* {M1} {M2} {N1} {N2}
	forall {L:leq M1 M2} {BD1:bound M1 N1} {BD2:bound M2 N2}
	exists {G:ge N2 N1}
	true.

- : leq-implies-bound-le leq/0 bound/0 _ N2>=0
    <- plus-commutative plus/z N2+0=N2    
    <- plus-implies-ge N2+0=N2 N2>=0.

- : leq-implies-bound-le (leq/= M1<=M2 _ nat`eq/) 
                         (bound/+ N+1+N1=N3 DM1<N1) 
                         (bound/+ N+1+N2=N4 DM2<N2)
                         N4>=N3
    <- leq-implies-bound-le M1<=M2 DM1<N1 DM2<N2 N2>=N1
    <- plus-left-preserves-ge* N2>=N1 N+1+N2=N4 N+1+N1=N3 N4>=N3.

- : leq-implies-bound-le (leq/> M311<=M2 N3+1+N2=N1) 
                         (bound/+ N1+1+N10=N11 DM1<N10) 
                         (bound/+ N2+1+N20=N22 DM2<N20)
                         N22>=N11
    <- plus-total N3+1+N10=N13
    <- leq-implies-bound-le M311<=M2 (bound/+ N3+1+N10=N13 DM1<N10) DM2<N20
                            N20>=N13 
    <- plus-swap-succ N1+1+N10=N11 N1+N10+1=N11
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- plus-swap-succ N3+1+N10=N13 N3+N10+1=N13
    <- plus-associative* N2+1+N3=N1 N1+N10+1=N11 N3+N10+1=N13 N2+1+N13=N11
    <- plus-left-preserves-ge* N20>=N13 N2+1+N20=N22 N2+1+N13=N11 N22>=N11.

%worlds () (leq-implies-bound-le _ _ _ _).
%total (L) (leq-implies-bound-le L _ _ _).


%theorem shift-left-preserves-leq*:
	forall* {M1} {M2} {N} {SM1} {D}
	forall {L:leq M1 M2}
	       {S1:shift N M1 SM1}
	exists {SL:leq SM1 (map/+ N D M2)}
	true.

- : shift-left-preserves-leq* _ shift/0 leq/0.

- : shift-left-preserves-leq* M111<=M2 (shift/+ N+1+N1=N1P) 
                              (leq/> M111<=M2 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-leq* _ _ _).
%total { } (shift-left-preserves-leq* _ _ _).


%theorem shift-preserves-leq*:
	forall* {M1} {M2} {N} {SM1} {SM2} 
	forall {L:leq M1 M2}
               {S1:shift N M1 SM1}
	       {S1:shift N M2 SM2}
	exists {SL:leq SM1 SM2}
	true.

- : shift-preserves-leq* _ shift/0 _ leq/0.

- : shift-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                         (shift/+ N+1+N1=N1P) 
                         (shift/+ N+1+N1=N2P)
                         (leq/= M1<=M2 D1<=D2 N1P=N2P)
    <- plus-deterministic N+1+N1=N1P N+1+N1=N2P nat`eq/ nat`eq/ N1P=N2P.

- : shift-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                         (shift/+ N+1+N1=N1P) 
                         (shift/+ N+1+N2=N2P)
                         (leq/> M311<=M2 N3+1+N2P=N1P)
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N1P N+1+N2=N2P N2P+N3+1=N1P
    <- plus-commutative N2P+N3+1=N1P N3+1+N2P=N1P.

%worlds () (shift-preserves-leq* _ _ _ _).
%total { } (shift-preserves-leq* _ _ _ _).

%abbrev shift-preserves-leq = shift-preserves-leq*.

%theorem shift-preserves-leq-converse:
	forall* {M1} {M2} {N} {SM1} {SM2} 
	forall {L:leq SM1 SM2}
               {S1:shift N M1 SM1}
	       {S1:shift N M2 SM2}
	exists {SL:leq M1 M2}
	true.

- : shift-preserves-leq-converse _ shift/0 _ leq/0.

- : shift-preserves-leq-converse (leq/= M1<=M2 D1<=D2 nat`eq/)
     				 (shift/+ N+1+N1P=N1) 
                         	 (shift/+ N+1+N2P=N1)
                         	 (leq/= M1<=M2 D1<=D2 N1P=N2P)
    <- plus-left-cancels N+1+N1P=N1 N+1+N2P=N1 nat`eq/ nat`eq/ N1P=N2P.

- : shift-preserves-leq-converse (leq/> M311<=M2 N3+1+N2P=N1P)
                         	 (shift/+ N+1+N1=N1P) 
                        	 (shift/+ N+1+N2=N2P)
                        	 (leq/> M311<=M2 N3+1+N2=N1)
    <- plus-commutative N3+1+N2P=N1P N2P+N3+1=N1P
    <- plus-associative N+1+N2=N2P N2P+N3+1=N1P M1 N2+N3+1=M1 N+1+M1=N1P
    <- plus-left-cancels N+1+M1=N1P N+1+N1=N1P nat`eq/ nat`eq/ M1=N1
    <- plus-respects-eq N2+N3+1=M1 nat`eq/ nat`eq/ M1=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1.

%worlds () (shift-preserves-leq-converse _ _ _ _).
%total { } (shift-preserves-leq-converse _ _ _ _).


%theorem disjoint-respects-geq* :
	forall* {M1} {M2} {M1P}
	forall {A:disjoint M1 M2} {E1:leq M1P M1}
	exists {AP:disjoint M1P M2}
	true.

- : disjoint-respects-geq* _ leq/0 disjoint/L.
	
- : disjoint-respects-geq* disjoint/R _ disjoint/R.

- : disjoint-respects-geq* 
	(disjoint/< D1 P) (leq/= L _ nat`eq/)
	(disjoint/< D1P P)
    <- disjoint-respects-geq* D1 L D1P.

- : disjoint-respects-geq*
	(disjoint/> D1 P) (leq/= L DL nat`eq/)
	(disjoint/> D1P P)
    <- disjoint-respects-geq* D1 (leq/= L DL nat`eq/) D1P.

- : disjoint-respects-geq*
	(disjoint/< D1 P1) (leq/> L P2) DP
    <- disjoint-respects-geq* D1 L D1P
    <- plus-swap-succ P1 P1S
    <- plus-swap-succ P2 P2S
    <- plus-commutative P1S P1SC
    <- plus-commutative P2S P2SC
    <- shift-preserves-disjoint D1P (shift/+ P2SC) (shift/+ P1SC) DP.

- : disjoint-respects-geq*
	(disjoint/> D1 N0+1+N1=N2) (leq/> L N3+1+N2=N4) DP
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N3+1+N2=N4 N5 N3+1+N0=N5 N5+N1+1=N4
    <- disjoint-respects-geq* D1 (leq/> L N3+1+N0=N5) D1P
    <- plus-commutative N5+N1+1=N4 N1+1+N5=N4
    <- shift-left-preserves-disjoint D1P (shift/+ N1+1+N5=N4) DP.

%worlds () (disjoint-respects-geq* _ _ _).
%total (D) (disjoint-respects-geq* D _ _).


%theorem disjoint-respects-geq :
	forall* {M1} {M2} {M1P} {M2P}
	forall {A:disjoint M1 M2} {E1:leq M1P M1} {E2:leq M2P M2} 
	exists {AP:disjoint M1P M2P}
	true.

- : disjoint-respects-geq M1^M2 M1P<=M1 M2P<=M2 M1P^M2P
    <- disjoint-respects-geq* M1^M2 M1P<=M1 M1P^M2
    <- disjoint-symmetric M1P^M2 M2^M1P
    <- disjoint-respects-geq* M2^M1P M2P<=M2 M2P^M1P
    <- disjoint-symmetric M2P^M1P M1P^M2P.

%worlds () (disjoint-respects-geq _ _ _ _).
%total { } (disjoint-respects-geq _ _ _ _).


%theorem disjoint-leq-implies-empty :
        forall* {M1} {M2}
        forall  {D: disjoint M1 M2}
                {L: leq M1 M2}
        exists  {E: eq map/0 M1}
        true.


- : disjoint-leq-implies-empty D L E
    <- leq-reflexive _ M<=M
    <- disjoint-respects-geq D M<=M L DD
    <- disjoint-anti-reflexive DD E.

%worlds () (disjoint-leq-implies-empty _ _ _).
%total { } (disjoint-leq-implies-empty _ _ _).


%theorem update-left-preserves-leq*:
	forall* {M1} {M2} {N} {D} {M1P} {M2P}
	forall {L:leq M1 M2} 
               {U1:update M1 N D M1P}
	       {U2:update M2 N D M2P}
	exists {LP:leq M1P M2P}
	true.

- : update-left-preserves-leq* leq/0 update/0 update/0 (leq/= leq/0 D<=D nat`eq/)
    <- unit`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/= nat`eq/) 
                          (leq/= leq/0 D<=D nat`eq/)
    <- unit`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/< _)
                          (leq/= leq/0 D<=D nat`eq/)
    <- unit`leq-reflexive _ D<=D.

- : update-left-preserves-leq* leq/0 update/0 (update/> U2505 N5+1+N2=N)
                          (leq/> M500<=M5 N5+1+N2=N)
    <- update-left-preserves-leq* leq/0 update/0 U2505 M500<=M5.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/= nat`eq/) 
                          (U2:update (map/+ N D2 M2) N D M)
                          M001<=M
    <- update/=-inversion U2 nat`eq/ M002=M
    <- unit`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= M1<=M2 D<=D nat`eq/) eq/ M002=M M001<=M.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/< N3+1+N=N1)
                          (U2:update (map/+ N1 D2 M2) N D M)
                          M00M311<=M
    <- update/<-inversion U2 N3+1+N=N1 M00M322=M
    <- unit`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= (leq/= M1<=M2 D1<=D2 nat`eq/) D<=D nat`eq/) eq/ 
                       M00M322=M M00M311<=M.

- : update-left-preserves-leq* (leq/= M1<=M2 D1<=D2 nat`eq/)
                          (update/> U1303 N3+1+N1=N)
                          (U2:update (map/+ N1 D2 M2) N D M)
                          M113<=M
    <- update/>-inversion U2 N3+1+N1=N M4 U2304 M124=M
    <- update-left-preserves-leq* M1<=M2 U1303 U2304 M3<=M4
    <- leq-respects-eq (leq/= M3<=M4 D1<=D2 nat`eq/) eq/ M124=M M113<=M.

- : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                          (update/= nat`eq/)
			  (U2:update (map/+ N2 D2 M2) N1 D M)
                          M101<=M
    <- update/>-inversion U2 N3+1+N2=N1 M4 U2304 M224=M
    <- update-left-preserves-leq* M311<=M2 (update/= nat`eq/) U2304 M301<=M4
    <- leq-respects-eq (leq/> M301<=M4 N3+1+N2=N1) eq/ M224=M M101<=M.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N=N1)
                           (update/< N4+1+N=N1)   
                           (update/= nat`eq/) %% hence N=N2
                           (leq/= M411<=M2 D<=D nat`eq/)
     <- nat`plus-right-cancels N3+1+N=N1 N4+1+N=N1 nat`eq/ nat`eq/ N3+1=N4+1
     <- nat`succ-cancels N3+1=N4+1 N3=N4
     <- map/+-preserves-eq N3=N4 unit`eq/ eq/ M311=M411
     <- leq-respects-eq M311<=M2 M311=M411 eq/ M411<=M2
     <- unit`leq-reflexive _ D<=D.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                           (update/< N4+1+N=N1)
                           (update/< N5+1+N=N2)
                           (leq/= (leq/> M311<=M2 N3+1+N5=N4) D<=D nat`eq/)
     <- nat`plus-swap-succ N5+1+N=N2 N5+N+1=N2
     <- nat`plus-associative-converse N5+N+1=N2 N3+1+N2=N1 
                                      N4P N3+1+N5=N4P N4P+N+1=N1
     <- nat`plus-swap-succ N4+1+N=N1 N4+N+1=N1
     <- nat`plus-right-cancels N4P+N+1=N1 N4+N+1=N1 nat`eq/ nat`eq/ N4P=N4
     <- nat`plus-respects-eq N3+1+N5=N4P nat`eq/ nat`eq/ N4P=N4 N3+1+N5=N4
     <- unit`leq-reflexive _ D<=D.

 - : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                           (update/< N4+1+N=N1)   
                           (update/> U2505 N5+1+N2=N)
                           (leq/> M50M411<=M5 N5+1+N2=N)
     <- nat`plus-swap-succ N5+1+N2=N N5+N2+1=N
     <- nat`plus-associative-converse N5+N2+1=N N4+1+N=N1
                                      N3P N4+1+N5=N3P N3P+N2+1=N1
     <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
     <- nat`plus-right-cancels N3P+N2+1=N1 N3+N2+1=N1 nat`eq/ nat`eq/ N3P=N3
     <- nat`plus-respects-eq N4+1+N5=N3P nat`eq/ nat`eq/ N3P=N3 N4+1+N5=N3
     <- update-left-preserves-leq* M311<=M2 (update/< N4+1+N5=N3) U2505 
                              M50M411<=M5.

- : update-left-preserves-leq* (leq/> M311<=M2 N3+1+N2=N1)
                          (update/> U1404 N4+1+N1=N)
                          (U2:update (map/+ N2 D2 M2) N D M)
                          M114<=M
    <- nat`plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- nat`plus-associative-converse N3+N2+1=N1 N4+1+N1=N 
                                     N5 N4+1+N3=N5 N5+N2+1=N
    <- nat`plus-swap-succ-converse N5+N2+1=N N5+1+N2=N
    <- update/>-inversion U2 N5+1+N2=N M5 U2505 M225=M
    <- update-left-preserves-leq* M311<=M2 (update/> U1404 N4+1+N3=N5) U2505
                             M314<=M5
    <- leq-respects-eq (leq/> M314<=M5 N3+1+N2=N1) eq/ M225=M M114<=M.

%worlds () (update-left-preserves-leq* _ _ _ _).
%total (U) (update-left-preserves-leq* _ _ U _).


%theorem update-right-preserves-leq*:
	forall* {M} {N} {D1} {D2} {M1P} {M2P}
	forall {L:unit`leq D1 D2} 
               {U1:update M N D1 M1P}
	       {U2:update M N D2 M2P}
	exists {LP:leq M1P M2P}
	true.

- : update-right-preserves-leq* D1<=D2 update/0 update/0 
                                (leq/= leq/0 D1<=D2 nat`eq/).

- : update-right-preserves-leq* D1<=D2 (update/= nat`eq/) U2 L
    <- update/=-inversion U2 nat`eq/ M221=M2P
    <- leq-reflexive _ M1<=M1
    <- leq-respects-eq (leq/= M1<=M1 D1<=D2 nat`eq/) eq/ M221=M2P L.

- : update-right-preserves-leq* D1<=D2 (update/< P) U2 L
    <- update/<-inversion U2 P M22311=M2P
    <- leq-reflexive _ M311<=M311
    <- leq-respects-eq (leq/= M311<=M311 D1<=D2 nat`eq/) eq/ M22311=M2P L.

- : update-right-preserves-leq* D1<=D2 (update/> U1 P) U22 L
    <- update/>-inversion U22 P M2P U2 M112=M
    <- update-right-preserves-leq* D1<=D2 U1 U2 M1P<=M2P
    <- unit`leq-reflexive _ D<=D
    <- leq-respects-eq (leq/= M1P<=M2P D<=D nat`eq/) eq/ M112=M L.

%worlds () (update-right-preserves-leq* _ _ _ _).
%total (U) (update-right-preserves-leq* _ U _ _).


%theorem update-preserves-leq* :
	forall* {M1} {M2} {N} {D1} {D2} {M1P} {M2P}
	forall {L:leq M1 M2} {L:unit`leq D1 D2} 
               {U1:update M1 N D1 M1P}
	       {U2:update M2 N D2 M2P}
	exists {LP:leq M1P M2P}
	true.

- : update-preserves-leq* M1<=M2 D1<=D2 M1^N=D1->M1P M2^N=D2->M2P M1P<=M2P
    <- update-total M2^N=D1->MM
    <- update-left-preserves-leq* M1<=M2 M1^N=D1->M1P M2^N=D1->MM M1P<=MM
    <- update-right-preserves-leq* D1<=D2 M2^N=D1->MM M2^N=D2->M2P MM<=M2P
    <- leq-transitive M1P<=MM MM<=M2P M1P<=M2P.

%worlds () (update-preserves-leq* _ _ _ _ _).
%total { } (update-preserves-leq* _ _ _ _ _).


%theorem not-member-update-preserves-leq-converse :
	forall* {M1} {M2} {N} {D1} {D2} {M1P} {M2P}
	forall	{LP:leq M1P M2P}
		{F1:not-member M1 N}
        	{U1:update M1 N D1 M1P}
		{F2:not-member M2 N}
		{U2:update M2 N D2 M2P}
	exists	{L:leq M1 M2} 
		{L:unit`leq D1 D2} 
	true.

- : not-member-update-preserves-leq-converse
	_ _ _ FR (update/= nat`eq/) L DL
    <- not-member-contradiction FR F
    <- false-implies-leq F L
    <- unit`false-implies-leq F DL.

- : not-member-update-preserves-leq-converse 
	M1P<=M2P not-member/0 update/0 _ U2 leq/0 D1<=D2
    <- update-implies-lookup U2 L2
    <- lookup-respects-leq* (lookup/= nat`eq/) M1P<=M2P L2 D1<=D2.

- : not-member-update-preserves-leq-converse
	M1P<=M2P (not-member/< GT1) U1 (not-member/< GT2) U2 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U1 P1 EQ1
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1P<=M2Px
    <- leq/=-inversion M1P<=M2Px nat`eq/ D1<=D2 M1s<=M2s
    <- plus-swap-succ P1 P1s
    <- plus-swap-succ P2 P2s
    <- plus-commutative P1s P1sc
    <- plus-commutative P2s P2sc
    <- shift-preserves-leq* M1s<=M2s (shift/+ P1sc) (shift/+ P2sc) M1<=M2.

- : not-member-update-preserves-leq-converse
	M1P<=M2P (not-member/< GT1) U1 not-member/0 update/0 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- eq-symmetric EQ1 EQ1s
    <- leq-respects-eq M1P<=M2P EQ1s eq/ M1Px<=M2P
    <- leq/=-inversion M1Px<=M2P nat`eq/ D1<=D2 M1s<=M2s
    <- leq-contradiction M1s<=M2s F
    <- false-implies-leq F M1<=M2.

- : not-member-update-preserves-leq-converse
	M1P<=M2P (not-member/< GT1) U1 (not-member/> F2R P2) U2 M1<=M2 D1<=D2
    <- gt-implies-plus GT1 _ P1
    <- update/<-inversion U1 P1 EQ1
    <- update/>-inversion U2 P2 _ U2R EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1P<=M2Px
    <- leq/>-inversion M1P<=M2Px P2 M1PR<=M2PR
    <- plus-swap-succ P2 P2s
    <- plus-associative-converse P2s P1 _ P1R P2Rc
    <- plus-commutative P2Rc P2R
    <- plus-implies-gt P1R nat`eq/ GT1R
    <- not-member-update-preserves-leq-converse
	M1PR<=M2PR (not-member/< GT1R) (update/< P1R) F2R U2R M1R<=M2R D1<=D2
    <- shift-left-preserves-leq* M1R<=M2R (shift/+ P2R) M1<=M2.

%theorem not-member-update-preserves-leq-converse/> :
	forall*	{N1} {X1} {M1} {C1} {R1} {D1} {N}
		{N2} {X2} {M2} {C2} {R2} {D2} {CC}
	forall	{LP: leq (map/+ N1 X1 M1) (map/+ N2 X2 M2)}
		{P1: plus (s C1) N1 N}
		{F1: not-member R1 C1}
		{U1: update R1 C1 D1 M1}
		{P2: plus (s C2) N2 N}
		{F2: not-member R2 C2}
		{U2: update R2 C2 D2 M2}
		{C12: nat`compare C1 C2 CC}
	exists	{L: leq (map/+ N1 X1 R1) (map/+ N2 X2 R2)}
		{DL: unit`leq D1 D2}
	true.

- : not-member-update-preserves-leq-converse/> 
	LP P1 F1 U1 P2 F2 U2 nat`compare/= 
	(leq/= LR XL N1=N2) DL
    <- plus-left-cancels P1 P2 nat`eq/ nat`eq/ N1=N2
    <- leq/=-inversion LP N1=N2 XL LRP
    <- not-member-update-preserves-leq-converse LRP F1 U1 F2 U2 LR DL.

- : not-member-update-preserves-leq-converse/>
	LP C1+1+N1=N F1 U1 C2+1+N2=N F2 U2 (nat`compare/< C2>C1)
	(leq/> LR D+1+N2=N1) DL
    <- gt-implies-plus C2>C1 D D+1+C1=C2
    <- plus-swap-succ C2+1+N2=N C2+N2+1=N
    <- plus-swap-succ D+1+C1=C2 D+C1+1=C2
    <- plus-commutative D+C1+1=C2 C1+1+D=C2
    <- plus-associative C1+1+D=C2 C2+N2+1=N X D+N2+1=X C1+1+X=N
    <- plus-left-cancels C1+1+X=N C1+1+N1=N nat`eq/ nat`eq/ X=N1
    <- plus-swap-succ-converse D+N2+1=X D+1+N2=X
    <- plus-respects-eq D+1+N2=X nat`eq/ nat`eq/ X=N1 D+1+N2=N1
    <- leq/>-inversion LP D+1+N2=N1 LRP
    <- not-member-update-preserves-leq-converse 
	LRP (not-member/> F1 C1+1+D=C2) (update/> U1 C1+1+D=C2) F2 U2 LR DL.

- : not-member-update-preserves-leq-converse/>
	LP P1 F1 U1 P2 F2 U2 (nat`compare/> C1>C2) L DL
    <- succ-preserves-gt C1>C2 SC1>SC2
    <- plus-left-reverses-gt P1 P2 SC1>SC2 nat`eq/ N2>N1
    <- gt-implies-plus N2>N1 _ P
    <- leq/<-contradiction LP P F
    <- false-implies-leq F L
    <- unit`false-implies-leq F DL.

- : {U1R: update R1 C1 D1 M1} not-member-update-preserves-leq-converse
	M1P<=M2P (not-member/> F1R P1) U1 (not-member/> F2R P2) U2 M1<=M2 D1<=D2
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- update/>-inversion U2 P2 _ U2R EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1PR<=M2PR
    <- nat`compare-total C
    <- not-member-update-preserves-leq-converse/>
	M1PR<=M2PR P1 F1R U1R P2 F2R U2R C M1<=M2 D1<=D2.

- : not-member-update-preserves-leq-converse
	M1P<=M2P (not-member/> F1R P1) U1 not-member/0 update/0 L DL
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- eq-symmetric EQ1 EQ1s
    <- leq-respects-eq M1P<=M2P EQ1s eq/ M1Px<=M2P
    <- leq/<-contradiction M1Px<=M2P P1 F
    <- false-implies-leq F L
    <- unit`false-implies-leq F DL.

- : not-member-update-preserves-leq-converse
	M1P<=M2P (not-member/> F1R P1) U1 (not-member/< GT2) U2 L DL
    <- update/>-inversion U1 P1 _ U1R EQ1
    <- gt-implies-plus GT2 _ P2
    <- update/<-inversion U2 P2 EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- leq-respects-eq M1P<=M2P EQ1s EQ2s M1PR<=M2PR
    <- leq/<-contradiction M1PR<=M2PR P1 F
    <- false-implies-leq F L
    <- unit`false-implies-leq F DL.

%worlds () (not-member-update-preserves-leq-converse _ _ _ _ _ _ _)
                 (not-member-update-preserves-leq-converse/> _ _ _ _ _ _ _ _ _ _).
%total (F2a F2b)
 	(not-member-update-preserves-leq-converse _ F1a _ F2a _ _ _)
        (not-member-update-preserves-leq-converse/> _ _ F1b _ _ F2b _ _ _ _).


%theorem not-member-update2-preserves-leq-converse :
	forall* {M1} {M2} {N} {D2} {M2P}
	forall	{LP:leq M1 M2P}
		{F1:not-member M1 N}
		{F2:not-member M2 N}
		{U2:update M2 N D2 M2P}
	exists	{L:leq M1 M2} 
	true.

- : not-member-update2-preserves-leq-converse M1<=M2P F1 F2 U2 M1<=M2
    <- update-total U1
    <- update-implies-lookup U2 L2
    <- lookup-implies-update L2 U2U
    <- update-left-preserves-leq* M1<=M2P U1 U2U M1P<=M2P
    <- not-member-update-preserves-leq-converse M1P<=M2P F1 U1 F2 U2 M1<=M2 _.

%worlds () (not-member-update2-preserves-leq-converse _ _ _ _ _).
%total { } (not-member-update2-preserves-leq-converse _ _ _ _ _).


%theorem not-member-update-implies-leq :
	forall* {M1} {N} {D} {M2}
	forall {F:not-member M1 N} {U:update M1 N D M2}
	exists {L:leq M1 M2}
	true.

- : not-member-update-implies-leq not-member/0 U leq/0.

- : not-member-update-implies-leq (not-member/< N2<N1) U L
    <- gt-implies-plus N2<N1 _ N3+1+N2=N1
    <- update/<-inversion U N3+1+N2=N1 M22311=M2
    <- leq-reflexive _ M311<=M311
    <- leq-respects-eq (leq/> M311<=M311 N3+1+N2=N1) eq/ M22311=M2 L.

- : not-member-update-implies-leq (not-member/> F1 N0+1+N1=N2) U L
    <- update/>-inversion U N0+1+N1=N2 _ U1 M112=M
    <- not-member-update-implies-leq F1 U1 L1
    <- unit`leq-reflexive _ DL
    <- leq-respects-eq (leq/= L1 DL nat`eq/) eq/ M112=M L.

%worlds () (not-member-update-implies-leq _ _ _).
%total (F) (not-member-update-implies-leq F _ _).


%theorem lookup-update-preserves-leq :
	forall* {M1} {N} {D1} {D2} {M2}
	forall {L:lookup M1 N D1} {U:update M1 N D2 M2}
               {L:unit`leq D1 D2}
	exists {L:leq M1 M2}
	true.

- : lookup-update-preserves-leq (lookup/= nat`eq/) U D1<=D2 L
    <- update/=-inversion U nat`eq/ M221=M2
    <- leq-reflexive _ M1<=M1
    <- leq-respects-eq (leq/= M1<=M1 D1<=D2 nat`eq/) eq/ M221=M2 L.

- : lookup-update-preserves-leq (lookup/> L1 N0+1+N1=N2) U D1<=D2 L
    <- update/>-inversion U N0+1+N1=N2 M2 U1 M112=M
    <- lookup-update-preserves-leq L1 U1 D1<=D2 L1P
    <- unit`leq-reflexive _ D1<=D1
    <- leq-respects-eq (leq/= L1P D1<=D1 nat`eq/) eq/ M112=M L.

%worlds () (lookup-update-preserves-leq _ _ _ _).
%total (L) (lookup-update-preserves-leq L _ _ _).



%%% Theorems about nle


%theorem nle-anti-reflexive :
	forall* {M}
	forall {N:nle M M}
	exists {F:void}
	true.

- : nle-anti-reflexive (nle/< L F) FALSE
    <- not-member-lookup-not-equal F L N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N FALSE.


%worlds () (nle-anti-reflexive _ _).
%total { } (nle-anti-reflexive _ _).


%theorem nle-implies-ne :
	forall* {M1} {M2}
	forall {N1:nle M1 M2}
	exists {N2:ne M1 M2}
	true.

- : nle-implies-ne (nle/< L F) (ne/< L F).


%worlds () (nle-implies-ne _ _).
%total (N) (nle-implies-ne N _).


%theorem leq-nle-contradiction :
	forall* {M1} {M2}
	forall {L:leq M1 M2} {N1:nle M1 M2}
	exists {F:void}
	true.

- : leq-nle-contradiction M1<=M2 (nle/< L1 F2) FALSE
    <- lookup-respects-leq L1 M1<=M2 _ L2 _
    <- not-member-lookup-not-equal F2 L2 N<>N
    <- nat`eq-ne-implies-false nat`eq/ N<>N FALSE.


%worlds () (leq-nle-contradiction _ _ _).
%total { } (leq-nle-contradiction _ _ _).



%%%% Map addition



%%% Definition of union


union : map -> map -> map -> type.


union/L : union map/0 M M.

union/R : union M map/0 M.

union/= : union (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N1 D3 M3)
    <- nat`eq N1 N2
    <- unit`union D1 D2 D3
    <- union M1 M2 M3.

union/< : union (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N1 D1 M3)
    <- nat`plus (s N0) N1 N2
    <- union M1 (map/+ N0 D2 M2) M3.

union/> : union (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N2 D2 M3)
    <- nat`plus (s N3) N2 N1
    <- union (map/+ N3 D1 M1) M2 M3.



%%% Theorems about union


%theorem false-implies-union :
	forall* {M1} {M2} {M3}
	forall {F:void}
	exists {D:union M1 M2 M3}
	true.

%worlds () (false-implies-union _ _).
%total {} (false-implies-union _ _).


%theorem union-respects-eq :
	forall* {M1} {M2} {M3} {M1P} {M2P} {M3P}
	forall {A:union M1 M2 M3} {E1:eq M1 M1P} {E2:eq M2 M2P} {E3:eq M3 M3P}
	exists {AP:union M1P M2P M3P}
	true.

- : union-respects-eq A eq/ eq/ eq/ A.

%worlds () (union-respects-eq _ _ _ _ _).
%total {} (union-respects-eq _ _ _ _ _).
%reduces A = AP (union-respects-eq A _ _ _ AP).


%% A way to get a union fact.

%theorem can-construct-unit-union:
	forall*	{N} {D} {M1} {M}
	forall	{S: shift N M1 M}
	exists	{A: union M (map/+ N D map/0) (map/+ N D M1)}
	true.

- : can-construct-unit-union shift/0 union/L.

- : can-construct-unit-union (shift/+ P) (union/> union/R PPP)
    <- plus-swap-succ P PP
    <- plus-commutative PP PPP.

%worlds () (can-construct-unit-union _ _).
%total { } (can-construct-unit-union _ _).


%% Inversion lemmas for union

%theorem union/=-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {M} 
	forall {A:union (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
	       {G:nat`eq N1 N2}
	exists {D3} {M3} 
	       {D:unit`union D1 D2 D3}
               {AP:union M1 M2 M3}
               {E:eq M (map/+ N1 D3 M3)}
	true.

- : union/=-inversion (union/= MM DD nat`eq/) _ _ _ DD MM eq/.

- : union/=-inversion (union/< (JP:union _ (map/+ N0 D2 M2) M3) N0+1+N=N) nat`eq/ 
                     D2 M3 DJ MJ ME
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- unit`false-implies-union F DJ
    <- false-implies-eq F (M022=M2:eq (map/+ N0 D2 M2) M2)
    <- union-respects-eq JP eq/ M022=M2 eq/ MJ
    <- false-implies-eq F ME.

- : union/=-inversion (union/> (JP:union (map/+ _ D1 M1) M2 M3) N3+1+N=N) nat`eq/
                     D1 M3 DJ MJ ME
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- unit`false-implies-union F DJ
    <- false-implies-eq F (M311=M1:eq (map/+ N3 D1 M1) M1)
    <- union-respects-eq JP M311=M1 eq/ eq/ MJ
    <- false-implies-eq F ME.

%worlds () (union/=-inversion _ _ _ _ _ _ _).
%total {} (union/=-inversion _ _ _ _ _ _ _).
%reduces JP < J (union/=-inversion J _ _ _ _ JP _).


%theorem union/<-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {M} {N0}
	forall {A:union (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
               {P:plus (s N0) N1 N2} 	       
	exists {M3} 
               {AP:union M1 (map/+ N0 D2 M2) M3}
               {E:eq M (map/+ N1 D1 M3)}
	true.

- : union/<-inversion (union/< J P) PP _ JP eq/
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P unit`eq/ eq/ M022=M022P
    <- union-respects-eq J eq/ M022=M022P eq/ JP.

- : union/<-inversion (union/= JP _ nat`eq/) N0+1+N=N M3 J E
    <- plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M2=M022
    <- union-respects-eq JP eq/ M2=M022 eq/ J
    <- false-implies-eq F E.

- : union/<-inversion (union/> JP N3+1+N2=N1) N0+1+N1=N2 M3 J E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M311=M1
    <- false-implies-eq F M2=M022
    <- union-respects-eq JP M311=M1 M2=M022 eq/ J
    <- false-implies-eq F E.

%worlds () (union/<-inversion _ _ _ _ _).
%total {}  (union/<-inversion _ _ _ _ _).
%reduces JP < J (union/<-inversion J _ _ JP _).


%theorem union/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {M} 
	forall {A:union (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
	       {P:plus (s N3) N2 N1}
	exists {M3} 
               {AP:union (map/+ N3 D1 M1) M2 M3}
               {E:eq M (map/+ N2 D2 M3)}
	true.

- : union/>-inversion (union/> J P) PP _ JP eq/
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P unit`eq/ eq/ M311=M311P
    <- union-respects-eq J M311=M311P eq/ eq/ JP.

- : union/>-inversion (union/= JP _ nat`eq/) N3+1+N=N M3 J E
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M1=M311
    <- union-respects-eq JP M1=M311 eq/ eq/ J
    <- false-implies-eq F E.

- : union/>-inversion (union/< JP N0+1+N1=N2) N3+1+N2=N1 M3 J E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M1=M311
    <- false-implies-eq F M022=M2
    <- union-respects-eq JP M1=M311 M022=M2 eq/ J
    <- false-implies-eq F E.

%worlds () (union/>-inversion _ _ _ _ _).
%total {} (union/>-inversion _ _ _ _ _).
%reduces JP < J (union/>-inversion J _ _ JP _).


%theorem false-implies-union-reduces:
	forall*	{M1} {M2} {M3} {M4} {M5} {M6}
	forall	{F: void}
		{J1: union M1 M2 M3}
		{J2: union M4 M5 M6}
	true.

%worlds () (false-implies-union-reduces _ _ _).
%total { } (false-implies-union-reduces _ _ _).
%reduces J2 < J1 (false-implies-union-reduces _ J1 J2).


%theorem union/<-inversion*:
	forall*	{N1} {D1} {M1}
		{N2} {D2} {M2}
		{N3} {D3} {M3}
	forall	{J: union (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N3 D3 M3)}
		{NE: nat`ne N2 N3}
	exists	{N0}
		{EQN: nat`eq N1 N3}
		{EQD: unit`eq D1 D3}
		{P: plus (s N0) N3 N2}
		{J0: union M1 (map/+ N0 D2 M2) M3}
	true.

- : union/<-inversion* (union/< J0 P) _ _ nat`eq/ unit`eq/ P J0.

- : union/<-inversion* J NE nat`z EQN EQD P J0
    <- nat`eq-ne-implies-false nat`eq/ NE F
    <- nat`false-implies-eq F EQN
    <- unit`false-implies-eq F EQD
    <- nat`false-implies-plus F P
    <- false-implies-union F J0
    <- false-implies-union-reduces F J J0.

%worlds () (union/<-inversion* _ _ _ _ _ _ _).
%total { } (union/<-inversion* _ _ _ _ _ _ _).
%reduces JP < J (union/<-inversion* J _ _ _ _ _ JP).


%theorem union/>-inversion*:
	forall*	{N1} {D1} {M1}
		{N2} {D2} {M2}
		{N3} {D3} {M3}
	forall	{J: union (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N3 D3 M3)}
		{NE: nat`ne N1 N3}
	exists	{N0}
		{EQN: nat`eq N2 N3}
		{EQD: unit`eq D2 D3}
		{P: plus (s N0) N3 N1}
		{J0: union (map/+ N0 D1 M1) M2 M3}
	true.

- : union/>-inversion* (union/> J0 P) _ _ nat`eq/ unit`eq/ P J0.

- : union/>-inversion* J NE nat`z EQN EQD P J0
    <- nat`eq-ne-implies-false nat`eq/ NE F
    <- nat`false-implies-eq F EQN
    <- unit`false-implies-eq F EQD
    <- nat`false-implies-plus F P
    <- false-implies-union F J0
    <- false-implies-union-reduces F J J0.

%worlds () (union/>-inversion* _ _ _ _ _ _ _).
%total { } (union/>-inversion* _ _ _ _ _ _ _).
%reduces JP < J (union/>-inversion* J _ _ _ _ _ JP).


%theorem union-deterministic :
	forall* {M1} {M2} {M3} {M1P} {M2P} {M3P}
	forall {A:union M1 M2 M3} {AP:union M1P M2P M3P}
               {E1:eq M1 M1P} {E2:eq M2 M2P}
	exists {E3:eq M3 M3P}
	true.

%abbrev union-unique = union-deterministic.

- : union-deterministic union/L union/L eq/ eq/ eq/.

- : union-deterministic union/L union/R eq/ eq/ eq/.

- : union-deterministic union/R union/L eq/ eq/ eq/.

- : union-deterministic union/R union/R eq/ eq/ eq/.

- : union-deterministic (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
                      (union/= M1+M2=M3P D1+D2=D3P nat`eq/) 
		      eq/ eq/ M=MP
    <- unit`union-deterministic D1+D2=D3 D1+D2=D3P unit`eq/ unit`eq/ D3=D3P
    <- union-deterministic M1+M2=M3 M1+M2=M3P eq/ eq/ M3=M3P
    <- map/+-preserves-eq nat`eq/ D3=D3P M3=M3P M=MP.

- : union-deterministic (union/< M1+MT=M3 N0+1+N1=N2)
                      (union/< M1+MTP=M3P N0P+1+N1=N2)
		      eq/ eq/ M=MP
    <- plus-right-cancels N0+1+N1=N2 N0P+1+N1=N2 nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P unit`eq/ eq/ MT=MTP
    <- union-deterministic M1+MT=M3 M1+MTP=M3P eq/ MT=MTP M3=M3P
    <- map/+-preserves-eq nat`eq/ unit`eq/ M3=M3P M=MP.

- : union-deterministic (union/> MT+M2=M3 N3+1+N2=N1)
                      (union/> MTP+M2=M3P N3P+1+N2=N1) eq/ eq/ E
    <- plus-right-cancels N3+1+N2=N1 N3P+1+N2=N1 nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P unit`eq/ eq/ MT=MTP
    <- union-deterministic MT+M2=M3 MTP+M2=M3P MT=MTP eq/ M3=M3P
    <- map/+-preserves-eq nat`eq/ unit`eq/ M3=M3P E.

%% contradiction cases:

- : union-deterministic (union/= _ _ nat`eq/) (union/< _ NP+1+N=N) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : union-deterministic (union/= _ _ nat`eq/) (union/> _ NP+1+N=N) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : union-deterministic (union/< _ NP+1+N=N) (union/= _ _ nat`eq/) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : union-deterministic (union/< _ N0+1+N1=N2) (union/> _ N3+1+N2=N1) eq/ eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

- : union-deterministic (union/> _ NP+1+N=N) (union/= _ _ nat`eq/) eq/ eq/ E
    <- plus-implies-gt NP+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F E.

- : union-deterministic (union/> _ N3+1+N2=N1) (union/< _ N0+1+N1=N2) eq/ eq/ E
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F E.

%worlds () (union-deterministic _ _ _ _ _).
%total (A) (union-deterministic A _ _ _ _).




%theorem union-total* :
	forall {M1} {M2}
	exists {M3} {A:union M1 M2 M3}
	true.

%% we need some lemmas
%% We need them to ensure termination because
%% union substitutes new maps on recursive calls which
%% makes it hard to prove the arguments get smaller.

%theorem union-map/+-M-total* :
	forall {N1} {D1} {M1} {M2}
        exists {M3} {A:union (map/+ N1 D1 M1) M2 M3}
	true.

%theorem union-M-map/+-total* :
	forall {M1} {N2} {D2} {M2}
        exists {M3} {A:union M1 (map/+ N2 D2 M2) M3}
	true.

%theorem union-map/+-map/+-total* :
	forall {N1} {D1} {M1} {N2} {D2} {M2} {C} {CMP:nat`compare N1 N2 C}
        exists {M3} 
               {A:union (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3}
	true.

- : union-total* map/0 M M union/L.

- : union-total* M map/0 M union/R.

- : union-total* (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3 A
    <- nat`compare-total* N1 N2 C CMP
    <- union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.               

- : union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 equal CMP (map/+ N1 D3 M3)
                           (union/= M1+M2=M3 D1+D2=D3 N1=N2)
    <- equal-implies-eq CMP N1=N2
    <- unit`union-total* D1 D2 D3 D1+D2=D3
    <- union-total* M1 M2 M3 M1+M2=M3.

- : union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 less CMP (map/+ N1 D1 M3)
                           (union/< M1+T=M3 N0+1+N1=N2)
    <- less-implies-lt CMP N2>N1
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- union-M-map/+-total* M1 N0 D2 M2 M3 M1+T=M3.

- : union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 greater CMP (map/+ N2 D2 M3)
                           (union/> T+M2=M3 N3+1+N2=N1)
    <- greater-implies-gt CMP N1>N2
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- union-map/+-M-total* N3 D1 M1 M2 M3 T+M2=M3.

- : union-M-map/+-total* map/0 N2 D2 M2 (map/+ N2 D2 M2) union/L.

- : union-M-map/+-total* (map/+ N1 D1 M1) N2 D2 M2 M3 A
    <- nat`compare-total* N1 N2 C CMP
    <- union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.

- : union-map/+-M-total* N1 D1 M1 map/0 (map/+ N1 D1 M1) union/R.

- : union-map/+-M-total* N1 D1 M1 (map/+ N2 D2 M2) M3 A
    <- nat`compare-total* N1 N2 C CMP
    <- union-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.

%worlds () (union-total* _ _ _ _)
           (union-M-map/+-total* _ _ _ _ _ _)
           (union-map/+-M-total* _ _ _ _ _ _)
           (union-map/+-map/+-total* _ _ _ _ _ _ _ _ _ _).

%total [ (M1a M1b M1c M1d) (M2a M2b M2c M2d) ]
        (union-total* M1d M2d _ _)
        (union-M-map/+-total* M1c _ _ M2c _ _)
        (union-map/+-M-total* _ _ M1b M2b _ _)
	(union-map/+-map/+-total* _ _ M1a _ _ M2a _ _ _ _).
               
%abbrev union-total = union-total* _ _ _.


%theorem disjoint-union-total :
	forall* {M1} {M2} 
	forall {D:disjoint M1 M2}
	exists {M3} {A:union M1 M2 M3}
	true.

- : disjoint-union-total disjoint/L _ union/L. 

- : disjoint-union-total disjoint/R _ union/R.

- : disjoint-union-total (disjoint/< D P) _ (union/< J P)
    <- disjoint-union-total D _ J.

- : disjoint-union-total (disjoint/> D P) _ (union/> J P)
    <- disjoint-union-total D _ J.

%worlds () (disjoint-union-total _ _ _).
%total (D) (disjoint-union-total D _ _).


%theorem disjoint-union-commutative :
        forall* {M1} {M2} {M3}
        forall  {D: disjoint M1 M2}
                {J: union M1 M2 M3}
        exists  {J: union M2 M1 M3}
        true.

- : disjoint-union-commutative _ union/L union/R.

- : disjoint-union-commutative _ union/R union/L.

- : disjoint-union-commutative D (union/= _ _ nat`eq/) J
    <- disjoint/=-contradiction D nat`eq/ F
    <- false-implies-union F J.

- : disjoint-union-commutative D (union/< J1 P) (union/> J1P P)
    <- disjoint/<-inversion D P D1
    <- disjoint-union-commutative D1 J1 J1P.

- : disjoint-union-commutative D (union/> J1 P) (union/< J1P P)
    <- disjoint/>-inversion D P D1
    <- disjoint-union-commutative D1 J1 J1P.

%worlds () (disjoint-union-commutative _ _ _).
%total (J) (disjoint-union-commutative _ J _).


%theorem union-empty-implies-empty :
	forall* {M1} {M2}
	forall {A:union M1 M2 map/0}
	exists {E1:eq M1 map/0} {E2:eq M2 map/0}
	true.

- : union-empty-implies-empty union/L eq/ eq/.

- : union-empty-implies-empty union/R eq/ eq/.

%worlds () (union-empty-implies-empty _ _ _).
%total { } (union-empty-implies-empty _ _ _).


%theorem union-preserves-disjoint* :
	forall* {M1} {M2} {M3} {M4}
	forall {D1:disjoint M1 M4} {D2:disjoint M2 M4}
	       {A:union M1 M2 M3}
	exists {D3:disjoint M3 M4}
	true.

% a lemma that counts the size of maps to help prove termination
%theorem union-preserves-disjoint*/L :
	forall* {M1} {M2} {M3} {M4}
	forall {S1} {S2} {SZ1:size M1 S1} {SZ2:size M2 S2}
               {D1:disjoint M1 M4} {D2:disjoint M2 M4}
	       {A:union M1 M2 M3}
	exists {D3:disjoint M3 M4}
	true.

- : union-preserves-disjoint* D1 D2 J D3
    <- size-total SZ1
    <- size-total SZ2
    <- union-preserves-disjoint*/L _ _ SZ1 SZ2 D1 D2 J D3.

- : union-preserves-disjoint*/L _ _ _ _ disjoint/R _ _ disjoint/R.

- : union-preserves-disjoint*/L _ _ _ _ _ disjoint/R _ disjoint/R.

- : union-preserves-disjoint*/L _ _ _ _ _ D union/L D.

- : union-preserves-disjoint*/L _ _ _ _ D _ union/R D.

- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/< D1 N5+1+N1=N4) D2X 
                               (union/= J _ nat`eq/)
                               (disjoint/< D3 N5+1+N1=N4)
    <- disjoint/<-inversion D2X N5+1+N1=N4 D2
    <- union-preserves-disjoint*/L S1 S2 SZ1 SZ2 D1 D2 J D3.

- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/< D1 N5+1+N1=N4) D2X
                               (union/> J N3+1+N2=N1)
                               (disjoint/< D3 N6+1+N2=N4)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N5+1+N1=N4 N6 N5+1+N3=N6 N6+N2+1=N4
    <- plus-swap-succ-converse N6+N2+1=N4 N6+1+N2=N4
    <- disjoint/<-inversion D2X N6+1+N2=N4 D2
    <- plus-swap-succ N5+1+N3=N6 N5+N3+1=N6
    <- plus-commutative N5+N3+1=N6 N3+1+N5=N6
    <- shift-right-preserves-disjoint D1 (shift/+ N3+1+N5=N6) D1<<N3
    <- union-preserves-disjoint*/L (s S1) S2 (size/+ SZ1) SZ2 D1<<N3 D2 J D3.

- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/> D1 N5+1+N4=N1) D2X 
                               (union/= J DJ nat`eq/)
                               (disjoint/> D3 N5+1+N4=N1)
    <- disjoint/>-inversion D2X N5+1+N4=N1 D2
    <- union-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2) 
                                  D1 D2 (union/= J DJ nat`eq/) D3.

- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/> D1 N5+1+N4=N1) D2X
                               (union/< J N0+1+N1=N2)
                               (disjoint/> D3 N5+1+N4=N1)
    <- plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 N6 N0+1+N5=N6 N6+N4+1=N2
    <- plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2
    <- disjoint/>-inversion D2X N6+1+N4=N2 D2
    <- union-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2) 
                                  D1 D2 (union/< J N0+1+N5=N6) D3.

- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               D1X (disjoint/< D2 N6+1+N2=N4) 
                               (union/< J N0+1+N1=N2)
                               (disjoint/< D3 N5+1+N1=N4)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N6+1+N2=N4 N5 N6+1+N0=N5 N5+N1+1=N4
    <- plus-swap-succ-converse N5+N1+1=N4 N5+1+N1=N4
    <- disjoint/<-inversion D1X N5+1+N1=N4 D1
    <- plus-swap-succ N6+1+N0=N5 N6+N0+1=N5
    <- plus-commutative N6+N0+1=N5 N0+1+N6=N5
    <- shift-right-preserves-disjoint D2 (shift/+ N0+1+N6=N5) D2<<N0
    <- union-preserves-disjoint*/L S1 (s S2) SZ1 (size/+ SZ2) D1 D2<<N0 J D3.

- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               D1X (disjoint/> D2 N6+1+N4=N2)
                               (union/> J N3+1+N2=N1)
                               (disjoint/> D3 N6+1+N4=N2)
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 N5 N3+1+N6=N5 N5+N4+1=N1
    <- plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1
    <- disjoint/>-inversion D1X N5+1+N4=N1 D1
    <- union-preserves-disjoint*/L _ _ (size/+ SZ1) (size/+ SZ2) 
                                  D1 D2 (union/> J N3+1+N6=N5) D3.

- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/< D1 N5+1+N1=N4)
                               (disjoint/> D2 N6+1+N4=N2) JX D3X
    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 N0 N6+1+N5=N0 N0+N1+1=N2
    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2
    <- union/<-inversion JX N0+1+N1=N2 _ J M=M113
    <- eq-symmetric M=M113 M113=M
    <- union-preserves-disjoint*/L S1 (s S2) SZ1 (size/+ SZ2)
                                  D1 (disjoint/> D2 N6+1+N5=N0) J D3
    <- disjoint-respects-eq (disjoint/< D3 N5+1+N1=N4) M113=M eq/ D3X.

- : union-preserves-disjoint*/L (s S1) (s S2) (size/+ SZ1) (size/+ SZ2)
                               (disjoint/> D1 N5+1+N4=N1)
                               (disjoint/< D2 N6+1+N2=N4) JX D3X
    <- plus-swap-succ N6+1+N2=N4 N6+N2+1=N4
    <- plus-associative-converse N6+N2+1=N4 N5+1+N4=N1 N3 N5+1+N6=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- union/>-inversion JX N3+1+N2=N1 _ J M=M223
    <- eq-symmetric M=M223 M223=M
    <- union-preserves-disjoint*/L _ _ (size/+ SZ1) SZ2
                                  (disjoint/> D1 N5+1+N6=N3) D2 J D3
    <- disjoint-respects-eq (disjoint/< D3 N6+1+N2=N4) M223=M eq/ D3X.

%worlds () (union-preserves-disjoint*/L _ _ _ _ _ _ _ _).
%total {S1 S2 D1} (union-preserves-disjoint*/L S1 S2 _ _ D1 _ _ _).

%worlds () (union-preserves-disjoint* _ _ _ _).
%total { } (union-preserves-disjoint* _ _ _ _).


%abbrev union-left-preserves-disjoint* = union-preserves-disjoint*.

%theorem union-right-preserves-disjoint* :
	forall* {M1} {M2} {M3} {M0}
	forall {D1:disjoint M0 M1} {D2:disjoint M0 M2}
	       {A:union M1 M2 M3}
	exists {D3:disjoint M0 M3}
	true.

- : union-right-preserves-disjoint* D1 D2 U D3
    <- disjoint-symmetric D1 D1s
    <- disjoint-symmetric D2 D2s
    <- union-left-preserves-disjoint* D1s D2s U D3s
    <- disjoint-symmetric D3s D3.

%worlds () (union-right-preserves-disjoint* _ _ _ _).
%total { } (union-right-preserves-disjoint* _ _ _ _).


%theorem union-preserves-disjoint-converse:
	forall* {M1} {M2} {M3} {M4}
	forall {D3:disjoint M3 M4}
	       {A:union M1 M2 M3}
	exists {D1:disjoint M1 M4} {D2:disjoint M2 M4}
	true.

- : union-preserves-disjoint-converse
	D union/L disjoint/L D.

- : union-preserves-disjoint-converse
	D union/R D disjoint/L.

- : union-preserves-disjoint-converse
	disjoint/R _
	disjoint/R disjoint/R.

- : union-preserves-disjoint-converse
	(disjoint/< D P)
	(union/= J _ nat`eq/)
	(disjoint/< D1 P) (disjoint/< D2 P)
    <- union-preserves-disjoint-converse D J D1 D2.

- : union-preserves-disjoint-converse
        (disjoint/< D P1)
        (union/< J P2)
	(disjoint/< D1 P1) D2S
    <- union-preserves-disjoint-converse D J D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-disjoint D2 (shift/+ P2sc) (shift/+ P1sc) D2S.

- : union-preserves-disjoint-converse
        (disjoint/< D P1)
        (union/> J P2)
	D1S (disjoint/< D2 P1)
    <- union-preserves-disjoint-converse D J D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-disjoint D1 (shift/+ P2sc) (shift/+ P1sc) D1S.

- : union-preserves-disjoint-converse
	(disjoint/> D P1)
	(union/= J DE nat`eq/)
	D1S D2S
    <- union-preserves-disjoint-converse D (union/= J DE nat`eq/) D1 D2
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- shift-left-preserves-disjoint D1 (shift/+ P1sc) D1S
    <- shift-left-preserves-disjoint D2 (shift/+ P1sc) D2S.

- : union-preserves-disjoint-converse
	(disjoint/> D P1)
	(union/< J P2)
        D1S D2S
    <- plus-swap-succ P1 P1s
    <- plus-associative-converse P1s P2 _ P3 P4s
    <- union-preserves-disjoint-converse D (union/< J P3) D1 D2
    <- plus-commutative P1s P1sc
    <- plus-commutative P4s P4sc
    <- shift-left-preserves-disjoint D1 (shift/+ P1sc) D1S
    <- shift-left-preserves-disjoint D2 (shift/+ P4sc) D2S.

- : union-preserves-disjoint-converse
	(disjoint/> D P1)
	(union/> J P2)
	D1S D2S
    <- plus-swap-succ P1 P1s
    <- plus-associative-converse P1s P2 _ P3 P4s
    <- union-preserves-disjoint-converse D (union/> J P3) D1 D2
    <- plus-commutative P1s P1sc
    <- plus-commutative P4s P4sc
    <- shift-left-preserves-disjoint D1 (shift/+ P4sc) D1S
    <- shift-left-preserves-disjoint D2 (shift/+ P1sc) D2S.

%worlds () (union-preserves-disjoint-converse _ _ _ _).
%total (D) (union-preserves-disjoint-converse D _ _ _).


%theorem disjoint-union-right-cancels :
        forall* {A1} {B1} {C1} {A2} {B2} {C2}
        forall  {D1: disjoint A1 B1}
                {J1: union A1 B1 C1}
                {D2: disjoint A2 B2}
                {J2: union A2 B2 C2}
                {EB: eq B1 B2}
                {EC: eq C1 C2}
        exists  {EA: eq A1 A2}
        true.

%theorem disjoint-union-right-cancels/L :
	forall*	{A} {B} {C}
	forall	{D: disjoint A B}
		{J: union A B C}
		{E: eq B C}
	exists	{E: eq map/0 A}
	true.

- : disjoint-union-right-cancels/L A^B A+B=B eq/ Z=A
    <- disjoint-symmetric A^B B^A
    <- union-preserves-disjoint-converse B^A A+B=B A^A _
    <- disjoint-anti-reflexive A^A Z=A.

%worlds () (disjoint-union-right-cancels/L _ _ _ _).
%total { } (disjoint-union-right-cancels/L _ _ _ _).

- : disjoint-union-right-cancels
        disjoint/L J1 A2^B J2 eq/ eq/ Z=A2
    <- union-deterministic J1 union/L eq/ eq/ C=B
    <- disjoint-union-right-cancels/L A2^B J2 C=B Z=A2.

- : disjoint-union-right-cancels
        A1^B J1 disjoint/L J2 eq/ eq/ A1=Z
    <- union-deterministic J2 union/L eq/ eq/ C=B
    <- disjoint-union-right-cancels/L A1^B J1 C=B Z=A1
    <- eq-symmetric Z=A1 A1=Z.

- : disjoint-union-right-cancels
        disjoint/R J1 _ J2 eq/ eq/ A1=A2
    <- union-deterministic J1 union/R eq/ eq/ A1=C
    <- union-deterministic union/R J2 eq/ eq/ C=A2
    <- eq-transitive A1=C C=A2 A1=A2.

- : disjoint-union-right-cancels
        (disjoint/< D1P P1) J1 (disjoint/< D2P P2) J2 
        eq/ eq/ A111=A222
    <- union/<-inversion J1 P1 _ J1P EQ1
    <- union/<-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C225
    <- map/+-preserves-eq-converse C114=C225 N1=N2 D1=D2 C4=C5
    <- plus-right-cancels P1 P2 N1=N2 nat`eq/ SN4=SN5
    <- succ-cancels SN4=SN5 N4=N5
    <- map/+-preserves-eq N4=N5 unit`eq/ eq/ B4=B5
    <- disjoint-union-right-cancels D1P J1P D2P J2P B4=B5 C4=C5 A1=A2
    <- map/+-preserves-eq N1=N2 D1=D2 A1=A2 A111=A222.

- : disjoint-union-right-cancels
        (disjoint/< D1P P1) J1 (disjoint/> D2P P2) J2 
        eq/ eq/ EQ
    <- union/<-inversion J1 P1 _ J1P EQ1
    <- union/>-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C225
    <- map/+-preserves-eq-converse C114=C225 N1=N2 _ _
    <- plus-implies-gt P1 nat`eq/ N2>N1
    <- gt-respects-eq N2>N1 nat`eq/ N1=N2 N2>N2
    <- gt-anti-reflexive N2>N2 F
    <- false-implies-eq F EQ.

- : disjoint-union-right-cancels
        (disjoint/> D1P P1) J1 (disjoint/< D2P P2) J2 
        eq/ eq/ EQ
    <- union/>-inversion J1 P1 _ J1P EQ1
    <- union/<-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C225
    <- map/+-preserves-eq-converse C114=C225 N1=N2 _ _
    <- plus-implies-gt P2 nat`eq/ N1>N2
    <- gt-respects-eq N1>N2 N1=N2 nat`eq/ N2>N2
    <- gt-anti-reflexive N2>N2 F
    <- false-implies-eq F EQ.

- : disjoint-union-right-cancels
        (disjoint/> D1P P1) J1 (disjoint/> D2P P2) J2 
        eq/ eq/ A111=A222
    <- union/>-inversion J1 P1 _ J1P EQ1
    <- union/>-inversion J2 P2 _ J2P EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-transitive EQ1s EQ2 C114=C115
    <- map/+-preserves-eq-converse C114=C115 _ _ C4=C5
    <- disjoint-union-right-cancels D1P J1P D2P J2P eq/ C4=C5 A411=A511
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-deterministic 
        (shift/+ P1sc) (shift/+ P2sc) nat`eq/ A411=A511 A111=A222.

%worlds () (disjoint-union-right-cancels _ _ _ _ _ _ _).
%total (D) (disjoint-union-right-cancels D _ _ _ _ _ _).


%theorem disjoint-union-left-cancels :
        forall* {A1} {B1} {C1} {A2} {B2} {C2}
        forall  {D1: disjoint A1 B1}
                {J1: union A1 B1 C1}
                {D2: disjoint A2 B2}
                {J2: union A2 B2 C2}
                {EB: eq A1 A2}
                {EC: eq C1 C2}
        exists  {EA: eq B1 B2}
        true.

- : disjoint-union-left-cancels D1 J1 D2 J2 EB EC EA
    <- disjoint-union-commutative D1 J1 J1c
    <- disjoint-union-commutative D2 J2 J2c
    <- disjoint-symmetric D1 D1s
    <- disjoint-symmetric D2 D2s
    <- disjoint-union-right-cancels D1s J1c D2s J2c EB EC EA.

%worlds () (disjoint-union-left-cancels _ _ _ _ _ _ _).
%total { } (disjoint-union-left-cancels _ _ _ _ _ _ _).


%theorem shift-left-preserves-union :
	forall* {N} {D} {M1} {M2} {M3} {SM1}
	forall {A:union M1 M2 M3} {S1:shift N M1 SM1}
        exists {SA:union SM1 (map/+ N D M2) (map/+ N D M3)}
        true.

- : shift-left-preserves-union union/L shift/0 union/L.

- : shift-left-preserves-union union/R shift/0 union/L.

- : shift-left-preserves-union M111+M2=M3 (shift/+ N+1+N1=N1P)
                              (union/> M111+M2=M3 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-union _ _ _).
%total { } (shift-left-preserves-union _ _ _).


%theorem shift-left-preserves-union-converse :
	forall* {N} {D} {M1} {M2} {SM1} {SM3}
	forall {SA:union SM1 (map/+ N D M2) SM3} {S1:shift N M1 SM1}
        exists {M3} {A:union M1 M2 M3} {E:eq (map/+ N D M3) SM3}
	true.

- : shift-left-preserves-union-converse union/L shift/0 _ union/L eq/.

- : shift-left-preserves-union-converse M111+M222=SM3 (shift/+ N2+1+N3=N1) M3
                                       M311+M2=M3 M223=SM3
    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1
    <- union/>-inversion M111+M222=SM3 N3+1+N2=N1 M3 M311+M2=M3 SM3=M223
    <- eq-symmetric SM3=M223 M223=SM3.

%worlds () (shift-left-preserves-union-converse _ _ _ _ _).
%total { } (shift-left-preserves-union-converse _ _ _ _ _).


%theorem shift-right-preserves-union :
	forall* {N} {D} {M1} {M2} {M3} {SM2}
	forall {A:union M1 M2 M3} {S2:shift N M2 SM2}
        exists {SA:union (map/+ N D M1) SM2 (map/+ N D M3)}
	true.

- : shift-right-preserves-union union/L shift/0 union/R.

- : shift-right-preserves-union union/R shift/0 union/R.

- : shift-right-preserves-union M1+M222=M3 (shift/+ N+1+N2=N2P) 
                               (union/< M1+M222=M3 N2+1+N=N2P)
    <- plus-swap-succ N+1+N2=N2P N+N2+1=N2P
    <- plus-commutative N+N2+1=N2P N2+1+N=N2P.

%worlds () (shift-right-preserves-union _ _ _).
%total { } (shift-right-preserves-union _ _ _).


%theorem shift-right-preserves-union-converse :
	forall* {N} {D} {M1} {M2} {SM2} {SM3}
	forall {SA:union (map/+ N D M1) SM2 SM3} {S2:shift N M2 SM2}
        exists {M3} {A:union M1 M2 M3} {E:eq (map/+ N D M3) SM3}
	true.

- : shift-right-preserves-union-converse union/R shift/0 _ union/R eq/.

- : shift-right-preserves-union-converse M111+M322=SM3 (shift/+ N1+1+N2=N3)
                                        M3 M1+M222=M3 M133=SM3
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- union/<-inversion M111+M322=SM3 N2+1+N1=N3 M3 M1+M222=M3 SM3=M133
    <- eq-symmetric SM3=M133 M133=SM3.

%worlds () (shift-right-preserves-union-converse _ _ _ _ _).
%total { } (shift-right-preserves-union-converse _ _ _ _ _).


%theorem shift-preserves-union* :
	forall* {N} {M1} {M2} {M3} {SM1} {SM2} {SM3}
	forall {A:union M1 M2 M3} 
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} {S3:shift N M3 SM3}
	exists {SA:union SM1 SM2 SM3}
	true.

- : shift-preserves-union* union/L shift/0 M2<<N=SM2 M2<<N=SM3 Z+SM2=SM3
    <- shift-deterministic M2<<N=SM2 M2<<N=SM3 nat`eq/ eq/ SM2=SM3
    <- union-respects-eq union/L eq/ eq/ SM2=SM3 Z+SM2=SM3.

- : shift-preserves-union* union/R M1<<N=SM1 shift/0 M1<<N=SM3 SM1+0=SM3
    <- shift-deterministic M1<<N=SM1 M1<<N=SM3 nat`eq/ eq/ SM1=SM3
    <- union-respects-eq union/R eq/ eq/ SM1=SM3 SM1+0=SM3.

- : shift-preserves-union* (union/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N1=N5) 
                          (shift/+ N+1+N1=N6)
                          M411+M522=M633
    <- plus-deterministic N+1+N1=N4 N+1+N1=N5 nat`eq/ nat`eq/ N4=N5
    <- plus-deterministic N+1+N1=N4 N+1+N1=N6 nat`eq/ nat`eq/ N4=N6
    <- map/+-preserves-eq N4=N6 unit`eq/ eq/ M433=M633
    <- union-respects-eq (union/= M1+M2=M3 D1+D2=D3 N4=N5) eq/ eq/ M433=M633
                        M411+M522=M633.

- : shift-preserves-union* (union/< M1+M022=M3 N0+1+N1=N2)
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) 
                          (shift/+ N+1+N1=N6) M411+M522=M613
    <- plus-deterministic N+1+N1=N4 N+1+N1=N6 nat`eq/ nat`eq/ N4=N6
    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4
    <- plus-commutative N+N1+1=N4 N1+1+N=N4
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5
    <- map/+-preserves-eq N4=N6 unit`eq/ eq/ M433=M613
    <- union-respects-eq (union/< M1+M022=M3 N0+1+N4=N5) eq/ eq/ M433=M613
                        M411+M522=M613.

- : shift-preserves-union* (union/> M311+M2=M3 N3+1+N2=N1)
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) 
                          (shift/+ N+1+N2=N6) M411+M522=M623
    <- plus-deterministic N+1+N2=N5 N+1+N2=N6 nat`eq/ nat`eq/ N5=N6
    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5
    <- plus-commutative N+N2+1=N5 N2+1+N=N5
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- map/+-preserves-eq N5=N6 unit`eq/ eq/ M523=M623
    <- union-respects-eq (union/> M311+M2=M3 N3+1+N5=N4) eq/ eq/ M523=M623
                        M411+M522=M623.

%worlds () (shift-preserves-union* _ _ _ _ _).
%total { } (shift-preserves-union* _ _ _ _ _).


%theorem shift-preserves-union :
	forall* {N} {M1} {M2} {M3} {SM1} {SM2}
	forall  {A:union M1 M2 M3} 
                {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	exists	{SM3} 
		{S3:shift N M3 SM3}
		{SA:union SM1 SM2 SM3}
	true.

- : shift-preserves-union J S1 S2 _ S3 JP
    <- shift-total S3
    <- shift-preserves-union* J S1 S2 S3 JP.

%worlds () (shift-preserves-union _ _ _ _ _ _).
%total { } (shift-preserves-union _ _ _ _ _ _).


%theorem shift-preserves-union-converse :
	forall* {N} {M1} {M2} {SM1} {SM2} {SM3}
	forall {SA:union SM1 SM2 SM3}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	exists {M3} {A:union M1 M2 M3} {S3:shift N M3 SM3}
	true.

- : shift-preserves-union-converse union/L shift/0 M2<<N=SM2 _ union/L M2<<N=SM2.

- : shift-preserves-union-converse union/R M1<<N=SM1 shift/0 _ union/R M1<<N=SM1.

- : shift-preserves-union-converse (union/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N1P=N4)
                                  (map/+ N1 D3 M3) M111+M122P=M133
                                  (shift/+ N+1+N1=N4)
    <- plus-left-cancels N+1+N1=N4 N+1+N1P=N4 nat`eq/ nat`eq/ N1=N1P
    <- map/+-preserves-eq N1=N1P unit`eq/ eq/ M122=M122P
    <- union-respects-eq (union/= M1+M2=M3 D1+D2=D3 nat`eq/) eq/ M122=M122P eq/
                        M111+M122P=M133.

- : shift-preserves-union-converse (union/< M1+M055=M3 N0+1+N4=N5)
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) _
				  (union/< M1+M055=M3 N0+1+N1=N2)
				  (shift/+ N+1+N1=N4)
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4
    <- plus-associative-converse N1+N+1=N4 N0+1+N4=N5 N2P N0+1+N1=N2P N2P+N+1=N5
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-right-cancels N2P+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2P=N2
    <- plus-respects-eq N0+1+N1=N2P nat`eq/ nat`eq/ N2P=N2 N0+1+N1=N2.
                                  
- : shift-preserves-union-converse (union/> M611+M2=M3 N6+1+N5=N4)
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) _
                                  (union/> M611+M2=M3 N6+1+N2=N1)
                                  (shift/+ N+1+N2=N5)
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5
    <- plus-associative-converse N2+N+1=N5 N6+1+N5=N4 N1P N6+1+N2=N1P N1P+N+1=N4
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-right-cancels N1P+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1P=N1
    <- plus-respects-eq N6+1+N2=N1P nat`eq/ nat`eq/ N1P=N1 N6+1+N2=N1.

%worlds () (shift-preserves-union-converse _ _ _ _ _ _).
%total { } (shift-preserves-union-converse _ _ _ _ _ _).


% arguably: this should be the non-starred version
%theorem shift-preserves-union-converse* :
	forall* {N} {M3} {SM1} {SM2} {SM3}
	forall {SA:union SM1 SM2 SM3}  {S3:shift N M3 SM3}
	exists {M1} {M2}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	       {A:union M1 M2 M3}
	true.

- : shift-preserves-union-converse* U shift/0 _ _ shift/0 shift/0 union/L.

- : shift-preserves-union-converse* union/L S _ _ shift/0 S union/L.

- : shift-preserves-union-converse* union/R S _ _ S shift/0 union/R.

- : shift-preserves-union-converse* (union/= U DJ nat`eq/) (shift/+ P) _ _
	(shift/+ P) (shift/+ P) (union/= U DJ nat`eq/).

- : shift-preserves-union-converse* (union/< U D+1+A=B) 
	(shift/+ N+1+Y=A) _ _
	(shift/+ N+1+Y=A)
	(shift/+ N+1+Z=B)
	(union/< U D+1+Y=Z)
    <- plus-commutative N+1+Y=A Y+N+1=A
    <- plus-associative-converse Y+N+1=A D+1+A=B Z D+1+Y=Z Z+N+1=B
    <- plus-commutative Z+N+1=B N+1+Z=B.

- : shift-preserves-union-converse* (union/> U D+1+B=A)
	(shift/+ N+1+Y=B) _ _
	(shift/+ N+1+Z=A)
	(shift/+ N+1+Y=B)
	(union/> U D+1+Y=Z)
    <- plus-commutative N+1+Y=B Y+N+1=B
    <- plus-associative-converse Y+N+1=B D+1+B=A Z D+1+Y=Z Z+N+1=A
    <- plus-commutative Z+N+1=A N+1+Z=A.

%worlds () (shift-preserves-union-converse* _ _ _ _ _ _ _).
%total { } (shift-preserves-union-converse* _ _ _ _ _ _ _).


%theorem shift-preserves-union-converse** :
	forall* {N} {M1} {M2} {M3} {SM1} {SM2} {SM3}
	forall {SA:union SM1 SM2 SM3}  {S3:shift N M3 SM3}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	exists {A:union M1 M2 M3}
	true.

- : shift-preserves-union-converse** JP S3 S1 S2 J
    <- shift-preserves-union-converse JP S1 S2 _ JX S3X
    <- shift-cancels S3X S3 nat`eq/ eq/ M3X=M3
    <- union-respects-eq JX eq/ eq/ M3X=M3 J.

%worlds () (shift-preserves-union-converse** _ _ _ _ _).
%total { } (shift-preserves-union-converse** _ _ _ _ _).



%theorem union-commutative :
	forall* {M1} {M2} {M3}
	forall {A:union M1 M2 M3}
	exists {AP:union M2 M1 M3}
	true.

- : union-commutative union/L union/R.

- : union-commutative union/R union/L.

- : union-commutative (union/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                     (union/= M2+M1=M3 D2+D1=D3 nat`eq/)
    <- unit`union-commutative D1+D2=D3 D2+D1=D3
    <- union-commutative M1+M2=M3 M2+M1=M3.

- : union-commutative (union/< M1+MT=M3 N0+1+N1=N2) (union/> MT+M1=M3 N0+1+N1=N2)
    <- union-commutative M1+MT=M3 MT+M1=M3.

- : union-commutative (union/> MT+M2=M3 N3+1+N2=N1) (union/< M2+MT=M3 N3+1+N2=N1)
    <- union-commutative MT+M2=M3 M2+MT=M3.

%worlds () (union-commutative _ _).
%total (A) (union-commutative A _).




%theorem union-associative :
	forall* {M1} {M2} {M3} {M4} {M7}
	forall {A12:union M1 M2 M3} {A34:union M3 M4 M7}
	exists {M6} {A24:union M2 M4 M6} {A16:union M1 M6 M7}
	true.

%% a lemma

%theorem union-associative-union/<-union/< :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N0} {N5} {N4} {D4} {M4} {M6} {M7}
	forall {PLUS012:nat`plus (s N0) N1 N2}
               {PLUS514:nat`plus (s N5) N1 N4}
               {JOIN246:union (map/+ N0 D2 M2) (map/+ N5 D4 M4) M6}
               {JOIN167:union M1 M6 M7}
        exists {M} {JOIN24: union (map/+ N2 D2 M2) (map/+ N4 D4 M4) M}
               {JOIN:union (map/+ N1 D1 M1) M (map/+ N1 D1 M7)}
        true.
               
- : union-associative union/L A _ A union/L.

- : union-associative A union/R _ union/R A.

- : union-associative union/R A _ union/L A.

- : union-associative (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
                    (union/= M3+M4=M7 D3+D4=D7 nat`eq/) (map/+ _ D6 M6)
                    (union/= M2+M4=M6 D2+D4=D6 nat`eq/)
		    (union/= M1+M6=M7 D1+D6=D7 nat`eq/)
    <- unit`union-associative D1+D2=D3 D3+D4=D7 D6 D2+D4=D6 D1+D6=D7
    <- union-associative M1+M2=M3 M3+M4=M7 M6 M2+M4=M6 M1+M6=M7.

- : union-associative (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
                    (union/< M3+M044=M7 N0+1+N3=N4) (map/+ _ _ M6) 
                    (union/< M2+M044=M6 N0+1+N3=N4) 
                    (union/= M1+M6=M7 D1+D2=D3 nat`eq/)
    <- union-associative M1+M2=M3 M3+M044=M7 M6 M2+M044=M6 M1+M6=M7.

- : union-associative (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
	            (union/> M533+M4=M7 N5+1+N4=N3) (map/+ _ _ M6)
                    (union/> M522+M4=M6 N5+1+N4=N3)
                    (union/> M511+M6=M7 N5+1+N4=N3)
    <- union-associative (union/= M1+M2=M3 D1+D2=D3 nat`eq/) M533+M4=M7
                       M6 M522+M4=M6 M511+M6=M7.

- : union-associative (union/< M1+M022=M3 N0+1+N1=N2)
                     (union/= M3+M4=M7 D1+D4=D7 nat`eq/) (map/+ _ _ M6)
                     (union/> M022+M3=M6 N0+1+N1=N2)
                     (union/= M1+M6=M7 D1+D4=D7 nat`eq/)
    <- union-associative M1+M022=M3 M3+M4=M7 M6 M022+M3=M6 M1+M6=M7.

%% the hardest of all 11 cases!

- : {M111+M=M117: union (map/+ N1 D1 M1) M (map/+ N1 D1 M7)}
    {M3+M544=M7: union M3 (map/+ N5 D4 M4) M7}
    {M1+M022=M3: union M1 (map/+ N0 D2 M2) M3}
    {M1+M6=M7: union M1 M6 M7}
    union-associative (union/< M1+M022=M3 N0+1+N1=N2)
       		     (union/< M3+M544=M7 N5+1+N1=N4) 
		     M M222+M444=M M111+M=M117
    <- union-associative M1+M022=M3 M3+M544=M7 M6 M022+M544=M6 M1+M6=M7
    <- union-associative-union/<-union/< 
       		N0+1+N1=N2 N5+1+N1=N4 M022+M544=M6 M1+M6=M7 
       		M M222+M444=M M111+M=M117.

- : union-associative-union/<-union/< N+1+N1=N2 N+1+N1=N4
                                   (union/= M2+M4=M6 D2+D4=D6 nat`eq/) 
                                   M1+M066=M7 (map/+ N2 D6 M6)
                                   (union/= M2+M4=M6 D2+D4=D6 N2=N4)
                                   (union/< M1+M066=M7 N+1+N1=N2)
    <- nat`plus-deterministic N+1+N1=N2 N+1+N1=N4 nat`eq/ nat`eq/ N2=N4.

- : union-associative-union/<-union/< N0+1+N1=N2 N5+1+N1=N4
                                   (union/< M2+M744=M6 N7+1+N0=N5)
                                   M1+M026=M7 (map/+ N2 D2 M6)
     				   (union/< M2+M744=M6 N7+1+N2=N4)
                                   (union/< M1+M026=M7 N0+1+N1=N2)
    <- nat`plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- nat`plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- nat`plus-associative* N7+1+N0=N5 N5+N1+1=N4 N0+N1+1=N2 N7+1+N2=N4.

- : union-associative-union/<-union/< N0+1+N1=N2 N5+1+N1=N4
                                   (union/> M722+M4=M6 N7+1+N5=N0)
                                   M1+M546=M7 (map/+ N4 D4 M6)
                                   (union/> M722+M4=M6 N7+1+N4=N2)
                                   (union/< M1+M546=M7 N5+1+N1=N4)
    <- nat`plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- nat`plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- nat`plus-associative* N7+1+N5=N0 N0+N1+1=N2 N5+N1+1=N4 N7+1+N4=N2.

%% and now we return to the main theorem

- : union-associative (union/< M1+M022=M3 N0+1+N1=N2)
		    (union/> M513+M4=M7 N5+1+N3=N1) (map/+ _ _ M6)
                    (union/> M622+M4=M6 N6+1+N3=N2)
                    (union/> M511+M6=M7 N5+1+N3=N1)
    <- nat`plus-swap-succ N5+1+N3=N1 N5+N3+1=N1
    <- nat`plus-associative-converse N5+N3+1=N1 N0+1+N1=N2 N6
                                     N0+1+N5=N6 N6+N3+1=N2
    <- nat`plus-swap-succ-converse N6+N3+1=N2 N6+1+N3=N2
    <- union-associative (union/< M1+M022=M3 N0+1+N5=N6) M513+M4=M7 
                       M6 M622+M4=M6 M511+M6=M7.

- : union-associative (union/> M311+M2=M3 N3+1+N2=N1)
                    (union/= M3+M4=M7 D2+D4=D7 nat`eq/) (map/+ _ _ M6)
                    (union/= M2+M4=M6 D2+D4=D7 nat`eq/)
                    (union/> M311+M6=M7 N3+1+N2=N1)
    <- union-associative M311+M2=M3 M3+M4=M7 M6 M2+M4=M6 M311+M6=M7.

- : union-associative (union/> M311+M2=M3 N3+1+N2=N1)
                    (union/< M3+M044=M7 N0+1+N2=N4) (map/+ _ _ M6)
                    (union/< M2+M044=M6 N0+1+N2=N4)
                    (union/> M311+M6=M7 N3+1+N2=N1)
    <- union-associative M311+M2=M3 M3+M044=M7 M6 M2+M044=M6 M311+M6=M7.

- : union-associative (union/> M311+M2=M3 N3+1+N2=N1)
                    (union/> M523+M4=M7 N5+1+N4=N2) (map/+ _ _ M6)
		    (union/> M522+M4=M6 N5+1+N4=N2)
                    (union/> M711+M6=M7 N7+1+N4=N1)
    <- nat`plus-swap-succ N5+1+N4=N2 N5+N4+1=N2
    <- nat`plus-associative-converse N5+N4+1=N2 N3+1+N2=N1 
                                     N7 N3+1+N5=N7 N7+N4+1=N1
    <- nat`plus-swap-succ-converse N7+N4+1=N1 N7+1+N4=N1
    <- union-associative (union/> M311+M2=M3 N3+1+N5=N7) M523+M4=M7
                       M6 M522+M4=M6 M711+M6=M7.

%worlds () (union-associative-union/<-union/< _ _ _ _ _ _ _).
%total {} (union-associative-union/<-union/< _ _ _ _ _ _ _).

%worlds () (union-associative _ _ _ _ _).
%total (J) (union-associative _ J _ _ _).


%theorem union-associative* :
	forall* {X1} {X2} {X12} {X3} {X23} {X123}
        forall {OP12:union X1 X2 X12} {OP12-3:union X12 X3 X123} {OP23:union X2 X3 X23}
        exists {OP1-23:union X1 X23 X123}
        true.

- : union-associative* X1+X2=X3 X3+X4=X7 X2+X4=X6 X1+X6=X7
    <- union-associative X1+X2=X3 X3+X4=X7 Y6 X2+X4=Y6 X1+Y6=X7
    <- union-unique X2+X4=Y6 X2+X4=X6 eq/ eq/ Y6=X6
    <- union-respects-eq X1+Y6=X7 eq/ Y6=X6 eq/ X1+X6=X7.

%worlds () (union-associative* _ _ _ _).
%total {} (union-associative* _ _ _ _).


%theorem union-associative-converse :
	forall* {X1} {X2} {X4} {X6} {X7}
	forall {OP24:union X2 X4 X6} {OP16:union X1 X6 X7}
        exists {X3} {OP12:union X1 X2 X3} {OP34:union X3 X4 X7}
        true.

- : union-associative-converse X2+X4=X6 X1+X6=X7 _ X1+X2=X3 X3+X4=X7
    <- union-commutative X2+X4=X6 X4+X2=X6
    <- union-commutative X1+X6=X7 X6+X1=X7
    <- union-associative X4+X2=X6 X6+X1=X7 _ X2+X1=X3 X4+X3=X7
    <- union-commutative X2+X1=X3 X1+X2=X3
    <- union-commutative X4+X3=X7 X3+X4=X7.

%worlds () (union-associative-converse X2+X4=X6 X1+X6=X7 X3 X1+X2=X3 X3+X4=X7).
%total {} (union-associative-converse _ _ _ _ _).


%theorem union-associative-converse* :
	forall* {X1} {X2} {X3} {X4} {X6} {X7}
	forall {OP24:union X2 X4 X6} {OP16:union X1 X6 X7} {OP12:union X1 X2 X3} 
	exists {OP34:union X3 X4 X7}
        true.

- : union-associative-converse* X2+X4=X6 X1+X6=X7 X1+X2=X3 X3+X4=X7
    <- union-associative-converse X2+X4=X6 X1+X6=X7 X3P X1+X2=X3P X3P+X4=X7
    <- union-unique X1+X2=X3P X1+X2=X3 eq/ eq/ X3P=X3
    <- union-respects-eq X3P+X4=X7 X3P=X3 eq/ eq/ X3+X4=X7.

%worlds () (union-associative-converse* X2+X4=X6 X1+X6=X7 X1+X2=X3 %{=>}% X3+X4=X7).
%total {} (union-associative-converse* _ _ _ _).

%% The following two theorems are useful for reordering elements
%% is a left-associative sequence of operations.

%theorem union-assoc-commutative* :
	forall* {X1} {X2} {X3} {X4} {X5} {X7}
	forall {OP1:union X1 X2 X3} {OP2:union X3 X4 X7}
               {OP3:union X1 X4 X5} 
        exists {OP4:union X5 X2 X7}
	true.

- : union-assoc-commutative* X1+X2=X3 X3+X4=X7 X1+X4=X5 X5+X2=X7
    <- union-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7
    <- union-commutative X2+X4=X6 X4+X2=X6
    <- union-associative-converse* X4+X2=X6 X1+X6=X7 X1+X4=X5 X5+X2=X7.

%worlds () (union-assoc-commutative* X1+X2=X3 X3+X4=X7 X1+X4=X5 %{=>}% X5+X2=X7).
%total {} (union-assoc-commutative* _ _ _ _).


%theorem union-assoc-commutative :
	forall* {X1} {X2} {X3} {X4} {X7}
	forall {OP1:union X1 X2 X3} {OP2:union X3 X4 X7}
        exists {X5} {OP3:union X1 X4 X5} {OP4:union X5 X2 X7}
	true.

- : union-assoc-commutative X1+X2=X3 X3+X4=X7 X5 X1+X4=X5 X5+X2=X7
    <- union-associative X1+X2=X3 X3+X4=X7 X6 X2+X4=X6 X1+X6=X7
    <- union-commutative X2+X4=X6 X4+X2=X6
    <- union-associative-converse X4+X2=X6 X1+X6=X7 X5 X1+X4=X5 X5+X2=X7.

%worlds () (union-assoc-commutative X1+X2=X3 X3+X4=X7 %{=>}% X5 X1+X4=X5 X5+X2=X7).
%total {} (union-assoc-commutative _ _ _ _ _).

%% The following theorem is a useful shortcut to
%% re-associate (AB)(CD) to (AC)(BD):

%theorem union-double-associative* :
	forall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}
	forall {AB:union A B A+B} {CD:union C D C+D} {ABCD:union A+B C+D X}
	       {AC:union A C A+C} {BD:union B D B+D} 
        exists {ACBD:union A+C B+D X}
	true.

- : union-double-associative* X1+X2=X3 X4+X8=XC X3+XC=XF X1+X4=X5 X2+X8=XA X5+XA=XF
    <- union-associative X1+X2=X3 X3+XC=XF XE X2+XC=XE X1+XE=XF
    <- union-commutative X4+X8=XC X8+X4=XC
    <- union-associative-converse* X8+X4=XC X2+XC=XE X2+X8=XA XA+X4=XE
    <- union-commutative XA+X4=XE X4+XA=XE
    <- union-associative-converse* X4+XA=XE X1+XE=XF X1+X4=X5 X5+XA=XF.

%worlds () (union-double-associative* X1+X2=X3 X4+X8=XC X3+XC=XF X1+X4=X5 X2+X8=XA
                            %{=>}% X5+XA=XF).
%total {} (union-double-associative* _ _ _ _ _ _).


%theorem union-double-associative :
	forall* {A} {B} {C} {D} {A+B} {C+D} {X}
	forall {AB:union A B A+B} {CD:union C D C+D} {ABCD:union A+B C+D X}
	exists {A+C} {B+D} {AC:union A C A+C} {BD:union B D B+D} 
               {ACBD:union A+C B+D X}
	true.

- : union-double-associative X1+X2=X3 X4+X8=XC X3+XC=XF X5 XA X1+X4=X5 X2+X8=XA X5+XA=XF
    <- union-associative X1+X2=X3 X3+XC=XF XE X2+XC=XE X1+XE=XF
    <- union-commutative X4+X8=XC X8+X4=XC
    <- union-associative-converse X8+X4=XC X2+XC=XE XA X2+X8=XA XA+X4=XE
    <- union-commutative XA+X4=XE X4+XA=XE
    <- union-associative-converse X4+XA=XE X1+XE=XF X5 X1+X4=X5 X5+XA=XF.

%worlds () (union-double-associative _ _ _ _ _ _ _ _).
%total { } (union-double-associative _ _ _ _ _ _ _ _).


%theorem lookup-implies-union :
	forall* {M} {N} {D}
	forall {L:lookup M N D}
	exists {M-} {F:not-member M- N}
	       {A:union (map/+ N D map/0) M- M}
	true.

- : lookup-implies-union (lookup/= nat`eq/) _
                        (not-member/0) (union/R).

- : lookup-implies-union (lookup/= nat`eq/) _
                        (not-member/< N2>N1) 
                        (union/< union/L N0+1+N1=N2)
    <- nat`plus-total N0+1+N1=N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1.

- : lookup-implies-union (lookup/> L N0+1+N1=N2) _
                        (not-member/> F N0+1+N1=N2)
			(union/> A N0+1+N1=N2)
    <- lookup-implies-union  L _ F A.

%worlds () (lookup-implies-union _ _ _ _).
%total (L) (lookup-implies-union L _ _ _).


%theorem union-joins-lookup :
	forall* {M1} {M2} {M3} {N} {D1} {D2}
	forall {L1:lookup M1 N D1} {L2:lookup M2 N D2}
               {A:union M1 M2 M3}
	exists {D3} {J:unit`union D1 D2 D3} {L3:lookup M3 N D3}
	true.

- : union-joins-lookup (lookup/= nat`eq/) (lookup/= nat`eq/) A
                           _ AD L3
    <- union/=-inversion A nat`eq/ _ _ AD _ M=M133
    <- eq-symmetric M=M133 M133=M
    <- lookup-respects-eq (lookup/= nat`eq/) M133=M nat`eq/ unit`eq/ L3.

- : union-joins-lookup (lookup/> L1 N0+1+N1=N2)
                           (lookup/= nat`eq/) A _ AD L3P
    <- union/<-inversion A N0+1+N1=N2 M3 M1+M022=M3 M=M113
    <- union-joins-lookup L1 (lookup/= nat`eq/) M1+M022=M3 _ AD L3
    <- eq-symmetric M=M113 M113=M
    <- lookup-respects-eq (lookup/> L3 N0+1+N1=N2) M113=M  nat`eq/ unit`eq/ L3P.

- : union-joins-lookup (lookup/= nat`eq/) 
                           (lookup/> L2 N3+1+N2=N1) A _ AD L3P
    <- union/>-inversion A N3+1+N2=N1 M3 M311+M2=M3 M=M223
    <- union-joins-lookup (lookup/= nat`eq/) L2 M311+M2=M3 _ AD L3
    <- eq-symmetric M=M223 M223=M
    <- lookup-respects-eq (lookup/> L3 N3+1+N2=N1) M223=M  nat`eq/ unit`eq/ L3P.

- : union-joins-lookup (lookup/> L1P N4+1+N1=N)
                           (lookup/> L2 N5+1+N2=N)
                           (union/= M1+M2=M3 _ nat`eq/) _ AD
                           (lookup/> L N5+1+N2=N)
    <- plus-right-cancels N4+1+N1=N N5+1+N2=N nat`eq/ nat`eq/ N4+1=N5+1
    <- succ-cancels N4+1=N5+1 N4=N5
    <- lookup-respects-eq L1P eq/ N4=N5 unit`eq/ L1
    <- union-joins-lookup L1 L2 M1+M2=M3 _ AD L.

- : union-joins-lookup (lookup/> L1 N4+1+N1=N)
                           (lookup/> L2 N5+1+N2=N)
                           (union/< M1+M022=M3 N0+1+N1=N2) _ AD
			   (lookup/> L3 N4+1+N1=N)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N5+1+N2=N N6 N5+1+N0=N6 N6+N1+1=N
    <- plus-swap-succ N4+1+N1=N N4+N1+1=N
    <- plus-right-cancels N6+N1+1=N N4+N1+1=N nat`eq/ nat`eq/ N6=N4
    <- plus-respects-eq N5+1+N0=N6 nat`eq/ nat`eq/ N6=N4 N5+1+N0=N4
    <- union-joins-lookup 
       L1 (lookup/> L2 N5+1+N0=N4) M1+M022=M3 _ AD L3.

- : union-joins-lookup (lookup/> L1 N4+1+N1=N)
                           (lookup/> L2 N5+1+N2=N)
                           (union/> M311+M2=M3 N3+1+N2=N1) _ AD
                           (lookup/> L3 N5+1+N2=N)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N4+1+N1=N N6 N4+1+N3=N6 N6+N2+1=N
    <- plus-swap-succ N5+1+N2=N N5+N2+1=N
    <- plus-right-cancels N6+N2+1=N N5+N2+1=N nat`eq/ nat`eq/ N6=N5
    <- plus-respects-eq N4+1+N3=N6 nat`eq/ nat`eq/ N6=N5 N4+1+N3=N5
    <- union-joins-lookup
       (lookup/> L1 N4+1+N3=N5) L2 M311+M2=M3 _ AD L3.

%worlds () (union-joins-lookup _ _ _ _ _ _).
%total (A) (union-joins-lookup _ _ A _ _ _).


%theorem union-joins-lookup* :
	forall* {M1} {M2} {M3} {N} {D1} {D2} {D3}
	forall {L1:lookup M1 N D1} {L2:lookup M2 N D2}
               {A:union M1 M2 M3}
	       {J:unit`union D1 D2 D3} 
	exists {L3:lookup M3 N D3}
	true.

- : union-joins-lookup* L1 L2 A J L3
    <- union-joins-lookup L1 L2 A _ JP L3P
    <- unit`union-deterministic JP J unit`eq/ unit`eq/ D3P=D3
    <- lookup-respects-eq L3P eq/ nat`eq/ D3P=D3 L3.

%worlds () (union-joins-lookup* _ _ _ _ _).
%total { } (union-joins-lookup* _ _ _ _ _).


%theorem union-commutes-lookup :
	forall* {M1} {M2} {M3} {N} {D1} {D2} {D3}
	forall {A:union M1 M2 M3}
	       {L1:lookup M1 N D1} {L2:lookup M2 N D2}
               {L3:lookup M3 N D3}	       
	exists {J:unit`union D1 D2 D3} 
	true.

- : union-commutes-lookup M1+M2=M3 L1 L2 L3 D1+D2=D3
    <- union-joins-lookup L1 L2 M1+M2=M3 D3X D1+D2=D3X L3X
    <- lookup-unique L3X L3 eq/ nat`eq/ D3X=D3
    <- unit`union-respects-eq D1+D2=D3X unit`eq/ unit`eq/ D3X=D3 D1+D2=D3.

%worlds () (union-commutes-lookup _ _ _ _ _).
%total { } (union-commutes-lookup _ _ _ _ _).


%theorem union-preserves-not-member* :
	forall* {M1} {M2} {M3} {N}
	forall {F1:not-member M1 N} {F2:not-member M2 N}
               {A:union M1 M2 M3}
	exists {F3:not-member M3 N}
	true.
	
- : union-preserves-not-member* _ F union/L F.

- : union-preserves-not-member* F _ union/R F.

- : union-preserves-not-member* (not-member/< N<N1) (not-member/< _) (union/= _ _ _) 
                          (not-member/< N<N1).

- : union-preserves-not-member* (not-member/< N<N1) (not-member/< _) (union/< _ _) 
                          (not-member/< N<N1).

- : union-preserves-not-member* (not-member/< _) (not-member/< N<N2) (union/> _ _) 
                          (not-member/< N<N2).

- : union-preserves-not-member* (not-member/< N<N1) (not-member/> F2 N4+1+N2=N) AX F3X
    <- gt-implies-plus N<N1 N0 N0+1+N=N1
    <- plus-swap-succ N4+1+N2=N N4+N2+1=N
    <- plus-associative-converse N4+N2+1=N N0+1+N=N1 N3 N0+1+N4=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- union/>-inversion AX N3+1+N2=N1 M3 A M=M223
    <- plus-implies-gt N0+1+N4=N3 nat`eq/ N4<N3
    <- union-preserves-not-member* (not-member/< N4<N3) F2 A F3
    <- eq-symmetric M=M223 M223=M
    <- not-member-respects-eq (not-member/> F3 N4+1+N2=N) M223=M nat`eq/ F3X.

- : union-preserves-not-member* (not-member/> F1 N3+1+N1=N) (not-member/< N<N2) AX F3X
    <- gt-implies-plus N<N2 N4 N4+1+N=N2
    <- plus-swap-succ N3+1+N1=N N2+N1+1=N
    <- plus-associative-converse N2+N1+1=N N4+1+N=N2 N0 N4+1+N2=N0 N0+N1+1=N2
    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2
    <- union/<-inversion AX N0+1+N1=N2 M3 A M=M113
    <- plus-implies-gt N4+1+N2=N0 nat`eq/ N2<N0
    <- union-preserves-not-member* F1 (not-member/< N2<N0) A F3
    <- eq-symmetric M=M113 M113=M
    <- not-member-respects-eq (not-member/> F3 N3+1+N1=N) M113=M nat`eq/ F3X.

- : union-preserves-not-member* (not-member/> F1 N3+1+N1=N) (not-member/> F2P N4+1+N2=N) 
                          (union/= A _ N1=N2) (not-member/> F3 N3+1+N1=N)
    <- plus-right-cancels N3+1+N1=N N4+1+N2=N N1=N2 nat`eq/ N3+1=N4+1
    <- succ-cancels N3+1=N4+1 N3=N4
    <- nat`eq-symmetric N3=N4 N4=N3
    <- not-member-respects-eq F2P eq/ N4=N3 F2
    <- union-preserves-not-member* F1 F2 A F3.

- : union-preserves-not-member* (not-member/> F1 N3+1+N1=N) (not-member/> F2 N4+1+N2=N) 
                          (union/< A N0+1+N1=N2) (not-member/> F3 N3+1+N1=N)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N4+1+N2=N N6 N4+1+N0=N6 N6+N1+1=N
    <- plus-swap-succ N3+1+N1=N N3+N1+1=N
    <- plus-right-cancels N6+N1+1=N N3+N1+1=N nat`eq/ nat`eq/ N6=N3
    <- plus-respects-eq N4+1+N0=N6 nat`eq/ nat`eq/ N6=N3 N4+1+N0=N3
    <- union-preserves-not-member* F1 (not-member/> F2 N4+1+N0=N3) A F3.

- : union-preserves-not-member* (not-member/> F1 N3+1+N1=N) (not-member/> F2 N4+1+N2=N) 
                          (union/> A N0+1+N2=N1) (not-member/> F3 N4+1+N2=N)
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-associative-converse N0+N2+1=N1 N3+1+N1=N N6 N3+1+N0=N6 N6+N2+1=N
    <- plus-swap-succ N4+1+N2=N N4+N2+1=N
    <- plus-right-cancels N6+N2+1=N N4+N2+1=N nat`eq/ nat`eq/ N6=N4
    <- plus-respects-eq N3+1+N0=N6 nat`eq/ nat`eq/ N6=N4 N3+1+N0=N4
    <- union-preserves-not-member* (not-member/> F1 N3+1+N0=N4) F2 A F3.

%worlds () (union-preserves-not-member* _ _ _ _).
%total (A) (union-preserves-not-member* _ _ A _).


%theorem not-member-union-left-preserves-lookup* :
	forall* {M1} {M2} {M3} {N} {D}
	forall {F1:not-member M1 N} {L2:lookup M2 N D} 
               {A:union M1 M2 M3}
	exists {L3:lookup M3 N D}
	true.

- : not-member-union-left-preserves-lookup* _ L union/L L.

- : not-member-union-left-preserves-lookup* (not-member/< N2<N1) (lookup/= nat`eq/) AX L3X
    <- gt-implies-plus N2<N1 N3 N3+1+N2=N1
    <- union/>-inversion AX N3+1+N2=N1 M3 A M=M223
    <- eq-symmetric M=M223 M223=M
    <- lookup-respects-eq (lookup/= nat`eq/) M223=M nat`eq/ unit`eq/ L3X.

- : not-member-union-left-preserves-lookup* (not-member/< N<N1) (lookup/> L2 N4+1+N2=N)
                                      AX L3X
    <- gt-implies-plus N<N1 N0 N0+1+N=N1
    <- plus-swap-succ N4+1+N2=N N4+N2+1=N
    <- plus-associative-converse N4+N2+1=N N0+1+N=N1 N3 N0+1+N4=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- union/>-inversion AX N3+1+N2=N1 M3 A M=M223
    <- eq-symmetric M=M223 M223=M
    <- plus-implies-gt N0+1+N4=N3 nat`eq/ N3>N4
    <- not-member-union-left-preserves-lookup* (not-member/< N3>N4) L2 A L3
    <- lookup-respects-eq (lookup/> L3 N4+1+N2=N) M223=M nat`eq/ unit`eq/ L3X.
 
- : not-member-union-left-preserves-lookup* (not-member/> F1 N0+1+N1=N2) 
                                      (lookup/= nat`eq/) AX L3X
    <- union/<-inversion AX N0+1+N1=N2 M3 A M=M113
    <- eq-symmetric M=M113 M113=M
    <- not-member-union-left-preserves-lookup* F1 (lookup/= nat`eq/) A L3
    <- lookup-respects-eq (lookup/> L3 N0+1+N1=N2) M113=M nat`eq/ unit`eq/ L3X.

- : not-member-union-left-preserves-lookup* (not-member/> F1P N4+1+N1=N)
                                      (lookup/> L2 N5+1+N1=N)
                                      (union/= A _ nat`eq/) 
                                      (lookup/> L3 N5+1+N1=N)
    <- plus-right-cancels N4+1+N1=N N5+1+N1=N nat`eq/ nat`eq/ N4+1=N5+1
    <- succ-cancels N4+1=N5+1 N4=N5
    <- not-member-respects-eq F1P eq/ N4=N5 F1
    <- not-member-union-left-preserves-lookup* F1 L2 A L3.

- : not-member-union-left-preserves-lookup* (not-member/> F1 N4+1+N1=N)
                                      (lookup/> L2 N5+1+N2=N)
                                      (union/< A N0+1+N1=N2)
                                      (lookup/> L3 N4+1+N1=N)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N5+1+N2=N N3 N5+1+N0=N3 N3+N1+1=N
    <- plus-swap-succ N4+1+N1=N N4+N1+1=N
    <- plus-right-cancels N3+N1+1=N N4+N1+1=N nat`eq/ nat`eq/ N3=N4
    <- plus-respects-eq N5+1+N0=N3 nat`eq/ nat`eq/ N3=N4 N5+1+N0=N4
    <- not-member-union-left-preserves-lookup* F1 (lookup/> L2 N5+1+N0=N4) A L3.

- : not-member-union-left-preserves-lookup* (not-member/> F1 N4+1+N1=N)
                                      (lookup/> L2 N5+1+N2=N)
                                      (union/> A N3+1+N2=N1)
                                      (lookup/> L3 N5+1+N2=N)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N4+1+N1=N N6 N4+1+N3=N6 N6+N2+1=N
    <- plus-swap-succ N5+1+N2=N N5+N2+1=N
    <- plus-right-cancels N6+N2+1=N N5+N2+1=N nat`eq/ nat`eq/ N6=N5
    <- plus-respects-eq N4+1+N3=N6 nat`eq/ nat`eq/ N6=N5 N4+1+N3=N5
    <- not-member-union-left-preserves-lookup* (not-member/> F1 N4+1+N3=N5) L2 A L3.

%worlds () (not-member-union-left-preserves-lookup* _ _ _ _).
%total (A) (not-member-union-left-preserves-lookup* _ _ A _).


%theorem not-member-union-left-preserves-lookup-converse :
	forall* {M1} {M2} {M3} {N} {D}
	forall {F1:not-member M1 N} {L3:lookup M3 N D} 
               {A:union M1 M2 M3}
	exists {L2:lookup M2 N D}
	true.

%theorem not-member-union-left-preserves-lookup-converse/L :
	forall* {M1} {M2} {M3} {N} {D} {B}
	forall {F1:not-member M1 N} {L3:lookup M3 N D} 
               {A:union M1 M2 M3}
               {D?:member? M2 N B}
	exists {L2:lookup M2 N D}
	true.

- : not-member-union-left-preserves-lookup-converse F1 L3 A L2
    <- member?-total D?
    <- not-member-union-left-preserves-lookup-converse/L F1 L3 A D? L2.

- : not-member-union-left-preserves-lookup-converse/L 
     F1 L3 A (member?/in L2P) L2
    <- not-member-union-left-preserves-lookup* F1 L2P A L3P
    <- lookup-deterministic L3P L3 eq/ nat`eq/ DP=D
    <- lookup-respects-eq L2P eq/ nat`eq/ DP=D L2.

- : not-member-union-left-preserves-lookup-converse/L
     F1 L3 A (member?/out F2) L2
    <- union-preserves-not-member* F1 F2 A F3
    <- not-member-lookup-not-equal F3 L3 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L2.

%worlds () (not-member-union-left-preserves-lookup-converse/L _ _ _ _ _).
%total { } (not-member-union-left-preserves-lookup-converse/L _ _ _ _ _).

%worlds () (not-member-union-left-preserves-lookup-converse _ _ _ _).
%total { } (not-member-union-left-preserves-lookup-converse _ _ _ _).


%theorem union-left-affects-lookup :
	forall* {M1} {N} {D2} {M2} {M3}
	forall {L:lookup M2 N D2}
	       {A:union M1 M2 M3}
	exists {D3}
               {N:lookup M3 N D3}
	true.

%theorem union-left-affects-lookup/L :
	forall* {M1} {N} {D2} {M2} {M3} {B}
	forall {L:lookup M2 N D2}
	       {A:union M1 M2 M3}
	       {D:member? M1 N B}
	exists {D3}
               {N:lookup M3 N D3}
	true.

- : union-left-affects-lookup/L L2 A (member?/in L1) _ L3
    <- union-joins-lookup L1 L2 A _ _ L3.

- : union-left-affects-lookup/L L2 A (member?/out F1) _ L3
    <- not-member-union-left-preserves-lookup* F1 L2 A L3.

%worlds () (union-left-affects-lookup/L _ _ _ _ _).
%total { } (union-left-affects-lookup/L _ _ _ _ _).

- : union-left-affects-lookup L2 A _ L3
    <- member?-total D
    <- union-left-affects-lookup/L L2 A D _ L3.

%worlds () (union-left-affects-lookup _ _ _ _).
%total { } (union-left-affects-lookup _ _ _ _).


% TODO: "*" should be removed here.

%theorem not-member-union-right-preserves-lookup :
	forall* {M1} {M2} {M3} {N} {D}
	forall {L1:lookup M1 N D} {F2:not-member M2 N}
               {A:union M1 M2 M3}
	exists {L3:lookup M3 N D}
	true.

% deprecated
%abbrev not-member-union-right-preserves-lookup* = not-member-union-right-preserves-lookup.

- : not-member-union-right-preserves-lookup L _ union/R L.

- : not-member-union-right-preserves-lookup (lookup/= nat`eq/) (not-member/< N2<N1) AX L3X
    <- gt-implies-plus N2<N1 N3 N3+1+N2=N1
    <- union/<-inversion AX N3+1+N2=N1 M3 A M=M223
    <- eq-symmetric M=M223 M223=M
    <- lookup-respects-eq (lookup/= nat`eq/) M223=M nat`eq/ unit`eq/ L3X.

- : not-member-union-right-preserves-lookup (lookup/> L2 N4+1+N2=N) (not-member/< N<N1)
                                      AX L3X
    <- gt-implies-plus N<N1 N0 N0+1+N=N1
    <- plus-swap-succ N4+1+N2=N N4+N2+1=N
    <- plus-associative-converse N4+N2+1=N N0+1+N=N1 N3 N0+1+N4=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- union/<-inversion AX N3+1+N2=N1 M3 A M=M223
    <- eq-symmetric M=M223 M223=M
    <- plus-implies-gt N0+1+N4=N3 nat`eq/ N3>N4
    <- not-member-union-right-preserves-lookup L2 (not-member/< N3>N4) A L3
    <- lookup-respects-eq (lookup/> L3 N4+1+N2=N) M223=M nat`eq/ unit`eq/ L3X.
 
- : not-member-union-right-preserves-lookup
	(lookup/= nat`eq/) (not-member/> F1 N0+1+N1=N2) 
	AX L3X
    <- union/>-inversion AX N0+1+N1=N2 M3 A M=M113
    <- eq-symmetric M=M113 M113=M
    <- not-member-union-right-preserves-lookup (lookup/= nat`eq/) F1 A L3
    <- lookup-respects-eq (lookup/> L3 N0+1+N1=N2) M113=M nat`eq/ unit`eq/ L3X.

- : not-member-union-right-preserves-lookup (lookup/> L2 N5+1+N1=N)
				      (not-member/> F1P N4+1+N1=N)
                                      (union/= A _ nat`eq/) 
                                      (lookup/> L3 N5+1+N1=N)
    <- plus-right-cancels N4+1+N1=N N5+1+N1=N nat`eq/ nat`eq/ N4+1=N5+1
    <- succ-cancels N4+1=N5+1 N4=N5
    <- not-member-respects-eq F1P eq/ N4=N5 F1
    <- not-member-union-right-preserves-lookup L2 F1 A L3.

- : not-member-union-right-preserves-lookup (lookup/> L2 N5+1+N2=N)
                                      (not-member/> F1 N4+1+N1=N)
                                      (union/> A N0+1+N1=N2)
                                      (lookup/> L3 N4+1+N1=N)
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N5+1+N2=N N3 N5+1+N0=N3 N3+N1+1=N
    <- plus-swap-succ N4+1+N1=N N4+N1+1=N
    <- plus-right-cancels N3+N1+1=N N4+N1+1=N nat`eq/ nat`eq/ N3=N4
    <- plus-respects-eq N5+1+N0=N3 nat`eq/ nat`eq/ N3=N4 N5+1+N0=N4
    <- not-member-union-right-preserves-lookup (lookup/> L2 N5+1+N0=N4) F1 A L3.

- : not-member-union-right-preserves-lookup (lookup/> L2 N5+1+N2=N)
				      (not-member/> F1 N4+1+N1=N)
                                      (union/< A N3+1+N2=N1)
                                      (lookup/> L3 N5+1+N2=N)
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N4+1+N1=N N6 N4+1+N3=N6 N6+N2+1=N
    <- plus-swap-succ N5+1+N2=N N5+N2+1=N
    <- plus-right-cancels N6+N2+1=N N5+N2+1=N nat`eq/ nat`eq/ N6=N5
    <- plus-respects-eq N4+1+N3=N6 nat`eq/ nat`eq/ N6=N5 N4+1+N3=N5
    <- not-member-union-right-preserves-lookup L2 (not-member/> F1 N4+1+N3=N5) A L3.

%worlds () (not-member-union-right-preserves-lookup _ _ _ _).
%total (A) (not-member-union-right-preserves-lookup _ _ A _).


%theorem not-member-union-right-preserves-lookup-converse :
	forall* {M1} {M2} {M3} {N} {D}
	forall {L3:lookup M3 N D} {F2:not-member M2 N}
               {A:union M1 M2 M3}
	exists {L1:lookup M1 N D}
	true.

%theorem not-member-union-right-preserves-lookup-converse/L :
	forall* {M1} {M2} {M3} {N} {D} {B}
	forall {L3:lookup M3 N D} {F2:not-member M2 N}
               {A:union M1 M2 M3}
	       {D?:member? M1 N B}
	exists {L1:lookup M1 N D}
	true.

- : not-member-union-right-preserves-lookup-converse L3 F2 A L1
    <- member?-total D?
    <- not-member-union-right-preserves-lookup-converse/L L3 F2 A D? L1.

- : not-member-union-right-preserves-lookup-converse/L 
     L3 F2 A (member?/in L1P) L1
    <- not-member-union-right-preserves-lookup* L1P F2 A L3P
    <- lookup-deterministic L3P L3 eq/ nat`eq/ DP=D
    <- lookup-respects-eq L1P eq/ nat`eq/ DP=D L1.

- : not-member-union-right-preserves-lookup-converse/L
     L3 F2 A (member?/out F1) L1
    <- union-preserves-not-member* F1 F2 A F3
    <- not-member-lookup-not-equal F3 L3 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-lookup F L1.

%worlds () (not-member-union-right-preserves-lookup-converse/L _ _ _ _ _).
%total { } (not-member-union-right-preserves-lookup-converse/L _ _ _ _ _).

%worlds () (not-member-union-right-preserves-lookup-converse _ _ _ _).
%total { } (not-member-union-right-preserves-lookup-converse _ _ _ _).


%theorem union-right-affects-lookup :
	forall* {M1} {N} {D1} {M2} {M3}
	forall {L:lookup M1 N D1}
	       {A:union M1 M2 M3}
	exists {D3}
               {N:lookup M3 N D3}
	true.

%theorem union-right-affects-lookup/L :
	forall* {M1} {N} {D1} {M2} {M3} {B}
	forall {L:lookup M1 N D1}
	       {A:union M1 M2 M3}
	       {D:member? M2 N B}
	exists {D3}
               {N:lookup M3 N D3}
	true.

- : union-right-affects-lookup/L L1 A (member?/in L2) _ L3
    <- union-joins-lookup L1 L2 A _ _ L3.

- : union-right-affects-lookup/L L1 A (member?/out F2) _ L3
    <- not-member-union-right-preserves-lookup* L1 F2 A L3.

%worlds () (union-right-affects-lookup/L _ _ _ _ _).
%total { } (union-right-affects-lookup/L _ _ _ _ _).

- : union-right-affects-lookup L1 A _ L3
    <- member?-total D
    <- union-right-affects-lookup/L L1 A D _ L3.

%worlds () (union-right-affects-lookup _ _ _ _).
%total { } (union-right-affects-lookup _ _ _ _).


% TODO deprecate *
%theorem union-preserves-not-member-converse* :
	forall* {M1} {M2} {M3} {N}
	forall {F3:not-member M3 N}
               {A:union M1 M2 M3}
	exists {F1:not-member M1 N} {F2:not-member M2 N}
	true.

%theorem union-preserves-not-member-converse/L :
	forall* {M1} {M2} {M3} {N} {B1} {B2}
	forall {F3:not-member M3 N}
               {A:union M1 M2 M3}
               {D1:member? M1 N B1}
               {D2:member? M2 N B2}
	exists {F1:not-member M1 N} {F2:not-member M2 N}
	true.

- : union-preserves-not-member-converse* F3 A F1 F2
    <- member?-total D1
    <- member?-total D2
    <- union-preserves-not-member-converse/L F3 A D1 D2 F1 F2.

- : union-preserves-not-member-converse/L _ _
     (member?/out F1) (member?/out F2) F1 F2.

- : union-preserves-not-member-converse/L F3 A
     (member?/out F1) (member?/in L2) F1 F2
    <- not-member-union-left-preserves-lookup* F1 L2 A L3
    <- not-member-lookup-not-equal F3 L3 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-not-member F F2.

- : union-preserves-not-member-converse/L F3 A
     (member?/in L1) (member?/out F2) F1 F2
    <- not-member-union-right-preserves-lookup* L1 F2 A L3
    <- not-member-lookup-not-equal F3 L3 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-not-member F F1.

- : union-preserves-not-member-converse/L F3 A
     (member?/in L1) (member?/in L2) F1 F2
    <- union-joins-lookup L1 L2 A _ _ L3
    <- not-member-lookup-not-equal F3 L3 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-not-member F F1
    <- false-implies-not-member F F2.

%worlds () (union-preserves-not-member-converse/L _ _ _ _ _ _).
%total { } (union-preserves-not-member-converse/L _ _ _ _ _ _).

%worlds () (union-preserves-not-member-converse* _ _ _ _).
%total { } (union-preserves-not-member-converse* _ _ _ _).


%theorem disjoint-union-cross-comparable :
	forall* {C} {C1} {C2} {C3} {C4}
	forall	{D12:disjoint C1 C2}
		{A12:union C1 C2 C} 
		{D34:disjoint C3 C4}
		{A34:union C3 C4 C}
	exists {C13} {C14} {C23} {C24}
	       {A1:union C13 C14 C1} {A2:union C23 C24 C2}
	       {A3:union C13 C23 C3} {A4:union C14 C24 C4}
	true.

%{%
NB: The client can easily prove all pieces are mutually disjoint.
For example C13 ^ C14 because C13 <= C3 and C14 <= C4 and C3^C4
            C13 ^ C23 because C13 <= C1 and C23 <= C2 and C1^C2
%}%

- : disjoint-union-cross-comparable _ union/L _ C3+C4=C2 _ _ _ _ union/L C3+C4=C2 union/L union/L.

- : disjoint-union-cross-comparable _ union/R _ C3+C4=C1 _ _ _ _ C3+C4=C1 union/R union/R union/R.

- : disjoint-union-cross-comparable _ C1+C2=C4 _ union/L _ _ _ _ union/L union/L union/L C1+C2=C4.

- : disjoint-union-cross-comparable _ C1+C2=C3 _ union/R _ _ _ _ union/R union/R C1+C2=C3 union/R.

- : disjoint-union-cross-comparable D (union/= _ _ nat`eq/) _ _ _ _ _ _
	union/L union/L J1 J2
    <- disjoint/=-contradiction D nat`eq/ F
    <- false-implies-union F J1
    <- false-implies-union F J2.

- : disjoint-union-cross-comparable _ _ D (union/= _ _ nat`eq/) _ _ _ _
	union/L union/L J1 J2
    <- disjoint/=-contradiction D nat`eq/ F
    <- false-implies-union F J1
    <- false-implies-union F J2.

- : disjoint-union-cross-comparable 
	D12 (union/< C1+CX2=C N0+1+N1=N2)
	D34 (union/< C3+CX4=C N5+1+N3=N4) _ _ _ _ % NB N1=N3=N
	CY1Y3+CY14=CY1 C2Y3+C24=C2
	CY1Y3+C2Y3=CY3 CY14+C24=C4
    <- disjoint/<-inversion D12 N0+1+N1=N2 D12P
    <- disjoint/<-inversion D34 N5+1+N3=N4 D34P
    <- disjoint-union-cross-comparable D12P C1+CX2=C D34P C3+CX4=C 
	C13 C1X4 CX23 CX2X4
	C13+C1X4=C1 CX23+CX2X4=CX2 C13+CX23=C3 C1X4+CX2X4=CX4
    <- shift-total C1X4<<N=CY14
    <- shift-total CX23<<N=C2Y3
    <- shift-total CX2X4<<N=C24
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-right-preserves-union C13+C1X4=C1 C1X4<<N=CY14 CY1Y3+CY14=CY1
    <- shift-preserves-union* CX23+CX2X4=CX2 
	CX23<<N=C2Y3 CX2X4<<N=C24 (shift/+ N1+1+N0=N2) C2Y3+C24=C2
    <- shift-right-preserves-union C13+CX23=C3 CX23<<N=C2Y3 CY1Y3+C2Y3=CY3
    <- plus-swap-succ N5+1+N3=N4 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- shift-preserves-union* C1X4+CX2X4=CX4
	C1X4<<N=CY14 CX2X4<<N=C24 (shift/+ N3+1+N5=N4) CY14+C24=C4.

- : disjoint-union-cross-comparable 
	D12 (union/< C1+CX2=C N0+1+N1=N2)
	D34 (union/> CX3+C4=C N5+1+N4=N3) _ _ _ _ % NB N1=N4=N
	CY13+CY1Y4=CY1 C23+C2Y4=C2 CY13+C23=C3 CY1Y4+C2Y4=CY4
    <- disjoint/<-inversion D12 N0+1+N1=N2 D12P
    <- disjoint/>-inversion D34 N5+1+N4=N3 D34P
    <- disjoint-union-cross-comparable D12P C1+CX2=C D34P CX3+C4=C 
	C1X3 C14 CX2X3 CX24
	C1X3+C14=C1 CX2X3+CX24=CX2 C1X3+CX2X3=CX3 C14+CX24=C4
    <- shift-total C1X3<<N=CY13
    <- shift-total CX2X3<<N=C23
    <- shift-total CX24<<N=C2Y4
    <- shift-left-preserves-union C1X3+C14=C1 C1X3<<N=CY13 CY13+CY1Y4=CY1
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-preserves-union* CX2X3+CX24=CX2 
	CX2X3<<N=C23 CX24<<N=C2Y4 (shift/+ N1+1+N0=N2) C23+C2Y4=C2
    <- plus-swap-succ N5+1+N4=N3 N5+N4+1=N3
    <- plus-commutative N5+N4+1=N3 N4+1+N5=N3
    <- shift-preserves-union* C1X3+CX2X3=CX3
	C1X3<<N=CY13 CX2X3<<N=C23 (shift/+ N4+1+N5=N3) CY13+C23=C3
    <- shift-right-preserves-union C14+CX24=C4 CX24<<N=C2Y4 CY1Y4+C2Y4=CY4.

- : disjoint-union-cross-comparable 
	D12 (union/> CX1+C2=C N0+1+N2=N1)
        D34 (union/< C3+CX4=C N5+1+N3=N4) _ _ _ _ % NB N2=N3=N
 	C1Y3+C14=C1 CY2Y3+CY24=CY2 C1Y3+CY2Y3=CY3 C14+CY24=C4
    <- disjoint/>-inversion D12 N0+1+N2=N1 D12P
    <- disjoint/<-inversion D34 N5+1+N3=N4 D34P
    <- disjoint-union-cross-comparable D12P CX1+C2=C D34P C3+CX4=C 
	CX13 CX1X4 C23 C2X4
	CX13+CX1X4=CX1 C23+C2X4=C2 CX13+C23=C3 CX1X4+C2X4=CX4
    <- shift-total CX13<<N=C1Y3
    <- shift-total CX1X4<<N=C14
    <- shift-total C2X4<<N=CY24
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-commutative N0+N2+1=N1 N2+1+N0=N1
    <- shift-preserves-union* CX13+CX1X4=CX1 
	CX13<<N=C1Y3 CX1X4<<N=C14 (shift/+ N2+1+N0=N1) C1Y3+C14=C1
    <- shift-right-preserves-union C23+C2X4=C2 C2X4<<N=CY24 CY2Y3+CY24=CY2
    <- shift-left-preserves-union CX13+C23=C3 CX13<<N=C1Y3 C1Y3+CY2Y3=CY3
    <- plus-swap-succ N5+1+N3=N4 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4
    <- shift-preserves-union* CX1X4+C2X4=CX4
	CX1X4<<N=C14 C2X4<<N=CY24 (shift/+ N3+1+N5=N4) C14+CY24=C4.

- : disjoint-union-cross-comparable 
	D12 (union/> CX1+C2=C N0+1+N2=N1)
	D34 (union/> CX3+C4=C N5+1+N4=N3) _ _ _ _ % NB N2=N4=N
	C13+C1Y4=C1 CY23+CY2Y4=CY2 C13+CY23=C3 C1Y4+CY2Y4=CY4
    <- disjoint/>-inversion D12 N0+1+N2=N1 D12P
    <- disjoint/>-inversion D34 N5+1+N4=N3 D34P
    <- disjoint-union-cross-comparable D12P CX1+C2=C D34P CX3+C4=C 
	CX1X3 CX14 C2X3 C2C4
	CX1X3+CX14=CX1 C2X3+C24=C2 CX1X3+C2X3=CX3 CX14+C24=C4
    <- shift-total CX1X3<<N=C13
    <- shift-total CX14<<N=C1Y4
    <- shift-total C2X3<<N=CY23
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-commutative N0+N2+1=N1 N2+1+N0=N1
    <- shift-preserves-union* CX1X3+CX14=CX1 
	CX1X3<<N=C13 CX14<<N=C1Y4 (shift/+ N2+1+N0=N1) C13+C1Y4=C1
    <- shift-left-preserves-union C2X3+C24=C2 C2X3<<N=CY23 CY23+CY2Y4=CY2
    <- plus-swap-succ N5+1+N4=N3 N5+N4+1=N3
    <- plus-commutative N5+N4+1=N3 N4+1+N5=N3
    <- shift-preserves-union* CX1X3+C2X3=CX3
	CX1X3<<N=C13 C2X3<<N=CY23 (shift/+ N4+1+N5=N3) C13+CY23=C3
    <- shift-left-preserves-union CX14+C24=C4 CX14<<N=C1Y4 C1Y4+CY2Y4=CY4.

%worlds () (disjoint-union-cross-comparable _ _ _ _ _ _ _ _ _ _ _ _).
%total (A) (disjoint-union-cross-comparable _ A _ _ _ _ _ _ _ _ _ _).


%theorem disjoint-union-left-preserves-lookup* :
	forall* {M1} {M2} {M3} {N} {D}
	forall {L2:lookup M2 N D}
               {X:disjoint M1 M2}
               {A:union M1 M2 M3}
	exists {L3:lookup M3 N D}
	true.

%theorem disjoint-union-left-preserves-lookup*/L :
	forall* {M1} {M2} {M3} {N} {D} {B}
	forall {L2:lookup M2 N D}
               {X:disjoint M1 M2}
               {A:union M1 M2 M3}
               {D?:member? M1 N B}
	exists {L3:lookup M3 N D}
	true.

- : disjoint-union-left-preserves-lookup* L2 X A L3
    <- member?-total D?
    <- disjoint-union-left-preserves-lookup*/L L2 X A D? L3.

- : disjoint-union-left-preserves-lookup*/L L2 X A (member?/in L1) L3
    <- disjoint-lookup-contradiction X L1 L2 F
    <- false-implies-lookup F L3.

- : disjoint-union-left-preserves-lookup*/L L2 X A (member?/out F1) L3
    <- not-member-union-left-preserves-lookup* F1 L2 A L3.

%worlds () (disjoint-union-left-preserves-lookup*/L _ _ _ _ _).
%total { } (disjoint-union-left-preserves-lookup*/L _ _ _ _ _).

%worlds () (disjoint-union-left-preserves-lookup* _ _ _ _).
%total { } (disjoint-union-left-preserves-lookup* _ _ _ _).


%theorem disjoint-union-right-preserves-lookup* :
	forall* {M1} {M2} {M3} {N} {D}
	forall {L1:lookup M1 N D}
               {X:disjoint M1 M2}
               {A:union M1 M2 M3}
	exists {L3:lookup M3 N D}
	true.

%theorem disjoint-union-right-preserves-lookup*/L :
	forall* {M1} {M2} {M3} {N} {D} {B}
	forall {L1:lookup M1 N D}
               {X:disjoint M1 M2}
               {A:union M1 M2 M3}
               {D?:member? M2 N B}
	exists {L3:lookup M3 N D}
	true.

- : disjoint-union-right-preserves-lookup* L1 X A L3
    <- member?-total D?
    <- disjoint-union-right-preserves-lookup*/L L1 X A D? L3.

- : disjoint-union-right-preserves-lookup*/L L1 X A (member?/in L2) L3
    <- disjoint-lookup-contradiction X L1 L2 F
    <- false-implies-lookup F L3.

- : disjoint-union-right-preserves-lookup*/L L1 X A (member?/out F2) L3
    <- not-member-union-right-preserves-lookup* L1 F2 A L3.

%worlds () (disjoint-union-right-preserves-lookup*/L _ _ _ _ _).
%total { } (disjoint-union-right-preserves-lookup*/L _ _ _ _ _).

%worlds () (disjoint-union-right-preserves-lookup* _ _ _ _).
%total { } (disjoint-union-right-preserves-lookup* _ _ _ _).


%theorem not-member-update-implies-unit-union:
	forall*	{M} {N} {D} {MP}
	forall	{F: not-member M N}
		{U: update M N D MP}
	exists	{J: union M (map/+ N D map/0) MP}
	true.

- : not-member-update-implies-unit-union
	not-member/0 update/0 union/L.

- : not-member-update-implies-unit-union
	(not-member/< N1>N2) U J
    <- nat`gt-implies-plus N1>N2 N3 SN3+N2=N1
    <- update/<-inversion U SN3+N2=N1 EQ
    <- union-respects-eq  (union/> union/R SN3+N2=N1) eq/ eq/ EQ J.

- : not-member-update-implies-unit-union
	(not-member/> F SN0+N1=N2) U J
    <- update/>-inversion U SN0+N1=N2 M1 U1 EQ
    <- not-member-update-implies-unit-union F U1 JP
    <- union-respects-eq (union/< JP SN0+N1=N2) eq/ eq/ EQ J.

%worlds () (not-member-update-implies-unit-union _ _ _).
%total (F) (not-member-update-implies-unit-union F _ _).


%theorem lookup-update-left-implies-unit-union:
	forall*	{M1} {N} {D1} {D2} {D3} {M3}
	forall	{L: lookup M1 N D1}
		{D: unit`union D1 D2 D3}
		{U: update M1 N D3 M3}
	exists	{J: union M1 (map/+ N D2 map/0) M3}
	true.

- : lookup-update-left-implies-unit-union
	(lookup/= nat`eq/) DJ U JP
    <- update/=-inversion U nat`eq/ EQ3
    <- union-respects-eq (union/= union/R DJ nat`eq/) eq/ eq/ EQ3 JP.

- : lookup-update-left-implies-unit-union
	(lookup/> L0 P) DJ U JP
    <- update/>-inversion U P _ U0 EQ3
    <- lookup-update-left-implies-unit-union L0 DJ U0 J0P
    <- union-respects-eq (union/< J0P P) eq/ eq/ EQ3 JP.

%worlds () (lookup-update-left-implies-unit-union _ _ _ _).
%total (L) (lookup-update-left-implies-unit-union L _ _ _).


%theorem lookup-update-right-implies-unit-union:
	forall*	{M2} {N} {D1} {D2} {D3} {M3}
	forall	{L: lookup M2 N D2}
		{D: unit`union D1 D2 D3}
		{U: update M2 N D3 M3}
	exists	{J: union (map/+ N D1 map/0) M2 M3}
	true.

- : lookup-update-right-implies-unit-union
	(lookup/= nat`eq/) DJ U JP
    <- update/=-inversion U nat`eq/ EQ3
    <- union-respects-eq (union/= union/L DJ nat`eq/) eq/ eq/ EQ3 JP.

- : lookup-update-right-implies-unit-union
	(lookup/> L0 P) DJ U JP
    <- update/>-inversion U P _ U0 EQ3
    <- lookup-update-right-implies-unit-union L0 DJ U0 J0P
    <- union-respects-eq (union/> J0P P) eq/ eq/ EQ3 JP.

%worlds () (lookup-update-right-implies-unit-union _ _ _ _).
%total (L) (lookup-update-right-implies-unit-union L _ _ _).


%theorem not-member-unit-union-implies-update:
	forall*	{M} {N} {D} {MP}
	forall	{F: not-member M N}
		{J: union M (map/+ N D map/0) MP}
	exists	{U: update M N D MP}
	true.

- : not-member-unit-union-implies-update _ union/L update/0.

- : not-member-unit-union-implies-update
	FR (union/= _ _ nat`eq/) U
    <- not-member-contradiction FR F
    <- false-implies-update F U.

- : not-member-unit-union-implies-update
	F (union/< J1 P) (update/> U1 P)
    <- not-member/>-inversion F P F1
    <- not-member-unit-union-implies-update F1 J1 U1.

- : not-member-unit-union-implies-update
	F (union/> J1 P) U
    <- union-deterministic union/R J1 eq/ eq/ ME
    <- map/+-preserves-eq nat`eq/ unit`eq/ ME ME2
    <- update-respects-eq (update/< P) eq/ nat`eq/ unit`eq/ ME2 U.

%worlds () (not-member-unit-union-implies-update _ _ _).
%total (J) (not-member-unit-union-implies-update _ J _).


%theorem union-commute-update-left*:
	forall*	{M1} {M2} {M3} {N} {D} {M1P} {M3P}
	forall	{J: union M1 M2 M3}
		{U1: update M1 N D M1P}
		{F2: not-member M2 N}
		{U3: update M3 N D M3P}
	exists	{J: union M1P M2 M3P}
	true.

- : union-commute-update-left*
	union/L update/0 F2 U3 JP
    <- not-member-update-implies-unit-union F2 U3 JPc
    <- not-member-implies-unit-disjoint F2 DJ
    <- disjoint-union-commutative DJ JPc JP.

- : union-commute-update-left*
	union/R U1 not-member/0 U1P J
    <- update-unique U1P U1 eq/ nat`eq/ unit`eq/ EQ
    <- union-respects-eq union/R EQ eq/ eq/ J.

- : union-commute-update-left*
	(union/= J0 DJ nat`eq/) U1 F2
	(update/< P) J
    <- update/<-inversion U1 P EQ1
    <- union-respects-eq (union/< (union/= J0 DJ nat`eq/) P) EQ1 eq/ eq/ J.

- : union-commute-update-left*
	(union/= J0 DJ nat`eq/) U1 F2
	(update/= nat`eq/) J
    <- not-member-contradiction F2 F
    <- false-implies-union F J.

- : union-commute-update-left*
	(union/= J0 DJ nat`eq/) U1 F2
	(update/> U30 P) J
    <- update/>-inversion U1 P _ U10 EQ1
    <- not-member/>-inversion F2 P F20
    <- union-commute-update-left* J0 U10 F20 U30 J0P
    <- union-respects-eq (union/= J0P DJ nat`eq/) EQ1 eq/ eq/ J.

- : union-commute-update-left*
	(union/< J0 P0) U1 F2
	(update/< P1) J
    <- update/<-inversion U1 P1 EQ1
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-commutative P0 P0c
    <- plus-associative P1sc P0c D2 P3c P2sc
    <- plus-swap-succ P2sc P2c
    <- plus-commutative P2c P2
    <- plus-commutative P3c P3
    <- union-respects-eq (union/< (union/< J0 P3) P2) EQ1 eq/ eq/ J.

- : union-commute-update-left*
	(union/< J0 P0) U1 F2
	(update/= nat`eq/) J
    <- update/=-inversion U1 nat`eq/ EQ1
    <- union-respects-eq (union/< J0 P0) EQ1 eq/ eq/ J.
    
- : union-commute-update-left*
	(union/< J0 P0) U1 F2
	(update/> U30 P1) J
    <- update/>-inversion U1 P1 _ U10 EQ1
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- shift-preserves-not-member-converse* F2 (shift/+ P0sc) P1sc F20
    <- union-commute-update-left* J0 U10 F20 U30 J0P
    <- union-respects-eq (union/< J0P P0) EQ1 eq/ eq/ J.

- : union-commute-update-left*
	(union/> _ _) _ F2
	(update/= nat`eq/) J
    <- not-member-contradiction F2 F
    <- false-implies-union F J.

- : union-commute-update-left*
	(union/> J0 P0) U1 F2
	(update/< P2) JP
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- plus-commutative P0 P0c
    <- plus-associative P2sc P0c D1 P3c P1sc
    <- plus-swap-succ P1sc P1c
    <- plus-commutative P1c P1
    <- plus-commutative P3c P3
    <- update/<-inversion U1 P1 EQ1
    <- union-respects-eq (union/< (union/> J0 P3) P2) EQ1 eq/ eq/ JP.

- : union-commute-update-left*
	(union/> J0 P0) U1 F2
	(update/> U30 P2) J
    <- not-member/>-inversion F2 P2 F20
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-update-converse U1 (shift/+ P0sc) P2sc _ SH1 U10
    <- union-commute-update-left* J0 U10 F20 U30 J0P
    <- shift-left-preserves-union J0P SH1 J.

%worlds () (union-commute-update-left* _ _ _ _ _).
%total (J) (union-commute-update-left* J _ _ _ _).


%theorem union-commute-update-left:
	forall*	{M1} {M2} {M3} {N} {D} {M1P}
	forall	{J: union M1 M2 M3}
		{U1: update M1 N D M1P}
		{F2: not-member M2 N}
	exists	{M3P}
		{U3: update M3 N D M3P}
		{J: union M1P M2 M3P}
	true.

- : union-commute-update-left J U1 F2 _ U3 JP
    <- update-total U3
    <- union-commute-update-left* J U1 F2 U3 JP.

%worlds () (union-commute-update-left _ _ _ _ _ _).
%total { } (union-commute-update-left _ _ _ _ _ _).


%theorem union-commute-update-right*:
	forall*	{M1} {M2} {M3} {N} {D} {M2P} {M3P}
	forall	{J: union M1 M2 M3}
		{F1: not-member M1 N}
		{U2: update M2 N D M2P}
		{U3: update M3 N D M3P}
	exists	{J: union M1 M2P M3P}
	true.

- : union-commute-update-right*
	union/L not-member/0 U2 U2P J
    <- update-unique U2P U2 eq/ nat`eq/ unit`eq/ EQ
    <- union-respects-eq union/L eq/ EQ eq/ J.

- : union-commute-update-right*
	union/R F1 update/0 U1 J
    <- not-member-update-implies-unit-union F1 U1 J.

- : union-commute-update-right*
	(union/= J0 DJ nat`eq/) F1 U2
	(update/< P) J
    <- update/<-inversion U2 P EQ2
    <- union-respects-eq (union/> (union/= J0 DJ nat`eq/) P) eq/ EQ2 eq/ J.

- : union-commute-update-right*
	(union/= J0 DJ nat`eq/) F1 U2
	(update/= nat`eq/) J
    <- not-member-contradiction F1 F
    <- false-implies-union F J.

- : union-commute-update-right*
	(union/= J0 DJ nat`eq/) F1 U2
	(update/> U30 P) J
    <- update/>-inversion U2 P _ U20 EQ2
    <- not-member/>-inversion F1 P F10
    <- union-commute-update-right* J0 F10 U20 U30 J0P
    <- union-respects-eq (union/= J0P DJ nat`eq/) eq/ EQ2 eq/ J.

- : union-commute-update-right*
	(union/> J0 P0) F1 U2
	(update/< P2) J
    <- update/<-inversion U2 P2 EQ2
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- plus-commutative P0 P0c
    <- plus-associative P2sc P0c D1 P3c P1sc
    <- plus-swap-succ P1sc P1c
    <- plus-commutative P1c P1
    <- plus-commutative P3c P3
    <- union-respects-eq (union/> (union/> J0 P3) P1) eq/ EQ2 eq/ J.

- : union-commute-update-right*
	(union/> J0 P0) F1 U2
	(update/= nat`eq/) J
    <- update/=-inversion U2 nat`eq/ EQ2
    <- union-respects-eq (union/> J0 P0) eq/ EQ2 eq/ J.
    
- : union-commute-update-right*
	(union/> J0 P0) F1 U2
	(update/> U30 P2) J
    <- update/>-inversion U2 P2 _ U20 EQ2
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-not-member-converse* F1 (shift/+ P0sc) P2sc F10
    <- union-commute-update-right* J0 F10 U20 U30 J0P
    <- union-respects-eq (union/> J0P P0) eq/ EQ2 eq/ J.

- : union-commute-update-right*
	(union/< _ _) F1 _
	(update/= nat`eq/) J
    <- not-member-contradiction F1 F
    <- false-implies-union F J.

- : union-commute-update-right*
	(union/< J0 P0) F1 U2
	(update/< P1) JP
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-commutative P0 P0c
    <- plus-associative P1sc P0c D2 P3c P2sc
    <- plus-swap-succ P2sc P2c
    <- plus-commutative P2c P2
    <- plus-commutative P3c P3
    <- update/<-inversion U2 P2 EQ2
    <- union-respects-eq (union/> (union/< J0 P3) P1) eq/ EQ2 eq/ JP.

- : union-commute-update-right*
	(union/< J0 P0) F1 U2
	(update/> U30 P1) J
    <- not-member/>-inversion F1 P1 F10
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- shift-preserves-update-converse U2 (shift/+ P0sc) P1sc _ SH2 U20
    <- union-commute-update-right* J0 F10 U20 U30 J0P
    <- shift-right-preserves-union J0P SH2 J.

%worlds () (union-commute-update-right* _ _ _ _ _).
%total (J) (union-commute-update-right* J _ _ _ _).


%theorem union-commute-update-right:
	forall*	{M1} {M2} {M3} {N} {D} {M2P}
	forall	{J: union M1 M2 M3}
		{F1: not-member M1 N}
		{U2: update M2 N D M2P}
	exists	{M3P}
		{U3: update M3 N D M3P}
		{J: union M1 M2P M3P}
	true.

- : union-commute-update-right J F1 U2 _ U3 JP
    <- update-total U3
    <- union-commute-update-right* J F1 U2 U3 JP.

%worlds () (union-commute-update-right _ _ _ _ _ _).
%total { } (union-commute-update-right _ _ _ _ _ _).


%theorem union-commute-update*:
	forall*	{M1} {M2} {M3} {N} {D1} {M1P} {D2} {D3} {M2P} {M3P}
	forall	{J: union M1 M2 M3}
		{DJ: unit`union D1 D2 D3}
		{U1: update M1 N D1 M1P}
		{U2: update M2 N D2 M2P}
		{U3: update M3 N D3 M3P}
	exists	{JP: union M1P M2P M3P}
	true.

- : union-commute-update* union/L DJ update/0 U2 U3 JP
    <- update-implies-lookup U2 L2
    <- update-overwrites-converse U3 U2 U23
    <- lookup-update-right-implies-unit-union L2 DJ U23 JP.

- : union-commute-update* union/R DJ U1 update/0 U3 JP
    <- update-implies-lookup U1 L1
    <- update-overwrites-converse U3 U1 U13
    <- lookup-update-left-implies-unit-union L1 DJ U13 JP.

- : union-commute-update* (union/= J0 DJ0 nat`eq/) DJ U1 U2 (update/< P) JP
    <- update/<-inversion U1 P EQ1
    <- update/<-inversion U2 P EQ2
    <- union-respects-eq 
	(union/= (union/= J0 DJ0 nat`eq/) DJ nat`eq/) EQ1 EQ2 eq/ JP.

- : union-commute-update* (union/= J0 _ nat`eq/) DJ U1 U2 (update/= nat`eq/) JP
    <- update/=-inversion U1 nat`eq/ EQ1
    <- update/=-inversion U2 nat`eq/ EQ2
    <- union-respects-eq (union/= J0 DJ nat`eq/) EQ1 EQ2 eq/ JP.

- : union-commute-update* (union/= J0 DJ0 nat`eq/) DJ U1 U2 (update/> U30 P) JP
    <- update/>-inversion U1 P _ U10 EQ1
    <- update/>-inversion U2 P _ U20 EQ2
    <- union-commute-update* J0 DJ U10 U20 U30 J0P
    <- union-respects-eq (union/= J0P DJ0 nat`eq/) EQ1 EQ2 eq/ JP.

- : union-commute-update* (union/< J0 P0) DJ U1 U2 (update/< P1) JP
    <- update/<-inversion U1 P1 EQ1
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- plus-commutative P0 P0c
    <- plus-associative P1sc P0c D2 P3c P2sc
    <- plus-swap-succ P2sc P2c
    <- plus-commutative P2c P2
    <- plus-commutative P3c P3
    <- update/<-inversion U2 P2 EQ2
    <- union-respects-eq (union/= (union/< J0 P3) DJ nat`eq/) EQ1 EQ2 eq/ JP.

- : union-commute-update* (union/< J0 P0) DJ U1 U2 (update/= nat`eq/) JP
    <- update/=-inversion U1 nat`eq/ EQ1
    <- update/<-inversion U2 P0 EQ2
    <- union-respects-eq (union/= J0 DJ nat`eq/) EQ1 EQ2 eq/ JP.

- : union-commute-update* (union/< J0 P0) DJ U1 U2 (update/> U30 P1) JP
    <- update/>-inversion U1 P1 _ U10 EQ1
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc
    <- plus-swap-succ P1 P1s
    <- plus-commutative P1s P1sc
    <- shift-preserves-update-converse U2 (shift/+ P0sc) P1sc _ SH2 U20
    <- union-commute-update* J0 DJ U10 U20 U30 J0P
    <- shift-right-preserves-union J0P SH2 JPP
    <- union-respects-eq JPP EQ1 eq/ eq/ JP.

- : union-commute-update* (union/> J0 P0) DJ U1 U2 (update/< P2) JP
    <- update/<-inversion U2 P2 EQ2
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- plus-commutative P0 P0c
    <- plus-associative P2sc P0c D1 P3c P1sc
    <- plus-swap-succ P1sc P1c
    <- plus-commutative P1c P1
    <- plus-commutative P3c P3
    <- update/<-inversion U1 P1 EQ1
    <- union-respects-eq (union/= (union/> J0 P3) DJ nat`eq/) EQ1 EQ2 eq/ JP.

- : union-commute-update* (union/> J0 P0) DJ U1 U2 (update/= nat`eq/) JP
    <- update/<-inversion U1 P0 EQ1
    <- update/=-inversion U2 nat`eq/ EQ2
    <- union-respects-eq (union/= J0 DJ nat`eq/) EQ1 EQ2 eq/ JP.

- : union-commute-update* (union/> J0 P0) DJ U1 U2 (update/> U30 P2) JP
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc
    <- plus-swap-succ P2 P2s
    <- plus-commutative P2s P2sc
    <- shift-preserves-update-converse U1 (shift/+ P0sc) P2sc _ SH1 U10
    <- update/>-inversion U2 P2 _ U20 EQ2
    <- union-commute-update* J0 DJ U10 U20 U30 J0P
    <- shift-left-preserves-union J0P SH1 JPP
    <- union-respects-eq JPP eq/ EQ2 eq/ JP.

%worlds () (union-commute-update* _ _ _ _ _ _).
%total (J) (union-commute-update* J _ _ _ _ _).


%theorem union-commute-update:
	forall*	{M1} {M2} {M3} {N} {D1} {M1P} {D2} {D3} {M2P}
	forall	{J: union M1 M2 M3}
		{DJ: unit`union D1 D2 D3}
		{U1: update M1 N D1 M1P}
		{U2: update M2 N D2 M2P}
	exists	{M3P}
		{U3: update M3 N D3 M3P}
		{JP: union M1P M2P M3P}
	true.

- : union-commute-update J DJ U1 U2 _ U3 JP
    <- update-total U3
    <- union-commute-update* J DJ U1 U2 U3 JP.

%worlds () (union-commute-update _ _ _ _ _ _ _).
%total { } (union-commute-update _ _ _ _ _ _ _).


%theorem union-preserves-not-member-update-left: 
	forall* {M1} {M1S} {M2S} {MS} {N} {D} 
	forall	{J: union M1S M2S MS}
		{F1: not-member M1S N}
    		{U1: update M1S N D M1}
    		{F2: not-member M2S N}
    	exists 	{M} 
		{F: not-member MS N}
    		{U: update MS N D M}
    		{J: union M1 M2S M}
    	true.

- : union-preserves-not-member-update-left J F1 U1 F2 _ F3 U3 JP
    <- union-commute-update-left J U1 F2 _ U3 JP
    <- union-preserves-not-member* F1 F2 J F3.

%worlds () (union-preserves-not-member-update-left _ _ _ _ _ _ _ _).
%total {} (union-preserves-not-member-update-left _ _ _ _ _ _ _ _).


%theorem not-member-update-left-preserves-union-converse :
	forall* {M1} {M1P} {M2} {M} {N} {D}
	forall	{F1: not-member M1P N}
    		{U1: update M1P N D M1}
    		{F2: not-member M2 N}
    		{J: union M1 M2 M}
 	exists  {MP} 
		{F: not-member MP N}
		{U: update MP N D M}
		{J: union M1P M2 MP}
	true.

%theorem not-member-update-left-preserves-union-converse/L :
	forall* {N1} {D1} {M1} {M1P} 
		{N2} {D2} {M2} 
		{N3} {D3} {M3} {N} {D} {B}
	forall	{F1: not-member M1P N}
    		{U1: update M1P N D (map/+ N1 D1 M1)}
    		{F2: not-member (map/+ N2 D2 M2) N}
    		{J: union (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N3 D3 M3)}
		{GE1: nat`ge? N N1 B}
 	exists  {MP} 
		{F: not-member MP N}
		{U: update MP N D (map/+ N3 D3 M3)}
		{J: union M1P (map/+ N2 D2 M2) MP}
	true.

- : not-member-update-left-preserves-union-converse/L F1P U1 _ _
	(nat`ge?/no GT) map/0 F3 U3 J3
    <- update-implies-lookup U1 L1
    <- not-member-lookup-not-equal (not-member/< GT) L1 NE
    <- nat`eq-ne-implies-false nat`eq/ NE F
    <- false-implies-not-member F F3
    <- false-implies-update F U3
    <- false-implies-union F J3.

- : not-member-update-left-preserves-union-converse/L F1P U1 F2
	(union/= J0 DA nat`eq/) (nat`ge?/yes (nat`ge/= nat`eq/)) map/0 F3 U3 J3
    <- not-member-lookup-not-equal F2 (lookup/= nat`eq/) NE
    <- nat`eq-ne-implies-false nat`eq/ NE F
    <- false-implies-not-member F F3
    <- false-implies-update F U3
    <- false-implies-union F J3.

- : not-member-update-left-preserves-union-converse/L F1P U1 F2
	(union/= J0 DA nat`eq/) (nat`ge?/yes (nat`ge/> GT)) _
	(not-member/> F30 P) (update/> U30 P) J
    <- nat`gt-implies-plus GT _ P
    <- not-member-lookup-not-equal F2 (lookup/= nat`eq/) NE
    <- update/>-inversion* U1 P _ U10 (EQ1: eq _ M1)
    <- eq-symmetric EQ1 EQ1s
    <- not-member-respects-eq F1P EQ1s nat`eq/ F1PP
    <- not-member/>-inversion F1PP P F1P0
    <- not-member/>-inversion F2 P F20
    <- not-member-update-left-preserves-union-converse F1P0 U10 F20 J0 _ F30 U30 J0P
    <- union-respects-eq (union/= J0P DA nat`eq/) EQ1 eq/ eq/ J.

- : not-member-update-left-preserves-union-converse/L F1P U1 _
	(union/< J0 P) (nat`ge?/yes (nat`ge/= nat`eq/)) _ F3 U3P J3
    <- not-member-update-implies-shift F1P U1 SH1 D1=D2
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- shift-preserves-union J0 SH1 (shift/+ Psc) _ SH3 J3
    <- shift-implies-not-member SH3 F3
    <- shift-implies-update SH3 U3
    <- update-respects-eq U3 eq/ nat`eq/ D1=D2 eq/ U3P.

- : not-member-update-left-preserves-union-converse/L F1P (U1:update M N D _) F2
	(union/< J0 (P0: plus (s D0) N1 N2))
	(nat`ge?/yes (nat`ge/> (N>N1:gt N N1)) ) _
	(not-member/> F30 P1) 
	(update/> U30 P1)
	J3
    <- gt-implies-plus N>N1 D1 P1
    <- update/>-inversion* U1 P1 _ U10 EQ1
    <- eq-symmetric EQ1 EQ1s
    <- not-member-respects-eq F1P EQ1s nat`eq/ F1PP
    <- not-member/>-inversion F1PP P1 F1P0
    <- plus-swap-succ P0 P0s
    <- plus-swap-succ P1 P1s
    <- plus-commutative P0s P0sc
    <- plus-commutative P1s P1sc
    <- shift-preserves-not-member-converse* F2 (shift/+ P0sc) P1sc F20
    <- not-member-update-left-preserves-union-converse F1P0 U10 (F20:not-member _ D1) J0 _
	 F30 U30 J0P
    <- union-respects-eq (union/< J0P P0) EQ1 eq/ eq/ J3.

- : not-member-update-left-preserves-union-converse/L F1P (U1:update M N _ _) F2
	(union/> J0 (P0: plus (s D0) N2 N1))
	(nat`ge?/yes N>=N1) _
	(not-member/> F30 P2) (update/> U30 P2) J3
    <- ge-implies-plus (N>=N1:nat`ge N N1) D1 P1
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc 
    <- plus-commutative P1 P1c
    <- plus-associative P0sc P1c D2 D0+D1=D2 P2sc
    <- plus-swap-succ P2sc P2c
    <- plus-commutative P2c P2
    <- update-commutes-shift-converse* U1 (shift/+ P0sc) P2sc _ SH U10
    <- shift-preserves-not-member-converse* F1P SH P2sc F1P0
    <- not-member/>-inversion F2 P2 F20
    <- not-member-update-left-preserves-union-converse F1P0 U10 (F20:not-member _ D2) J0 _
	 F30 U30 J0P
    <- shift-left-preserves-union J0P SH J3.

- : not-member-update-left-preserves-union-converse F1P U1 _
	union/R _ F1P U1 union/R.

- : not-member-update-left-preserves-union-converse F1P U1 F2 J _ F3 U3 J3
    <- nat`ge?-total GE?
    <- not-member-update-left-preserves-union-converse/L F1P U1 F2 J GE? _ F3 U3 J3.

%worlds () 
	(not-member-update-left-preserves-union-converse _ _ _ _ _ _ _ _)
	(not-member-update-left-preserves-union-converse/L _ _ _ _ _ _ _ _ _).
%total (J1 J2)
	(not-member-update-left-preserves-union-converse/L _ _ _ J1 _ _ _ _ _)
	(not-member-update-left-preserves-union-converse _ _ _ J2 _ _ _ _).


%theorem not-member-update-left-preserves-union-converse* :
	forall* {M1} {M1P} {M2} {M} {MP} {N} {D} 
	forall	{F1: not-member M1P N}
		{U1: update M1P N D M1}
		{F2: not-member M2 N}
		{J: union M1 M2 M}
		{F: not-member MP N}
		{U: update MP N D M}
	exists	{J: union M1P M2 MP}
	true.

- : not-member-update-left-preserves-union-converse*
    N!<M1P M1P+N+D=M1 N!<M2 M1+M2=M N!<MP MP+N+D=M M1P+M2=MP
    <- not-member-update-left-preserves-union-converse
      N!<M1P M1P+N+D=M1 N!<M2 M1+M2=M MQ N!<MQ MQ+N+D=M M1P+M2=MQ
    <- not-member-update-cancels N!<MQ MQ+N+D=M N!<MP MP+N+D=M nat`eq/ eq/ _ ME
    <- union-respects-eq M1P+M2=MQ eq/ eq/ ME M1P+M2=MP.

%worlds () (not-member-update-left-preserves-union-converse* _ _ _ _ _ _ _).
%total {} (not-member-update-left-preserves-union-converse* _ _ _ _ _ _ _).


%theorem not-member-update-right-preserves-union-converse :
	forall* {M1} {M2P} {M2} {M} {N} {D}
	forall	{F1: not-member M1 N}
    		{F2: not-member M2P N}
    		{U2: update M2P N D M2}
    		{J: union M1 M2 M}
 	exists  {MP} 
		{F: not-member MP N}
		{U: update MP N D M}
		{J: union M1 M2P MP}
	true.

%theorem not-member-update-right-preserves-union-converse/L :
	forall* {N1} {D1} {M1} {M2P} 
		{N2} {D2} {M2} {M} {N} {D} {B}
	forall	{F1: not-member (map/+ N1 D1 M1) N}
    		{F2: not-member M2P N}
    		{U2: update M2P N D (map/+ N2 D2 M2)}
    		{J: union (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
		{GE1: nat`ge? N N2 B}
 	exists  {MP} 
		{F: not-member MP N}
		{U: update MP N D M}
		{J: union (map/+ N1 D1 M1) M2P MP}
	true.

- : not-member-update-right-preserves-union-converse/L F1 F2P U2 _
	(nat`ge?/no GT) map/0 F3 U3 J3
    <- update-implies-lookup U2 L2
    <- not-member-lookup-not-equal (not-member/< GT) L2 NE
    <- nat`eq-ne-implies-false nat`eq/ NE F
    <- false-implies-not-member F F3
    <- false-implies-update F U3
    <- false-implies-union F J3.

- : not-member-update-right-preserves-union-converse/L F1 F2P U2
	(union/= J0 DA nat`eq/) (nat`ge?/yes (nat`ge/= nat`eq/)) map/0 F3 U3 J3
    <- not-member-lookup-not-equal F1 (lookup/= nat`eq/) NE
    <- nat`eq-ne-implies-false nat`eq/ NE F
    <- false-implies-not-member F F3
    <- false-implies-update F U3
    <- false-implies-union F J3.

- : not-member-update-right-preserves-union-converse/L F1 F2P U2
	(union/= J0 DA nat`eq/) (nat`ge?/yes (nat`ge/> GT)) _
	(not-member/> F30 P) (update/> U30 P) J
    <- nat`gt-implies-plus GT _ P
    <- not-member-lookup-not-equal F1 (lookup/= nat`eq/) NE
    <- update/>-inversion* U2 P M22 U20 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- not-member-respects-eq F2P EQ2s nat`eq/ F2PP
    <- not-member/>-inversion F2PP P F2P0
    <- not-member/>-inversion F1 P F10
    <- not-member-update-right-preserves-union-converse F10 F2P0 U20 J0 M0 F30 U30 J0P
    <- union-respects-eq (union/= J0P DA nat`eq/) eq/ EQ2 eq/ J.

- : not-member-update-right-preserves-union-converse/L _ F2P U2
	(union/> J0 P) (nat`ge?/yes (nat`ge/= nat`eq/)) _ F3 U3P J3
    <- not-member-update-implies-shift F2P U2 SH2 D1=D2
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- shift-preserves-union J0 (shift/+ Psc) SH2 _ SH3 J3
    <- shift-implies-not-member SH3 F3
    <- shift-implies-update SH3 U3
    <- update-respects-eq U3 eq/ nat`eq/ D1=D2 eq/ U3P.

- : not-member-update-right-preserves-union-converse/L F1 F2P (U2:update M N D _)
	(union/> J0 (P0: plus (s D0) N2 N1))
	(nat`ge?/yes (nat`ge/> (N>N2:gt N N2)) ) _
	(not-member/> F30 P2) 
	(update/> U30 P2)
	J3
    <- gt-implies-plus N>N2 D2 P2
    <- update/>-inversion* U2 P2 _ U20 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- not-member-respects-eq F2P EQ2s nat`eq/ F2PP
    <- not-member/>-inversion F2PP P2 F2P0
    <- plus-swap-succ P0 P0s
    <- plus-swap-succ P2 P2s
    <- plus-commutative P0s P0sc
    <- plus-commutative P2s P2sc
    <- shift-preserves-not-member-converse* F1 (shift/+ P0sc) P2sc F10
    <- not-member-update-right-preserves-union-converse F10 F2P0 U20 J0 _
	 F30 U30 J0P
    <- union-respects-eq (union/> J0P P0) eq/ EQ2 eq/ J3.

- : not-member-update-right-preserves-union-converse/L F1 F2P (U2:update M N _ _)
	(union/< J0 (P0: plus (s D0) N1 N2))
	(nat`ge?/yes N>=N2) _
	(not-member/> F30 P1) (update/> U30 P1) J3
    <- ge-implies-plus (N>=N2:nat`ge N N2) D2 P2
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc 
    <- plus-commutative P2 P2c
    <- plus-associative P0sc P2c D1 D0+D2=D1 P1sc
    <- plus-swap-succ P1sc P1c
    <- plus-commutative P1c P1
    <- update-commutes-shift-converse* U2 (shift/+ P0sc) P1sc _ SH U20
    <- shift-preserves-not-member-converse* F2P SH P1sc F2P0
    <- not-member/>-inversion F1 P1 F10
    <- not-member-update-right-preserves-union-converse F10 F2P0 U20 J0 _
	 F30 U30 J0P
    <- shift-right-preserves-union J0P SH J3.

- : not-member-update-right-preserves-union-converse F1 F2P U2
	union/L _ F2P U2 union/L.

- : not-member-update-right-preserves-union-converse F1 F2P U2 J _ F3 U3 J3
    <- nat`ge?-total GE?
    <- not-member-update-right-preserves-union-converse/L F1 F2P U2 J GE? _ F3 U3 J3.

%worlds () 
	(not-member-update-right-preserves-union-converse _ _ _ _ _ _ _ _)
	(not-member-update-right-preserves-union-converse/L _ _ _ _ _ _ _ _ _).
%total (J1 J2)
	(not-member-update-right-preserves-union-converse/L _ _ _ J1 _ _ _ _ _)
	(not-member-update-right-preserves-union-converse _ _ _ J2 _ _ _ _).


%theorem not-member-update-right-preserves-union-converse* :
	forall* {M1} {M2P} {M2} {M} {N} {D} {MP}
	forall	{F1: not-member M1 N}
    		{F2: not-member M2P N}
    		{U2: update M2P N D M2}
    		{J: union M1 M2 M}
		{F: not-member MP N}
		{U: update MP N D M}
	exists	{J: union M1 M2P MP}
	true.

- : not-member-update-right-preserves-union-converse* F1 F2P U2 J F U JP
    <- not-member-update-right-preserves-union-converse F1 F2P U2 J _ FP UP JPP
    <- not-member-update-cancels FP UP F U nat`eq/ eq/ _ ME
    <- union-respects-eq JPP eq/ eq/ ME JP.

%worlds () (not-member-update-right-preserves-union-converse* _ _ _ _ _ _ _).
%total {} (not-member-update-right-preserves-union-converse* _ _ _ _ _ _ _).


%theorem not-member-update-preserves-union-converse :
	forall* {M1P} {M1} {M2P} {M2} {M} {N} {D1} {D2}
	forall	{F1: not-member M1P N}
		{U1: update M1P N D1 M1}
    		{F2: not-member M2P N}
    		{U2: update M2P N D2 M2}
    		{J: union M1 M2 M}
 	exists  {MP} {D}
		{F: not-member MP N}
		{U: update MP N D M}
		{J: unit`union D1 D2 D}
		{J: union M1P M2P MP}
	true.

%theorem not-member-update-preserves-union-converse/L :
	forall* {N1} {D1} {M1} {M1P} 
		{N2} {D2} {M2} {M2P} {M} {N} {D1P} {D2P} {B1} {B2}
	forall	{F1: not-member M1P N}
		{U1: update M1P N D1P (map/+ N1 D1 M1)}
    		{F2: not-member M2P N}
    		{U2: update M2P N D2P (map/+ N2 D2 M2)}
    		{J: union (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
		{GE1: nat`ge? N N1 B1}
		{GE2: nat`ge? N N2 B2}
 	exists  {MP} {D}
		{F: not-member MP N}
		{U: update MP N D M}
		{J: unit`union D1P D2P D}
		{J: union M1P M2P MP}
	true.

%theorem false-implies-unit:
	forall	{F: void}
	exists	{D: unit}
	true.

%worlds () (false-implies-unit _ _).
%total { } (false-implies-unit _ _).

- : not-member-update-preserves-union-converse/L F1P U1 F2P U2 _
	(nat`ge?/no GT) _ map/0 D F3 U3 DJ J3
    <- update-implies-lookup U1 L1
    <- not-member-lookup-not-equal (not-member/< GT) L1 NE
    <- nat`eq-ne-implies-false nat`eq/ NE F
    <- false-implies-unit F D
    <- false-implies-not-member F F3
    <- false-implies-update F U3
    <- unit`false-implies-union F DJ
    <- false-implies-union F J3.

- : not-member-update-preserves-union-converse/L F1P U1 F2P U2 _
	_ (nat`ge?/no GT) map/0 D F3 U3 DJ J3
    <- update-implies-lookup U2 L2
    <- not-member-lookup-not-equal (not-member/< GT) L2 NE
    <- nat`eq-ne-implies-false nat`eq/ NE F
    <- false-implies-unit F D
    <- false-implies-not-member F F3
    <- false-implies-update F U3
    <- unit`false-implies-union F DJ
    <- false-implies-union F J3.

- : not-member-update-preserves-union-converse/L F1P U1 F2P U2 
	(union/= J0 DJ0 nat`eq/) (nat`ge?/yes (nat`ge/= nat`eq/)) _ _ _ 
	F3 U3 DJ J3
    <- not-member-update-implies-shift F1P U1 SH1 EQ1
    <- not-member-update-implies-shift F2P U2 SH2 EQ2
    <- shift-preserves-union J0 SH1 SH2 _ SH3 J3
    <- shift-implies-not-member SH3 F3
    <- shift-implies-update SH3 U3
    <- unit`union-respects-eq DJ0 EQ1 EQ2 unit`eq/ DJ.

- : not-member-update-preserves-union-converse/L F1P U1 F2P U2 
	(union/= J0 DJ0 nat`eq/) (nat`ge?/yes (nat`ge/> GT)) _ _ _ 
	(not-member/> F30 P) (update/> U30 P)
	DJ J3
    <- gt-implies-plus GT _ P
    <- update/>-inversion* U1 P _ U10 EQ1
    <- update/>-inversion* U2 P _ U20 EQ2
    <- eq-symmetric EQ1 EQ1s
    <- eq-symmetric EQ2 EQ2s
    <- not-member-respects-eq F1P EQ1s nat`eq/ F1PP
    <- not-member-respects-eq F2P EQ2s nat`eq/ F2PP
    <- not-member/>-inversion F1PP P F1P0
    <- not-member/>-inversion F2PP P F2P0
    <- not-member-update-preserves-union-converse F1P0 U10 F2P0 U20 J0 _ _
	F30 U30 DJ J30
    <- union-respects-eq (union/= J30 DJ0 nat`eq/) EQ1 EQ2 eq/ J3.

- : not-member-update-preserves-union-converse/L F1P U1 F2P U2 
	(union/< J0 (P0:plus (s D0) N1 N2)) _ (nat`ge?/yes (N>=N2:nat`ge N N2)) 
	_ _ 
	(not-member/> F30 P1) 
	(update/> U30 P1) DJ J3
    <- ge-implies-plus (N>=N2:nat`ge N N2) D2 P2
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc 
    <- plus-commutative P2 P2c
    <- plus-associative P0sc P2c D1 D0+D2=D1 P1sc
    <- plus-swap-succ P1sc P1c
    <- plus-commutative P1c P1
    <- update/>-inversion* U1 P1 _ U10 EQ1
    <- eq-symmetric EQ1 EQ1s
    <- not-member-respects-eq F1P EQ1s nat`eq/ F1PP
    <- not-member/>-inversion F1PP P1 F1P0
    <- update-commutes-shift-converse* U2 (shift/+ P0sc) P1sc _ SH2 U20
    <- shift-preserves-not-member-converse* F2P SH2 P1sc F2P0
    <- not-member-update-preserves-union-converse F1P0 U10 F2P0 U20 J0 _ _
	F30 U30 DJ J30
    <- shift-right-preserves-union J30 SH2 J3P
    <- union-respects-eq J3P EQ1 eq/ eq/ J3.

- : not-member-update-preserves-union-converse/L F1P U1 F2P U2 
	(union/> J0 (P0:plus (s D0) N2 N1)) (nat`ge?/yes (N>=N1:nat`ge N N1)) _
	_ _ 
	(not-member/> F30 P2) 
	(update/> U30 P2) DJ J3
    <- ge-implies-plus (N>=N1:nat`ge N N1) D1 P1
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc 
    <- plus-commutative P1 P1c
    <- plus-associative P0sc P1c D2 D0+D1=D2 P2sc
    <- plus-swap-succ P2sc P2c
    <- plus-commutative P2c P2
    <- update-commutes-shift-converse* U1 (shift/+ P0sc) P2sc _ SH1 U10
    <- shift-preserves-not-member-converse* F1P SH1 P2sc F1P0
    <- update/>-inversion* U2 P2 _ U20 EQ2
    <- eq-symmetric EQ2 EQ2s
    <- not-member-respects-eq F2P EQ2s nat`eq/ F2PP
    <- not-member/>-inversion F2PP P2 F2P0
    <- not-member-update-preserves-union-converse F1P0 U10 F2P0 U20 J0 _ _
	F30 U30 DJ J30
    <- shift-left-preserves-union J30 SH1 J3P
    <- union-respects-eq J3P eq/ EQ2 eq/ J3.

- : not-member-update-preserves-union-converse F1P U1 F2P U2 J _ _ FP UP DJ JP
    <- nat`ge?-total GE1
    <- nat`ge?-total GE2
    <- not-member-update-preserves-union-converse/L F1P U1 F2P U2 J GE1 GE2 _ _ 
	FP UP DJ JP.

%worlds ()
	(not-member-update-preserves-union-converse/L _ _ _ _ _ _ _ _ _ _ _ _ _)
	(not-member-update-preserves-union-converse _ _ _ _ _ _ _ _ _ _ _).

%total (J1 J2)
	(not-member-update-preserves-union-converse/L _ _ _ _ J1 _ _ _ _ _ _ _ _)
	(not-member-update-preserves-union-converse _ _ _ _ J2 _ _ _ _ _ _).


%theorem unit-eq-symmetric:
	forall*	{D1} {D2}
	forall	{DE: unit`eq D1 D2}
	exists	{DE: unit`eq D2 D1}
	true.

- : unit-eq-symmetric unit`eq/ unit`eq/.

%worlds () (unit-eq-symmetric _ _).
%total { } (unit-eq-symmetric _ _).

%theorem not-member-update-preserves-union-converse* :
	forall* {M1P} {M1} {M2P} {M2} {M} {N} {D1} {D2} {MP} {D}
	forall	{F1: not-member M1P N}
		{U1: update M1P N D1 M1}
    		{F2: not-member M2P N}
    		{U2: update M2P N D2 M2}
    		{J: union M1 M2 M}
		{F: not-member MP N}
		{U: update MP N D M}
	exists	{J: unit`union D1 D2 D}
		{J: union M1P M2P MP}
	true.

- : not-member-update-preserves-union-converse* F1P U1 F2P U2 J F3 U3 DJ J3
    <- not-member-update-preserves-union-converse F1P U1 F2P U2 J _ _ F3P U3P DJP J3P
    <- not-member-update-cancels F3P U3P F3 U3 nat`eq/ eq/ DE E
    <- unit`union-respects-eq DJP unit`eq/ unit`eq/ DE DJ
    <- union-respects-eq J3P eq/ eq/ E J3.

%worlds () (not-member-update-preserves-union-converse* _ _ _ _ _ _ _ _ _).
%total { } (not-member-update-preserves-union-converse* _ _ _ _ _ _ _ _ _).


%theorem bound-commute-union* :
	forall* {M1} {M2} {M3} {N1} {N2} {N3}
	forall	{B1: bound M1 N1}
		{B2: bound M2 N2}
		{B3: bound M3 N3}
		{J: union M1 M2 M3}
	exists	{MX: nat`max N1 N2 N3}
	true.

- : bound-commute-union* (bound/0) B2 B3 union/L M
    <- bound-unique B2 B3 eq/ N2=N3
    <- ge-zero-always _ N2>=0
    <- nat`le-implies-max N2>=0 MP
    <- nat`max-respects-eq MP nat`eq/ nat`eq/ N2=N3 M.

- : bound-commute-union* B1 (bound/0) B3 union/R M
    <- bound-unique B1 B3 eq/ N1=N3
    <- ge-zero-always _ N1>=0
    <- nat`ge-implies-max N1>=0 MP
    <- nat`max-respects-eq MP nat`eq/ nat`eq/ N1=N3 M.

- : bound-commute-union* 
	(bound/+ P1 B1) (bound/+ P2 B2) (bound/+ P3 B3)
	(union/= J _ nat`eq/) MP
    <- bound-commute-union* B1 B2 B3 J M
    <- plus-left-preserves-max M P1 P2 P3 MP.

- : bound-commute-union*
	(bound/+ P1 B1) (bound/+ P2 B2) (bound/+ P3 B3)
	(union/< J P) MP
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- plus-swap-succ P2 P2s
    <- plus-associative Psc P2s _ P2Ps PP2
    <- plus-swap-succ-converse P2Ps P2P
    <- bound-commute-union* B1 (bound/+ P2P B2) B3 J M
    <- plus-left-preserves-max M P1 PP2 P3 MP.

- : bound-commute-union*
	(bound/+ P1 B1) (bound/+ P2 B2) (bound/+ P3 B3)
	(union/> J P) MP
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- plus-swap-succ P1 P1s
    <- plus-associative Psc P1s _ P1Ps PP1
    <- plus-swap-succ-converse P1Ps P1P
    <- bound-commute-union* (bound/+ P1P B1) B2 B3 J M
    <- plus-left-preserves-max M PP1 P2 P3 MP.

%worlds () (bound-commute-union* _ _ _ _ _).
%total (J) (bound-commute-union* _ _ _ J _).


%theorem size-commute-disjoint-union*:
	forall* {M1} {M2} {M3} {N1} {N2} {N3}
	forall	{B1: size M1 N1}
		{B2: size M2 N2}
		{B3: size M3 N3}
		{DJ: disjoint M1 M2}
		{J: union M1 M2 M3}
	exists	{MX: nat`plus N1 N2 N3}
	true.

- : size-commute-disjoint-union* (size/0) B2 B3 _ union/L P
    <- size-unique B2 B3 eq/ N2=N3
    <- nat`plus-respects-eq plus/z nat`eq/ nat`eq/ N2=N3 P.

- : size-commute-disjoint-union* B1 (size/0) B3 _ union/R P
    <- size-unique B1 B3 eq/ N1=N3
    <- plus-right-identity N1 N1+0=N1
    <- nat`plus-respects-eq N1+0=N1 nat`eq/ nat`eq/ N1=N3 P.

- : size-commute-disjoint-union* _ _ _ DSJ
	(union/= J _ nat`eq/) P
    <- disjoint/=-contradiction DSJ nat`eq/ F
    <- nat`false-implies-plus F P.

- : size-commute-disjoint-union*
	(size/+ S1) (size/+ S2) (size/+ S3) DSJ
	(union/< J1 P1) (plus/s PP1)
    <- disjoint/<-inversion DSJ P1 DSJ1
    <- size-commute-disjoint-union* S1 (size/+ S2) S3 DSJ1 J1 PP1.

- : size-commute-disjoint-union*
	(size/+ S1) (size/+ S2) (size/+ S3) DSJ
	(union/> J1 P1) PP
    <- disjoint/>-inversion DSJ P1 DSJ1
    <- size-commute-disjoint-union* (size/+ S1) S2 S3 DSJ1 J1 PP1
    <- plus-right-increase PP1 PP.

%worlds () (size-commute-disjoint-union* _ _ _ _ _ _).
%total (J) (size-commute-disjoint-union* _ _ _ _ J _).


%theorem union-implies-leq* :
	forall* {M1} {M2} {M3}
	forall {J:union M1 M2 M3}
        exists {L:leq M1 M3}
	true.

- : union-implies-leq* union/L leq/0.

- : union-implies-leq* union/R M2=M2
    <- leq-reflexive _ M2=M2.

- : union-implies-leq* (union/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                      (leq/= M1<=M3 D1<=D3 nat`eq/)
    <- unit`union-implies-leq* D1+D2=D3 D1<=D3
    <- union-implies-leq* M1+M2=M3 M1<=M3.

- : union-implies-leq* (union/< M1+_=M3 _) (leq/= M1<=M3 D1<=D1 nat`eq/)
    <- unit`leq-reflexive _ D1<=D1
    <- union-implies-leq* M1+_=M3 M1<=M3.	

- : union-implies-leq* (union/> M311+M2=M3 P) (leq/> M311<=M3 P)
    <- union-implies-leq* M311+M2=M3 M311<=M3.

%worlds () (union-implies-leq* _ _).
%total (J) (union-implies-leq* J _).


%theorem union-implies-leq :
	forall* {M1} {M2} {M3}
	forall {A:union M1 M2 M3}
        exists {L1:leq M1 M3} {L2:leq M2 M3}
	true.

- : union-implies-leq M1*M2=M3 M1<=M3 M2<=M3
    <- union-implies-leq* M1*M2=M3 M1<=M3
    <- union-commutative M1*M2=M3 M2*M1=M3
    <- union-implies-leq* M2*M1=M3 M2<=M3.

%worlds () (union-implies-leq _ _ _).
%total { } (union-implies-leq _ _ _).


%theorem union-is-lub :
	forall* {M1} {M2} {M3} {M4}
	forall {J:union M1 M2 M3}
	       {L1:leq M1 M4} {L2:leq M2 M4}
	exists {L3:leq M3 M4}
	true.

- : union-is-lub union/L _ L L.

- : union-is-lub union/R L _ L.

- : union-is-lub (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
                (leq/= M1<=M4 D1<=D4 nat`eq/)
                (leq/= M2<=M4 D2<=D4 nat`eq/)
                (leq/= M3<=M4 D3<=D4 nat`eq/)
    <- unit`union-is-lub D1+D2=D3 D1<=D4 D2<=D4 D3<=D4
    <- union-is-lub M1+M2=M3 M1<=M4 M2<=M4 M3<=M4.

- : union-is-lub (union/= _ _ nat`eq/) (leq/= _ _ nat`eq/) (leq/> _ N3+1+N=N) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-leq F L.

- : union-is-lub (union/= _ _ nat`eq/) (leq/> _ N3+1+N=N) (leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-leq F L.

- : union-is-lub (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
                (leq/> M511<=M4 N5+1+N4=N)
                (leq/> M622<=M4 N6+1+N4=N)
                (leq/> M633<=M4 N6+1+N4=N)
    <- nat`plus-right-cancels N5+1+N4=N N6+1+N4=N nat`eq/ nat`eq/ N5+1=N6+1
    <- nat`succ-cancels N5+1=N6+1 N5=N6
    <- map/+-preserves-eq N5=N6 unit`eq/ eq/ M511=M611
    <- leq-respects-eq M511<=M4 M511=M611 eq/ M611<=M4
    <- union-is-lub (union/= M1+M2=M3 D1+D2=D3 nat`eq/) 
                   M611<=M4 M622<=M4 M633<=M4.

- : union-is-lub (union/< _ N0+1+N=N) (leq/= _ _ nat`eq/) (leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-leq F L.

- : union-is-lub (union/< M1+M022=M3 N0+1+N1=N2)
                (leq/= M1<=M4 D1<=D4 nat`eq/)
                (leq/> M622<=M4 N6+1+N1=N2)
                (leq/= M3<=M4 D1<=D4 nat`eq/)
    <- nat`plus-right-cancels N6+1+N1=N2 N0+1+N1=N2 nat`eq/ nat`eq/ N6+1=N0+1
    <- succ-cancels N6+1=N0+1 N6=N0
    <- map/+-preserves-eq N6=N0 unit`eq/ eq/ M622=M022
    <- leq-respects-eq M622<=M4 M622=M022 eq/ M022<=M4
    <- union-is-lub M1+M022=M3 M1<=M4 M022<=M4 M3<=M4.

- : union-is-lub (union/< _ N0+1+N1=N2) (leq/> _ N3+1+N2=N1) (leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-leq F L.

- : union-is-lub (union/< M1+M022=M3 N0+1+N1=N2)
                (leq/> M511<=M4 N5+1+N4=N1)
                (leq/> M622<=M4 N6+1+N4=N2)
                (leq/> M513<=M4 N5+1+N4=N1)
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 
                                     N6P N0+1+N5=N6P N6P+N4+1=N2
    <- nat`plus-swap-succ-converse N6P+N4+1=N2 N6P+1+N4=N2
    <- nat`plus-right-cancels N6P+1+N4=N2 N6+1+N4=N2 nat`eq/ nat`eq/ N6P+1=N6+1
    <- nat`succ-cancels N6P+1=N6+1 N6P=N6
    <- nat`plus-respects-eq N0+1+N5=N6P nat`eq/ nat`eq/ N6P=N6 N0+1+N5=N6
    <- union-is-lub (union/< M1+M022=M3 N0+1+N5=N6) M511<=M4 M622<=M4 M513<=M4.

- : union-is-lub (union/> _ N3+1+N=N) (leq/= _ _ nat`eq/) (leq/= _ _ nat`eq/) L
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-leq F L.

- : union-is-lub (union/> _ N3+1+N2=N1) (leq/= _ _ nat`eq/) (leq/> _ N0+1+N1=N2) L
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-leq F L.

- : union-is-lub (union/> M311+M2=M3 N3+1+N2=N1)
                (leq/> M511<=M4 N5+1+N2=N1)
                (leq/= M2<=M4 D2<=D4 nat`eq/)
                (leq/= M3<=M4 D2<=D4 nat`eq/)
    <- nat`plus-right-cancels N3+1+N2=N1 N5+1+N2=N1 nat`eq/ nat`eq/ N3+1=N5+1
    <- nat`succ-cancels N3+1=N5+1 N3=N5
    <- map/+-preserves-eq N3=N5 unit`eq/ eq/ M311=M511
    <- union-respects-eq M311+M2=M3 M311=M511 eq/ eq/ M511+M2=M3
    <- union-is-lub M511+M2=M3 M511<=M4 M2<=M4 M3<=M4.

- : union-is-lub (union/> M311+M2=M3 N3+1+N2=N1)
                (leq/> M511<=M4 N5+1+N4=N1)
                (leq/> M622<=M4 N6+1+N4=N2)
                (leq/> M623<=M4 N6+1+N4=N2)
    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- nat`plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 
                                     N5P N3+1+N6=N5P N5P+N4+1=N1
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-right-cancels N5P+N4+1=N1 N5+N4+1=N1 nat`eq/ nat`eq/ N5P=N5
    <- nat`plus-respects-eq N3+1+N6=N5P nat`eq/ nat`eq/ N5P=N5 N3+1+N6=N5
    <- union-is-lub (union/> M311+M2=M3 N3+1+N6=N5) M511<=M4 M622<=M4 M623<=M4.

%worlds () (union-is-lub _ _ _ _).
%total (L) (union-is-lub _ L _ _).


%theorem union-idempotent :
	forall* {S}
	exists {J:union S S S}
	true.

- : union-idempotent S+S=S
    <- union-total S+S=SP
    <- union-implies-leq* S+S=SP S<=SP
    <- leq-reflexive _ S<=S
    <- union-is-lub S+S=SP S<=S S<=S SP<=S
    <- leq-anti-symmetric SP<=S S<=SP SP=S
    <- union-respects-eq S+S=SP eq/ eq/ SP=S S+S=S.

%worlds () (union-idempotent _).
%total { } (union-idempotent _).


%theorem leq-implies-union :
	forall* {M1} {M2}
	forall {L:leq M1 M2}
	exists {J:union M1 M2 M2}
	true.

- : leq-implies-union M1<=M2 M1+M2=M2
    <- union-total M1+M2=M3
    <- leq-reflexive _ M2<=M2
    <- union-is-lub M1+M2=M3 M1<=M2 M2<=M2 M3<=M2
    <- union-implies-leq M1+M2=M3 _ M2<=M3
    <- leq-anti-symmetric M3<=M2 M2<=M3 M3=M2
    <- union-respects-eq M1+M2=M3 eq/ eq/ M3=M2 M1+M2=M2.

%worlds () (leq-implies-union _ _).
%total { } (leq-implies-union _ _).


%theorem disjoint-leq-implies-union-leq* :
	forall* {C1} {C2} {C} {C3}
	forall	{D:disjoint C1 C2}
		{L1:leq C1 C}
		{L2:leq C2 C}
		{J:union C1 C2 C3}
	exists	{L3:leq C3 C}
	true.

- : disjoint-leq-implies-union-leq* disjoint/L _ C2<=C Z+C2=C3 C3<=C
    <- union-deterministic union/L Z+C2=C3 eq/ eq/ C2=C3
    <- leq-respects-eq C2<=C C2=C3 eq/ C3<=C.

- : disjoint-leq-implies-union-leq* disjoint/R C1<=C _ C1+0=C3 C3<=C
    <- union-deterministic union/R C1+0=C3 eq/ eq/ C1=C3
    <- leq-respects-eq C1<=C C1=C3 eq/ C3<=C.

- : disjoint-leq-implies-union-leq* 
	(disjoint/< C1^C022 P) 
	(leq/= C1<=C4 D1<=D4 nat`eq/) 
	C222<=C444 C111+C222=C333 C333<=C444
    <- union/<-inversion C111+C222=C333 P _ C1+C022=C5 C333=C115
    <- leq/>-inversion C222<=C444 P C022<=C4
    <- disjoint-leq-implies-union-leq* 
	C1^C022 C1<=C4 C022<=C4 C1+C022=C5 C5<=C4
    <- eq-symmetric C333=C115 C115=C333
    <- leq-respects-eq 
	(leq/= C5<=C4 D1<=D4 nat`eq/) C115=C333 eq/ C333<=C444.

- : disjoint-leq-implies-union-leq* (disjoint/< C1^C022 N0+1+N1=N2) (leq/> C611<=C4 N6+1+N4=N1) C222<=C444 C111+C222=C333 C333<=C444
    <- union/<-inversion C111+C222=C333 N0+1+N1=N2 _ C1+C022=C5 C333=C115
    <- plus-swap-succ N6+1+N4=N1 N6+N4+1=N1
    <- plus-associative-converse 
	N6+N4+1=N1 N0+1+N1=N2 N7 N0+1+N6=N7 N7+N4+1=N2
    <- plus-swap-succ-converse N7+N4+1=N2 N7+1+N4=N2
    <- leq/>-inversion C222<=C444 N7+1+N4=N2 C722<=C4
    <- disjoint-leq-implies-union-leq* 
	(disjoint/< C1^C022 N0+1+N6=N7) 
	C611<=C4 C722<=C4 
	(union/< C1+C022=C5 N0+1+N6=N7) C615<=C4
    <- eq-symmetric C333=C115 C115=C333
    <- leq-respects-eq 
	(leq/> C615<=C4 N6+1+N4=N1) C115=C333 eq/ C333<=C444.

- : disjoint-leq-implies-union-leq* 
	(disjoint/> C011^C2 P) 
	C111<=C444 (leq/= C2<=C4 D2<=D4 nat`eq/) 
	C111+C222=C333 C333<=C444
    <- union/>-inversion C111+C222=C333 P _ C011+C2=C5 C333=C225
    <- leq/>-inversion C111<=C444 P C011<=C4
    <- disjoint-leq-implies-union-leq* 
	C011^C2 C011<=C4 C2<=C4 C011+C2=C5 C5<=C4
    <- eq-symmetric C333=C225 C225=C333
    <- leq-respects-eq 
	(leq/= C5<=C4 D2<=D4 nat`eq/) C225=C333 eq/ C333<=C444.

- : disjoint-leq-implies-union-leq* 
	(disjoint/> C011^C2 N0+1+N2=N1) 
	C111<=C444 (leq/> C622<=C4 N6+1+N4=N2)
	C111+C222=C333 C333<=C444
    <- union/>-inversion C111+C222=C333 N0+1+N2=N1 _ C011+C2=C5 C333=C225
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-associative-converse 
	N6+N4+1=N2 N0+1+N2=N1 N7 N0+1+N6=N7 N7+N4+1=N1
    <- plus-swap-succ-converse N7+N4+1=N1 N7+1+N4=N1
    <- leq/>-inversion C111<=C444 N7+1+N4=N1 C711<=C4
    <- disjoint-leq-implies-union-leq* 
	(disjoint/> C011^C2 N0+1+N6=N7) 
	C711<=C4 C622<=C4 
	(union/> C011+C2=C5 N0+1+N6=N7) C625<=C4
    <- eq-symmetric C333=C225 C225=C333
    <- leq-respects-eq 
	(leq/> C625<=C4 N6+1+N4=N2) C225=C333 eq/ C333<=C444.

%worlds () (disjoint-leq-implies-union-leq* _ _ _ _ _).
%total (L) (disjoint-leq-implies-union-leq* _ L _ _ _).


%theorem union-left-preserves-leq* :
	forall* {M1} {M2} {M3} {M4} {M5}
	forall {L1:leq M2 M4}
               {J:union M1 M2 M3} {JP:union M1 M4 M5}
	exists {L3:leq M3 M5}
	true.

- : union-left-preserves-leq* L union/L union/L L.

- : union-left-preserves-leq* _ union/L union/R leq/0.

- : union-left-preserves-leq* leq/0 union/R M1+M4=M5 M1<=M5
    <- union-implies-leq* M1+M4=M5 M1<=M5.

- : union-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
                             M111+M144=M M133<=M
    <- union/=-inversion M111+M144=M nat`eq/ D5 M5 D1+D4=D5 M1+M4=M5 M=M155
    <- eq-symmetric M=M155 M155=M
    <- meta-eq (map/+ N1 D5 M5) M M155=M
    <- unit`union-left-preserves-leq* D2<=D4 D1+D2=D3 D1+D4=D5 D3<=D5
    <- union-left-preserves-leq* M2<=M4 M1+M2=M3 M1+M4=M5 M3<=M5
    <- leq-respects-eq (leq/= M3<=M5 D3<=D5 nat`eq/) eq/ M155=M M133<=M.

- : {M1+M044=M5:union M1 (map/+ N0 D4 M4) M5}
    {M115=M: eq (map/+ N1 D1 M5) M}
    union-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (union/< M1+M022=M3 N0+1+N1=N2)
                             M111+M244=M M113<=M
    <- union/<-inversion M111+M244=M N0+1+N1=N2 M5 M1+M044=M5 M=M115
    <- eq-symmetric M=M115 M115=M
    <- meta-eq (map/+ N1 D1 M5) M M115=M
    <- union-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/) 
                                M1+M022=M3 M1+M044=M5 M3<=M5
    <- unit`leq-reflexive _ D1<=D1
    <- leq-respects-eq (leq/= M3<=M5 D1<=D1 nat`eq/) eq/ M115=M M113<=M.

- : union-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (union/> M311+M2=M3 N3+1+N2=N1)
                             M111+M244=M M223<=M
    <- union/>-inversion M111+M244=M N3+1+N2=N1 M5 M311+M4=M5 M=M245
    <- eq-symmetric M=M245 M245=M
    <- meta-eq (map/+ N2 D4 M5) M M245=M
    <- union-left-preserves-leq* M2<=M4 M311+M2=M3 M311+M4=M5 M3<=M5
    <- leq-respects-eq (leq/= M3<=M5 D2<=D4 nat`eq/) eq/ M245=M M223<=M.

- : union-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (union/= M1+M2=M3 D1+D2=D3 nat`eq/)   % N1=N2
                             M211+M444=M M233<=M
    <- union/>-inversion M211+M444=M N6+1+N4=N2 M5 M611+M4=M5 M=M445
    <- eq-symmetric M=M445 M445=M
    <- meta-eq (map/+ N4 D4 M5) M M445=M
    <- union-left-preserves-leq* M622<=M4 (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
                                M611+M4=M5 M633<=M5
    <- leq-respects-eq (leq/> M633<=M5 N6+1+N4=N2) eq/ M445=M M233<=M.

- : union-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (union/< M1+M022=M3 N0+1+N4=N2)
                             (union/= M1+M4=M5 D1+D4=D5 nat`eq/)
                             (leq/= M3<=M5 D1<=D5 nat`eq/)
    <- nat`plus-right-cancels N6+1+N4=N2 N0+1+N4=N2 nat`eq/ nat`eq/ N6+1=N0+1
    <- nat`succ-cancels N6+1=N0+1 N6=N0
    <- map/+-preserves-eq N6=N0 unit`eq/ eq/ M622=M022
    <- leq-respects-eq M622<=M4 M622=M022 eq/ M022<=M4
    <- union-left-preserves-leq* M022<=M4 M1+M022=M3 M1+M4=M5 M3<=M5
    <- unit`union-implies-leq* D1+D4=D5 D1<=D5.

- : union-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (union/< M1+M022=M3 N0+1+N1=N2)
                             (union/< M1+M544=M5 N5+1+N1=N4)
                             (leq/= M3<=M5 D1<=D1 nat`eq/)
    <- nat`plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- nat`plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 
                                     N0P N6+1+N5=N0P N0P+N1+1=N2
    <- nat`plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- nat`plus-right-cancels N0P+N1+1=N2 N0+N1+1=N2 nat`eq/ nat`eq/ N0P=N0
    <- nat`plus-respects-eq N6+1+N5=N0P nat`eq/ nat`eq/ N0P=N0 N6+1+N5=N0
    <- union-left-preserves-leq* (leq/> M622<=M4 N6+1+N5=N0) 
                                M1+M022=M3 M1+M544=M5 M3<=M5
    <- unit`leq-reflexive _ D1<=D1.
       

% for some reason, twelf needs a lot of help inferring types here:
- : union-left-preserves-leq* ((leq/> M622<=M4 N6+1+N4=N2):leq (map/+ N2 D2 M2) (map/+ N4 D4 M4))
                             (union/< M1+M022=M3 N0+1+N1=N2)
                             (union/> M511+M4=M5 N5+1+N4=N1)
                             (leq/> M513<=M5 N5+1+N4=N1)
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 
                                     N6P N0+1+N5=N6P N6P+N4+1=N2
    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- nat`plus-right-cancels N6P+N4+1=N2 N6+N4+1=N2 nat`eq/ nat`eq/ N6P=N6
    <- nat`plus-respects-eq N0+1+N5=N6P nat`eq/ nat`eq/ N6P=N6 N0+1+N5=N6
    <- union-left-preserves-leq* M622<=M4 
       ((union/< M1+M022=M3 N0+1+N5=N6):union (map/+ N5 D1 M1) (map/+ N6 D2 M2)
                                            (map/+ N5 D1 M3))
                                M511+M4=M5 M513<=M5.

- : union-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (union/> M311+M2=M3 N3+1+N2=N1) 
                             M111+M444=M M223<=M
    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- nat`plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 
                                     N5 N3+1+N6=N5 N5+N4+1=N1
    <- nat`plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1 
    <- union/>-inversion M111+M444=M N5+1+N4=N1 M5 M511+M4=M5 M=M445
    <- eq-symmetric M=M445 M445=M
    <- meta-eq _ _ M445=M
    <- union-left-preserves-leq* M622<=M4 (union/> M311+M2=M3 N3+1+N6=N5)
                                M511+M4=M5 M623<=M5
    <- leq-respects-eq (leq/> M623<=M5 N6+1+N4=N2) eq/ M445=M M223<=M.
  
%worlds () (union-left-preserves-leq* _ _ _ _).
%total (J) (union-left-preserves-leq* _ _ J _).



%theorem union-left-preserves-leq :
	forall* {X1} {X2} {X4}
      	forall {G:leq X2 X4}
	exists {X3} {X5}
               {O1:union X1 X2 X3} {O2:union X1 X4 X5}
      	       {G2:leq X3 X5}
	true.

- : union-left-preserves-leq X2<=X4 X3 X5 X1+X2=A3 X1+X4=X5 X3<=X5
    <- union-total X1+X2=A3 
    <- union-total X1+X4=X5
    <- union-left-preserves-leq* X2<=X4 X1+X2=A3 X1+X4=X5 X3<=X5.

%worlds () (union-left-preserves-leq X2<=X4 %{=>}% X3 X5 X1+X2=A3 X1+X4=X5 X3<=X5).
%total {} (union-left-preserves-leq _ _ _ _ _ _).


%theorem union-right-preserves-leq* :
	forall* {X1} {X2} {X3} {X4} {X5}
	forall {G1:leq X1 X2} {O1:union X1 X3 X4} {O2:union X2 X3 X5}
	exists {G2:leq X4 X5}
	true.

- : union-right-preserves-leq* X1<=X2 X1+X3=X4 X2+X3=X5 X4<=X5
    <- union-commutative X1+X3=X4 X3+X1=X4
    <- union-commutative X2+X3=X5 X3+X2=X5
    <- union-left-preserves-leq* X1<=X2 X3+X1=X4 X3+X2=X5 X4<=X5.

%worlds () (union-right-preserves-leq* X1<=X2 X1+X3=X4 X2+X3=X5 %{=>}% X4<=X5).
%total {} (union-right-preserves-leq* _ _ _ _).


%theorem union-right-preserves-leq :
	forall* {X1} {X2} {X3}
	forall {G1:leq X1 X2} 
	exists {X4} {X5} {O1:union X1 X3 X4} {O2:union X2 X3 X5} {G2:leq X4 X5}
	true.

- : union-right-preserves-leq X1<=X2 X4 X5 X1+X3=X4 X2+X3=X5 X4<=X5
    <- union-total X1+X3=X4 
    <- union-total X2+X3=X5
    <- union-right-preserves-leq* X1<=X2 X1+X3=X4 X2+X3=X5 X4<=X5.
%worlds () (union-right-preserves-leq X1<=X2 %{=>}% X4 X5 X1+X3=X4 X2+X3=X5 X4<=X5).
%total {} (union-right-preserves-leq _ _ _ _ _ _).


%theorem union-preserves-leq* :
	forall* {X1} {X2} {X3} {Y1} {Y2} {Y3}
	forall {G1:leq X1 Y1} {G2:leq X2 Y2}
               {MX:union X1 X2 X3} {MY:union Y1 Y2 Y3}
        exists {G3:leq X3 Y3}
	true.

- : union-preserves-leq* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3 X3<=Y3
    <- union-total Y1+X2=X
    <- union-right-preserves-leq* X1<=Y1 X1+X2=X3 Y1+X2=X X3<=X
    <- union-left-preserves-leq* X2<=Y2 Y1+X2=X Y1+Y2=Y3 X<=Y3
    <- leq-transitive X3<=X X<=Y3 X3<=Y3.

%worlds () (union-preserves-leq* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3 %{=>}% X3<=Y3).
%total {} (union-preserves-leq* _ _ _ _ _).


%theorem union-preserves-leq :
	forall* {X1} {X2} {Y1} {Y2}
	forall {G1:leq X1 Y1} {G2:leq X2 Y2}
	exists {X3} {Y3} {MX:union X1 X2 X3} {MY:union Y1 Y2 Y3} {G3:leq X3 Y3}
	true.

- : union-preserves-leq X1<=Y1 X2<=Y2 X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<=Y3
    <- union-total X1+X2=X3
    <- union-total Y1+Y2=Y3
    <- union-preserves-leq* X1<=Y1 X2<=Y2 X1+X2=X3 Y1+Y2=Y3 X3<=Y3.

%worlds () (union-preserves-leq X1<=Y1 X2<=Y2 %{=>}% X3 Y3 X1+X2=X3 Y1+Y2=Y3 X3<=Y3).
%total {} (union-preserves-leq _ _ _ _ _ _ _).



%theorem disjoint-union-left-preserves-leq-converse:
	forall* {M1} {M2} {M3} {M}
    	forall	{M3<=M: leq M3 M}
		{M1UM2=M: union M1 M2 M}
    		{M2^M3: disjoint M1 M3}
	exists	{M3<=M1: leq M3 M2}
 	true.

- : disjoint-union-left-preserves-leq-converse
	leq/0 _ _ leq/0.

- : disjoint-union-left-preserves-leq-converse
	L union/L _ L.

- : disjoint-union-left-preserves-leq-converse
	L union/R D LP
    <- disjoint-respects-geq* D L M3^M3
    <- disjoint-anti-reflexive M3^M3 Z=M3
    <- leq-respects-eq leq/0 Z=M3 eq/ LP.

- : disjoint-union-left-preserves-leq-converse
	(leq/= L0 D3<=D nat`eq/) J DJ
	(leq/= L0P D3<=D2 N=N2)
    <- disjoint-symmetric DJ DJs
    <- disjoint-lookup-implies-not-member (lookup/= nat`eq/) DJs F1
    <- not-member-lookup-not-equal F1 (lookup/= nat`eq/) N<>N1
    <- nat`ne-symmetric N<>N1 N1<>N
    <- union/>-inversion* J N1<>N _ N2=N D2=D P J0
    <- disjoint/>-inversion DJ P DJ0
    <- disjoint-union-left-preserves-leq-converse L0 J0 DJ0 L0P
    <- unit-eq-symmetric D2=D D=D2
    <- unit`leq-respects-eq D3<=D unit`eq/ D=D2 D3<=D2
    <- nat`eq-symmetric N2=N N=N2.
	
- : disjoint-union-left-preserves-leq-converse
	(leq/> L0 P3)
	(union/= J0 D1+D2=D nat`eq/) DJ
	(leq/> L0P P3)
    <- disjoint/<-inversion DJ P3 DJ0
    <- disjoint-union-left-preserves-leq-converse L0 J0 DJ0 L0P.

- : disjoint-union-left-preserves-leq-converse
	(leq/> L0 P3)
	(union/> J0 P0) DJ
	(leq/> L0P P3)
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc
    <- plus-swap-succ P3 P3s
    <- plus-commutative P3s P3sc
    <- shift-preserves-disjoint-converse DJ (shift/+ P0sc) (shift/+ P3sc) DJ0
    <- disjoint-union-left-preserves-leq-converse L0 J0 DJ0 L0P.

- : disjoint-union-left-preserves-leq-converse
	(leq/> L0 P3)
	(union/< J0 P0) DJ
	LP
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc
    <- plus-swap-succ P3 P3s
    <- plus-commutative P3s P3sc
    <- disjoint/<-inversion DJ P3 DJ0
    <- disjoint-union-left-preserves-leq-converse L0 J0 DJ0 L0P
    <- shift-preserves-leq* L0P (shift/+ P3sc) (shift/+ P0sc) LP.

%worlds () (disjoint-union-left-preserves-leq-converse _ _ _ _).
%total (J) (disjoint-union-left-preserves-leq-converse _ J _ _).


%theorem disjoint-union-right-preserves-leq-converse:
	forall* {M1} {M2} {M3} {M}
    	forall	{M3<=M: leq M3 M}
		{M1UM2=M: union M1 M2 M}
    		{M2^M3: disjoint M2 M3}
	exists	{M3<=M1: leq M3 M1}
 	true.

- : disjoint-union-right-preserves-leq-converse
	leq/0 _ _ leq/0.

- : disjoint-union-right-preserves-leq-converse
	L union/R _ L.

- : disjoint-union-right-preserves-leq-converse
	L union/L D LP
    <- disjoint-respects-geq* D L M3^M3
    <- disjoint-anti-reflexive M3^M3 Z=M3
    <- leq-respects-eq leq/0 Z=M3 eq/ LP.

- : disjoint-union-right-preserves-leq-converse
	(leq/= L0 D3<=D nat`eq/) J DJ
	(leq/= L0P D3<=D1 N=N1)
    <- disjoint-symmetric DJ DJs
    <- disjoint-lookup-implies-not-member (lookup/= nat`eq/) DJs F2
    <- not-member-lookup-not-equal F2 (lookup/= nat`eq/) N<>N2
    <- nat`ne-symmetric N<>N2 N2<>N
    <- union/<-inversion* J N2<>N _ N1=N D1=D P J0
    <- disjoint/>-inversion DJ P DJ0
    <- disjoint-union-right-preserves-leq-converse L0 J0 DJ0 L0P
    <- unit-eq-symmetric D1=D D=D1
    <- unit`leq-respects-eq D3<=D unit`eq/ D=D1 D3<=D1
    <- nat`eq-symmetric N1=N N=N1.
	
- : disjoint-union-right-preserves-leq-converse
	(leq/> L0 P3)
	(union/= J0 D1+D2=D nat`eq/) DJ
	(leq/> L0P P3)
    <- disjoint/<-inversion DJ P3 DJ0
    <- disjoint-union-right-preserves-leq-converse L0 J0 DJ0 L0P.

- : disjoint-union-right-preserves-leq-converse
	(leq/> L0 P3)
	(union/< J0 P0) DJ
	(leq/> L0P P3)
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc
    <- plus-swap-succ P3 P3s
    <- plus-commutative P3s P3sc
    <- shift-preserves-disjoint-converse DJ (shift/+ P0sc) (shift/+ P3sc) DJ0
    <- disjoint-union-right-preserves-leq-converse L0 J0 DJ0 L0P.

- : disjoint-union-right-preserves-leq-converse
	(leq/> L0 P3)
	(union/> J0 P0) DJ
	LP
    <- plus-swap-succ P0 P0s
    <- plus-commutative P0s P0sc
    <- plus-swap-succ P3 P3s
    <- plus-commutative P3s P3sc
    <- disjoint/<-inversion DJ P3 DJ0
    <- disjoint-union-right-preserves-leq-converse L0 J0 DJ0 L0P
    <- shift-preserves-leq* L0P (shift/+ P3sc) (shift/+ P0sc) LP.

%worlds () (disjoint-union-right-preserves-leq-converse _ _ _ _).
%total (J) (disjoint-union-right-preserves-leq-converse _ J _ _).


%%%% Map "multiplication"



%%% Definition of intersection


intersection : map -> map -> map -> type.


intersection/L : intersection map/0 M map/0.

intersection/R : intersection M map/0 map/0.

intersection/= : intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N1 D3 M3)
    <- nat`eq N1 N2
    <- unit`intersection D1 D2 D3
    <- intersection M1 M2 M3.

intersection/< : intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) S1M3
    <- nat`plus (s N0) N1 N2
    <- intersection M1 (map/+ N0 D2 M2) M3
    <- shift N1 M3 S1M3.

intersection/> : intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) S2M3
    <- nat`plus (s N3) N2 N1
    <- intersection (map/+ N3 D1 M1) M2 M3
    <- shift N2 M3 S2M3.



%%% Theorems about intersection


%theorem false-implies-intersection :
	forall* {M1} {M2} {M3}
	forall {F:void}
	exists {D:intersection M1 M2 M3}
	true.

%worlds () (false-implies-intersection _ _).
%total {} (false-implies-intersection _ _).


%theorem intersection-respects-eq :
	forall* {M1} {M2} {M3} {M1P} {M2P} {M3P}
	forall {A:intersection M1 M2 M3} {E1:eq M1 M1P} {E2:eq M2 M2P} {E3:eq M3 M3P}
	exists {AP:intersection M1P M2P M3P}
	true.

- : intersection-respects-eq A eq/ eq/ eq/ A.

%worlds () (intersection-respects-eq _ _ _ _ _).
%total {} (intersection-respects-eq _ _ _ _ _).
%reduces A = AP (intersection-respects-eq A _ _ _ AP).


%% Inversion lemmas for intersection


%theorem intersection/L-inversion :
	forall* {M1} {M2} {M3}
	forall {A:intersection M1 M2 M3} {E1:eq map/0 M1}
        exists {E3:eq map/0 M3}
	true.

- : intersection/L-inversion intersection/L eq/ eq/.

- : intersection/L-inversion intersection/R eq/ eq/.

%worlds () (intersection/L-inversion _ _ _).
%total { } (intersection/L-inversion _ _ _).


%theorem intersection/R-inversion :
	forall* {M1} {M2} {M3}
	forall {A:intersection M1 M2 M3} {E1:eq map/0 M2}
        exists {E3:eq map/0 M3}
	true.

- : intersection/R-inversion intersection/L eq/ eq/.

- : intersection/R-inversion intersection/R eq/ eq/.

%worlds () (intersection/R-inversion _ _ _).
%total { } (intersection/R-inversion _ _ _).


%theorem intersection/=-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {M} 
	forall {A:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) M}
	       {G:nat`eq N1 N2}
	exists {D3} {M3} 
	       {D:unit`intersection D1 D2 D3}
               {AP:intersection M1 M2 M3}
               {E:eq (map/+ N1 D3 M3) M}
	true.

- : intersection/=-inversion (intersection/= MM DD nat`eq/) _ _ _ DD MM eq/.

- : intersection/=-inversion (intersection/< S AP N0+1+N=N) nat`eq/ 
                     D2 M3 DA MA ME
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- unit`false-implies-intersection F DA
    <- false-implies-eq F (M022=M2:eq (map/+ N0 D2 M2) M2)
    <- intersection-respects-eq AP eq/ M022=M2 eq/ MA
    <- false-implies-eq F ME.

- : intersection/=-inversion (intersection/> S (AP:intersection (map/+ _ D1 M1) M2 _) N3+1+N=N) nat`eq/
                     D1 M3 DA MA ME
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- nat`gt-anti-reflexive N>N F
    <- unit`false-implies-intersection F DA
    <- false-implies-eq F (M311=M1:eq (map/+ N3 D1 M1) M1)
    <- intersection-respects-eq AP M311=M1 eq/ eq/ MA
    <- false-implies-eq F ME.

%worlds () (intersection/=-inversion _ _ _ _ _ _ _).
%total {} (intersection/=-inversion _ _ _ _ _ _ _).
%reduces AP < A (intersection/=-inversion A _ _ _ _ AP _).


%theorem intersection/<-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {S1M3} {N0}
	forall {A:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) S1M3}
               {P:plus (s N0) N1 N2} 	       
	exists {M3} {AP:intersection M1 (map/+ N0 D2 M2) M3}
               {S:shift N1 M3 S1M3}
	true.

- : intersection/<-inversion (intersection/< S A P) PP _ AP S
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N0+1=N0P+1
    <- succ-cancels N0+1=N0P+1 N0=N0P
    <- map/+-preserves-eq N0=N0P unit`eq/ eq/ M022=M022P
    <- intersection-respects-eq A eq/ M022=M022P eq/ AP.

- : intersection/<-inversion (intersection/= AP _ nat`eq/) N0+1+N=N map/0 A S
    <- nat`plus-implies-gt N0+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M2=M022
    <- false-implies-eq F M3=M333
    <- intersection-respects-eq AP eq/ M2=M022 M3=M333 A
    <- false-implies-shift F S.

- : intersection/<-inversion (intersection/> S AP N3+1+N2=N1) N0+1+N1=N2 _ A SP
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M311=M1
    <- false-implies-eq F M2=M022
    <- intersection-respects-eq AP M311=M1 M2=M022 eq/ A
    <- false-implies-shift F SP.

%worlds () (intersection/<-inversion _ _ _ _ _).
%total {}  (intersection/<-inversion _ _ _ _ _).
%reduces AP < A (intersection/<-inversion A _ _ AP _).


%theorem intersection/>-inversion :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {S2M3} 
	forall {A:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) S2M3}
	       {P:plus (s N3) N2 N1}
	exists {M3} {AP:intersection (map/+ N3 D1 M1) M2 M3}
               {S:shift N2 M3 S2M3}
	true.

- : intersection/>-inversion (intersection/> S A P) PP _ AP S
    <- nat`plus-right-cancels P PP nat`eq/ nat`eq/ N3+1=N3P+1
    <- succ-cancels N3+1=N3P+1 N3=N3P
    <- map/+-preserves-eq N3=N3P unit`eq/ eq/ M311=M311P
    <- intersection-respects-eq A M311=M311P eq/ eq/ AP.

- : intersection/>-inversion (intersection/= AP _ nat`eq/) N3+1+N=N map/0 A S
    <- nat`plus-implies-gt N3+1+N=N nat`eq/ N>N
    <- gt-anti-reflexive N>N F
    <- false-implies-eq F M1=M311
    <- false-implies-eq F M3=M333
    <- intersection-respects-eq AP M1=M311 eq/ M3=M333 A
    <- false-implies-shift F S.

- : intersection/>-inversion (intersection/< S AP N0+1+N1=N2) N3+1+N2=N1 _ A SP
    <- nat`plus-implies-gt N3+1+N2=N1 nat`eq/ N1>N2
    <- nat`plus-implies-gt N0+1+N1=N2 nat`eq/ N2>N1
    <- nat`gt-anti-symmetric N1>N2 N2>N1 F
    <- false-implies-eq F M1=M311
    <- false-implies-eq F M022=M2
    <- intersection-respects-eq AP M1=M311 M022=M2 eq/ A
    <- false-implies-shift F SP.

%worlds () (intersection/>-inversion _ _ _ _ _).
%total { } (intersection/>-inversion _ _ _ _ _).
%reduces AP < A (intersection/>-inversion A _ _ AP _).


%theorem intersection-implies-ge :
	forall* {N1} {D1} {M1} {N2} {D2} {M2} {N3} {D3} {M3}
	forall {A:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) (map/+ N3 D3 M3)}
	exists {G1:ge N3 N1} {G2:ge N3 N2}
	true.

- : intersection-implies-ge (intersection/= _ _ nat`eq/) (ge/= nat`eq/) (ge/= nat`eq/).

- : intersection-implies-ge (intersection/< (shift/+ N1+1+N3=N4) M1*M022=M333 N0+1+N1=N2)
                    (ge/> N4>N1) N4>=N2
    <- plus-swap-succ N1+1+N3=N4 N1+N3+1=N4
    <- plus-commutative N1+N3+1=N4 N3+1+N1=N4
    <- plus-implies-gt N3+1+N1=N4 nat`eq/ N4>N1
    <- intersection-implies-ge M1*M022=M333 _ N3>=N0
    <- succ-preserves-ge N3>=N0 N3+1>=N0+1
    <- plus-right-preserves-ge* N3+1>=N0+1 N3+1+N1=N4 N0+1+N1=N2 N4>=N2.

- : intersection-implies-ge (intersection/> (shift/+ N2+1+N3=N5) M011*M2=M333 N0+1+N2=N1)
                    N5>=N1 (ge/> N5>N2)
    <- plus-swap-succ N2+1+N3=N5 N2+N3+1=N5
    <- plus-commutative N2+N3+1=N5 N3+1+N2=N5
    <- plus-implies-gt N3+1+N2=N5 nat`eq/ N5>N2
    <- intersection-implies-ge M011*M2=M333 N3>=N0 _
    <- succ-preserves-ge N3>=N0 N3+1>=N0+1
    <- plus-right-preserves-ge* N3+1>=N0+1 N3+1+N2=N5 N0+1+N2=N1 N5>=N1.

%worlds () (intersection-implies-ge _ _ _).
%total (A) (intersection-implies-ge A _ _).


%theorem intersection-empty-implies-disjoint :
	forall* {M1} {M2}
	forall	{A: intersection M1 M2 map/0}
	exists	{D: disjoint M1 M2}
	true.

- : intersection-empty-implies-disjoint (intersection/L) (disjoint/L).

- : intersection-empty-implies-disjoint (intersection/R) (disjoint/R).

- : intersection-empty-implies-disjoint (intersection/< shift/0 A P) (disjoint/< D P)
    <- intersection-empty-implies-disjoint A D.

- : intersection-empty-implies-disjoint (intersection/> shift/0 A P) (disjoint/> D P)
    <- intersection-empty-implies-disjoint A D.

%worlds () (intersection-empty-implies-disjoint _ _).
%total (A) (intersection-empty-implies-disjoint A _).


%theorem intersection-deterministic :
	forall* {M1} {M2} {M3} {M1P} {M2P} {M3P}
	forall {A:intersection M1 M2 M3} {AP:intersection M1P M2P M3P}
               {E1:eq M1 M1P} {E2:eq M2 M2P}
	exists {E3:eq M3 M3P}
	true.

%abbrev intersection-unique = intersection-deterministic.

- : intersection-deterministic intersection/L intersection/L eq/ eq/ eq/.

- : intersection-deterministic intersection/L intersection/R eq/ eq/ eq/.

- : intersection-deterministic intersection/R intersection/L eq/ eq/ eq/.

- : intersection-deterministic intersection/R intersection/R eq/ eq/ eq/.

- : intersection-deterministic (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) 
                       (AP:intersection _ _ MP) eq/ eq/ M133=MP
    <- intersection/=-inversion AP nat`eq/ D3P M3P D1*D2=D3P M1*M2=M3P M133P=MP
    <- unit`intersection-deterministic D1*D2=D3 D1*D2=D3P unit`eq/ unit`eq/ D3=D3P
    <- intersection-deterministic M1*M2=M3 M1*M2=M3P eq/ eq/ M3=M3P
    <- map/+-preserves-eq nat`eq/ D3=D3P M3=M3P M133=M133P
    <- eq-transitive M133=M133P M133P=MP M133=MP.

- : intersection-deterministic (intersection/< M3<<N1=M M1*M022=M3 N0+1+N1=N2)
                       (AP:intersection _ _ MP) eq/ eq/ M=MP
    <- intersection/<-inversion AP N0+1+N1=N2 M3P M1*M022=M3P M3P<<N1=MP
    <- intersection-deterministic M1*M022=M3 M1*M022=M3P eq/ eq/ M3=M3P
    <- shift-deterministic M3<<N1=M M3P<<N1=MP nat`eq/ M3=M3P M=MP.

- : intersection-deterministic (intersection/> M3<<N2=M M311*M2=M3 N3+1+N2=N1) AP eq/ eq/ M=MP
    <- intersection/>-inversion AP N3+1+N2=N1 M3P M311*M2=M3P M3P<<N2=MP
    <- intersection-deterministic M311*M2=M3 M311*M2=M3P eq/ eq/ M3=M3P
    <- shift-deterministic M3<<N2=M M3P<<N2=MP nat`eq/ M3=M3P M=MP.

%worlds () (intersection-deterministic _ _ _ _ _).
%total (A) (intersection-deterministic A _ _ _ _).


%theorem intersection-total* :
	forall {M1} {M2}
	exists {M3} {A:intersection M1 M2 M3}
	true.

%% we need some lemmas
%% We need them to ensure termination because
%% intersection substitutes new maps on recursive calls which
%% makes it hard to prove the arguments get smaller.

%theorem intersection-map/+-M-total* :
	forall {N1} {D1} {M1} {M2}
        exists {M3} {A:intersection (map/+ N1 D1 M1) M2 M3}
	true.

%theorem intersection-M-map/+-total* :
	forall {M1} {N2} {D2} {M2}
        exists {M3} {A:intersection M1 (map/+ N2 D2 M2) M3}
	true.

%theorem intersection-map/+-map/+-total* :
	forall {N1} {D1} {M1} {N2} {D2} {M2} {C} {CMP:nat`compare N1 N2 C}
        exists {M3} 
               {A:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3}
	true.

- : intersection-total* map/0 M map/0 intersection/L.

- : intersection-total* M map/0 map/0 intersection/R.

- : intersection-total* (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3 A
    <- nat`compare-total* N1 N2 C CMP
    <- intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.               

- : intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 equal CMP (map/+ N1 D3 M3)
                           (intersection/= M1*M2=M3 D1*D2=D3 N1=N2)
    <- equal-implies-eq CMP N1=N2
    <- unit`intersection-total* D1 D2 D3 D1*D2=D3
    <- intersection-total* M1 M2 M3 M1*M2=M3.

- : intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 less CMP S1M3
                           (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2)
    <- less-implies-lt CMP N2>N1
    <- gt-implies-plus N2>N1 _ N0+1+N1=N2
    <- intersection-M-map/+-total* M1 N0 D2 M2 M3 M1*M022=M3
    <- shift-total* N1 M3 S1M3 M3<<N1=S1M3.

- : intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 greater CMP S2M3
                           (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1)
    <- greater-implies-gt CMP N1>N2
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- intersection-map/+-M-total* N3 D1 M1 M2 M3 M311*M2=M3
    <- shift-total* N2 M3 S2M3 M3<<N2=S2M3.

- : intersection-M-map/+-total* map/0 N2 D2 M2 map/0 intersection/L.

- : intersection-M-map/+-total* (map/+ N1 D1 M1) N2 D2 M2 M3 A
    <- nat`compare-total* N1 N2 C CMP
    <- intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.

- : intersection-map/+-M-total* N1 D1 M1 map/0 map/0 intersection/R.

- : intersection-map/+-M-total* N1 D1 M1 (map/+ N2 D2 M2) M3 A
    <- nat`compare-total* N1 N2 C CMP
    <- intersection-map/+-map/+-total* N1 D1 M1 N2 D2 M2 C CMP M3 A.

%worlds () (intersection-total* _ _ _ _)
           (intersection-M-map/+-total* _ _ _ _ _ _)
           (intersection-map/+-M-total* _ _ _ _ _ _)
           (intersection-map/+-map/+-total* _ _ _ _ _ _ _ _ _ _).

%total [ (M1a M1b M1c M1d) (M2a M2b M2c M2d) ]
        (intersection-total* M1d M2d _ _)
        (intersection-M-map/+-total* M1c _ _ M2c _ _)
        (intersection-map/+-M-total* _ _ M1b M2b _ _)
	(intersection-map/+-map/+-total* _ _ M1a _ _ M2a _ _ _ _).
               
%abbrev intersection-total = intersection-total* _ _ _.


%theorem disjoint-intersection-empty :
	forall* {M1} {M2}
	forall {D:disjoint M1 M2}
	exists {A:intersection M1 M2 map/0}
	true.

- : disjoint-intersection-empty disjoint/L intersection/L.

- : disjoint-intersection-empty disjoint/R intersection/R.

- : disjoint-intersection-empty (disjoint/< D N0+1+N1=N2)
                        (intersection/< shift/0 M N0+1+N1=N2)
    <- disjoint-intersection-empty D M.

- : disjoint-intersection-empty (disjoint/> D N3+1+N2=N1)
                        (intersection/> shift/0 M N3+1+N2=N1)
    <- disjoint-intersection-empty D M.

%worlds () (disjoint-intersection-empty _ _).
%total (D) (disjoint-intersection-empty D _).


%theorem intersection-commutative :
	forall* {M1} {M2} {M3}
	forall {A:intersection M1 M2 M3}
	exists {AP:intersection M2 M1 M3}
	true.

- : intersection-commutative intersection/L intersection/R.

- : intersection-commutative intersection/R intersection/L.

- : intersection-commutative (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) 
                     (intersection/= M2*M1=M3 D2*D1=D3 nat`eq/)
    <- unit`intersection-commutative D1*D2=D3 D2*D1=D3
    <- intersection-commutative M1*M2=M3 M2*M1=M3.

- : intersection-commutative (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2) 
                     (intersection/> M3<<N1=S1M3 M022*M1=M3 N0+1+N1=N2)
    <- intersection-commutative M1*M022=M3 M022*M1=M3.

- : intersection-commutative (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1) 
                     (intersection/< M3<<N2=S2M3 M2*M311=M3 N3+1+N2=N1)
    <- intersection-commutative M311*M2=M3 M2*M311=M3.

%worlds () (intersection-commutative _ _).
%total (A) (intersection-commutative A _).


%theorem shift-left-preserves-intersection :
	forall* {N} {D} {M1} {M2} {M3} {SM1} {SM3}
	forall {A:intersection M1 M2 M3} {S1:shift N M1 SM1} {S3:shift N M3 SM3}
        exists {SA:intersection SM1 (map/+ N D M2) SM3}
        true.

- : shift-left-preserves-intersection Z*M2=M3 shift/0 M3<<N=SM3 Z*M222=SM3
    <- intersection/L-inversion Z*M2=M3 eq/ Z=M3
    <- shift-deterministic shift/0 M3<<N=SM3 nat`eq/ Z=M3 Z=SM3
    <- intersection-respects-eq intersection/L eq/ eq/ Z=SM3 Z*M222=SM3.

- : shift-left-preserves-intersection M111*M2=M3 (shift/+ N+1+N1=N1P) M3<<N=SM3
                              (intersection/> M3<<N=SM3 M111*M2=M3 N1+1+N=N1P)
    <- plus-swap-succ N+1+N1=N1P N+N1+1=N1P
    <- plus-commutative N+N1+1=N1P N1+1+N=N1P.

%worlds () (shift-left-preserves-intersection _ _ _ _).
%total { } (shift-left-preserves-intersection _ _ _ _).


%theorem shift-left-preserves-intersection-converse :
	forall* {N} {D} {M1} {M2} {SM1} {SM3}
	forall {SA:intersection SM1 (map/+ N D M2) SM3} {S1:shift N M1 SM1}
        exists {M3} {A:intersection M1 M2 M3} {S3:shift N M3 SM3}
	true.

- : shift-left-preserves-intersection-converse Z*M222=SM3 shift/0 map/0 intersection/L Z<<N=SM3
    <- intersection/L-inversion Z*M222=SM3 eq/ Z=SM3
    <- shift-respects-eq shift/0 nat`eq/ eq/ Z=SM3 Z<<N=SM3.

- : shift-left-preserves-intersection-converse M111*M222=SM3 (shift/+ N2+1+N3=N1) M3
                                       M311*M2=M3 M3<<N2=SM3
    <- plus-swap-succ N2+1+N3=N1 N2+N3+1=N1
    <- plus-commutative N2+N3+1=N1 N3+1+N2=N1
    <- intersection/>-inversion M111*M222=SM3 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=SM3.

%worlds () (shift-left-preserves-intersection-converse _ _ _ _ _).
%total { } (shift-left-preserves-intersection-converse _ _ _ _ _).


%theorem shift-right-preserves-intersection :
	forall* {N} {D} {M1} {M2} {M3} {SM2} {SM3}
	forall {A:intersection M1 M2 M3} {S2:shift N M2 SM2} {S3:shift N M3 SM3}
        exists {SA:intersection (map/+ N D M1) SM2 SM3}
	true.

- : shift-right-preserves-intersection M1*0=M3 shift/0 M3<<N=SM3 M111*0=SM3
    <- intersection/R-inversion M1*0=M3 eq/ Z=M3
    <- shift-deterministic shift/0 M3<<N=SM3 nat`eq/ Z=M3 Z=SM3
    <- intersection-respects-eq intersection/R eq/ eq/ Z=SM3 M111*0=SM3.

- : shift-right-preserves-intersection M1*M222=M3 (shift/+ N+1+N2=N2P) M3<<N=SM3
                               (intersection/< M3<<N=SM3 M1*M222=M3 N2+1+N=N2P)
    <- plus-swap-succ N+1+N2=N2P N+N2+1=N2P
    <- plus-commutative N+N2+1=N2P N2+1+N=N2P.

%worlds () (shift-right-preserves-intersection _ _ _ _).
%total { } (shift-right-preserves-intersection _ _ _ _).


%theorem shift-right-preserves-intersection-converse :
	forall* {N} {D} {M1} {M2} {SM2} {SM3}
	forall {SA:intersection (map/+ N D M1) SM2 SM3} {S2:shift N M2 SM2}
        exists {M3} {A:intersection M1 M2 M3} {S3:shift N M3 SM3}
	true.

- : shift-right-preserves-intersection-converse M*0=SM3 shift/0 map/0 intersection/R Z<<N=SM3
    <- intersection/R-inversion M*0=SM3 eq/ Z=SM3
    <- shift-respects-eq shift/0 nat`eq/ eq/ Z=SM3 Z<<N=SM3.

- : shift-right-preserves-intersection-converse M111*M322=SM3 (shift/+ N1+1+N2=N3)
                                        M3 M1*M222=M3 M3<<N1=SM3
    <- plus-swap-succ N1+1+N2=N3 N1+N2+1=N3
    <- plus-commutative N1+N2+1=N3 N2+1+N1=N3
    <- intersection/<-inversion M111*M322=SM3 N2+1+N1=N3 M3 M1*M222=M3 M3<<N1=SM3.

%worlds () (shift-right-preserves-intersection-converse _ _ _ _ _).
%total { } (shift-right-preserves-intersection-converse _ _ _ _ _).


%theorem shift-preserves-intersection* :
	forall* {N} {M1} {M2} {M3} {SM1} {SM2} {SM3}
	forall {A:intersection M1 M2 M3} 
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} {S3:shift N M3 SM3}
	exists {SA:intersection SM1 SM2 SM3}
	true.

- : shift-preserves-intersection* Z*M2=M3 shift/0 _ M3<<N=SM3 Z*SM2=SM3
    <- intersection/L-inversion Z*M2=M3 eq/ Z=M3
    <- shift-deterministic shift/0 M3<<N=SM3 nat`eq/ Z=M3 Z=SM3
    <- intersection-respects-eq intersection/L eq/ eq/ Z=SM3 Z*SM2=SM3.

- : shift-preserves-intersection* M1*0=M3 _ shift/0 M3<<N=SM3 SM1*0=SM3
    <- intersection/R-inversion M1*0=M3 eq/ Z=M3
    <- shift-deterministic shift/0 M3<<N=SM3 nat`eq/ Z=M3 Z=SM3
    <- intersection-respects-eq intersection/R eq/ eq/ Z=SM3 SM1*0=SM3.

- : shift-preserves-intersection* (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) 
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N1=N5) 
                          (shift/+ N+1+N1=N6)
                          M411*M522=M633
    <- plus-deterministic N+1+N1=N4 N+1+N1=N5 nat`eq/ nat`eq/ N4=N5
    <- plus-deterministic N+1+N1=N4 N+1+N1=N6 nat`eq/ nat`eq/ N4=N6
    <- map/+-preserves-eq N4=N6 unit`eq/ eq/ M433=M633
    <- intersection-respects-eq (intersection/= M1*M2=M3 D1*D2=D3 N4=N5) eq/ eq/ M433=M633
                        M411*M522=M633.

- : shift-preserves-intersection* (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2)
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) S1M3<<N=SS1M3
                          (intersection/< M3<<N4=SS1M3 M1*M022=M3 N0+1+N4=N5)
    <- plus-swap-succ N+1+N1=N4 N+N1+1=N4
    <- plus-commutative N+N1+1=N4 N1+1+N=N4
    <- shifts-add M3<<N1=S1M3 S1M3<<N=SS1M3 N1+1+N=N4 M3<<N4=SS1M3
    <- plus-commutative N0+1+N1=N2 N1+N0+1=N2
    <- plus-associative-converse* N1+N0+1=N2 N+1+N2=N5 N+1+N1=N4 N4+N0+1=N5
    <- plus-commutative N4+N0+1=N5 N0+1+N4=N5.

- : shift-preserves-intersection* (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1)
                          (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) S2M3<<N=SS2M3
                          (intersection/> M3<<N5=SS2M3 M311*M2=M3 N3+1+N5=N4)
    <- plus-swap-succ N+1+N2=N5 N+N2+1=N5
    <- plus-commutative N+N2+1=N5 N2+1+N=N5
    <- shifts-add M3<<N2=S2M3 S2M3<<N=SS2M3 N2+1+N=N5 M3<<N5=SS2M3
    <- plus-commutative N3+1+N2=N1 N2+N3+1=N1
    <- plus-associative-converse* N2+N3+1=N1 N+1+N1=N4 N+1+N2=N5 N5+N3+1=N4
    <- plus-commutative N5+N3+1=N4 N3+1+N5=N4.

%worlds () (shift-preserves-intersection* _ _ _ _ _).
%total { } (shift-preserves-intersection* _ _ _ _ _).


%theorem shift-preserves-intersection-converse :
	forall* {N} {M1} {M2} {SM1} {SM2} {SM3}
	forall {SA:intersection SM1 SM2 SM3}
               {S1:shift N M1 SM1} {S2:shift N M2 SM2} 
	exists {M3} {A:intersection M1 M2 M3} {S3:shift N M3 SM3}
	true.

- : shift-preserves-intersection-converse Z*SM2=SM3 shift/0 _ map/0 intersection/L Z<<N=SM3
    <- intersection/L-inversion Z*SM2=SM3 eq/ Z=SM3
    <- shift-respects-eq shift/0 nat`eq/ eq/ Z=SM3 Z<<N=SM3.

- : shift-preserves-intersection-converse SM1*0=SM3 _ shift/0 map/0 intersection/R Z<<N=SM3
    <- intersection/R-inversion SM1*0=SM3 eq/ Z=SM3
    <- shift-respects-eq shift/0 nat`eq/ eq/ Z=SM3 Z<<N=SM3.

- : shift-preserves-intersection-converse (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) 
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N1P=N4)
                                  (map/+ N1 D3 M3) M111*M122P=M133
                                  (shift/+ N+1+N1=N4)
    <- plus-left-cancels N+1+N1=N4 N+1+N1P=N4 nat`eq/ nat`eq/ N1=N1P
    <- map/+-preserves-eq N1=N1P unit`eq/ eq/ M122=M122P
    <- intersection-respects-eq (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) eq/ M122=M122P eq/
                        M111*M122P=M133.

- : shift-preserves-intersection-converse (intersection/< M3<<N4=S4M3 M1*M055=M3 N0+1+N4=N5)
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) S1M3
				  (intersection/< M3<<N1=S1M3 M1*M055=M3 N0+1+N1=N2)
				  S1M3<<N=S4M3
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-swap-succ-converse N1+N+1=N4 N1+1+N=N4
    <- shifts-add-converse M3<<N4=S4M3 N1+1+N=N4 S1M3 M3<<N1=S1M3 S1M3<<N=S4M3
    <- plus-associative-converse N1+N+1=N4 N0+1+N4=N5 N2P N0+1+N1=N2P N2P+N+1=N5
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-right-cancels N2P+N+1=N5 N2+N+1=N5 nat`eq/ nat`eq/ N2P=N2
    <- plus-respects-eq N0+1+N1=N2P nat`eq/ nat`eq/ N2P=N2 N0+1+N1=N2.
                                  
- : shift-preserves-intersection-converse (intersection/> M3<<N5=S5M3 M611*M2=M3 N6+1+N5=N4)
                                  (shift/+ N+1+N1=N4) (shift/+ N+1+N2=N5) S2M3
                                  (intersection/> M3<<N2=S2M3 M611*M2=M3 N6+1+N2=N1)
                                  S2M3<<N=S5M3
    <- plus-commutative N+1+N2=N5 N2+N+1=N5
    <- plus-swap-succ-converse N2+N+1=N5 N2+1+N=N5
    <- shifts-add-converse M3<<N5=S5M3 N2+1+N=N5 S2M3 M3<<N2=S2M3 S2M3<<N=S5M3
    <- plus-associative-converse N2+N+1=N5 N6+1+N5=N4 N1P N6+1+N2=N1P N1P+N+1=N4
    <- plus-commutative N+1+N1=N4 N1+N+1=N4
    <- plus-right-cancels N1P+N+1=N4 N1+N+1=N4 nat`eq/ nat`eq/ N1P=N1
    <- plus-respects-eq N6+1+N2=N1P nat`eq/ nat`eq/ N1P=N1 N6+1+N2=N1.

%worlds () (shift-preserves-intersection-converse _ _ _ _ _ _).
%total { } (shift-preserves-intersection-converse _ _ _ _ _ _).


%% We prove associativity by induction over the bound of
%% the first map.  Hence we need to pass the "BOUND" to the theorem
%% (both the actual bound and the fact that it is the bound).
%% Later we define a traditional associativity theorem using this one.

%theorem intersection-associativeM :
	forall* {M1} {M2} {M3} {M4} {M6} {M7}
	forall {B} {BD:bound M1 B}
               {A12:intersection M1 M2 M3} {A34:intersection M3 M4 M7}
	       {A24:intersection M2 M4 M6} 
        exists {A16:intersection M1 M6 M7}
	true.

%theorem intersection-associativeM* :
        forall* {N1} {D1} {M1} {N2} {D2} {M2} {N4} {D4} {M4} {M3} {M6} {M7}
                {C12} {C24} {C14}
	forall {B} {BD:bound (map/+ N1 D1 M1) B}
               {CMP12:nat`compare N1 N2 C12} {CMP24:nat`compare N2 N4 C24}
               {CMP14:nat`compare N1 N4 C14}
               {A12:intersection (map/+ N1 D1 M1) (map/+ N2 D2 M2) M3} 
               {A34:intersection M3 (map/+ N4 D4 M4) M7} 
               {A24:intersection (map/+ N2 D2 M2) (map/+ N4 D4 M4) M6} 
        exists {A16:intersection (map/+ N1 D1 M1) M6 M7}
        true.

%% handle all the cases where M1, M2 or M4 is map/0

- : intersection-associativeM _ _ intersection/L Z*M3=M7 _ Z*M6=M7
    <- intersection/L-inversion Z*M3=M7 eq/ Z=M7
    <- intersection-respects-eq intersection/L eq/ eq/ Z=M7 Z*M6=M7.

- : intersection-associativeM _ _ intersection/R Z*M3=M7 _ M1*0=M7
    <- intersection/L-inversion Z*M3=M7 eq/ Z=M7
    <- intersection-respects-eq intersection/R eq/ eq/ Z=M7 M1*0=M7.

- : intersection-associativeM _ _ _ _ (_:intersection _ _ map/0) intersection/R.

%% now defer the remaining cases to the lemma.

- : intersection-associativeM B BD A12 A34 A24 A16
    <- nat`compare-total CMP12
    <- nat`compare-total CMP24
    <- nat`compare-total CMP14
    <- intersection-associativeM* B BD CMP12 CMP24 CMP14 A12 A34 A24 A16.
 
- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1) 
                       (nat`compare/=) (nat`compare/=) _
                       A12 A34 A24 A16
    <- intersection/=-inversion A12 nat`eq/ D3 M3 D1*D2=D3 M1*M2=M3 M133=M12
    <- eq-symmetric M133=M12 M12=M133
    <- intersection-respects-eq A34 M12=M133 eq/ eq/ A34P
    <- intersection/=-inversion A34P nat`eq/ D7 M7 D3*D4=D7 M3*M4=M7 M177=M34
    <- intersection/=-inversion A24 nat`eq/ D6 M6 D2*D4=D6 M2*M4=M6 M166=M24
    <- unit`intersection-associative* D1*D2=D3 D3*D4=D7 D2*D4=D6 D1*D6=D7
    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1
    <- meta-gt _ _ B>B1
    <- intersection-associativeM _ BD1 M1*M2=M3 M3*M4=M7 M2*M4=M6 M1*M6=M7
    <- intersection-respects-eq (intersection/= M1*M6=M7 D1*D6=D7 nat`eq/) 
                        eq/ M166=M24 M177=M34 A16.

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1) 
                       (nat`compare/=) (nat`compare/< N4>N1) _
                       A12 A34 A24 A16
    <- intersection/=-inversion A12 nat`eq/ D3 M3 D1*D2=D3 M1*M2=M3 M133=M12
    <- eq-symmetric M133=M12 M12=M133
    <- intersection-respects-eq A34 M12=M133 eq/ eq/ A34P
    <- gt-implies-plus N4>N1 N5 N5+1+N1=N4 
    <- intersection/<-inversion A34P N5+1+N1=N4 M7 M3*M544=M7 M7<<N3=M34
    <- intersection/<-inversion A24  N5+1+N1=N4 M6 M2*M544=M6 M6<<N3=M24
    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1
    <- meta-gt _ _ B>B1
    <- intersection-associativeM _ BD1 M1*M2=M3 M3*M544=M7 M2*M544=M6 M1*M6=M7
    <- shift-right-preserves-intersection M1*M6=M7 M6<<N3=M24 M7<<N3=M34 A16.

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)
                       (nat`compare/=) (nat`compare/> N1>N4) _
                       A12 A34 A24 A16
    <- intersection/=-inversion A12 nat`eq/ D3 M3 D1*D2=D3 M1*M2=M3 M133=M12
    <- eq-symmetric M133=M12 M12=M133
    <- intersection-respects-eq A34 M12=M133 eq/ eq/ A34P
    <- gt-implies-plus N1>N4 N6 N6+1+N4=N1     %% NB N2 eq N1
    <- intersection/>-inversion A34P N6+1+N4=N1 M7 M633*M4=M7 M7<<N4=M34
    <- intersection/>-inversion A24  N6+1+N4=N1 M6 M622*M4=M6 M6<<N4=M24
    <- plus-swap-succ N6+1+N4=N1 N6+N4+1=N1
    <- plus-commutative N6+N4+1=N1 N4+1+N6=N1
    <- plus-implies-gt N4+1+N6=N1 nat`eq/ N1>N6
    <- succ-preserves-gt N1>N6 N1+1>N6+1
    <- plus-total N6+1+B1=B6
    <- plus-right-preserves-gt* N1+1>N6+1  N1+1+B1=B N6+1+B1=B6 B>B6
    <- meta-gt _ _ B>B6
    <- intersection-associativeM _ (bound/+ N6+1+B1=B6 BD1)
                         (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)
                         M633*M4=M7 M622*M4=M6 M611*M6=M7
    <- shift-preserves-intersection* M611*M6=M7 
                             (shift/+ N4+1+N6=N1) M6<<N4=M24 M7<<N4=M34 A16.

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)
                       (nat`compare/< N2>N1) (nat`compare/=) _
                       A12 A34 A24 A16
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- intersection/<-inversion A12 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M12
    <- intersection/=-inversion A24 nat`eq/ D6 M6 D2*D4=D6 M2*M4=M6 M266=M24
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- shift-preserves-intersection-converse A34 M3<<N1=M12 (shift/+ N1+1+N0=N2)
                                     M7 M3*M044=M7 M7<<N1=M34
    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1
    <- meta-gt _ _ B>B1
    <- intersection-associativeM _ BD1 M1*M022=M3 M3*M044=M7 
                         (intersection/= M2*M4=M6 D2*D4=D6 nat`eq/) 
                         M1*M066=M7
    <- shift-right-preserves-intersection M1*M066=M7 (shift/+ N1+1+N0=N2) M7<<N1=M34
                                  M111*M266=M34
    <- intersection-respects-eq M111*M266=M34 eq/ M266=M24 eq/ A16.

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)
                       (nat`compare/> N1>N2) (nat`compare/=) _
                       A12 A34 A24 A16
    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1
    <- intersection/>-inversion A12 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=M12
    <- intersection/=-inversion A24 nat`eq/ D6 M6 D2*D4=D6 M2*M4=M6 M266=M24
    <- shift-left-preserves-intersection-converse A34 M3<<N2=M12 M7 M3*M4=M7 M7<<N2=M34
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- plus-implies-gt N2+1+N3=N1 nat`eq/ N1>N3
    <- succ-preserves-gt N1>N3 N1+1>N3+1
    <- plus-total N3+1+B1=B3
    <- plus-right-preserves-gt* N1+1>N3+1  N1+1+B1=B N3+1+B1=B3 B>B3
    <- meta-gt _ _ B>B3
    <- intersection-associativeM _ (bound/+ N3+1+B1=B3 BD1) 
                         M311*M2=M3 M3*M4=M7 M2*M4=M6 M311*M6=M7
    <- intersection-respects-eq (intersection/> M7<<N2=M34 M311*M6=M7 N3+1+N2=N1) 
                        eq/ M266=M24 eq/ A16.

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)
                       (nat`compare/< N2>N1) _ (nat`compare/=)
                       A12 A34 A24 A16
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- intersection/<-inversion A12 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M12
    <- shift-left-preserves-intersection-converse A34 M3<<N1=M12 M7 M3*M4=M7 M7<<N1=M34
    <- intersection/>-inversion A24 N0+1+N1=N2 M6 M022*M4=M6 M6<<N1=M24
    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1
    <- meta-gt _ _ B>B1
    <- intersection-associativeM _ BD1 M1*M022=M3 M3*M4=M7 M022*M4=M6 M1*M6=M7
    <- shift-right-preserves-intersection M1*M6=M7 M6<<N1=M24 M7<<N1=M34 A16.

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)
                       (nat`compare/> N1>N2) _ (nat`compare/=)
                       A12 A34 A24 A16
    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- intersection/>-inversion A12 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=M12
    <- shift-preserves-intersection-converse A34 M3<<N2=M12 (shift/+ N2+1+N3=N1) 
                                     M7 M3*M344=M7 M7<<N2=M34
    <- intersection/<-inversion A24 N3+1+N2=N1 M6 M2*M344=M6 M6<<N2=M24
    <- plus-implies-gt N2+1+N3=N1 nat`eq/ N1>N3
    <- succ-preserves-gt N1>N3 N1+1>N3+1
    <- plus-total N3+1+B1=B3
    <- plus-right-preserves-gt* N1+1>N3+1  N1+1+B1=B N3+1+B1=B3 B>B3
    <- meta-gt _ _ B>B3
    <- intersection-associativeM _ (bound/+ N3+1+B1=B3 BD1)
                         M311*M2=M3 M3*M344=M7 M2*M344=M6 M311*M6=M7
    <- shift-preserves-intersection* M311*M6=M7 (shift/+ N2+1+N3=N1) M6<<N2=M24 
                             M7<<N2=M34 A16.

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)
                       (nat`compare/< N2>N1) (nat`compare/< N4>N2) _
                       A12 A34 A24 A16
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- intersection/<-inversion A12 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M12
    <- gt-implies-plus N4>N2 N6 N6+1+N2=N4
    <- intersection/<-inversion A24 N6+1+N2=N4 M6 M2*M644=M6 M6<<N2=M24
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N6+1+N2=N4 
                                 N7 N6+1+N0=N7 N7+N1+1=N4
    <- plus-commutative N7+N1+1=N4 N1+1+N7=N4
    <- plus-swap-succ-converse N7+N1+1=N4 N7+1+N1=N4
    <- shift-preserves-intersection-converse A34 M3<<N1=M12 (shift/+ N1+1+N7=N4)
                                     M7 M3*M744=M7 M7<<N1=M34
    <- shifts-add-converse M6<<N2=M24 N0+1+N1=N2 S0M6 M6<<N0=S0M6 S0M6<<N1=M24
    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1
    <- meta-gt _ _ B>B1
    <- intersection-associativeM _ BD1 M1*M022=M3 M3*M744=M7 
                         (intersection/< M6<<N0=S0M6 M2*M644=M6 N6+1+N0=N7)
                         M1*S0M6=M7
    <- shift-right-preserves-intersection M1*S0M6=M7 S0M6<<N1=M24 M7<<N1=M34 A16.
                         

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)
                       (nat`compare/> N1>N2) (nat`compare/> N2>N4) _
                       A12 A34 A24 A16
    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1
    <- intersection/>-inversion A12 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=M12
    <- gt-implies-plus N2>N4 N6 N6+1+N4=N2
    <- intersection/>-inversion A24 N6+1+N4=N2 M6 M622*M4=M6 M6<<N4=M24
    <- shifts-add-converse M3<<N2=M12 N6+1+N4=N2 S6M3 M3<<N6=S6M3 S6M3<<N4=M12
    <- shift-left-preserves-intersection-converse A34 S6M3<<N4=M12 
                                          M7 S6M3*M4=M7 M7<<N4=M34
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 N9 N3+1+N6=N9 N9+N4+1=N1
    <- plus-swap-succ N3+1+N6=N9 N3+N6+1=N9
    <- plus-commutative N3+N6+1=N9 N6+1+N3=N9
    <- shift-left-preserves-intersection M311*M2=M3 (shift/+ N6+1+N3=N9) M3<<N6=S6M3
                                 M911*M622=S6M3
    <- plus-commutative N9+N4+1=N1 N4+1+N9=N1
    <- plus-implies-gt N4+1+N9=N1 nat`eq/ N1>N9
    <- succ-preserves-gt N1>N9 N1+1>N9+1
    <- plus-total N9+1+B1=B9
    <- plus-right-preserves-gt* N1+1>N9+1  N1+1+B1=B N9+1+B1=B9 B>B9
    <- meta-gt _ _ B>B9
    <- intersection-associativeM _ (bound/+ N9+1+B1=B9 BD1)
                         M911*M622=S6M3 S6M3*M4=M7 M622*M4=M6 M911*M6=M7
    <- shift-preserves-intersection* M911*M6=M7 (shift/+ N4+1+N9=N1) 
                             M6<<N4=M24 M7<<N4=M34 A16.

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)
                       _ (nat`compare/> N2>N4) (nat`compare/< N4>N1)
                       A12 A34 A24 A16
    <- gt-implies-plus N2>N4 N6 N6+1+N4=N2
    <- gt-implies-plus N4>N1 N5 N5+1+N1=N4
    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 N0 N6+1+N5=N0 N0+N1+1=N2
    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2
    <- intersection/<-inversion A12 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M12
    <- intersection/>-inversion A24 N6+1+N4=N2 M6 M622*M4=M6 M6<<N4=M24
    <- plus-commutative N5+N1+1=N4 N1+1+N5=N4
    <- shift-preserves-intersection-converse A34 M3<<N1=M12 (shift/+ N1+1+N5=N4)
                                     M7 M3*M544=M7 M7<<N1=M34
    <- shifts-add-converse M6<<N4=M24 N5+1+N1=N4 S5M6 M6<<N5=S5M6 S5M6<<N1=M24
    <- plus-swap-succ N6+1+N5=N0 N6+N5+1=N0
    <- plus-commutative N6+N5+1=N0 N5+1+N6=N0
    <- shift-left-preserves-intersection M622*M4=M6 (shift/+ N5+1+N6=N0) M6<<N5=S5M6
                                 M022*M544=S5M6
    <- plus-implies-gt N1+1+B1=B nat`eq/ B>B1
    <- meta-gt _ _ B>B1
    <- intersection-associativeM _ BD1 M1*M022=M3 M3*M544=M7 M022*M544=S5M6 M1*S5M6=M7
    <- shift-right-preserves-intersection M1*S5M6=M7 S5M6<<N1=M24 M7<<N1=M34 A16.

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)
                       _ (nat`compare/< N4>N2) (nat`compare/> N1>N4)
                       A12 A34 A24 A16
    <- gt-implies-plus N4>N2 N6 N6+1+N2=N4
    <- gt-implies-plus N1>N4 N5 N5+1+N4=N1
    <- plus-swap-succ N6+1+N2=N4 N6+N2+1=N4
    <- plus-associative-converse N6+N2+1=N4 N5+1+N4=N1 N3 N5+1+N6=N3 N3+N2+1=N1
    <- plus-swap-succ-converse N3+N2+1=N1 N3+1+N2=N1
    <- intersection/>-inversion A12 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=M12
    <- intersection/<-inversion A24 N6+1+N2=N4 M6 M2*M644=M6 M6<<N2=M24
    <- plus-commutative N6+N2+1=N4 N2+1+N6=N4
    <- shift-preserves-intersection-converse A34 M3<<N2=M12 (shift/+ N2+1+N6=N4)
                                     M7 M3*M644=M7 M7<<N2=M34
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- plus-implies-gt N2+1+N3=N1 nat`eq/ N1>N3
    <- succ-preserves-gt N1>N3 N1+1>N3+1
    <- plus-total N3+1+B1=B3
    <- plus-right-preserves-gt* N1+1>N3+1  N1+1+B1=B N3+1+B1=B3 B>B3
    <- meta-gt _ _ B>B3
    <- intersection-associativeM _ (bound/+ N3+1+B1=B3 BD1)
                         M311*M2=M3 M3*M644=M7 M2*M644=M6 M311*M6=M7
    <- shift-preserves-intersection* M311*M6=M7 (shift/+ N2+1+N3=N1) M6<<N2=M24 
                             M7<<N2=M34 A16.

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)
                       (nat`compare/> N1>N2) _ (nat`compare/< N4>N1)
                       A12 A34 A24 A16
    <- gt-implies-plus N1>N2 N3 N3+1+N2=N1
    <- gt-implies-plus N4>N1 N5 N5+1+N1=N4
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N5+1+N1=N4 N6 N5+1+N3=N6 N6+N2+1=N4
    <- plus-swap-succ-converse N6+N2+1=N4 N6+1+N2=N4
    <- intersection/>-inversion A12 N3+1+N2=N1 M3 M311*M2=M3 M3<<N2=M12
    <- intersection/<-inversion A24 N6+1+N2=N4 M6 M2*M644=M6 M6<<N2=M24
    <- plus-commutative N6+N2+1=N4 N2+1+N6=N4
    <- shift-preserves-intersection-converse A34 M3<<N2=M12 (shift/+ N2+1+N6=N4)
                                     M7 M3*M644=M7 M7<<N2=M34
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- plus-implies-gt N2+1+N3=N1 nat`eq/ N1>N3
    <- succ-preserves-gt N1>N3 N1+1>N3+1
    <- plus-total N3+1+B1=B3
    <- plus-right-preserves-gt* N1+1>N3+1  N1+1+B1=B N3+1+B1=B3 B>B3
    <- meta-gt _ _ B>B3
    <- intersection-associativeM _ (bound/+ N3+1+B1=B3 BD1)
                         M311*M2=M3 M3*M644=M7 M2*M644=M6 M311*M6=M7
    <- shift-preserves-intersection* M311*M6=M7 (shift/+ N2+1+N3=N1) M6<<N2=M24 
                             M7<<N2=M34 A16.

- : intersection-associativeM* B (bound/+ N1+1+B1=B BD1)
                       (nat`compare/< N2>N1) _ (nat`compare/> N1>N4)
                       A12 A34 A24 A16
    <- gt-implies-plus N2>N1 N0 N0+1+N1=N2
    <- gt-implies-plus N1>N4 N5 N5+1+N4=N1
    <- plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 N6 N0+1+N5=N6 N6+N4+1=N2
    <- plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2
    <- intersection/<-inversion A12 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M12
    <- intersection/>-inversion A24 N6+1+N4=N2 M6 M622*M4=M6 M6<<N4=M24
    <- shifts-add-converse M3<<N1=M12 N5+1+N4=N1 S5M3 M3<<N5=S5M3 S5M3<<N4=M12
    <- shift-left-preserves-intersection-converse A34 S5M3<<N4=M12
                                          M7 S5M3*M4=M7 M7<<N4=M34
    <- plus-swap-succ N0+1+N5=N6 N0+N5+1=N6
    <- plus-commutative N0+N5+1=N6 N5+1+N0=N6
    <- shift-right-preserves-intersection M1*M022=M3 (shift/+ N5+1+N0=N6) M3<<N5=S5M3
                                  M511*M622=S5M3
    <- plus-commutative N5+N4+1=N1 N4+1+N5=N1
    <- plus-implies-gt N4+1+N5=N1 nat`eq/ N1>N5
    <- succ-preserves-gt N1>N5 N1+1>N5+1
    <- plus-total N5+1+B1=B5
    <- plus-right-preserves-gt* N1+1>N5+1  N1+1+B1=B N5+1+B1=B5 B>B5
    <- meta-gt _ _ B>B5
    <- intersection-associativeM _ (bound/+ N5+1+B1=B5 BD1)
                         M511*M622=S5M3 S5M3*M4=M7 M622*M4=M6 M511*M6=M7
    <- shift-preserves-intersection* M511*M6=M7 (shift/+ N4+1+N5=N1) 
                             M6<<N4=M24 M7<<N4=M34 A16.

%worlds () (intersection-associativeM _ _ _ _ _ _) 
           (intersection-associativeM* _ _ _ _ _ _ _ _ _).

%total (S SP) (intersection-associativeM* SP _ _ _ _ _ _ _ _)
              (intersection-associativeM S _ _ _ _ _) .


%theorem intersection-associative :
	forall* {M1} {M2} {M3} {M4} {M7}
	forall {A12:intersection M1 M2 M3} {A34:intersection M3 M4 M7}
        exists {M6} {A24:intersection M2 M4 M6} 
               {A16:intersection M1 M6 M7}
	true.

- : intersection-associative A12 A34 _ A24 A16
    <- bound-total BD
    <- intersection-total A24
    <- intersection-associativeM _ BD A12 A34 A24 A16.

%worlds () (intersection-associative _ _ _ _ _).
%total { } (intersection-associative _ _ _ _ _).



%theorem intersection-associative* :
	forall* {X1} {X2} {X12} {X3} {X23} {X123}
        forall {OP12:intersection X1 X2 X12} {OP12-3:intersection X12 X3 X123} {OP23:intersection X2 X3 X23}
        exists {OP1-23:intersection X1 X23 X123}
        true.

- : intersection-associative* X1*X2=X3 X3*X4=X7 X2*X4=X6 X1*X6=X7
    <- intersection-associative X1*X2=X3 X3*X4=X7 Y6 X2*X4=Y6 X1*Y6=X7
    <- intersection-unique X2*X4=Y6 X2*X4=X6 eq/ eq/ Y6=X6
    <- intersection-respects-eq X1*Y6=X7 eq/ Y6=X6 eq/ X1*X6=X7.

%worlds () (intersection-associative* _ _ _ _).
%total {} (intersection-associative* _ _ _ _).


%theorem intersection-associative-converse :
	forall* {X1} {X2} {X4} {X6} {X7}
	forall {OP24:intersection X2 X4 X6} {OP16:intersection X1 X6 X7}
        exists {X3} {OP12:intersection X1 X2 X3} {OP34:intersection X3 X4 X7}
        true.

- : intersection-associative-converse X2*X4=X6 X1*X6=X7 _ X1*X2=X3 X3*X4=X7
    <- intersection-commutative X2*X4=X6 X4*X2=X6
    <- intersection-commutative X1*X6=X7 X6*X1=X7
    <- intersection-associative X4*X2=X6 X6*X1=X7 _ X2*X1=X3 X4*X3=X7
    <- intersection-commutative X2*X1=X3 X1*X2=X3
    <- intersection-commutative X4*X3=X7 X3*X4=X7.

%worlds () (intersection-associative-converse X2*X4=X6 X1*X6=X7 X3 X1*X2=X3 X3*X4=X7).
%total {} (intersection-associative-converse _ _ _ _ _).


%theorem intersection-associative-converse* :
	forall* {X1} {X2} {X3} {X4} {X6} {X7}
	forall {OP24:intersection X2 X4 X6} {OP16:intersection X1 X6 X7} {OP12:intersection X1 X2 X3} 
	exists {OP34:intersection X3 X4 X7}
        true.

- : intersection-associative-converse* X2*X4=X6 X1*X6=X7 X1*X2=X3 X3*X4=X7
    <- intersection-associative-converse X2*X4=X6 X1*X6=X7 X3P X1*X2=X3P X3P*X4=X7
    <- intersection-unique X1*X2=X3P X1*X2=X3 eq/ eq/ X3P=X3
    <- intersection-respects-eq X3P*X4=X7 X3P=X3 eq/ eq/ X3*X4=X7.

%worlds () (intersection-associative-converse* X2*X4=X6 X1*X6=X7 X1*X2=X3 %{=>}% X3*X4=X7).
%total {} (intersection-associative-converse* _ _ _ _).


%theorem intersection-assoc-commutative* :
	forall* {X1} {X2} {X3} {X4} {X5} {X7}
	forall {OP1:intersection X1 X2 X3} {OP2:intersection X3 X4 X7}
               {OP3:intersection X1 X4 X5} 
        exists {OP4:intersection X5 X2 X7}
	true.

- : intersection-assoc-commutative* X1*X2=X3 X3*X4=X7 X1*X4=X5 X5*X2=X7
    <- intersection-associative X1*X2=X3 X3*X4=X7 X6 X2*X4=X6 X1*X6=X7
    <- intersection-commutative X2*X4=X6 X4*X2=X6
    <- intersection-associative-converse* X4*X2=X6 X1*X6=X7 X1*X4=X5 X5*X2=X7.

%worlds () (intersection-assoc-commutative* X1*X2=X3 X3*X4=X7 X1*X4=X5 %{=>}% X5*X2=X7).
%total {} (intersection-assoc-commutative* _ _ _ _).


%theorem intersection-assoc-commutative :
	forall* {X1} {X2} {X3} {X4} {X7}
	forall {OP1:intersection X1 X2 X3} {OP2:intersection X3 X4 X7}
        exists {X5} {OP3:intersection X1 X4 X5} {OP4:intersection X5 X2 X7}
	true.

- : intersection-assoc-commutative X1*X2=X3 X3*X4=X7 X5 X1*X4=X5 X5*X2=X7
    <- intersection-associative X1*X2=X3 X3*X4=X7 X6 X2*X4=X6 X1*X6=X7
    <- intersection-commutative X2*X4=X6 X4*X2=X6
    <- intersection-associative-converse X4*X2=X6 X1*X6=X7 X5 X1*X4=X5 X5*X2=X7.

%worlds () (intersection-assoc-commutative X1*X2=X3 X3*X4=X7 %{=>}% X5 X1*X4=X5 X5*X2=X7).
%total {} (intersection-assoc-commutative _ _ _ _ _).


%theorem intersection-double-associative* :
	forall* {A} {B} {C} {D} {A+B} {C+D} {A+C} {B+D} {X}
	forall {AB:intersection A B A+B} {CD:intersection C D C+D} {ABCD:intersection A+B C+D X}
	       {AC:intersection A C A+C} {BD:intersection B D B+D} 
        exists {ACBD:intersection A+C B+D X}
	true.

- : intersection-double-associative* X1*X2=X3 X4*X8=XC X3*XC=XF X1*X4=X5 X2*X8=XA X5*XA=XF
    <- intersection-associative X1*X2=X3 X3*XC=XF XE X2*XC=XE X1*XE=XF
    <- intersection-commutative X4*X8=XC X8*X4=XC
    <- intersection-associative-converse* X8*X4=XC X2*XC=XE X2*X8=XA XA*X4=XE
    <- intersection-commutative XA*X4=XE X4*XA=XE
    <- intersection-associative-converse* X4*XA=XE X1*XE=XF X1*X4=X5 X5*XA=XF.

%worlds () (intersection-double-associative* X1*X2=X3 X4*X8=XC X3*XC=XF X1*X4=X5 X2*X8=XA
                            %{=>}% X5*XA=XF).
%total {} (intersection-double-associative* _ _ _ _ _ _).


%theorem intersection-double-associative :
	forall* {A} {B} {C} {D} {A+B} {C+D} {X}
	forall {AB:intersection A B A+B} {CD:intersection C D C+D} {ABCD:intersection A+B C+D X}
	exists {A+C} {B+D} {AC:intersection A C A+C} {BD:intersection B D B+D} 
               {ACBD:intersection A+C B+D X}
	true.

- : intersection-double-associative X1*X2=X3 X4*X8=XC X3*XC=XF X5 XA X1*X4=X5 X2*X8=XA X5*XA=XF
    <- intersection-associative X1*X2=X3 X3*XC=XF XE X2*XC=XE X1*XE=XF
    <- intersection-commutative X4*X8=XC X8*X4=XC
    <- intersection-associative-converse X8*X4=XC X2*XC=XE XA X2*X8=XA XA*X4=XE
    <- intersection-commutative XA*X4=XE X4*XA=XE
    <- intersection-associative-converse X4*XA=XE X1*XE=XF X5 X1*X4=X5 X5*XA=XF.

%worlds () (intersection-double-associative _ _ _ _ _ _ _ _).
%total { } (intersection-double-associative _ _ _ _ _ _ _ _).


%theorem intersection-meets-lookup :
	forall*	{M1} {M2} {M3} {N} {D1} {D2}
	forall	{L1: lookup M1 N D1}
		{L2: lookup M2 N D2}
		{MM: intersection M1 M2 M3}
	exists	{D3}
		{DM: unit`intersection D1 D2 D3}
		{L3: lookup M3 N D3}
	true.

- : intersection-meets-lookup (lookup/= nat`eq/) (lookup/= nat`eq/) MM _ DM L3
    <- intersection/=-inversion MM nat`eq/ _ _ DM _ NM=M3
    <- lookup-respects-eq (lookup/= nat`eq/) NM=M3 nat`eq/ unit`eq/ L3.

- : intersection-meets-lookup (lookup/= nat`eq/) (lookup/> L2 P2) MM _ DM L3
    <- intersection/>-inversion MM P2 _ MP SM
    <- intersection-meets-lookup (lookup/= nat`eq/) L2 MP _ DM L3P
    <- plus-swap-succ P2 P2S
    <- plus-commutative P2S P2SC
    <- shift-preserves-lookup* L3P SM P2SC L3.

- : intersection-meets-lookup (lookup/> L1 P1) (lookup/= nat`eq/) MM _ DM L3
    <- intersection/<-inversion MM P1 _ MP SM
    <- intersection-meets-lookup L1 (lookup/= nat`eq/) MP _ DM L3P
    <- plus-swap-succ P1 P1S
    <- plus-commutative P1S P1SC
    <- shift-preserves-lookup* L3P SM P1SC L3.

- : intersection-meets-lookup (lookup/> L1 P1) LL2
	(intersection/= MM _ nat`eq/) _ DM (lookup/> L3 P1)
    <- lookup/>-inversion LL2 P1 L2
    <- intersection-meets-lookup L1 L2 MM _ DM L3.

- : intersection-meets-lookup (lookup/> L1 N4+1+N1=N) (lookup/> L2 N5+1+N2=N)
	(intersection/< SM MM N0+1+N1=N2) _ DM SL3
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-associative-converse N0+N1+1=N2 N5+1+N2=N _ N5+1+N0=N4P N4P+N1+1=N
    <- plus-swap-succ N4+1+N1=N N4+N1+1=N
    <- plus-right-cancels N4P+N1+1=N N4+N1+1=N nat`eq/ nat`eq/ N4P=N4
    <- plus-respects-eq N5+1+N0=N4P nat`eq/ nat`eq/ N4P=N4 N5+1+N0=N4
    <- intersection-meets-lookup L1 (lookup/> L2 N5+1+N0=N4) MM _ DM L3
    <- plus-commutative N4+N1+1=N N1+1+N4=N
    <- shift-preserves-lookup* L3 SM N1+1+N4=N SL3. 

- : intersection-meets-lookup (lookup/> L1 N4+1+N1=N) (lookup/> L2 N5+1+N2=N)
	(intersection/> SM MM N0+1+N2=N1) _ DM SL3
    <- plus-swap-succ N0+1+N2=N1 N0+N2+1=N1
    <- plus-associative-converse N0+N2+1=N1 N4+1+N1=N _ N4+1+N0=N5P N5P+N2+1=N
    <- plus-swap-succ N5+1+N2=N N5+N2+1=N
    <- plus-right-cancels N5P+N2+1=N N5+N2+1=N nat`eq/ nat`eq/ N5P=N5
    <- plus-respects-eq N4+1+N0=N5P nat`eq/ nat`eq/ N5P=N5 N4+1+N0=N5
    <- intersection-meets-lookup (lookup/> L1 N4+1+N0=N5) L2 MM _ DM L3
    <- plus-commutative N5+N2+1=N N2+1+N5=N
    <- shift-preserves-lookup* L3 SM N2+1+N5=N SL3. 

%worlds () (intersection-meets-lookup _ _ _ _ _ _).
%total (M) (intersection-meets-lookup _ _ M _ _ _).


%theorem intersection-meets-lookup-converse :
	forall*	{M1} {M2} {M3} {N} {D3}
	forall	{MM: intersection M1 M2 M3}
		{L3: lookup M3 N D3}
	exists	{D1} {D2}
		{L1: lookup M1 N D1}
		{L2: lookup M2 N D2}
		{DM: unit`intersection D1 D2 D3}
	true.

- : intersection-meets-lookup-converse (intersection/= _ DM nat`eq/) (lookup/= nat`eq/) _ _
	(lookup/= nat`eq/) (lookup/= nat`eq/) DM.

- : intersection-meets-lookup-converse (intersection/= M _ nat`eq/) (lookup/> L3 P) _ _
	(lookup/> L1 P) (lookup/> L2 P) DM
    <- intersection-meets-lookup-converse M L3 _ _ L1 L2 DM.

- : intersection-meets-lookup-converse (intersection/< SH M P) L3P _ _ 
	(lookup/> L1 PPsc) L2P DM
    <- shift-preserves-lookup-converse L3P SH _ PP L3
    <- intersection-meets-lookup-converse M L3 _ _ L1 L2 DM
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- shift-preserves-lookup* L2 (shift/+ Psc) PP L2P
    <- plus-swap-succ PP PPs
    <- plus-commutative PPs PPsc.

- : intersection-meets-lookup-converse (intersection/> SH M P) L3P _ _ 
	L1P (lookup/> L2 PPsc) DM
    <- shift-preserves-lookup-converse L3P SH _ PP L3
    <- intersection-meets-lookup-converse M L3 _ _ L1 L2 DM
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- shift-preserves-lookup* L1 (shift/+ Psc) PP L1P
    <- plus-swap-succ PP PPs
    <- plus-commutative PPs PPsc.

%worlds () (intersection-meets-lookup-converse _ _ _ _ _ _ _).
%total (M) (intersection-meets-lookup-converse M _ _ _ _ _ _).


%theorem intersection-meets-lookup-converse* :
	forall*	{M1} {M2} {M3} {N} {D1} {D2} {D3}
	forall	{MM: intersection M1 M2 M3}
		{L3: lookup M3 N D3}
		{L1: lookup M1 N D1}
		{L2: lookup M2 N D2}
	exists	{DM: unit`intersection D1 D2 D3}
	true.

- : intersection-meets-lookup-converse* MM L3 L1 L2 DM
    <- intersection-meets-lookup-converse MM L3 _ _ L1P L2P DMP
    <- lookup-unique L1P L1 eq/ nat`eq/ D1P=D1
    <- lookup-unique L2P L2 eq/ nat`eq/ D2P=D2
    <- unit`intersection-respects-eq DMP D1P=D1 D2P=D2 unit`eq/ DM.

%worlds () (intersection-meets-lookup-converse* _ _ _ _ _).
%total { } (intersection-meets-lookup-converse* _ _ _ _ _).


%theorem intersection-meets-lookup* :
	forall*	{M1} {M2} {M3} {N} {D1} {D2} {D3}
	forall	{L1: lookup M1 N D1}
		{L2: lookup M2 N D2}
		{MM: intersection M1 M2 M3}
		{DM: unit`intersection D1 D2 D3}
	exists	{L3: lookup M3 N D3}
	true.

- : intersection-meets-lookup* L1 L2 MM DM L3
    <- intersection-meets-lookup L1 L2 MM _ DMX L3X
    <- unit`intersection-deterministic DMX DM unit`eq/ unit`eq/ D3X=D3
    <- lookup-respects-eq L3X eq/ nat`eq/ D3X=D3 L3.

%worlds () (intersection-meets-lookup* _ _ _ _ _).
%total { } (intersection-meets-lookup* _ _ _ _ _).


%theorem intersection-right-preserves-not-member:
	forall*	{M1} {N} {M2} {M3}
	forall	{F1: not-member M1 N}
		{M: intersection M1 M2 M3}
	exists	{F3: not-member M3 N}
	true.

%theorem intersection-right-preserves-not-member/L:
	forall*	{M1} {N} {M2} {M3} {B}
	forall	{F1: not-member M1 N}
		{M: intersection M1 M2 M3}
		{F3: member? M3 N B}
	exists	{F3: not-member M3 N}
	true.

- : intersection-right-preserves-not-member/L _ _ (member?/out F) F.

- : intersection-right-preserves-not-member/L F1 M (member?/in L3) F3
    <- intersection-meets-lookup-converse M L3 _ _ L1 L2 MD
    <- not-member-lookup-not-equal F1 L1 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-not-member F F3.

%worlds () (intersection-right-preserves-not-member/L _ _ _ _).
%total { } (intersection-right-preserves-not-member/L _ _ _ _).

- : intersection-right-preserves-not-member F1 M F3
    <- member?-total D?
    <- intersection-right-preserves-not-member/L F1 M D? F3.

%worlds () (intersection-right-preserves-not-member _ _ _).
%total { } (intersection-right-preserves-not-member _ _ _).


%theorem intersection-left-preserves-not-member:
	forall*	{M1} {N} {M2} {M3}
	forall	{F2: not-member M2 N}
		{M: intersection M1 M2 M3}
	exists	{F3: not-member M3 N}
	true.

%theorem intersection-left-preserves-not-member/L:
	forall*	{M1} {N} {M2} {M3} {B}
	forall	{F2: not-member M2 N}
		{M: intersection M1 M2 M3}
		{F3: member? M3 N B}
	exists	{F3: not-member M3 N}
	true.

- : intersection-left-preserves-not-member/L _ _ (member?/out F) F.

- : intersection-left-preserves-not-member/L F2 M (member?/in L3) F3
    <- intersection-meets-lookup-converse M L3 _ _ L1 L2 MD
    <- not-member-lookup-not-equal F2 L2 N<>N
    <- nat`ne-anti-reflexive N<>N F
    <- false-implies-not-member F F3.

%worlds () (intersection-left-preserves-not-member/L _ _ _ _).
%total { } (intersection-left-preserves-not-member/L _ _ _ _).

- : intersection-left-preserves-not-member F2 M F3
    <- member?-total D?
    <- intersection-left-preserves-not-member/L F2 M D? F3.

%worlds () (intersection-left-preserves-not-member _ _ _).
%total { } (intersection-left-preserves-not-member _ _ _).


%theorem intersection-implies-leq* :
	forall* {M1} {M2} {M3}
	forall {A:intersection M1 M2 M3}
        exists {L:leq M3 M1}
	true.

- : intersection-implies-leq* intersection/L leq/0.

- : intersection-implies-leq* intersection/R leq/0.

- : intersection-implies-leq* (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/) 
                      (leq/= M3<=M1 D3<=D1 nat`eq/)
    <- unit`intersection-implies-leq* D1*D2=D3 D3<=D1
    <- intersection-implies-leq* M1*M2=M3 M3<=M1.

- : intersection-implies-leq* (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1+N2) 
                      S1M3<=M111
    <- intersection-implies-leq* M1*M022=M3 M3<=M1
    <- shift-left-preserves-leq* M3<=M1 M3<<N1=S1M3 S1M3<=M111.

- : intersection-implies-leq* (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1) 
                      S2M3<=M111
    <- intersection-implies-leq* M311*M2=M3 M3<=M311
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- shift-preserves-leq* M3<=M311 M3<<N2=S2M3 (shift/+ N2+1+N3=N1) 
                            S2M3<=M111.

%worlds () (intersection-implies-leq* _ _).
%total (A) (intersection-implies-leq* A _).


%theorem intersection-implies-leq :
	forall* {M1} {M2} {M3}
	forall {A:intersection M1 M2 M3}
        exists {L1:leq M3 M1} {L2:leq M3 M2}
	true.

- : intersection-implies-leq M1*M2=M3 M3<=M1 M3<=M2
    <- intersection-implies-leq* M1*M2=M3 M3<=M1
    <- intersection-commutative M1*M2=M3 M2*M1=M3
    <- intersection-implies-leq* M2*M1=M3 M3<=M2.

%worlds () (intersection-implies-leq _ _ _).
%total { } (intersection-implies-leq _ _ _).


%theorem intersection-is-glb :
	forall* {M0} {M1} {M2} {M3}
	forall {A:intersection M1 M2 M3}
	       {L1:leq M0 M1} {L2:leq M0 M2}
	exists {L3:leq M0 M3}
	true.

- : intersection-is-glb _ leq/0 _ leq/0.

- : intersection-is-glb _ _ leq/0 leq/0.

- : intersection-is-glb (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)
                (leq/= M0<=M1 D0<=D1 nat`eq/) L2
                (leq/= M0<=M3 D0<=D3 nat`eq/)
    <- leq/=-inversion L2 nat`eq/ D0<=D2 M0<=M2
    <- unit`intersection-is-glb D1*D2=D3 D0<=D1 D0<=D2 D0<=D3
    <- intersection-is-glb M1*M2=M3 M0<=M1 M0<=M2 M0<=M3.

- : intersection-is-glb (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)
                (leq/> M400<=M1 N4+1+N1=N0) L2
                (leq/> M400<=M3 N4+1+N1=N0)
    <- leq/>-inversion L2 N4+1+N1=N0 M400<=M2
    <- intersection-is-glb M1*M2=M3 M400<=M1 M400<=M2 M400<=M3.

- : intersection-is-glb (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2)
                (leq/= M0<=M1 D0<=D1 nat`eq/) L2 L3
    <- leq/<-contradiction L2 N0+1+N1=N2 F
    <- false-implies-leq F L3.

- : intersection-is-glb (intersection/< M3<<N1=S1M3 M1*M322=M3 N3+1+N1=N2)
                (leq/> M500<=M1 N5+1+N1=N2) (leq/= M0<=M2 D0<=D2 nat`eq/)
                M200<=S1M3
    <- plus-right-cancels N5+1+N1=N2 N3+1+N1=N2 nat`eq/ nat`eq/ N5+1=N3+1
    <- succ-cancels N5+1=N3+1 N5=N3
    <- map/+-preserves-eq N5=N3 unit`eq/ eq/ M500=M300
    <- leq-respects-eq M500<=M1 M500=M300 eq/ M300<=M1
    <- intersection-is-glb M1*M322=M3 M300<=M1 (leq/= M0<=M2 D0<=D2 nat`eq/) M300<=M3
    <- plus-swap-succ N3+1+N1=N2 N3+N1+1=N2
    <- plus-commutative N3+N1+1=N2 N1+1+N3=N2
    <- shift-preserves-leq* M300<=M3 (shift/+ N1+1+N3=N2) M3<<N1=S1M3 M200<=S1M3.

- : intersection-is-glb (intersection/< M3<<N1=S1M3 M1*M322=M3 N3+1+N1=N2)
                (leq/> M500<=M1 N5+1+N1=N0) (leq/> M600<=M2 N6+1+N2=N0)
                M000<=S1M3
    <- plus-swap-succ N3+1+N1=N2 N3+N1+1=N2
    <- plus-associative-converse N3+N1+1=N2 N6+1+N2=N0 
                                 N5P N6+1+N3=N5P N5P+N1+1=N0
    <- plus-swap-succ N5+1+N1=N0 N5+N1+1=N0
    <- plus-right-cancels N5P+N1+1=N0 N5+N1+1=N0 nat`eq/ nat`eq/ N5P=N5
    <- plus-respects-eq N6+1+N3=N5P nat`eq/ nat`eq/ N5P=N5 N6+1+N3=N5
    <- plus-swap-succ N6+1+N3=N5 N6+N3+1=N5
    <- plus-commutative N6+N3+1=N5 N3+1+N6=N5
    <- shift-left-preserves-leq* M600<=M2 (shift/+ N3+1+N6=N5) M500<=M322
    <- intersection-is-glb M1*M322=M3 M500<=M1 M500<=M322 M500<=M3
    <- plus-commutative N5+N1+1=N0 N1+1+N5=N0
    <- shift-preserves-leq* M500<=M3 (shift/+ N1+1+N5=N0) M3<<N1=S1M3 M000<=S1M3.

- : intersection-is-glb (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1)
                (leq/= M0<=M1 D0<=D1 nat`eq/) L2
                M100<=S2M3
    <- leq/>-inversion L2 N3+1+N2=N1 M300<=M2
    <- intersection-is-glb M311*M2=M3 (leq/= M0<=M1 D0<=D1 nat`eq/) M300<=M2 M300<=M3
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- shift-preserves-leq* M300<=M3 (shift/+ N2+1+N3=N1) M3<<N2=S2M3 M100<=S2M3.

- : intersection-is-glb (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1)
                (leq/> M500<=M1 N5+1+N1=N0) L2
                M000<=S2M3
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-associative-converse N3+N2+1=N1 N5+1+N1=N0 
                                 N6 N5+1+N3=N6 N6+N2+1=N0
    <- plus-swap-succ-converse N6+N2+1=N0 N6+1+N2=N0
    <- leq/>-inversion L2 N6+1+N2=N0 M600<=M2
    <- plus-swap-succ N5+1+N3=N6 N5+N3+1=N6
    <- plus-commutative N5+N3+1=N6 N3+1+N5=N6
    <- shift-left-preserves-leq* M500<=M1 (shift/+ N3+1+N5=N6) M600<=M311
    <- intersection-is-glb M311*M2=M3 M600<=M311 M600<=M2 M600<=M3
    <- plus-commutative N6+N2+1=N0 N2+1+N6=N0
    <- shift-preserves-leq* M600<=M3 (shift/+ N2+1+N6=N0) M3<<N2=S2M3 M000<=S2M3.

%worlds () (intersection-is-glb _ _ _ _).
%total (A) (intersection-is-glb A _ _ _).


%theorem intersection-idempotent :
	forall* {S}
	exists {A:intersection S S S}
	true.

- : intersection-idempotent S*S=S
    <- intersection-total S*S=SP
    <- intersection-implies-leq* S*S=SP SP<=S
    <- leq-reflexive _ S<=S
    <- intersection-is-glb S*S=SP S<=S S<=S S<=SP
    <- leq-anti-symmetric SP<=S S<=SP SP=S
    <- intersection-respects-eq S*S=SP eq/ eq/ SP=S S*S=S.

%worlds () (intersection-idempotent _).
%total { } (intersection-idempotent _).


%theorem leq-implies-intersection :
	forall* {M1} {M2}
	forall {L:leq M1 M2}
	exists {J:intersection M1 M2 M1}
	true.

- : leq-implies-intersection M1<=M2 M1*M2=M1
    <- intersection-total M1*M2=M3
    <- leq-reflexive _ M1<=M1
    <- intersection-is-glb M1*M2=M3 M1<=M1 M1<=M2 M1<=M3
    <- intersection-implies-leq* M1*M2=M3 M3<=M1
    <- leq-anti-symmetric M3<=M1 M1<=M3 M3=M1
    <- intersection-respects-eq M1*M2=M3 eq/ eq/ M3=M1 M1*M2=M1.

%worlds () (leq-implies-intersection _ _).
%total { } (leq-implies-intersection _ _).


%theorem intersection-left-preserves-leq* :
	forall* {M1} {M2} {M3} {M4} {M5}
	forall {L1:leq M2 M4}
               {A:intersection M1 M2 M3} {AP:intersection M1 M4 M5}
	exists {L3:leq M3 M5}
	true.

- : intersection-left-preserves-leq* _ intersection/L _ leq/0.

- : intersection-left-preserves-leq* _ intersection/R _ leq/0.

- : intersection-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)
                             M111*M144=M M133<=M
    <- intersection/=-inversion M111*M144=M nat`eq/ D5 M5 D1*D4=D5 M1*M4=M5 M155=M
    <- meta-eq (map/+ N1 D5 M5) M M155=M
    <- unit`intersection-left-preserves-leq* D2<=D4 D1*D2=D3 D1*D4=D5 D3<=D5
    <- intersection-left-preserves-leq* M2<=M4 M1*M2=M3 M1*M4=M5 M3<=M5
    <- leq-respects-eq (leq/= M3<=M5 D3<=D5 nat`eq/) eq/ M155=M M133<=M.

- : intersection-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2)
                             M111*M244=M S1M3<=M
    <- intersection/<-inversion M111*M244=M N0+1+N1=N2 M5 M1*M044=M5 M5<<N1=M
    <- intersection-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/) 
                                M1*M022=M3 M1*M044=M5 M3<=M5
    <- shift-preserves-leq* M3<=M5 M3<<N1=S1M3 M5<<N1=M S1M3<=M.

- : intersection-left-preserves-leq* (leq/= M2<=M4 D2<=D4 nat`eq/)
                             (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1)
                             M111*M244=M S2M3<=M
    <- intersection/>-inversion M111*M244=M N3+1+N2=N1 M5 M311*M4=M5 M5<<N2=M
    <- intersection-left-preserves-leq* M2<=M4 M311*M2=M3 M311*M4=M5 M3<=M5
    <- shift-preserves-leq* M3<=M5 M3<<N2=S2M3 M5<<N2=M S2M3<=M.

- : intersection-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)   % N1=N2
                             M211*M444=M M233<=M
    <- intersection/>-inversion M211*M444=M N6+1+N4=N2 M5 M611*M4=M5 M5<<N4=M
    <- intersection-left-preserves-leq* M622<=M4 (intersection/= M1*M2=M3 D1*D2=D3 nat`eq/)
                                M611*M4=M5 M633<=M5
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-commutative N6+N4+1=N2 N4+1+N6=N2
    <- shift-preserves-leq* M633<=M5 (shift/+ N4+1+N6=N2) M5<<N4=M M233<=M.

- : intersection-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             (intersection/> M3<<N2=S2M3 M311*M2=M3 N3+1+N2=N1) 
                             M111*M444=M S2M3<=M
    <- nat`plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- nat`plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 
                                     N5 N3+1+N6=N5 N5+N4+1=N1
    <- nat`plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1 
    <- intersection/>-inversion M111*M444=M N5+1+N4=N1 M5 M511*M4=M5 M5<<N4=M
    <- shift-total M3<<N6=S6M3
    <- intersection-left-preserves-leq* M622<=M4 
                                (intersection/> M3<<N6=S6M3 M311*M2=M3 N3+1+N6=N5)
                                M511*M4=M5 S6M3<=M5
    <- shift-total S6M3<<N4=M?
    <- shifts-add M3<<N6=S6M3 S6M3<<N4=M? N6+1+N4=N2 M3<<N2=M?
    <- shift-deterministic M3<<N2=M? M3<<N2=S2M3 nat`eq/ eq/ M?=S2M3
    <- shift-respects-eq S6M3<<N4=M? nat`eq/ eq/ M?=S2M3 S6M3<<N4=S2M3
    <- shift-preserves-leq* S6M3<=M5 S6M3<<N4=S2M3 M5<<N4=M S2M3<=M.

- : intersection-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2) 
                             A1 (intersection/= M1*M4=M5 D1*D4=D5 nat`eq/)
                             S1M3<=M455
    <- intersection/<-inversion A1 N6+1+N4=N2 M3 M1*M622=M3 M3<<N4=S1M3
    <- intersection-left-preserves-leq* M622<=M4 M1*M622=M3 M1*M4=M5 M3<=M5
    <- shift-left-preserves-leq* M3<=M5 M3<<N4=S1M3 S1M3<=M455.

- : intersection-left-preserves-leq* (leq/> M622<=M4 N6+1+N4=N2)
                             A1 (intersection/< M5<<N1=S1M5 M1*M544=M5 N5+1+N1=N4)
                             M<=S1M5
    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- plus-associative-converse N5+N1+1=N4 N6+1+N4=N2 
                                 N0 N6+1+N5=N0 N0+N1+1=N2
    <- plus-swap-succ-converse N0+N1+1=N2 N0+1+N1=N2
    <- intersection/<-inversion A1 N0+1+N1=N2 M3 M1*M022=M3 M3<<N1=M
    <- plus-swap-succ N6+1+N5=N0 N6+N5+1=N0
    <- plus-commutative N6+N5+1=N0 N5+1+N6=N0
    <- shift-left-preserves-leq* M622<=M4 (shift/+ N5+1+N6=N0) M022<=M544
    <- intersection-left-preserves-leq* M022<=M544 M1*M022=M3 M1*M544=M5 M3<=M5
    <- shift-preserves-leq* M3<=M5 M3<<N1=M M5<<N1=S1M5 M<=S1M5.

- : intersection-left-preserves-leq* L
                             (intersection/< M3<<N1=S1M3 M1*M022=M3 N0+1+N1=N2)
                             (intersection/> M5<<N4=S4M5 M511*M4=M5 N5+1+N4=N1)
                             S1M3<<S4M5
    <- nat`plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- nat`plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 
                                     N6 N0+1+N5=N6 N6+N4+1=N2
    <- nat`plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2
    <- leq/>-inversion L N6+1+N4=N2 M622<=M4
    <- plus-swap-succ N0+1+N5=N6 N0+N5+1=N6
    <- plus-commutative N0+N5+1=N6 N5+1+N0=N6
    <- shift-total M3<<N5=S5M3
    <- shift-right-preserves-intersection M1*M022=M3 (shift/+ N5+1+N0=N6) M3<<N5=S5M3
                                  M511*M622=S5M3
    <- intersection-left-preserves-leq* M622<=M4 M511*M622=S5M3 M511*M4=M5 S5M3<=M5
    <- shift-total S5M3<<N4=S4S5M3
    <- shifts-add M3<<N5=S5M3 S5M3<<N4=S4S5M3 N5+1+N4=N1 M3<<N1=S4S5M3
    <- shift-deterministic M3<<N1=S4S5M3 M3<<N1=S1M3 nat`eq/ eq/ S4S5M3=S1M3
    <- shift-respects-eq S5M3<<N4=S4S5M3 nat`eq/ eq/ S4S5M3=S1M3 S5M3<<N4=S1M3
    <- shift-preserves-leq* S5M3<=M5 S5M3<<N4=S1M3 M5<<N4=S4M5 S1M3<<S4M5.

%worlds () (intersection-left-preserves-leq* _ _ _ _).
%total (A) (intersection-left-preserves-leq* _ _ A _).



%theorem intersection-right-preserves-leq* :
	forall* {X1} {X2} {X3} {X4} {X5}
	forall {G1:leq X1 X2} {O1:intersection X1 X3 X4} {O2:intersection X2 X3 X5}
	exists {G2:leq X4 X5}
	true.

- : intersection-right-preserves-leq* X1<=X2 X1*X3=X4 X2*X3=X5 X4<=X5
    <- intersection-commutative X1*X3=X4 X3*X1=X4
    <- intersection-commutative X2*X3=X5 X3*X2=X5
    <- intersection-left-preserves-leq* X1<=X2 X3*X1=X4 X3*X2=X5 X4<=X5.

%worlds () (intersection-right-preserves-leq* X1<=X2 X1*X3=X4 X2*X3=X5 %{=>}% X4<=X5).
%total {} (intersection-right-preserves-leq* _ _ _ _).





%theorem intersection-right-distributes-over-union :
	forall* {M1} {M2} {M3} {M4} {M7}
        forall {J12:union M1 M2 M3} {A34:intersection M3 M4 M7}
        exists {M5} {M6} {A14:intersection M1 M4 M5} {A24:intersection M2 M4 M6}
               {J56:union M5 M6 M7}
	true.

- : intersection-right-distributes-over-union union/L A24 _ _ intersection/L A24 union/L.

- : intersection-right-distributes-over-union union/R A14 _ _ A14 intersection/L union/R.

- : intersection-right-distributes-over-union _ intersection/R _ _ intersection/R intersection/R union/L.

- : intersection-right-distributes-over-union (union/= M1+M2=M3 D1+D2=D3 nat`eq/) intersection/R
                                     _ _ intersection/R intersection/R union/L.

- : intersection-right-distributes-over-union (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
                                     (intersection/= M3*M4=M7 D3*D4=D7 nat`eq/) _ _
                                     (intersection/= M1*M4=M5 D1*D4=D5 nat`eq/) 
                                     (intersection/= M2*M4=M6 D2*D4=D6 nat`eq/) 
                                     (union/= M5+M6=M7 D5+D6=D7 nat`eq/)
    <- intersection-right-distributes-over-union M1+M2=M3 M3*M4=M7 _ _
                                        M1*M4=M5 M2*M4=M6 M5+M6=M7
    <- unit`intersection-right-distributes-over-union D1+D2=D3 D3*D4=D7 _ _
                                             D1*D4=D5 D2*D4=D6 D5+D6=D7.

- : intersection-right-distributes-over-union (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
                                     (intersection/< M7<<N1=S1M7 M3*M744=M7 N7+1+N1=N4)
                                 _ _ (intersection/< M5<<N1=S1M5 M1*M744=M5 N7+1+N1=N4)
                                     (intersection/< M6<<N1=S1M6 M2*M744=M6 N7+1+N1=N4)
                                     S1M5+S1M6=S1M7
    <- intersection-right-distributes-over-union M1+M2=M3 M3*M744=M7 _ _
                                        M1*M744=M5 M2*M744=M6 M5+M6=M7
    <- shift-total M5<<N1=S1M5
    <- shift-total M6<<N1=S1M6
    <- shift-preserves-union* M5+M6=M7 M5<<N1=S1M5 M6<<N1=S1M6 M7<<N1=S1M7 
                             S1M5+S1M6=S1M7.

- : intersection-right-distributes-over-union (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
                                     (intersection/> M7<<N2=S2M7 M733*M4=M7 N7+1+N4=N1)
                                 _ _ (intersection/> M5<<N2=S2M5 M711*M4=M5 N7+1+N4=N1)
                                     (intersection/> M6<<N2=S2M6 M722*M4=M6 N7+1+N4=N1)
                                     S2M5+S2M6=S2M7
    <- intersection-right-distributes-over-union (union/= M1+M2=M3 D1+D2=D3 nat`eq/)
                                        M733*M4=M7 _ _ M711*M4=M5 M722*M4=M6
                                        M5+M6=M7
    <- shift-total M5<<N2=S2M5
    <- shift-total M6<<N2=S2M6
    <- shift-preserves-union* M5+M6=M7 M5<<N2=S2M5 M6<<N2=S2M6 M7<<N2=S2M7 
                             S2M5+S2M6=S2M7.

- : intersection-right-distributes-over-union (union/< M1+M022=M3 N0+1+N1=N2)
                                     (intersection/= M3*M4=M7 D1*D4=D7 nat`eq/)
                                 _ _ (intersection/= M1*M4=M5 D1*D4=D7 nat`eq/)
                                     (intersection/> M6<<N1=S1M6 M022*M4=M6 N0+1+N1=N2)
                                     M175+S1M6=M177
    <- intersection-right-distributes-over-union M1+M022=M3 M3*M4=M7 _ _
                                        M1*M4=M5 M022*M4=M6 M5+M6=M7
    <- shift-total M6<<N1=S1M6
    <- shift-right-preserves-union M5+M6=M7 M6<<N1=S1M6 M175+S1M6=M177.

- : intersection-right-distributes-over-union (union/< M1+M022=M3 N0+1+N1=N2)
                                     (intersection/< M7<<N1=S1M7 M3*M544=M7 N5+1+N1=N4)
                                 _ _ (intersection/< M5<<N1=S1M5 M1*M544=M5 N5+1+N1=N4)
                                     M222*M444=S1M6 S1M5+S1M6=S1M7
    <- intersection-right-distributes-over-union M1+M022=M3 M3*M544=M7 _ _
                                        M1*M544=M5 M022*M544=M6 M5+M6=M7
    <- shift-total M5<<N1=S1M5
    <- shift-total M6<<N1=S1M6
    <- plus-swap-succ N0+1+N1=N2 N0+N1+1=N2
    <- plus-commutative N0+N1+1=N2 N1+1+N0=N2
    <- plus-swap-succ N5+1+N1=N4 N5+N1+1=N4
    <- plus-commutative N5+N1+1=N4 N1+1+N5=N4
    <- shift-preserves-intersection* M022*M544=M6 (shift/+ N1+1+N0=N2) 
                             (shift/+ N1+1+N5=N4) M6<<N1=S1M6 M222*M444=S1M6
    <- shift-preserves-union* M5+M6=M7 M5<<N1=S1M5 M6<<N1=S1M6 M7<<N1=S1M7
                             S1M5+S1M6=S1M7.

- : intersection-right-distributes-over-union (union/< M1+M022=M3 N0+1+N1=N2)
                                     (intersection/> M7<<N4=S4M7 M513*M4=M7 N5+1+N4=N1)
                                 _ _ (intersection/> M5<<N4=S4M5 M511*M4=M5 N5+1+N4=N1)
                                     (intersection/> M6<<N4=S4M6 M622*M4=M6 N6+1+N4=N2)
                                     S4M5+S4M6=S4M7
    <- plus-swap-succ N5+1+N4=N1 N5+N4+1=N1
    <- plus-associative-converse N5+N4+1=N1 N0+1+N1=N2 N6 N0+1+N5=N6 N6+N4+1=N2
    <- plus-swap-succ-converse N6+N4+1=N2 N6+1+N4=N2
    <- plus-swap-succ N0+1+N5=N6 N0+N5+1=N6
    <- plus-commutative N0+N5+1=N6 N5+1+N0=N6
    <- shift-right-preserves-union M1+M022=M3 (shift/+ N5+1+N0=N6) M511*M622=M513
    <- intersection-right-distributes-over-union M511*M622=M513 M513*M4=M7 _ _
                                        M511*M4=M5 M622*M4=M6 M5+M6=M7
    <- shift-total M5<<N4=S4M5
    <- shift-total M6<<N4=S4M6
    <- shift-preserves-union* M5+M6=M7 M5<<N4=S4M5 M6<<N4=S4M6 M7<<N4=S4M7
                             S4M5+S4M6=S4M7.

- : intersection-right-distributes-over-union (union/> M311+M2=M3 N3+1+N2=N1)
                                     (intersection/= M3*M4=M7 D2*D4=D7 nat`eq/)
                                 _ _ (intersection/> M5<<N2=S2M5 M311*M4=M5 N3+1+N2=N1)
                                     (intersection/= M2*M4=M6 D2*D4=D7 nat`eq/)
                                     S2M5+M276=M277
    <- intersection-right-distributes-over-union M311+M2=M3 M3*M4=M7 _ _
                                        M311*M4=M5 M2*M4=M6 M5+M6=M7
    <- shift-total M5<<N2=S2M5
    <- shift-left-preserves-union M5+M6=M7 M5<<N2=S2M5 S2M5+M276=M277.

- : intersection-right-distributes-over-union (union/> M311+M2=M3 N3+1+N2=N1)
                                     (intersection/< M7<<N2=S2M7 M3*M644=M7 N6+1+N2=N4)
                                 _ _ M111*M444=S2M5
                                     (intersection/< M6<<N2=S2M6 M2*M644=M6 N6+1+N2=N4)
                                     S2M5+S2M6=S2M7
    <- intersection-right-distributes-over-union M311+M2=M3 M3*M644=M7 _ _
                                        M311*M644=M5 M2*M644=M6 M5+M6=M7
    <- shift-total M5<<N2=S2M5
    <- shift-total M6<<N2=S2M6    
    <- plus-swap-succ N3+1+N2=N1 N3+N2+1=N1
    <- plus-commutative N3+N2+1=N1 N2+1+N3=N1
    <- plus-swap-succ N6+1+N2=N4 N6+N2+1=N4
    <- plus-commutative N6+N2+1=N4 N2+1+N6=N4
    <- shift-preserves-intersection* M311*M644=M5 (shift/+ N2+1+N3=N1) 
                             (shift/+ N2+1+N6=N4) M5<<N2=S2M5 M111*M444=S2M5
    <- shift-preserves-union* M5+M6=M7 M5<<N2=S2M5 M6<<N2=S2M6 M7<<N2=S2M7
                             S2M5+S2M6=S2M7.

- : intersection-right-distributes-over-union (union/> M311+M2=M3 N3+1+N2=N1)
                                     (intersection/> M7<<N4=S4M7 M623*M4=M7 N6+1+N4=N2)
                                 _ _ (intersection/> M5<<N4=S4M5 M511*M4=M5 N5+1+N4=N1)
                                     (intersection/> M6<<N4=S4M6 M622*M4=M6 N6+1+N4=N2)
                                     S4M5+S4M6=S4M7
    <- plus-swap-succ N6+1+N4=N2 N6+N4+1=N2
    <- plus-associative-converse N6+N4+1=N2 N3+1+N2=N1 N5 N3+1+N6=N5 N5+N4+1=N1
    <- plus-swap-succ-converse N5+N4+1=N1 N5+1+N4=N1
    <- plus-swap-succ N3+1+N6=N5 N3+N6+1=N5
    <- plus-commutative N3+N6+1=N5 N6+1+N3=N5
    <- shift-left-preserves-union M311+M2=M3 (shift/+ N6+1+N3=N5) M511+M622=M623
    <- intersection-right-distributes-over-union M511+M622=M623 M623*M4=M7 _ _
                                        M511*M4=M5 M622*M4=M6 M5+M6=M7
    <- shift-total M5<<N4=S4M5
    <- shift-total M6<<N4=S4M6
    <- shift-preserves-union* M5+M6=M7 M5<<N4=S4M5 M6<<N4=S4M6 M7<<N4=S4M7
                             S4M5+S4M6=S4M7.

%worlds () (intersection-right-distributes-over-union _ _ _ _ _ _ _).
%total (A) (intersection-right-distributes-over-union _ A _ _ _ _ _).



%theorem intersection-right-distributes-over-union* :
	forall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}
        forall {A12:union X1 X2 X3} {M34:intersection X3 X4 X7}
               {M14:intersection X1 X4 X5} {M24:intersection X2 X4 X6}
        exists {A56:union X5 X6 X7}
	true.

- : intersection-right-distributes-over-union* X1+X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6 X5+X6=X7
    <- intersection-right-distributes-over-union X1+X2=X3 X3*X4=X7 Y5 Y6
                                      X1*X4=Y5 X2*X4=Y6 Y5+Y6=X7
    <- intersection-deterministic X1*X4=Y5 X1*X4=X5 eq/ eq/ Y5=X5
    <- intersection-deterministic X2*X4=Y6 X2*X4=X6 eq/ eq/ Y6=X6
    <- union-respects-eq Y5+Y6=X7 Y5=X5 Y6=X6 eq/ X5+X6=X7.

%worlds () (intersection-right-distributes-over-union* X1+X2=X3 X3*X4=X7 X1*X4=X5 X2*X4=X6
                                      %{=>}% X5+X6=X7).
%total {} (intersection-right-distributes-over-union* _ _ _ _ _).


%theorem intersection-left-distributes-over-union* :
	forall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}
        forall {A12:union X2 X4 X6} {M34:intersection X1 X6 X7}
               {M14:intersection X1 X2 X3} {M24:intersection X1 X4 X5}
        exists {A56:union X3 X5 X7}
	true.

- : intersection-left-distributes-over-union* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5 X3+X5=X7
    <- intersection-commutative X1*X6=X7 X6*X1=X7
    <- intersection-commutative X1*X2=X3 X2*X1=X3
    <- intersection-commutative X1*X4=X5 X4*X1=X5
    <- intersection-right-distributes-over-union* X2+X4=X6 X6*X1=X7 X2*X1=X3 X4*X1=X5
                                       X3+X5=X7.

%worlds () (intersection-left-distributes-over-union* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5
                                    %{=>}% X3+X5=X7).
%total {} (intersection-left-distributes-over-union* _ _ _ _ _).


%theorem intersection-left-distributes-over-union :
	forall* {X1} {X2} {X4} {X6} {X7}
        forall {A12:union X2 X4 X6} {M34:intersection X1 X6 X7}
        exists {X3} {X5} {M14:intersection X1 X2 X3} {M24:intersection X1 X4 X5}
               {A56:union X3 X5 X7}
	true.

- : intersection-left-distributes-over-union X2+X4=X6 X1*X6=X7 
                                  X3 X5 X1*X2=X3 X1*X4=X5 X3+X5=X7
    <- intersection-total X1*X2=X3
    <- intersection-total X1*X4=X5
    <- intersection-left-distributes-over-union* X2+X4=X6 X1*X6=X7 X1*X2=X3 X1*X4=X5
                                      X3+X5=X7.

%worlds () (intersection-left-distributes-over-union X2+X4=X6 X1*X6=X7 
                                   %{=>}% X3 X5 X1*X2=X3 X1*X4=X5 X3+X5=X7).
%total {} (intersection-left-distributes-over-union _ _ _ _ _ _ _).


%theorem intersection-right-factors-over-union* :
	forall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}
        forall {M14:intersection X1 X4 X5} {M24:intersection X2 X4 X6} {A56:union X5 X6 X7}
               {A12:union X1 X2 X3} 
        exists {M34:intersection X3 X4 X7}
	true.

- : intersection-right-factors-over-union* X1*X4=X5 X2*X4=X6 X5+X6=X7 X1+X2=X3 X3*X4=X7
    <- intersection-total X3*X4=Y7
    <- intersection-right-distributes-over-union* X1+X2=X3 X3*X4=Y7 X1*X4=X5 X2*X4=X6 
                                       X5+X6=Y7
    <- union-deterministic X5+X6=Y7 X5+X6=X7 eq/ eq/ Y7=X7
    <- intersection-respects-eq X3*X4=Y7 eq/ eq/ Y7=X7 X3*X4=X7.

%worlds () (intersection-right-factors-over-union* X1*X4=X5 X2*X4=X6 X5+X6=X7 X1+X2=X3
                                 %{=>}% X3*X4=X7 ).
%total {} (intersection-right-factors-over-union* _ _ _ _ _).


%theorem intersection-left-factors-over-union* :
	forall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}
	forall {M12:intersection X1 X2 X3} {M14:intersection X1 X4 X5} 
               {A35:union X3 X5 X7} {A24:union X2 X4 X6} 
        exists {M16:intersection X1 X6 X7}
        true.

- : intersection-left-factors-over-union* X1*X2=X3 X1*X4=X5 X3+X5=X7 X2+X4=X6 
                               X1*X6=X7
    <- intersection-total X1*X6=Y7
    <- intersection-left-distributes-over-union* X2+X4=X6 X1*X6=Y7 X1*X2=X3 X1*X4=X5
                                      X3+X5=Y7
    <- union-deterministic X3+X5=Y7 X3+X5=X7 eq/ eq/ Y7=X7
    <- intersection-respects-eq X1*X6=Y7 eq/ eq/ Y7=X7 X1*X6=X7.

%worlds () (intersection-left-factors-over-union* X1*X2=X3 X1*X4=X5 X3+X5=X7 X2+X4=X6 
                               %{=>}% X1*X6=X7).
%total {} (intersection-left-factors-over-union* _ _ _ _ _).




%%%% Map min and max



%%% Definition of max and min


%abbrev max : map -> nat -> type = [M] [N] bound M (s N).


min : map -> nat -> type.

min/+ : min (map/+ N D M) N.



%%% Theorems about max


%abbrev false-implies-max = false-implies-bound.


%theorem max-respects-eq:
	forall*	{M1} {N1} {M2} {N2}
	forall	{MX1: max M1 N1}
		{EM: eq M1 M2}
		{EN: nat`eq N1 N2}
	exists	{MX2: max M2 N2}
	true.

- : max-respects-eq M _ _ M.

%worlds () (max-respects-eq _ _ _ _).
%total { } (max-respects-eq _ _ _ _).


%theorem max-unique :
	forall*	{M1} {N1} {M2} {N2}
	forall	{MX1: max M1 N1}
		{MX2: max M2 N2}
		{EM: eq M1 M2}
	exists	{EN: nat`eq N1 N2}
	true.

%abbrev max-deterministic = max-unique.

- : max-unique B1 B2 EQ1 EQ3
    <- bound-unique B1 B2 EQ1 EQ2
    <- succ-cancels EQ2 EQ3.

%worlds () (max-unique _ _ _ _).
%total (M) (max-unique M _ _ _).


%theorem max-implies-lookup :
	forall*	{M} {N}
	forall	{MX: max M N}
	exists	{D}
		{L: lookup M N D}
	true.

- : max-implies-lookup (bound/+ (plus/s P) bound/0) _ (lookup/= EQ)
    <- plus-right-identity _ PP
    <- plus-unique PP P nat`eq/ nat`eq/ EQ.

- : max-implies-lookup (bound/+ (plus/s P) B1) _ (lookup/> L1 Pc)
    <- max-implies-lookup B1 _ L1
    <- plus-commutative P Pc.

%worlds () (max-implies-lookup _ _ _).
%total (M) (max-implies-lookup M _ _).


%theorem max-empty-contradiction:
	forall*	{N}
	forall	{M: max map/0 N}
	exists	{F: void}
	true.

%worlds () (max-empty-contradiction _ _).
%total { } (max-empty-contradiction _ _).


%theorem lookup-implies-max :
	forall*	{M} {N} {D}
	forall	{L: lookup M N D}
	exists	{NP}
		{MX: max M NP}
	true.

%theorem lookup-implies-max/L :
	forall*	{M} {N} {D} {B}
	forall	{L: lookup M N D}
		{B: bound M B}
	exists	{NP}
		{MX: max M NP}
	true.

- : lookup-implies-max/L (L:lookup (map/+ _ _ _) _ _) M _ M.

%worlds () (lookup-implies-max/L _ _ _ _).
%total { } (lookup-implies-max/L _ _ _ _).

- : lookup-implies-max L _ M
    <- bound-total B
    <- lookup-implies-max/L L B _ M.

%worlds () (lookup-implies-max _ _ _).
%total { } (lookup-implies-max _ _ _).


%theorem max-lookup-implies-ge :
	forall*	{M} {N1} {N2} {D}
	forall	{MX: max M N1}
		{ML: lookup M N2 D}
	exists	{GE: nat`ge N1 N2}
	true.

- : max-lookup-implies-ge B L GE
    <- bound-lookup-implies-gt B L GT
    <- succ-gt-implies-ge GT GE.

%worlds () (max-lookup-implies-ge _ _ _).
%total { } (max-lookup-implies-ge _ _ _).


%theorem gt-max-implies-not-member :
	forall*	{M} {N1} {N2}
	forall	{MX: max M N1}
		{GT: nat`gt N2 N1}
	exists	{F: not-member M N2}
	true.

- : gt-max-implies-not-member B GT F
    <- gt-implies-ge-succ GT GE
    <- ge-bound-implies-not-member B GE F.

%worlds () (gt-max-implies-not-member _ _ _).
%total { } (gt-max-implies-not-member _ _ _).



%%% Theorems about min


%theorem false-implies-min :
	forall* {M} {N}
	forall {F:void}
	exists {D:min M N}
	true.

%worlds () (false-implies-min _ _).
%total {} (false-implies-min _ _).


%theorem min-respects-eq :
	forall* {M1} {M2} {N1} {N2}
	forall {D1:min M1 N1} {E1:eq M1 M2} {E2:nat`eq N1 N2}
	exists {D2:min M2 N2}
	true.

- : min-respects-eq M eq/ nat`eq/ M.

%worlds () (min-respects-eq _ _ _ _).
%total {} (min-respects-eq _ _ _ _).
%reduces A = AP (union-respects-eq A _ _ _ AP).


%% Inversion lemmas for map

%theorem min/+-inversion :
	forall* {M} {N}
	forall {A:min M N}
	exists {D} {MP} 
               {E:eq M (map/+ N D MP)}
	true.

- : min/+-inversion min/+ _ _ eq/.

%worlds () (min/+-inversion _ _ _ _).
%total {} (min/+-inversion _ _ _ _).


%theorem min-deterministic :
	forall* {M1} {M2} {N1} {N2}
	forall {A:min M1 N1} {D2:min M2 N2}
               {E1:eq M1 M2}
	exists {E3:nat`eq N1 N2}
	true.

%abbrev min-unique = min-deterministic.

- : min-deterministic min/+ min/+ _ nat`eq/.

%worlds () (min-deterministic _ _ _ _).
%total { } (min-deterministic _ _ _ _).


%theorem min-implies-lookup:
	forall*	{M} {N}
	forall	{D: min M N}
	exists	{D}
		{L: lookup M N D}
	true.

- : min-implies-lookup min/+ _ (lookup/= nat`eq/).

%worlds () (min-implies-lookup _ _ _).
%total { } (min-implies-lookup _ _ _).


%theorem min-lookup-implies-ge:
	forall*	{M} {N1} {N2} {D}
	forall	{MN: min M N1}
		{ML: lookup M N2 D}
	exists	{G: nat`ge N2 N1}
	true.

- : min-lookup-implies-ge min/+ (lookup/= nat`eq/) (nat`ge/= nat`eq/).

- : min-lookup-implies-ge min/+ L G
    <- lookup-implies-ge L G.

%worlds () (min-lookup-implies-ge _ _ _).
%total { } (min-lookup-implies-ge _ _ _).


%theorem min-gt-implies-not-member :
	forall*	{M} {N} {NP}
	forall	{D: min M N}
		{G: nat`gt N NP}
	exists	{F: not-member M NP}
	true.

- : min-gt-implies-not-member min/+ GT (not-member/< GT).

%worlds () (min-gt-implies-not-member _ _ _).
%total { } (min-gt-implies-not-member _ _ _).


%theorem min-implies-max :
	forall* {M} {N1}
	forall	{MN: min M N1}
	exists	{N2}
		{MX: max M N2}
	true.

- : min-implies-max min/+ _ (bound/+ (plus/s P) B)
    <- bound-total B
    <- plus-total P.

%worlds () (min-implies-max _ _ _).
%total { } (min-implies-max _ _ _).


%theorem max-implies-min:
	forall* {M} {N1}
	forall	{MN: max M N1}
	exists	{N2}
		{MX: min M N2}
	true.

- : max-implies-min _ _ min/+.

%worlds () (max-implies-min _ _ _).
%total { } (max-implies-min _ _ _).


%theorem maxmin-implies-ge :
	forall*	{M} {N1} {N2}
	forall	{MX: max M N1}
		{MN: min M N2}
	exists	{GE: nat`ge N1 N2}
	true.

- : maxmin-implies-ge MX MN GE
    <- min-implies-lookup MN _ LK
    <- bound-lookup-implies-gt MX LK GT
    <- succ-gt-implies-ge GT GE.

%worlds () (maxmin-implies-ge _ _ _).
%total { } (maxmin-implies-ge _ _ _).


%%% Theorems about min/max and leq


%theorem max-preserves-leq* :
	forall*	{M1} {N1} {M2} {N2}
	forall	{LE:leq M1 M2}
		{X1:max M1 N1}
		{X2:max M2 N2}
	exists	{LE:nat`ge N2 N1}
	true.

- : max-preserves-leq* M1<=M2 MX1 MX2 N2>=N1
    <- leq-implies-bound-le M1<=M2 MX1 MX2 LE
    <- succ-preserves-ge-converse LE N2>=N1.

%worlds () (max-preserves-leq* _ _ _ _).
%total { } (max-preserves-leq* _ _ _ _).


%theorem min-reverses-leq* :
	forall*	{M1} {N1} {M2} {N2}
	forall	{LE:leq M1 M2}
		{X1:min M1 N1}
		{X2:min M2 N2}
	exists	{LE:nat`ge N1 N2}
	true.

- : min-reverses-leq* (leq/= _ _ nat`eq/) min/+ min/+ (nat`ge/= nat`eq/).

- : min-reverses-leq* (leq/> _ P) min/+ min/+ (nat`ge/> GT)
    <- plus-implies-gt P nat`eq/ GT.

%worlds () (min-reverses-leq* _ _ _ _).
%total { } (min-reverses-leq* _ _ _ _).


%%% Theorems about minmax and union


%theorem max-commute-union*:
	forall*	{M1} {M2} {M3} {N1} {N2} {N3}
	forall	{MX1: max M1 N1}
		{MX2: max M2 N2}
		{MX3: max M3 N3}
		{J: union M1 M2 M3}
	exists	{MX: nat`max N1 N2 N3}
	true.

- : max-commute-union* M1 M2 M3 J M
    <- bound-commute-union* M1 M2 M3 J MP
    <- succ-preserves-max-converse MP M.

%worlds () (max-commute-union* _ _ _ _ _).
%total { } (max-commute-union* _ _ _ _ _).


%theorem min-commute-union*:
	forall*	{M1} {M2} {M3} {N1} {N2} {N3}
	forall	{MX1: min M1 N1}
		{MX2: min M2 N2}
		{MX3: min M3 N3}
		{J: union M1 M2 M3}
	exists	{MX: nat`min N1 N2 N3}
	true.

- : min-commute-union* min/+ min/+ min/+ (union/= _ _ nat`eq/) nat`min/=.

- : min-commute-union* min/+ min/+ min/+ (union/< _ P) (nat`min/< G)
    <- plus-implies-gt P nat`eq/ G.

- : min-commute-union* min/+ min/+ min/+ (union/> _ P) (nat`min/> G)
    <- plus-implies-gt P nat`eq/ G.

%worlds () (min-commute-union* _ _ _ _ _).
%total { } (min-commute-union* _ _ _ _ _).





%%%% Redefinitions

%{%
  This file includes definitions of operations with
  more appropriate names and/or arguments than the
  ones created by map.
%}%

%abbrev set = map.
%abbrev 0 = map/0.
%abbrev set/0 = map/0.
%abbrev set/+ = [N] [S] (map/+ N unit/ S).
%abbrev set/1 : nat -> set = [N] (set/+ N set/0).


%%  To avoid nasty skolemization functions, we do some explicit typing:

%abbrev set/+-preserves-eq = [NE:nat`eq N NP] [ME:eq M MP]
        (map/+-preserves-eq NE unit`eq/ ME).

%abbrev set/+-preserves-leq = [NE:nat`eq N NP] [ML:leq M MP]
        (map/+-preserves-leq NE unit`eq/ ML).


%abbrev member = [S] [N] lookup S N unit/.

%abbrev member/1 = (lookup/= nat`eq/).


%% 'join' and 'meet' and converted using CPP,
%% but some names do not quite work:

%abbrev union/= = [U] [E:nat`eq N1 N2] union/= U unit`union/ E.
%abbrev intersection/= = [I] [E:nat`eq N1 N2] intersection/= I unit`union/ E.

%abbrev add : set -> nat -> set -> type = [S1] [N] [S2] update S1 N unit/ S2.


%%% Theorem renamings.

%% using "member"

%abbrev false-implies-member = false-implies-lookup.
%abbrev not-member-member-implies-ne = not-member-lookup-not-equal.
%abbrev in-implies-member = in-implies-lookup.

%abbrev member-respects-eq = 
    [L:member M N] [EM:eq M MP] [EN:nat`eq N NP] [LP:member MP NP] 
    lookup-respects-eq L EM EN unit`eq/ LP.

%abbrev member-respects-leq = 
    [L:member M N] [EM:leq M MP] [LP:member MP N]
    lookup-respects-leq L EM unit/ LP unit`eq/.

%abbrev member-implies-unit-leq =
    [L:member M N] [LE:leq (set/1 N) M]
    lookup-implies-unit-leq L LE.

%abbrev member-implies-ge = lookup-implies-ge.
%abbrev bound-member-implies-gt = bound-lookup-implies-gt.

%abbrev not-member-member-not-equal = not-member-lookup-not-equal.
%abbrev disjoint-member-contradiction = disjoint-lookup-contradiction.
%abbrev disjoint-member-implies-not-member = disjoint-lookup-implies-not-member.

%abbrev not-member-union-left-preserves-member-converse = not-member-union-left-preserves-lookup-converse.
%abbrev not-member-union-right-preserves-member-converse = not-member-union-right-preserves-lookup-converse.

%abbrev intersection-preserves-member =
	[MA: member A N] [MB:member B N]
	[I: intersection A B C]
	[MC: member C N]
	intersection-meets-lookup* MA MB I unit`union/ MC.

%abbrev intersection-preserves-member-converse :
	member C X -> intersection A B C -> member A X -> member B X -> type =
	[MC] [A^B] [MA] [MB]
	intersection-meets-lookup-converse 
		A^B MC unit/ unit/ MA MB unit`union/.

%abbrev max-implies-member :
	max S N -> member S N -> type =
	[MX] [ME] max-implies-lookup MX unit/ ME.

%abbrev member-implies-max = lookup-implies-max.

%abbrev max-member-implies-ge = max-lookup-implies-ge.

%abbrev min-implies-member :
	min S N -> member S N -> type =
	[MN] [ME] min-implies-lookup MN unit/ ME.

%abbrev min-member-implies-ge = min-lookup-implies-ge.


%% using "add"

%abbrev false-implies-add = false-implies-update.
%abbrev add-respects-eq 
	: add S1 X1 T1 -> eq S1 S2 -> nat`eq X1 X2 -> eq T1 T2 -> 
          add S2 X2 T2 -> type
	= [A] [ES] [EX] [ET] [AP] update-respects-eq A ES EX unit`eq/ ET AP.
%abbrev add-deterministic 
	: add S1 X1 T1 -> add S2 X2 T2 -> eq S1 S2 -> nat`eq X1 X2 ->
	  eq T1 T2 -> type
        = [A1] [A2] [ES] [EX] [ET] update-deterministic A1 A2 ES EX unit`eq/ ET.
%abbrev add-unique = add-deterministic.
%abbrev add-total* = update-total*.
%abbrev add-total = update-total.
%abbrev member-implies-add = lookup-implies-update.
%abbrev member-implies-not-member-add = lookup-implies-not-member-update.
%abbrev add-implies-member = update-implies-lookup.
% should not need NE : %abbrev add-preserves-member = update-preserves-lookup.
%abbrev add-preserves-not-member = update-preserves-not-member.
%abbrev add-preserves-membership = update-preserves-membership.
%abbrev add-preserves-member-converse = update-preserves-lookup-converse.
%abbrev add-preserves-not-member-converse = update-preserves-not-member-converse.
%abbrev add-preserves-bound-converse = update-preserves-bound-converse.
%abbrev add-preserves-disjoint-converse = update-preserves-disjoint-converse.


%abbrev add-overwrites = update-overwrites.
%abbrev add-member-has-no-effect 
	: member S1 X -> add S1 X S2 -> eq S1 S2 -> type
	= [M] [A] [E] update-may-have-no-effect M A E.
%abbrev add-idempotent = update-idempotent.
%abbrev add-commutes = update-commutes.
%abbrev add-commutes* = update-commutes*.
%abbrev add-commutes-converse = update-commutes-converse.
%abbrev not-member-add-commutes-converse* = 
	not-member-update-commutes-converse*.
%abbrev add-preserves-leq* = update-left-preserves-leq*.
%abbrev not-member-add-preserves-disjoint = 
	not-member-update-preserves-disjoint.
%abbrev not-member-add-increases-size = not-member-update-increases-size.
%abbrev not-member-add-increases-size-converse = 
	not-member-update-increases-size-converse.
%abbrev not-member-add-cancels
	: not-member M1 N1 -> add M1 N1 M1P ->
	  not-member M2 N2 -> add M2 N2 M2P -> 
	  nat`eq N1 N2 -> eq M1P M2P -> eq M1 M2 -> type
	= [F1] [A1] [F2] [A2] [EQ1] [EQ2] [EQ3]
	  not-member-update-cancels F1 A1 F2 A2 EQ1 EQ2 unit`eq/ EQ3.
%abbrev not-member-add-preserves-leq-converse
	: leq M1P M2P -> not-member M1 N -> add M1 N M1P ->
	                 not-member M2 N -> add M2 N M2P ->
          leq M1 M2 -> type
	= [LP] [F1] [U1] [F2] [U2] [L]
	  not-member-update-preserves-leq-converse LP F1 U1 F2 U2 L unit`eq/.
% deprecated:
%abbrev not-member-add2-preserves-leq-converse
	: leq M1 M2P ->  not-member M1 N -> 
	                 not-member M2 N -> add M2 N M2P ->
          leq M1 M2 -> type
	= [LP] [F1] [F2] [U2] [L]
	  not-member-update2-preserves-leq-converse LP F1 F2 U2 L.

% the third argument in the last theorem is unecessary:
%theorem irrelevant-add-preserves-leq-converse:
	forall*	{M1} {M2P} {N} {M2}
	forall	{L: leq M1 M2P}
		{F: not-member M1 N}
		{A: add M2 N M2P}
	exists	{L: leq M1 M2}
	true.

%theorem irrelevant-add-preserves-leq-converse/L:
	forall*	{M1} {M2P} {N} {M2} {B}
	forall	{L: leq M1 M2P}
		{F: not-member M1 N}
		{M: member? M2 N B}
		{A: add M2 N M2P}
	exists	{L: leq M1 M2}
	true.

- : irrelevant-add-preserves-leq-converse/L LP F1 (member?/out F2) A L
    <- not-member-update2-preserves-leq-converse LP F1 F2 A L.

- : irrelevant-add-preserves-leq-converse/L LP F1 (member?/in M2) A L
    <- member-implies-add M2 AP
    <- add-unique A AP eq/ nat`eq/ EQ
    <- leq-respects-eq LP eq/ EQ L.

%worlds () (irrelevant-add-preserves-leq-converse/L _ _ _ _ _).
%total { } (irrelevant-add-preserves-leq-converse/L _ _ _ _ _).

- : irrelevant-add-preserves-leq-converse LP F1 A L
    <- member?-total M?
    <- irrelevant-add-preserves-leq-converse/L LP F1 M? A L.

%worlds () (irrelevant-add-preserves-leq-converse _ _ _ _).
%total { } (irrelevant-add-preserves-leq-converse _ _ _ _).


%% using "union"

% nothing yet


%%%%% set-extra.elf
%%%%% Extra theorems about sets not derived from map.
%%%%% This file is part of the set.elf signature



%%%% Theorems


%theorem eq?-total* :
        forall {M} {N}
        exists {B} {T:eq? M N B}
        true.

%abbrev eq?-total = eq?-total* _ _ _.

%theorem eq?-total/+ :
	forall* {N1} {N2} {M2} {CMP} {EM}
	forall {M1} 
	       {CN: nat`compare N1 N2 CMP}
	       {EM?:eq? M1 M2 EM}
	exists {B}
	       {E?:eq? (set/+ N1 M1) (set/+ N2 M2) B}
	true.

- : eq?-total eq?/yes.

- : eq?-total (ne/< (lookup/= nat`eq/) not-member/0).

- : eq?-total (ne/> not-member/0 (lookup/= nat`eq/)).

- : eq?-total E?
    <- nat`compare-total EC
    <- eq?-total EM?
    <- eq?-total/+ _ EC EM? _ E?.

- : eq?-total/+ _ (nat`compare/=) EQ? _ EQP?
    <- map/+-preserves-eq? nat`eq/ unit`eq/ EQ? EQP?.

- : eq?-total/+ _ (nat`compare/< N2>N1) _ _
	(ne/< (lookup/= nat`eq/) (not-member/< N2>N1)).

- : eq?-total/+ _ (nat`compare/> N1>N2) _ _ 
	(ne/> (not-member/< N1>N2) (lookup/= nat`eq/) ).

%worlds ()   (eq?-total* _ _ _ _) (eq?-total/+ _ _ _ _ _).
%total (M W) (eq?-total* M _ _ _) (eq?-total/+ W _ _ _ _).


%theorem leq?-total* :
	forall {M1} {M2}
	exists {B} {L?:leq? M1 M2 B}
	true.

%abbrev leq?-total = leq?-total* _ _ _.

%theorem leq?-total/+ :
	forall* {N1} {N2} {M1} {CN}
	forall	{M2}
		{CMP:nat`compare N1 N2 CN}
	exists	{B} 
		{L:leq? (set/+ N1 M1) (set/+ N2 M2) B}
	true.

- : leq?-total (leq?/yes leq/0).

- : leq?-total (leq?/no (nle/< (lookup/= nat`eq/) not-member/0)).

- : leq?-total L?
    <- nat`compare-total CMP
    <- leq?-total/+ _ CMP _ L?.

- : leq?-total/+ _ (nat`compare/=) _ LL?
    <- leq?-total L?
    <- map/+-preserves-leq? nat`eq/ unit`eq/ L? LL?.

- : leq?-total/+ _ (nat`compare/< N1<N2) _
		 (leq?/no (nle/< (lookup/= nat`eq/) (not-member/< N1<N2))).

%theorem leq?-total/> :
        forall* {N1} {N2} {N3} {D1} {D2} {M1} {M2} {B}
        forall	{L?:leq? (map/+ N3 D1 M1) M2 B}
               	{P:plus (s N3) N2 N1}
        exists	{LL?:leq? (map/+ N1 D1 M1) (map/+ N2 D2 M2) B}
        true.

- : leq?-total/> (leq?/yes L) P (leq?/yes (leq/> L P)).

- : leq?-total/> (leq?/no (nle/< L1 F2)) P
		 (leq?/no (nle/< L1P (not-member/> F2 PP)))
    <- plus-swap-succ P Ps
    <- plus-commutative Ps Psc
    <- plus-total PP
    <- plus-swap-succ PP PPs
    <- plus-commutative PPs PPsc
    <- shift-preserves-lookup* L1 (shift/+ Psc) PPsc L1P.

%worlds () (leq?-total/> _ _ _).
%total { } (leq?-total/> _ _ _).

- : leq?-total/+ _ (nat`compare/> N1>N2) _ LL?
    <- gt-implies-plus N1>N2 _ N3+1+N2=N1
    <- leq?-total L?
    <- leq?-total/> L? N3+1+N2=N1 LL?.

%worlds ()   (leq?-total* _ _ _ _) (leq?-total/+ _ _ _ _).
%total (L M) (leq?-total* _ L _ _) (leq?-total/+ M _ _ _).


%theorem member-not-member-contradiction :
	forall* {S} {N}
	forall	{M: lookup S N unit/}
		{NM: not-member S N}
	exists	{F: void}
	true.

- : member-not-member-contradiction M NM F
    <- not-member-lookup-not-equal NM M N<>N
    <- nat`ne-anti-reflexive N<>N F.

%worlds () (member-not-member-contradiction _ _ _).
%total { } (member-not-member-contradiction _ _ _).


%theorem can-remove-member :
	forall* {S} {N} {X}
	forall	{SZ: size S (s N)}
		{SM: member S X}
	exists	{SP}
		{SZP: size SP N}
		{SA: add SP X S}
		{NM: not-member SP X}
	true.

- : can-remove-member SZ M SP SZP SA NM
    <- lookup-implies-not-member-update M SP NM SA
    <- not-member-update-increases-size-converse SZ NM SA SZP.

%worlds () (can-remove-member _ _ _ _ _ _).
%total { } (can-remove-member _ _ _ _ _ _).


%theorem add-preserves-member :
	forall* {S} {N1} {N2} {SP}
	forall	{SM: lookup S N1 unit/}
		{SA: update S N2 unit/ SP}
	exists	{SMP: lookup SP N1 unit/}
	true.

%theorem add-preserves-member/L :
	forall* {S} {N1} {N2} {SP} {B}
	forall	{SM: lookup S N1 unit/}
		{SA: update S N2 unit/ SP}
		{EQ?: nat`eq? N1 N2 B}
	exists	{SMP: lookup SP N1 unit/}
	true.

- : add-preserves-member/L SM SA (nat`eq?/no NE) SMP
    <- update-preserves-lookup SM SA NE SMP.

- : add-preserves-member/L _ SA (nat`eq?/yes) SMP
    <- update-implies-lookup SA SMP.

%worlds () (add-preserves-member/L _ _ _ _).
%total { } (add-preserves-member/L _ _ _ _).

- : add-preserves-member SM SA SMP
    <- nat`eq?-total EQ?
    <- add-preserves-member/L SM SA EQ? SMP.

%worlds () (add-preserves-member _ _ _).
%total { } (add-preserves-member _ _ _).


%theorem union-right-distributes-over-intersection :
	forall* {S1} {S2} {S3} {S4} {S7}
        forall {I12:intersection S1 S2 S3} {U34:union S3 S4 S7}
        exists {S5} {S6} {U14:union S1 S4 S5} {U24:union S2 S4 S6}
               {I56:intersection S5 S6 S7}
	true.

- : union-right-distributes-over-intersection S1*S2=S3 S3+S4=S7 S5 S6
                                              S1+S4=S5 S2+S4=S6 S5*S6=S7
    <- union-total S1+S4=S5
    <- union-total S2+S4=S6
    <- intersection-total S5*S6=S7P
    <- union-implies-leq S2+S4=S6 _ S4<=S6
    <- leq-implies-intersection S4<=S6 S4*S6=S4
    <- intersection-total S1*S6=S8
    <- intersection-total S1*S4=S9
    <- intersection-right-distributes-over-union* S1+S4=S5 S5*S6=S7P
                                                  S1*S6=S8 S4*S6=S4 S8+S4=S7P
    <- intersection-left-distributes-over-union* S2+S4=S6 S1*S6=S8
                                                 S1*S2=S3 S1*S4=S9 S3+S9=S8
    <- intersection-implies-leq S1*S4=S9 _ S9<=S4
    <- leq-implies-union S9<=S4 S9+S4=S4
    <- union-associative* S3+S9=S8 S8+S4=S7P S9+S4=S4 S3+S4=S7P
    <- union-deterministic S3+S4=S7P S3+S4=S7 eq/ eq/ S7P=S7 
    <- intersection-respects-eq S5*S6=S7P eq/ eq/ S7P=S7 S5*S6=S7.

%worlds () (union-right-distributes-over-intersection _ _ _ _ _ _ _).
%total { } (union-right-distributes-over-intersection _ _ _ _ _ _ _).



%theorem union-right-distributes-over-intersection* :
	forall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}
        forall {A12:intersection X1 X2 X3} {M34:union X3 X4 X7}
               {M14:union X1 X4 X5} {M24:union X2 X4 X6}
        exists {A56:intersection X5 X6 X7}
	true.

- : union-right-distributes-over-intersection* X1*X2=X3 X3+X4=X7 X1+X4=X5 X2+X4=X6 X5*X6=X7
    <- union-right-distributes-over-intersection X1*X2=X3 X3+X4=X7 Y5 Y6
                                      X1+X4=Y5 X2+X4=Y6 Y5*Y6=X7
    <- union-deterministic X1+X4=Y5 X1+X4=X5 eq/ eq/ Y5=X5
    <- union-deterministic X2+X4=Y6 X2+X4=X6 eq/ eq/ Y6=X6
    <- intersection-respects-eq Y5*Y6=X7 Y5=X5 Y6=X6 eq/ X5*X6=X7.

%worlds () (union-right-distributes-over-intersection* X1*X2=X3 X3+X4=X7 X1+X4=X5 X2+X4=X6
                                      %{=>}% X5*X6=X7).
%total {} (union-right-distributes-over-intersection* _ _ _ _ _).


%theorem union-left-distributes-over-intersection* :
	forall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}
        forall {A12:intersection X2 X4 X6} {M34:union X1 X6 X7}
               {M14:union X1 X2 X3} {M24:union X1 X4 X5}
        exists {A56:intersection X3 X5 X7}
	true.

- : union-left-distributes-over-intersection* X2*X4=X6 X1+X6=X7 X1+X2=X3 X1+X4=X5 X3*X5=X7
    <- union-commutative X1+X6=X7 X6+X1=X7
    <- union-commutative X1+X2=X3 X2+X1=X3
    <- union-commutative X1+X4=X5 X4+X1=X5
    <- union-right-distributes-over-intersection* X2*X4=X6 X6+X1=X7 X2+X1=X3 X4+X1=X5
                                       X3*X5=X7.

%worlds () (union-left-distributes-over-intersection* X2*X4=X6 X1+X6=X7 X1+X2=X3 X1+X4=X5
                                    %{=>}% X3*X5=X7).
%total {} (union-left-distributes-over-intersection* _ _ _ _ _).


%theorem union-left-distributes-over-intersection :
	forall* {X1} {X2} {X4} {X6} {X7}
        forall {A12:intersection X2 X4 X6} {M34:union X1 X6 X7}
        exists {X3} {X5} {M14:union X1 X2 X3} {M24:union X1 X4 X5}
               {A56:intersection X3 X5 X7}
	true.

- : union-left-distributes-over-intersection X2*X4=X6 X1+X6=X7 
                                  X3 X5 X1+X2=X3 X1+X4=X5 X3*X5=X7
    <- union-total X1+X2=X3
    <- union-total X1+X4=X5
    <- union-left-distributes-over-intersection* X2*X4=X6 X1+X6=X7 X1+X2=X3 X1+X4=X5
                                      X3*X5=X7.

%worlds () (union-left-distributes-over-intersection X2*X4=X6 X1+X6=X7 
                                   %{=>}% X3 X5 X1+X2=X3 X1+X4=X5 X3*X5=X7).
%total {} (union-left-distributes-over-intersection _ _ _ _ _ _ _).


%theorem union-right-factors-over-intersection :
	forall* {X1} {X2} {X4} {X5} {X6} {X7}
        forall {M14:union X1 X4 X5} {M24:union X2 X4 X6} {A56:intersection X5 X6 X7}
        exists {X3} {A12:intersection X1 X2 X3} {M34:union X3 X4 X7}
	true.
- : union-right-factors-over-intersection X1+X4=X5 X2+X4=X6 X5*X6=X7 X3 X1*X2=X3 X3+X4=X7
    <- intersection-total X1*X2=X3
    <- union-total X3+X4=Y7
    <- union-right-distributes-over-intersection* X1*X2=X3 X3+X4=Y7 X1+X4=X5 X2+X4=X6 
                                       X5*X6=Y7
    <- intersection-deterministic X5*X6=Y7 X5*X6=X7 eq/ eq/ Y7=X7
    <- union-respects-eq X3+X4=Y7 eq/ eq/ Y7=X7 X3+X4=X7.

%worlds () (union-right-factors-over-intersection X1+X4=X5 X2+X4=X6 X5*X6=X7
                                %{=>}% X3 X1*X2=X3 X3+X4=X7 ).
%total {} (union-right-factors-over-intersection _ _ _ _ _ _).


%theorem union-right-factors-over-intersection* :
	forall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}
        forall {M14:union X1 X4 X5} {M24:union X2 X4 X6} {A56:intersection X5 X6 X7}
               {A12:intersection X1 X2 X3} 
        exists {M34:union X3 X4 X7}
	true.

- : union-right-factors-over-intersection* X1+X4=X5 X2+X4=X6 X5*X6=X7 X1*X2=X3 X3+X4=X7
    <- union-total X3+X4=Y7
    <- union-right-distributes-over-intersection* X1*X2=X3 X3+X4=Y7 X1+X4=X5 X2+X4=X6 
                                       X5*X6=Y7
    <- intersection-deterministic X5*X6=Y7 X5*X6=X7 eq/ eq/ Y7=X7
    <- union-respects-eq X3+X4=Y7 eq/ eq/ Y7=X7 X3+X4=X7.

%worlds () (union-right-factors-over-intersection* X1+X4=X5 X2+X4=X6 X5*X6=X7 X1*X2=X3
                                 %{=>}% X3+X4=X7 ).
%total {} (union-right-factors-over-intersection* _ _ _ _ _).


%theorem union-left-factors-over-intersection :
	forall* {X1} {X2} {X3} {X4} {X5} {X7}
	forall {M12:union X1 X2 X3} {M14:union X1 X4 X5} {A35:intersection X3 X5 X7}
        exists {X6} {A24:intersection X2 X4 X6} {M16:union X1 X6 X7}
        true.

- : union-left-factors-over-intersection X1+X2=X3 X1+X4=X5 X3*X5=X7 X6 X2*X4=X6 X1+X6=X7
    <- union-commutative X1+X2=X3 X2+X1=X3
    <- union-commutative X1+X4=X5 X4+X1=X5
    <- union-right-factors-over-intersection X2+X1=X3 X4+X1=X5 X3*X5=X7 X6 X2*X4=X6 X6+X1=X7
    <- union-commutative X6+X1=X7 X1+X6=X7.

%worlds () (union-left-factors-over-intersection X1+X2=X3 X1+X4=X5 X3*X5=X7
                               %{=>}% X6 X2*X4=X6 X1+X6=X7).
%total {} (union-left-factors-over-intersection _ _ _ _ _ _).


%theorem union-left-factors-over-intersection* :
	forall* {X1} {X2} {X3} {X4} {X5} {X6} {X7}
	forall {M12:union X1 X2 X3} {M14:union X1 X4 X5} 
               {A35:intersection X3 X5 X7} {A24:intersection X2 X4 X6} 
        exists {M16:union X1 X6 X7}
        true.

- : union-left-factors-over-intersection* X1+X2=X3 X1+X4=X5 X3*X5=X7 X2*X4=X6 
                               X1+X6=X7
    <- union-total X1+X6=Y7
    <- union-left-distributes-over-intersection* X2*X4=X6 X1+X6=Y7 X1+X2=X3 X1+X4=X5
                                      X3*X5=Y7
    <- intersection-deterministic X3*X5=Y7 X3*X5=X7 eq/ eq/ Y7=X7
    <- union-respects-eq X1+X6=Y7 eq/ eq/ Y7=X7 X1+X6=X7.

%worlds () (union-left-factors-over-intersection* X1+X2=X3 X1+X4=X5 X3*X5=X7 X2*X4=X6 
                               %{=>}% X1+X6=X7).
%total {} (union-left-factors-over-intersection* _ _ _ _ _).




% a useful way to break down a union:

%theorem leq-union-implies-leq-intersection-union :
	forall*	{A} {B} {C} {D} {E} {F}
	forall	{L: leq A D}
		{U: union B C D}
		{I: intersection A B E}
		{V: union E C F}
	exists	{M: leq A F}
	true.

- : leq-union-implies-leq-intersection-union
	A<=D BUC=D A^B=E EUC=F A<=F
    <- leq-implies-intersection A<=D A^D=A
    <- intersection-total* A C G A^C=G
    <- intersection-left-distributes-over-union* BUC=D A^D=A A^B=E A^C=G EUG=A
    <- intersection-implies-leq A^C=G G<=A G<=C
    <- union-left-preserves-leq* G<=C EUG=A EUC=F A<=F.

%worlds () (leq-union-implies-leq-intersection-union _ _ _ _ _).
%total { } (leq-union-implies-leq-intersection-union _ _ _ _ _).


%theorem leq-union-disjoint-implies-leq :
	forall*	{A} {B} {C} {D}
	forall	{L: leq A D}
		{U: union B C D}
		{X: disjoint A B}
	exists	{M: leq A C}
	true.

- : leq-union-disjoint-implies-leq A<=D BUC=D A^B A<=C
    <- disjoint-intersection-empty A^B A^B=0
    <- leq-union-implies-leq-intersection-union A<=D BUC=D A^B=0 union/L A<=C.

%worlds () (leq-union-disjoint-implies-leq _ _ _ _).
%total { } (leq-union-disjoint-implies-leq _ _ _ _).


%theorem leq-intersection-disjoint-implies-disjoint:
	forall*	{A} {B} {C} {D}
	forall	{L: leq A B}
		{I: intersection B C D}
		{X: disjoint A D}
	exists	{X: disjoint A C}
	true.

%theorem leq-intersection-disjoint-implies-disjoint/L:
	forall*	{A} {B} {C} {D} {Q}
	forall	{L: leq A B}
		{I: intersection B C D}
		{X: disjoint A D}
		{Y: disjoint? A C Q}
	exists	{Z: disjoint A C}
	true.

- : leq-intersection-disjoint-implies-disjoint/L _ _ _ (disjoint?/yes D) D.

- : leq-intersection-disjoint-implies-disjoint/L 
	A<=B B^C=D A^D (disjoint?/no A->X C->X) Z
    <- member-respects-leq A->X A<=B B->X
    <- intersection-preserves-member B->X C->X B^C=D D->X
    <- disjoint-member-contradiction A^D A->X D->X F
    <- false-implies-disjoint F Z.

%worlds () (leq-intersection-disjoint-implies-disjoint/L _ _ _ _ _).
%total { } (leq-intersection-disjoint-implies-disjoint/L _ _ _ _ _).

- : leq-intersection-disjoint-implies-disjoint L I X Z
    <- disjoint?-total Y
    <- leq-intersection-disjoint-implies-disjoint/L L I X Y Z.

%worlds () (leq-intersection-disjoint-implies-disjoint _ _ _ _).
%total { } (leq-intersection-disjoint-implies-disjoint _ _ _ _).


% not true for general maps.
%theorem leq-size-eq-implies-eq :
        forall* {S1} {S2} {Z1} {Z2}
        forall  {L: leq S1 S2}
                {SZ1: size S1 Z1}
                {SZ2: size S2 Z2}
                {EQZ: nat`eq Z1 Z2}
        exists  {EQS: eq S1 S2}
        true.

%theorem leq-size-eq-implies-eq/L :
        forall* {S1} {S2} {Z} {B}
        forall  {L: leq S1 S2}
                {SZ1: size S1 Z}
                {SZ2: size S2 Z}
                {LE?: leq? S2 S1 B}
        exists  {EQS: eq S1 S2}
        true.

- : leq-size-eq-implies-eq/L S1<=S2 _ _ S2<=S1 S1=S2
    <- leq-anti-symmetric S1<=S2 S2<=S1 S1=S2.

- : leq-size-eq-implies-eq/L S1<=S2 SS1 SS2 (nle/< M2 NM1) EQ
    <- member-implies-not-member-add M2 S3 NM3 S3+X=S2
    <- size-total SS3
    <- not-member-add-increases-size SS3 NM3 S3+X=S2 SS2P
    <- size-unique SS2 SS2P eq/ Z=Z3+1
    <- not-member-update-implies-unit-union NM3 S3+X=S2 S3UX=S2
    <- union-commutative S3UX=S2 XUS3=S2
    <- not-member-implies-unit-disjoint NM1 S1^X
    <- leq-union-disjoint-implies-leq S1<=S2 XUS3=S2 S1^X S1<=S3
    <- leq-implies-size-le S1<=S3 SS1 SS3 Z3>=Z
    <- nat`ge-respects-eq Z3>=Z nat`eq/ Z=Z3+1 Z3>=Z3+1
    <- ge-succ-implies-gt Z3>=Z3+1 Z3>Z3
    <- gt-anti-reflexive Z3>Z3 F
    <- false-implies-eq F EQ.

%worlds () (leq-size-eq-implies-eq/L _ _ _ _ _).
%total { } (leq-size-eq-implies-eq/L _ _ _ _ _).

- : leq-size-eq-implies-eq L SZ1 SZ2 nat`eq/ EQ
    <- leq?-total LEQ?
    <- leq-size-eq-implies-eq/L L SZ1 SZ2 LEQ? EQ.

%worlds () (leq-size-eq-implies-eq _ _ _ _ _).
%total { } (leq-size-eq-implies-eq _ _ _ _ _).



%%% set membership w.r.t. union:


%theorem add-implies-unit-union :
	forall*	{S1} {X} {S2}
	forall	{A: add S1 X S2}
	exists	{U: union S1 (set/1 X) S2}
	true.

%theorem add-implies-unit-union/L :
	forall*	{S1} {X} {S2} {B}
	forall	{A: add S1 X S2}
		{M?: member? S1 X B}
	exists	{U: union S1 (set/1 X) S2}
	true.

- : add-implies-unit-union/L A (member?/in S1->X) S1UX=S2
    <- member-implies-unit-leq S1->X X<=S1
    <- add-member-has-no-effect S1->X A S1=S2
    <- leq-implies-union X<=S1 XUS1=S1
    <- union-commutative XUS1=S1 S1UX=S1
    <- union-respects-eq S1UX=S1 eq/ eq/ S1=S2 S1UX=S2.

- : add-implies-unit-union/L A (member?/out S1-/>X) S1UX=S2
    <- not-member-update-implies-unit-union S1-/>X A S1UX=S2.

%worlds () (add-implies-unit-union/L _ _ _).
%total { } (add-implies-unit-union/L _ _ _).

- : add-implies-unit-union A U
    <- member?-total M?
    <- add-implies-unit-union/L A M? U.

%worlds () (add-implies-unit-union _ _).
%total { } (add-implies-unit-union _ _).


%theorem add-implies-leq :
	forall*	{S1} {X} {S2}
	forall	{A: add S1 X S2}
	exists	{L: leq S1 S2}
	true.

- : add-implies-leq A L
    <- add-implies-unit-union A U
    <- union-implies-leq U L _.

%worlds () (add-implies-leq _ _).
%total { } (add-implies-leq _ _).


%theorem add-member-preserves-leq :
        forall* {S1} {S2} {S} {N}
        forall  {L1: leq S1 S}
                {A: add S1 N S2}
                {M: lookup S N unit/}
        exists  {L2: leq S2 S}
        true.

- : add-member-preserves-leq L1 A M L2
    <- lookup-implies-update M AP
    <- update-left-preserves-leq* L1 A AP L2.

%worlds () (add-member-preserves-leq _ _ _ _).
%total { } (add-member-preserves-leq _ _ _ _).


%theorem unit-union-implies-add :
	forall*	{S1} {X} {S2}
	forall	{U: union S1 (set/1 X) S2}
	exists	{A: add S1 X S2}
	true.

%theorem unit-union-implies-add/L :
	forall*	{S1} {X} {S2} {B}
	forall	{U: union S1 (set/1 X) S2}
		{M?: member? S1 X B}
	exists	{A: add S1 X S2}
	true.

- : unit-union-implies-add/L S1UX=S2 (member?/in S1->X) S1+X=S2
    <- member-implies-unit-leq S1->X X<=S1
    <- leq-implies-union X<=S1 XUS1=S1
    <- union-commutative XUS1=S1 S1UX=S1
    <- union-unique S1UX=S1 S1UX=S2 eq/ eq/ S1=S2
    <- member-implies-add S1->X S1+X=S1
    <- add-respects-eq S1+X=S1 eq/ nat`eq/ S1=S2 S1+X=S2.

- : unit-union-implies-add/L S1UX=S2 (member?/out S1-/>X) S1+X=S2
    <- add-total S1+X=S3
    <- add-implies-unit-union S1+X=S3 S1UX=S3
    <- union-unique S1UX=S3 S1UX=S2 eq/ eq/ S3=S2
    <- add-respects-eq S1+X=S3 eq/ nat`eq/ S3=S2 S1+X=S2.

%worlds () (unit-union-implies-add/L _ _ _).
%total { } (unit-union-implies-add/L _ _ _).

- : unit-union-implies-add U A
    <- member?-total M?
    <- unit-union-implies-add/L U M? A.

%worlds () (unit-union-implies-add _ _).
%total { } (unit-union-implies-add _ _).


%theorem union-left-preserves-member* :
	forall* {S1} {S2} {S3} {N}
	forall {M:lookup S2 N unit/}
	       {U:union S1 S2 S3}
	exists {M:lookup S3 N unit/}
	true.

- : union-left-preserves-member* M U MP
    <- union-left-affects-lookup M U _ MP.

%worlds () (union-left-preserves-member* _ _ _).
%total { } (union-left-preserves-member* _ _ _).


%theorem union-right-preserves-member* :
        forall* {S1} {S2} {S3} {N}
        forall {M:lookup S1 N unit/}
               {U:union S1 S2 S3}
        exists {M:lookup S3 N unit/}
        true.

- : union-right-preserves-member* M U MP
    <- union-right-affects-lookup M U _ MP.

%worlds () (union-right-preserves-member* _ _ _).
%total { } (union-right-preserves-member* _ _ _).


% not sure if this is the right way to express this lemma.
%theorem add-member-right-preserves-union :
        forall* {S1} {S2} {S3} {N} {S2P}
        forall  {U1: union S1 S2 S3}
                {A: add S2 N S2P}
                {M: member S3 N}
        exists  {U2: union S1 S2P S3}
        true.

- : add-member-right-preserves-union U1 A M U2
    <- add-implies-unit-union A UU2
    <- member-implies-add M A3
    <- add-implies-unit-union A3 UU3
    <- union-associative* U1 UU3 UU2 U2.

%worlds () (add-member-right-preserves-union _ _ _ _).
%total { } (add-member-right-preserves-union _ _ _ _).


%theorem union-preserves-disjoint-converse:
	forall* {S1} {S2} {S3} {S}
	forall	{D: disjoint S3 S}
		{U: union S1 S2 S3}
	exists	{D1: disjoint S1 S}
		{D2: disjoint S2 S}
	true.

%theorem union-preserves-disjoint-converse/L:
	forall* {S1} {S2} {S3} {S} {B1} {B2}
	forall	{D: disjoint S3 S}
		{U: union S1 S2 S3}
		{D1?: disjoint? S1 S B1}
		{D2?: disjoint? S2 S B2}
	exists	{D1: disjoint S1 S}
		{D2: disjoint S2 S}
	true.

- : union-preserves-disjoint-converse/L _ _ 
	(disjoint?/yes D1) (disjoint?/yes D2) D1 D2.

- : union-preserves-disjoint-converse/L D U
	(disjoint?/no M1 M) _ D1 D2
    <- union-right-preserves-member* M1 U M3
    <- disjoint-lookup-contradiction D M3 M F
    <- false-implies-disjoint F D1
    <- false-implies-disjoint F D2.

- : union-preserves-disjoint-converse/L D U
	_ (disjoint?/no M2 M) D1 D2
    <- union-left-preserves-member* M2 U M3
    <- disjoint-lookup-contradiction D M3 M F
    <- false-implies-disjoint F D1
    <- false-implies-disjoint F D2.

%worlds () (union-preserves-disjoint-converse/L _ _ _ _ _ _).
%total { } (union-preserves-disjoint-converse/L _ _ _ _ _ _).

- : union-preserves-disjoint-converse SD SU S1 S2
    <- disjoint?-total D1?
    <- disjoint?-total D2?
    <- union-preserves-disjoint-converse/L SD SU D1? D2? S1 S2.

%worlds () (union-preserves-disjoint-converse _ _ _ _).
%total { } (union-preserves-disjoint-converse _ _ _ _).



%%% Theorems about size, union and intersection


%theorem union-intersection-size :
	forall*	{S1} {S2} {S3} {S4} {N1} {N2} {N3} {N4} {N}
	forall	{U: union S1 S2 S3}
		{I: intersection S1 S2 S4}
		{SZ1: size S1 N1}
		{SZ2: size S2 N2}
		{SZ3: size S3 N3}
		{SZ4: size S4 N4}
		{P12: plus N1 N2 N}
	exists	{P34: plus N3 N4 N}
	true.

- : union-intersection-size 
	(union/L) (intersection/L) 
	size/0 SZ2 SZ3 size/0 
	plus/z P
    <- plus-right-identity _ PP
    <- size-deterministic SZ2 SZ3 eq/ N2=N3
    <- plus-respects-eq PP N2=N3 nat`eq/ nat`eq/ P.

- : union-intersection-size
	union/L intersection/R
	size/0 size/0 size/0 size/0
        plus/z plus/z.

- : union-intersection-size
	union/R intersection/L
	size/0 size/0 size/0 size/0
        plus/z plus/z.

- : union-intersection-size
	union/R intersection/R
	SZ1 size/0 SZ3 size/0
	N1+0=N N3+0=N
    <- size-deterministic SZ1 SZ3 eq/ N1=N3
    <- plus-respects-eq N1+0=N N1=N3 nat`eq/ nat`eq/ N3+0=N.

- : union-intersection-size
	(union/= U12 nat`eq/) I
        (size/+ SZ1) (size/+ SZ2) (size/+ SZ3) (SZ444: size S444 N444)
        (plus/s N1+SN2=N) SN3+N444=SN
    <- intersection/=-inversion I nat`eq/ _ _ _ I12 E
    <- plus-total N1+N2=N-1
    <- size-total SZ4
    <- union-intersection-size U12 I12 SZ1 SZ2 SZ3 SZ4 N1+N2=N-1 N3+N4=N-1
    <- plus-swap-succ (plus/s N1+N2=N-1) N1+SN2=SN-1
    <- plus-swap-succ (plus/s N3+N4=N-1) N3+SN4=SN-1
    <- plus-deterministic N1+SN2=SN-1 N1+SN2=N nat`eq/ nat`eq/ SN-1=N
    <- plus-respects-eq N3+SN4=SN-1 nat`eq/ nat`eq/ SN-1=N N3+SN4=N
    <- size-deterministic (size/+ SZ4) SZ444 E SN4=N444
    <- plus-respects-eq (plus/s N3+SN4=N) nat`eq/ SN4=N444 nat`eq/ SN3+N444=SN.

- : union-intersection-size
	(union/< U103 SN0+N1=N2) I
	(size/+ SZ1) (size/+ SZ2) (size/+ SZ3) (SZ444:size S444 N4)
	(plus/s N1+SN2=N) (plus/s N3+N4=N)
    <- intersection/<-inversion I SN0+N1=N2 S4 I104 S4<<N1=S444
    <- shift-preserves-size-converse SZ444 S4<<N1=S444 SZ4
    <- union-intersection-size 
	U103 I104 SZ1 (size/+ SZ2) SZ3 SZ4 N1+SN2=N N3+N4=N.

- : union-intersection-size
	(union/> U023 SN0+N2=N1) I
	(size/+ SZ1) (size/+ SZ2) (size/+ SZ3) (SZ444:size S444 N4)
	(plus/s N1+SN2=N) (plus/s N3+N4=N)
    <- intersection/>-inversion I SN0+N2=N1 S4 I024 S4<<N2=S444
    <- shift-preserves-size-converse SZ444 S4<<N2=S444 SZ4
    <- plus-swap-succ-converse N1+SN2=N SN1+N2=N
    <- union-intersection-size 
	U023 I024 (size/+ SZ1) SZ2 SZ3 SZ4 SN1+N2=N N3+N4=N.

%worlds () (union-intersection-size _ _ _ _ _ _ _ _).
%total (U) (union-intersection-size U _ _ _ _ _ _ _).



%theorem intersection-characterization:
	forall* {A} {B} {C} {D} {E}
	forall	{U1: union C D A}
		{U2: union C E B}
		{D: disjoint D E}
	exists	{I: intersection A B C}
	true.

%theorem intersection-characterization/L:
	forall* {A} {B} {C} {D} {E} {CP} {B?}
	forall	{U1: union C D A}
		{U2: union C E B}
		{D: disjoint D E}
		{I: intersection A B CP}
		{E?: eq? CP C B?}
	exists	{E: eq CP C}
	true.

- : intersection-characterization/L _ _ _ _ eq?/yes eq/.

- : intersection-characterization/L CUD=A CUE=B D^E A^B=CP 
	(ne/< CP->X C-/>X) EQ
    <- intersection-preserves-member-converse CP->X A^B=CP A->X B->X
    <- not-member-union-left-preserves-member-converse C-/>X A->X CUD=A D->X
    <- not-member-union-left-preserves-member-converse C-/>X B->X CUE=B E->X
    <- disjoint-member-contradiction D^E D->X E->X FALSE
    <- false-implies-eq FALSE EQ.

- : intersection-characterization/L CUD=A CUE=B D^E A^B=CP 
	(ne/> CP-/>X C->X) EQ
    <- union-right-preserves-member* C->X CUD=A A->X
    <- union-right-preserves-member* C->X CUE=B B->X
    <- intersection-preserves-member A->X B->X A^B=CP CP->X
    <- member-not-member-contradiction CP->X CP-/>X FALSE
    <- false-implies-eq FALSE EQ.

%worlds () (intersection-characterization/L _ _ _ _ _ _).
%total { } (intersection-characterization/L _ _ _ _ _ _).

- : intersection-characterization CUD=A CUE=B D^E A^B=C
    <- intersection-total A^B=CP
    <- eq?-total EQ?
    <- intersection-characterization/L CUD=A CUE=B D^E A^B=CP EQ? EQ
    <- intersection-respects-eq A^B=CP eq/ eq/ EQ A^B=C.

%worlds () (intersection-characterization _ _ _ _).
%total { } (intersection-characterization _ _ _ _).



%%% Theorems with min/max


%theorem can-remove-min:
	forall*	{S} {N1} {N2}
	forall	{SZ: size S (s N1)}
		{MN: min S N2}
	exists	{SP}
		{SZP: size SP N1}
		{A: add SP N2 S}
		{F: not-member SP N2}
	true.

- : can-remove-min SZ MN _ SZ1 A F
    <- can-remove SZ (lookup/= nat`eq/) _ _ SZ1P EQs A F
    <- succ-cancels EQs EQ
    <- size-respects-eq SZ1P eq/ EQ SZ1.

%worlds () (can-remove-min _ _ _ _ _ _).
%total { } (can-remove-min _ _ _ _ _ _).


%theorem can-remove-max:
	forall*	{S} {N1} {N2}
	forall	{SZ: size S (s N1)}
		{MN: max S N2}
	exists	{SP}
		{SZP: size SP N1}
		{A: add SP N2 S}
		{F: not-member SP N2}
	true.

- : can-remove-max SZ MN _ SZ1 A F
    <- max-implies-lookup MN _ SL
    <- can-remove SZ SL _ _ SZ1P EQs A F
    <- succ-cancels EQs EQ
    <- size-respects-eq SZ1P eq/ EQ SZ1.

%worlds () (can-remove-max _ _ _ _ _ _).
%total { } (can-remove-max _ _ _ _ _ _).


%%%%% set-remove.elf
%%%%% Set subtraction.
%%%%% This file is part of the set.elf signature


%%%% Definitions


%%% removal

remove : set -> set -> set -> type.

remove/ : leq C A -> disjoint B C -> union B C D -> leq A D -> remove A B C.



%%%% Theorems


%%% Theorems about remove


%theorem false-implies-remove :
	forall* {S1} {S2} {S3}
	forall {F:void}
	exists {D:remove S1 S2 S3}
	true.

%worlds () (false-implies-remove _ %{=>}% S1-S2=S3).
%total {} (false-implies-remove _ _).


%theorem remove-respects-eq :
	forall* {S1} {S2} {S3} {T1} {T2} {T3}
	forall {DS:remove S1 S2 S3}
               {E1:eq S1 T1} {E2:eq S2 T2} {E3:eq S3 T3}
	exists {DT:remove T1 T2 T3}
	true.

- : remove-respects-eq R eq/ eq/ eq/ R.

%worlds () (remove-respects-eq S1-S2=S3 S1=T1 S2=T2 S3=T3 %{=>}% T1-T2=T3).
%total {} (remove-respects-eq _ _ _ _ _).
%reduces R = RP (remove-respects-eq R _ _ _ RP).


%theorem remove-total* :
	forall {S1} {S2}
	exists {S3} {R:remove S1 S2 S3}
	true.

%abbrev remove-total = remove-total* _ _ _.

%theorem remove-total/L1 :
        forall* {A} {B} 
	forall	{N}
	       	{S: size A N}
        exists	{C} 
		{R:remove A B C}
	true.

%theorem remove-total/L2 :
        forall* {B} {A} {AP} {CP} {X} {B?}
	forall  {AD: add AP X A}
		{R: remove AP B CP}
		{D?: member? B X B?}
        exists	{C} 
		{R:remove A B C}
	true.

- : remove-total/L2 AP+X=A
	(remove/ CP<=AP B^CP BUCP=DP AP<=DP) (member?/in X<-B) CP 
	(remove/ CP<=A B^CP BUCP=DP A<=DP)
    <- add-implies-unit-union AP+X=A APUX=A
    <- union-implies-leq APUX=A AP<=A X<=A
    <- leq-transitive CP<=AP AP<=A CP<=A
    <- union-implies-leq BUCP=DP B<=DP CP<=DP
    <- member-respects-leq X<-B B<=DP X<-DP
    <- member-implies-unit-leq X<-DP X<=DP
    <- union-is-lub APUX=A AP<=DP X<=DP A<=DP.

- : remove-total/L2 AP+X=A
	(remove/ CP<=AP B^CP BUCP=DP AP<=DP) (member?/out X</-B) C 
	(remove/ C<=A B^C BUC=D A<=D)
    <- not-member-implies-unit-disjoint X</-B B^X
    <- union-total* CP (set/1 X) C CPUX=C
    <- union-right-preserves-disjoint* B^CP B^X CPUX=C B^C
    <- add-implies-unit-union AP+X=A APUX=A
    <- union-implies-leq APUX=A AP<=A X<=A
    <- leq-transitive CP<=AP AP<=A CP<=A
    <- union-is-lub CPUX=C CP<=A X<=A C<=A
    <- union-total* DP (set/1 X) D DPUX=D
    <- union-associative* BUCP=DP DPUX=D CPUX=C BUC=D
    <- union-implies-leq DPUX=D DP<=D X<=D
    <- leq-transitive AP<=DP DP<=D AP<=D
    <- union-is-lub APUX=A AP<=D X<=D A<=D.

%worlds () (remove-total/L2 _ _ _ _ _).
%total { } (remove-total/L2 _ _ _ _ _).

- : remove-total/L1 _ size/0 set/0 (remove/ leq/0 disjoint/R union/R leq/0).

- : remove-total/L1 _ SZ C A-B=C
    <- can-remove* SZ AP X _ SZP AP+X=A _
    <- remove-total/L1 _ SZP CP AP-B=CP
    <- member?-total M?
    <- remove-total/L2 AP+X=A AP-B=CP M? C A-B=C.

%worlds () (remove-total/L1 _ _ _ _).
%total (N) (remove-total/L1 N _ _ _).

- : remove-total R
    <- size-total SZ
    <- remove-total/L1 _ SZ _ R.

%worlds () (remove-total* _ _ _ _).
%total { } (remove-total* _ _ _ _).


%theorem remove-deterministic :
	forall* {S1} {S2} {S3} {T1} {T2} {T3}
	forall {RS:remove S1 S2 S3} {RT:remove T1 T2 T3}
	       {E1:eq S1 T1} {E2:eq S2 T2}
	exists {E3:eq S3 T3}
	true.

%abbrev remove-unique = remove-deterministic.

%theorem remove-deterministic/L :
	forall* {S1} {S2} {S3} {T3} {B}
	forall	{RS:remove S1 S2 S3} {RT:remove S1 S2 T3}
		{E: eq? S3 T3 B}
	exists	{E3:eq S3 T3}
	true.

- : remove-deterministic/L _ _ eq?/yes eq/.

- : remove-deterministic/L 
	(remove/ C<=A B^C BUC=D A<=D)
	(remove/ E<=F B^E BUE=F A<=F)
	(ne/< X<-C X</-E) C=E
    <- member-respects-leq X<-C C<=A X<-A
    <- member-respects-leq X<-A A<=F X<-F
    <- disjoint-symmetric B^C C^B
    <- disjoint-member-implies-not-member X<-C C^B X</-B
    <- not-member-union-left-preserves-member-converse X</-B X<-F BUE=F X<-E
    <- member-not-member-contradiction X<-E X</-E FALSE
    <- false-implies-eq FALSE C=E.

- : remove-deterministic/L 
	(remove/ E<=F B^E BUE=F A<=F)
	(remove/ C<=A B^C BUC=D A<=D)
	(ne/> X</-E X<-C) E=C
    <- member-respects-leq X<-C C<=A X<-A
    <- member-respects-leq X<-A A<=F X<-F
    <- disjoint-symmetric B^C C^B
    <- disjoint-member-implies-not-member X<-C C^B X</-B
    <- not-member-union-left-preserves-member-converse X</-B X<-F BUE=F X<-E
    <- member-not-member-contradiction X<-E X</-E FALSE
    <- false-implies-eq FALSE E=C.

%worlds () (remove-deterministic/L _ _ _ _).
%total { } (remove-deterministic/L _ _ _ _).

- : remove-deterministic R1 R2 eq/ eq/ EQ
    <- eq?-total EQ?
    <- remove-deterministic/L R1 R2 EQ? EQ.

%worlds () (remove-deterministic _ _ _ _ _).
%total { } (remove-deterministic _ _ _ _ _).


%theorem shift-preserves-remove :
	forall*	{A} {B} {C} {N} {AP} {BP}
	forall	{R: remove A B C}
		{SA: shift N A AP}
		{SB: shift N B BP}
	exists	{CP}
		{SC: shift N C CP}
		{RP: remove AP BP CP}
	true.

- : shift-preserves-remove 
	(remove/ C<=A B^C BUC=D A<=D) SA SB CP SC
	(remove/ CP<=AP BP^CP BPUCP=DP AP<=DP)
    <- shift-total* N C CP SC
    <- shift-preserves-leq C<=A SC SA CP<=AP
    <- shift-preserves-disjoint B^C SB SC BP^CP
    <- shift-preserves-union BUC=D SB SC _ SD BPUCP=DP
    <- shift-preserves-leq A<=D SA SD AP<=DP.

%worlds () (shift-preserves-remove _ _ _ _ _ _).
%total { } (shift-preserves-remove _ _ _ _ _ _).


%theorem remove-implies-leq :
	forall* {S1} {S2} {S3}
	forall {D:remove S1 S2 S3}
	exists {L:leq S3 S1}
	true.

- : remove-implies-leq (remove/ L _ _ _) L.

%worlds () (remove-implies-leq _ _).
%total { } (remove-implies-leq _ _).


%theorem remove-implies-leq-union :
	forall* {S1} {S2} {S3} {S4}
	forall {D:remove S1 S2 S3} {U:union S2 S3 S4}
	exists {L:leq S1 S4}
	true.

- : remove-implies-leq-union (remove/ C<=A B^C BUC=D A<=D) BUC=E A<=E
    <- union-unique BUC=D BUC=E eq/ eq/ D=E
    <- leq-respects-eq A<=D eq/ D=E A<=E.

%worlds () (remove-implies-leq-union _ _ _).
%total { } (remove-implies-leq-union _ _ _).


%theorem remove-implies-disjoint :
	forall* {S1} {S2} {S3}
	forall {D:remove S1 S2 S3}
	exists {I:disjoint S2 S3}
	true.

- : remove-implies-disjoint (remove/ _ B^C _ _) B^C.

%worlds () (remove-implies-disjoint _ _).
%total { } (remove-implies-disjoint _ _).


%theorem remove-implies-empty-intersection :
	forall* {S1} {S2} {S3}
	forall {D:remove S1 S2 S3}
	exists {I:intersection S2 S3 set/0}
	true.

- : remove-implies-empty-intersection R I
    <- remove-implies-disjoint R D
    <- disjoint-intersection-empty D I.

%worlds () (remove-implies-empty-intersection _ _).
%total { } (remove-implies-empty-intersection _ _).


%theorem leq-implies-remove-all :
	forall*	{A} {B}
	forall	{L: leq A B}
	exists	{R: remove A B set/0}
	true.

- : leq-implies-remove-all A<=B (remove/ leq/0 disjoint/R union/R A<=B).

%worlds () (leq-implies-remove-all _ _).
%total { } (leq-implies-remove-all _ _).


%theorem remove-all-implies-leq :
	forall*	{A} {B}
	forall	{R: remove A B set/0}
	exists	{L: leq A B}
	true.

- : remove-all-implies-leq (remove/ _ _ BU0=D A<=D) A<=B
    <- union-unique BU0=D union/R eq/ eq/ D=B
    <- leq-respects-eq A<=D eq/ D=B A<=B.

%worlds () (remove-all-implies-leq _ _).
%total { } (remove-all-implies-leq _ _).


%theorem remove-characterization:
	forall*	{A} {B} {C} {D}
	forall	{L: leq C A}
		{I: disjoint B C}
		{U: union B C D}
		{G: leq A D}
	exists	{R: remove A B C}
	true.

- : remove-characterization D1 D2 D3 D4 (remove/ D1 D2 D3 D4).

%worlds () (remove-characterization _ _ _ _ _).
%total { } (remove-characterization _ _ _ _ _).


%theorem disjoint-union-implies-remove:
	forall*	{A} {B} {C}
	forall	{U: union A B C}
		{D: disjoint A B}
	exists	{R: remove C B A}
	true.

- : disjoint-union-implies-remove U D R
    <- leq-reflexive _ LL
    <- disjoint-symmetric D Ds
    <- union-commutative U Uc
    <- union-implies-leq* U L
    <- remove-characterization L Ds Uc LL R.

%worlds () (disjoint-union-implies-remove _ _ _).
%total { } (disjoint-union-implies-remove _ _ _).


%theorem remove-preserves-member :
        forall* {A} {B} {C} {X}
        forall  {M: member A X}
                {R: remove A B C}
                {N: not-member B X}
        exists  {M: member C X}
        true.

- : remove-preserves-member M1 R NM2 M3
    <- union-total BUC=D
    <- remove-implies-leq-union R BUC=D A<=D 
    <- member-respects-leq M1 A<=D M4
    <- not-member-union-left-preserves-member-converse NM2 M4 BUC=D M3.

%worlds () (remove-preserves-member _ _ _ _).
%total { } (remove-preserves-member _ _ _ _).


%theorem remove-preserves-member-converse :
        forall* {A} {B} {C} {X}
        forall  {M: member C X}
                {R: remove A B C}
        exists  {M: member A X}
        true.

- : remove-preserves-member-converse C->X A-B=C A->X
    <- remove-implies-leq A-B=C C<=A
    <- member-respects-leq C->X C<=A A->X.

%worlds () (remove-preserves-member-converse _ _ _).
%total { } (remove-preserves-member-converse _ _ _).


%theorem remove-associates-union* :
	forall*	{A} {B} {C} {D} {E} {F}
	forall	{R1: remove A B C}
		{R2: remove C D E}
		{U: union B D F}
	exists	{R3: remove A F E}
	true.

- : remove-associates-union* 
	(remove/ C<=A B^C BUC=G A<=G)
	(remove/ E<=C D^E DUE=H C<=H) BUD=F 
	(remove/ E<=A F^E FUE=I A<=I)
    <- leq-transitive E<=C C<=A E<=A
    <- union-total BUH=I
    <- union-associative-converse* DUE=H BUH=I BUD=F FUE=I
    <- leq-reflexive B B<=B
    <- disjoint-respects-geq B^C B<=B E<=C B^E
    <- union-preserves-disjoint* B^E D^E BUD=F F^E
    <- union-left-preserves-leq* C<=H BUC=G BUH=I G<=I
    <- leq-transitive A<=G G<=I A<=I.

%worlds () (remove-associates-union* _ _ _ _).
%total { } (remove-associates-union* _ _ _ _).


%theorem remove-associates-union :
	forall*	{A} {B} {C} {D} {E}
	forall	{R1: remove A B C}
		{R2: remove C D E}
	exists	{F}
		{U: union B D F}
		{R3: remove A F E}
	true.

- : remove-associates-union A-B=C C-D=E F BUD=F A-F=E
    <- union-total BUD=F
    <- remove-associates-union* A-B=C C-D=E BUD=F A-F=E.

%worlds () (remove-associates-union _ _ _ _ _).
%total { } (remove-associates-union _ _ _ _ _).


%theorem remove-associates-union-converse* :
	forall*	{A} {B} {C} {D} {E} {F}
	forall	{U: union B D F}
		{R3: remove A F E}
		{R1: remove A B C}
	exists	{R2: remove C D E}
	true.

- : remove-associates-union-converse* BUD=F A-F=E A-B=C C-D=E
    <- remove-total C-D=EP
    <- remove-associates-union* A-B=C C-D=EP BUD=F A-F=EP
    <- remove-unique A-F=EP A-F=E eq/ eq/ EP=E
    <- remove-respects-eq C-D=EP eq/ eq/ EP=E C-D=E.

%worlds () (remove-associates-union-converse* _ _ _ _).
%total { } (remove-associates-union-converse* _ _ _ _).


%theorem remove-associates-union-converse :
	forall*	{A} {B} {D} {E} {F}
	forall	{U: union B D F}
		{R3: remove A F E}
	exists	{C}
		{R1: remove A B C}
		{R2: remove C D E}
	true.

- : remove-associates-union-converse BUD=F A-F=E C A-B=C C-D=E
    <- remove-total A-B=C
    <- remove-associates-union-converse* BUD=F A-F=E A-B=C C-D=E.

%worlds () (remove-associates-union-converse _ _ _ _ _).
%total { } (remove-associates-union-converse _ _ _ _ _).


%theorem remove-reorders* :
	forall*	{A} {B} {C} {D} {E} {F}
	forall	{R1: remove A B C}
		{R2: remove C D E}
		{R3: remove A D F}
	exists	{R4: remove F B E}
	true.

- : remove-reorders* A-B=C C-D=E A-D=G G-B=E
    <- remove-associates-union A-B=C C-D=E F BUD=F A-F=E
    <- union-commutative BUD=F DUB=F
    <- remove-associates-union-converse* DUB=F A-F=E A-D=G G-B=E.

%worlds () (remove-reorders* _ _ _ _).
%total { } (remove-reorders* _ _ _ _).


%theorem remove-reorders :
	forall*	{A} {B} {C} {D} {E}
	forall	{R1: remove A B C}
		{R2: remove C D E}
	exists	{F}
		{R3: remove A D F}
		{R4: remove F B E}
	true.

- : remove-reorders A-B=C C-D=E G A-D=G G-B=E
    <- remove-total A-D=G
    <- remove-reorders* A-B=C C-D=E A-D=G G-B=E.

%worlds () (remove-reorders _ _ _ _ _).
%total { } (remove-reorders _ _ _ _ _).


%theorem disjoint-implies-remove-nothing :
	forall* {A} {B}
	forall	{D: disjoint A B}
	exists	{R: remove A B A}
	true.

- : disjoint-implies-remove-nothing A^B A-B=A
    <- leq-reflexive A A<=A
    <- union-total* B A C BUA=C
    <- union-implies-leq BUA=C B<=C A<=C
    <- disjoint-symmetric A^B B^A
    <- remove-characterization A<=A B^A BUA=C A<=C A-B=A.

%worlds () (disjoint-implies-remove-nothing _ _).
%total { } (disjoint-implies-remove-nothing _ _).


%theorem remove-subset-implies-union :
	forall*	{A} {B} {C}
	forall	{R: remove A B C}
		{L: leq B A}
	exists	{U: union B C A}
	true.

- : remove-subset-implies-union A-B=C B<=A BUC=A
    <- remove-implies-leq A-B=C C<=A
    <- union-total* B C AX BUC=AX
    <- remove-implies-leq-union A-B=C BUC=AX A<=AX
    <- union-is-lub BUC=AX B<=A C<=A AX<=A
    <- leq-anti-symmetric AX<=A A<=AX AX=A
    <- union-respects-eq BUC=AX eq/ eq/ AX=A BUC=A.

%worlds () (remove-subset-implies-union _ _ _).
%total { } (remove-subset-implies-union _ _ _).


%theorem union-right-commutes-remove* :
	forall*	{A} {B} {C} {D} {E} {F} {G}
	forall	{R: remove A B C}
		{U1: union A G D}
		{R2: remove B G E}
		{U3: union C G F}
	exists	{EP: remove D E F}
	true.

- : union-right-commutes-remove* A-B=C AUG=D B-G=E CUG=F D-E=F
    <- remove-implies-leq A-B=C C<=A
    <- union-implies-leq AUG=D A<=D G<=D
    <- leq-transitive C<=A A<=D C<=D
    <- union-is-lub CUG=F C<=D G<=D F<=D
    <- remove-implies-disjoint B-G=E G^E
    <- remove-implies-disjoint A-B=C B^C
    <- remove-implies-leq B-G=E E<=B
    <- disjoint-respects-geq* B^C E<=B E^C
    <- disjoint-symmetric E^C C^E
    <- union-preserves-disjoint* C^E G^E CUG=F F^E
    <- disjoint-symmetric F^E E^F
    <- union-total* B C I BUC=I
    <- union-total* E F H EUF=H
    <- union-commutative EUF=H FUE=H
    <- union-associative CUG=F FUE=H J GUE=J CUJ=H
    <- union-implies-leq GUE=J G<=J E<=J
    <- union-implies-leq CUJ=H C<=H J<=H
    <- remove-implies-leq-union A-B=C BUC=I A<=I 
    <- remove-implies-leq-union B-G=E GUE=J B<=J
    <- leq-transitive B<=J J<=H B<=H
    <- leq-transitive G<=J J<=H G<=H
    <- union-is-lub BUC=I B<=H C<=H I<=H
    <- leq-transitive A<=I I<=H A<=H
    <- union-is-lub AUG=D A<=H G<=H D<=H
    <- remove-characterization F<=D E^F EUF=H D<=H D-E=F.
	
%worlds () (union-right-commutes-remove* _ _ _ _ _).
%total { } (union-right-commutes-remove* _ _ _ _ _).


%theorem union-right-commutes-remove :
	forall*	{A} {B} {C} {G}
	forall	{R: remove A B C}
	exists	{D} {E} {F}
		{U1: union A G D}
		{R2: remove B G E}
		{U3: union C G F}
		{EP: remove D E F}
	true.

- : union-right-commutes-remove A-B=C D E F AUG=D B-G=E CUG=F D-E=F
    <- union-total AUG=D
    <- remove-total B-G=E
    <- union-total CUG=F
    <- union-right-commutes-remove* A-B=C AUG=D B-G=E CUG=F D-E=F.

%worlds () (union-right-commutes-remove _ _ _ _ _ _ _ _).
%total { } (union-right-commutes-remove _ _ _ _ _ _ _ _).


%theorem union-right-preserves-remove :
	forall*	{A} {B} {C} {D} {G}
	forall	{R: remove A B C}
		{U1: union A G D}
		{R2: leq G B}
	exists	{EP: remove D B C}
	true.

- : union-right-preserves-remove A-B=C AUG=D G<=B D-B=C
    <- union-total* B C E BUC=E
    <- remove-implies-leq A-B=C C<=A
    <- remove-implies-leq-union A-B=C BUC=E A<=E
    <- remove-implies-disjoint A-B=C B^C
    <- union-implies-leq AUG=D A<=D G<=D
    <- union-implies-leq BUC=E B<=E C<=E
    <- leq-transitive C<=A A<=D C<=D
    <- leq-transitive G<=B B<=E G<=E
    <- union-is-lub AUG=D A<=E G<=E D<=E
    <- remove-characterization C<=D B^C BUC=E D<=E D-B=C.

%worlds () (union-right-preserves-remove _ _ _ _).
%total { } (union-right-preserves-remove _ _ _ _).


%theorem remove-right-distributes-over-union* :
	forall*	{A} {B} {C} {D} {E} {F} {G}
	forall	{U: union A B C}
		{R: remove C D E}
		{RA: remove A D F}
		{RB: remove B D G}
	exists	{U: union F G E}
	true.

%theorem remove-right-distributes-over-union/L :
	forall*	{A} {B} {C} {D} {E} {F} {G} {B?} {EP}
	forall	{U: union A B C}
		{R: remove C D E}
		{RA: remove A D F}
		{RB: remove B D G}
		{U: union F G EP}
		{E?: eq? EP E B?}
	exists	{E: eq EP E}
	true.

- : remove-right-distributes-over-union/L _ _ _ _ _ eq?/yes eq/.

- : remove-right-distributes-over-union/L AUB=C
	(remove/ E<=C D^E DUE=H C<=H)
	(remove/ F<=A D^F DUF=I A<=I)
	(remove/ G<=B D^G DUG=J B<=J) FUG=EP
	(ne/> X</-EP X<-E) EQ
    <- union-preserves-not-member-converse* X</-EP FUG=EP X</-F X</-G
    <- member-respects-leq X<-E E<=C X<-C
    <- disjoint-symmetric D^E E^D
    <- disjoint-member-implies-not-member X<-E E^D X</-D
    <- union-preserves-not-member* X</-D X</-F DUF=I X</-I
    <- union-preserves-not-member* X</-D X</-G DUG=J X</-J
    <- not-member-respects-geq X</-I A<=I X</-A
    <- not-member-respects-geq X</-J B<=J X</-B
    <- union-preserves-not-member* X</-A X</-B AUB=C X</-C
    <- member-not-member-contradiction X<-C X</-C FALSE
    <- false-implies-eq FALSE EQ.

%theorem remove-right-distributes-over-union/L/< :
	forall*	{A} {B} {C} {D} {E} {F} {G} {X} {FB} {EP}
	forall	{U: union A B C}
		{R: remove C D E}
		{RA: remove A D F}
		{RB: remove B D G}
		{U: union F G EP}
		{M: member EP X}
		{FM?: member? F X FB}
	exists	{EM: member E X}
	true.

- : remove-right-distributes-over-union/L/< AUB=C
	(remove/ E<=C D^E DUE=H C<=H)
	(remove/ F<=A D^F DUF=I A<=I)
	(remove/ G<=B D^G DUG=J B<=J) FUG=EP X<-EP 
	(member?/in X<-F) X<-E
    <- member-respects-leq X<-F F<=A X<-A
    <- union-right-preserves-member* X<-A AUB=C X<-C
    <- member-respects-leq X<-C C<=H X<-H
    <- disjoint-symmetric D^F F^D
    <- disjoint-member-implies-not-member X<-F F^D X</-D
    <- not-member-union-left-preserves-member-converse X</-D X<-H DUE=H X<-E.

- : remove-right-distributes-over-union/L/< AUB=C
	(remove/ E<=C D^E DUE=H C<=H)
	(remove/ F<=A D^F DUF=I A<=I)
	(remove/ G<=B D^G DUG=J B<=J) FUG=EP X<-EP 
	(member?/out X</-F) X<-E
    <- not-member-union-left-preserves-member-converse X</-F X<-EP FUG=EP X<-G
    <- member-respects-leq X<-G G<=B X<-B
    <- union-left-preserves-member* X<-B AUB=C X<-C
    <- member-respects-leq X<-C C<=H X<-H
    <- disjoint-symmetric D^G G^D
    <- disjoint-member-implies-not-member X<-G G^D X</-D
    <- not-member-union-left-preserves-member-converse X</-D X<-H DUE=H X<-E.

%worlds () (remove-right-distributes-over-union/L/< _ _ _ _ _ _ _ _).
%total { } (remove-right-distributes-over-union/L/< _ _ _ _ _ _ _ _).

- : remove-right-distributes-over-union/L AUB=C C-D=E A-D=F B-D=G FUG=EP
	(ne/< X<-EP X</-E) EQ
    <- member?-total M?
    <- remove-right-distributes-over-union/L/<
	AUB=C C-D=E A-D=F B-D=G FUG=EP X<-EP M? X<-E
    <- member-not-member-contradiction X<-E X</-E FALSE
    <- false-implies-eq FALSE EQ.

%worlds () (remove-right-distributes-over-union/L _ _ _ _ _ _ _).
%total { } (remove-right-distributes-over-union/L _ _ _ _ _ _ _).

- : remove-right-distributes-over-union* U1 R1 R2 R3 U2
    <- union-total U2P
    <- eq?-total EQ?
    <- remove-right-distributes-over-union/L U1 R1 R2 R3 U2P EQ? EQ
    <- union-respects-eq U2P eq/ eq/ EQ U2.

%worlds () (remove-right-distributes-over-union* _ _ _ _ _).
%total { } (remove-right-distributes-over-union* _ _ _ _ _).


%theorem remove-right-distributes-over-union :
	forall*	{A} {B} {C} {D} {E}
	forall	{U: union A B C}
		{R: remove C D E}
	exists	{F} {G}
		{RA: remove A D F}
		{RB: remove B D G}
		{U: union F G E}
	true.

- : remove-right-distributes-over-union U R1 _ _ R2 R3 UP
    <- remove-total R2
    <- remove-total R3
    <- remove-right-distributes-over-union* U R1 R2 R3 UP.

%worlds () (remove-right-distributes-over-union _ _ _ _ _ _ _).
%total { } (remove-right-distributes-over-union _ _ _ _ _ _ _).


%theorem remove-right-preserves-leq :
	forall*	{A} {B} {C} {D} {E}
	forall	{L: leq A D}
		{R: remove A B C}
		{RP: remove D B E}
	exists	{LP: leq C E}
	true.

- : remove-right-preserves-leq A<=D A-B=C D-B=E C<=E
    <- remove-implies-leq A-B=C C<=A
    <- leq-transitive C<=A A<=D C<=D
    <- union-total* B E F BUE=F
    <- remove-implies-leq-union D-B=E BUE=F D<=F
    <- leq-transitive C<=D D<=F C<=F
    <- remove-implies-disjoint A-B=C B^C
    <- disjoint-symmetric B^C C^B
    <- leq-union-disjoint-implies-leq C<=F BUE=F C^B C<=E.

%worlds () (remove-right-preserves-leq _ _ _ _).
%total { } (remove-right-preserves-leq _ _ _ _).


%theorem remove-left-inverts-leq :
        forall* {A} {B} {C} {D} {E}
        forall  {L: leq B D}
                {R1: remove A B C}
                {R2: remove A D E}
        exists  {LP: leq E C}
        true.

%theorem remove-left-inverts-leq/L :
        forall* {A} {B} {C} {D} {E} {X}
        forall  {L: leq B D}
                {R1: remove A B C}
                {R2: remove A D E}
                {L?: leq? E C X}
        exists  {LP: leq E C}
        true.

- : remove-left-inverts-leq/L _ _ _ L L.

- : remove-left-inverts-leq/L B<=D A-B=C A-D=E (nle/< X<-E X/<-C) L
    <- remove-implies-leq A-D=E E<=A
    <- member-respects-leq X<-E E<=A X<-A
    <- remove-implies-disjoint A-D=E D^E
    <- disjoint-symmetric D^E E^D
    <- disjoint-member-implies-not-member X<-E E^D X/<-D
    <- not-member-respects-geq X/<-D B<=D X/<-B
    <- remove-preserves-member X<-A A-B=C X/<-B X<-C
    <- member-not-member-contradiction X<-C X/<-C F
    <- false-implies-leq F L.

%worlds () (remove-left-inverts-leq/L _ _ _ _ _).
%total { } (remove-left-inverts-leq/L _ _ _ _ _).

- : remove-left-inverts-leq B<=D A-B=C A-D=E E<=C
    <- leq?-total E<=C?
    <- remove-left-inverts-leq/L B<=D A-B=C A-D=E E<=C? E<=C.

%worlds () (remove-left-inverts-leq _ _ _ _).
%total { } (remove-left-inverts-leq _ _ _ _).


%theorem remove-right-preserves-disjoint :
	forall*	{A} {B} {C} {D} {E}
	forall	{L: disjoint A D}
		{R: remove A B C}
		{RP: remove D B E}
	exists	{LP: disjoint C E}
	true.

- : remove-right-preserves-disjoint A^D A-B=C D-B=E C^E
    <- remove-implies-leq A-B=C C<=A
    <- remove-implies-leq D-B=E E<=D
    <- disjoint-respects-geq A^D C<=A E<=D C^E.

%worlds () (remove-right-preserves-disjoint _ _ _ _).
%total { } (remove-right-preserves-disjoint _ _ _ _).


%theorem remove-right-distributes-over-intersection* :
	forall*	{A} {B} {C} {D} {E} {F} {G}
	forall	{U: intersection A B C}
		{R: remove C D E}
		{RA: remove A D F}
		{RB: remove B D G}
	exists	{U: intersection F G E}
	true.

%theorem remove-right-distributes-over-intersection/L :
	forall*	{A} {B} {C} {D} {E} {F} {G} {X} {Y} {B?}
	forall	{U: intersection A B C}
		{R: remove C D E}
		{RA: remove A D F}
		{RB: remove B D G}
		{RF: remove F E X}
		{RG: remove G E Y}
		{D?: disjoint? X Y B?}
	exists	{D: disjoint X Y}
	true.

- : remove-right-distributes-over-intersection/L _ _ _ _ _ _ 
	(disjoint?/yes D) D.

- : remove-right-distributes-over-intersection/L
	A^B=C C-D=E A-D=F B-D=G F-E=X G-E=Y (disjoint?/no XM YM) X^Y
    <- remove-implies-disjoint F-E=X E^X
    <- disjoint-symmetric E^X X^E
    <- disjoint-member-implies-not-member XM X^E ENM
    <- remove-implies-leq F-E=X X<=F
    <- remove-implies-leq G-E=Y Y<=G
    <- member-respects-leq XM X<=F FM
    <- member-respects-leq YM Y<=G GM
    <- remove-implies-disjoint A-D=F D^F
    <- disjoint-symmetric D^F F^D
    <- disjoint-member-implies-not-member FM F^D DNM
    <- union-total* D E H DUE=H
    <- union-preserves-not-member* DNM ENM DUE=H HNM
    <- remove-implies-leq-union C-D=E DUE=H C<=H
    <- not-member-respects-geq HNM C<=H CNM
    <- remove-implies-leq A-D=F F<=A
    <- remove-implies-leq B-D=G G<=B
    <- member-respects-leq FM F<=A AM
    <- member-respects-leq GM G<=B BM
    <- intersection-preserves-member AM BM A^B=C CM
    <- member-not-member-contradiction CM CNM FALSE
    <- false-implies-disjoint FALSE X^Y.
		
%worlds () (remove-right-distributes-over-intersection/L _ _ _ _ _ _ _ _).
%total { } (remove-right-distributes-over-intersection/L _ _ _ _ _ _ _ _).

- : remove-right-distributes-over-intersection* A^B=C C-D=E A-D=F B-D=G F^G=E
    <- intersection-implies-leq A^B=C C<=A C<=B
    <- remove-right-preserves-leq C<=A C-D=E A-D=F E<=F
    <- remove-right-preserves-leq C<=B C-D=E B-D=G E<=G
    <- remove-total* F E X F-E=X
    <- remove-total* G E Y G-E=Y 
    <- remove-subset-implies-union F-E=X E<=F EUX=F
    <- remove-subset-implies-union G-E=Y E<=G EUY=G
    <- disjoint?-total X^Y?
    <- remove-right-distributes-over-intersection/L 
	A^B=C C-D=E A-D=F B-D=G F-E=X G-E=Y X^Y? X^Y
    <- intersection-characterization EUX=F EUY=G X^Y F^G=E.

%worlds () (remove-right-distributes-over-intersection* _ _ _ _ _).
%total { } (remove-right-distributes-over-intersection* _ _ _ _ _).


%theorem remove-right-distributes-over-intersection :
	forall*	{A} {B} {C} {D} {E}
	forall	{U: intersection A B C}
		{R: remove C D E}
	exists	{F} {G}
		{RA: remove A D F}
		{RB: remove B D G}
		{U: intersection F G E}
	true.

- : remove-right-distributes-over-intersection U R _ _ RA RB UP
    <- remove-total RA
    <- remove-total RB
    <- remove-right-distributes-over-intersection* U R RA RB UP.

%worlds () (remove-right-distributes-over-intersection _ _ _ _ _ _ _).
%total { } (remove-right-distributes-over-intersection _ _ _ _ _ _ _).


%theorem not-member-add-implies-remove :
	forall*	{A} {N} {B}
	forall	{NM: not-member A N}
		{AD: add A N B}
	exists	{R: remove B (set/1 N) A}
	true.

- : not-member-add-implies-remove NM A+N=B SR
    <- not-member-update-implies-unit-union NM A+N=B AUN=B
    <- union-commutative AUN=B NUA=B
    <- union-implies-leq NUA=B _ A<=B
    <- not-member-implies-unit-disjoint NM A^N
    <- disjoint-symmetric A^N N^A
    <- leq-reflexive B B<=B
    <- remove-characterization A<=B N^A NUA=B B<=B SR.

%worlds () (not-member-add-implies-remove _ _ _).
%total { } (not-member-add-implies-remove _ _ _).


%theorem remove-idempotent :
	forall*	{A} {B} {C}
	forall	{R:remove A B C}
	exists	{R:remove C B C}
	true.

- : remove-idempotent A-B=C C-B=C
    <- remove-implies-disjoint A-B=C B^C
    <- disjoint-symmetric B^C C^B
    <- disjoint-implies-remove-nothing C^B C-B=C.

%worlds () (remove-idempotent _ _).
%total { } (remove-idempotent _ _).


%theorem remove-preserves-max :
	forall* {A} {B} {C} {M}
	forall	{D: bound A (s M)}
		{R: remove A B C}
		{N: not-member B M}
	exists	{DP: bound C (s M)}
	true.

%theorem remove-preserves-max/L :
	forall* {A} {B} {C} {M} {MP}
	forall	{D: bound A (s M)}
		{R: remove A B C}
		{N: not-member B M}
		{DX: bound C MP}
	exists	{DP: bound C (s M)}
	true.

- : remove-preserves-max/L MAXA=M A-B=0 B-/>M bound/0 DP
    <- remove-all-implies-leq A-B=0 A<=B
    <- max-implies-member MAXA=M A->M
    <- member-respects-leq A->M A<=B B->M
    <- member-not-member-contradiction B->M B-/>M F
    <- false-implies-bound F DP.

- : remove-preserves-max/L MAXA=M A-B=C B-/>M MAXC=MP DP
    <- max-implies-member MAXA=M A->M
    <- remove-preserves-member A->M A-B=C B-/>M C->M
    <- max-implies-member MAXC=MP C->MP
    <- remove-preserves-member-converse C->MP A-B=C A->MP
    <- max-member-implies-ge MAXA=M A->MP M>=MP
    <- max-member-implies-ge MAXC=MP C->M MP>=M
    <- ge-anti-symmetric MP>=M M>=MP MP=M
    <- succ-preserves-eq MP=M MP+1=M+1
    <- bound-respects-eq MAXC=MP eq/ MP+1=M+1 DP.

%worlds () (remove-preserves-max/L _ _ _ _ _).
%total { } (remove-preserves-max/L _ _ _ _ _).

- : remove-preserves-max MAX1 R NM MAX2
    <- bound-total B2
    <- remove-preserves-max/L MAX1 R NM B2 MAX2.

%worlds () (remove-preserves-max _ _ _ _).
%total { } (remove-preserves-max _ _ _ _).





%%%% Exports



%abbrev set`map = map.
%abbrev set`map/0 = map/0.
%abbrev set`map/+ = map/+.
%abbrev set`map/1 = map/1.
%abbrev set`eq? = eq?.
%abbrev set`eq = eq.
%abbrev set`ne = ne.
%abbrev set`eq?/yes = eq?/yes.
%abbrev set`eq/ = eq/.
%abbrev set`eq?/no = eq?/no.
%abbrev set`lookup = lookup.
%abbrev set`lookup/= = lookup/=.
%abbrev set`lookup/> = lookup/>.
%abbrev set`not-member = not-member.
%abbrev set`not-member/0 = not-member/0.
%abbrev set`not-member/< = not-member/<.
%abbrev set`not-member/> = not-member/>.
%abbrev set`ne/< = ne/<.
%abbrev set`ne/> = ne/>.
%abbrev set`member? = member?.
%abbrev set`member?/in = member?/in.
%abbrev set`member?/out = member?/out.
%abbrev set`disjoint = disjoint.
%abbrev set`disjoint/L = disjoint/L.
%abbrev set`disjoint/R = disjoint/R.
%abbrev set`disjoint/< = disjoint/<.
%abbrev set`disjoint/> = disjoint/>.
%abbrev set`disjoint? = disjoint?.
%abbrev set`disjoint?/yes = disjoint?/yes.
%abbrev set`disjoint?/no = disjoint?/no.
%abbrev set`size = size.
%abbrev set`size/0 = size/0.
%abbrev set`size/+ = size/+.
%abbrev set`bound = bound.
%abbrev set`bound/0 = bound/0.
%abbrev set`bound/+ = bound/+.
%abbrev set`shift = shift.
%abbrev set`shift/0 = shift/0.
%abbrev set`shift/+ = shift/+.
%abbrev set`update = update.
%abbrev set`update/0 = update/0.
%abbrev set`update/= = update/=.
%abbrev set`update/< = update/<.
%abbrev set`update/> = update/>.
%abbrev set`meta-eq = meta-eq.
%abbrev set`false-implies-eq? = false-implies-eq?.
%abbrev set`false-implies-eq = false-implies-eq.
%abbrev set`false-implies-ne = false-implies-ne.
%abbrev set`eq-reflexive = eq-reflexive.
%abbrev set`eq?-symmetric = eq?-symmetric.
%abbrev set`eq-symmetric = eq-symmetric.
%abbrev set`ne-symmetric = ne-symmetric.
%abbrev set`eq-transitive = eq-transitive.
%abbrev set`map/+-preserves-eq? = map/+-preserves-eq?.
%abbrev set`map/+-preserves-eq = map/+-preserves-eq.
%abbrev set`map/+-preserves-ne = map/+-preserves-ne.
%abbrev set`map/+-preserves-eq-converse = map/+-preserves-eq-converse.
%abbrev set`eq-no-occur = eq-no-occur.
%abbrev set`eq-contradiction = eq-contradiction.
%abbrev set`false-implies-lookup = false-implies-lookup.
%abbrev set`lookup-respects-eq = lookup-respects-eq.
%abbrev set`meta-reduces-lookup = meta-reduces-lookup.
%abbrev set`lookup/>-inversion = lookup/>-inversion.
%abbrev set`lookup-deterministic = lookup-deterministic.
%abbrev set`lookup-unique = lookup-unique.
%abbrev set`lookup-contradiction = lookup-contradiction.
%abbrev set`lookup-one-choice = lookup-one-choice.
%abbrev set`lookup-implies-ge = lookup-implies-ge.
%abbrev set`false-implies-not-member = false-implies-not-member.
%abbrev set`not-member-respects-eq = not-member-respects-eq.
%abbrev set`not-member/>-inversion = not-member/>-inversion.
%abbrev set`not-member-total* = not-member-total*.
%abbrev set`not-member-total = not-member-total.
%abbrev set`not-member-lookup-not-equal = not-member-lookup-not-equal.
%abbrev set`not-member-contradiction = not-member-contradiction.
%abbrev set`ne-implies-unit-map-not-member = ne-implies-unit-map-not-member.
%abbrev set`plus-right-preserves-not-member* = plus-right-preserves-not-member*.
%abbrev set`not-member-lookup-implies-ne = not-member-lookup-implies-ne.
%abbrev set`eq?-respects-eq = eq?-respects-eq.
%abbrev set`ne-respects-eq = ne-respects-eq.
%abbrev set`ne-anti-reflexive = ne-anti-reflexive.
%abbrev set`eq-ne-implies-false = eq-ne-implies-false.
%abbrev set`false-implies-member? = false-implies-member?.
%abbrev set`member?-respects-eq = member?-respects-eq.
%abbrev set`member?-deterministic = member?-deterministic.
%abbrev set`member?-unique = member?-unique.
%abbrev set`member?-total* = member?-total*.
%abbrev set`member?-map/+-total = member?-map/+-total.
%abbrev set`member?-map/+-complete = member?-map/+-complete.
%abbrev set`member?-total = member?-total.
%abbrev set`in-implies-lookup = in-implies-lookup.
%abbrev set`out-implies-not-member = out-implies-not-member.
%abbrev set`false-implies-disjoint = false-implies-disjoint.
%abbrev set`disjoint-respects-eq = disjoint-respects-eq.
%abbrev set`disjoint/=-contradiction = disjoint/=-contradiction.
%abbrev set`disjoint/<-inversion = disjoint/<-inversion.
%abbrev set`disjoint/>-inversion = disjoint/>-inversion.
%abbrev set`disjoint-anti-reflexive = disjoint-anti-reflexive.
%abbrev set`disjoint-symmetric = disjoint-symmetric.
%abbrev set`disjoint-lookup-contradiction = disjoint-lookup-contradiction.
%abbrev set`disjoint-lookup-implies-not-member = disjoint-lookup-implies-not-member.
%abbrev set`disjoint-lookup-implies-not-member/L = disjoint-lookup-implies-not-member/L.
%abbrev set`shift-left-preserves-disjoint = shift-left-preserves-disjoint.
%abbrev set`shift-left-preserves-disjoint-converse = shift-left-preserves-disjoint-converse.
%abbrev set`shift-right-preserves-disjoint = shift-right-preserves-disjoint.
%abbrev set`shift-right-preserves-disjoint-converse = shift-right-preserves-disjoint-converse.
%abbrev set`shift-preserves-disjoint = shift-preserves-disjoint.
%abbrev set`shift-preserves-disjoint-converse = shift-preserves-disjoint-converse.
%abbrev set`can-construct-unit-disjoint = can-construct-unit-disjoint.
%abbrev set`ne-implies-disjoint = ne-implies-disjoint.
%abbrev set`not-member-implies-unit-disjoint = not-member-implies-unit-disjoint.
%abbrev set`false-implies-size = false-implies-size.
%abbrev set`size-total* = size-total*.
%abbrev set`size-total = size-total.
%abbrev set`size-respects-eq = size-respects-eq.
%abbrev set`size-deterministic = size-deterministic.
%abbrev set`size-unique = size-unique.
%abbrev set`shift-preserves-size = shift-preserves-size.
%abbrev set`shift-preserves-size-converse = shift-preserves-size-converse.
%abbrev set`false-implies-bound = false-implies-bound.
%abbrev set`bound-respects-eq = bound-respects-eq.
%abbrev set`bound-unique = bound-unique.
%abbrev set`bound-deterministic = bound-deterministic.
%abbrev set`bound-total* = bound-total*.
%abbrev set`bound-total = bound-total.
%abbrev set`bound-lookup-implies-gt = bound-lookup-implies-gt.
%abbrev set`ge-bound-implies-not-member = ge-bound-implies-not-member.
%abbrev set`false-implies-shift = false-implies-shift.
%abbrev set`shift-respects-eq = shift-respects-eq.
%abbrev set`shift-total* = shift-total*.
%abbrev set`shift-total = shift-total.
%abbrev set`shift-deterministic = shift-deterministic.
%abbrev set`shift-unique = shift-unique.
%abbrev set`shift-cancels = shift-cancels.
%abbrev set`shifts-add = shifts-add.
%abbrev set`shifts-add-converse = shifts-add-converse.
%abbrev set`shift-preserves-not-member = shift-preserves-not-member.
%abbrev set`shift-preserves-not-member* = shift-preserves-not-member*.
%abbrev set`shift-preserves-not-member-converse* = shift-preserves-not-member-converse*.
%abbrev set`shift-preserves-lookup = shift-preserves-lookup.
%abbrev set`shift-preserves-lookup* = shift-preserves-lookup*.
%abbrev set`shift-preserves-lookup-converse = shift-preserves-lookup-converse.
%abbrev set`shift-preserves-lookup-converse* = shift-preserves-lookup-converse*.
%abbrev set`shift-implies-not-member* = shift-implies-not-member*.
%abbrev set`shift-implies-not-member = shift-implies-not-member.
%abbrev set`removal-preserves-not-member = removal-preserves-not-member.
%abbrev set`shift-preserves-size = shift-preserves-size.
%abbrev set`disjoint?-total* = disjoint?-total*.
%abbrev set`disjoint?-total*/+ = disjoint?-total*/+.
%abbrev set`disjoint?-total*/< = disjoint?-total*/<.
%abbrev set`disjoint?-total*/> = disjoint?-total*/>.
%abbrev set`disjoint?-total = disjoint?-total.
%abbrev set`false-implies-update = false-implies-update.
%abbrev set`update-respects-eq = update-respects-eq.
%abbrev set`meta-reduces-update = meta-reduces-update.
%abbrev set`update/=-inversion = update/=-inversion.
%abbrev set`update/<-inversion = update/<-inversion.
%abbrev set`update/>-inversion = update/>-inversion.
%abbrev set`update/>-inversion* = update/>-inversion*.
%abbrev set`update-contradiction = update-contradiction.
%abbrev set`update-deterministic = update-deterministic.
%abbrev set`update-unique = update-unique.
%abbrev set`update-total* = update-total*.
%abbrev set`update-map/+-total = update-map/+-total.
%abbrev set`update-total = update-total.
%abbrev set`lookup-implies-update = lookup-implies-update.
%abbrev set`lookup-implies-not-member-update = lookup-implies-not-member-update.
%abbrev set`update-implies-lookup = update-implies-lookup.
%abbrev set`update-preserves-lookup = update-preserves-lookup.
%abbrev set`update-preserves-lookup-converse = update-preserves-lookup-converse.
%abbrev set`update-preserves-not-member = update-preserves-not-member.
%abbrev set`update-preserves-not-member-converse = update-preserves-not-member-converse.
%abbrev set`update-preserves-not-member-converse-helper = update-preserves-not-member-converse-helper.
%abbrev set`update-is-cause-of-change = update-is-cause-of-change.
%abbrev set`update-is-cause-of-change/L = update-is-cause-of-change/L.
%abbrev set`update-preserves-membership = update-preserves-membership.
%abbrev set`update-preserves-membership-converse = update-preserves-membership-converse.
%abbrev set`lookup-update-preserves-membership = lookup-update-preserves-membership.
%abbrev set`lookup-update-preserves-membership/L = lookup-update-preserves-membership/L.
%abbrev set`lookup-update-preserves-membership-converse = lookup-update-preserves-membership-converse.
%abbrev set`update-preserves-in-member = update-preserves-in-member.
%abbrev set`update-preserves-in-member/L = update-preserves-in-member/L.
%abbrev set`shift-preserves-update = shift-preserves-update.
%abbrev set`shift-preserves-update* = shift-preserves-update*.
%abbrev set`shift-preserves-update-converse = shift-preserves-update-converse.
%abbrev set`shift-preserves-update-converse* = shift-preserves-update-converse*.
%abbrev set`update-commutes-shift-converse = update-commutes-shift-converse.
%abbrev set`update-commutes-shift-converse* = update-commutes-shift-converse*.
%abbrev set`not-member-update-preserves-lookup = not-member-update-preserves-lookup.
%abbrev set`not-member-update-increases-size = not-member-update-increases-size.
%abbrev set`not-member-update-increases-size-converse = not-member-update-increases-size-converse.
%abbrev set`not-member-update-preserves-disjoint = not-member-update-preserves-disjoint.
%abbrev set`not-member-update-preserves-disjoint/L = not-member-update-preserves-disjoint/L.
%abbrev set`update-preserves-disjoint-converse = update-preserves-disjoint-converse.
%abbrev set`update-preserves-disjoint-converse/L = update-preserves-disjoint-converse/L.
%abbrev set`update-preserves-bound = update-preserves-bound.
%abbrev set`update-preserves-bound-converse = update-preserves-bound-converse.
%abbrev set`update-overwrites = update-overwrites.
%abbrev set`update-overwrites-converse = update-overwrites-converse.
%abbrev set`update-may-have-no-effect = update-may-have-no-effect.
%abbrev set`update-idempotent = update-idempotent.
%abbrev set`update-commutes = update-commutes.
%abbrev set`update-commutes* = update-commutes*.
%abbrev set`not-member-update-cancels = not-member-update-cancels.
%abbrev set`update-commutes-converse = update-commutes-converse.
%abbrev set`update-commutes-converse/L = update-commutes-converse/L.
%abbrev set`not-member-update-commutes-converse* = not-member-update-commutes-converse*.
%abbrev set`can-remove = can-remove.
%abbrev set`can-remove* = can-remove*.
%abbrev set`shift-implies-update = shift-implies-update.
%abbrev set`not-member-update-implies-shift = not-member-update-implies-shift.
%abbrev set`leq? = leq?.
%abbrev set`leq = leq.
%abbrev set`nle = nle.
%abbrev set`leq/0 = leq/0.
%abbrev set`leq/= = leq/=.
%abbrev set`leq/> = leq/>.
%abbrev set`nle/< = nle/<.
%abbrev set`leq?/yes = leq?/yes.
%abbrev set`leq?/no = leq?/no.
%abbrev set`false-implies-leq? = false-implies-leq?.
%abbrev set`false-implies-leq = false-implies-leq.
%abbrev set`false-implies-nle = false-implies-nle.
%abbrev set`leq?-respects-eq = leq?-respects-eq.
%abbrev set`leq-respects-eq = leq-respects-eq.
%abbrev set`nle-respects-eq = nle-respects-eq.
%abbrev set`leq/0-inversion = leq/0-inversion.
%abbrev set`leq/=-inversion = leq/=-inversion.
%abbrev set`leq/>-inversion = leq/>-inversion.
%abbrev set`leq-contradiction = leq-contradiction.
%abbrev set`leq/<-contradiction = leq/<-contradiction.
%abbrev set`leq-reflexive = leq-reflexive.
%abbrev set`leq-anti-symmetric = leq-anti-symmetric.
%abbrev set`leq-transitive = leq-transitive.
%abbrev set`map/+-preserves-leq? = map/+-preserves-leq?.
%abbrev set`map/+-preserves-leq = map/+-preserves-leq.
%abbrev set`map/+-preserves-nle = map/+-preserves-nle.
%abbrev set`lookup-respects-leq = lookup-respects-leq.
%abbrev set`lookup-respects-leq* = lookup-respects-leq*.
%abbrev set`lookup-implies-unit-leq = lookup-implies-unit-leq.
%abbrev set`not-member-respects-geq = not-member-respects-geq.
%abbrev set`leq-implies-size-le = leq-implies-size-le.
%abbrev set`leq-implies-bound-le = leq-implies-bound-le.
%abbrev set`shift-left-preserves-leq* = shift-left-preserves-leq*.
%abbrev set`shift-preserves-leq* = shift-preserves-leq*.
%abbrev set`shift-preserves-leq = shift-preserves-leq.
%abbrev set`shift-preserves-leq-converse = shift-preserves-leq-converse.
%abbrev set`disjoint-respects-geq* = disjoint-respects-geq*.
%abbrev set`disjoint-respects-geq = disjoint-respects-geq.
%abbrev set`disjoint-leq-implies-empty = disjoint-leq-implies-empty.
%abbrev set`update-left-preserves-leq* = update-left-preserves-leq*.
%abbrev set`update-right-preserves-leq* = update-right-preserves-leq*.
%abbrev set`update-preserves-leq* = update-preserves-leq*.
%abbrev set`not-member-update-preserves-leq-converse = not-member-update-preserves-leq-converse.
%abbrev set`not-member-update-preserves-leq-converse/> = not-member-update-preserves-leq-converse/>.
%abbrev set`not-member-update2-preserves-leq-converse = not-member-update2-preserves-leq-converse.
%abbrev set`not-member-update-implies-leq = not-member-update-implies-leq.
%abbrev set`lookup-update-preserves-leq = lookup-update-preserves-leq.
%abbrev set`nle-anti-reflexive = nle-anti-reflexive.
%abbrev set`nle-implies-ne = nle-implies-ne.
%abbrev set`leq-nle-contradiction = leq-nle-contradiction.
%abbrev set`union = union.
%abbrev set`union/L = union/L.
%abbrev set`union/R = union/R.
%abbrev set`union/= = union/=.
%abbrev set`union/< = union/<.
%abbrev set`union/> = union/>.
%abbrev set`false-implies-union = false-implies-union.
%abbrev set`union-respects-eq = union-respects-eq.
%abbrev set`can-construct-unit-union = can-construct-unit-union.
%abbrev set`union/=-inversion = union/=-inversion.
%abbrev set`union/<-inversion = union/<-inversion.
%abbrev set`union/>-inversion = union/>-inversion.
%abbrev set`false-implies-union-reduces = false-implies-union-reduces.
%abbrev set`union/<-inversion* = union/<-inversion*.
%abbrev set`union/>-inversion* = union/>-inversion*.
%abbrev set`union-deterministic = union-deterministic.
%abbrev set`union-unique = union-unique.
%abbrev set`union-total* = union-total*.
%abbrev set`union-map/+-M-total* = union-map/+-M-total*.
%abbrev set`union-M-map/+-total* = union-M-map/+-total*.
%abbrev set`union-map/+-map/+-total* = union-map/+-map/+-total*.
%abbrev set`union-total = union-total.
%abbrev set`disjoint-union-total = disjoint-union-total.
%abbrev set`disjoint-union-commutative = disjoint-union-commutative.
%abbrev set`union-empty-implies-empty = union-empty-implies-empty.
%abbrev set`union-preserves-disjoint* = union-preserves-disjoint*.
%abbrev set`union-preserves-disjoint*/L = union-preserves-disjoint*/L.
%abbrev set`union-left-preserves-disjoint* = union-left-preserves-disjoint*.
%abbrev set`union-right-preserves-disjoint* = union-right-preserves-disjoint*.
%abbrev set`union-preserves-disjoint-converse = union-preserves-disjoint-converse.
%abbrev set`disjoint-union-right-cancels = disjoint-union-right-cancels.
%abbrev set`disjoint-union-right-cancels/L = disjoint-union-right-cancels/L.
%abbrev set`disjoint-union-left-cancels = disjoint-union-left-cancels.
%abbrev set`shift-left-preserves-union = shift-left-preserves-union.
%abbrev set`shift-left-preserves-union-converse = shift-left-preserves-union-converse.
%abbrev set`shift-right-preserves-union = shift-right-preserves-union.
%abbrev set`shift-right-preserves-union-converse = shift-right-preserves-union-converse.
%abbrev set`shift-preserves-union* = shift-preserves-union*.
%abbrev set`shift-preserves-union = shift-preserves-union.
%abbrev set`shift-preserves-union-converse = shift-preserves-union-converse.
%abbrev set`shift-preserves-union-converse* = shift-preserves-union-converse*.
%abbrev set`shift-preserves-union-converse** = shift-preserves-union-converse**.
%abbrev set`union-commutative = union-commutative.
%abbrev set`union-associative = union-associative.
%abbrev set`union-associative-union/<-union/< = union-associative-union/<-union/<.
%abbrev set`union-associative* = union-associative*.
%abbrev set`union-associative-converse = union-associative-converse.
%abbrev set`union-associative-converse* = union-associative-converse*.
%abbrev set`union-assoc-commutative* = union-assoc-commutative*.
%abbrev set`union-assoc-commutative = union-assoc-commutative.
%abbrev set`union-double-associative* = union-double-associative*.
%abbrev set`union-double-associative = union-double-associative.
%abbrev set`lookup-implies-union = lookup-implies-union.
%abbrev set`union-joins-lookup = union-joins-lookup.
%abbrev set`union-joins-lookup* = union-joins-lookup*.
%abbrev set`union-commutes-lookup = union-commutes-lookup.
%abbrev set`union-preserves-not-member* = union-preserves-not-member*.
%abbrev set`not-member-union-left-preserves-lookup* = not-member-union-left-preserves-lookup*.
%abbrev set`not-member-union-left-preserves-lookup-converse = not-member-union-left-preserves-lookup-converse.
%abbrev set`not-member-union-left-preserves-lookup-converse/L = not-member-union-left-preserves-lookup-converse/L.
%abbrev set`union-left-affects-lookup = union-left-affects-lookup.
%abbrev set`union-left-affects-lookup/L = union-left-affects-lookup/L.
%abbrev set`not-member-union-right-preserves-lookup = not-member-union-right-preserves-lookup.
%abbrev set`not-member-union-right-preserves-lookup* = not-member-union-right-preserves-lookup*.
%abbrev set`not-member-union-right-preserves-lookup-converse = not-member-union-right-preserves-lookup-converse.
%abbrev set`not-member-union-right-preserves-lookup-converse/L = not-member-union-right-preserves-lookup-converse/L.
%abbrev set`union-right-affects-lookup = union-right-affects-lookup.
%abbrev set`union-right-affects-lookup/L = union-right-affects-lookup/L.
%abbrev set`union-preserves-not-member-converse* = union-preserves-not-member-converse*.
%abbrev set`union-preserves-not-member-converse/L = union-preserves-not-member-converse/L.
%abbrev set`disjoint-union-cross-comparable = disjoint-union-cross-comparable.
%abbrev set`disjoint-union-left-preserves-lookup* = disjoint-union-left-preserves-lookup*.
%abbrev set`disjoint-union-left-preserves-lookup*/L = disjoint-union-left-preserves-lookup*/L.
%abbrev set`disjoint-union-right-preserves-lookup* = disjoint-union-right-preserves-lookup*.
%abbrev set`disjoint-union-right-preserves-lookup*/L = disjoint-union-right-preserves-lookup*/L.
%abbrev set`not-member-update-implies-unit-union = not-member-update-implies-unit-union.
%abbrev set`lookup-update-left-implies-unit-union = lookup-update-left-implies-unit-union.
%abbrev set`lookup-update-right-implies-unit-union = lookup-update-right-implies-unit-union.
%abbrev set`not-member-unit-union-implies-update = not-member-unit-union-implies-update.
%abbrev set`union-commute-update-left* = union-commute-update-left*.
%abbrev set`union-commute-update-left = union-commute-update-left.
%abbrev set`union-commute-update-right* = union-commute-update-right*.
%abbrev set`union-commute-update-right = union-commute-update-right.
%abbrev set`union-commute-update* = union-commute-update*.
%abbrev set`union-commute-update = union-commute-update.
%abbrev set`union-preserves-not-member-update-left = union-preserves-not-member-update-left.
%abbrev set`not-member-update-left-preserves-union-converse = not-member-update-left-preserves-union-converse.
%abbrev set`not-member-update-left-preserves-union-converse/L = not-member-update-left-preserves-union-converse/L.
%abbrev set`not-member-update-left-preserves-union-converse* = not-member-update-left-preserves-union-converse*.
%abbrev set`not-member-update-right-preserves-union-converse = not-member-update-right-preserves-union-converse.
%abbrev set`not-member-update-right-preserves-union-converse/L = not-member-update-right-preserves-union-converse/L.
%abbrev set`not-member-update-right-preserves-union-converse* = not-member-update-right-preserves-union-converse*.
%abbrev set`not-member-update-preserves-union-converse = not-member-update-preserves-union-converse.
%abbrev set`not-member-update-preserves-union-converse/L = not-member-update-preserves-union-converse/L.
%abbrev set`false-implies-unit = false-implies-unit.
%abbrev set`unit-eq-symmetric = unit-eq-symmetric.
%abbrev set`not-member-update-preserves-union-converse* = not-member-update-preserves-union-converse*.
%abbrev set`bound-commute-union* = bound-commute-union*.
%abbrev set`size-commute-disjoint-union* = size-commute-disjoint-union*.
%abbrev set`union-implies-leq* = union-implies-leq*.
%abbrev set`union-implies-leq = union-implies-leq.
%abbrev set`union-is-lub = union-is-lub.
%abbrev set`union-idempotent = union-idempotent.
%abbrev set`leq-implies-union = leq-implies-union.
%abbrev set`disjoint-leq-implies-union-leq* = disjoint-leq-implies-union-leq*.
%abbrev set`union-left-preserves-leq* = union-left-preserves-leq*.
%abbrev set`union-left-preserves-leq = union-left-preserves-leq.
%abbrev set`union-right-preserves-leq* = union-right-preserves-leq*.
%abbrev set`union-right-preserves-leq = union-right-preserves-leq.
%abbrev set`union-preserves-leq* = union-preserves-leq*.
%abbrev set`union-preserves-leq = union-preserves-leq.
%abbrev set`disjoint-union-left-preserves-leq-converse = disjoint-union-left-preserves-leq-converse.
%abbrev set`disjoint-union-right-preserves-leq-converse = disjoint-union-right-preserves-leq-converse.
%abbrev set`intersection = intersection.
%abbrev set`intersection/L = intersection/L.
%abbrev set`intersection/R = intersection/R.
%abbrev set`intersection/= = intersection/=.
%abbrev set`intersection/< = intersection/<.
%abbrev set`intersection/> = intersection/>.
%abbrev set`false-implies-intersection = false-implies-intersection.
%abbrev set`intersection-respects-eq = intersection-respects-eq.
%abbrev set`intersection/L-inversion = intersection/L-inversion.
%abbrev set`intersection/R-inversion = intersection/R-inversion.
%abbrev set`intersection/=-inversion = intersection/=-inversion.
%abbrev set`intersection/<-inversion = intersection/<-inversion.
%abbrev set`intersection/>-inversion = intersection/>-inversion.
%abbrev set`intersection-implies-ge = intersection-implies-ge.
%abbrev set`intersection-empty-implies-disjoint = intersection-empty-implies-disjoint.
%abbrev set`intersection-deterministic = intersection-deterministic.
%abbrev set`intersection-unique = intersection-unique.
%abbrev set`intersection-total* = intersection-total*.
%abbrev set`intersection-map/+-M-total* = intersection-map/+-M-total*.
%abbrev set`intersection-M-map/+-total* = intersection-M-map/+-total*.
%abbrev set`intersection-map/+-map/+-total* = intersection-map/+-map/+-total*.
%abbrev set`intersection-total = intersection-total.
%abbrev set`disjoint-intersection-empty = disjoint-intersection-empty.
%abbrev set`intersection-commutative = intersection-commutative.
%abbrev set`shift-left-preserves-intersection = shift-left-preserves-intersection.
%abbrev set`shift-left-preserves-intersection-converse = shift-left-preserves-intersection-converse.
%abbrev set`shift-right-preserves-intersection = shift-right-preserves-intersection.
%abbrev set`shift-right-preserves-intersection-converse = shift-right-preserves-intersection-converse.
%abbrev set`shift-preserves-intersection* = shift-preserves-intersection*.
%abbrev set`shift-preserves-intersection-converse = shift-preserves-intersection-converse.
%abbrev set`intersection-associativeM = intersection-associativeM.
%abbrev set`intersection-associativeM* = intersection-associativeM*.
%abbrev set`intersection-associative = intersection-associative.
%abbrev set`intersection-associative* = intersection-associative*.
%abbrev set`intersection-associative-converse = intersection-associative-converse.
%abbrev set`intersection-associative-converse* = intersection-associative-converse*.
%abbrev set`intersection-assoc-commutative* = intersection-assoc-commutative*.
%abbrev set`intersection-assoc-commutative = intersection-assoc-commutative.
%abbrev set`intersection-double-associative* = intersection-double-associative*.
%abbrev set`intersection-double-associative = intersection-double-associative.
%abbrev set`intersection-meets-lookup = intersection-meets-lookup.
%abbrev set`intersection-meets-lookup-converse = intersection-meets-lookup-converse.
%abbrev set`intersection-meets-lookup-converse* = intersection-meets-lookup-converse*.
%abbrev set`intersection-meets-lookup* = intersection-meets-lookup*.
%abbrev set`intersection-right-preserves-not-member = intersection-right-preserves-not-member.
%abbrev set`intersection-right-preserves-not-member/L = intersection-right-preserves-not-member/L.
%abbrev set`intersection-left-preserves-not-member = intersection-left-preserves-not-member.
%abbrev set`intersection-left-preserves-not-member/L = intersection-left-preserves-not-member/L.
%abbrev set`intersection-implies-leq* = intersection-implies-leq*.
%abbrev set`intersection-implies-leq = intersection-implies-leq.
%abbrev set`intersection-is-glb = intersection-is-glb.
%abbrev set`intersection-idempotent = intersection-idempotent.
%abbrev set`leq-implies-intersection = leq-implies-intersection.
%abbrev set`intersection-left-preserves-leq* = intersection-left-preserves-leq*.
%abbrev set`intersection-right-preserves-leq* = intersection-right-preserves-leq*.
%abbrev set`intersection-right-distributes-over-union = intersection-right-distributes-over-union.
%abbrev set`intersection-right-distributes-over-union* = intersection-right-distributes-over-union*.
%abbrev set`intersection-left-distributes-over-union* = intersection-left-distributes-over-union*.
%abbrev set`intersection-left-distributes-over-union = intersection-left-distributes-over-union.
%abbrev set`intersection-right-factors-over-union* = intersection-right-factors-over-union*.
%abbrev set`intersection-left-factors-over-union* = intersection-left-factors-over-union*.
%abbrev set`max = max.
%abbrev set`min = min.
%abbrev set`min/+ = min/+.
%abbrev set`false-implies-max = false-implies-max.
%abbrev set`max-respects-eq = max-respects-eq.
%abbrev set`max-unique = max-unique.
%abbrev set`max-deterministic = max-deterministic.
%abbrev set`max-implies-lookup = max-implies-lookup.
%abbrev set`max-empty-contradiction = max-empty-contradiction.
%abbrev set`lookup-implies-max = lookup-implies-max.
%abbrev set`lookup-implies-max/L = lookup-implies-max/L.
%abbrev set`max-lookup-implies-ge = max-lookup-implies-ge.
%abbrev set`gt-max-implies-not-member = gt-max-implies-not-member.
%abbrev set`false-implies-min = false-implies-min.
%abbrev set`min-respects-eq = min-respects-eq.
%abbrev set`min/+-inversion = min/+-inversion.
%abbrev set`min-deterministic = min-deterministic.
%abbrev set`min-unique = min-unique.
%abbrev set`min-implies-lookup = min-implies-lookup.
%abbrev set`min-lookup-implies-ge = min-lookup-implies-ge.
%abbrev set`min-gt-implies-not-member = min-gt-implies-not-member.
%abbrev set`min-implies-max = min-implies-max.
%abbrev set`max-implies-min = max-implies-min.
%abbrev set`maxmin-implies-ge = maxmin-implies-ge.
%abbrev set`max-preserves-leq* = max-preserves-leq*.
%abbrev set`min-reverses-leq* = min-reverses-leq*.
%abbrev set`max-commute-union* = max-commute-union*.
%abbrev set`min-commute-union* = min-commute-union*.
%abbrev set`set = set.
%abbrev set`0 = 0.
%abbrev set`set/0 = set/0.
%abbrev set`set/+ = set/+.
%abbrev set`set/1 = set/1.
%abbrev set`set/+-preserves-eq = set/+-preserves-eq.
%abbrev set`set/+-preserves-leq = set/+-preserves-leq.
%abbrev set`member = member.
%abbrev set`member/1 = member/1.
%abbrev set`union/= = union/=.
%abbrev set`intersection/= = intersection/=.
%abbrev set`add = add.
%abbrev set`false-implies-member = false-implies-member.
%abbrev set`not-member-member-implies-ne = not-member-member-implies-ne.
%abbrev set`in-implies-member = in-implies-member.
%abbrev set`member-respects-eq = member-respects-eq.
%abbrev set`member-respects-leq = member-respects-leq.
%abbrev set`member-implies-unit-leq = member-implies-unit-leq.
%abbrev set`member-implies-ge = member-implies-ge.
%abbrev set`bound-member-implies-gt = bound-member-implies-gt.
%abbrev set`not-member-member-not-equal = not-member-member-not-equal.
%abbrev set`disjoint-member-contradiction = disjoint-member-contradiction.
%abbrev set`disjoint-member-implies-not-member = disjoint-member-implies-not-member.
%abbrev set`not-member-union-left-preserves-member-converse = not-member-union-left-preserves-member-converse.
%abbrev set`not-member-union-right-preserves-member-converse = not-member-union-right-preserves-member-converse.
%abbrev set`intersection-preserves-member = intersection-preserves-member.
%abbrev set`intersection-preserves-member-converse = intersection-preserves-member-converse.
%abbrev set`max-implies-member = max-implies-member.
%abbrev set`member-implies-max = member-implies-max.
%abbrev set`max-member-implies-ge = max-member-implies-ge.
%abbrev set`min-implies-member = min-implies-member.
%abbrev set`min-member-implies-ge = min-member-implies-ge.
%abbrev set`false-implies-add = false-implies-add.
%abbrev set`add-respects-eq = add-respects-eq.
%abbrev set`add-deterministic = add-deterministic.
%abbrev set`add-unique = add-unique.
%abbrev set`add-total* = add-total*.
%abbrev set`add-total = add-total.
%abbrev set`member-implies-add = member-implies-add.
%abbrev set`member-implies-not-member-add = member-implies-not-member-add.
%abbrev set`add-implies-member = add-implies-member.
%abbrev set`add-preserves-not-member = add-preserves-not-member.
%abbrev set`add-preserves-membership = add-preserves-membership.
%abbrev set`add-preserves-member-converse = add-preserves-member-converse.
%abbrev set`add-preserves-not-member-converse = add-preserves-not-member-converse.
%abbrev set`add-preserves-bound-converse = add-preserves-bound-converse.
%abbrev set`add-preserves-disjoint-converse = add-preserves-disjoint-converse.
%abbrev set`add-overwrites = add-overwrites.
%abbrev set`add-member-has-no-effect = add-member-has-no-effect.
%abbrev set`add-idempotent = add-idempotent.
%abbrev set`add-commutes = add-commutes.
%abbrev set`add-commutes* = add-commutes*.
%abbrev set`add-commutes-converse = add-commutes-converse.
%abbrev set`not-member-add-commutes-converse* = not-member-add-commutes-converse*.
%abbrev set`add-preserves-leq* = add-preserves-leq*.
%abbrev set`not-member-add-preserves-disjoint = not-member-add-preserves-disjoint.
%abbrev set`not-member-add-increases-size = not-member-add-increases-size.
%abbrev set`not-member-add-increases-size-converse = not-member-add-increases-size-converse.
%abbrev set`not-member-add-cancels = not-member-add-cancels.
%abbrev set`not-member-add-preserves-leq-converse = not-member-add-preserves-leq-converse.
%abbrev set`not-member-add2-preserves-leq-converse = not-member-add2-preserves-leq-converse.
%abbrev set`irrelevant-add-preserves-leq-converse = irrelevant-add-preserves-leq-converse.
%abbrev set`irrelevant-add-preserves-leq-converse/L = irrelevant-add-preserves-leq-converse/L.
%abbrev set`eq?-total* = eq?-total*.
%abbrev set`eq?-total = eq?-total.
%abbrev set`eq?-total/+ = eq?-total/+.
%abbrev set`leq?-total* = leq?-total*.
%abbrev set`leq?-total = leq?-total.
%abbrev set`leq?-total/+ = leq?-total/+.
%abbrev set`leq?-total/> = leq?-total/>.
%abbrev set`member-not-member-contradiction = member-not-member-contradiction.
%abbrev set`can-remove-member = can-remove-member.
%abbrev set`add-preserves-member = add-preserves-member.
%abbrev set`add-preserves-member/L = add-preserves-member/L.
%abbrev set`union-right-distributes-over-intersection = union-right-distributes-over-intersection.
%abbrev set`union-right-distributes-over-intersection* = union-right-distributes-over-intersection*.
%abbrev set`union-left-distributes-over-intersection* = union-left-distributes-over-intersection*.
%abbrev set`union-left-distributes-over-intersection = union-left-distributes-over-intersection.
%abbrev set`union-right-factors-over-intersection = union-right-factors-over-intersection.
%abbrev set`union-right-factors-over-intersection* = union-right-factors-over-intersection*.
%abbrev set`union-left-factors-over-intersection = union-left-factors-over-intersection.
%abbrev set`union-left-factors-over-intersection* = union-left-factors-over-intersection*.
%abbrev set`leq-union-implies-leq-intersection-union = leq-union-implies-leq-intersection-union.
%abbrev set`leq-union-disjoint-implies-leq = leq-union-disjoint-implies-leq.
%abbrev set`leq-intersection-disjoint-implies-disjoint = leq-intersection-disjoint-implies-disjoint.
%abbrev set`leq-intersection-disjoint-implies-disjoint/L = leq-intersection-disjoint-implies-disjoint/L.
%abbrev set`leq-size-eq-implies-eq = leq-size-eq-implies-eq.
%abbrev set`leq-size-eq-implies-eq/L = leq-size-eq-implies-eq/L.
%abbrev set`add-implies-unit-union = add-implies-unit-union.
%abbrev set`add-implies-unit-union/L = add-implies-unit-union/L.
%abbrev set`add-implies-leq = add-implies-leq.
%abbrev set`add-member-preserves-leq = add-member-preserves-leq.
%abbrev set`unit-union-implies-add = unit-union-implies-add.
%abbrev set`unit-union-implies-add/L = unit-union-implies-add/L.
%abbrev set`union-left-preserves-member* = union-left-preserves-member*.
%abbrev set`union-right-preserves-member* = union-right-preserves-member*.
%abbrev set`add-member-right-preserves-union = add-member-right-preserves-union.
%abbrev set`union-preserves-disjoint-converse = union-preserves-disjoint-converse.
%abbrev set`union-preserves-disjoint-converse/L = union-preserves-disjoint-converse/L.
%abbrev set`union-intersection-size = union-intersection-size.
%abbrev set`intersection-characterization = intersection-characterization.
%abbrev set`intersection-characterization/L = intersection-characterization/L.
%abbrev set`can-remove-min = can-remove-min.
%abbrev set`can-remove-max = can-remove-max.
%abbrev set`remove = remove.
%abbrev set`remove/ = remove/.
%abbrev set`false-implies-remove = false-implies-remove.
%abbrev set`remove-respects-eq = remove-respects-eq.
%abbrev set`remove-total* = remove-total*.
%abbrev set`remove-total = remove-total.
%abbrev set`remove-total/L1 = remove-total/L1.
%abbrev set`remove-total/L2 = remove-total/L2.
%abbrev set`remove-deterministic = remove-deterministic.
%abbrev set`remove-unique = remove-unique.
%abbrev set`remove-deterministic/L = remove-deterministic/L.
%abbrev set`shift-preserves-remove = shift-preserves-remove.
%abbrev set`remove-implies-leq = remove-implies-leq.
%abbrev set`remove-implies-leq-union = remove-implies-leq-union.
%abbrev set`remove-implies-disjoint = remove-implies-disjoint.
%abbrev set`remove-implies-empty-intersection = remove-implies-empty-intersection.
%abbrev set`leq-implies-remove-all = leq-implies-remove-all.
%abbrev set`remove-all-implies-leq = remove-all-implies-leq.
%abbrev set`remove-characterization = remove-characterization.
%abbrev set`disjoint-union-implies-remove = disjoint-union-implies-remove.
%abbrev set`remove-preserves-member = remove-preserves-member.
%abbrev set`remove-preserves-member-converse = remove-preserves-member-converse.
%abbrev set`remove-associates-union* = remove-associates-union*.
%abbrev set`remove-associates-union = remove-associates-union.
%abbrev set`remove-associates-union-converse* = remove-associates-union-converse*.
%abbrev set`remove-associates-union-converse = remove-associates-union-converse.
%abbrev set`remove-reorders* = remove-reorders*.
%abbrev set`remove-reorders = remove-reorders.
%abbrev set`disjoint-implies-remove-nothing = disjoint-implies-remove-nothing.
%abbrev set`remove-subset-implies-union = remove-subset-implies-union.
%abbrev set`union-right-commutes-remove* = union-right-commutes-remove*.
%abbrev set`union-right-commutes-remove = union-right-commutes-remove.
%abbrev set`union-right-preserves-remove = union-right-preserves-remove.
%abbrev set`remove-right-distributes-over-union* = remove-right-distributes-over-union*.
%abbrev set`remove-right-distributes-over-union/L = remove-right-distributes-over-union/L.
%abbrev set`remove-right-distributes-over-union/L/< = remove-right-distributes-over-union/L/<.
%abbrev set`remove-right-distributes-over-union = remove-right-distributes-over-union.
%abbrev set`remove-right-preserves-leq = remove-right-preserves-leq.
%abbrev set`remove-left-inverts-leq = remove-left-inverts-leq.
%abbrev set`remove-left-inverts-leq/L = remove-left-inverts-leq/L.
%abbrev set`remove-right-preserves-disjoint = remove-right-preserves-disjoint.
%abbrev set`remove-right-distributes-over-intersection* = remove-right-distributes-over-intersection*.
%abbrev set`remove-right-distributes-over-intersection/L = remove-right-distributes-over-intersection/L.
%abbrev set`remove-right-distributes-over-intersection = remove-right-distributes-over-intersection.
%abbrev set`not-member-add-implies-remove = not-member-add-implies-remove.
%abbrev set`remove-idempotent = remove-idempotent.
%abbrev set`remove-preserves-max = remove-preserves-max.
%abbrev set`remove-preserves-max/L = remove-preserves-max/L.
